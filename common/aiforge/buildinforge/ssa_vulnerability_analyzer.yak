# SSA 漏洞分析 Forge
# 根据 SSA Risk ID 生成详细的漏洞分析

# 获取参数
risk_id = cli.Int("risk_id", cli.setHelp("直接输入RiskID"))
additional_context = cli.String("additional_context", cli.setHelp("直接输入额外需要补充的提示词信息"))
cli.check()

# 在代码行中高亮问题位置的函数
func highlightProblemCodeInLines(lines, problemLine) {
    var result = []

    for i = 0; i < len(lines); i++ {
        lineNum = i + 1
        line = lines[i]

        # 在问题代码开始前添加标记
        if lineNum == problemLine {
            result = append(result, "// ⚠️ 问题代码开始 - 请重点关注以下代码\n")
        }

        # 如果是问题代码行，添加特殊标记
        if lineNum == problemLine {
            result = append(result, sprintf(">>> %s // ⚠️ 漏洞位置\n", line))
        } else {
            result = append(result, line)
            if i < len(lines) - 1 {
                result = append(result, "\n")
            }
        }

        # 在问题代码结束后添加标记
        if lineNum == problemLine {
            result = append(result, "// ⚠️ 问题代码结束\n")
        }
    }

    return str.Join(result, "")
}

# 构建漏洞分析提示词的函数
func buildVulnerabilityAnalysisPrompt(wrappedRisk, fullCode, fragment, hasFullCode, additionalContext) {
    var result = []

    result = append(result, "# 代码安全漏洞分析请求\n")
    result = append(result, "请作为一名资深的网络安全专家，分析以下代码安全漏洞，并提供详细的分析报告。\n\n")

    # 漏洞基本信息
    result = append(result, "## 漏洞基本信息\n")
    result = append(result, sprintf("- **漏洞标题**: %s\n", wrappedRisk.Title))
    result = append(result, sprintf("- **漏洞类型**: %s\n", wrappedRisk.RiskType))
    result = append(result, sprintf("- **严重程度**: %s\n", wrappedRisk.Severity))
    result = append(result, sprintf("- **项目名称**: %s\n", wrappedRisk.ProgramName))
    result = append(result, sprintf("- **函数名称**: %s\n", wrappedRisk.FunctionName))
    result = append(result, sprintf("- **代码行数**: %d\n", wrappedRisk.Line))
    result = append(result, sprintf("- **编程语言**: %s\n", wrappedRisk.Language))

    if wrappedRisk.CVE != "" {
        result = append(result, sprintf("- **CVE编号**: %s\n", wrappedRisk.CVE))
    }

    if len(wrappedRisk.CWE) > 0 {
        result = append(result, sprintf("- **CWE分类**: %s\n", str.Join(wrappedRisk.CWE, ", ")))
    }

    if wrappedRisk.RuleName != "" {
        result = append(result, sprintf("- **检测规则**: %s\n", wrappedRisk.RuleName))
    }

    # 漏洞描述
    result = append(result, "\n## 漏洞描述\n")
    result = append(result, wrappedRisk.Description)
    result = append(result, "\n\n")

    # 代码上下文
    if fullCode != "" {
        codeLines = str.Split(fullCode, "\n")
        shouldIncludeFullCode = len(fullCode) <= 10000 && len(codeLines) <= 500

        if shouldIncludeFullCode {
            result = append(result, "## 完整代码上下文\n")
            result = append(result, sprintf("```%s\n", str.ToLower(wrappedRisk.Language)))

            # 尝试高亮问题代码位置
            if wrappedRisk.Line > 0 && wrappedRisk.Line <= len(codeLines) {
                highlightedCode = highlightProblemCodeInLines(codeLines, wrappedRisk.Line)
                result = append(result, highlightedCode)
            } else {
                result = append(result, fullCode)
            }

            result = append(result, "\n```\n\n")
        } else {
            # 代码太长，显示文件信息
            result = append(result, "## 源代码文件信息\n")
            result = append(result, sprintf("- **文件路径**: %s\n", wrappedRisk.CodeSourceURL))
            result = append(result, sprintf("- **文件大小**: %d 字符\n", len(fullCode)))
            result = append(result, sprintf("- **总行数**: %d 行\n", len(codeLines)))
            result = append(result, sprintf("- **问题位置**: 第 %d 行\n", wrappedRisk.Line))
            result = append(result, "\n**注意**: 由于源代码文件过大，此处不显示完整内容，请重点关注下面的问题代码片段。\n\n")
        }
    }

    # 问题代码片段
    if fragment != "" && fragment != fullCode {
        result = append(result, "## 问题代码片段（重点关注）\n")
        result = append(result, sprintf("**位置**: 第 %d 行\n\n", wrappedRisk.Line))
        result = append(result, sprintf("```%s\n", str.ToLower(wrappedRisk.Language)))
        result = append(result, fragment)
        result = append(result, "\n```\n\n")
    }

    # 添加数据流路径信息
    if len(wrappedRisk.DataFlowPaths) > 0 {
        result = append(result, "## 数据流分析\n")
        for i, path := range wrappedRisk.DataFlowPaths {
            result = append(result, sprintf("### 数据流路径 %d\n", i+1))
            if path.Description != "" {
                result = append(result, sprintf("**描述**: %s\n\n", path.Description))
            }

            if len(path.Nodes) > 0 {
                result = append(result, "**数据流节点**:\n")
                for j, node := range path.Nodes {
                    result = append(result, sprintf("%d. **节点ID**: %s\n", j+1, node.NodeID))
                    if node.SourceCode != "" {
                        result = append(result, sprintf("   **源代码**: `%s`\n", node.SourceCode))
                    }
                    if node.IRCode != "" {
                        result = append(result, sprintf("   **IR代码**: `%s`\n", node.IRCode))
                    }
                    result = append(result, "\n")
                }
            }

            if len(path.Edges) > 0 {
                result = append(result, "**数据流边**:\n")
                for j, edge := range path.Edges {
                    result = append(result, sprintf("%d. **%s** → **%s** (%s)\n",
                        j+1, edge.FromNodeID, edge.ToNodeID, edge.EdgeType))
                    if edge.Description != "" {
                        result = append(result, sprintf("   **描述**: %s\n", edge.Description))
                    }
                    result = append(result, "\n")
                }
            }
        }
    }

    # 详细信息
    if wrappedRisk.Details != "" {
        result = append(result, "## 详细信息\n")
        result = append(result, wrappedRisk.Details)
        result = append(result, "\n\n")
    }

    # 额外上下文
    if additionalContext != "" {
        result = append(result, "## 额外上下文\n")
        result = append(result, additionalContext)
        result = append(result, "\n\n")
    }

    # 分析要求
    result = append(result, "## 分析要求\n")
    result = append(result, "请提供以下内容：\n")
    result = append(result, "1. **漏洞原理分析**: 详细解释漏洞的成因和机制\n")
    result = append(result, "2. **数据流分析**: 分析漏洞的数据传播过程\n")
    result = append(result, "3. **影响范围**: 说明漏洞可能造成的危害\n")
    result = append(result, "4. **利用场景**: 描述攻击者如何利用此漏洞\n")
    result = append(result, "5. **修复建议**: 提供具体的代码修复方案\n")
    result = append(result, "6. **防护措施**: 建议相应的安全防护措施\n")

    return str.Join(result, "")
}



if risk_id <= 0 {
    die(sprintf("无效的 Risk ID: %d", risk_id))
}

# 获取包含数据流信息的 SSA Risk 数据
wrappedRisk = risk.GetSSARiskWithDataFlow(risk_id)
if wrappedRisk == nil {
    die(sprintf("无法找到 Risk ID 为 %d 的 SSA 风险记录", risk_id))
}

# 获取完整源代码
fullCode, fragment, hasFullCode = risk.GetSSARiskSourceCodeWithFragment(risk_id)

# 构建漏洞分析提示词
prompt = buildVulnerabilityAnalysisPrompt(wrappedRisk, fullCode, fragment, hasFullCode, additional_context)

# 输出结果
println(prompt)

schema = jsonschema.ActionObject(
    jsonschema.paramObject("result",
        jsonschema.paramString("output", jsonschema.description("分析后产生的结果")),
    )
)

forgeHandle = func(params) {
    res = liteforge.Execute(prompt, liteforge.output(schema))~
    println(res.GetInvokeParams("result"))
    return res.GetInvokeParams("result")
}