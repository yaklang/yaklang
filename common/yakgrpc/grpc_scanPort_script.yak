yakit.AutoInitYakit()

hostFile = cli.String("target-file", cli.setRequired(true))
ports = cli.String("ports", cli.setDefault("22,443,445,80,8000-8004,3306,3389,5432,8080-8084,7000-7005"))
mode = cli.String("mode", cli.setDefault("fingerprint"))
saveToDB = cli.Bool("save-to-db")
saveClosed = cli.Bool("save-closed-ports")
proxies = cli.String("proxy", cli.setDefault("no"))
probeTimeoutFloat = cli.Float("probe-timeout", cli.setDefault(5.0), cli.setRequired(false))
probeMax = cli.Int("probe-max", cli.setRequired(false), cli.setDefault(4))

// host alive scan
skippedHostAliveScan = cli.Bool("skipped-host-alive-scan")
hostAliveConcurrent = cli.Int("host-alive-concurrent", cli.setDefault(20), cli.setRequired(false))
hostAliveTimeout = cli.Float("host-alive-timeout", cli.setDefault(5.0), cli.setRequired(false))
hostAliveTCPPorts = cli.String("host-alive-ports", cli.setDefault("80,22,443"), cli.setRequired(false))


active = cli.Bool("active")
concurrent = cli.Int("concurrent", cli.setDefault(50))
synConcurrent = cli.Int("syn-concurrent", cli.setDefault(800))
synScanNetInterface = cli.String("syn-scan-net-interface", cli.setDefault(""))
protos = cli.String("proto", cli.setDefault("tcp"))

fpMode = cli.String("fp-mode", cli.setDefault("all"))
scriptNames = cli.YakitPlugin()

excludeHosts = cli.String("exclude-hosts")
excludePorts = cli.String("exclude-ports")
enableCrawler = cli.Have("enable-basic-crawler")
crawlerMaxRequest = cli.Int("basic-crawler-request-max")
crawlerEnableJSParser = cli.Bool("basic-crawler-enable-jsparser", cli.setDefault(false), cli.setRequired(false))
cli.check()

if proxies == "no" {
	proxies = ""
}

hostRaw, _ = file.ReadFile(hostFile)
hosts = string(hostRaw)

if hosts == "" {
	die("target / hosts empty")
}


hostTotal = len(str.ParseStringToHosts(str.Trim(hosts, ",")))
portTotal = len(str.ParseStringToPorts(str.Trim(ports, ",")))
// yakit.StatusCard("扫描主机数", hostTotal)
// yakit.StatusCard("扫描端口数", portTotal)

pingProgressLock = sync.NewLock()
pingProgress = {
    "title":"主机存活探测",
    "doneTasks":0.0,
}

synProgressLock = sync.NewLock()
synProgress = {
    "title":"syn端口开放探测",
    "doneTasks":0.0,
}

fingerPrintProgressLock = sync.NewLock()
fingerPrintProgress =  {
    "title":"端口指纹识别",
    "doneTasks":0.0,
}

pluginProgressLock = sync.NewLock()
pluginProgress = {
    "title":"插件执行",
    "doneTasks":0.0,
}


updateProgress = func(progressIns,lock,delta,total...){
    allTasks = hostTotal*portTotal
    if len(total) > 0 {
        allTasks = total[0]
    }
    if allTasks <= 0 {
        yakit.SetProgressEx(progressIns.title,1)
    }
    lock.Lock()
    defer lock.Unlock()
    progressIns.doneTasks += delta
    if allTasks < progressIns.doneTasks {
        progressIns.doneTasks = allTasks
    }
    yakit.SetProgressEx(progressIns.title,(float(progressIns.doneTasks) / float(allTasks) ))
}

if !skippedHostAliveScan{
    updateProgress(pingProgress,pingProgressLock, 0)
}

opts = []
opts = append(opts, servicescan.active(active))

if concurrent > 0 {
    opts = append(opts, servicescan.concurrent(concurrent))
}

if protos != "" {
    protoList = str.Split(protos, ",")
	printf("PROTO: %#v\n", protos)
    opts = append(opts, servicescan.proto(protoList...))
}

// 使用指纹检测规则条数
if probeMax > 0 {
	opts = append(opts, servicescan.maxProbes(probeMax))
} else {
	opts = append(opts, servicescan.maxProbes(3))
}

if proxies != "" {
    proxyList = str.Split(proxies, ",")
    printf("PROXY: %v\n", proxyList)
    opts = append(opts, servicescan.proxy(proxyList...))
}

if probeTimeoutFloat > 0 {
    opts = append(opts, servicescan.probeTimeout(probeTimeoutFloat))
}

if fpMode == "web" {
	opts = append(opts, servicescan.web())
}

if fpMode == "service" {
	opts = append(opts, servicescan.service())
}

if fpMode == "all" {
	opts = append(opts, servicescan.all())
}

// 设置排除端口和主机
if excludePorts != "" {
    yakit.Info("设置排除端口：%v", excludePorts)
    opts = append(opts, servicescan.excludePorts(excludePorts))
}
if excludeHosts != "" {
    yakit.Info("设置排除主机：%v", excludeHosts)
    opts = append(opts, servicescan.excludeHosts(excludeHosts))
}

if !enableCrawler {
    yakit.Info("禁用基础爬虫")
}

/*
Loading Plugins
*/

scriptNameList = str.Join(x.Map( scriptNames, func(i) {
    // 0x60 反引号
    return "1. \x60" + sprint(i) + "\x60"
}), "\n")

yakit.Info("Preparing For Loading Plugins：%v", len(scriptNames))
manager, err = hook.NewMixPluginCaller()
if err != nil {
    yakit.Error("build mix plugin caller failed: %s", err)
    die(err)
}
// 这个有必要设置：独立上下文，避免在大并发的时候出现问题
manager.SetConcurrent(20)
manager.SetDividedContext(true)
x.Foreach(scriptNames, func(e){
    yakit.Info("Start to Load Plugin: %v", e)
    err = manager.LoadPlugin(e)
    if err != nil {
        yakit.Error("load plugin[%v] error: %v", e, err)
    }
    println(e + " Is Loaded")
})

// handle Result
handleMITMPluginCaller = func(crawlerReq) {
    defer func{
        err = recover()
        if err != nil { yakit.Error("handle plugin result failed: %s", err) }
    }

    rspIns = crawlerReq.Response()
    url = crawlerReq.Url()
    body = crawlerReq.ResponseBody()
    req = crawlerReq.RequestRaw()
    isHttps = x.If(str.HasPrefix(url, "https://"), true, false)
    rsp, _ = http.dumphead(rspIns)
    rsp = str.ReplaceHTTPPacketBody(rsp, body, false)
    manager.MirrorHTTPFlowExSync(false, isHttps, url, req, rsp, body)
}

handleCrawler = func(result) {
    defer func{
        err = recover()
        if err != nil { yakit.Error("call crawler error: %s", err) }
    }


	if (!enableCrawler) {
        return
    }
    if result.IsOpen() && result.Fingerprint != nil && len(result.Fingerprint.HttpFlows) > 0 {
        wg = sync.NewWaitGroup()
        addr = str.HostPort(result.Target, result.Port)
        res, err = crawler.Start(
            addr, crawler.maxRequest(crawlerMaxRequest),
            crawler.autoLogin("admin", "password"), 
            crawler.urlRegexpExclude(`(?i).*?\/?(logout|reset|delete|setup).*`),
            crawler.jsParser(crawlerEnableJSParser),
        )
        if err != nil {
            yakit.Error("basic crawler start failed: %s", err)
            return
        }
        yakit.Info("Start to Exec Basic Crawler for %v", addr)
        for crawlerReq = range res {
            yakit.Info("found url: %s", crawlerReq.Url())
            go func(){
                wg.Add()
                defer wg.Done()
                handleMITMPluginCaller(crawlerReq)
            } ()
        }
        wg.Wait()
        updateProgress(pluginProgress,pluginProgressLock,0.5)
    }
}


// 保存统计数据
startTimestamp = time.Now().Unix()
portTableHeader = ["Host", "Port", "Fingerprint", "HtmlTitle"]
portTableData = make([][]string)
addPortTableData = func(host, port, fp, title) {
    portTableData = append(portTableData, [sprint(host), sprint(port), sprint(fp), sprint(title)])
}
cClassCounter = make(map[string]int)
targetCounter = make(map[string]int)
updateCounter = func(target) {
    ordinaryCount = targetCounter[target]
    if ordinaryCount == undefined {
        targetCounter[target] = 1
    }else{
        targetCounter[target] = targetCounter[target] + 1
    }

    cClass = str.ParseStringToCClassHosts(target)
    if cClass != "" {
        cCount = cClassCounter[cClass]
        if cCount != undefined {
            cClassCounter[cClass] = cClassCounter[cClass] + 1
        }else{
            cClassCounter[cClass] = 1
        }
    }
}


handleFpResult = func(result) {
	defer func{
		err = recover()
		if err != nil { yakit.Error("call port-scan failed: %s", err) }
	}

    if result.IsOpen() {
        addPortTableData(result.Target, result.Port, result.GetServiceName(), result.GetHtmlTitle())
        updateCounter(result.Target)
	    yakit.Output({
		    "host": result.Target,
		    "port": result.Port,
		    "fingerprint": result.GetServiceName(),
            "htmlTitle": result.GetHtmlTitle(),
            "isOpen": true,
	    })
        if saveToDB {
            yakit.SavePortFromResult(result)
        }
        println(result.String(protos))
    }else{
        yakit.Output({
		    "host": result.Target,
		    "port": result.Port,
            "isOpen": false,
	    })
        if saveClosed && saveToDB {
            yakit.SavePortFromResult(result)
        }
        println(result.String(protos))
    }

	go func(){
        defer func{
            err = recover()
            if err != nil { yakit.Error("call port-scan plugin failed: %s", err) }
        }
        manager.GetNativeCaller().CallByNameSync("handle", result)
        updateProgress(pluginProgress,pluginProgressLock,0.5)
    }()

    go func{
        handleCrawler(result)
    }
}

getPingScan = func() {
	return ping.Scan(
        hosts, ping.proxy(proxies), ping.skip(skippedHostAliveScan), ping.tcpPingPorts(hostAliveTCPPorts),
        ping.timeout(hostAliveTimeout), ping.concurrent(hostAliveConcurrent), ping.onResult(func(i){
            if !(i.Ok) {
                hostTotal--
            }
            if i.Reason == "skipped"{
                return
            }
            updateProgress(pingProgress,pingProgressLock, portTotal)
        }), ping.excludeHosts(excludeHosts),
    )
}

if mode == "fingerprint" {
    updateProgress(fingerPrintProgress,fingerPrintProgressLock, 0)
    updateProgress(pluginProgress,pluginProgressLock,0)
    res, err := servicescan.ScanFromPing(
        getPingScan(),
        ports, opts...)
    die(err)

    for result = range res {
        updateProgress(fingerPrintProgress,fingerPrintProgressLock,1)
        handleFpResult(result)
    }
    updateProgress(fingerPrintProgress,fingerPrintProgressLock,hostTotal*portTotal)
}

synOpenPortCount = 0
addSynOpenPortCount = func() {
    synOpenPortCount++
    yakit.StatusCard("SYN 开放端口", synOpenPortCount)
}

// 数据包计数
synPacketCounter = 0
addSynPacketCounter = func(){synPacketCounter++}
startSYNPacketCounter = func(){
    go func{
        for { sleep(1); yakit.StatusCard("SYN 发包数", synPacketCounter) }
    }
}

if mode == "syn" {
    updateProgress(synProgress,synProgressLock,0)
    startSYNPacketCounter()
    synResults, err := synscan.ScanFromPing(
        getPingScan(), ports, synscan.initHostFilter(hosts), synscan.initPortFilter(ports),
        synscan.excludeHosts(excludeHosts), synscan.excludePorts(excludePorts),
        synscan.submitTaskCallback(func(i){ addSynPacketCounter() }),
        synscan.concurrent(synConcurrent),
        synscan.iface(synScanNetInterface),
    )
    die(err)

    for result := range synResults {
        updateProgress(synProgress,synProgressLock,1)
        addSynOpenPortCount()
	    yakit.Output({
		    "host": result.Host,
		    "port": result.Port,
            "isOpen": true,
	    })
        if saveToDB {
            yakit.SavePortFromResult(result)
        }
        result.Show()
    }
    updateProgress(synProgress,synProgressLock,hostTotal*portTotal)
}

if mode == "all" {
    updateProgress(fingerPrintProgress,fingerPrintProgressLock, 0)
    updateProgress(pluginProgress,pluginProgressLock,0)
    updateProgress(synProgress,synProgressLock,0)
    startSYNPacketCounter()
    synResults, err := synscan.ScanFromPing(
        getPingScan(), ports,
        synscan.initHostFilter(hosts), synscan.initPortFilter(ports),
        synscan.excludeHosts(excludeHosts),
        synscan.excludePorts(excludePorts),
        synscan.callback(func(i){
            addSynOpenPortCount()
            db.SavePortFromResult(i)
        }),
        synscan.submitTaskCallback(func(i){ addSynPacketCounter() }),
        synscan.concurrent(synConcurrent),
        synscan.iface(synScanNetInterface),
    )
    die(err)

    res, err := servicescan.ScanFromSynResult(synResults, opts...)
    die(err)

    for result := range res {
        updateProgress(synProgress,synProgressLock,1)
        updateProgress(fingerPrintProgress,fingerPrintProgressLock,1)
        handleFpResult(result)
    }
    updateProgress(synProgress,synProgressLock,hostTotal*portTotal)
    updateProgress(fingerPrintProgress,fingerPrintProgressLock,hostTotal*portTotal)
}


// 生成报告
reportIns = report.New()
reportIns.From("port-scan")
resultPortCount = len(portTableData)

endTimestamp = time.Now().Unix()

reportIns.Title("端口扫描报告:[%v]台主机/[%v]个开放端口/涉及[%v]个C段", len(targetCounter), resultPortCount, len(cClassCounter))
reportIns.Table(portTableHeader, portTableData...)
reportIns.Markdown(
    sprintf("# 扫描状态统计\n\n"+
    "本次扫描耗时 %v 秒\n\n"+
    "涉及扫描插件: %v 个",
    endTimestamp - startTimestamp, len(scriptNames),
))
if scriptNameList != "" {
    reportIns.Markdown(scriptNameList)
}
items = make([][]string)
if len(cClassCounter) > 0 {
    reportIns.Markdown("## C 段统计\n\n")
    for name, count = range cClassCounter{
        items = append(items, [sprint(name), sprint(count)])
    }
    reportIns.Table(["C 段", "开放端口数量"], items...)
}

if len(targetCounter) > 0 {
    reportIns.Markdown("## 主机维度端口统计")
    for name, count = range targetCounter{
        items = append(items, [sprint(name), sprint(count)])
    }
    reportIns.Table(["主机 IP", "开放端口数量"], items...)
}
reportIns.Save()


// 等待插件执行结果
yakit.Info("PortScan Finished Waiting for Plugin Results")
println("PortScan Finished... Waiting Plugins")
manager.Wait()
if mode == "all" || mode == "fingerprint" {
    updateProgress(pluginProgress,pluginProgressLock,hostTotal*portTotal)
}
