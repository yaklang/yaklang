// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.2.0
// - protoc             v3.19.1
// source: yakgrpc.proto

package ypb

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

// YakClient is the client API for Yak service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type YakClient interface {
	// version
	Version(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*VersionResponse, error)
	// echo 通常用于测试服务是否通畅
	Echo(ctx context.Context, in *EchoRequest, opts ...grpc.CallOption) (*EchoResposne, error)
	// 中间人劫持
	MITM(ctx context.Context, opts ...grpc.CallOption) (Yak_MITMClient, error)
	SetMITMFilter(ctx context.Context, in *SetMITMFilterRequest, opts ...grpc.CallOption) (*SetMITMFilterResponse, error)
	GetMITMFilter(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*SetMITMFilterRequest, error)
	DownloadMITMCert(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*MITMCert, error)
	// 开启端口
	OpenPort(ctx context.Context, opts ...grpc.CallOption) (Yak_OpenPortClient, error)
	// Exec
	Exec(ctx context.Context, in *ExecRequest, opts ...grpc.CallOption) (Yak_ExecClient, error)
	QueryExecHistory(ctx context.Context, in *ExecHistoryRequest, opts ...grpc.CallOption) (*ExecHistoryRecordResponse, error)
	RemoveExecHistory(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*Empty, error)
	LoadNucleiTemplates(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*Empty, error)
	AutoUpdateYakModule(ctx context.Context, in *Empty, opts ...grpc.CallOption) (Yak_AutoUpdateYakModuleClient, error)
	ExecYakScript(ctx context.Context, in *ExecRequest, opts ...grpc.CallOption) (Yak_ExecYakScriptClient, error)
	ExecBatchYakScript(ctx context.Context, in *ExecBatchYakScriptRequest, opts ...grpc.CallOption) (Yak_ExecBatchYakScriptClient, error)
	GetExecBatchYakScriptUnfinishedTask(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*GetExecBatchYakScriptUnfinishedTaskResponse, error)
	GetExecBatchYakScriptUnfinishedTaskByUid(ctx context.Context, in *GetExecBatchYakScriptUnfinishedTaskByUidRequest, opts ...grpc.CallOption) (*ExecBatchYakScriptRequest, error)
	PopExecBatchYakScriptUnfinishedTaskByUid(ctx context.Context, in *GetExecBatchYakScriptUnfinishedTaskByUidRequest, opts ...grpc.CallOption) (*ExecBatchYakScriptRequest, error)
	RecoverExecBatchYakScriptUnfinishedTask(ctx context.Context, in *RecoverExecBatchYakScriptUnfinishedTaskRequest, opts ...grpc.CallOption) (Yak_RecoverExecBatchYakScriptUnfinishedTaskClient, error)
	// yakScript
	QueryYakScript(ctx context.Context, in *QueryYakScriptRequest, opts ...grpc.CallOption) (*QueryYakScriptResponse, error)
	QueryYakScriptByYakScriptName(ctx context.Context, in *QueryYakScriptRequest, opts ...grpc.CallOption) (Yak_QueryYakScriptByYakScriptNameClient, error)
	SaveYakScript(ctx context.Context, in *YakScript, opts ...grpc.CallOption) (*YakScript, error)
	DeleteYakScript(ctx context.Context, in *DeleteYakScriptRequest, opts ...grpc.CallOption) (*Empty, error)
	GetYakScriptById(ctx context.Context, in *GetYakScriptByIdRequest, opts ...grpc.CallOption) (*YakScript, error)
	GetYakScriptByName(ctx context.Context, in *GetYakScriptByNameRequest, opts ...grpc.CallOption) (*YakScript, error)
	GetYakScriptByOnlineID(ctx context.Context, in *GetYakScriptByOnlineIDRequest, opts ...grpc.CallOption) (*YakScript, error)
	IgnoreYakScript(ctx context.Context, in *DeleteYakScriptRequest, opts ...grpc.CallOption) (*Empty, error)
	UnIgnoreYakScript(ctx context.Context, in *DeleteYakScriptRequest, opts ...grpc.CallOption) (*Empty, error)
	ExportYakScript(ctx context.Context, in *ExportYakScriptRequest, opts ...grpc.CallOption) (*ExportYakScriptResponse, error)
	ExecutePacketYakScript(ctx context.Context, in *ExecutePacketYakScriptParams, opts ...grpc.CallOption) (Yak_ExecutePacketYakScriptClient, error)
	ExecuteBatchPacketYakScript(ctx context.Context, in *ExecuteBatchPacketYakScriptParams, opts ...grpc.CallOption) (Yak_ExecuteBatchPacketYakScriptClient, error)
	GetYakScriptTags(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*GetYakScriptTagsResponse, error)
	QueryYakScriptLocalAndUser(ctx context.Context, in *QueryYakScriptLocalAndUserRequest, opts ...grpc.CallOption) (*QueryYakScriptLocalAndUserResponse, error)
	QueryYakScriptByOnlineGroup(ctx context.Context, in *QueryYakScriptByOnlineGroupRequest, opts ...grpc.CallOption) (*QueryYakScriptLocalAndUserResponse, error)
	QueryYakScriptLocalAll(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*QueryYakScriptLocalAndUserResponse, error)
	QueryYakScriptByNames(ctx context.Context, in *QueryYakScriptByNamesRequest, opts ...grpc.CallOption) (*QueryYakScriptByNamesResponse, error)
	QueryYakScriptByIsCore(ctx context.Context, in *QueryYakScriptByIsCoreRequest, opts ...grpc.CallOption) (*QueryYakScriptByIsCoreResponse, error)
	// HTTPFlow
	GetHTTPFlowByHash(ctx context.Context, in *GetHTTPFlowByHashRequest, opts ...grpc.CallOption) (*HTTPFlow, error)
	GetHTTPFlowById(ctx context.Context, in *GetHTTPFlowByIdRequest, opts ...grpc.CallOption) (*HTTPFlow, error)
	GetHTTPFlowByIds(ctx context.Context, in *GetHTTPFlowByIdsRequest, opts ...grpc.CallOption) (*HTTPFlows, error)
	QueryHTTPFlows(ctx context.Context, in *QueryHTTPFlowRequest, opts ...grpc.CallOption) (*QueryHTTPFlowResponse, error)
	DeleteHTTPFlows(ctx context.Context, in *DeleteHTTPFlowRequest, opts ...grpc.CallOption) (*Empty, error)
	SetTagForHTTPFlow(ctx context.Context, in *SetTagForHTTPFlowRequest, opts ...grpc.CallOption) (*Empty, error)
	QueryHTTPFlowsIds(ctx context.Context, in *QueryHTTPFlowsIdsRequest, opts ...grpc.CallOption) (*QueryHTTPFlowsIdsResponse, error)
	HTTPFlowsFieldGroup(ctx context.Context, in *HTTPFlowsFieldGroupRequest, opts ...grpc.CallOption) (*HTTPFlowsFieldGroupResponse, error)
	HTTPFlowsShare(ctx context.Context, in *HTTPFlowsShareRequest, opts ...grpc.CallOption) (*HTTPFlowsShareResponse, error)
	HTTPFlowsExtract(ctx context.Context, in *HTTPFlowsExtractRequest, opts ...grpc.CallOption) (*Empty, error)
	GetHTTPFlowBare(ctx context.Context, in *HTTPFlowBareRequest, opts ...grpc.CallOption) (*HTTPFlowBareResponse, error)
	// 从一个 FuzzerRequest 中提取 Url
	ExtractUrl(ctx context.Context, in *FuzzerRequest, opts ...grpc.CallOption) (*ExtractedUrl, error)
	// Fuzzer
	GetHistoryHTTPFuzzerTask(ctx context.Context, in *GetHistoryHTTPFuzzerTaskRequest, opts ...grpc.CallOption) (*HistoryHTTPFuzzerTaskDetail, error)
	QueryHistoryHTTPFuzzerTask(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*HistoryHTTPFuzzerTasks, error)
	QueryHistoryHTTPFuzzerTaskEx(ctx context.Context, in *QueryHistoryHTTPFuzzerTaskExParams, opts ...grpc.CallOption) (*HistoryHTTPFuzzerTasksResponse, error)
	DeleteHistoryHTTPFuzzerTask(ctx context.Context, in *DeleteHistoryHTTPFuzzerTaskRequest, opts ...grpc.CallOption) (*Empty, error)
	HTTPFuzzer(ctx context.Context, in *FuzzerRequest, opts ...grpc.CallOption) (Yak_HTTPFuzzerClient, error)
	HTTPFuzzerSequence(ctx context.Context, in *FuzzerRequests, opts ...grpc.CallOption) (Yak_HTTPFuzzerSequenceClient, error)
	PreloadHTTPFuzzerParams(ctx context.Context, in *PreloadHTTPFuzzerParamsRequest, opts ...grpc.CallOption) (*PreloadHTTPFuzzerParamsResponse, error)
	RenderVariables(ctx context.Context, in *RenderVariablesRequest, opts ...grpc.CallOption) (*RenderVariablesResponse, error)
	MatchHTTPResponse(ctx context.Context, in *MatchHTTPResponseParams, opts ...grpc.CallOption) (*MatchHTTPResponseResult, error)
	ExtractHTTPResponse(ctx context.Context, in *ExtractHTTPResponseParams, opts ...grpc.CallOption) (*ExtractHTTPResponseResult, error)
	RedirectRequest(ctx context.Context, in *RedirectRequestParams, opts ...grpc.CallOption) (*FuzzerResponse, error)
	HTTPRequestMutate(ctx context.Context, in *HTTPRequestMutateParams, opts ...grpc.CallOption) (*MutateResult, error)
	HTTPResponseMutate(ctx context.Context, in *HTTPResponseMutateParams, opts ...grpc.CallOption) (*MutateResult, error)
	FixUploadPacket(ctx context.Context, in *FixUploadPacketRequest, opts ...grpc.CallOption) (*FixUploadPacketResponse, error)
	IsMultipartFormDataRequest(ctx context.Context, in *FixUploadPacketRequest, opts ...grpc.CallOption) (*IsMultipartFormDataRequestResult, error)
	GenerateExtractRule(ctx context.Context, in *GenerateExtractRuleRequest, opts ...grpc.CallOption) (*GenerateExtractRuleResponse, error)
	ExtractData(ctx context.Context, opts ...grpc.CallOption) (Yak_ExtractDataClient, error)
	ImportHTTPFuzzerTaskFromYaml(ctx context.Context, in *ImportHTTPFuzzerTaskFromYamlRequest, opts ...grpc.CallOption) (*ImportHTTPFuzzerTaskFromYamlResponse, error)
	ExportHTTPFuzzerTaskToYaml(ctx context.Context, in *ExportHTTPFuzzerTaskToYamlRequest, opts ...grpc.CallOption) (*ExportHTTPFuzzerTaskToYamlResponse, error)
	SaveFuzzerLabel(ctx context.Context, in *SaveFuzzerLabelRequest, opts ...grpc.CallOption) (*Empty, error)
	QueryFuzzerLabel(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*QueryFuzzerLabelResponse, error)
	DeleteFuzzerLabel(ctx context.Context, in *DeleteFuzzerLabelRequest, opts ...grpc.CallOption) (*Empty, error)
	// HTTPFuzzerResponse
	// 这个挺特殊的，因为数据包太多了，会卡，所以后端会保存一份，通过这个接口做缓存查询
	QueryHTTPFuzzerResponseByTaskId(ctx context.Context, in *QueryHTTPFuzzerResponseByTaskIdRequest, opts ...grpc.CallOption) (*QueryHTTPFuzzerResponseByTaskIdResponse, error)
	// WebSocket
	CreateWebsocketFuzzer(ctx context.Context, opts ...grpc.CallOption) (Yak_CreateWebsocketFuzzerClient, error)
	QueryWebsocketFlowByHTTPFlowWebsocketHash(ctx context.Context, in *QueryWebsocketFlowByHTTPFlowWebsocketHashRequest, opts ...grpc.CallOption) (*WebsocketFlows, error)
	DeleteWebsocketFlowByHTTPFlowWebsocketHash(ctx context.Context, in *DeleteWebsocketFlowByHTTPFlowWebsocketHashRequest, opts ...grpc.CallOption) (*Empty, error)
	DeleteWebsocketFlowAll(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*Empty, error)
	// FuzzerResponse 对象转 HTTPFlow：以便分析和模糊测试
	ConvertFuzzerResponseToHTTPFlow(ctx context.Context, in *FuzzerResponse, opts ...grpc.CallOption) (*HTTPFlow, error)
	// 渲染 Fuzzer 模版
	StringFuzzer(ctx context.Context, in *StringFuzzerRequest, opts ...grpc.CallOption) (*StringFuzzerResponse, error)
	// 分析一个 HTTP 请求详情
	HTTPRequestAnalyzer(ctx context.Context, in *HTTPRequestAnalysisMaterial, opts ...grpc.CallOption) (*HTTPRequestAnalysis, error)
	// 编码解码
	Codec(ctx context.Context, in *CodecRequest, opts ...grpc.CallOption) (*CodecResponse, error)
	NewCodec(ctx context.Context, in *CodecRequestFlow, opts ...grpc.CallOption) (*CodecResponse, error)
	PacketPrettifyHelper(ctx context.Context, in *PacketPrettifyHelperRequest, opts ...grpc.CallOption) (*PacketPrettifyHelperResponse, error)
	// Payload 相关接口
	QueryPayload(ctx context.Context, in *QueryPayloadRequest, opts ...grpc.CallOption) (*QueryPayloadResponse, error)
	DeletePayloadByGroup(ctx context.Context, in *DeletePayloadByGroupRequest, opts ...grpc.CallOption) (*Empty, error)
	DeletePayload(ctx context.Context, in *DeletePayloadRequest, opts ...grpc.CallOption) (*Empty, error)
	SavePayload(ctx context.Context, in *SavePayloadRequest, opts ...grpc.CallOption) (*Empty, error)
	SavePayloadStream(ctx context.Context, in *SavePayloadRequest, opts ...grpc.CallOption) (Yak_SavePayloadStreamClient, error)
	GetAllPayloadGroup(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*GetAllPayloadGroupResponse, error)
	UpdatePayload(ctx context.Context, in *UpdatePayloadRequest, opts ...grpc.CallOption) (*Empty, error)
	GetAllPayload(ctx context.Context, in *GetAllPayloadRequest, opts ...grpc.CallOption) (*GetAllPayloadResponse, error)
	// 自动生成补全
	GetYakitCompletionRaw(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*YakitCompletionRawResponse, error)
	GetYakVMBuildInMethodCompletion(ctx context.Context, in *GetYakVMBuildInMethodCompletionRequest, opts ...grpc.CallOption) (*GetYakVMBuildInMethodCompletionResponse, error)
	StaticAnalyzeError(ctx context.Context, in *StaticAnalyzeErrorRequest, opts ...grpc.CallOption) (*StaticAnalyzeErrorResponse, error)
	YaklangCompileAndFormat(ctx context.Context, in *YaklangCompileAndFormatRequest, opts ...grpc.CallOption) (*YaklangCompileAndFormatResponse, error)
	// 端口扫描的封装
	PortScan(ctx context.Context, in *PortScanRequest, opts ...grpc.CallOption) (Yak_PortScanClient, error)
	ViewPortScanCode(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*SimpleScript, error)
	SimpleDetect(ctx context.Context, in *RecordPortScanRequest, opts ...grpc.CallOption) (Yak_SimpleDetectClient, error)
	SaveCancelSimpleDetect(ctx context.Context, in *RecordPortScanRequest, opts ...grpc.CallOption) (*Empty, error)
	GetSimpleDetectUnfinishedTask(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*GetSimpleDetectUnfinishedTaskResponse, error)
	GetSimpleDetectUnfinishedTaskByUid(ctx context.Context, in *GetExecBatchYakScriptUnfinishedTaskByUidRequest, opts ...grpc.CallOption) (*RecordPortScanRequest, error)
	PopSimpleDetectUnfinishedTaskByUid(ctx context.Context, in *GetExecBatchYakScriptUnfinishedTaskByUidRequest, opts ...grpc.CallOption) (*RecordPortScanRequest, error)
	RecoverSimpleDetectUnfinishedTask(ctx context.Context, in *RecoverExecBatchYakScriptUnfinishedTaskRequest, opts ...grpc.CallOption) (Yak_RecoverSimpleDetectUnfinishedTaskClient, error)
	// 资产管理
	QueryPorts(ctx context.Context, in *QueryPortsRequest, opts ...grpc.CallOption) (*QueryPortsResponse, error)
	DeletePorts(ctx context.Context, in *DeletePortsRequest, opts ...grpc.CallOption) (*Empty, error)
	QueryHosts(ctx context.Context, in *QueryHostsRequest, opts ...grpc.CallOption) (*QueryHostsResponse, error)
	DeleteHosts(ctx context.Context, in *DeleteHostsRequest, opts ...grpc.CallOption) (*Empty, error)
	QueryDomains(ctx context.Context, in *QueryDomainsRequest, opts ...grpc.CallOption) (*QueryDomainsResponse, error)
	DeleteDomains(ctx context.Context, in *DeleteDomainsRequest, opts ...grpc.CallOption) (*Empty, error)
	QueryPortsGroup(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*QueryPortsGroupResponse, error)
	// Yakit Store
	UpdateFromYakitResource(ctx context.Context, in *UpdateFromYakitResourceRequest, opts ...grpc.CallOption) (*Empty, error)
	UpdateFromGithub(ctx context.Context, in *UpdateFromGithubRequest, opts ...grpc.CallOption) (*Empty, error)
	// Menu
	AddToMenu(ctx context.Context, in *AddToMenuRequest, opts ...grpc.CallOption) (*Empty, error)
	RemoveFromMenu(ctx context.Context, in *RemoveFromMenuRequest, opts ...grpc.CallOption) (*Empty, error)
	YakScriptIsInMenu(ctx context.Context, in *YakScriptIsInMenuRequest, opts ...grpc.CallOption) (*Empty, error)
	GetAllMenuItem(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*MenuByGroup, error)
	DeleteAllMenuItem(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*Empty, error)
	ImportMenuItem(ctx context.Context, in *ImportMenuItemRequest, opts ...grpc.CallOption) (*Empty, error)
	ExportMenuItem(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*ExportMenuItemResult, error)
	GetMenuItemById(ctx context.Context, in *GetMenuItemByIdRequest, opts ...grpc.CallOption) (*MenuItem, error)
	QueryGroupsByYakScriptId(ctx context.Context, in *QueryGroupsByYakScriptIdRequest, opts ...grpc.CallOption) (*GroupNames, error)
	AddMenus(ctx context.Context, in *AddMenuRequest, opts ...grpc.CallOption) (*Empty, error)
	QueryAllMenuItem(ctx context.Context, in *QueryAllMenuItemRequest, opts ...grpc.CallOption) (*MenuByGroup, error)
	DeleteAllMenu(ctx context.Context, in *QueryAllMenuItemRequest, opts ...grpc.CallOption) (*Empty, error)
	// NewMenu
	AddToNavigation(ctx context.Context, in *AddToNavigationRequest, opts ...grpc.CallOption) (*Empty, error)
	GetAllNavigationItem(ctx context.Context, in *GetAllNavigationRequest, opts ...grpc.CallOption) (*GetAllNavigationItemResponse, error)
	DeleteAllNavigation(ctx context.Context, in *GetAllNavigationRequest, opts ...grpc.CallOption) (*Empty, error)
	AddOneNavigation(ctx context.Context, in *AddOneNavigationRequest, opts ...grpc.CallOption) (*Empty, error)
	QueryNavigationGroups(ctx context.Context, in *QueryNavigationGroupsRequest, opts ...grpc.CallOption) (*GroupNames, error)
	// document
	SaveMarkdownDocument(ctx context.Context, in *SaveMarkdownDocumentRequest, opts ...grpc.CallOption) (*Empty, error)
	GetMarkdownDocument(ctx context.Context, in *GetMarkdownDocumentRequest, opts ...grpc.CallOption) (*GetMarkdownDocumentResponse, error)
	DeleteMarkdownDocument(ctx context.Context, in *GetMarkdownDocumentRequest, opts ...grpc.CallOption) (*Empty, error)
	// Crawler
	StartBasicCrawler(ctx context.Context, in *StartBasicCrawlerRequest, opts ...grpc.CallOption) (*ExecResult, error)
	ViewBasicCrawlerCode(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*SimpleScript, error)
	GenerateWebsiteTree(ctx context.Context, in *GenerateWebsiteTreeRequest, opts ...grpc.CallOption) (*GenerateWebsiteTreeResponse, error)
	// 对插件结果的操作
	QueryYakScriptExecResult(ctx context.Context, in *QueryYakScriptExecResultRequest, opts ...grpc.CallOption) (*QueryYakScriptExecResultResponse, error)
	QueryYakScriptNameInExecResult(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*YakScriptNames, error)
	DeleteYakScriptExecResult(ctx context.Context, in *DeleteYakScriptExecResultRequest, opts ...grpc.CallOption) (*Empty, error)
	DeleteYakScriptExec(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*Empty, error)
	// Bruter
	StartBrute(ctx context.Context, in *StartBruteParams, opts ...grpc.CallOption) (Yak_StartBruteClient, error)
	GetAvailableBruteTypes(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*GetAvailableBruteTypesResponse, error)
	// Tunnel Server RMI/DNSLog
	GetTunnelServerExternalIP(ctx context.Context, in *GetTunnelServerExternalIPParams, opts ...grpc.CallOption) (*GetTunnelServerExternalIPResponse, error)
	VerifyTunnelServerDomain(ctx context.Context, in *VerifyTunnelServerDomainParams, opts ...grpc.CallOption) (*VerifyTunnelServerDomainResponse, error)
	StartFacades(ctx context.Context, in *StartFacadesParams, opts ...grpc.CallOption) (Yak_StartFacadesClient, error)
	StartFacadesWithYsoObject(ctx context.Context, in *StartFacadesWithYsoParams, opts ...grpc.CallOption) (Yak_StartFacadesWithYsoObjectClient, error)
	ApplyClassToFacades(ctx context.Context, in *ApplyClassToFacadesParamsWithVerbose, opts ...grpc.CallOption) (*Empty, error)
	BytesToBase64(ctx context.Context, in *BytesToBase64Request, opts ...grpc.CallOption) (*BytesToBase64Response, error)
	ConfigGlobalReverse(ctx context.Context, in *ConfigGlobalReverseParams, opts ...grpc.CallOption) (Yak_ConfigGlobalReverseClient, error)
	AvailableLocalAddr(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*AvailableLocalAddrResponse, error)
	GetGlobalReverseServer(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*GetGlobalReverseServerResponse, error)
	// Risk
	QueryRisks(ctx context.Context, in *QueryRisksRequest, opts ...grpc.CallOption) (*QueryRisksResponse, error)
	QueryRisk(ctx context.Context, in *QueryRiskRequest, opts ...grpc.CallOption) (*Risk, error)
	DeleteRisk(ctx context.Context, in *DeleteRiskRequest, opts ...grpc.CallOption) (*Empty, error)
	QueryAvailableRiskType(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*Fields, error)
	QueryAvailableRiskLevel(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*Fields, error)
	QueryRiskTableStats(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*RiskTableStats, error)
	ResetRiskTableStats(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*Empty, error)
	QueryAvailableTarget(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*Fields, error)
	QueryNewRisk(ctx context.Context, in *QueryNewRiskRequest, opts ...grpc.CallOption) (*QueryNewRiskResponse, error)
	NewRiskRead(ctx context.Context, in *NewRiskReadRequest, opts ...grpc.CallOption) (*Empty, error)
	UploadRiskToOnline(ctx context.Context, in *UploadRiskToOnlineRequest, opts ...grpc.CallOption) (*Empty, error)
	// Report
	QueryReports(ctx context.Context, in *QueryReportsRequest, opts ...grpc.CallOption) (*QueryReportsResponse, error)
	QueryReport(ctx context.Context, in *QueryReportRequest, opts ...grpc.CallOption) (*Report, error)
	DeleteReport(ctx context.Context, in *DeleteReportRequest, opts ...grpc.CallOption) (*Empty, error)
	QueryAvailableReportFrom(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*Fields, error)
	DownloadReport(ctx context.Context, in *DownloadReportRequest, opts ...grpc.CallOption) (*Empty, error)
	//Yso
	GetAllYsoGadgetOptions(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*YsoOptionsWithVerbose, error)
	GetAllYsoClassOptions(ctx context.Context, in *YsoOptionsRequerstWithVerbose, opts ...grpc.CallOption) (*YsoOptionsWithVerbose, error)
	GetAllYsoClassGeneraterOptions(ctx context.Context, in *YsoOptionsRequerstWithVerbose, opts ...grpc.CallOption) (*YsoClassOptionsResponseWithVerbose, error)
	GenerateYsoCode(ctx context.Context, in *YsoOptionsRequerstWithVerbose, opts ...grpc.CallOption) (*YsoCodeResponse, error)
	GenerateYsoBytes(ctx context.Context, in *YsoOptionsRequerstWithVerbose, opts ...grpc.CallOption) (*YsoBytesResponse, error)
	YsoDump(ctx context.Context, in *YsoBytesObject, opts ...grpc.CallOption) (*YsoDumpResponse, error)
	// DNSLog / ICMP / RandomTrigger
	SetYakBridgeLogServer(ctx context.Context, in *YakDNSLogBridgeAddr, opts ...grpc.CallOption) (*Empty, error)
	GetCurrentYakBridgeLogServer(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*YakDNSLogBridgeAddr, error)
	RequireDNSLogDomain(ctx context.Context, in *YakDNSLogBridgeAddr, opts ...grpc.CallOption) (*DNSLogRootDomain, error)
	RequireDNSLogDomainByScript(ctx context.Context, in *RequireDNSLogDomainByScriptRequest, opts ...grpc.CallOption) (*DNSLogRootDomain, error)
	QueryDNSLogByToken(ctx context.Context, in *QueryDNSLogByTokenRequest, opts ...grpc.CallOption) (*QueryDNSLogByTokenResponse, error)
	QueryDNSLogTokenByScript(ctx context.Context, in *RequireDNSLogDomainByScriptRequest, opts ...grpc.CallOption) (*QueryDNSLogByTokenResponse, error)
	RequireICMPRandomLength(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*RequireICMPRandomLengthResponse, error)
	QueryICMPTrigger(ctx context.Context, in *QueryICMPTriggerRequest, opts ...grpc.CallOption) (*QueryICMPTriggerResponse, error)
	RequireRandomPortToken(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*RandomPortInfo, error)
	QueryRandomPortTrigger(ctx context.Context, in *QueryRandomPortTriggerRequest, opts ...grpc.CallOption) (*RandomPortTriggerNotification, error)
	QuerySupportedDnsLogPlatforms(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*QuerySupportedDnsLogPlatformsResponse, error)
	// 获取 Tags
	GetAvailableYakScriptTags(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*Fields, error)
	ForceUpdateAvailableYakScriptTags(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*Empty, error)
	// 通用的漏洞检测技术方案
	ExecYakitPluginsByYakScriptFilter(ctx context.Context, in *ExecYakitPluginsByYakScriptFilterRequest, opts ...grpc.CallOption) (Yak_ExecYakitPluginsByYakScriptFilterClient, error)
	// GenerateYakCodeByPacket
	GenerateYakCodeByPacket(ctx context.Context, in *GenerateYakCodeByPacketRequest, opts ...grpc.CallOption) (*GenerateYakCodeByPacketResponse, error)
	// CSRF Generator
	GenerateCSRFPocByPacket(ctx context.Context, in *GenerateCSRFPocByPacketRequest, opts ...grpc.CallOption) (*GenerateCSRFPocByPacketResponse, error)
	// MITM 衍生功能：
	// Replacers 管理
	ExportMITMReplacerRules(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*ExportMITMReplacerRulesResponse, error)
	ImportMITMReplacerRules(ctx context.Context, in *ImportMITMReplacerRulesRequest, opts ...grpc.CallOption) (*Empty, error)
	GetCurrentRules(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*MITMContentReplacers, error)
	SetCurrentRules(ctx context.Context, in *MITMContentReplacers, opts ...grpc.CallOption) (*Empty, error)
	ExtractDataToFile(ctx context.Context, opts ...grpc.CallOption) (Yak_ExtractDataToFileClient, error)
	// 尝试自动解码
	AutoDecode(ctx context.Context, in *AutoDecodeRequest, opts ...grpc.CallOption) (*AutoDecodeResponse, error)
	GetSystemProxy(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*GetSystemProxyResult, error)
	SetSystemProxy(ctx context.Context, in *SetSystemProxyRequest, opts ...grpc.CallOption) (*Empty, error)
	// 设置通用存储
	GetKey(ctx context.Context, in *GetKeyRequest, opts ...grpc.CallOption) (*GetKeyResult, error)
	SetKey(ctx context.Context, in *SetKeyRequest, opts ...grpc.CallOption) (*Empty, error)
	DelKey(ctx context.Context, in *GetKeyRequest, opts ...grpc.CallOption) (*Empty, error)
	GetAllProcessEnvKey(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*GetProcessEnvKeyResult, error)
	SetProcessEnvKey(ctx context.Context, in *SetKeyRequest, opts ...grpc.CallOption) (*Empty, error)
	GetProjectKey(ctx context.Context, in *GetKeyRequest, opts ...grpc.CallOption) (*GetKeyResult, error)
	SetProjectKey(ctx context.Context, in *SetKeyRequest, opts ...grpc.CallOption) (*Empty, error)
	// Online
	GetOnlineProfile(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*OnlineProfile, error)
	SetOnlineProfile(ctx context.Context, in *OnlineProfile, opts ...grpc.CallOption) (*Empty, error)
	DownloadOnlinePluginById(ctx context.Context, in *DownloadOnlinePluginByIdRequest, opts ...grpc.CallOption) (*Empty, error)
	DownloadOnlinePluginByIds(ctx context.Context, in *DownloadOnlinePluginByIdsRequest, opts ...grpc.CallOption) (*Empty, error)
	DownloadOnlinePluginAll(ctx context.Context, in *DownloadOnlinePluginByTokenRequest, opts ...grpc.CallOption) (Yak_DownloadOnlinePluginAllClient, error)
	DeletePluginByUserID(ctx context.Context, in *DeletePluginByUserIDRequest, opts ...grpc.CallOption) (*Empty, error)
	DeleteAllLocalPlugins(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*Empty, error)
	GetYakScriptTagsAndType(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*GetYakScriptTagsAndTypeResponse, error)
	DeleteLocalPluginsByWhere(ctx context.Context, in *DeleteLocalPluginsByWhereRequest, opts ...grpc.CallOption) (*Empty, error)
	DownloadOnlinePluginByScriptNames(ctx context.Context, in *DownloadOnlinePluginByScriptNamesRequest, opts ...grpc.CallOption) (*DownloadOnlinePluginByScriptNamesResponse, error)
	// 新的扫描模式
	ExecPacketScan(ctx context.Context, in *ExecPacketScanRequest, opts ...grpc.CallOption) (Yak_ExecPacketScanClient, error)
	GetEngineDefaultProxy(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*DefaultProxyResult, error)
	SetEngineDefaultProxy(ctx context.Context, in *DefaultProxyResult, opts ...grpc.CallOption) (*Empty, error)
	// machine id
	GetMachineID(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*GetMachineIDResponse, error)
	// license
	GetLicense(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*GetLicenseResponse, error)
	CheckLicense(ctx context.Context, in *CheckLicenseRequest, opts ...grpc.CallOption) (*Empty, error)
	// Response Body 的魔法操作
	GetRequestBodyByHTTPFlowID(ctx context.Context, in *DownloadBodyByHTTPFlowIDRequest, opts ...grpc.CallOption) (*Bytes, error)
	GetResponseBodyByHTTPFlowID(ctx context.Context, in *DownloadBodyByHTTPFlowIDRequest, opts ...grpc.CallOption) (*Bytes, error)
	GetHTTPPacketBody(ctx context.Context, in *GetHTTPPacketBodyRequest, opts ...grpc.CallOption) (*Bytes, error)
	// 注册一个 Facades HTTP 响应
	RegisterFacadesHTTP(ctx context.Context, in *RegisterFacadesHTTPRequest, opts ...grpc.CallOption) (*RegisterFacadesHTTPResponse, error)
	// 重置到恢复出厂设置
	ResetAndInvalidUserData(ctx context.Context, in *ResetAndInvalidUserDataRequest, opts ...grpc.CallOption) (*Empty, error)
	// Yaklang Shell
	// 创建一个交互式 Shell
	CreateYaklangShell(ctx context.Context, opts ...grpc.CallOption) (Yak_CreateYaklangShellClient, error)
	// 接入标准输出和标准错误流
	AttachCombinedOutput(ctx context.Context, in *AttachCombinedOutputRequest, opts ...grpc.CallOption) (Yak_AttachCombinedOutputClient, error)
	// 判断当前引擎对网卡是否有操作权限？
	// 主要是能否发包等敏感操作
	// Windows 判断是否是管理员即可 I Am Admin
	// Linux 和 MacOS 应该尝试 pcap 打开网卡就行
	IsPrivilegedForNetRaw(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*IsPrivilegedForNetRawResponse, error)
	PromotePermissionForUserPcap(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*Empty, error)
	// 操作项目的相关接口，通过设置 ProjectDatabase
	SetCurrentProject(ctx context.Context, in *SetCurrentProjectRequest, opts ...grpc.CallOption) (*Empty, error)
	GetCurrentProject(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*ProjectDescription, error)
	GetProjects(ctx context.Context, in *GetProjectsRequest, opts ...grpc.CallOption) (*GetProjectsResponse, error)
	NewProject(ctx context.Context, in *NewProjectRequest, opts ...grpc.CallOption) (*NewProjectResponse, error)
	IsProjectNameValid(ctx context.Context, in *IsProjectNameValidRequest, opts ...grpc.CallOption) (*Empty, error)
	RemoveProject(ctx context.Context, in *RemoveProjectRequest, opts ...grpc.CallOption) (*Empty, error)
	DeleteProject(ctx context.Context, in *DeleteProjectRequest, opts ...grpc.CallOption) (*Empty, error)
	GetDefaultProject(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*ProjectDescription, error)
	QueryProjectDetail(ctx context.Context, in *QueryProjectDetailRequest, opts ...grpc.CallOption) (*ProjectDescription, error)
	// 导入导出项目，带密码，带进度
	ExportProject(ctx context.Context, in *ExportProjectRequest, opts ...grpc.CallOption) (Yak_ExportProjectClient, error)
	ImportProject(ctx context.Context, in *ImportProjectRequest, opts ...grpc.CallOption) (Yak_ImportProjectClient, error)
	// 迁移旧数据库
	MigrateLegacyDatabase(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*Empty, error)
	// 从规则中提取数据
	QueryMITMRuleExtractedData(ctx context.Context, in *QueryMITMRuleExtractedDataRequest, opts ...grpc.CallOption) (*QueryMITMRuleExtractedDataResponse, error)
	//
	//ChaosMakerRule: Bas
	ImportChaosMakerRules(ctx context.Context, in *ImportChaosMakerRulesRequest, opts ...grpc.CallOption) (*Empty, error)
	QueryChaosMakerRule(ctx context.Context, in *QueryChaosMakerRuleRequest, opts ...grpc.CallOption) (*QueryChaosMakerRuleResponse, error)
	DeleteChaosMakerRuleByID(ctx context.Context, in *DeleteChaosMakerRuleByIDRequest, opts ...grpc.CallOption) (*Empty, error)
	ExecuteChaosMakerRule(ctx context.Context, in *ExecuteChaosMakerRuleRequest, opts ...grpc.CallOption) (Yak_ExecuteChaosMakerRuleClient, error)
	// 这个接口是判断 BAS Agent 远程端口是否可用的，使用 Vulinbox ws agent 协议连接
	// ConnectVulinboxAgent is the same as IsRemoteAddrAvailable
	IsRemoteAddrAvailable(ctx context.Context, in *IsRemoteAddrAvailableRequest, opts ...grpc.CallOption) (*IsRemoteAddrAvailableResponse, error)
	ConnectVulinboxAgent(ctx context.Context, in *IsRemoteAddrAvailableRequest, opts ...grpc.CallOption) (*IsRemoteAddrAvailableResponse, error)
	// vulinbox agent 的操作接口
	GetRegisteredVulinboxAgent(ctx context.Context, in *GetRegisteredAgentRequest, opts ...grpc.CallOption) (*GetRegisteredAgentResponse, error)
	DisconnectVulinboxAgent(ctx context.Context, in *DisconnectVulinboxAgentRequest, opts ...grpc.CallOption) (*Empty, error)
	// CVE
	IsCVEDatabaseReady(ctx context.Context, in *IsCVEDatabaseReadyRequest, opts ...grpc.CallOption) (*IsCVEDatabaseReadyResponse, error)
	UpdateCVEDatabase(ctx context.Context, in *UpdateCVEDatabaseRequest, opts ...grpc.CallOption) (Yak_UpdateCVEDatabaseClient, error)
	ExportsProfileDatabase(ctx context.Context, in *ExportsProfileDatabaseRequest, opts ...grpc.CallOption) (Yak_ExportsProfileDatabaseClient, error)
	ImportsProfileDatabase(ctx context.Context, in *ImportsProfileDatabaseRequest, opts ...grpc.CallOption) (Yak_ImportsProfileDatabaseClient, error)
	QueryCVE(ctx context.Context, in *QueryCVERequest, opts ...grpc.CallOption) (*QueryCVEResponse, error)
	GetCVE(ctx context.Context, in *GetCVERequest, opts ...grpc.CallOption) (*CVEDetailEx, error)
	SaveTextToTemporalFile(ctx context.Context, in *SaveTextToTemporalFileRequest, opts ...grpc.CallOption) (*SaveTextToTemporalFileResponse, error)
	// Screcorder
	IsScrecorderReady(ctx context.Context, in *IsScrecorderReadyRequest, opts ...grpc.CallOption) (*IsScrecorderReadyResponse, error)
	InstallScrecorder(ctx context.Context, in *InstallScrecorderRequest, opts ...grpc.CallOption) (Yak_InstallScrecorderClient, error)
	StartScrecorder(ctx context.Context, in *StartScrecorderRequest, opts ...grpc.CallOption) (Yak_StartScrecorderClient, error)
	QueryScreenRecorders(ctx context.Context, in *QueryScreenRecorderRequest, opts ...grpc.CallOption) (*QueryScreenRecorderResponse, error)
	DeleteScreenRecorders(ctx context.Context, in *QueryScreenRecorderRequest, opts ...grpc.CallOption) (*Empty, error)
	UploadScreenRecorders(ctx context.Context, in *UploadScreenRecorderRequest, opts ...grpc.CallOption) (*Empty, error)
	GetOneScreenRecorders(ctx context.Context, in *GetOneScreenRecorderRequest, opts ...grpc.CallOption) (*ScreenRecorder, error)
	UpdateScreenRecorders(ctx context.Context, in *UpdateScreenRecorderRequest, opts ...grpc.CallOption) (*Empty, error)
	// Vulinbox
	IsVulinboxReady(ctx context.Context, in *IsVulinboxReadyRequest, opts ...grpc.CallOption) (*IsVulinboxReadyResponse, error)
	InstallVulinbox(ctx context.Context, in *InstallVulinboxRequest, opts ...grpc.CallOption) (Yak_InstallVulinboxClient, error)
	StartVulinbox(ctx context.Context, in *StartVulinboxRequest, opts ...grpc.CallOption) (Yak_StartVulinboxClient, error)
	GenQualityInspectionReport(ctx context.Context, in *GenQualityInspectionReportRequest, opts ...grpc.CallOption) (Yak_GenQualityInspectionReportClient, error)
	// 通过他可以构造一个 HTTP 请求
	// 这个请求可能是一个，也可能是一系列
	// 一般用来调试插件等
	HTTPRequestBuilder(ctx context.Context, in *HTTPRequestBuilderParams, opts ...grpc.CallOption) (*HTTPRequestBuilderResponse, error)
	// rpc QueryHTTPRequestBuilder(QueryHTTPRequestBuilderRequest) returns (QueryHTTPRequestBuilderResponse);
	// rpc DeleteHTTPRequestBuilder(DeleteHTTPRequestBuilderRequest) returns (Empty);
	DebugPlugin(ctx context.Context, in *DebugPluginRequest, opts ...grpc.CallOption) (Yak_DebugPluginClient, error)
	SmokingEvaluatePlugin(ctx context.Context, in *SmokingEvaluatePluginRequest, opts ...grpc.CallOption) (*SmokingEvaluatePluginResponse, error)
	GetSystemDefaultDnsServers(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*DefaultDnsServerResponse, error)
	// 诊断网络发生的问题
	DiagnoseNetwork(ctx context.Context, in *DiagnoseNetworkRequest, opts ...grpc.CallOption) (Yak_DiagnoseNetworkClient, error)
	DiagnoseNetworkDNS(ctx context.Context, in *DiagnoseNetworkDNSRequest, opts ...grpc.CallOption) (Yak_DiagnoseNetworkDNSClient, error)
	// Global Network Config
	GetGlobalNetworkConfig(ctx context.Context, in *GetGlobalNetworkConfigRequest, opts ...grpc.CallOption) (*GlobalNetworkConfig, error)
	SetGlobalNetworkConfig(ctx context.Context, in *GlobalNetworkConfig, opts ...grpc.CallOption) (*Empty, error)
	ResetGlobalNetworkConfig(ctx context.Context, in *ResetGlobalNetworkConfigRequest, opts ...grpc.CallOption) (*Empty, error)
	ValidP12PassWord(ctx context.Context, in *ValidP12PassWordRequest, opts ...grpc.CallOption) (*ValidP12PassWordResponse, error)
	RequestYakURL(ctx context.Context, in *RequestYakURLParams, opts ...grpc.CallOption) (*RequestYakURLResponse, error)
	// Wireshark
	GetPcapMetadata(ctx context.Context, in *PcapMetadataRequest, opts ...grpc.CallOption) (*PcapMetadata, error)
	PcapX(ctx context.Context, opts ...grpc.CallOption) (Yak_PcapXClient, error)
	QueryTrafficSession(ctx context.Context, in *QueryTrafficSessionRequest, opts ...grpc.CallOption) (*QueryTrafficSessionResponse, error)
	QueryTrafficPacket(ctx context.Context, in *QueryTrafficPacketRequest, opts ...grpc.CallOption) (*QueryTrafficPacketResponse, error)
	QueryTrafficTCPReassembled(ctx context.Context, in *QueryTrafficTCPReassembledRequest, opts ...grpc.CallOption) (*QueryTrafficTCPReassembledResponse, error)
	DuplexConnection(ctx context.Context, opts ...grpc.CallOption) (Yak_DuplexConnectionClient, error)
}

type yakClient struct {
	cc grpc.ClientConnInterface
}

func NewYakClient(cc grpc.ClientConnInterface) YakClient {
	return &yakClient{cc}
}

func (c *yakClient) Version(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*VersionResponse, error) {
	out := new(VersionResponse)
	err := c.cc.Invoke(ctx, "/ypb.Yak/Version", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) Echo(ctx context.Context, in *EchoRequest, opts ...grpc.CallOption) (*EchoResposne, error) {
	out := new(EchoResposne)
	err := c.cc.Invoke(ctx, "/ypb.Yak/Echo", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) MITM(ctx context.Context, opts ...grpc.CallOption) (Yak_MITMClient, error) {
	stream, err := c.cc.NewStream(ctx, &Yak_ServiceDesc.Streams[0], "/ypb.Yak/MITM", opts...)
	if err != nil {
		return nil, err
	}
	x := &yakMITMClient{stream}
	return x, nil
}

type Yak_MITMClient interface {
	Send(*MITMRequest) error
	Recv() (*MITMResponse, error)
	grpc.ClientStream
}

type yakMITMClient struct {
	grpc.ClientStream
}

func (x *yakMITMClient) Send(m *MITMRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *yakMITMClient) Recv() (*MITMResponse, error) {
	m := new(MITMResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *yakClient) SetMITMFilter(ctx context.Context, in *SetMITMFilterRequest, opts ...grpc.CallOption) (*SetMITMFilterResponse, error) {
	out := new(SetMITMFilterResponse)
	err := c.cc.Invoke(ctx, "/ypb.Yak/SetMITMFilter", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) GetMITMFilter(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*SetMITMFilterRequest, error) {
	out := new(SetMITMFilterRequest)
	err := c.cc.Invoke(ctx, "/ypb.Yak/GetMITMFilter", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) DownloadMITMCert(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*MITMCert, error) {
	out := new(MITMCert)
	err := c.cc.Invoke(ctx, "/ypb.Yak/DownloadMITMCert", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) OpenPort(ctx context.Context, opts ...grpc.CallOption) (Yak_OpenPortClient, error) {
	stream, err := c.cc.NewStream(ctx, &Yak_ServiceDesc.Streams[1], "/ypb.Yak/OpenPort", opts...)
	if err != nil {
		return nil, err
	}
	x := &yakOpenPortClient{stream}
	return x, nil
}

type Yak_OpenPortClient interface {
	Send(*Input) error
	Recv() (*Output, error)
	grpc.ClientStream
}

type yakOpenPortClient struct {
	grpc.ClientStream
}

func (x *yakOpenPortClient) Send(m *Input) error {
	return x.ClientStream.SendMsg(m)
}

func (x *yakOpenPortClient) Recv() (*Output, error) {
	m := new(Output)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *yakClient) Exec(ctx context.Context, in *ExecRequest, opts ...grpc.CallOption) (Yak_ExecClient, error) {
	stream, err := c.cc.NewStream(ctx, &Yak_ServiceDesc.Streams[2], "/ypb.Yak/Exec", opts...)
	if err != nil {
		return nil, err
	}
	x := &yakExecClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Yak_ExecClient interface {
	Recv() (*ExecResult, error)
	grpc.ClientStream
}

type yakExecClient struct {
	grpc.ClientStream
}

func (x *yakExecClient) Recv() (*ExecResult, error) {
	m := new(ExecResult)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *yakClient) QueryExecHistory(ctx context.Context, in *ExecHistoryRequest, opts ...grpc.CallOption) (*ExecHistoryRecordResponse, error) {
	out := new(ExecHistoryRecordResponse)
	err := c.cc.Invoke(ctx, "/ypb.Yak/QueryExecHistory", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) RemoveExecHistory(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, "/ypb.Yak/RemoveExecHistory", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) LoadNucleiTemplates(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, "/ypb.Yak/LoadNucleiTemplates", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) AutoUpdateYakModule(ctx context.Context, in *Empty, opts ...grpc.CallOption) (Yak_AutoUpdateYakModuleClient, error) {
	stream, err := c.cc.NewStream(ctx, &Yak_ServiceDesc.Streams[3], "/ypb.Yak/AutoUpdateYakModule", opts...)
	if err != nil {
		return nil, err
	}
	x := &yakAutoUpdateYakModuleClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Yak_AutoUpdateYakModuleClient interface {
	Recv() (*ExecResult, error)
	grpc.ClientStream
}

type yakAutoUpdateYakModuleClient struct {
	grpc.ClientStream
}

func (x *yakAutoUpdateYakModuleClient) Recv() (*ExecResult, error) {
	m := new(ExecResult)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *yakClient) ExecYakScript(ctx context.Context, in *ExecRequest, opts ...grpc.CallOption) (Yak_ExecYakScriptClient, error) {
	stream, err := c.cc.NewStream(ctx, &Yak_ServiceDesc.Streams[4], "/ypb.Yak/ExecYakScript", opts...)
	if err != nil {
		return nil, err
	}
	x := &yakExecYakScriptClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Yak_ExecYakScriptClient interface {
	Recv() (*ExecResult, error)
	grpc.ClientStream
}

type yakExecYakScriptClient struct {
	grpc.ClientStream
}

func (x *yakExecYakScriptClient) Recv() (*ExecResult, error) {
	m := new(ExecResult)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *yakClient) ExecBatchYakScript(ctx context.Context, in *ExecBatchYakScriptRequest, opts ...grpc.CallOption) (Yak_ExecBatchYakScriptClient, error) {
	stream, err := c.cc.NewStream(ctx, &Yak_ServiceDesc.Streams[5], "/ypb.Yak/ExecBatchYakScript", opts...)
	if err != nil {
		return nil, err
	}
	x := &yakExecBatchYakScriptClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Yak_ExecBatchYakScriptClient interface {
	Recv() (*ExecBatchYakScriptResult, error)
	grpc.ClientStream
}

type yakExecBatchYakScriptClient struct {
	grpc.ClientStream
}

func (x *yakExecBatchYakScriptClient) Recv() (*ExecBatchYakScriptResult, error) {
	m := new(ExecBatchYakScriptResult)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *yakClient) GetExecBatchYakScriptUnfinishedTask(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*GetExecBatchYakScriptUnfinishedTaskResponse, error) {
	out := new(GetExecBatchYakScriptUnfinishedTaskResponse)
	err := c.cc.Invoke(ctx, "/ypb.Yak/GetExecBatchYakScriptUnfinishedTask", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) GetExecBatchYakScriptUnfinishedTaskByUid(ctx context.Context, in *GetExecBatchYakScriptUnfinishedTaskByUidRequest, opts ...grpc.CallOption) (*ExecBatchYakScriptRequest, error) {
	out := new(ExecBatchYakScriptRequest)
	err := c.cc.Invoke(ctx, "/ypb.Yak/GetExecBatchYakScriptUnfinishedTaskByUid", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) PopExecBatchYakScriptUnfinishedTaskByUid(ctx context.Context, in *GetExecBatchYakScriptUnfinishedTaskByUidRequest, opts ...grpc.CallOption) (*ExecBatchYakScriptRequest, error) {
	out := new(ExecBatchYakScriptRequest)
	err := c.cc.Invoke(ctx, "/ypb.Yak/PopExecBatchYakScriptUnfinishedTaskByUid", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) RecoverExecBatchYakScriptUnfinishedTask(ctx context.Context, in *RecoverExecBatchYakScriptUnfinishedTaskRequest, opts ...grpc.CallOption) (Yak_RecoverExecBatchYakScriptUnfinishedTaskClient, error) {
	stream, err := c.cc.NewStream(ctx, &Yak_ServiceDesc.Streams[6], "/ypb.Yak/RecoverExecBatchYakScriptUnfinishedTask", opts...)
	if err != nil {
		return nil, err
	}
	x := &yakRecoverExecBatchYakScriptUnfinishedTaskClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Yak_RecoverExecBatchYakScriptUnfinishedTaskClient interface {
	Recv() (*ExecBatchYakScriptResult, error)
	grpc.ClientStream
}

type yakRecoverExecBatchYakScriptUnfinishedTaskClient struct {
	grpc.ClientStream
}

func (x *yakRecoverExecBatchYakScriptUnfinishedTaskClient) Recv() (*ExecBatchYakScriptResult, error) {
	m := new(ExecBatchYakScriptResult)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *yakClient) QueryYakScript(ctx context.Context, in *QueryYakScriptRequest, opts ...grpc.CallOption) (*QueryYakScriptResponse, error) {
	out := new(QueryYakScriptResponse)
	err := c.cc.Invoke(ctx, "/ypb.Yak/QueryYakScript", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) QueryYakScriptByYakScriptName(ctx context.Context, in *QueryYakScriptRequest, opts ...grpc.CallOption) (Yak_QueryYakScriptByYakScriptNameClient, error) {
	stream, err := c.cc.NewStream(ctx, &Yak_ServiceDesc.Streams[7], "/ypb.Yak/QueryYakScriptByYakScriptName", opts...)
	if err != nil {
		return nil, err
	}
	x := &yakQueryYakScriptByYakScriptNameClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Yak_QueryYakScriptByYakScriptNameClient interface {
	Recv() (*YakScript, error)
	grpc.ClientStream
}

type yakQueryYakScriptByYakScriptNameClient struct {
	grpc.ClientStream
}

func (x *yakQueryYakScriptByYakScriptNameClient) Recv() (*YakScript, error) {
	m := new(YakScript)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *yakClient) SaveYakScript(ctx context.Context, in *YakScript, opts ...grpc.CallOption) (*YakScript, error) {
	out := new(YakScript)
	err := c.cc.Invoke(ctx, "/ypb.Yak/SaveYakScript", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) DeleteYakScript(ctx context.Context, in *DeleteYakScriptRequest, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, "/ypb.Yak/DeleteYakScript", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) GetYakScriptById(ctx context.Context, in *GetYakScriptByIdRequest, opts ...grpc.CallOption) (*YakScript, error) {
	out := new(YakScript)
	err := c.cc.Invoke(ctx, "/ypb.Yak/GetYakScriptById", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) GetYakScriptByName(ctx context.Context, in *GetYakScriptByNameRequest, opts ...grpc.CallOption) (*YakScript, error) {
	out := new(YakScript)
	err := c.cc.Invoke(ctx, "/ypb.Yak/GetYakScriptByName", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) GetYakScriptByOnlineID(ctx context.Context, in *GetYakScriptByOnlineIDRequest, opts ...grpc.CallOption) (*YakScript, error) {
	out := new(YakScript)
	err := c.cc.Invoke(ctx, "/ypb.Yak/GetYakScriptByOnlineID", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) IgnoreYakScript(ctx context.Context, in *DeleteYakScriptRequest, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, "/ypb.Yak/IgnoreYakScript", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) UnIgnoreYakScript(ctx context.Context, in *DeleteYakScriptRequest, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, "/ypb.Yak/UnIgnoreYakScript", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) ExportYakScript(ctx context.Context, in *ExportYakScriptRequest, opts ...grpc.CallOption) (*ExportYakScriptResponse, error) {
	out := new(ExportYakScriptResponse)
	err := c.cc.Invoke(ctx, "/ypb.Yak/ExportYakScript", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) ExecutePacketYakScript(ctx context.Context, in *ExecutePacketYakScriptParams, opts ...grpc.CallOption) (Yak_ExecutePacketYakScriptClient, error) {
	stream, err := c.cc.NewStream(ctx, &Yak_ServiceDesc.Streams[8], "/ypb.Yak/ExecutePacketYakScript", opts...)
	if err != nil {
		return nil, err
	}
	x := &yakExecutePacketYakScriptClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Yak_ExecutePacketYakScriptClient interface {
	Recv() (*ExecResult, error)
	grpc.ClientStream
}

type yakExecutePacketYakScriptClient struct {
	grpc.ClientStream
}

func (x *yakExecutePacketYakScriptClient) Recv() (*ExecResult, error) {
	m := new(ExecResult)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *yakClient) ExecuteBatchPacketYakScript(ctx context.Context, in *ExecuteBatchPacketYakScriptParams, opts ...grpc.CallOption) (Yak_ExecuteBatchPacketYakScriptClient, error) {
	stream, err := c.cc.NewStream(ctx, &Yak_ServiceDesc.Streams[9], "/ypb.Yak/ExecuteBatchPacketYakScript", opts...)
	if err != nil {
		return nil, err
	}
	x := &yakExecuteBatchPacketYakScriptClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Yak_ExecuteBatchPacketYakScriptClient interface {
	Recv() (*ExecBatchYakScriptResult, error)
	grpc.ClientStream
}

type yakExecuteBatchPacketYakScriptClient struct {
	grpc.ClientStream
}

func (x *yakExecuteBatchPacketYakScriptClient) Recv() (*ExecBatchYakScriptResult, error) {
	m := new(ExecBatchYakScriptResult)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *yakClient) GetYakScriptTags(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*GetYakScriptTagsResponse, error) {
	out := new(GetYakScriptTagsResponse)
	err := c.cc.Invoke(ctx, "/ypb.Yak/GetYakScriptTags", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) QueryYakScriptLocalAndUser(ctx context.Context, in *QueryYakScriptLocalAndUserRequest, opts ...grpc.CallOption) (*QueryYakScriptLocalAndUserResponse, error) {
	out := new(QueryYakScriptLocalAndUserResponse)
	err := c.cc.Invoke(ctx, "/ypb.Yak/QueryYakScriptLocalAndUser", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) QueryYakScriptByOnlineGroup(ctx context.Context, in *QueryYakScriptByOnlineGroupRequest, opts ...grpc.CallOption) (*QueryYakScriptLocalAndUserResponse, error) {
	out := new(QueryYakScriptLocalAndUserResponse)
	err := c.cc.Invoke(ctx, "/ypb.Yak/QueryYakScriptByOnlineGroup", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) QueryYakScriptLocalAll(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*QueryYakScriptLocalAndUserResponse, error) {
	out := new(QueryYakScriptLocalAndUserResponse)
	err := c.cc.Invoke(ctx, "/ypb.Yak/QueryYakScriptLocalAll", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) QueryYakScriptByNames(ctx context.Context, in *QueryYakScriptByNamesRequest, opts ...grpc.CallOption) (*QueryYakScriptByNamesResponse, error) {
	out := new(QueryYakScriptByNamesResponse)
	err := c.cc.Invoke(ctx, "/ypb.Yak/QueryYakScriptByNames", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) QueryYakScriptByIsCore(ctx context.Context, in *QueryYakScriptByIsCoreRequest, opts ...grpc.CallOption) (*QueryYakScriptByIsCoreResponse, error) {
	out := new(QueryYakScriptByIsCoreResponse)
	err := c.cc.Invoke(ctx, "/ypb.Yak/QueryYakScriptByIsCore", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) GetHTTPFlowByHash(ctx context.Context, in *GetHTTPFlowByHashRequest, opts ...grpc.CallOption) (*HTTPFlow, error) {
	out := new(HTTPFlow)
	err := c.cc.Invoke(ctx, "/ypb.Yak/GetHTTPFlowByHash", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) GetHTTPFlowById(ctx context.Context, in *GetHTTPFlowByIdRequest, opts ...grpc.CallOption) (*HTTPFlow, error) {
	out := new(HTTPFlow)
	err := c.cc.Invoke(ctx, "/ypb.Yak/GetHTTPFlowById", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) GetHTTPFlowByIds(ctx context.Context, in *GetHTTPFlowByIdsRequest, opts ...grpc.CallOption) (*HTTPFlows, error) {
	out := new(HTTPFlows)
	err := c.cc.Invoke(ctx, "/ypb.Yak/GetHTTPFlowByIds", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) QueryHTTPFlows(ctx context.Context, in *QueryHTTPFlowRequest, opts ...grpc.CallOption) (*QueryHTTPFlowResponse, error) {
	out := new(QueryHTTPFlowResponse)
	err := c.cc.Invoke(ctx, "/ypb.Yak/QueryHTTPFlows", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) DeleteHTTPFlows(ctx context.Context, in *DeleteHTTPFlowRequest, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, "/ypb.Yak/DeleteHTTPFlows", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) SetTagForHTTPFlow(ctx context.Context, in *SetTagForHTTPFlowRequest, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, "/ypb.Yak/SetTagForHTTPFlow", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) QueryHTTPFlowsIds(ctx context.Context, in *QueryHTTPFlowsIdsRequest, opts ...grpc.CallOption) (*QueryHTTPFlowsIdsResponse, error) {
	out := new(QueryHTTPFlowsIdsResponse)
	err := c.cc.Invoke(ctx, "/ypb.Yak/QueryHTTPFlowsIds", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) HTTPFlowsFieldGroup(ctx context.Context, in *HTTPFlowsFieldGroupRequest, opts ...grpc.CallOption) (*HTTPFlowsFieldGroupResponse, error) {
	out := new(HTTPFlowsFieldGroupResponse)
	err := c.cc.Invoke(ctx, "/ypb.Yak/HTTPFlowsFieldGroup", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) HTTPFlowsShare(ctx context.Context, in *HTTPFlowsShareRequest, opts ...grpc.CallOption) (*HTTPFlowsShareResponse, error) {
	out := new(HTTPFlowsShareResponse)
	err := c.cc.Invoke(ctx, "/ypb.Yak/HTTPFlowsShare", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) HTTPFlowsExtract(ctx context.Context, in *HTTPFlowsExtractRequest, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, "/ypb.Yak/HTTPFlowsExtract", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) GetHTTPFlowBare(ctx context.Context, in *HTTPFlowBareRequest, opts ...grpc.CallOption) (*HTTPFlowBareResponse, error) {
	out := new(HTTPFlowBareResponse)
	err := c.cc.Invoke(ctx, "/ypb.Yak/GetHTTPFlowBare", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) ExtractUrl(ctx context.Context, in *FuzzerRequest, opts ...grpc.CallOption) (*ExtractedUrl, error) {
	out := new(ExtractedUrl)
	err := c.cc.Invoke(ctx, "/ypb.Yak/ExtractUrl", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) GetHistoryHTTPFuzzerTask(ctx context.Context, in *GetHistoryHTTPFuzzerTaskRequest, opts ...grpc.CallOption) (*HistoryHTTPFuzzerTaskDetail, error) {
	out := new(HistoryHTTPFuzzerTaskDetail)
	err := c.cc.Invoke(ctx, "/ypb.Yak/GetHistoryHTTPFuzzerTask", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) QueryHistoryHTTPFuzzerTask(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*HistoryHTTPFuzzerTasks, error) {
	out := new(HistoryHTTPFuzzerTasks)
	err := c.cc.Invoke(ctx, "/ypb.Yak/QueryHistoryHTTPFuzzerTask", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) QueryHistoryHTTPFuzzerTaskEx(ctx context.Context, in *QueryHistoryHTTPFuzzerTaskExParams, opts ...grpc.CallOption) (*HistoryHTTPFuzzerTasksResponse, error) {
	out := new(HistoryHTTPFuzzerTasksResponse)
	err := c.cc.Invoke(ctx, "/ypb.Yak/QueryHistoryHTTPFuzzerTaskEx", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) DeleteHistoryHTTPFuzzerTask(ctx context.Context, in *DeleteHistoryHTTPFuzzerTaskRequest, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, "/ypb.Yak/DeleteHistoryHTTPFuzzerTask", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) HTTPFuzzer(ctx context.Context, in *FuzzerRequest, opts ...grpc.CallOption) (Yak_HTTPFuzzerClient, error) {
	stream, err := c.cc.NewStream(ctx, &Yak_ServiceDesc.Streams[10], "/ypb.Yak/HTTPFuzzer", opts...)
	if err != nil {
		return nil, err
	}
	x := &yakHTTPFuzzerClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Yak_HTTPFuzzerClient interface {
	Recv() (*FuzzerResponse, error)
	grpc.ClientStream
}

type yakHTTPFuzzerClient struct {
	grpc.ClientStream
}

func (x *yakHTTPFuzzerClient) Recv() (*FuzzerResponse, error) {
	m := new(FuzzerResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *yakClient) HTTPFuzzerSequence(ctx context.Context, in *FuzzerRequests, opts ...grpc.CallOption) (Yak_HTTPFuzzerSequenceClient, error) {
	stream, err := c.cc.NewStream(ctx, &Yak_ServiceDesc.Streams[11], "/ypb.Yak/HTTPFuzzerSequence", opts...)
	if err != nil {
		return nil, err
	}
	x := &yakHTTPFuzzerSequenceClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Yak_HTTPFuzzerSequenceClient interface {
	Recv() (*FuzzerSequenceResponse, error)
	grpc.ClientStream
}

type yakHTTPFuzzerSequenceClient struct {
	grpc.ClientStream
}

func (x *yakHTTPFuzzerSequenceClient) Recv() (*FuzzerSequenceResponse, error) {
	m := new(FuzzerSequenceResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *yakClient) PreloadHTTPFuzzerParams(ctx context.Context, in *PreloadHTTPFuzzerParamsRequest, opts ...grpc.CallOption) (*PreloadHTTPFuzzerParamsResponse, error) {
	out := new(PreloadHTTPFuzzerParamsResponse)
	err := c.cc.Invoke(ctx, "/ypb.Yak/PreloadHTTPFuzzerParams", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) RenderVariables(ctx context.Context, in *RenderVariablesRequest, opts ...grpc.CallOption) (*RenderVariablesResponse, error) {
	out := new(RenderVariablesResponse)
	err := c.cc.Invoke(ctx, "/ypb.Yak/RenderVariables", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) MatchHTTPResponse(ctx context.Context, in *MatchHTTPResponseParams, opts ...grpc.CallOption) (*MatchHTTPResponseResult, error) {
	out := new(MatchHTTPResponseResult)
	err := c.cc.Invoke(ctx, "/ypb.Yak/MatchHTTPResponse", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) ExtractHTTPResponse(ctx context.Context, in *ExtractHTTPResponseParams, opts ...grpc.CallOption) (*ExtractHTTPResponseResult, error) {
	out := new(ExtractHTTPResponseResult)
	err := c.cc.Invoke(ctx, "/ypb.Yak/ExtractHTTPResponse", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) RedirectRequest(ctx context.Context, in *RedirectRequestParams, opts ...grpc.CallOption) (*FuzzerResponse, error) {
	out := new(FuzzerResponse)
	err := c.cc.Invoke(ctx, "/ypb.Yak/RedirectRequest", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) HTTPRequestMutate(ctx context.Context, in *HTTPRequestMutateParams, opts ...grpc.CallOption) (*MutateResult, error) {
	out := new(MutateResult)
	err := c.cc.Invoke(ctx, "/ypb.Yak/HTTPRequestMutate", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) HTTPResponseMutate(ctx context.Context, in *HTTPResponseMutateParams, opts ...grpc.CallOption) (*MutateResult, error) {
	out := new(MutateResult)
	err := c.cc.Invoke(ctx, "/ypb.Yak/HTTPResponseMutate", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) FixUploadPacket(ctx context.Context, in *FixUploadPacketRequest, opts ...grpc.CallOption) (*FixUploadPacketResponse, error) {
	out := new(FixUploadPacketResponse)
	err := c.cc.Invoke(ctx, "/ypb.Yak/FixUploadPacket", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) IsMultipartFormDataRequest(ctx context.Context, in *FixUploadPacketRequest, opts ...grpc.CallOption) (*IsMultipartFormDataRequestResult, error) {
	out := new(IsMultipartFormDataRequestResult)
	err := c.cc.Invoke(ctx, "/ypb.Yak/IsMultipartFormDataRequest", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) GenerateExtractRule(ctx context.Context, in *GenerateExtractRuleRequest, opts ...grpc.CallOption) (*GenerateExtractRuleResponse, error) {
	out := new(GenerateExtractRuleResponse)
	err := c.cc.Invoke(ctx, "/ypb.Yak/GenerateExtractRule", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) ExtractData(ctx context.Context, opts ...grpc.CallOption) (Yak_ExtractDataClient, error) {
	stream, err := c.cc.NewStream(ctx, &Yak_ServiceDesc.Streams[12], "/ypb.Yak/ExtractData", opts...)
	if err != nil {
		return nil, err
	}
	x := &yakExtractDataClient{stream}
	return x, nil
}

type Yak_ExtractDataClient interface {
	Send(*ExtractDataRequest) error
	Recv() (*ExtractDataResponse, error)
	grpc.ClientStream
}

type yakExtractDataClient struct {
	grpc.ClientStream
}

func (x *yakExtractDataClient) Send(m *ExtractDataRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *yakExtractDataClient) Recv() (*ExtractDataResponse, error) {
	m := new(ExtractDataResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *yakClient) ImportHTTPFuzzerTaskFromYaml(ctx context.Context, in *ImportHTTPFuzzerTaskFromYamlRequest, opts ...grpc.CallOption) (*ImportHTTPFuzzerTaskFromYamlResponse, error) {
	out := new(ImportHTTPFuzzerTaskFromYamlResponse)
	err := c.cc.Invoke(ctx, "/ypb.Yak/ImportHTTPFuzzerTaskFromYaml", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) ExportHTTPFuzzerTaskToYaml(ctx context.Context, in *ExportHTTPFuzzerTaskToYamlRequest, opts ...grpc.CallOption) (*ExportHTTPFuzzerTaskToYamlResponse, error) {
	out := new(ExportHTTPFuzzerTaskToYamlResponse)
	err := c.cc.Invoke(ctx, "/ypb.Yak/ExportHTTPFuzzerTaskToYaml", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) SaveFuzzerLabel(ctx context.Context, in *SaveFuzzerLabelRequest, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, "/ypb.Yak/SaveFuzzerLabel", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) QueryFuzzerLabel(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*QueryFuzzerLabelResponse, error) {
	out := new(QueryFuzzerLabelResponse)
	err := c.cc.Invoke(ctx, "/ypb.Yak/QueryFuzzerLabel", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) DeleteFuzzerLabel(ctx context.Context, in *DeleteFuzzerLabelRequest, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, "/ypb.Yak/DeleteFuzzerLabel", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) QueryHTTPFuzzerResponseByTaskId(ctx context.Context, in *QueryHTTPFuzzerResponseByTaskIdRequest, opts ...grpc.CallOption) (*QueryHTTPFuzzerResponseByTaskIdResponse, error) {
	out := new(QueryHTTPFuzzerResponseByTaskIdResponse)
	err := c.cc.Invoke(ctx, "/ypb.Yak/QueryHTTPFuzzerResponseByTaskId", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) CreateWebsocketFuzzer(ctx context.Context, opts ...grpc.CallOption) (Yak_CreateWebsocketFuzzerClient, error) {
	stream, err := c.cc.NewStream(ctx, &Yak_ServiceDesc.Streams[13], "/ypb.Yak/CreateWebsocketFuzzer", opts...)
	if err != nil {
		return nil, err
	}
	x := &yakCreateWebsocketFuzzerClient{stream}
	return x, nil
}

type Yak_CreateWebsocketFuzzerClient interface {
	Send(*ClientWebsocketRequest) error
	Recv() (*ClientWebsocketResponse, error)
	grpc.ClientStream
}

type yakCreateWebsocketFuzzerClient struct {
	grpc.ClientStream
}

func (x *yakCreateWebsocketFuzzerClient) Send(m *ClientWebsocketRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *yakCreateWebsocketFuzzerClient) Recv() (*ClientWebsocketResponse, error) {
	m := new(ClientWebsocketResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *yakClient) QueryWebsocketFlowByHTTPFlowWebsocketHash(ctx context.Context, in *QueryWebsocketFlowByHTTPFlowWebsocketHashRequest, opts ...grpc.CallOption) (*WebsocketFlows, error) {
	out := new(WebsocketFlows)
	err := c.cc.Invoke(ctx, "/ypb.Yak/QueryWebsocketFlowByHTTPFlowWebsocketHash", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) DeleteWebsocketFlowByHTTPFlowWebsocketHash(ctx context.Context, in *DeleteWebsocketFlowByHTTPFlowWebsocketHashRequest, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, "/ypb.Yak/DeleteWebsocketFlowByHTTPFlowWebsocketHash", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) DeleteWebsocketFlowAll(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, "/ypb.Yak/DeleteWebsocketFlowAll", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) ConvertFuzzerResponseToHTTPFlow(ctx context.Context, in *FuzzerResponse, opts ...grpc.CallOption) (*HTTPFlow, error) {
	out := new(HTTPFlow)
	err := c.cc.Invoke(ctx, "/ypb.Yak/ConvertFuzzerResponseToHTTPFlow", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) StringFuzzer(ctx context.Context, in *StringFuzzerRequest, opts ...grpc.CallOption) (*StringFuzzerResponse, error) {
	out := new(StringFuzzerResponse)
	err := c.cc.Invoke(ctx, "/ypb.Yak/StringFuzzer", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) HTTPRequestAnalyzer(ctx context.Context, in *HTTPRequestAnalysisMaterial, opts ...grpc.CallOption) (*HTTPRequestAnalysis, error) {
	out := new(HTTPRequestAnalysis)
	err := c.cc.Invoke(ctx, "/ypb.Yak/HTTPRequestAnalyzer", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) Codec(ctx context.Context, in *CodecRequest, opts ...grpc.CallOption) (*CodecResponse, error) {
	out := new(CodecResponse)
	err := c.cc.Invoke(ctx, "/ypb.Yak/Codec", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) NewCodec(ctx context.Context, in *CodecRequestFlow, opts ...grpc.CallOption) (*CodecResponse, error) {
	out := new(CodecResponse)
	err := c.cc.Invoke(ctx, "/ypb.Yak/NewCodec", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) PacketPrettifyHelper(ctx context.Context, in *PacketPrettifyHelperRequest, opts ...grpc.CallOption) (*PacketPrettifyHelperResponse, error) {
	out := new(PacketPrettifyHelperResponse)
	err := c.cc.Invoke(ctx, "/ypb.Yak/PacketPrettifyHelper", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) QueryPayload(ctx context.Context, in *QueryPayloadRequest, opts ...grpc.CallOption) (*QueryPayloadResponse, error) {
	out := new(QueryPayloadResponse)
	err := c.cc.Invoke(ctx, "/ypb.Yak/QueryPayload", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) DeletePayloadByGroup(ctx context.Context, in *DeletePayloadByGroupRequest, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, "/ypb.Yak/DeletePayloadByGroup", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) DeletePayload(ctx context.Context, in *DeletePayloadRequest, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, "/ypb.Yak/DeletePayload", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) SavePayload(ctx context.Context, in *SavePayloadRequest, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, "/ypb.Yak/SavePayload", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) SavePayloadStream(ctx context.Context, in *SavePayloadRequest, opts ...grpc.CallOption) (Yak_SavePayloadStreamClient, error) {
	stream, err := c.cc.NewStream(ctx, &Yak_ServiceDesc.Streams[14], "/ypb.Yak/SavePayloadStream", opts...)
	if err != nil {
		return nil, err
	}
	x := &yakSavePayloadStreamClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Yak_SavePayloadStreamClient interface {
	Recv() (*SavePayloadProgress, error)
	grpc.ClientStream
}

type yakSavePayloadStreamClient struct {
	grpc.ClientStream
}

func (x *yakSavePayloadStreamClient) Recv() (*SavePayloadProgress, error) {
	m := new(SavePayloadProgress)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *yakClient) GetAllPayloadGroup(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*GetAllPayloadGroupResponse, error) {
	out := new(GetAllPayloadGroupResponse)
	err := c.cc.Invoke(ctx, "/ypb.Yak/GetAllPayloadGroup", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) UpdatePayload(ctx context.Context, in *UpdatePayloadRequest, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, "/ypb.Yak/UpdatePayload", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) GetAllPayload(ctx context.Context, in *GetAllPayloadRequest, opts ...grpc.CallOption) (*GetAllPayloadResponse, error) {
	out := new(GetAllPayloadResponse)
	err := c.cc.Invoke(ctx, "/ypb.Yak/GetAllPayload", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) GetYakitCompletionRaw(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*YakitCompletionRawResponse, error) {
	out := new(YakitCompletionRawResponse)
	err := c.cc.Invoke(ctx, "/ypb.Yak/GetYakitCompletionRaw", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) GetYakVMBuildInMethodCompletion(ctx context.Context, in *GetYakVMBuildInMethodCompletionRequest, opts ...grpc.CallOption) (*GetYakVMBuildInMethodCompletionResponse, error) {
	out := new(GetYakVMBuildInMethodCompletionResponse)
	err := c.cc.Invoke(ctx, "/ypb.Yak/GetYakVMBuildInMethodCompletion", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) StaticAnalyzeError(ctx context.Context, in *StaticAnalyzeErrorRequest, opts ...grpc.CallOption) (*StaticAnalyzeErrorResponse, error) {
	out := new(StaticAnalyzeErrorResponse)
	err := c.cc.Invoke(ctx, "/ypb.Yak/StaticAnalyzeError", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) YaklangCompileAndFormat(ctx context.Context, in *YaklangCompileAndFormatRequest, opts ...grpc.CallOption) (*YaklangCompileAndFormatResponse, error) {
	out := new(YaklangCompileAndFormatResponse)
	err := c.cc.Invoke(ctx, "/ypb.Yak/YaklangCompileAndFormat", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) PortScan(ctx context.Context, in *PortScanRequest, opts ...grpc.CallOption) (Yak_PortScanClient, error) {
	stream, err := c.cc.NewStream(ctx, &Yak_ServiceDesc.Streams[15], "/ypb.Yak/PortScan", opts...)
	if err != nil {
		return nil, err
	}
	x := &yakPortScanClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Yak_PortScanClient interface {
	Recv() (*ExecResult, error)
	grpc.ClientStream
}

type yakPortScanClient struct {
	grpc.ClientStream
}

func (x *yakPortScanClient) Recv() (*ExecResult, error) {
	m := new(ExecResult)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *yakClient) ViewPortScanCode(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*SimpleScript, error) {
	out := new(SimpleScript)
	err := c.cc.Invoke(ctx, "/ypb.Yak/ViewPortScanCode", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) SimpleDetect(ctx context.Context, in *RecordPortScanRequest, opts ...grpc.CallOption) (Yak_SimpleDetectClient, error) {
	stream, err := c.cc.NewStream(ctx, &Yak_ServiceDesc.Streams[16], "/ypb.Yak/SimpleDetect", opts...)
	if err != nil {
		return nil, err
	}
	x := &yakSimpleDetectClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Yak_SimpleDetectClient interface {
	Recv() (*ExecResult, error)
	grpc.ClientStream
}

type yakSimpleDetectClient struct {
	grpc.ClientStream
}

func (x *yakSimpleDetectClient) Recv() (*ExecResult, error) {
	m := new(ExecResult)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *yakClient) SaveCancelSimpleDetect(ctx context.Context, in *RecordPortScanRequest, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, "/ypb.Yak/SaveCancelSimpleDetect", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) GetSimpleDetectUnfinishedTask(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*GetSimpleDetectUnfinishedTaskResponse, error) {
	out := new(GetSimpleDetectUnfinishedTaskResponse)
	err := c.cc.Invoke(ctx, "/ypb.Yak/GetSimpleDetectUnfinishedTask", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) GetSimpleDetectUnfinishedTaskByUid(ctx context.Context, in *GetExecBatchYakScriptUnfinishedTaskByUidRequest, opts ...grpc.CallOption) (*RecordPortScanRequest, error) {
	out := new(RecordPortScanRequest)
	err := c.cc.Invoke(ctx, "/ypb.Yak/GetSimpleDetectUnfinishedTaskByUid", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) PopSimpleDetectUnfinishedTaskByUid(ctx context.Context, in *GetExecBatchYakScriptUnfinishedTaskByUidRequest, opts ...grpc.CallOption) (*RecordPortScanRequest, error) {
	out := new(RecordPortScanRequest)
	err := c.cc.Invoke(ctx, "/ypb.Yak/PopSimpleDetectUnfinishedTaskByUid", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) RecoverSimpleDetectUnfinishedTask(ctx context.Context, in *RecoverExecBatchYakScriptUnfinishedTaskRequest, opts ...grpc.CallOption) (Yak_RecoverSimpleDetectUnfinishedTaskClient, error) {
	stream, err := c.cc.NewStream(ctx, &Yak_ServiceDesc.Streams[17], "/ypb.Yak/RecoverSimpleDetectUnfinishedTask", opts...)
	if err != nil {
		return nil, err
	}
	x := &yakRecoverSimpleDetectUnfinishedTaskClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Yak_RecoverSimpleDetectUnfinishedTaskClient interface {
	Recv() (*ExecResult, error)
	grpc.ClientStream
}

type yakRecoverSimpleDetectUnfinishedTaskClient struct {
	grpc.ClientStream
}

func (x *yakRecoverSimpleDetectUnfinishedTaskClient) Recv() (*ExecResult, error) {
	m := new(ExecResult)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *yakClient) QueryPorts(ctx context.Context, in *QueryPortsRequest, opts ...grpc.CallOption) (*QueryPortsResponse, error) {
	out := new(QueryPortsResponse)
	err := c.cc.Invoke(ctx, "/ypb.Yak/QueryPorts", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) DeletePorts(ctx context.Context, in *DeletePortsRequest, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, "/ypb.Yak/DeletePorts", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) QueryHosts(ctx context.Context, in *QueryHostsRequest, opts ...grpc.CallOption) (*QueryHostsResponse, error) {
	out := new(QueryHostsResponse)
	err := c.cc.Invoke(ctx, "/ypb.Yak/QueryHosts", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) DeleteHosts(ctx context.Context, in *DeleteHostsRequest, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, "/ypb.Yak/DeleteHosts", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) QueryDomains(ctx context.Context, in *QueryDomainsRequest, opts ...grpc.CallOption) (*QueryDomainsResponse, error) {
	out := new(QueryDomainsResponse)
	err := c.cc.Invoke(ctx, "/ypb.Yak/QueryDomains", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) DeleteDomains(ctx context.Context, in *DeleteDomainsRequest, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, "/ypb.Yak/DeleteDomains", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) QueryPortsGroup(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*QueryPortsGroupResponse, error) {
	out := new(QueryPortsGroupResponse)
	err := c.cc.Invoke(ctx, "/ypb.Yak/QueryPortsGroup", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) UpdateFromYakitResource(ctx context.Context, in *UpdateFromYakitResourceRequest, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, "/ypb.Yak/UpdateFromYakitResource", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) UpdateFromGithub(ctx context.Context, in *UpdateFromGithubRequest, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, "/ypb.Yak/UpdateFromGithub", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) AddToMenu(ctx context.Context, in *AddToMenuRequest, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, "/ypb.Yak/AddToMenu", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) RemoveFromMenu(ctx context.Context, in *RemoveFromMenuRequest, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, "/ypb.Yak/RemoveFromMenu", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) YakScriptIsInMenu(ctx context.Context, in *YakScriptIsInMenuRequest, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, "/ypb.Yak/YakScriptIsInMenu", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) GetAllMenuItem(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*MenuByGroup, error) {
	out := new(MenuByGroup)
	err := c.cc.Invoke(ctx, "/ypb.Yak/GetAllMenuItem", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) DeleteAllMenuItem(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, "/ypb.Yak/DeleteAllMenuItem", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) ImportMenuItem(ctx context.Context, in *ImportMenuItemRequest, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, "/ypb.Yak/ImportMenuItem", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) ExportMenuItem(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*ExportMenuItemResult, error) {
	out := new(ExportMenuItemResult)
	err := c.cc.Invoke(ctx, "/ypb.Yak/ExportMenuItem", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) GetMenuItemById(ctx context.Context, in *GetMenuItemByIdRequest, opts ...grpc.CallOption) (*MenuItem, error) {
	out := new(MenuItem)
	err := c.cc.Invoke(ctx, "/ypb.Yak/GetMenuItemById", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) QueryGroupsByYakScriptId(ctx context.Context, in *QueryGroupsByYakScriptIdRequest, opts ...grpc.CallOption) (*GroupNames, error) {
	out := new(GroupNames)
	err := c.cc.Invoke(ctx, "/ypb.Yak/QueryGroupsByYakScriptId", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) AddMenus(ctx context.Context, in *AddMenuRequest, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, "/ypb.Yak/AddMenus", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) QueryAllMenuItem(ctx context.Context, in *QueryAllMenuItemRequest, opts ...grpc.CallOption) (*MenuByGroup, error) {
	out := new(MenuByGroup)
	err := c.cc.Invoke(ctx, "/ypb.Yak/QueryAllMenuItem", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) DeleteAllMenu(ctx context.Context, in *QueryAllMenuItemRequest, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, "/ypb.Yak/DeleteAllMenu", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) AddToNavigation(ctx context.Context, in *AddToNavigationRequest, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, "/ypb.Yak/AddToNavigation", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) GetAllNavigationItem(ctx context.Context, in *GetAllNavigationRequest, opts ...grpc.CallOption) (*GetAllNavigationItemResponse, error) {
	out := new(GetAllNavigationItemResponse)
	err := c.cc.Invoke(ctx, "/ypb.Yak/GetAllNavigationItem", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) DeleteAllNavigation(ctx context.Context, in *GetAllNavigationRequest, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, "/ypb.Yak/DeleteAllNavigation", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) AddOneNavigation(ctx context.Context, in *AddOneNavigationRequest, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, "/ypb.Yak/AddOneNavigation", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) QueryNavigationGroups(ctx context.Context, in *QueryNavigationGroupsRequest, opts ...grpc.CallOption) (*GroupNames, error) {
	out := new(GroupNames)
	err := c.cc.Invoke(ctx, "/ypb.Yak/QueryNavigationGroups", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) SaveMarkdownDocument(ctx context.Context, in *SaveMarkdownDocumentRequest, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, "/ypb.Yak/SaveMarkdownDocument", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) GetMarkdownDocument(ctx context.Context, in *GetMarkdownDocumentRequest, opts ...grpc.CallOption) (*GetMarkdownDocumentResponse, error) {
	out := new(GetMarkdownDocumentResponse)
	err := c.cc.Invoke(ctx, "/ypb.Yak/GetMarkdownDocument", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) DeleteMarkdownDocument(ctx context.Context, in *GetMarkdownDocumentRequest, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, "/ypb.Yak/DeleteMarkdownDocument", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) StartBasicCrawler(ctx context.Context, in *StartBasicCrawlerRequest, opts ...grpc.CallOption) (*ExecResult, error) {
	out := new(ExecResult)
	err := c.cc.Invoke(ctx, "/ypb.Yak/StartBasicCrawler", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) ViewBasicCrawlerCode(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*SimpleScript, error) {
	out := new(SimpleScript)
	err := c.cc.Invoke(ctx, "/ypb.Yak/ViewBasicCrawlerCode", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) GenerateWebsiteTree(ctx context.Context, in *GenerateWebsiteTreeRequest, opts ...grpc.CallOption) (*GenerateWebsiteTreeResponse, error) {
	out := new(GenerateWebsiteTreeResponse)
	err := c.cc.Invoke(ctx, "/ypb.Yak/GenerateWebsiteTree", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) QueryYakScriptExecResult(ctx context.Context, in *QueryYakScriptExecResultRequest, opts ...grpc.CallOption) (*QueryYakScriptExecResultResponse, error) {
	out := new(QueryYakScriptExecResultResponse)
	err := c.cc.Invoke(ctx, "/ypb.Yak/QueryYakScriptExecResult", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) QueryYakScriptNameInExecResult(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*YakScriptNames, error) {
	out := new(YakScriptNames)
	err := c.cc.Invoke(ctx, "/ypb.Yak/QueryYakScriptNameInExecResult", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) DeleteYakScriptExecResult(ctx context.Context, in *DeleteYakScriptExecResultRequest, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, "/ypb.Yak/DeleteYakScriptExecResult", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) DeleteYakScriptExec(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, "/ypb.Yak/DeleteYakScriptExec", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) StartBrute(ctx context.Context, in *StartBruteParams, opts ...grpc.CallOption) (Yak_StartBruteClient, error) {
	stream, err := c.cc.NewStream(ctx, &Yak_ServiceDesc.Streams[18], "/ypb.Yak/StartBrute", opts...)
	if err != nil {
		return nil, err
	}
	x := &yakStartBruteClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Yak_StartBruteClient interface {
	Recv() (*ExecResult, error)
	grpc.ClientStream
}

type yakStartBruteClient struct {
	grpc.ClientStream
}

func (x *yakStartBruteClient) Recv() (*ExecResult, error) {
	m := new(ExecResult)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *yakClient) GetAvailableBruteTypes(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*GetAvailableBruteTypesResponse, error) {
	out := new(GetAvailableBruteTypesResponse)
	err := c.cc.Invoke(ctx, "/ypb.Yak/GetAvailableBruteTypes", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) GetTunnelServerExternalIP(ctx context.Context, in *GetTunnelServerExternalIPParams, opts ...grpc.CallOption) (*GetTunnelServerExternalIPResponse, error) {
	out := new(GetTunnelServerExternalIPResponse)
	err := c.cc.Invoke(ctx, "/ypb.Yak/GetTunnelServerExternalIP", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) VerifyTunnelServerDomain(ctx context.Context, in *VerifyTunnelServerDomainParams, opts ...grpc.CallOption) (*VerifyTunnelServerDomainResponse, error) {
	out := new(VerifyTunnelServerDomainResponse)
	err := c.cc.Invoke(ctx, "/ypb.Yak/VerifyTunnelServerDomain", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) StartFacades(ctx context.Context, in *StartFacadesParams, opts ...grpc.CallOption) (Yak_StartFacadesClient, error) {
	stream, err := c.cc.NewStream(ctx, &Yak_ServiceDesc.Streams[19], "/ypb.Yak/StartFacades", opts...)
	if err != nil {
		return nil, err
	}
	x := &yakStartFacadesClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Yak_StartFacadesClient interface {
	Recv() (*ExecResult, error)
	grpc.ClientStream
}

type yakStartFacadesClient struct {
	grpc.ClientStream
}

func (x *yakStartFacadesClient) Recv() (*ExecResult, error) {
	m := new(ExecResult)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *yakClient) StartFacadesWithYsoObject(ctx context.Context, in *StartFacadesWithYsoParams, opts ...grpc.CallOption) (Yak_StartFacadesWithYsoObjectClient, error) {
	stream, err := c.cc.NewStream(ctx, &Yak_ServiceDesc.Streams[20], "/ypb.Yak/StartFacadesWithYsoObject", opts...)
	if err != nil {
		return nil, err
	}
	x := &yakStartFacadesWithYsoObjectClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Yak_StartFacadesWithYsoObjectClient interface {
	Recv() (*ExecResult, error)
	grpc.ClientStream
}

type yakStartFacadesWithYsoObjectClient struct {
	grpc.ClientStream
}

func (x *yakStartFacadesWithYsoObjectClient) Recv() (*ExecResult, error) {
	m := new(ExecResult)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *yakClient) ApplyClassToFacades(ctx context.Context, in *ApplyClassToFacadesParamsWithVerbose, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, "/ypb.Yak/ApplyClassToFacades", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) BytesToBase64(ctx context.Context, in *BytesToBase64Request, opts ...grpc.CallOption) (*BytesToBase64Response, error) {
	out := new(BytesToBase64Response)
	err := c.cc.Invoke(ctx, "/ypb.Yak/BytesToBase64", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) ConfigGlobalReverse(ctx context.Context, in *ConfigGlobalReverseParams, opts ...grpc.CallOption) (Yak_ConfigGlobalReverseClient, error) {
	stream, err := c.cc.NewStream(ctx, &Yak_ServiceDesc.Streams[21], "/ypb.Yak/ConfigGlobalReverse", opts...)
	if err != nil {
		return nil, err
	}
	x := &yakConfigGlobalReverseClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Yak_ConfigGlobalReverseClient interface {
	Recv() (*Empty, error)
	grpc.ClientStream
}

type yakConfigGlobalReverseClient struct {
	grpc.ClientStream
}

func (x *yakConfigGlobalReverseClient) Recv() (*Empty, error) {
	m := new(Empty)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *yakClient) AvailableLocalAddr(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*AvailableLocalAddrResponse, error) {
	out := new(AvailableLocalAddrResponse)
	err := c.cc.Invoke(ctx, "/ypb.Yak/AvailableLocalAddr", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) GetGlobalReverseServer(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*GetGlobalReverseServerResponse, error) {
	out := new(GetGlobalReverseServerResponse)
	err := c.cc.Invoke(ctx, "/ypb.Yak/GetGlobalReverseServer", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) QueryRisks(ctx context.Context, in *QueryRisksRequest, opts ...grpc.CallOption) (*QueryRisksResponse, error) {
	out := new(QueryRisksResponse)
	err := c.cc.Invoke(ctx, "/ypb.Yak/QueryRisks", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) QueryRisk(ctx context.Context, in *QueryRiskRequest, opts ...grpc.CallOption) (*Risk, error) {
	out := new(Risk)
	err := c.cc.Invoke(ctx, "/ypb.Yak/QueryRisk", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) DeleteRisk(ctx context.Context, in *DeleteRiskRequest, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, "/ypb.Yak/DeleteRisk", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) QueryAvailableRiskType(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*Fields, error) {
	out := new(Fields)
	err := c.cc.Invoke(ctx, "/ypb.Yak/QueryAvailableRiskType", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) QueryAvailableRiskLevel(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*Fields, error) {
	out := new(Fields)
	err := c.cc.Invoke(ctx, "/ypb.Yak/QueryAvailableRiskLevel", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) QueryRiskTableStats(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*RiskTableStats, error) {
	out := new(RiskTableStats)
	err := c.cc.Invoke(ctx, "/ypb.Yak/QueryRiskTableStats", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) ResetRiskTableStats(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, "/ypb.Yak/ResetRiskTableStats", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) QueryAvailableTarget(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*Fields, error) {
	out := new(Fields)
	err := c.cc.Invoke(ctx, "/ypb.Yak/QueryAvailableTarget", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) QueryNewRisk(ctx context.Context, in *QueryNewRiskRequest, opts ...grpc.CallOption) (*QueryNewRiskResponse, error) {
	out := new(QueryNewRiskResponse)
	err := c.cc.Invoke(ctx, "/ypb.Yak/QueryNewRisk", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) NewRiskRead(ctx context.Context, in *NewRiskReadRequest, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, "/ypb.Yak/NewRiskRead", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) UploadRiskToOnline(ctx context.Context, in *UploadRiskToOnlineRequest, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, "/ypb.Yak/UploadRiskToOnline", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) QueryReports(ctx context.Context, in *QueryReportsRequest, opts ...grpc.CallOption) (*QueryReportsResponse, error) {
	out := new(QueryReportsResponse)
	err := c.cc.Invoke(ctx, "/ypb.Yak/QueryReports", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) QueryReport(ctx context.Context, in *QueryReportRequest, opts ...grpc.CallOption) (*Report, error) {
	out := new(Report)
	err := c.cc.Invoke(ctx, "/ypb.Yak/QueryReport", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) DeleteReport(ctx context.Context, in *DeleteReportRequest, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, "/ypb.Yak/DeleteReport", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) QueryAvailableReportFrom(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*Fields, error) {
	out := new(Fields)
	err := c.cc.Invoke(ctx, "/ypb.Yak/QueryAvailableReportFrom", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) DownloadReport(ctx context.Context, in *DownloadReportRequest, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, "/ypb.Yak/DownloadReport", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) GetAllYsoGadgetOptions(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*YsoOptionsWithVerbose, error) {
	out := new(YsoOptionsWithVerbose)
	err := c.cc.Invoke(ctx, "/ypb.Yak/GetAllYsoGadgetOptions", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) GetAllYsoClassOptions(ctx context.Context, in *YsoOptionsRequerstWithVerbose, opts ...grpc.CallOption) (*YsoOptionsWithVerbose, error) {
	out := new(YsoOptionsWithVerbose)
	err := c.cc.Invoke(ctx, "/ypb.Yak/GetAllYsoClassOptions", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) GetAllYsoClassGeneraterOptions(ctx context.Context, in *YsoOptionsRequerstWithVerbose, opts ...grpc.CallOption) (*YsoClassOptionsResponseWithVerbose, error) {
	out := new(YsoClassOptionsResponseWithVerbose)
	err := c.cc.Invoke(ctx, "/ypb.Yak/GetAllYsoClassGeneraterOptions", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) GenerateYsoCode(ctx context.Context, in *YsoOptionsRequerstWithVerbose, opts ...grpc.CallOption) (*YsoCodeResponse, error) {
	out := new(YsoCodeResponse)
	err := c.cc.Invoke(ctx, "/ypb.Yak/GenerateYsoCode", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) GenerateYsoBytes(ctx context.Context, in *YsoOptionsRequerstWithVerbose, opts ...grpc.CallOption) (*YsoBytesResponse, error) {
	out := new(YsoBytesResponse)
	err := c.cc.Invoke(ctx, "/ypb.Yak/GenerateYsoBytes", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) YsoDump(ctx context.Context, in *YsoBytesObject, opts ...grpc.CallOption) (*YsoDumpResponse, error) {
	out := new(YsoDumpResponse)
	err := c.cc.Invoke(ctx, "/ypb.Yak/YsoDump", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) SetYakBridgeLogServer(ctx context.Context, in *YakDNSLogBridgeAddr, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, "/ypb.Yak/SetYakBridgeLogServer", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) GetCurrentYakBridgeLogServer(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*YakDNSLogBridgeAddr, error) {
	out := new(YakDNSLogBridgeAddr)
	err := c.cc.Invoke(ctx, "/ypb.Yak/GetCurrentYakBridgeLogServer", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) RequireDNSLogDomain(ctx context.Context, in *YakDNSLogBridgeAddr, opts ...grpc.CallOption) (*DNSLogRootDomain, error) {
	out := new(DNSLogRootDomain)
	err := c.cc.Invoke(ctx, "/ypb.Yak/RequireDNSLogDomain", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) RequireDNSLogDomainByScript(ctx context.Context, in *RequireDNSLogDomainByScriptRequest, opts ...grpc.CallOption) (*DNSLogRootDomain, error) {
	out := new(DNSLogRootDomain)
	err := c.cc.Invoke(ctx, "/ypb.Yak/RequireDNSLogDomainByScript", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) QueryDNSLogByToken(ctx context.Context, in *QueryDNSLogByTokenRequest, opts ...grpc.CallOption) (*QueryDNSLogByTokenResponse, error) {
	out := new(QueryDNSLogByTokenResponse)
	err := c.cc.Invoke(ctx, "/ypb.Yak/QueryDNSLogByToken", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) QueryDNSLogTokenByScript(ctx context.Context, in *RequireDNSLogDomainByScriptRequest, opts ...grpc.CallOption) (*QueryDNSLogByTokenResponse, error) {
	out := new(QueryDNSLogByTokenResponse)
	err := c.cc.Invoke(ctx, "/ypb.Yak/QueryDNSLogTokenByScript", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) RequireICMPRandomLength(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*RequireICMPRandomLengthResponse, error) {
	out := new(RequireICMPRandomLengthResponse)
	err := c.cc.Invoke(ctx, "/ypb.Yak/RequireICMPRandomLength", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) QueryICMPTrigger(ctx context.Context, in *QueryICMPTriggerRequest, opts ...grpc.CallOption) (*QueryICMPTriggerResponse, error) {
	out := new(QueryICMPTriggerResponse)
	err := c.cc.Invoke(ctx, "/ypb.Yak/QueryICMPTrigger", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) RequireRandomPortToken(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*RandomPortInfo, error) {
	out := new(RandomPortInfo)
	err := c.cc.Invoke(ctx, "/ypb.Yak/RequireRandomPortToken", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) QueryRandomPortTrigger(ctx context.Context, in *QueryRandomPortTriggerRequest, opts ...grpc.CallOption) (*RandomPortTriggerNotification, error) {
	out := new(RandomPortTriggerNotification)
	err := c.cc.Invoke(ctx, "/ypb.Yak/QueryRandomPortTrigger", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) QuerySupportedDnsLogPlatforms(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*QuerySupportedDnsLogPlatformsResponse, error) {
	out := new(QuerySupportedDnsLogPlatformsResponse)
	err := c.cc.Invoke(ctx, "/ypb.Yak/QuerySupportedDnsLogPlatforms", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) GetAvailableYakScriptTags(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*Fields, error) {
	out := new(Fields)
	err := c.cc.Invoke(ctx, "/ypb.Yak/GetAvailableYakScriptTags", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) ForceUpdateAvailableYakScriptTags(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, "/ypb.Yak/ForceUpdateAvailableYakScriptTags", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) ExecYakitPluginsByYakScriptFilter(ctx context.Context, in *ExecYakitPluginsByYakScriptFilterRequest, opts ...grpc.CallOption) (Yak_ExecYakitPluginsByYakScriptFilterClient, error) {
	stream, err := c.cc.NewStream(ctx, &Yak_ServiceDesc.Streams[22], "/ypb.Yak/ExecYakitPluginsByYakScriptFilter", opts...)
	if err != nil {
		return nil, err
	}
	x := &yakExecYakitPluginsByYakScriptFilterClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Yak_ExecYakitPluginsByYakScriptFilterClient interface {
	Recv() (*ExecResult, error)
	grpc.ClientStream
}

type yakExecYakitPluginsByYakScriptFilterClient struct {
	grpc.ClientStream
}

func (x *yakExecYakitPluginsByYakScriptFilterClient) Recv() (*ExecResult, error) {
	m := new(ExecResult)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *yakClient) GenerateYakCodeByPacket(ctx context.Context, in *GenerateYakCodeByPacketRequest, opts ...grpc.CallOption) (*GenerateYakCodeByPacketResponse, error) {
	out := new(GenerateYakCodeByPacketResponse)
	err := c.cc.Invoke(ctx, "/ypb.Yak/GenerateYakCodeByPacket", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) GenerateCSRFPocByPacket(ctx context.Context, in *GenerateCSRFPocByPacketRequest, opts ...grpc.CallOption) (*GenerateCSRFPocByPacketResponse, error) {
	out := new(GenerateCSRFPocByPacketResponse)
	err := c.cc.Invoke(ctx, "/ypb.Yak/GenerateCSRFPocByPacket", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) ExportMITMReplacerRules(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*ExportMITMReplacerRulesResponse, error) {
	out := new(ExportMITMReplacerRulesResponse)
	err := c.cc.Invoke(ctx, "/ypb.Yak/ExportMITMReplacerRules", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) ImportMITMReplacerRules(ctx context.Context, in *ImportMITMReplacerRulesRequest, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, "/ypb.Yak/ImportMITMReplacerRules", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) GetCurrentRules(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*MITMContentReplacers, error) {
	out := new(MITMContentReplacers)
	err := c.cc.Invoke(ctx, "/ypb.Yak/GetCurrentRules", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) SetCurrentRules(ctx context.Context, in *MITMContentReplacers, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, "/ypb.Yak/SetCurrentRules", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) ExtractDataToFile(ctx context.Context, opts ...grpc.CallOption) (Yak_ExtractDataToFileClient, error) {
	stream, err := c.cc.NewStream(ctx, &Yak_ServiceDesc.Streams[23], "/ypb.Yak/ExtractDataToFile", opts...)
	if err != nil {
		return nil, err
	}
	x := &yakExtractDataToFileClient{stream}
	return x, nil
}

type Yak_ExtractDataToFileClient interface {
	Send(*ExtractDataToFileRequest) error
	Recv() (*ExtractDataToFileResult, error)
	grpc.ClientStream
}

type yakExtractDataToFileClient struct {
	grpc.ClientStream
}

func (x *yakExtractDataToFileClient) Send(m *ExtractDataToFileRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *yakExtractDataToFileClient) Recv() (*ExtractDataToFileResult, error) {
	m := new(ExtractDataToFileResult)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *yakClient) AutoDecode(ctx context.Context, in *AutoDecodeRequest, opts ...grpc.CallOption) (*AutoDecodeResponse, error) {
	out := new(AutoDecodeResponse)
	err := c.cc.Invoke(ctx, "/ypb.Yak/AutoDecode", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) GetSystemProxy(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*GetSystemProxyResult, error) {
	out := new(GetSystemProxyResult)
	err := c.cc.Invoke(ctx, "/ypb.Yak/GetSystemProxy", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) SetSystemProxy(ctx context.Context, in *SetSystemProxyRequest, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, "/ypb.Yak/SetSystemProxy", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) GetKey(ctx context.Context, in *GetKeyRequest, opts ...grpc.CallOption) (*GetKeyResult, error) {
	out := new(GetKeyResult)
	err := c.cc.Invoke(ctx, "/ypb.Yak/GetKey", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) SetKey(ctx context.Context, in *SetKeyRequest, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, "/ypb.Yak/SetKey", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) DelKey(ctx context.Context, in *GetKeyRequest, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, "/ypb.Yak/DelKey", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) GetAllProcessEnvKey(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*GetProcessEnvKeyResult, error) {
	out := new(GetProcessEnvKeyResult)
	err := c.cc.Invoke(ctx, "/ypb.Yak/GetAllProcessEnvKey", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) SetProcessEnvKey(ctx context.Context, in *SetKeyRequest, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, "/ypb.Yak/SetProcessEnvKey", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) GetProjectKey(ctx context.Context, in *GetKeyRequest, opts ...grpc.CallOption) (*GetKeyResult, error) {
	out := new(GetKeyResult)
	err := c.cc.Invoke(ctx, "/ypb.Yak/GetProjectKey", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) SetProjectKey(ctx context.Context, in *SetKeyRequest, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, "/ypb.Yak/SetProjectKey", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) GetOnlineProfile(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*OnlineProfile, error) {
	out := new(OnlineProfile)
	err := c.cc.Invoke(ctx, "/ypb.Yak/GetOnlineProfile", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) SetOnlineProfile(ctx context.Context, in *OnlineProfile, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, "/ypb.Yak/SetOnlineProfile", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) DownloadOnlinePluginById(ctx context.Context, in *DownloadOnlinePluginByIdRequest, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, "/ypb.Yak/DownloadOnlinePluginById", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) DownloadOnlinePluginByIds(ctx context.Context, in *DownloadOnlinePluginByIdsRequest, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, "/ypb.Yak/DownloadOnlinePluginByIds", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) DownloadOnlinePluginAll(ctx context.Context, in *DownloadOnlinePluginByTokenRequest, opts ...grpc.CallOption) (Yak_DownloadOnlinePluginAllClient, error) {
	stream, err := c.cc.NewStream(ctx, &Yak_ServiceDesc.Streams[24], "/ypb.Yak/DownloadOnlinePluginAll", opts...)
	if err != nil {
		return nil, err
	}
	x := &yakDownloadOnlinePluginAllClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Yak_DownloadOnlinePluginAllClient interface {
	Recv() (*DownloadOnlinePluginProgress, error)
	grpc.ClientStream
}

type yakDownloadOnlinePluginAllClient struct {
	grpc.ClientStream
}

func (x *yakDownloadOnlinePluginAllClient) Recv() (*DownloadOnlinePluginProgress, error) {
	m := new(DownloadOnlinePluginProgress)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *yakClient) DeletePluginByUserID(ctx context.Context, in *DeletePluginByUserIDRequest, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, "/ypb.Yak/DeletePluginByUserID", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) DeleteAllLocalPlugins(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, "/ypb.Yak/DeleteAllLocalPlugins", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) GetYakScriptTagsAndType(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*GetYakScriptTagsAndTypeResponse, error) {
	out := new(GetYakScriptTagsAndTypeResponse)
	err := c.cc.Invoke(ctx, "/ypb.Yak/GetYakScriptTagsAndType", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) DeleteLocalPluginsByWhere(ctx context.Context, in *DeleteLocalPluginsByWhereRequest, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, "/ypb.Yak/DeleteLocalPluginsByWhere", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) DownloadOnlinePluginByScriptNames(ctx context.Context, in *DownloadOnlinePluginByScriptNamesRequest, opts ...grpc.CallOption) (*DownloadOnlinePluginByScriptNamesResponse, error) {
	out := new(DownloadOnlinePluginByScriptNamesResponse)
	err := c.cc.Invoke(ctx, "/ypb.Yak/DownloadOnlinePluginByScriptNames", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) ExecPacketScan(ctx context.Context, in *ExecPacketScanRequest, opts ...grpc.CallOption) (Yak_ExecPacketScanClient, error) {
	stream, err := c.cc.NewStream(ctx, &Yak_ServiceDesc.Streams[25], "/ypb.Yak/ExecPacketScan", opts...)
	if err != nil {
		return nil, err
	}
	x := &yakExecPacketScanClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Yak_ExecPacketScanClient interface {
	Recv() (*ExecResult, error)
	grpc.ClientStream
}

type yakExecPacketScanClient struct {
	grpc.ClientStream
}

func (x *yakExecPacketScanClient) Recv() (*ExecResult, error) {
	m := new(ExecResult)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *yakClient) GetEngineDefaultProxy(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*DefaultProxyResult, error) {
	out := new(DefaultProxyResult)
	err := c.cc.Invoke(ctx, "/ypb.Yak/GetEngineDefaultProxy", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) SetEngineDefaultProxy(ctx context.Context, in *DefaultProxyResult, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, "/ypb.Yak/SetEngineDefaultProxy", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) GetMachineID(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*GetMachineIDResponse, error) {
	out := new(GetMachineIDResponse)
	err := c.cc.Invoke(ctx, "/ypb.Yak/GetMachineID", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) GetLicense(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*GetLicenseResponse, error) {
	out := new(GetLicenseResponse)
	err := c.cc.Invoke(ctx, "/ypb.Yak/GetLicense", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) CheckLicense(ctx context.Context, in *CheckLicenseRequest, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, "/ypb.Yak/CheckLicense", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) GetRequestBodyByHTTPFlowID(ctx context.Context, in *DownloadBodyByHTTPFlowIDRequest, opts ...grpc.CallOption) (*Bytes, error) {
	out := new(Bytes)
	err := c.cc.Invoke(ctx, "/ypb.Yak/GetRequestBodyByHTTPFlowID", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) GetResponseBodyByHTTPFlowID(ctx context.Context, in *DownloadBodyByHTTPFlowIDRequest, opts ...grpc.CallOption) (*Bytes, error) {
	out := new(Bytes)
	err := c.cc.Invoke(ctx, "/ypb.Yak/GetResponseBodyByHTTPFlowID", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) GetHTTPPacketBody(ctx context.Context, in *GetHTTPPacketBodyRequest, opts ...grpc.CallOption) (*Bytes, error) {
	out := new(Bytes)
	err := c.cc.Invoke(ctx, "/ypb.Yak/GetHTTPPacketBody", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) RegisterFacadesHTTP(ctx context.Context, in *RegisterFacadesHTTPRequest, opts ...grpc.CallOption) (*RegisterFacadesHTTPResponse, error) {
	out := new(RegisterFacadesHTTPResponse)
	err := c.cc.Invoke(ctx, "/ypb.Yak/RegisterFacadesHTTP", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) ResetAndInvalidUserData(ctx context.Context, in *ResetAndInvalidUserDataRequest, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, "/ypb.Yak/ResetAndInvalidUserData", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) CreateYaklangShell(ctx context.Context, opts ...grpc.CallOption) (Yak_CreateYaklangShellClient, error) {
	stream, err := c.cc.NewStream(ctx, &Yak_ServiceDesc.Streams[26], "/ypb.Yak/CreateYaklangShell", opts...)
	if err != nil {
		return nil, err
	}
	x := &yakCreateYaklangShellClient{stream}
	return x, nil
}

type Yak_CreateYaklangShellClient interface {
	Send(*YaklangShellRequest) error
	Recv() (*YaklangShellResponse, error)
	grpc.ClientStream
}

type yakCreateYaklangShellClient struct {
	grpc.ClientStream
}

func (x *yakCreateYaklangShellClient) Send(m *YaklangShellRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *yakCreateYaklangShellClient) Recv() (*YaklangShellResponse, error) {
	m := new(YaklangShellResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *yakClient) AttachCombinedOutput(ctx context.Context, in *AttachCombinedOutputRequest, opts ...grpc.CallOption) (Yak_AttachCombinedOutputClient, error) {
	stream, err := c.cc.NewStream(ctx, &Yak_ServiceDesc.Streams[27], "/ypb.Yak/AttachCombinedOutput", opts...)
	if err != nil {
		return nil, err
	}
	x := &yakAttachCombinedOutputClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Yak_AttachCombinedOutputClient interface {
	Recv() (*ExecResult, error)
	grpc.ClientStream
}

type yakAttachCombinedOutputClient struct {
	grpc.ClientStream
}

func (x *yakAttachCombinedOutputClient) Recv() (*ExecResult, error) {
	m := new(ExecResult)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *yakClient) IsPrivilegedForNetRaw(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*IsPrivilegedForNetRawResponse, error) {
	out := new(IsPrivilegedForNetRawResponse)
	err := c.cc.Invoke(ctx, "/ypb.Yak/IsPrivilegedForNetRaw", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) PromotePermissionForUserPcap(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, "/ypb.Yak/PromotePermissionForUserPcap", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) SetCurrentProject(ctx context.Context, in *SetCurrentProjectRequest, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, "/ypb.Yak/SetCurrentProject", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) GetCurrentProject(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*ProjectDescription, error) {
	out := new(ProjectDescription)
	err := c.cc.Invoke(ctx, "/ypb.Yak/GetCurrentProject", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) GetProjects(ctx context.Context, in *GetProjectsRequest, opts ...grpc.CallOption) (*GetProjectsResponse, error) {
	out := new(GetProjectsResponse)
	err := c.cc.Invoke(ctx, "/ypb.Yak/GetProjects", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) NewProject(ctx context.Context, in *NewProjectRequest, opts ...grpc.CallOption) (*NewProjectResponse, error) {
	out := new(NewProjectResponse)
	err := c.cc.Invoke(ctx, "/ypb.Yak/NewProject", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) IsProjectNameValid(ctx context.Context, in *IsProjectNameValidRequest, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, "/ypb.Yak/IsProjectNameValid", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) RemoveProject(ctx context.Context, in *RemoveProjectRequest, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, "/ypb.Yak/RemoveProject", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) DeleteProject(ctx context.Context, in *DeleteProjectRequest, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, "/ypb.Yak/DeleteProject", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) GetDefaultProject(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*ProjectDescription, error) {
	out := new(ProjectDescription)
	err := c.cc.Invoke(ctx, "/ypb.Yak/GetDefaultProject", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) QueryProjectDetail(ctx context.Context, in *QueryProjectDetailRequest, opts ...grpc.CallOption) (*ProjectDescription, error) {
	out := new(ProjectDescription)
	err := c.cc.Invoke(ctx, "/ypb.Yak/QueryProjectDetail", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) ExportProject(ctx context.Context, in *ExportProjectRequest, opts ...grpc.CallOption) (Yak_ExportProjectClient, error) {
	stream, err := c.cc.NewStream(ctx, &Yak_ServiceDesc.Streams[28], "/ypb.Yak/ExportProject", opts...)
	if err != nil {
		return nil, err
	}
	x := &yakExportProjectClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Yak_ExportProjectClient interface {
	Recv() (*ProjectIOProgress, error)
	grpc.ClientStream
}

type yakExportProjectClient struct {
	grpc.ClientStream
}

func (x *yakExportProjectClient) Recv() (*ProjectIOProgress, error) {
	m := new(ProjectIOProgress)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *yakClient) ImportProject(ctx context.Context, in *ImportProjectRequest, opts ...grpc.CallOption) (Yak_ImportProjectClient, error) {
	stream, err := c.cc.NewStream(ctx, &Yak_ServiceDesc.Streams[29], "/ypb.Yak/ImportProject", opts...)
	if err != nil {
		return nil, err
	}
	x := &yakImportProjectClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Yak_ImportProjectClient interface {
	Recv() (*ProjectIOProgress, error)
	grpc.ClientStream
}

type yakImportProjectClient struct {
	grpc.ClientStream
}

func (x *yakImportProjectClient) Recv() (*ProjectIOProgress, error) {
	m := new(ProjectIOProgress)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *yakClient) MigrateLegacyDatabase(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, "/ypb.Yak/MigrateLegacyDatabase", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) QueryMITMRuleExtractedData(ctx context.Context, in *QueryMITMRuleExtractedDataRequest, opts ...grpc.CallOption) (*QueryMITMRuleExtractedDataResponse, error) {
	out := new(QueryMITMRuleExtractedDataResponse)
	err := c.cc.Invoke(ctx, "/ypb.Yak/QueryMITMRuleExtractedData", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) ImportChaosMakerRules(ctx context.Context, in *ImportChaosMakerRulesRequest, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, "/ypb.Yak/ImportChaosMakerRules", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) QueryChaosMakerRule(ctx context.Context, in *QueryChaosMakerRuleRequest, opts ...grpc.CallOption) (*QueryChaosMakerRuleResponse, error) {
	out := new(QueryChaosMakerRuleResponse)
	err := c.cc.Invoke(ctx, "/ypb.Yak/QueryChaosMakerRule", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) DeleteChaosMakerRuleByID(ctx context.Context, in *DeleteChaosMakerRuleByIDRequest, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, "/ypb.Yak/DeleteChaosMakerRuleByID", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) ExecuteChaosMakerRule(ctx context.Context, in *ExecuteChaosMakerRuleRequest, opts ...grpc.CallOption) (Yak_ExecuteChaosMakerRuleClient, error) {
	stream, err := c.cc.NewStream(ctx, &Yak_ServiceDesc.Streams[30], "/ypb.Yak/ExecuteChaosMakerRule", opts...)
	if err != nil {
		return nil, err
	}
	x := &yakExecuteChaosMakerRuleClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Yak_ExecuteChaosMakerRuleClient interface {
	Recv() (*ExecResult, error)
	grpc.ClientStream
}

type yakExecuteChaosMakerRuleClient struct {
	grpc.ClientStream
}

func (x *yakExecuteChaosMakerRuleClient) Recv() (*ExecResult, error) {
	m := new(ExecResult)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *yakClient) IsRemoteAddrAvailable(ctx context.Context, in *IsRemoteAddrAvailableRequest, opts ...grpc.CallOption) (*IsRemoteAddrAvailableResponse, error) {
	out := new(IsRemoteAddrAvailableResponse)
	err := c.cc.Invoke(ctx, "/ypb.Yak/IsRemoteAddrAvailable", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) ConnectVulinboxAgent(ctx context.Context, in *IsRemoteAddrAvailableRequest, opts ...grpc.CallOption) (*IsRemoteAddrAvailableResponse, error) {
	out := new(IsRemoteAddrAvailableResponse)
	err := c.cc.Invoke(ctx, "/ypb.Yak/ConnectVulinboxAgent", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) GetRegisteredVulinboxAgent(ctx context.Context, in *GetRegisteredAgentRequest, opts ...grpc.CallOption) (*GetRegisteredAgentResponse, error) {
	out := new(GetRegisteredAgentResponse)
	err := c.cc.Invoke(ctx, "/ypb.Yak/GetRegisteredVulinboxAgent", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) DisconnectVulinboxAgent(ctx context.Context, in *DisconnectVulinboxAgentRequest, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, "/ypb.Yak/DisconnectVulinboxAgent", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) IsCVEDatabaseReady(ctx context.Context, in *IsCVEDatabaseReadyRequest, opts ...grpc.CallOption) (*IsCVEDatabaseReadyResponse, error) {
	out := new(IsCVEDatabaseReadyResponse)
	err := c.cc.Invoke(ctx, "/ypb.Yak/IsCVEDatabaseReady", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) UpdateCVEDatabase(ctx context.Context, in *UpdateCVEDatabaseRequest, opts ...grpc.CallOption) (Yak_UpdateCVEDatabaseClient, error) {
	stream, err := c.cc.NewStream(ctx, &Yak_ServiceDesc.Streams[31], "/ypb.Yak/UpdateCVEDatabase", opts...)
	if err != nil {
		return nil, err
	}
	x := &yakUpdateCVEDatabaseClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Yak_UpdateCVEDatabaseClient interface {
	Recv() (*ExecResult, error)
	grpc.ClientStream
}

type yakUpdateCVEDatabaseClient struct {
	grpc.ClientStream
}

func (x *yakUpdateCVEDatabaseClient) Recv() (*ExecResult, error) {
	m := new(ExecResult)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *yakClient) ExportsProfileDatabase(ctx context.Context, in *ExportsProfileDatabaseRequest, opts ...grpc.CallOption) (Yak_ExportsProfileDatabaseClient, error) {
	stream, err := c.cc.NewStream(ctx, &Yak_ServiceDesc.Streams[32], "/ypb.Yak/ExportsProfileDatabase", opts...)
	if err != nil {
		return nil, err
	}
	x := &yakExportsProfileDatabaseClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Yak_ExportsProfileDatabaseClient interface {
	Recv() (*ExecResult, error)
	grpc.ClientStream
}

type yakExportsProfileDatabaseClient struct {
	grpc.ClientStream
}

func (x *yakExportsProfileDatabaseClient) Recv() (*ExecResult, error) {
	m := new(ExecResult)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *yakClient) ImportsProfileDatabase(ctx context.Context, in *ImportsProfileDatabaseRequest, opts ...grpc.CallOption) (Yak_ImportsProfileDatabaseClient, error) {
	stream, err := c.cc.NewStream(ctx, &Yak_ServiceDesc.Streams[33], "/ypb.Yak/ImportsProfileDatabase", opts...)
	if err != nil {
		return nil, err
	}
	x := &yakImportsProfileDatabaseClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Yak_ImportsProfileDatabaseClient interface {
	Recv() (*ExecResult, error)
	grpc.ClientStream
}

type yakImportsProfileDatabaseClient struct {
	grpc.ClientStream
}

func (x *yakImportsProfileDatabaseClient) Recv() (*ExecResult, error) {
	m := new(ExecResult)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *yakClient) QueryCVE(ctx context.Context, in *QueryCVERequest, opts ...grpc.CallOption) (*QueryCVEResponse, error) {
	out := new(QueryCVEResponse)
	err := c.cc.Invoke(ctx, "/ypb.Yak/QueryCVE", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) GetCVE(ctx context.Context, in *GetCVERequest, opts ...grpc.CallOption) (*CVEDetailEx, error) {
	out := new(CVEDetailEx)
	err := c.cc.Invoke(ctx, "/ypb.Yak/GetCVE", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) SaveTextToTemporalFile(ctx context.Context, in *SaveTextToTemporalFileRequest, opts ...grpc.CallOption) (*SaveTextToTemporalFileResponse, error) {
	out := new(SaveTextToTemporalFileResponse)
	err := c.cc.Invoke(ctx, "/ypb.Yak/SaveTextToTemporalFile", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) IsScrecorderReady(ctx context.Context, in *IsScrecorderReadyRequest, opts ...grpc.CallOption) (*IsScrecorderReadyResponse, error) {
	out := new(IsScrecorderReadyResponse)
	err := c.cc.Invoke(ctx, "/ypb.Yak/IsScrecorderReady", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) InstallScrecorder(ctx context.Context, in *InstallScrecorderRequest, opts ...grpc.CallOption) (Yak_InstallScrecorderClient, error) {
	stream, err := c.cc.NewStream(ctx, &Yak_ServiceDesc.Streams[34], "/ypb.Yak/InstallScrecorder", opts...)
	if err != nil {
		return nil, err
	}
	x := &yakInstallScrecorderClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Yak_InstallScrecorderClient interface {
	Recv() (*ExecResult, error)
	grpc.ClientStream
}

type yakInstallScrecorderClient struct {
	grpc.ClientStream
}

func (x *yakInstallScrecorderClient) Recv() (*ExecResult, error) {
	m := new(ExecResult)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *yakClient) StartScrecorder(ctx context.Context, in *StartScrecorderRequest, opts ...grpc.CallOption) (Yak_StartScrecorderClient, error) {
	stream, err := c.cc.NewStream(ctx, &Yak_ServiceDesc.Streams[35], "/ypb.Yak/StartScrecorder", opts...)
	if err != nil {
		return nil, err
	}
	x := &yakStartScrecorderClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Yak_StartScrecorderClient interface {
	Recv() (*ExecResult, error)
	grpc.ClientStream
}

type yakStartScrecorderClient struct {
	grpc.ClientStream
}

func (x *yakStartScrecorderClient) Recv() (*ExecResult, error) {
	m := new(ExecResult)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *yakClient) QueryScreenRecorders(ctx context.Context, in *QueryScreenRecorderRequest, opts ...grpc.CallOption) (*QueryScreenRecorderResponse, error) {
	out := new(QueryScreenRecorderResponse)
	err := c.cc.Invoke(ctx, "/ypb.Yak/QueryScreenRecorders", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) DeleteScreenRecorders(ctx context.Context, in *QueryScreenRecorderRequest, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, "/ypb.Yak/DeleteScreenRecorders", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) UploadScreenRecorders(ctx context.Context, in *UploadScreenRecorderRequest, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, "/ypb.Yak/UploadScreenRecorders", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) GetOneScreenRecorders(ctx context.Context, in *GetOneScreenRecorderRequest, opts ...grpc.CallOption) (*ScreenRecorder, error) {
	out := new(ScreenRecorder)
	err := c.cc.Invoke(ctx, "/ypb.Yak/GetOneScreenRecorders", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) UpdateScreenRecorders(ctx context.Context, in *UpdateScreenRecorderRequest, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, "/ypb.Yak/UpdateScreenRecorders", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) IsVulinboxReady(ctx context.Context, in *IsVulinboxReadyRequest, opts ...grpc.CallOption) (*IsVulinboxReadyResponse, error) {
	out := new(IsVulinboxReadyResponse)
	err := c.cc.Invoke(ctx, "/ypb.Yak/IsVulinboxReady", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) InstallVulinbox(ctx context.Context, in *InstallVulinboxRequest, opts ...grpc.CallOption) (Yak_InstallVulinboxClient, error) {
	stream, err := c.cc.NewStream(ctx, &Yak_ServiceDesc.Streams[36], "/ypb.Yak/InstallVulinbox", opts...)
	if err != nil {
		return nil, err
	}
	x := &yakInstallVulinboxClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Yak_InstallVulinboxClient interface {
	Recv() (*ExecResult, error)
	grpc.ClientStream
}

type yakInstallVulinboxClient struct {
	grpc.ClientStream
}

func (x *yakInstallVulinboxClient) Recv() (*ExecResult, error) {
	m := new(ExecResult)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *yakClient) StartVulinbox(ctx context.Context, in *StartVulinboxRequest, opts ...grpc.CallOption) (Yak_StartVulinboxClient, error) {
	stream, err := c.cc.NewStream(ctx, &Yak_ServiceDesc.Streams[37], "/ypb.Yak/StartVulinbox", opts...)
	if err != nil {
		return nil, err
	}
	x := &yakStartVulinboxClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Yak_StartVulinboxClient interface {
	Recv() (*ExecResult, error)
	grpc.ClientStream
}

type yakStartVulinboxClient struct {
	grpc.ClientStream
}

func (x *yakStartVulinboxClient) Recv() (*ExecResult, error) {
	m := new(ExecResult)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *yakClient) GenQualityInspectionReport(ctx context.Context, in *GenQualityInspectionReportRequest, opts ...grpc.CallOption) (Yak_GenQualityInspectionReportClient, error) {
	stream, err := c.cc.NewStream(ctx, &Yak_ServiceDesc.Streams[38], "/ypb.Yak/GenQualityInspectionReport", opts...)
	if err != nil {
		return nil, err
	}
	x := &yakGenQualityInspectionReportClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Yak_GenQualityInspectionReportClient interface {
	Recv() (*ExecResult, error)
	grpc.ClientStream
}

type yakGenQualityInspectionReportClient struct {
	grpc.ClientStream
}

func (x *yakGenQualityInspectionReportClient) Recv() (*ExecResult, error) {
	m := new(ExecResult)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *yakClient) HTTPRequestBuilder(ctx context.Context, in *HTTPRequestBuilderParams, opts ...grpc.CallOption) (*HTTPRequestBuilderResponse, error) {
	out := new(HTTPRequestBuilderResponse)
	err := c.cc.Invoke(ctx, "/ypb.Yak/HTTPRequestBuilder", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) DebugPlugin(ctx context.Context, in *DebugPluginRequest, opts ...grpc.CallOption) (Yak_DebugPluginClient, error) {
	stream, err := c.cc.NewStream(ctx, &Yak_ServiceDesc.Streams[39], "/ypb.Yak/DebugPlugin", opts...)
	if err != nil {
		return nil, err
	}
	x := &yakDebugPluginClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Yak_DebugPluginClient interface {
	Recv() (*ExecResult, error)
	grpc.ClientStream
}

type yakDebugPluginClient struct {
	grpc.ClientStream
}

func (x *yakDebugPluginClient) Recv() (*ExecResult, error) {
	m := new(ExecResult)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *yakClient) SmokingEvaluatePlugin(ctx context.Context, in *SmokingEvaluatePluginRequest, opts ...grpc.CallOption) (*SmokingEvaluatePluginResponse, error) {
	out := new(SmokingEvaluatePluginResponse)
	err := c.cc.Invoke(ctx, "/ypb.Yak/SmokingEvaluatePlugin", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) GetSystemDefaultDnsServers(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*DefaultDnsServerResponse, error) {
	out := new(DefaultDnsServerResponse)
	err := c.cc.Invoke(ctx, "/ypb.Yak/GetSystemDefaultDnsServers", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) DiagnoseNetwork(ctx context.Context, in *DiagnoseNetworkRequest, opts ...grpc.CallOption) (Yak_DiagnoseNetworkClient, error) {
	stream, err := c.cc.NewStream(ctx, &Yak_ServiceDesc.Streams[40], "/ypb.Yak/DiagnoseNetwork", opts...)
	if err != nil {
		return nil, err
	}
	x := &yakDiagnoseNetworkClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Yak_DiagnoseNetworkClient interface {
	Recv() (*DiagnoseNetworkResponse, error)
	grpc.ClientStream
}

type yakDiagnoseNetworkClient struct {
	grpc.ClientStream
}

func (x *yakDiagnoseNetworkClient) Recv() (*DiagnoseNetworkResponse, error) {
	m := new(DiagnoseNetworkResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *yakClient) DiagnoseNetworkDNS(ctx context.Context, in *DiagnoseNetworkDNSRequest, opts ...grpc.CallOption) (Yak_DiagnoseNetworkDNSClient, error) {
	stream, err := c.cc.NewStream(ctx, &Yak_ServiceDesc.Streams[41], "/ypb.Yak/DiagnoseNetworkDNS", opts...)
	if err != nil {
		return nil, err
	}
	x := &yakDiagnoseNetworkDNSClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Yak_DiagnoseNetworkDNSClient interface {
	Recv() (*DiagnoseNetworkResponse, error)
	grpc.ClientStream
}

type yakDiagnoseNetworkDNSClient struct {
	grpc.ClientStream
}

func (x *yakDiagnoseNetworkDNSClient) Recv() (*DiagnoseNetworkResponse, error) {
	m := new(DiagnoseNetworkResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *yakClient) GetGlobalNetworkConfig(ctx context.Context, in *GetGlobalNetworkConfigRequest, opts ...grpc.CallOption) (*GlobalNetworkConfig, error) {
	out := new(GlobalNetworkConfig)
	err := c.cc.Invoke(ctx, "/ypb.Yak/GetGlobalNetworkConfig", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) SetGlobalNetworkConfig(ctx context.Context, in *GlobalNetworkConfig, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, "/ypb.Yak/SetGlobalNetworkConfig", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) ResetGlobalNetworkConfig(ctx context.Context, in *ResetGlobalNetworkConfigRequest, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, "/ypb.Yak/ResetGlobalNetworkConfig", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) ValidP12PassWord(ctx context.Context, in *ValidP12PassWordRequest, opts ...grpc.CallOption) (*ValidP12PassWordResponse, error) {
	out := new(ValidP12PassWordResponse)
	err := c.cc.Invoke(ctx, "/ypb.Yak/ValidP12PassWord", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) RequestYakURL(ctx context.Context, in *RequestYakURLParams, opts ...grpc.CallOption) (*RequestYakURLResponse, error) {
	out := new(RequestYakURLResponse)
	err := c.cc.Invoke(ctx, "/ypb.Yak/RequestYakURL", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) GetPcapMetadata(ctx context.Context, in *PcapMetadataRequest, opts ...grpc.CallOption) (*PcapMetadata, error) {
	out := new(PcapMetadata)
	err := c.cc.Invoke(ctx, "/ypb.Yak/GetPcapMetadata", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) PcapX(ctx context.Context, opts ...grpc.CallOption) (Yak_PcapXClient, error) {
	stream, err := c.cc.NewStream(ctx, &Yak_ServiceDesc.Streams[42], "/ypb.Yak/PcapX", opts...)
	if err != nil {
		return nil, err
	}
	x := &yakPcapXClient{stream}
	return x, nil
}

type Yak_PcapXClient interface {
	Send(*PcapXRequest) error
	Recv() (*PcapXResponse, error)
	grpc.ClientStream
}

type yakPcapXClient struct {
	grpc.ClientStream
}

func (x *yakPcapXClient) Send(m *PcapXRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *yakPcapXClient) Recv() (*PcapXResponse, error) {
	m := new(PcapXResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *yakClient) QueryTrafficSession(ctx context.Context, in *QueryTrafficSessionRequest, opts ...grpc.CallOption) (*QueryTrafficSessionResponse, error) {
	out := new(QueryTrafficSessionResponse)
	err := c.cc.Invoke(ctx, "/ypb.Yak/QueryTrafficSession", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) QueryTrafficPacket(ctx context.Context, in *QueryTrafficPacketRequest, opts ...grpc.CallOption) (*QueryTrafficPacketResponse, error) {
	out := new(QueryTrafficPacketResponse)
	err := c.cc.Invoke(ctx, "/ypb.Yak/QueryTrafficPacket", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) QueryTrafficTCPReassembled(ctx context.Context, in *QueryTrafficTCPReassembledRequest, opts ...grpc.CallOption) (*QueryTrafficTCPReassembledResponse, error) {
	out := new(QueryTrafficTCPReassembledResponse)
	err := c.cc.Invoke(ctx, "/ypb.Yak/QueryTrafficTCPReassembled", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) DuplexConnection(ctx context.Context, opts ...grpc.CallOption) (Yak_DuplexConnectionClient, error) {
	stream, err := c.cc.NewStream(ctx, &Yak_ServiceDesc.Streams[43], "/ypb.Yak/DuplexConnection", opts...)
	if err != nil {
		return nil, err
	}
	x := &yakDuplexConnectionClient{stream}
	return x, nil
}

type Yak_DuplexConnectionClient interface {
	Send(*DuplexConnectionRequest) error
	Recv() (*DuplexConnectionResponse, error)
	grpc.ClientStream
}

type yakDuplexConnectionClient struct {
	grpc.ClientStream
}

func (x *yakDuplexConnectionClient) Send(m *DuplexConnectionRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *yakDuplexConnectionClient) Recv() (*DuplexConnectionResponse, error) {
	m := new(DuplexConnectionResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// YakServer is the server API for Yak service.
// All implementations must embed UnimplementedYakServer
// for forward compatibility
type YakServer interface {
	// version
	Version(context.Context, *Empty) (*VersionResponse, error)
	// echo 通常用于测试服务是否通畅
	Echo(context.Context, *EchoRequest) (*EchoResposne, error)
	// 中间人劫持
	MITM(Yak_MITMServer) error
	SetMITMFilter(context.Context, *SetMITMFilterRequest) (*SetMITMFilterResponse, error)
	GetMITMFilter(context.Context, *Empty) (*SetMITMFilterRequest, error)
	DownloadMITMCert(context.Context, *Empty) (*MITMCert, error)
	// 开启端口
	OpenPort(Yak_OpenPortServer) error
	// Exec
	Exec(*ExecRequest, Yak_ExecServer) error
	QueryExecHistory(context.Context, *ExecHistoryRequest) (*ExecHistoryRecordResponse, error)
	RemoveExecHistory(context.Context, *Empty) (*Empty, error)
	LoadNucleiTemplates(context.Context, *Empty) (*Empty, error)
	AutoUpdateYakModule(*Empty, Yak_AutoUpdateYakModuleServer) error
	ExecYakScript(*ExecRequest, Yak_ExecYakScriptServer) error
	ExecBatchYakScript(*ExecBatchYakScriptRequest, Yak_ExecBatchYakScriptServer) error
	GetExecBatchYakScriptUnfinishedTask(context.Context, *Empty) (*GetExecBatchYakScriptUnfinishedTaskResponse, error)
	GetExecBatchYakScriptUnfinishedTaskByUid(context.Context, *GetExecBatchYakScriptUnfinishedTaskByUidRequest) (*ExecBatchYakScriptRequest, error)
	PopExecBatchYakScriptUnfinishedTaskByUid(context.Context, *GetExecBatchYakScriptUnfinishedTaskByUidRequest) (*ExecBatchYakScriptRequest, error)
	RecoverExecBatchYakScriptUnfinishedTask(*RecoverExecBatchYakScriptUnfinishedTaskRequest, Yak_RecoverExecBatchYakScriptUnfinishedTaskServer) error
	// yakScript
	QueryYakScript(context.Context, *QueryYakScriptRequest) (*QueryYakScriptResponse, error)
	QueryYakScriptByYakScriptName(*QueryYakScriptRequest, Yak_QueryYakScriptByYakScriptNameServer) error
	SaveYakScript(context.Context, *YakScript) (*YakScript, error)
	DeleteYakScript(context.Context, *DeleteYakScriptRequest) (*Empty, error)
	GetYakScriptById(context.Context, *GetYakScriptByIdRequest) (*YakScript, error)
	GetYakScriptByName(context.Context, *GetYakScriptByNameRequest) (*YakScript, error)
	GetYakScriptByOnlineID(context.Context, *GetYakScriptByOnlineIDRequest) (*YakScript, error)
	IgnoreYakScript(context.Context, *DeleteYakScriptRequest) (*Empty, error)
	UnIgnoreYakScript(context.Context, *DeleteYakScriptRequest) (*Empty, error)
	ExportYakScript(context.Context, *ExportYakScriptRequest) (*ExportYakScriptResponse, error)
	ExecutePacketYakScript(*ExecutePacketYakScriptParams, Yak_ExecutePacketYakScriptServer) error
	ExecuteBatchPacketYakScript(*ExecuteBatchPacketYakScriptParams, Yak_ExecuteBatchPacketYakScriptServer) error
	GetYakScriptTags(context.Context, *Empty) (*GetYakScriptTagsResponse, error)
	QueryYakScriptLocalAndUser(context.Context, *QueryYakScriptLocalAndUserRequest) (*QueryYakScriptLocalAndUserResponse, error)
	QueryYakScriptByOnlineGroup(context.Context, *QueryYakScriptByOnlineGroupRequest) (*QueryYakScriptLocalAndUserResponse, error)
	QueryYakScriptLocalAll(context.Context, *Empty) (*QueryYakScriptLocalAndUserResponse, error)
	QueryYakScriptByNames(context.Context, *QueryYakScriptByNamesRequest) (*QueryYakScriptByNamesResponse, error)
	QueryYakScriptByIsCore(context.Context, *QueryYakScriptByIsCoreRequest) (*QueryYakScriptByIsCoreResponse, error)
	// HTTPFlow
	GetHTTPFlowByHash(context.Context, *GetHTTPFlowByHashRequest) (*HTTPFlow, error)
	GetHTTPFlowById(context.Context, *GetHTTPFlowByIdRequest) (*HTTPFlow, error)
	GetHTTPFlowByIds(context.Context, *GetHTTPFlowByIdsRequest) (*HTTPFlows, error)
	QueryHTTPFlows(context.Context, *QueryHTTPFlowRequest) (*QueryHTTPFlowResponse, error)
	DeleteHTTPFlows(context.Context, *DeleteHTTPFlowRequest) (*Empty, error)
	SetTagForHTTPFlow(context.Context, *SetTagForHTTPFlowRequest) (*Empty, error)
	QueryHTTPFlowsIds(context.Context, *QueryHTTPFlowsIdsRequest) (*QueryHTTPFlowsIdsResponse, error)
	HTTPFlowsFieldGroup(context.Context, *HTTPFlowsFieldGroupRequest) (*HTTPFlowsFieldGroupResponse, error)
	HTTPFlowsShare(context.Context, *HTTPFlowsShareRequest) (*HTTPFlowsShareResponse, error)
	HTTPFlowsExtract(context.Context, *HTTPFlowsExtractRequest) (*Empty, error)
	GetHTTPFlowBare(context.Context, *HTTPFlowBareRequest) (*HTTPFlowBareResponse, error)
	// 从一个 FuzzerRequest 中提取 Url
	ExtractUrl(context.Context, *FuzzerRequest) (*ExtractedUrl, error)
	// Fuzzer
	GetHistoryHTTPFuzzerTask(context.Context, *GetHistoryHTTPFuzzerTaskRequest) (*HistoryHTTPFuzzerTaskDetail, error)
	QueryHistoryHTTPFuzzerTask(context.Context, *Empty) (*HistoryHTTPFuzzerTasks, error)
	QueryHistoryHTTPFuzzerTaskEx(context.Context, *QueryHistoryHTTPFuzzerTaskExParams) (*HistoryHTTPFuzzerTasksResponse, error)
	DeleteHistoryHTTPFuzzerTask(context.Context, *DeleteHistoryHTTPFuzzerTaskRequest) (*Empty, error)
	HTTPFuzzer(*FuzzerRequest, Yak_HTTPFuzzerServer) error
	HTTPFuzzerSequence(*FuzzerRequests, Yak_HTTPFuzzerSequenceServer) error
	PreloadHTTPFuzzerParams(context.Context, *PreloadHTTPFuzzerParamsRequest) (*PreloadHTTPFuzzerParamsResponse, error)
	RenderVariables(context.Context, *RenderVariablesRequest) (*RenderVariablesResponse, error)
	MatchHTTPResponse(context.Context, *MatchHTTPResponseParams) (*MatchHTTPResponseResult, error)
	ExtractHTTPResponse(context.Context, *ExtractHTTPResponseParams) (*ExtractHTTPResponseResult, error)
	RedirectRequest(context.Context, *RedirectRequestParams) (*FuzzerResponse, error)
	HTTPRequestMutate(context.Context, *HTTPRequestMutateParams) (*MutateResult, error)
	HTTPResponseMutate(context.Context, *HTTPResponseMutateParams) (*MutateResult, error)
	FixUploadPacket(context.Context, *FixUploadPacketRequest) (*FixUploadPacketResponse, error)
	IsMultipartFormDataRequest(context.Context, *FixUploadPacketRequest) (*IsMultipartFormDataRequestResult, error)
	GenerateExtractRule(context.Context, *GenerateExtractRuleRequest) (*GenerateExtractRuleResponse, error)
	ExtractData(Yak_ExtractDataServer) error
	ImportHTTPFuzzerTaskFromYaml(context.Context, *ImportHTTPFuzzerTaskFromYamlRequest) (*ImportHTTPFuzzerTaskFromYamlResponse, error)
	ExportHTTPFuzzerTaskToYaml(context.Context, *ExportHTTPFuzzerTaskToYamlRequest) (*ExportHTTPFuzzerTaskToYamlResponse, error)
	SaveFuzzerLabel(context.Context, *SaveFuzzerLabelRequest) (*Empty, error)
	QueryFuzzerLabel(context.Context, *Empty) (*QueryFuzzerLabelResponse, error)
	DeleteFuzzerLabel(context.Context, *DeleteFuzzerLabelRequest) (*Empty, error)
	// HTTPFuzzerResponse
	// 这个挺特殊的，因为数据包太多了，会卡，所以后端会保存一份，通过这个接口做缓存查询
	QueryHTTPFuzzerResponseByTaskId(context.Context, *QueryHTTPFuzzerResponseByTaskIdRequest) (*QueryHTTPFuzzerResponseByTaskIdResponse, error)
	// WebSocket
	CreateWebsocketFuzzer(Yak_CreateWebsocketFuzzerServer) error
	QueryWebsocketFlowByHTTPFlowWebsocketHash(context.Context, *QueryWebsocketFlowByHTTPFlowWebsocketHashRequest) (*WebsocketFlows, error)
	DeleteWebsocketFlowByHTTPFlowWebsocketHash(context.Context, *DeleteWebsocketFlowByHTTPFlowWebsocketHashRequest) (*Empty, error)
	DeleteWebsocketFlowAll(context.Context, *Empty) (*Empty, error)
	// FuzzerResponse 对象转 HTTPFlow：以便分析和模糊测试
	ConvertFuzzerResponseToHTTPFlow(context.Context, *FuzzerResponse) (*HTTPFlow, error)
	// 渲染 Fuzzer 模版
	StringFuzzer(context.Context, *StringFuzzerRequest) (*StringFuzzerResponse, error)
	// 分析一个 HTTP 请求详情
	HTTPRequestAnalyzer(context.Context, *HTTPRequestAnalysisMaterial) (*HTTPRequestAnalysis, error)
	// 编码解码
	Codec(context.Context, *CodecRequest) (*CodecResponse, error)
	NewCodec(context.Context, *CodecRequestFlow) (*CodecResponse, error)
	PacketPrettifyHelper(context.Context, *PacketPrettifyHelperRequest) (*PacketPrettifyHelperResponse, error)
	// Payload 相关接口
	QueryPayload(context.Context, *QueryPayloadRequest) (*QueryPayloadResponse, error)
	DeletePayloadByGroup(context.Context, *DeletePayloadByGroupRequest) (*Empty, error)
	DeletePayload(context.Context, *DeletePayloadRequest) (*Empty, error)
	SavePayload(context.Context, *SavePayloadRequest) (*Empty, error)
	SavePayloadStream(*SavePayloadRequest, Yak_SavePayloadStreamServer) error
	GetAllPayloadGroup(context.Context, *Empty) (*GetAllPayloadGroupResponse, error)
	UpdatePayload(context.Context, *UpdatePayloadRequest) (*Empty, error)
	GetAllPayload(context.Context, *GetAllPayloadRequest) (*GetAllPayloadResponse, error)
	// 自动生成补全
	GetYakitCompletionRaw(context.Context, *Empty) (*YakitCompletionRawResponse, error)
	GetYakVMBuildInMethodCompletion(context.Context, *GetYakVMBuildInMethodCompletionRequest) (*GetYakVMBuildInMethodCompletionResponse, error)
	StaticAnalyzeError(context.Context, *StaticAnalyzeErrorRequest) (*StaticAnalyzeErrorResponse, error)
	YaklangCompileAndFormat(context.Context, *YaklangCompileAndFormatRequest) (*YaklangCompileAndFormatResponse, error)
	// 端口扫描的封装
	PortScan(*PortScanRequest, Yak_PortScanServer) error
	ViewPortScanCode(context.Context, *Empty) (*SimpleScript, error)
	SimpleDetect(*RecordPortScanRequest, Yak_SimpleDetectServer) error
	SaveCancelSimpleDetect(context.Context, *RecordPortScanRequest) (*Empty, error)
	GetSimpleDetectUnfinishedTask(context.Context, *Empty) (*GetSimpleDetectUnfinishedTaskResponse, error)
	GetSimpleDetectUnfinishedTaskByUid(context.Context, *GetExecBatchYakScriptUnfinishedTaskByUidRequest) (*RecordPortScanRequest, error)
	PopSimpleDetectUnfinishedTaskByUid(context.Context, *GetExecBatchYakScriptUnfinishedTaskByUidRequest) (*RecordPortScanRequest, error)
	RecoverSimpleDetectUnfinishedTask(*RecoverExecBatchYakScriptUnfinishedTaskRequest, Yak_RecoverSimpleDetectUnfinishedTaskServer) error
	// 资产管理
	QueryPorts(context.Context, *QueryPortsRequest) (*QueryPortsResponse, error)
	DeletePorts(context.Context, *DeletePortsRequest) (*Empty, error)
	QueryHosts(context.Context, *QueryHostsRequest) (*QueryHostsResponse, error)
	DeleteHosts(context.Context, *DeleteHostsRequest) (*Empty, error)
	QueryDomains(context.Context, *QueryDomainsRequest) (*QueryDomainsResponse, error)
	DeleteDomains(context.Context, *DeleteDomainsRequest) (*Empty, error)
	QueryPortsGroup(context.Context, *Empty) (*QueryPortsGroupResponse, error)
	// Yakit Store
	UpdateFromYakitResource(context.Context, *UpdateFromYakitResourceRequest) (*Empty, error)
	UpdateFromGithub(context.Context, *UpdateFromGithubRequest) (*Empty, error)
	// Menu
	AddToMenu(context.Context, *AddToMenuRequest) (*Empty, error)
	RemoveFromMenu(context.Context, *RemoveFromMenuRequest) (*Empty, error)
	YakScriptIsInMenu(context.Context, *YakScriptIsInMenuRequest) (*Empty, error)
	GetAllMenuItem(context.Context, *Empty) (*MenuByGroup, error)
	DeleteAllMenuItem(context.Context, *Empty) (*Empty, error)
	ImportMenuItem(context.Context, *ImportMenuItemRequest) (*Empty, error)
	ExportMenuItem(context.Context, *Empty) (*ExportMenuItemResult, error)
	GetMenuItemById(context.Context, *GetMenuItemByIdRequest) (*MenuItem, error)
	QueryGroupsByYakScriptId(context.Context, *QueryGroupsByYakScriptIdRequest) (*GroupNames, error)
	AddMenus(context.Context, *AddMenuRequest) (*Empty, error)
	QueryAllMenuItem(context.Context, *QueryAllMenuItemRequest) (*MenuByGroup, error)
	DeleteAllMenu(context.Context, *QueryAllMenuItemRequest) (*Empty, error)
	// NewMenu
	AddToNavigation(context.Context, *AddToNavigationRequest) (*Empty, error)
	GetAllNavigationItem(context.Context, *GetAllNavigationRequest) (*GetAllNavigationItemResponse, error)
	DeleteAllNavigation(context.Context, *GetAllNavigationRequest) (*Empty, error)
	AddOneNavigation(context.Context, *AddOneNavigationRequest) (*Empty, error)
	QueryNavigationGroups(context.Context, *QueryNavigationGroupsRequest) (*GroupNames, error)
	// document
	SaveMarkdownDocument(context.Context, *SaveMarkdownDocumentRequest) (*Empty, error)
	GetMarkdownDocument(context.Context, *GetMarkdownDocumentRequest) (*GetMarkdownDocumentResponse, error)
	DeleteMarkdownDocument(context.Context, *GetMarkdownDocumentRequest) (*Empty, error)
	// Crawler
	StartBasicCrawler(context.Context, *StartBasicCrawlerRequest) (*ExecResult, error)
	ViewBasicCrawlerCode(context.Context, *Empty) (*SimpleScript, error)
	GenerateWebsiteTree(context.Context, *GenerateWebsiteTreeRequest) (*GenerateWebsiteTreeResponse, error)
	// 对插件结果的操作
	QueryYakScriptExecResult(context.Context, *QueryYakScriptExecResultRequest) (*QueryYakScriptExecResultResponse, error)
	QueryYakScriptNameInExecResult(context.Context, *Empty) (*YakScriptNames, error)
	DeleteYakScriptExecResult(context.Context, *DeleteYakScriptExecResultRequest) (*Empty, error)
	DeleteYakScriptExec(context.Context, *Empty) (*Empty, error)
	// Bruter
	StartBrute(*StartBruteParams, Yak_StartBruteServer) error
	GetAvailableBruteTypes(context.Context, *Empty) (*GetAvailableBruteTypesResponse, error)
	// Tunnel Server RMI/DNSLog
	GetTunnelServerExternalIP(context.Context, *GetTunnelServerExternalIPParams) (*GetTunnelServerExternalIPResponse, error)
	VerifyTunnelServerDomain(context.Context, *VerifyTunnelServerDomainParams) (*VerifyTunnelServerDomainResponse, error)
	StartFacades(*StartFacadesParams, Yak_StartFacadesServer) error
	StartFacadesWithYsoObject(*StartFacadesWithYsoParams, Yak_StartFacadesWithYsoObjectServer) error
	ApplyClassToFacades(context.Context, *ApplyClassToFacadesParamsWithVerbose) (*Empty, error)
	BytesToBase64(context.Context, *BytesToBase64Request) (*BytesToBase64Response, error)
	ConfigGlobalReverse(*ConfigGlobalReverseParams, Yak_ConfigGlobalReverseServer) error
	AvailableLocalAddr(context.Context, *Empty) (*AvailableLocalAddrResponse, error)
	GetGlobalReverseServer(context.Context, *Empty) (*GetGlobalReverseServerResponse, error)
	// Risk
	QueryRisks(context.Context, *QueryRisksRequest) (*QueryRisksResponse, error)
	QueryRisk(context.Context, *QueryRiskRequest) (*Risk, error)
	DeleteRisk(context.Context, *DeleteRiskRequest) (*Empty, error)
	QueryAvailableRiskType(context.Context, *Empty) (*Fields, error)
	QueryAvailableRiskLevel(context.Context, *Empty) (*Fields, error)
	QueryRiskTableStats(context.Context, *Empty) (*RiskTableStats, error)
	ResetRiskTableStats(context.Context, *Empty) (*Empty, error)
	QueryAvailableTarget(context.Context, *Empty) (*Fields, error)
	QueryNewRisk(context.Context, *QueryNewRiskRequest) (*QueryNewRiskResponse, error)
	NewRiskRead(context.Context, *NewRiskReadRequest) (*Empty, error)
	UploadRiskToOnline(context.Context, *UploadRiskToOnlineRequest) (*Empty, error)
	// Report
	QueryReports(context.Context, *QueryReportsRequest) (*QueryReportsResponse, error)
	QueryReport(context.Context, *QueryReportRequest) (*Report, error)
	DeleteReport(context.Context, *DeleteReportRequest) (*Empty, error)
	QueryAvailableReportFrom(context.Context, *Empty) (*Fields, error)
	DownloadReport(context.Context, *DownloadReportRequest) (*Empty, error)
	//Yso
	GetAllYsoGadgetOptions(context.Context, *Empty) (*YsoOptionsWithVerbose, error)
	GetAllYsoClassOptions(context.Context, *YsoOptionsRequerstWithVerbose) (*YsoOptionsWithVerbose, error)
	GetAllYsoClassGeneraterOptions(context.Context, *YsoOptionsRequerstWithVerbose) (*YsoClassOptionsResponseWithVerbose, error)
	GenerateYsoCode(context.Context, *YsoOptionsRequerstWithVerbose) (*YsoCodeResponse, error)
	GenerateYsoBytes(context.Context, *YsoOptionsRequerstWithVerbose) (*YsoBytesResponse, error)
	YsoDump(context.Context, *YsoBytesObject) (*YsoDumpResponse, error)
	// DNSLog / ICMP / RandomTrigger
	SetYakBridgeLogServer(context.Context, *YakDNSLogBridgeAddr) (*Empty, error)
	GetCurrentYakBridgeLogServer(context.Context, *Empty) (*YakDNSLogBridgeAddr, error)
	RequireDNSLogDomain(context.Context, *YakDNSLogBridgeAddr) (*DNSLogRootDomain, error)
	RequireDNSLogDomainByScript(context.Context, *RequireDNSLogDomainByScriptRequest) (*DNSLogRootDomain, error)
	QueryDNSLogByToken(context.Context, *QueryDNSLogByTokenRequest) (*QueryDNSLogByTokenResponse, error)
	QueryDNSLogTokenByScript(context.Context, *RequireDNSLogDomainByScriptRequest) (*QueryDNSLogByTokenResponse, error)
	RequireICMPRandomLength(context.Context, *Empty) (*RequireICMPRandomLengthResponse, error)
	QueryICMPTrigger(context.Context, *QueryICMPTriggerRequest) (*QueryICMPTriggerResponse, error)
	RequireRandomPortToken(context.Context, *Empty) (*RandomPortInfo, error)
	QueryRandomPortTrigger(context.Context, *QueryRandomPortTriggerRequest) (*RandomPortTriggerNotification, error)
	QuerySupportedDnsLogPlatforms(context.Context, *Empty) (*QuerySupportedDnsLogPlatformsResponse, error)
	// 获取 Tags
	GetAvailableYakScriptTags(context.Context, *Empty) (*Fields, error)
	ForceUpdateAvailableYakScriptTags(context.Context, *Empty) (*Empty, error)
	// 通用的漏洞检测技术方案
	ExecYakitPluginsByYakScriptFilter(*ExecYakitPluginsByYakScriptFilterRequest, Yak_ExecYakitPluginsByYakScriptFilterServer) error
	// GenerateYakCodeByPacket
	GenerateYakCodeByPacket(context.Context, *GenerateYakCodeByPacketRequest) (*GenerateYakCodeByPacketResponse, error)
	// CSRF Generator
	GenerateCSRFPocByPacket(context.Context, *GenerateCSRFPocByPacketRequest) (*GenerateCSRFPocByPacketResponse, error)
	// MITM 衍生功能：
	// Replacers 管理
	ExportMITMReplacerRules(context.Context, *Empty) (*ExportMITMReplacerRulesResponse, error)
	ImportMITMReplacerRules(context.Context, *ImportMITMReplacerRulesRequest) (*Empty, error)
	GetCurrentRules(context.Context, *Empty) (*MITMContentReplacers, error)
	SetCurrentRules(context.Context, *MITMContentReplacers) (*Empty, error)
	ExtractDataToFile(Yak_ExtractDataToFileServer) error
	// 尝试自动解码
	AutoDecode(context.Context, *AutoDecodeRequest) (*AutoDecodeResponse, error)
	GetSystemProxy(context.Context, *Empty) (*GetSystemProxyResult, error)
	SetSystemProxy(context.Context, *SetSystemProxyRequest) (*Empty, error)
	// 设置通用存储
	GetKey(context.Context, *GetKeyRequest) (*GetKeyResult, error)
	SetKey(context.Context, *SetKeyRequest) (*Empty, error)
	DelKey(context.Context, *GetKeyRequest) (*Empty, error)
	GetAllProcessEnvKey(context.Context, *Empty) (*GetProcessEnvKeyResult, error)
	SetProcessEnvKey(context.Context, *SetKeyRequest) (*Empty, error)
	GetProjectKey(context.Context, *GetKeyRequest) (*GetKeyResult, error)
	SetProjectKey(context.Context, *SetKeyRequest) (*Empty, error)
	// Online
	GetOnlineProfile(context.Context, *Empty) (*OnlineProfile, error)
	SetOnlineProfile(context.Context, *OnlineProfile) (*Empty, error)
	DownloadOnlinePluginById(context.Context, *DownloadOnlinePluginByIdRequest) (*Empty, error)
	DownloadOnlinePluginByIds(context.Context, *DownloadOnlinePluginByIdsRequest) (*Empty, error)
	DownloadOnlinePluginAll(*DownloadOnlinePluginByTokenRequest, Yak_DownloadOnlinePluginAllServer) error
	DeletePluginByUserID(context.Context, *DeletePluginByUserIDRequest) (*Empty, error)
	DeleteAllLocalPlugins(context.Context, *Empty) (*Empty, error)
	GetYakScriptTagsAndType(context.Context, *Empty) (*GetYakScriptTagsAndTypeResponse, error)
	DeleteLocalPluginsByWhere(context.Context, *DeleteLocalPluginsByWhereRequest) (*Empty, error)
	DownloadOnlinePluginByScriptNames(context.Context, *DownloadOnlinePluginByScriptNamesRequest) (*DownloadOnlinePluginByScriptNamesResponse, error)
	// 新的扫描模式
	ExecPacketScan(*ExecPacketScanRequest, Yak_ExecPacketScanServer) error
	GetEngineDefaultProxy(context.Context, *Empty) (*DefaultProxyResult, error)
	SetEngineDefaultProxy(context.Context, *DefaultProxyResult) (*Empty, error)
	// machine id
	GetMachineID(context.Context, *Empty) (*GetMachineIDResponse, error)
	// license
	GetLicense(context.Context, *Empty) (*GetLicenseResponse, error)
	CheckLicense(context.Context, *CheckLicenseRequest) (*Empty, error)
	// Response Body 的魔法操作
	GetRequestBodyByHTTPFlowID(context.Context, *DownloadBodyByHTTPFlowIDRequest) (*Bytes, error)
	GetResponseBodyByHTTPFlowID(context.Context, *DownloadBodyByHTTPFlowIDRequest) (*Bytes, error)
	GetHTTPPacketBody(context.Context, *GetHTTPPacketBodyRequest) (*Bytes, error)
	// 注册一个 Facades HTTP 响应
	RegisterFacadesHTTP(context.Context, *RegisterFacadesHTTPRequest) (*RegisterFacadesHTTPResponse, error)
	// 重置到恢复出厂设置
	ResetAndInvalidUserData(context.Context, *ResetAndInvalidUserDataRequest) (*Empty, error)
	// Yaklang Shell
	// 创建一个交互式 Shell
	CreateYaklangShell(Yak_CreateYaklangShellServer) error
	// 接入标准输出和标准错误流
	AttachCombinedOutput(*AttachCombinedOutputRequest, Yak_AttachCombinedOutputServer) error
	// 判断当前引擎对网卡是否有操作权限？
	// 主要是能否发包等敏感操作
	// Windows 判断是否是管理员即可 I Am Admin
	// Linux 和 MacOS 应该尝试 pcap 打开网卡就行
	IsPrivilegedForNetRaw(context.Context, *Empty) (*IsPrivilegedForNetRawResponse, error)
	PromotePermissionForUserPcap(context.Context, *Empty) (*Empty, error)
	// 操作项目的相关接口，通过设置 ProjectDatabase
	SetCurrentProject(context.Context, *SetCurrentProjectRequest) (*Empty, error)
	GetCurrentProject(context.Context, *Empty) (*ProjectDescription, error)
	GetProjects(context.Context, *GetProjectsRequest) (*GetProjectsResponse, error)
	NewProject(context.Context, *NewProjectRequest) (*NewProjectResponse, error)
	IsProjectNameValid(context.Context, *IsProjectNameValidRequest) (*Empty, error)
	RemoveProject(context.Context, *RemoveProjectRequest) (*Empty, error)
	DeleteProject(context.Context, *DeleteProjectRequest) (*Empty, error)
	GetDefaultProject(context.Context, *Empty) (*ProjectDescription, error)
	QueryProjectDetail(context.Context, *QueryProjectDetailRequest) (*ProjectDescription, error)
	// 导入导出项目，带密码，带进度
	ExportProject(*ExportProjectRequest, Yak_ExportProjectServer) error
	ImportProject(*ImportProjectRequest, Yak_ImportProjectServer) error
	// 迁移旧数据库
	MigrateLegacyDatabase(context.Context, *Empty) (*Empty, error)
	// 从规则中提取数据
	QueryMITMRuleExtractedData(context.Context, *QueryMITMRuleExtractedDataRequest) (*QueryMITMRuleExtractedDataResponse, error)
	//
	//ChaosMakerRule: Bas
	ImportChaosMakerRules(context.Context, *ImportChaosMakerRulesRequest) (*Empty, error)
	QueryChaosMakerRule(context.Context, *QueryChaosMakerRuleRequest) (*QueryChaosMakerRuleResponse, error)
	DeleteChaosMakerRuleByID(context.Context, *DeleteChaosMakerRuleByIDRequest) (*Empty, error)
	ExecuteChaosMakerRule(*ExecuteChaosMakerRuleRequest, Yak_ExecuteChaosMakerRuleServer) error
	// 这个接口是判断 BAS Agent 远程端口是否可用的，使用 Vulinbox ws agent 协议连接
	// ConnectVulinboxAgent is the same as IsRemoteAddrAvailable
	IsRemoteAddrAvailable(context.Context, *IsRemoteAddrAvailableRequest) (*IsRemoteAddrAvailableResponse, error)
	ConnectVulinboxAgent(context.Context, *IsRemoteAddrAvailableRequest) (*IsRemoteAddrAvailableResponse, error)
	// vulinbox agent 的操作接口
	GetRegisteredVulinboxAgent(context.Context, *GetRegisteredAgentRequest) (*GetRegisteredAgentResponse, error)
	DisconnectVulinboxAgent(context.Context, *DisconnectVulinboxAgentRequest) (*Empty, error)
	// CVE
	IsCVEDatabaseReady(context.Context, *IsCVEDatabaseReadyRequest) (*IsCVEDatabaseReadyResponse, error)
	UpdateCVEDatabase(*UpdateCVEDatabaseRequest, Yak_UpdateCVEDatabaseServer) error
	ExportsProfileDatabase(*ExportsProfileDatabaseRequest, Yak_ExportsProfileDatabaseServer) error
	ImportsProfileDatabase(*ImportsProfileDatabaseRequest, Yak_ImportsProfileDatabaseServer) error
	QueryCVE(context.Context, *QueryCVERequest) (*QueryCVEResponse, error)
	GetCVE(context.Context, *GetCVERequest) (*CVEDetailEx, error)
	SaveTextToTemporalFile(context.Context, *SaveTextToTemporalFileRequest) (*SaveTextToTemporalFileResponse, error)
	// Screcorder
	IsScrecorderReady(context.Context, *IsScrecorderReadyRequest) (*IsScrecorderReadyResponse, error)
	InstallScrecorder(*InstallScrecorderRequest, Yak_InstallScrecorderServer) error
	StartScrecorder(*StartScrecorderRequest, Yak_StartScrecorderServer) error
	QueryScreenRecorders(context.Context, *QueryScreenRecorderRequest) (*QueryScreenRecorderResponse, error)
	DeleteScreenRecorders(context.Context, *QueryScreenRecorderRequest) (*Empty, error)
	UploadScreenRecorders(context.Context, *UploadScreenRecorderRequest) (*Empty, error)
	GetOneScreenRecorders(context.Context, *GetOneScreenRecorderRequest) (*ScreenRecorder, error)
	UpdateScreenRecorders(context.Context, *UpdateScreenRecorderRequest) (*Empty, error)
	// Vulinbox
	IsVulinboxReady(context.Context, *IsVulinboxReadyRequest) (*IsVulinboxReadyResponse, error)
	InstallVulinbox(*InstallVulinboxRequest, Yak_InstallVulinboxServer) error
	StartVulinbox(*StartVulinboxRequest, Yak_StartVulinboxServer) error
	GenQualityInspectionReport(*GenQualityInspectionReportRequest, Yak_GenQualityInspectionReportServer) error
	// 通过他可以构造一个 HTTP 请求
	// 这个请求可能是一个，也可能是一系列
	// 一般用来调试插件等
	HTTPRequestBuilder(context.Context, *HTTPRequestBuilderParams) (*HTTPRequestBuilderResponse, error)
	// rpc QueryHTTPRequestBuilder(QueryHTTPRequestBuilderRequest) returns (QueryHTTPRequestBuilderResponse);
	// rpc DeleteHTTPRequestBuilder(DeleteHTTPRequestBuilderRequest) returns (Empty);
	DebugPlugin(*DebugPluginRequest, Yak_DebugPluginServer) error
	SmokingEvaluatePlugin(context.Context, *SmokingEvaluatePluginRequest) (*SmokingEvaluatePluginResponse, error)
	GetSystemDefaultDnsServers(context.Context, *Empty) (*DefaultDnsServerResponse, error)
	// 诊断网络发生的问题
	DiagnoseNetwork(*DiagnoseNetworkRequest, Yak_DiagnoseNetworkServer) error
	DiagnoseNetworkDNS(*DiagnoseNetworkDNSRequest, Yak_DiagnoseNetworkDNSServer) error
	// Global Network Config
	GetGlobalNetworkConfig(context.Context, *GetGlobalNetworkConfigRequest) (*GlobalNetworkConfig, error)
	SetGlobalNetworkConfig(context.Context, *GlobalNetworkConfig) (*Empty, error)
	ResetGlobalNetworkConfig(context.Context, *ResetGlobalNetworkConfigRequest) (*Empty, error)
	ValidP12PassWord(context.Context, *ValidP12PassWordRequest) (*ValidP12PassWordResponse, error)
	RequestYakURL(context.Context, *RequestYakURLParams) (*RequestYakURLResponse, error)
	// Wireshark
	GetPcapMetadata(context.Context, *PcapMetadataRequest) (*PcapMetadata, error)
	PcapX(Yak_PcapXServer) error
	QueryTrafficSession(context.Context, *QueryTrafficSessionRequest) (*QueryTrafficSessionResponse, error)
	QueryTrafficPacket(context.Context, *QueryTrafficPacketRequest) (*QueryTrafficPacketResponse, error)
	QueryTrafficTCPReassembled(context.Context, *QueryTrafficTCPReassembledRequest) (*QueryTrafficTCPReassembledResponse, error)
	DuplexConnection(Yak_DuplexConnectionServer) error
	mustEmbedUnimplementedYakServer()
}

// UnimplementedYakServer must be embedded to have forward compatible implementations.
type UnimplementedYakServer struct {
}

func (UnimplementedYakServer) Version(context.Context, *Empty) (*VersionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Version not implemented")
}
func (UnimplementedYakServer) Echo(context.Context, *EchoRequest) (*EchoResposne, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Echo not implemented")
}
func (UnimplementedYakServer) MITM(Yak_MITMServer) error {
	return status.Errorf(codes.Unimplemented, "method MITM not implemented")
}
func (UnimplementedYakServer) SetMITMFilter(context.Context, *SetMITMFilterRequest) (*SetMITMFilterResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetMITMFilter not implemented")
}
func (UnimplementedYakServer) GetMITMFilter(context.Context, *Empty) (*SetMITMFilterRequest, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetMITMFilter not implemented")
}
func (UnimplementedYakServer) DownloadMITMCert(context.Context, *Empty) (*MITMCert, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DownloadMITMCert not implemented")
}
func (UnimplementedYakServer) OpenPort(Yak_OpenPortServer) error {
	return status.Errorf(codes.Unimplemented, "method OpenPort not implemented")
}
func (UnimplementedYakServer) Exec(*ExecRequest, Yak_ExecServer) error {
	return status.Errorf(codes.Unimplemented, "method Exec not implemented")
}
func (UnimplementedYakServer) QueryExecHistory(context.Context, *ExecHistoryRequest) (*ExecHistoryRecordResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QueryExecHistory not implemented")
}
func (UnimplementedYakServer) RemoveExecHistory(context.Context, *Empty) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RemoveExecHistory not implemented")
}
func (UnimplementedYakServer) LoadNucleiTemplates(context.Context, *Empty) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method LoadNucleiTemplates not implemented")
}
func (UnimplementedYakServer) AutoUpdateYakModule(*Empty, Yak_AutoUpdateYakModuleServer) error {
	return status.Errorf(codes.Unimplemented, "method AutoUpdateYakModule not implemented")
}
func (UnimplementedYakServer) ExecYakScript(*ExecRequest, Yak_ExecYakScriptServer) error {
	return status.Errorf(codes.Unimplemented, "method ExecYakScript not implemented")
}
func (UnimplementedYakServer) ExecBatchYakScript(*ExecBatchYakScriptRequest, Yak_ExecBatchYakScriptServer) error {
	return status.Errorf(codes.Unimplemented, "method ExecBatchYakScript not implemented")
}
func (UnimplementedYakServer) GetExecBatchYakScriptUnfinishedTask(context.Context, *Empty) (*GetExecBatchYakScriptUnfinishedTaskResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetExecBatchYakScriptUnfinishedTask not implemented")
}
func (UnimplementedYakServer) GetExecBatchYakScriptUnfinishedTaskByUid(context.Context, *GetExecBatchYakScriptUnfinishedTaskByUidRequest) (*ExecBatchYakScriptRequest, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetExecBatchYakScriptUnfinishedTaskByUid not implemented")
}
func (UnimplementedYakServer) PopExecBatchYakScriptUnfinishedTaskByUid(context.Context, *GetExecBatchYakScriptUnfinishedTaskByUidRequest) (*ExecBatchYakScriptRequest, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PopExecBatchYakScriptUnfinishedTaskByUid not implemented")
}
func (UnimplementedYakServer) RecoverExecBatchYakScriptUnfinishedTask(*RecoverExecBatchYakScriptUnfinishedTaskRequest, Yak_RecoverExecBatchYakScriptUnfinishedTaskServer) error {
	return status.Errorf(codes.Unimplemented, "method RecoverExecBatchYakScriptUnfinishedTask not implemented")
}
func (UnimplementedYakServer) QueryYakScript(context.Context, *QueryYakScriptRequest) (*QueryYakScriptResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QueryYakScript not implemented")
}
func (UnimplementedYakServer) QueryYakScriptByYakScriptName(*QueryYakScriptRequest, Yak_QueryYakScriptByYakScriptNameServer) error {
	return status.Errorf(codes.Unimplemented, "method QueryYakScriptByYakScriptName not implemented")
}
func (UnimplementedYakServer) SaveYakScript(context.Context, *YakScript) (*YakScript, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SaveYakScript not implemented")
}
func (UnimplementedYakServer) DeleteYakScript(context.Context, *DeleteYakScriptRequest) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteYakScript not implemented")
}
func (UnimplementedYakServer) GetYakScriptById(context.Context, *GetYakScriptByIdRequest) (*YakScript, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetYakScriptById not implemented")
}
func (UnimplementedYakServer) GetYakScriptByName(context.Context, *GetYakScriptByNameRequest) (*YakScript, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetYakScriptByName not implemented")
}
func (UnimplementedYakServer) GetYakScriptByOnlineID(context.Context, *GetYakScriptByOnlineIDRequest) (*YakScript, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetYakScriptByOnlineID not implemented")
}
func (UnimplementedYakServer) IgnoreYakScript(context.Context, *DeleteYakScriptRequest) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method IgnoreYakScript not implemented")
}
func (UnimplementedYakServer) UnIgnoreYakScript(context.Context, *DeleteYakScriptRequest) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UnIgnoreYakScript not implemented")
}
func (UnimplementedYakServer) ExportYakScript(context.Context, *ExportYakScriptRequest) (*ExportYakScriptResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ExportYakScript not implemented")
}
func (UnimplementedYakServer) ExecutePacketYakScript(*ExecutePacketYakScriptParams, Yak_ExecutePacketYakScriptServer) error {
	return status.Errorf(codes.Unimplemented, "method ExecutePacketYakScript not implemented")
}
func (UnimplementedYakServer) ExecuteBatchPacketYakScript(*ExecuteBatchPacketYakScriptParams, Yak_ExecuteBatchPacketYakScriptServer) error {
	return status.Errorf(codes.Unimplemented, "method ExecuteBatchPacketYakScript not implemented")
}
func (UnimplementedYakServer) GetYakScriptTags(context.Context, *Empty) (*GetYakScriptTagsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetYakScriptTags not implemented")
}
func (UnimplementedYakServer) QueryYakScriptLocalAndUser(context.Context, *QueryYakScriptLocalAndUserRequest) (*QueryYakScriptLocalAndUserResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QueryYakScriptLocalAndUser not implemented")
}
func (UnimplementedYakServer) QueryYakScriptByOnlineGroup(context.Context, *QueryYakScriptByOnlineGroupRequest) (*QueryYakScriptLocalAndUserResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QueryYakScriptByOnlineGroup not implemented")
}
func (UnimplementedYakServer) QueryYakScriptLocalAll(context.Context, *Empty) (*QueryYakScriptLocalAndUserResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QueryYakScriptLocalAll not implemented")
}
func (UnimplementedYakServer) QueryYakScriptByNames(context.Context, *QueryYakScriptByNamesRequest) (*QueryYakScriptByNamesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QueryYakScriptByNames not implemented")
}
func (UnimplementedYakServer) QueryYakScriptByIsCore(context.Context, *QueryYakScriptByIsCoreRequest) (*QueryYakScriptByIsCoreResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QueryYakScriptByIsCore not implemented")
}
func (UnimplementedYakServer) GetHTTPFlowByHash(context.Context, *GetHTTPFlowByHashRequest) (*HTTPFlow, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetHTTPFlowByHash not implemented")
}
func (UnimplementedYakServer) GetHTTPFlowById(context.Context, *GetHTTPFlowByIdRequest) (*HTTPFlow, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetHTTPFlowById not implemented")
}
func (UnimplementedYakServer) GetHTTPFlowByIds(context.Context, *GetHTTPFlowByIdsRequest) (*HTTPFlows, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetHTTPFlowByIds not implemented")
}
func (UnimplementedYakServer) QueryHTTPFlows(context.Context, *QueryHTTPFlowRequest) (*QueryHTTPFlowResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QueryHTTPFlows not implemented")
}
func (UnimplementedYakServer) DeleteHTTPFlows(context.Context, *DeleteHTTPFlowRequest) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteHTTPFlows not implemented")
}
func (UnimplementedYakServer) SetTagForHTTPFlow(context.Context, *SetTagForHTTPFlowRequest) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetTagForHTTPFlow not implemented")
}
func (UnimplementedYakServer) QueryHTTPFlowsIds(context.Context, *QueryHTTPFlowsIdsRequest) (*QueryHTTPFlowsIdsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QueryHTTPFlowsIds not implemented")
}
func (UnimplementedYakServer) HTTPFlowsFieldGroup(context.Context, *HTTPFlowsFieldGroupRequest) (*HTTPFlowsFieldGroupResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method HTTPFlowsFieldGroup not implemented")
}
func (UnimplementedYakServer) HTTPFlowsShare(context.Context, *HTTPFlowsShareRequest) (*HTTPFlowsShareResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method HTTPFlowsShare not implemented")
}
func (UnimplementedYakServer) HTTPFlowsExtract(context.Context, *HTTPFlowsExtractRequest) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method HTTPFlowsExtract not implemented")
}
func (UnimplementedYakServer) GetHTTPFlowBare(context.Context, *HTTPFlowBareRequest) (*HTTPFlowBareResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetHTTPFlowBare not implemented")
}
func (UnimplementedYakServer) ExtractUrl(context.Context, *FuzzerRequest) (*ExtractedUrl, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ExtractUrl not implemented")
}
func (UnimplementedYakServer) GetHistoryHTTPFuzzerTask(context.Context, *GetHistoryHTTPFuzzerTaskRequest) (*HistoryHTTPFuzzerTaskDetail, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetHistoryHTTPFuzzerTask not implemented")
}
func (UnimplementedYakServer) QueryHistoryHTTPFuzzerTask(context.Context, *Empty) (*HistoryHTTPFuzzerTasks, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QueryHistoryHTTPFuzzerTask not implemented")
}
func (UnimplementedYakServer) QueryHistoryHTTPFuzzerTaskEx(context.Context, *QueryHistoryHTTPFuzzerTaskExParams) (*HistoryHTTPFuzzerTasksResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QueryHistoryHTTPFuzzerTaskEx not implemented")
}
func (UnimplementedYakServer) DeleteHistoryHTTPFuzzerTask(context.Context, *DeleteHistoryHTTPFuzzerTaskRequest) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteHistoryHTTPFuzzerTask not implemented")
}
func (UnimplementedYakServer) HTTPFuzzer(*FuzzerRequest, Yak_HTTPFuzzerServer) error {
	return status.Errorf(codes.Unimplemented, "method HTTPFuzzer not implemented")
}
func (UnimplementedYakServer) HTTPFuzzerSequence(*FuzzerRequests, Yak_HTTPFuzzerSequenceServer) error {
	return status.Errorf(codes.Unimplemented, "method HTTPFuzzerSequence not implemented")
}
func (UnimplementedYakServer) PreloadHTTPFuzzerParams(context.Context, *PreloadHTTPFuzzerParamsRequest) (*PreloadHTTPFuzzerParamsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PreloadHTTPFuzzerParams not implemented")
}
func (UnimplementedYakServer) RenderVariables(context.Context, *RenderVariablesRequest) (*RenderVariablesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RenderVariables not implemented")
}
func (UnimplementedYakServer) MatchHTTPResponse(context.Context, *MatchHTTPResponseParams) (*MatchHTTPResponseResult, error) {
	return nil, status.Errorf(codes.Unimplemented, "method MatchHTTPResponse not implemented")
}
func (UnimplementedYakServer) ExtractHTTPResponse(context.Context, *ExtractHTTPResponseParams) (*ExtractHTTPResponseResult, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ExtractHTTPResponse not implemented")
}
func (UnimplementedYakServer) RedirectRequest(context.Context, *RedirectRequestParams) (*FuzzerResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RedirectRequest not implemented")
}
func (UnimplementedYakServer) HTTPRequestMutate(context.Context, *HTTPRequestMutateParams) (*MutateResult, error) {
	return nil, status.Errorf(codes.Unimplemented, "method HTTPRequestMutate not implemented")
}
func (UnimplementedYakServer) HTTPResponseMutate(context.Context, *HTTPResponseMutateParams) (*MutateResult, error) {
	return nil, status.Errorf(codes.Unimplemented, "method HTTPResponseMutate not implemented")
}
func (UnimplementedYakServer) FixUploadPacket(context.Context, *FixUploadPacketRequest) (*FixUploadPacketResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method FixUploadPacket not implemented")
}
func (UnimplementedYakServer) IsMultipartFormDataRequest(context.Context, *FixUploadPacketRequest) (*IsMultipartFormDataRequestResult, error) {
	return nil, status.Errorf(codes.Unimplemented, "method IsMultipartFormDataRequest not implemented")
}
func (UnimplementedYakServer) GenerateExtractRule(context.Context, *GenerateExtractRuleRequest) (*GenerateExtractRuleResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GenerateExtractRule not implemented")
}
func (UnimplementedYakServer) ExtractData(Yak_ExtractDataServer) error {
	return status.Errorf(codes.Unimplemented, "method ExtractData not implemented")
}
func (UnimplementedYakServer) ImportHTTPFuzzerTaskFromYaml(context.Context, *ImportHTTPFuzzerTaskFromYamlRequest) (*ImportHTTPFuzzerTaskFromYamlResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ImportHTTPFuzzerTaskFromYaml not implemented")
}
func (UnimplementedYakServer) ExportHTTPFuzzerTaskToYaml(context.Context, *ExportHTTPFuzzerTaskToYamlRequest) (*ExportHTTPFuzzerTaskToYamlResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ExportHTTPFuzzerTaskToYaml not implemented")
}
func (UnimplementedYakServer) SaveFuzzerLabel(context.Context, *SaveFuzzerLabelRequest) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SaveFuzzerLabel not implemented")
}
func (UnimplementedYakServer) QueryFuzzerLabel(context.Context, *Empty) (*QueryFuzzerLabelResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QueryFuzzerLabel not implemented")
}
func (UnimplementedYakServer) DeleteFuzzerLabel(context.Context, *DeleteFuzzerLabelRequest) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteFuzzerLabel not implemented")
}
func (UnimplementedYakServer) QueryHTTPFuzzerResponseByTaskId(context.Context, *QueryHTTPFuzzerResponseByTaskIdRequest) (*QueryHTTPFuzzerResponseByTaskIdResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QueryHTTPFuzzerResponseByTaskId not implemented")
}
func (UnimplementedYakServer) CreateWebsocketFuzzer(Yak_CreateWebsocketFuzzerServer) error {
	return status.Errorf(codes.Unimplemented, "method CreateWebsocketFuzzer not implemented")
}
func (UnimplementedYakServer) QueryWebsocketFlowByHTTPFlowWebsocketHash(context.Context, *QueryWebsocketFlowByHTTPFlowWebsocketHashRequest) (*WebsocketFlows, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QueryWebsocketFlowByHTTPFlowWebsocketHash not implemented")
}
func (UnimplementedYakServer) DeleteWebsocketFlowByHTTPFlowWebsocketHash(context.Context, *DeleteWebsocketFlowByHTTPFlowWebsocketHashRequest) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteWebsocketFlowByHTTPFlowWebsocketHash not implemented")
}
func (UnimplementedYakServer) DeleteWebsocketFlowAll(context.Context, *Empty) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteWebsocketFlowAll not implemented")
}
func (UnimplementedYakServer) ConvertFuzzerResponseToHTTPFlow(context.Context, *FuzzerResponse) (*HTTPFlow, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ConvertFuzzerResponseToHTTPFlow not implemented")
}
func (UnimplementedYakServer) StringFuzzer(context.Context, *StringFuzzerRequest) (*StringFuzzerResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method StringFuzzer not implemented")
}
func (UnimplementedYakServer) HTTPRequestAnalyzer(context.Context, *HTTPRequestAnalysisMaterial) (*HTTPRequestAnalysis, error) {
	return nil, status.Errorf(codes.Unimplemented, "method HTTPRequestAnalyzer not implemented")
}
func (UnimplementedYakServer) Codec(context.Context, *CodecRequest) (*CodecResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Codec not implemented")
}
func (UnimplementedYakServer) NewCodec(context.Context, *CodecRequestFlow) (*CodecResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method NewCodec not implemented")
}
func (UnimplementedYakServer) PacketPrettifyHelper(context.Context, *PacketPrettifyHelperRequest) (*PacketPrettifyHelperResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PacketPrettifyHelper not implemented")
}
func (UnimplementedYakServer) QueryPayload(context.Context, *QueryPayloadRequest) (*QueryPayloadResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QueryPayload not implemented")
}
func (UnimplementedYakServer) DeletePayloadByGroup(context.Context, *DeletePayloadByGroupRequest) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeletePayloadByGroup not implemented")
}
func (UnimplementedYakServer) DeletePayload(context.Context, *DeletePayloadRequest) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeletePayload not implemented")
}
func (UnimplementedYakServer) SavePayload(context.Context, *SavePayloadRequest) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SavePayload not implemented")
}
func (UnimplementedYakServer) SavePayloadStream(*SavePayloadRequest, Yak_SavePayloadStreamServer) error {
	return status.Errorf(codes.Unimplemented, "method SavePayloadStream not implemented")
}
func (UnimplementedYakServer) GetAllPayloadGroup(context.Context, *Empty) (*GetAllPayloadGroupResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetAllPayloadGroup not implemented")
}
func (UnimplementedYakServer) UpdatePayload(context.Context, *UpdatePayloadRequest) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdatePayload not implemented")
}
func (UnimplementedYakServer) GetAllPayload(context.Context, *GetAllPayloadRequest) (*GetAllPayloadResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetAllPayload not implemented")
}
func (UnimplementedYakServer) GetYakitCompletionRaw(context.Context, *Empty) (*YakitCompletionRawResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetYakitCompletionRaw not implemented")
}
func (UnimplementedYakServer) GetYakVMBuildInMethodCompletion(context.Context, *GetYakVMBuildInMethodCompletionRequest) (*GetYakVMBuildInMethodCompletionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetYakVMBuildInMethodCompletion not implemented")
}
func (UnimplementedYakServer) StaticAnalyzeError(context.Context, *StaticAnalyzeErrorRequest) (*StaticAnalyzeErrorResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method StaticAnalyzeError not implemented")
}
func (UnimplementedYakServer) YaklangCompileAndFormat(context.Context, *YaklangCompileAndFormatRequest) (*YaklangCompileAndFormatResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method YaklangCompileAndFormat not implemented")
}
func (UnimplementedYakServer) PortScan(*PortScanRequest, Yak_PortScanServer) error {
	return status.Errorf(codes.Unimplemented, "method PortScan not implemented")
}
func (UnimplementedYakServer) ViewPortScanCode(context.Context, *Empty) (*SimpleScript, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ViewPortScanCode not implemented")
}
func (UnimplementedYakServer) SimpleDetect(*RecordPortScanRequest, Yak_SimpleDetectServer) error {
	return status.Errorf(codes.Unimplemented, "method SimpleDetect not implemented")
}
func (UnimplementedYakServer) SaveCancelSimpleDetect(context.Context, *RecordPortScanRequest) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SaveCancelSimpleDetect not implemented")
}
func (UnimplementedYakServer) GetSimpleDetectUnfinishedTask(context.Context, *Empty) (*GetSimpleDetectUnfinishedTaskResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetSimpleDetectUnfinishedTask not implemented")
}
func (UnimplementedYakServer) GetSimpleDetectUnfinishedTaskByUid(context.Context, *GetExecBatchYakScriptUnfinishedTaskByUidRequest) (*RecordPortScanRequest, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetSimpleDetectUnfinishedTaskByUid not implemented")
}
func (UnimplementedYakServer) PopSimpleDetectUnfinishedTaskByUid(context.Context, *GetExecBatchYakScriptUnfinishedTaskByUidRequest) (*RecordPortScanRequest, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PopSimpleDetectUnfinishedTaskByUid not implemented")
}
func (UnimplementedYakServer) RecoverSimpleDetectUnfinishedTask(*RecoverExecBatchYakScriptUnfinishedTaskRequest, Yak_RecoverSimpleDetectUnfinishedTaskServer) error {
	return status.Errorf(codes.Unimplemented, "method RecoverSimpleDetectUnfinishedTask not implemented")
}
func (UnimplementedYakServer) QueryPorts(context.Context, *QueryPortsRequest) (*QueryPortsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QueryPorts not implemented")
}
func (UnimplementedYakServer) DeletePorts(context.Context, *DeletePortsRequest) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeletePorts not implemented")
}
func (UnimplementedYakServer) QueryHosts(context.Context, *QueryHostsRequest) (*QueryHostsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QueryHosts not implemented")
}
func (UnimplementedYakServer) DeleteHosts(context.Context, *DeleteHostsRequest) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteHosts not implemented")
}
func (UnimplementedYakServer) QueryDomains(context.Context, *QueryDomainsRequest) (*QueryDomainsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QueryDomains not implemented")
}
func (UnimplementedYakServer) DeleteDomains(context.Context, *DeleteDomainsRequest) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteDomains not implemented")
}
func (UnimplementedYakServer) QueryPortsGroup(context.Context, *Empty) (*QueryPortsGroupResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QueryPortsGroup not implemented")
}
func (UnimplementedYakServer) UpdateFromYakitResource(context.Context, *UpdateFromYakitResourceRequest) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateFromYakitResource not implemented")
}
func (UnimplementedYakServer) UpdateFromGithub(context.Context, *UpdateFromGithubRequest) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateFromGithub not implemented")
}
func (UnimplementedYakServer) AddToMenu(context.Context, *AddToMenuRequest) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddToMenu not implemented")
}
func (UnimplementedYakServer) RemoveFromMenu(context.Context, *RemoveFromMenuRequest) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RemoveFromMenu not implemented")
}
func (UnimplementedYakServer) YakScriptIsInMenu(context.Context, *YakScriptIsInMenuRequest) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method YakScriptIsInMenu not implemented")
}
func (UnimplementedYakServer) GetAllMenuItem(context.Context, *Empty) (*MenuByGroup, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetAllMenuItem not implemented")
}
func (UnimplementedYakServer) DeleteAllMenuItem(context.Context, *Empty) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteAllMenuItem not implemented")
}
func (UnimplementedYakServer) ImportMenuItem(context.Context, *ImportMenuItemRequest) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ImportMenuItem not implemented")
}
func (UnimplementedYakServer) ExportMenuItem(context.Context, *Empty) (*ExportMenuItemResult, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ExportMenuItem not implemented")
}
func (UnimplementedYakServer) GetMenuItemById(context.Context, *GetMenuItemByIdRequest) (*MenuItem, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetMenuItemById not implemented")
}
func (UnimplementedYakServer) QueryGroupsByYakScriptId(context.Context, *QueryGroupsByYakScriptIdRequest) (*GroupNames, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QueryGroupsByYakScriptId not implemented")
}
func (UnimplementedYakServer) AddMenus(context.Context, *AddMenuRequest) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddMenus not implemented")
}
func (UnimplementedYakServer) QueryAllMenuItem(context.Context, *QueryAllMenuItemRequest) (*MenuByGroup, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QueryAllMenuItem not implemented")
}
func (UnimplementedYakServer) DeleteAllMenu(context.Context, *QueryAllMenuItemRequest) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteAllMenu not implemented")
}
func (UnimplementedYakServer) AddToNavigation(context.Context, *AddToNavigationRequest) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddToNavigation not implemented")
}
func (UnimplementedYakServer) GetAllNavigationItem(context.Context, *GetAllNavigationRequest) (*GetAllNavigationItemResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetAllNavigationItem not implemented")
}
func (UnimplementedYakServer) DeleteAllNavigation(context.Context, *GetAllNavigationRequest) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteAllNavigation not implemented")
}
func (UnimplementedYakServer) AddOneNavigation(context.Context, *AddOneNavigationRequest) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddOneNavigation not implemented")
}
func (UnimplementedYakServer) QueryNavigationGroups(context.Context, *QueryNavigationGroupsRequest) (*GroupNames, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QueryNavigationGroups not implemented")
}
func (UnimplementedYakServer) SaveMarkdownDocument(context.Context, *SaveMarkdownDocumentRequest) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SaveMarkdownDocument not implemented")
}
func (UnimplementedYakServer) GetMarkdownDocument(context.Context, *GetMarkdownDocumentRequest) (*GetMarkdownDocumentResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetMarkdownDocument not implemented")
}
func (UnimplementedYakServer) DeleteMarkdownDocument(context.Context, *GetMarkdownDocumentRequest) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteMarkdownDocument not implemented")
}
func (UnimplementedYakServer) StartBasicCrawler(context.Context, *StartBasicCrawlerRequest) (*ExecResult, error) {
	return nil, status.Errorf(codes.Unimplemented, "method StartBasicCrawler not implemented")
}
func (UnimplementedYakServer) ViewBasicCrawlerCode(context.Context, *Empty) (*SimpleScript, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ViewBasicCrawlerCode not implemented")
}
func (UnimplementedYakServer) GenerateWebsiteTree(context.Context, *GenerateWebsiteTreeRequest) (*GenerateWebsiteTreeResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GenerateWebsiteTree not implemented")
}
func (UnimplementedYakServer) QueryYakScriptExecResult(context.Context, *QueryYakScriptExecResultRequest) (*QueryYakScriptExecResultResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QueryYakScriptExecResult not implemented")
}
func (UnimplementedYakServer) QueryYakScriptNameInExecResult(context.Context, *Empty) (*YakScriptNames, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QueryYakScriptNameInExecResult not implemented")
}
func (UnimplementedYakServer) DeleteYakScriptExecResult(context.Context, *DeleteYakScriptExecResultRequest) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteYakScriptExecResult not implemented")
}
func (UnimplementedYakServer) DeleteYakScriptExec(context.Context, *Empty) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteYakScriptExec not implemented")
}
func (UnimplementedYakServer) StartBrute(*StartBruteParams, Yak_StartBruteServer) error {
	return status.Errorf(codes.Unimplemented, "method StartBrute not implemented")
}
func (UnimplementedYakServer) GetAvailableBruteTypes(context.Context, *Empty) (*GetAvailableBruteTypesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetAvailableBruteTypes not implemented")
}
func (UnimplementedYakServer) GetTunnelServerExternalIP(context.Context, *GetTunnelServerExternalIPParams) (*GetTunnelServerExternalIPResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetTunnelServerExternalIP not implemented")
}
func (UnimplementedYakServer) VerifyTunnelServerDomain(context.Context, *VerifyTunnelServerDomainParams) (*VerifyTunnelServerDomainResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method VerifyTunnelServerDomain not implemented")
}
func (UnimplementedYakServer) StartFacades(*StartFacadesParams, Yak_StartFacadesServer) error {
	return status.Errorf(codes.Unimplemented, "method StartFacades not implemented")
}
func (UnimplementedYakServer) StartFacadesWithYsoObject(*StartFacadesWithYsoParams, Yak_StartFacadesWithYsoObjectServer) error {
	return status.Errorf(codes.Unimplemented, "method StartFacadesWithYsoObject not implemented")
}
func (UnimplementedYakServer) ApplyClassToFacades(context.Context, *ApplyClassToFacadesParamsWithVerbose) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ApplyClassToFacades not implemented")
}
func (UnimplementedYakServer) BytesToBase64(context.Context, *BytesToBase64Request) (*BytesToBase64Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BytesToBase64 not implemented")
}
func (UnimplementedYakServer) ConfigGlobalReverse(*ConfigGlobalReverseParams, Yak_ConfigGlobalReverseServer) error {
	return status.Errorf(codes.Unimplemented, "method ConfigGlobalReverse not implemented")
}
func (UnimplementedYakServer) AvailableLocalAddr(context.Context, *Empty) (*AvailableLocalAddrResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AvailableLocalAddr not implemented")
}
func (UnimplementedYakServer) GetGlobalReverseServer(context.Context, *Empty) (*GetGlobalReverseServerResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetGlobalReverseServer not implemented")
}
func (UnimplementedYakServer) QueryRisks(context.Context, *QueryRisksRequest) (*QueryRisksResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QueryRisks not implemented")
}
func (UnimplementedYakServer) QueryRisk(context.Context, *QueryRiskRequest) (*Risk, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QueryRisk not implemented")
}
func (UnimplementedYakServer) DeleteRisk(context.Context, *DeleteRiskRequest) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteRisk not implemented")
}
func (UnimplementedYakServer) QueryAvailableRiskType(context.Context, *Empty) (*Fields, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QueryAvailableRiskType not implemented")
}
func (UnimplementedYakServer) QueryAvailableRiskLevel(context.Context, *Empty) (*Fields, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QueryAvailableRiskLevel not implemented")
}
func (UnimplementedYakServer) QueryRiskTableStats(context.Context, *Empty) (*RiskTableStats, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QueryRiskTableStats not implemented")
}
func (UnimplementedYakServer) ResetRiskTableStats(context.Context, *Empty) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ResetRiskTableStats not implemented")
}
func (UnimplementedYakServer) QueryAvailableTarget(context.Context, *Empty) (*Fields, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QueryAvailableTarget not implemented")
}
func (UnimplementedYakServer) QueryNewRisk(context.Context, *QueryNewRiskRequest) (*QueryNewRiskResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QueryNewRisk not implemented")
}
func (UnimplementedYakServer) NewRiskRead(context.Context, *NewRiskReadRequest) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method NewRiskRead not implemented")
}
func (UnimplementedYakServer) UploadRiskToOnline(context.Context, *UploadRiskToOnlineRequest) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UploadRiskToOnline not implemented")
}
func (UnimplementedYakServer) QueryReports(context.Context, *QueryReportsRequest) (*QueryReportsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QueryReports not implemented")
}
func (UnimplementedYakServer) QueryReport(context.Context, *QueryReportRequest) (*Report, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QueryReport not implemented")
}
func (UnimplementedYakServer) DeleteReport(context.Context, *DeleteReportRequest) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteReport not implemented")
}
func (UnimplementedYakServer) QueryAvailableReportFrom(context.Context, *Empty) (*Fields, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QueryAvailableReportFrom not implemented")
}
func (UnimplementedYakServer) DownloadReport(context.Context, *DownloadReportRequest) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DownloadReport not implemented")
}
func (UnimplementedYakServer) GetAllYsoGadgetOptions(context.Context, *Empty) (*YsoOptionsWithVerbose, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetAllYsoGadgetOptions not implemented")
}
func (UnimplementedYakServer) GetAllYsoClassOptions(context.Context, *YsoOptionsRequerstWithVerbose) (*YsoOptionsWithVerbose, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetAllYsoClassOptions not implemented")
}
func (UnimplementedYakServer) GetAllYsoClassGeneraterOptions(context.Context, *YsoOptionsRequerstWithVerbose) (*YsoClassOptionsResponseWithVerbose, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetAllYsoClassGeneraterOptions not implemented")
}
func (UnimplementedYakServer) GenerateYsoCode(context.Context, *YsoOptionsRequerstWithVerbose) (*YsoCodeResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GenerateYsoCode not implemented")
}
func (UnimplementedYakServer) GenerateYsoBytes(context.Context, *YsoOptionsRequerstWithVerbose) (*YsoBytesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GenerateYsoBytes not implemented")
}
func (UnimplementedYakServer) YsoDump(context.Context, *YsoBytesObject) (*YsoDumpResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method YsoDump not implemented")
}
func (UnimplementedYakServer) SetYakBridgeLogServer(context.Context, *YakDNSLogBridgeAddr) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetYakBridgeLogServer not implemented")
}
func (UnimplementedYakServer) GetCurrentYakBridgeLogServer(context.Context, *Empty) (*YakDNSLogBridgeAddr, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetCurrentYakBridgeLogServer not implemented")
}
func (UnimplementedYakServer) RequireDNSLogDomain(context.Context, *YakDNSLogBridgeAddr) (*DNSLogRootDomain, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RequireDNSLogDomain not implemented")
}
func (UnimplementedYakServer) RequireDNSLogDomainByScript(context.Context, *RequireDNSLogDomainByScriptRequest) (*DNSLogRootDomain, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RequireDNSLogDomainByScript not implemented")
}
func (UnimplementedYakServer) QueryDNSLogByToken(context.Context, *QueryDNSLogByTokenRequest) (*QueryDNSLogByTokenResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QueryDNSLogByToken not implemented")
}
func (UnimplementedYakServer) QueryDNSLogTokenByScript(context.Context, *RequireDNSLogDomainByScriptRequest) (*QueryDNSLogByTokenResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QueryDNSLogTokenByScript not implemented")
}
func (UnimplementedYakServer) RequireICMPRandomLength(context.Context, *Empty) (*RequireICMPRandomLengthResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RequireICMPRandomLength not implemented")
}
func (UnimplementedYakServer) QueryICMPTrigger(context.Context, *QueryICMPTriggerRequest) (*QueryICMPTriggerResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QueryICMPTrigger not implemented")
}
func (UnimplementedYakServer) RequireRandomPortToken(context.Context, *Empty) (*RandomPortInfo, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RequireRandomPortToken not implemented")
}
func (UnimplementedYakServer) QueryRandomPortTrigger(context.Context, *QueryRandomPortTriggerRequest) (*RandomPortTriggerNotification, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QueryRandomPortTrigger not implemented")
}
func (UnimplementedYakServer) QuerySupportedDnsLogPlatforms(context.Context, *Empty) (*QuerySupportedDnsLogPlatformsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QuerySupportedDnsLogPlatforms not implemented")
}
func (UnimplementedYakServer) GetAvailableYakScriptTags(context.Context, *Empty) (*Fields, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetAvailableYakScriptTags not implemented")
}
func (UnimplementedYakServer) ForceUpdateAvailableYakScriptTags(context.Context, *Empty) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ForceUpdateAvailableYakScriptTags not implemented")
}
func (UnimplementedYakServer) ExecYakitPluginsByYakScriptFilter(*ExecYakitPluginsByYakScriptFilterRequest, Yak_ExecYakitPluginsByYakScriptFilterServer) error {
	return status.Errorf(codes.Unimplemented, "method ExecYakitPluginsByYakScriptFilter not implemented")
}
func (UnimplementedYakServer) GenerateYakCodeByPacket(context.Context, *GenerateYakCodeByPacketRequest) (*GenerateYakCodeByPacketResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GenerateYakCodeByPacket not implemented")
}
func (UnimplementedYakServer) GenerateCSRFPocByPacket(context.Context, *GenerateCSRFPocByPacketRequest) (*GenerateCSRFPocByPacketResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GenerateCSRFPocByPacket not implemented")
}
func (UnimplementedYakServer) ExportMITMReplacerRules(context.Context, *Empty) (*ExportMITMReplacerRulesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ExportMITMReplacerRules not implemented")
}
func (UnimplementedYakServer) ImportMITMReplacerRules(context.Context, *ImportMITMReplacerRulesRequest) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ImportMITMReplacerRules not implemented")
}
func (UnimplementedYakServer) GetCurrentRules(context.Context, *Empty) (*MITMContentReplacers, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetCurrentRules not implemented")
}
func (UnimplementedYakServer) SetCurrentRules(context.Context, *MITMContentReplacers) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetCurrentRules not implemented")
}
func (UnimplementedYakServer) ExtractDataToFile(Yak_ExtractDataToFileServer) error {
	return status.Errorf(codes.Unimplemented, "method ExtractDataToFile not implemented")
}
func (UnimplementedYakServer) AutoDecode(context.Context, *AutoDecodeRequest) (*AutoDecodeResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AutoDecode not implemented")
}
func (UnimplementedYakServer) GetSystemProxy(context.Context, *Empty) (*GetSystemProxyResult, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetSystemProxy not implemented")
}
func (UnimplementedYakServer) SetSystemProxy(context.Context, *SetSystemProxyRequest) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetSystemProxy not implemented")
}
func (UnimplementedYakServer) GetKey(context.Context, *GetKeyRequest) (*GetKeyResult, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetKey not implemented")
}
func (UnimplementedYakServer) SetKey(context.Context, *SetKeyRequest) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetKey not implemented")
}
func (UnimplementedYakServer) DelKey(context.Context, *GetKeyRequest) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DelKey not implemented")
}
func (UnimplementedYakServer) GetAllProcessEnvKey(context.Context, *Empty) (*GetProcessEnvKeyResult, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetAllProcessEnvKey not implemented")
}
func (UnimplementedYakServer) SetProcessEnvKey(context.Context, *SetKeyRequest) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetProcessEnvKey not implemented")
}
func (UnimplementedYakServer) GetProjectKey(context.Context, *GetKeyRequest) (*GetKeyResult, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetProjectKey not implemented")
}
func (UnimplementedYakServer) SetProjectKey(context.Context, *SetKeyRequest) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetProjectKey not implemented")
}
func (UnimplementedYakServer) GetOnlineProfile(context.Context, *Empty) (*OnlineProfile, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetOnlineProfile not implemented")
}
func (UnimplementedYakServer) SetOnlineProfile(context.Context, *OnlineProfile) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetOnlineProfile not implemented")
}
func (UnimplementedYakServer) DownloadOnlinePluginById(context.Context, *DownloadOnlinePluginByIdRequest) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DownloadOnlinePluginById not implemented")
}
func (UnimplementedYakServer) DownloadOnlinePluginByIds(context.Context, *DownloadOnlinePluginByIdsRequest) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DownloadOnlinePluginByIds not implemented")
}
func (UnimplementedYakServer) DownloadOnlinePluginAll(*DownloadOnlinePluginByTokenRequest, Yak_DownloadOnlinePluginAllServer) error {
	return status.Errorf(codes.Unimplemented, "method DownloadOnlinePluginAll not implemented")
}
func (UnimplementedYakServer) DeletePluginByUserID(context.Context, *DeletePluginByUserIDRequest) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeletePluginByUserID not implemented")
}
func (UnimplementedYakServer) DeleteAllLocalPlugins(context.Context, *Empty) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteAllLocalPlugins not implemented")
}
func (UnimplementedYakServer) GetYakScriptTagsAndType(context.Context, *Empty) (*GetYakScriptTagsAndTypeResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetYakScriptTagsAndType not implemented")
}
func (UnimplementedYakServer) DeleteLocalPluginsByWhere(context.Context, *DeleteLocalPluginsByWhereRequest) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteLocalPluginsByWhere not implemented")
}
func (UnimplementedYakServer) DownloadOnlinePluginByScriptNames(context.Context, *DownloadOnlinePluginByScriptNamesRequest) (*DownloadOnlinePluginByScriptNamesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DownloadOnlinePluginByScriptNames not implemented")
}
func (UnimplementedYakServer) ExecPacketScan(*ExecPacketScanRequest, Yak_ExecPacketScanServer) error {
	return status.Errorf(codes.Unimplemented, "method ExecPacketScan not implemented")
}
func (UnimplementedYakServer) GetEngineDefaultProxy(context.Context, *Empty) (*DefaultProxyResult, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetEngineDefaultProxy not implemented")
}
func (UnimplementedYakServer) SetEngineDefaultProxy(context.Context, *DefaultProxyResult) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetEngineDefaultProxy not implemented")
}
func (UnimplementedYakServer) GetMachineID(context.Context, *Empty) (*GetMachineIDResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetMachineID not implemented")
}
func (UnimplementedYakServer) GetLicense(context.Context, *Empty) (*GetLicenseResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetLicense not implemented")
}
func (UnimplementedYakServer) CheckLicense(context.Context, *CheckLicenseRequest) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CheckLicense not implemented")
}
func (UnimplementedYakServer) GetRequestBodyByHTTPFlowID(context.Context, *DownloadBodyByHTTPFlowIDRequest) (*Bytes, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetRequestBodyByHTTPFlowID not implemented")
}
func (UnimplementedYakServer) GetResponseBodyByHTTPFlowID(context.Context, *DownloadBodyByHTTPFlowIDRequest) (*Bytes, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetResponseBodyByHTTPFlowID not implemented")
}
func (UnimplementedYakServer) GetHTTPPacketBody(context.Context, *GetHTTPPacketBodyRequest) (*Bytes, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetHTTPPacketBody not implemented")
}
func (UnimplementedYakServer) RegisterFacadesHTTP(context.Context, *RegisterFacadesHTTPRequest) (*RegisterFacadesHTTPResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RegisterFacadesHTTP not implemented")
}
func (UnimplementedYakServer) ResetAndInvalidUserData(context.Context, *ResetAndInvalidUserDataRequest) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ResetAndInvalidUserData not implemented")
}
func (UnimplementedYakServer) CreateYaklangShell(Yak_CreateYaklangShellServer) error {
	return status.Errorf(codes.Unimplemented, "method CreateYaklangShell not implemented")
}
func (UnimplementedYakServer) AttachCombinedOutput(*AttachCombinedOutputRequest, Yak_AttachCombinedOutputServer) error {
	return status.Errorf(codes.Unimplemented, "method AttachCombinedOutput not implemented")
}
func (UnimplementedYakServer) IsPrivilegedForNetRaw(context.Context, *Empty) (*IsPrivilegedForNetRawResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method IsPrivilegedForNetRaw not implemented")
}
func (UnimplementedYakServer) PromotePermissionForUserPcap(context.Context, *Empty) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PromotePermissionForUserPcap not implemented")
}
func (UnimplementedYakServer) SetCurrentProject(context.Context, *SetCurrentProjectRequest) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetCurrentProject not implemented")
}
func (UnimplementedYakServer) GetCurrentProject(context.Context, *Empty) (*ProjectDescription, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetCurrentProject not implemented")
}
func (UnimplementedYakServer) GetProjects(context.Context, *GetProjectsRequest) (*GetProjectsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetProjects not implemented")
}
func (UnimplementedYakServer) NewProject(context.Context, *NewProjectRequest) (*NewProjectResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method NewProject not implemented")
}
func (UnimplementedYakServer) IsProjectNameValid(context.Context, *IsProjectNameValidRequest) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method IsProjectNameValid not implemented")
}
func (UnimplementedYakServer) RemoveProject(context.Context, *RemoveProjectRequest) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RemoveProject not implemented")
}
func (UnimplementedYakServer) DeleteProject(context.Context, *DeleteProjectRequest) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteProject not implemented")
}
func (UnimplementedYakServer) GetDefaultProject(context.Context, *Empty) (*ProjectDescription, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetDefaultProject not implemented")
}
func (UnimplementedYakServer) QueryProjectDetail(context.Context, *QueryProjectDetailRequest) (*ProjectDescription, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QueryProjectDetail not implemented")
}
func (UnimplementedYakServer) ExportProject(*ExportProjectRequest, Yak_ExportProjectServer) error {
	return status.Errorf(codes.Unimplemented, "method ExportProject not implemented")
}
func (UnimplementedYakServer) ImportProject(*ImportProjectRequest, Yak_ImportProjectServer) error {
	return status.Errorf(codes.Unimplemented, "method ImportProject not implemented")
}
func (UnimplementedYakServer) MigrateLegacyDatabase(context.Context, *Empty) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method MigrateLegacyDatabase not implemented")
}
func (UnimplementedYakServer) QueryMITMRuleExtractedData(context.Context, *QueryMITMRuleExtractedDataRequest) (*QueryMITMRuleExtractedDataResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QueryMITMRuleExtractedData not implemented")
}
func (UnimplementedYakServer) ImportChaosMakerRules(context.Context, *ImportChaosMakerRulesRequest) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ImportChaosMakerRules not implemented")
}
func (UnimplementedYakServer) QueryChaosMakerRule(context.Context, *QueryChaosMakerRuleRequest) (*QueryChaosMakerRuleResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QueryChaosMakerRule not implemented")
}
func (UnimplementedYakServer) DeleteChaosMakerRuleByID(context.Context, *DeleteChaosMakerRuleByIDRequest) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteChaosMakerRuleByID not implemented")
}
func (UnimplementedYakServer) ExecuteChaosMakerRule(*ExecuteChaosMakerRuleRequest, Yak_ExecuteChaosMakerRuleServer) error {
	return status.Errorf(codes.Unimplemented, "method ExecuteChaosMakerRule not implemented")
}
func (UnimplementedYakServer) IsRemoteAddrAvailable(context.Context, *IsRemoteAddrAvailableRequest) (*IsRemoteAddrAvailableResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method IsRemoteAddrAvailable not implemented")
}
func (UnimplementedYakServer) ConnectVulinboxAgent(context.Context, *IsRemoteAddrAvailableRequest) (*IsRemoteAddrAvailableResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ConnectVulinboxAgent not implemented")
}
func (UnimplementedYakServer) GetRegisteredVulinboxAgent(context.Context, *GetRegisteredAgentRequest) (*GetRegisteredAgentResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetRegisteredVulinboxAgent not implemented")
}
func (UnimplementedYakServer) DisconnectVulinboxAgent(context.Context, *DisconnectVulinboxAgentRequest) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DisconnectVulinboxAgent not implemented")
}
func (UnimplementedYakServer) IsCVEDatabaseReady(context.Context, *IsCVEDatabaseReadyRequest) (*IsCVEDatabaseReadyResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method IsCVEDatabaseReady not implemented")
}
func (UnimplementedYakServer) UpdateCVEDatabase(*UpdateCVEDatabaseRequest, Yak_UpdateCVEDatabaseServer) error {
	return status.Errorf(codes.Unimplemented, "method UpdateCVEDatabase not implemented")
}
func (UnimplementedYakServer) ExportsProfileDatabase(*ExportsProfileDatabaseRequest, Yak_ExportsProfileDatabaseServer) error {
	return status.Errorf(codes.Unimplemented, "method ExportsProfileDatabase not implemented")
}
func (UnimplementedYakServer) ImportsProfileDatabase(*ImportsProfileDatabaseRequest, Yak_ImportsProfileDatabaseServer) error {
	return status.Errorf(codes.Unimplemented, "method ImportsProfileDatabase not implemented")
}
func (UnimplementedYakServer) QueryCVE(context.Context, *QueryCVERequest) (*QueryCVEResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QueryCVE not implemented")
}
func (UnimplementedYakServer) GetCVE(context.Context, *GetCVERequest) (*CVEDetailEx, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetCVE not implemented")
}
func (UnimplementedYakServer) SaveTextToTemporalFile(context.Context, *SaveTextToTemporalFileRequest) (*SaveTextToTemporalFileResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SaveTextToTemporalFile not implemented")
}
func (UnimplementedYakServer) IsScrecorderReady(context.Context, *IsScrecorderReadyRequest) (*IsScrecorderReadyResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method IsScrecorderReady not implemented")
}
func (UnimplementedYakServer) InstallScrecorder(*InstallScrecorderRequest, Yak_InstallScrecorderServer) error {
	return status.Errorf(codes.Unimplemented, "method InstallScrecorder not implemented")
}
func (UnimplementedYakServer) StartScrecorder(*StartScrecorderRequest, Yak_StartScrecorderServer) error {
	return status.Errorf(codes.Unimplemented, "method StartScrecorder not implemented")
}
func (UnimplementedYakServer) QueryScreenRecorders(context.Context, *QueryScreenRecorderRequest) (*QueryScreenRecorderResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QueryScreenRecorders not implemented")
}
func (UnimplementedYakServer) DeleteScreenRecorders(context.Context, *QueryScreenRecorderRequest) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteScreenRecorders not implemented")
}
func (UnimplementedYakServer) UploadScreenRecorders(context.Context, *UploadScreenRecorderRequest) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UploadScreenRecorders not implemented")
}
func (UnimplementedYakServer) GetOneScreenRecorders(context.Context, *GetOneScreenRecorderRequest) (*ScreenRecorder, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetOneScreenRecorders not implemented")
}
func (UnimplementedYakServer) UpdateScreenRecorders(context.Context, *UpdateScreenRecorderRequest) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateScreenRecorders not implemented")
}
func (UnimplementedYakServer) IsVulinboxReady(context.Context, *IsVulinboxReadyRequest) (*IsVulinboxReadyResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method IsVulinboxReady not implemented")
}
func (UnimplementedYakServer) InstallVulinbox(*InstallVulinboxRequest, Yak_InstallVulinboxServer) error {
	return status.Errorf(codes.Unimplemented, "method InstallVulinbox not implemented")
}
func (UnimplementedYakServer) StartVulinbox(*StartVulinboxRequest, Yak_StartVulinboxServer) error {
	return status.Errorf(codes.Unimplemented, "method StartVulinbox not implemented")
}
func (UnimplementedYakServer) GenQualityInspectionReport(*GenQualityInspectionReportRequest, Yak_GenQualityInspectionReportServer) error {
	return status.Errorf(codes.Unimplemented, "method GenQualityInspectionReport not implemented")
}
func (UnimplementedYakServer) HTTPRequestBuilder(context.Context, *HTTPRequestBuilderParams) (*HTTPRequestBuilderResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method HTTPRequestBuilder not implemented")
}
func (UnimplementedYakServer) DebugPlugin(*DebugPluginRequest, Yak_DebugPluginServer) error {
	return status.Errorf(codes.Unimplemented, "method DebugPlugin not implemented")
}
func (UnimplementedYakServer) SmokingEvaluatePlugin(context.Context, *SmokingEvaluatePluginRequest) (*SmokingEvaluatePluginResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SmokingEvaluatePlugin not implemented")
}
func (UnimplementedYakServer) GetSystemDefaultDnsServers(context.Context, *Empty) (*DefaultDnsServerResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetSystemDefaultDnsServers not implemented")
}
func (UnimplementedYakServer) DiagnoseNetwork(*DiagnoseNetworkRequest, Yak_DiagnoseNetworkServer) error {
	return status.Errorf(codes.Unimplemented, "method DiagnoseNetwork not implemented")
}
func (UnimplementedYakServer) DiagnoseNetworkDNS(*DiagnoseNetworkDNSRequest, Yak_DiagnoseNetworkDNSServer) error {
	return status.Errorf(codes.Unimplemented, "method DiagnoseNetworkDNS not implemented")
}
func (UnimplementedYakServer) GetGlobalNetworkConfig(context.Context, *GetGlobalNetworkConfigRequest) (*GlobalNetworkConfig, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetGlobalNetworkConfig not implemented")
}
func (UnimplementedYakServer) SetGlobalNetworkConfig(context.Context, *GlobalNetworkConfig) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetGlobalNetworkConfig not implemented")
}
func (UnimplementedYakServer) ResetGlobalNetworkConfig(context.Context, *ResetGlobalNetworkConfigRequest) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ResetGlobalNetworkConfig not implemented")
}
func (UnimplementedYakServer) ValidP12PassWord(context.Context, *ValidP12PassWordRequest) (*ValidP12PassWordResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ValidP12PassWord not implemented")
}
func (UnimplementedYakServer) RequestYakURL(context.Context, *RequestYakURLParams) (*RequestYakURLResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RequestYakURL not implemented")
}
func (UnimplementedYakServer) GetPcapMetadata(context.Context, *PcapMetadataRequest) (*PcapMetadata, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetPcapMetadata not implemented")
}
func (UnimplementedYakServer) PcapX(Yak_PcapXServer) error {
	return status.Errorf(codes.Unimplemented, "method PcapX not implemented")
}
func (UnimplementedYakServer) QueryTrafficSession(context.Context, *QueryTrafficSessionRequest) (*QueryTrafficSessionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QueryTrafficSession not implemented")
}
func (UnimplementedYakServer) QueryTrafficPacket(context.Context, *QueryTrafficPacketRequest) (*QueryTrafficPacketResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QueryTrafficPacket not implemented")
}
func (UnimplementedYakServer) QueryTrafficTCPReassembled(context.Context, *QueryTrafficTCPReassembledRequest) (*QueryTrafficTCPReassembledResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QueryTrafficTCPReassembled not implemented")
}
func (UnimplementedYakServer) DuplexConnection(Yak_DuplexConnectionServer) error {
	return status.Errorf(codes.Unimplemented, "method DuplexConnection not implemented")
}
func (UnimplementedYakServer) mustEmbedUnimplementedYakServer() {}

// UnsafeYakServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to YakServer will
// result in compilation errors.
type UnsafeYakServer interface {
	mustEmbedUnimplementedYakServer()
}

func RegisterYakServer(s grpc.ServiceRegistrar, srv YakServer) {
	s.RegisterService(&Yak_ServiceDesc, srv)
}

func _Yak_Version_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).Version(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ypb.Yak/Version",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).Version(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_Echo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EchoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).Echo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ypb.Yak/Echo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).Echo(ctx, req.(*EchoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_MITM_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(YakServer).MITM(&yakMITMServer{stream})
}

type Yak_MITMServer interface {
	Send(*MITMResponse) error
	Recv() (*MITMRequest, error)
	grpc.ServerStream
}

type yakMITMServer struct {
	grpc.ServerStream
}

func (x *yakMITMServer) Send(m *MITMResponse) error {
	return x.ServerStream.SendMsg(m)
}

func (x *yakMITMServer) Recv() (*MITMRequest, error) {
	m := new(MITMRequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _Yak_SetMITMFilter_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetMITMFilterRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).SetMITMFilter(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ypb.Yak/SetMITMFilter",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).SetMITMFilter(ctx, req.(*SetMITMFilterRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_GetMITMFilter_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).GetMITMFilter(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ypb.Yak/GetMITMFilter",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).GetMITMFilter(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_DownloadMITMCert_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).DownloadMITMCert(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ypb.Yak/DownloadMITMCert",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).DownloadMITMCert(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_OpenPort_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(YakServer).OpenPort(&yakOpenPortServer{stream})
}

type Yak_OpenPortServer interface {
	Send(*Output) error
	Recv() (*Input, error)
	grpc.ServerStream
}

type yakOpenPortServer struct {
	grpc.ServerStream
}

func (x *yakOpenPortServer) Send(m *Output) error {
	return x.ServerStream.SendMsg(m)
}

func (x *yakOpenPortServer) Recv() (*Input, error) {
	m := new(Input)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _Yak_Exec_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(ExecRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(YakServer).Exec(m, &yakExecServer{stream})
}

type Yak_ExecServer interface {
	Send(*ExecResult) error
	grpc.ServerStream
}

type yakExecServer struct {
	grpc.ServerStream
}

func (x *yakExecServer) Send(m *ExecResult) error {
	return x.ServerStream.SendMsg(m)
}

func _Yak_QueryExecHistory_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ExecHistoryRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).QueryExecHistory(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ypb.Yak/QueryExecHistory",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).QueryExecHistory(ctx, req.(*ExecHistoryRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_RemoveExecHistory_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).RemoveExecHistory(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ypb.Yak/RemoveExecHistory",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).RemoveExecHistory(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_LoadNucleiTemplates_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).LoadNucleiTemplates(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ypb.Yak/LoadNucleiTemplates",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).LoadNucleiTemplates(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_AutoUpdateYakModule_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(Empty)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(YakServer).AutoUpdateYakModule(m, &yakAutoUpdateYakModuleServer{stream})
}

type Yak_AutoUpdateYakModuleServer interface {
	Send(*ExecResult) error
	grpc.ServerStream
}

type yakAutoUpdateYakModuleServer struct {
	grpc.ServerStream
}

func (x *yakAutoUpdateYakModuleServer) Send(m *ExecResult) error {
	return x.ServerStream.SendMsg(m)
}

func _Yak_ExecYakScript_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(ExecRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(YakServer).ExecYakScript(m, &yakExecYakScriptServer{stream})
}

type Yak_ExecYakScriptServer interface {
	Send(*ExecResult) error
	grpc.ServerStream
}

type yakExecYakScriptServer struct {
	grpc.ServerStream
}

func (x *yakExecYakScriptServer) Send(m *ExecResult) error {
	return x.ServerStream.SendMsg(m)
}

func _Yak_ExecBatchYakScript_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(ExecBatchYakScriptRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(YakServer).ExecBatchYakScript(m, &yakExecBatchYakScriptServer{stream})
}

type Yak_ExecBatchYakScriptServer interface {
	Send(*ExecBatchYakScriptResult) error
	grpc.ServerStream
}

type yakExecBatchYakScriptServer struct {
	grpc.ServerStream
}

func (x *yakExecBatchYakScriptServer) Send(m *ExecBatchYakScriptResult) error {
	return x.ServerStream.SendMsg(m)
}

func _Yak_GetExecBatchYakScriptUnfinishedTask_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).GetExecBatchYakScriptUnfinishedTask(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ypb.Yak/GetExecBatchYakScriptUnfinishedTask",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).GetExecBatchYakScriptUnfinishedTask(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_GetExecBatchYakScriptUnfinishedTaskByUid_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetExecBatchYakScriptUnfinishedTaskByUidRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).GetExecBatchYakScriptUnfinishedTaskByUid(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ypb.Yak/GetExecBatchYakScriptUnfinishedTaskByUid",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).GetExecBatchYakScriptUnfinishedTaskByUid(ctx, req.(*GetExecBatchYakScriptUnfinishedTaskByUidRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_PopExecBatchYakScriptUnfinishedTaskByUid_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetExecBatchYakScriptUnfinishedTaskByUidRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).PopExecBatchYakScriptUnfinishedTaskByUid(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ypb.Yak/PopExecBatchYakScriptUnfinishedTaskByUid",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).PopExecBatchYakScriptUnfinishedTaskByUid(ctx, req.(*GetExecBatchYakScriptUnfinishedTaskByUidRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_RecoverExecBatchYakScriptUnfinishedTask_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(RecoverExecBatchYakScriptUnfinishedTaskRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(YakServer).RecoverExecBatchYakScriptUnfinishedTask(m, &yakRecoverExecBatchYakScriptUnfinishedTaskServer{stream})
}

type Yak_RecoverExecBatchYakScriptUnfinishedTaskServer interface {
	Send(*ExecBatchYakScriptResult) error
	grpc.ServerStream
}

type yakRecoverExecBatchYakScriptUnfinishedTaskServer struct {
	grpc.ServerStream
}

func (x *yakRecoverExecBatchYakScriptUnfinishedTaskServer) Send(m *ExecBatchYakScriptResult) error {
	return x.ServerStream.SendMsg(m)
}

func _Yak_QueryYakScript_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryYakScriptRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).QueryYakScript(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ypb.Yak/QueryYakScript",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).QueryYakScript(ctx, req.(*QueryYakScriptRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_QueryYakScriptByYakScriptName_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(QueryYakScriptRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(YakServer).QueryYakScriptByYakScriptName(m, &yakQueryYakScriptByYakScriptNameServer{stream})
}

type Yak_QueryYakScriptByYakScriptNameServer interface {
	Send(*YakScript) error
	grpc.ServerStream
}

type yakQueryYakScriptByYakScriptNameServer struct {
	grpc.ServerStream
}

func (x *yakQueryYakScriptByYakScriptNameServer) Send(m *YakScript) error {
	return x.ServerStream.SendMsg(m)
}

func _Yak_SaveYakScript_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(YakScript)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).SaveYakScript(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ypb.Yak/SaveYakScript",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).SaveYakScript(ctx, req.(*YakScript))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_DeleteYakScript_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteYakScriptRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).DeleteYakScript(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ypb.Yak/DeleteYakScript",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).DeleteYakScript(ctx, req.(*DeleteYakScriptRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_GetYakScriptById_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetYakScriptByIdRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).GetYakScriptById(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ypb.Yak/GetYakScriptById",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).GetYakScriptById(ctx, req.(*GetYakScriptByIdRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_GetYakScriptByName_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetYakScriptByNameRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).GetYakScriptByName(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ypb.Yak/GetYakScriptByName",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).GetYakScriptByName(ctx, req.(*GetYakScriptByNameRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_GetYakScriptByOnlineID_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetYakScriptByOnlineIDRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).GetYakScriptByOnlineID(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ypb.Yak/GetYakScriptByOnlineID",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).GetYakScriptByOnlineID(ctx, req.(*GetYakScriptByOnlineIDRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_IgnoreYakScript_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteYakScriptRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).IgnoreYakScript(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ypb.Yak/IgnoreYakScript",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).IgnoreYakScript(ctx, req.(*DeleteYakScriptRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_UnIgnoreYakScript_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteYakScriptRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).UnIgnoreYakScript(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ypb.Yak/UnIgnoreYakScript",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).UnIgnoreYakScript(ctx, req.(*DeleteYakScriptRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_ExportYakScript_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ExportYakScriptRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).ExportYakScript(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ypb.Yak/ExportYakScript",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).ExportYakScript(ctx, req.(*ExportYakScriptRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_ExecutePacketYakScript_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(ExecutePacketYakScriptParams)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(YakServer).ExecutePacketYakScript(m, &yakExecutePacketYakScriptServer{stream})
}

type Yak_ExecutePacketYakScriptServer interface {
	Send(*ExecResult) error
	grpc.ServerStream
}

type yakExecutePacketYakScriptServer struct {
	grpc.ServerStream
}

func (x *yakExecutePacketYakScriptServer) Send(m *ExecResult) error {
	return x.ServerStream.SendMsg(m)
}

func _Yak_ExecuteBatchPacketYakScript_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(ExecuteBatchPacketYakScriptParams)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(YakServer).ExecuteBatchPacketYakScript(m, &yakExecuteBatchPacketYakScriptServer{stream})
}

type Yak_ExecuteBatchPacketYakScriptServer interface {
	Send(*ExecBatchYakScriptResult) error
	grpc.ServerStream
}

type yakExecuteBatchPacketYakScriptServer struct {
	grpc.ServerStream
}

func (x *yakExecuteBatchPacketYakScriptServer) Send(m *ExecBatchYakScriptResult) error {
	return x.ServerStream.SendMsg(m)
}

func _Yak_GetYakScriptTags_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).GetYakScriptTags(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ypb.Yak/GetYakScriptTags",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).GetYakScriptTags(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_QueryYakScriptLocalAndUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryYakScriptLocalAndUserRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).QueryYakScriptLocalAndUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ypb.Yak/QueryYakScriptLocalAndUser",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).QueryYakScriptLocalAndUser(ctx, req.(*QueryYakScriptLocalAndUserRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_QueryYakScriptByOnlineGroup_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryYakScriptByOnlineGroupRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).QueryYakScriptByOnlineGroup(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ypb.Yak/QueryYakScriptByOnlineGroup",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).QueryYakScriptByOnlineGroup(ctx, req.(*QueryYakScriptByOnlineGroupRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_QueryYakScriptLocalAll_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).QueryYakScriptLocalAll(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ypb.Yak/QueryYakScriptLocalAll",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).QueryYakScriptLocalAll(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_QueryYakScriptByNames_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryYakScriptByNamesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).QueryYakScriptByNames(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ypb.Yak/QueryYakScriptByNames",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).QueryYakScriptByNames(ctx, req.(*QueryYakScriptByNamesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_QueryYakScriptByIsCore_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryYakScriptByIsCoreRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).QueryYakScriptByIsCore(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ypb.Yak/QueryYakScriptByIsCore",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).QueryYakScriptByIsCore(ctx, req.(*QueryYakScriptByIsCoreRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_GetHTTPFlowByHash_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetHTTPFlowByHashRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).GetHTTPFlowByHash(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ypb.Yak/GetHTTPFlowByHash",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).GetHTTPFlowByHash(ctx, req.(*GetHTTPFlowByHashRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_GetHTTPFlowById_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetHTTPFlowByIdRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).GetHTTPFlowById(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ypb.Yak/GetHTTPFlowById",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).GetHTTPFlowById(ctx, req.(*GetHTTPFlowByIdRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_GetHTTPFlowByIds_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetHTTPFlowByIdsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).GetHTTPFlowByIds(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ypb.Yak/GetHTTPFlowByIds",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).GetHTTPFlowByIds(ctx, req.(*GetHTTPFlowByIdsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_QueryHTTPFlows_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryHTTPFlowRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).QueryHTTPFlows(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ypb.Yak/QueryHTTPFlows",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).QueryHTTPFlows(ctx, req.(*QueryHTTPFlowRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_DeleteHTTPFlows_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteHTTPFlowRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).DeleteHTTPFlows(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ypb.Yak/DeleteHTTPFlows",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).DeleteHTTPFlows(ctx, req.(*DeleteHTTPFlowRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_SetTagForHTTPFlow_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetTagForHTTPFlowRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).SetTagForHTTPFlow(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ypb.Yak/SetTagForHTTPFlow",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).SetTagForHTTPFlow(ctx, req.(*SetTagForHTTPFlowRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_QueryHTTPFlowsIds_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryHTTPFlowsIdsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).QueryHTTPFlowsIds(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ypb.Yak/QueryHTTPFlowsIds",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).QueryHTTPFlowsIds(ctx, req.(*QueryHTTPFlowsIdsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_HTTPFlowsFieldGroup_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(HTTPFlowsFieldGroupRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).HTTPFlowsFieldGroup(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ypb.Yak/HTTPFlowsFieldGroup",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).HTTPFlowsFieldGroup(ctx, req.(*HTTPFlowsFieldGroupRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_HTTPFlowsShare_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(HTTPFlowsShareRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).HTTPFlowsShare(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ypb.Yak/HTTPFlowsShare",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).HTTPFlowsShare(ctx, req.(*HTTPFlowsShareRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_HTTPFlowsExtract_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(HTTPFlowsExtractRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).HTTPFlowsExtract(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ypb.Yak/HTTPFlowsExtract",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).HTTPFlowsExtract(ctx, req.(*HTTPFlowsExtractRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_GetHTTPFlowBare_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(HTTPFlowBareRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).GetHTTPFlowBare(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ypb.Yak/GetHTTPFlowBare",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).GetHTTPFlowBare(ctx, req.(*HTTPFlowBareRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_ExtractUrl_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FuzzerRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).ExtractUrl(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ypb.Yak/ExtractUrl",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).ExtractUrl(ctx, req.(*FuzzerRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_GetHistoryHTTPFuzzerTask_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetHistoryHTTPFuzzerTaskRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).GetHistoryHTTPFuzzerTask(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ypb.Yak/GetHistoryHTTPFuzzerTask",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).GetHistoryHTTPFuzzerTask(ctx, req.(*GetHistoryHTTPFuzzerTaskRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_QueryHistoryHTTPFuzzerTask_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).QueryHistoryHTTPFuzzerTask(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ypb.Yak/QueryHistoryHTTPFuzzerTask",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).QueryHistoryHTTPFuzzerTask(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_QueryHistoryHTTPFuzzerTaskEx_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryHistoryHTTPFuzzerTaskExParams)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).QueryHistoryHTTPFuzzerTaskEx(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ypb.Yak/QueryHistoryHTTPFuzzerTaskEx",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).QueryHistoryHTTPFuzzerTaskEx(ctx, req.(*QueryHistoryHTTPFuzzerTaskExParams))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_DeleteHistoryHTTPFuzzerTask_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteHistoryHTTPFuzzerTaskRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).DeleteHistoryHTTPFuzzerTask(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ypb.Yak/DeleteHistoryHTTPFuzzerTask",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).DeleteHistoryHTTPFuzzerTask(ctx, req.(*DeleteHistoryHTTPFuzzerTaskRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_HTTPFuzzer_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(FuzzerRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(YakServer).HTTPFuzzer(m, &yakHTTPFuzzerServer{stream})
}

type Yak_HTTPFuzzerServer interface {
	Send(*FuzzerResponse) error
	grpc.ServerStream
}

type yakHTTPFuzzerServer struct {
	grpc.ServerStream
}

func (x *yakHTTPFuzzerServer) Send(m *FuzzerResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _Yak_HTTPFuzzerSequence_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(FuzzerRequests)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(YakServer).HTTPFuzzerSequence(m, &yakHTTPFuzzerSequenceServer{stream})
}

type Yak_HTTPFuzzerSequenceServer interface {
	Send(*FuzzerSequenceResponse) error
	grpc.ServerStream
}

type yakHTTPFuzzerSequenceServer struct {
	grpc.ServerStream
}

func (x *yakHTTPFuzzerSequenceServer) Send(m *FuzzerSequenceResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _Yak_PreloadHTTPFuzzerParams_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PreloadHTTPFuzzerParamsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).PreloadHTTPFuzzerParams(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ypb.Yak/PreloadHTTPFuzzerParams",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).PreloadHTTPFuzzerParams(ctx, req.(*PreloadHTTPFuzzerParamsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_RenderVariables_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RenderVariablesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).RenderVariables(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ypb.Yak/RenderVariables",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).RenderVariables(ctx, req.(*RenderVariablesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_MatchHTTPResponse_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MatchHTTPResponseParams)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).MatchHTTPResponse(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ypb.Yak/MatchHTTPResponse",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).MatchHTTPResponse(ctx, req.(*MatchHTTPResponseParams))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_ExtractHTTPResponse_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ExtractHTTPResponseParams)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).ExtractHTTPResponse(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ypb.Yak/ExtractHTTPResponse",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).ExtractHTTPResponse(ctx, req.(*ExtractHTTPResponseParams))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_RedirectRequest_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RedirectRequestParams)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).RedirectRequest(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ypb.Yak/RedirectRequest",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).RedirectRequest(ctx, req.(*RedirectRequestParams))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_HTTPRequestMutate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(HTTPRequestMutateParams)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).HTTPRequestMutate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ypb.Yak/HTTPRequestMutate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).HTTPRequestMutate(ctx, req.(*HTTPRequestMutateParams))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_HTTPResponseMutate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(HTTPResponseMutateParams)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).HTTPResponseMutate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ypb.Yak/HTTPResponseMutate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).HTTPResponseMutate(ctx, req.(*HTTPResponseMutateParams))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_FixUploadPacket_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FixUploadPacketRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).FixUploadPacket(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ypb.Yak/FixUploadPacket",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).FixUploadPacket(ctx, req.(*FixUploadPacketRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_IsMultipartFormDataRequest_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FixUploadPacketRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).IsMultipartFormDataRequest(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ypb.Yak/IsMultipartFormDataRequest",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).IsMultipartFormDataRequest(ctx, req.(*FixUploadPacketRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_GenerateExtractRule_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GenerateExtractRuleRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).GenerateExtractRule(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ypb.Yak/GenerateExtractRule",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).GenerateExtractRule(ctx, req.(*GenerateExtractRuleRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_ExtractData_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(YakServer).ExtractData(&yakExtractDataServer{stream})
}

type Yak_ExtractDataServer interface {
	Send(*ExtractDataResponse) error
	Recv() (*ExtractDataRequest, error)
	grpc.ServerStream
}

type yakExtractDataServer struct {
	grpc.ServerStream
}

func (x *yakExtractDataServer) Send(m *ExtractDataResponse) error {
	return x.ServerStream.SendMsg(m)
}

func (x *yakExtractDataServer) Recv() (*ExtractDataRequest, error) {
	m := new(ExtractDataRequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _Yak_ImportHTTPFuzzerTaskFromYaml_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ImportHTTPFuzzerTaskFromYamlRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).ImportHTTPFuzzerTaskFromYaml(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ypb.Yak/ImportHTTPFuzzerTaskFromYaml",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).ImportHTTPFuzzerTaskFromYaml(ctx, req.(*ImportHTTPFuzzerTaskFromYamlRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_ExportHTTPFuzzerTaskToYaml_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ExportHTTPFuzzerTaskToYamlRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).ExportHTTPFuzzerTaskToYaml(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ypb.Yak/ExportHTTPFuzzerTaskToYaml",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).ExportHTTPFuzzerTaskToYaml(ctx, req.(*ExportHTTPFuzzerTaskToYamlRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_SaveFuzzerLabel_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SaveFuzzerLabelRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).SaveFuzzerLabel(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ypb.Yak/SaveFuzzerLabel",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).SaveFuzzerLabel(ctx, req.(*SaveFuzzerLabelRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_QueryFuzzerLabel_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).QueryFuzzerLabel(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ypb.Yak/QueryFuzzerLabel",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).QueryFuzzerLabel(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_DeleteFuzzerLabel_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteFuzzerLabelRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).DeleteFuzzerLabel(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ypb.Yak/DeleteFuzzerLabel",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).DeleteFuzzerLabel(ctx, req.(*DeleteFuzzerLabelRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_QueryHTTPFuzzerResponseByTaskId_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryHTTPFuzzerResponseByTaskIdRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).QueryHTTPFuzzerResponseByTaskId(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ypb.Yak/QueryHTTPFuzzerResponseByTaskId",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).QueryHTTPFuzzerResponseByTaskId(ctx, req.(*QueryHTTPFuzzerResponseByTaskIdRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_CreateWebsocketFuzzer_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(YakServer).CreateWebsocketFuzzer(&yakCreateWebsocketFuzzerServer{stream})
}

type Yak_CreateWebsocketFuzzerServer interface {
	Send(*ClientWebsocketResponse) error
	Recv() (*ClientWebsocketRequest, error)
	grpc.ServerStream
}

type yakCreateWebsocketFuzzerServer struct {
	grpc.ServerStream
}

func (x *yakCreateWebsocketFuzzerServer) Send(m *ClientWebsocketResponse) error {
	return x.ServerStream.SendMsg(m)
}

func (x *yakCreateWebsocketFuzzerServer) Recv() (*ClientWebsocketRequest, error) {
	m := new(ClientWebsocketRequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _Yak_QueryWebsocketFlowByHTTPFlowWebsocketHash_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryWebsocketFlowByHTTPFlowWebsocketHashRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).QueryWebsocketFlowByHTTPFlowWebsocketHash(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ypb.Yak/QueryWebsocketFlowByHTTPFlowWebsocketHash",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).QueryWebsocketFlowByHTTPFlowWebsocketHash(ctx, req.(*QueryWebsocketFlowByHTTPFlowWebsocketHashRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_DeleteWebsocketFlowByHTTPFlowWebsocketHash_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteWebsocketFlowByHTTPFlowWebsocketHashRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).DeleteWebsocketFlowByHTTPFlowWebsocketHash(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ypb.Yak/DeleteWebsocketFlowByHTTPFlowWebsocketHash",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).DeleteWebsocketFlowByHTTPFlowWebsocketHash(ctx, req.(*DeleteWebsocketFlowByHTTPFlowWebsocketHashRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_DeleteWebsocketFlowAll_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).DeleteWebsocketFlowAll(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ypb.Yak/DeleteWebsocketFlowAll",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).DeleteWebsocketFlowAll(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_ConvertFuzzerResponseToHTTPFlow_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FuzzerResponse)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).ConvertFuzzerResponseToHTTPFlow(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ypb.Yak/ConvertFuzzerResponseToHTTPFlow",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).ConvertFuzzerResponseToHTTPFlow(ctx, req.(*FuzzerResponse))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_StringFuzzer_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StringFuzzerRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).StringFuzzer(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ypb.Yak/StringFuzzer",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).StringFuzzer(ctx, req.(*StringFuzzerRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_HTTPRequestAnalyzer_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(HTTPRequestAnalysisMaterial)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).HTTPRequestAnalyzer(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ypb.Yak/HTTPRequestAnalyzer",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).HTTPRequestAnalyzer(ctx, req.(*HTTPRequestAnalysisMaterial))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_Codec_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CodecRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).Codec(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ypb.Yak/Codec",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).Codec(ctx, req.(*CodecRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_NewCodec_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CodecRequestFlow)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).NewCodec(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ypb.Yak/NewCodec",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).NewCodec(ctx, req.(*CodecRequestFlow))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_PacketPrettifyHelper_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PacketPrettifyHelperRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).PacketPrettifyHelper(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ypb.Yak/PacketPrettifyHelper",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).PacketPrettifyHelper(ctx, req.(*PacketPrettifyHelperRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_QueryPayload_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryPayloadRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).QueryPayload(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ypb.Yak/QueryPayload",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).QueryPayload(ctx, req.(*QueryPayloadRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_DeletePayloadByGroup_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeletePayloadByGroupRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).DeletePayloadByGroup(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ypb.Yak/DeletePayloadByGroup",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).DeletePayloadByGroup(ctx, req.(*DeletePayloadByGroupRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_DeletePayload_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeletePayloadRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).DeletePayload(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ypb.Yak/DeletePayload",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).DeletePayload(ctx, req.(*DeletePayloadRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_SavePayload_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SavePayloadRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).SavePayload(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ypb.Yak/SavePayload",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).SavePayload(ctx, req.(*SavePayloadRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_SavePayloadStream_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(SavePayloadRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(YakServer).SavePayloadStream(m, &yakSavePayloadStreamServer{stream})
}

type Yak_SavePayloadStreamServer interface {
	Send(*SavePayloadProgress) error
	grpc.ServerStream
}

type yakSavePayloadStreamServer struct {
	grpc.ServerStream
}

func (x *yakSavePayloadStreamServer) Send(m *SavePayloadProgress) error {
	return x.ServerStream.SendMsg(m)
}

func _Yak_GetAllPayloadGroup_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).GetAllPayloadGroup(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ypb.Yak/GetAllPayloadGroup",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).GetAllPayloadGroup(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_UpdatePayload_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdatePayloadRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).UpdatePayload(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ypb.Yak/UpdatePayload",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).UpdatePayload(ctx, req.(*UpdatePayloadRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_GetAllPayload_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetAllPayloadRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).GetAllPayload(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ypb.Yak/GetAllPayload",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).GetAllPayload(ctx, req.(*GetAllPayloadRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_GetYakitCompletionRaw_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).GetYakitCompletionRaw(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ypb.Yak/GetYakitCompletionRaw",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).GetYakitCompletionRaw(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_GetYakVMBuildInMethodCompletion_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetYakVMBuildInMethodCompletionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).GetYakVMBuildInMethodCompletion(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ypb.Yak/GetYakVMBuildInMethodCompletion",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).GetYakVMBuildInMethodCompletion(ctx, req.(*GetYakVMBuildInMethodCompletionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_StaticAnalyzeError_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StaticAnalyzeErrorRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).StaticAnalyzeError(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ypb.Yak/StaticAnalyzeError",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).StaticAnalyzeError(ctx, req.(*StaticAnalyzeErrorRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_YaklangCompileAndFormat_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(YaklangCompileAndFormatRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).YaklangCompileAndFormat(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ypb.Yak/YaklangCompileAndFormat",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).YaklangCompileAndFormat(ctx, req.(*YaklangCompileAndFormatRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_PortScan_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(PortScanRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(YakServer).PortScan(m, &yakPortScanServer{stream})
}

type Yak_PortScanServer interface {
	Send(*ExecResult) error
	grpc.ServerStream
}

type yakPortScanServer struct {
	grpc.ServerStream
}

func (x *yakPortScanServer) Send(m *ExecResult) error {
	return x.ServerStream.SendMsg(m)
}

func _Yak_ViewPortScanCode_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).ViewPortScanCode(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ypb.Yak/ViewPortScanCode",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).ViewPortScanCode(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_SimpleDetect_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(RecordPortScanRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(YakServer).SimpleDetect(m, &yakSimpleDetectServer{stream})
}

type Yak_SimpleDetectServer interface {
	Send(*ExecResult) error
	grpc.ServerStream
}

type yakSimpleDetectServer struct {
	grpc.ServerStream
}

func (x *yakSimpleDetectServer) Send(m *ExecResult) error {
	return x.ServerStream.SendMsg(m)
}

func _Yak_SaveCancelSimpleDetect_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RecordPortScanRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).SaveCancelSimpleDetect(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ypb.Yak/SaveCancelSimpleDetect",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).SaveCancelSimpleDetect(ctx, req.(*RecordPortScanRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_GetSimpleDetectUnfinishedTask_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).GetSimpleDetectUnfinishedTask(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ypb.Yak/GetSimpleDetectUnfinishedTask",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).GetSimpleDetectUnfinishedTask(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_GetSimpleDetectUnfinishedTaskByUid_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetExecBatchYakScriptUnfinishedTaskByUidRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).GetSimpleDetectUnfinishedTaskByUid(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ypb.Yak/GetSimpleDetectUnfinishedTaskByUid",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).GetSimpleDetectUnfinishedTaskByUid(ctx, req.(*GetExecBatchYakScriptUnfinishedTaskByUidRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_PopSimpleDetectUnfinishedTaskByUid_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetExecBatchYakScriptUnfinishedTaskByUidRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).PopSimpleDetectUnfinishedTaskByUid(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ypb.Yak/PopSimpleDetectUnfinishedTaskByUid",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).PopSimpleDetectUnfinishedTaskByUid(ctx, req.(*GetExecBatchYakScriptUnfinishedTaskByUidRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_RecoverSimpleDetectUnfinishedTask_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(RecoverExecBatchYakScriptUnfinishedTaskRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(YakServer).RecoverSimpleDetectUnfinishedTask(m, &yakRecoverSimpleDetectUnfinishedTaskServer{stream})
}

type Yak_RecoverSimpleDetectUnfinishedTaskServer interface {
	Send(*ExecResult) error
	grpc.ServerStream
}

type yakRecoverSimpleDetectUnfinishedTaskServer struct {
	grpc.ServerStream
}

func (x *yakRecoverSimpleDetectUnfinishedTaskServer) Send(m *ExecResult) error {
	return x.ServerStream.SendMsg(m)
}

func _Yak_QueryPorts_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryPortsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).QueryPorts(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ypb.Yak/QueryPorts",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).QueryPorts(ctx, req.(*QueryPortsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_DeletePorts_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeletePortsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).DeletePorts(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ypb.Yak/DeletePorts",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).DeletePorts(ctx, req.(*DeletePortsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_QueryHosts_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryHostsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).QueryHosts(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ypb.Yak/QueryHosts",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).QueryHosts(ctx, req.(*QueryHostsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_DeleteHosts_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteHostsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).DeleteHosts(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ypb.Yak/DeleteHosts",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).DeleteHosts(ctx, req.(*DeleteHostsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_QueryDomains_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryDomainsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).QueryDomains(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ypb.Yak/QueryDomains",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).QueryDomains(ctx, req.(*QueryDomainsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_DeleteDomains_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteDomainsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).DeleteDomains(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ypb.Yak/DeleteDomains",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).DeleteDomains(ctx, req.(*DeleteDomainsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_QueryPortsGroup_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).QueryPortsGroup(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ypb.Yak/QueryPortsGroup",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).QueryPortsGroup(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_UpdateFromYakitResource_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateFromYakitResourceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).UpdateFromYakitResource(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ypb.Yak/UpdateFromYakitResource",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).UpdateFromYakitResource(ctx, req.(*UpdateFromYakitResourceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_UpdateFromGithub_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateFromGithubRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).UpdateFromGithub(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ypb.Yak/UpdateFromGithub",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).UpdateFromGithub(ctx, req.(*UpdateFromGithubRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_AddToMenu_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddToMenuRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).AddToMenu(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ypb.Yak/AddToMenu",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).AddToMenu(ctx, req.(*AddToMenuRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_RemoveFromMenu_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RemoveFromMenuRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).RemoveFromMenu(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ypb.Yak/RemoveFromMenu",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).RemoveFromMenu(ctx, req.(*RemoveFromMenuRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_YakScriptIsInMenu_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(YakScriptIsInMenuRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).YakScriptIsInMenu(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ypb.Yak/YakScriptIsInMenu",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).YakScriptIsInMenu(ctx, req.(*YakScriptIsInMenuRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_GetAllMenuItem_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).GetAllMenuItem(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ypb.Yak/GetAllMenuItem",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).GetAllMenuItem(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_DeleteAllMenuItem_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).DeleteAllMenuItem(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ypb.Yak/DeleteAllMenuItem",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).DeleteAllMenuItem(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_ImportMenuItem_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ImportMenuItemRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).ImportMenuItem(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ypb.Yak/ImportMenuItem",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).ImportMenuItem(ctx, req.(*ImportMenuItemRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_ExportMenuItem_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).ExportMenuItem(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ypb.Yak/ExportMenuItem",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).ExportMenuItem(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_GetMenuItemById_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetMenuItemByIdRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).GetMenuItemById(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ypb.Yak/GetMenuItemById",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).GetMenuItemById(ctx, req.(*GetMenuItemByIdRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_QueryGroupsByYakScriptId_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryGroupsByYakScriptIdRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).QueryGroupsByYakScriptId(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ypb.Yak/QueryGroupsByYakScriptId",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).QueryGroupsByYakScriptId(ctx, req.(*QueryGroupsByYakScriptIdRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_AddMenus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddMenuRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).AddMenus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ypb.Yak/AddMenus",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).AddMenus(ctx, req.(*AddMenuRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_QueryAllMenuItem_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryAllMenuItemRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).QueryAllMenuItem(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ypb.Yak/QueryAllMenuItem",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).QueryAllMenuItem(ctx, req.(*QueryAllMenuItemRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_DeleteAllMenu_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryAllMenuItemRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).DeleteAllMenu(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ypb.Yak/DeleteAllMenu",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).DeleteAllMenu(ctx, req.(*QueryAllMenuItemRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_AddToNavigation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddToNavigationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).AddToNavigation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ypb.Yak/AddToNavigation",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).AddToNavigation(ctx, req.(*AddToNavigationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_GetAllNavigationItem_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetAllNavigationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).GetAllNavigationItem(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ypb.Yak/GetAllNavigationItem",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).GetAllNavigationItem(ctx, req.(*GetAllNavigationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_DeleteAllNavigation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetAllNavigationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).DeleteAllNavigation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ypb.Yak/DeleteAllNavigation",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).DeleteAllNavigation(ctx, req.(*GetAllNavigationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_AddOneNavigation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddOneNavigationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).AddOneNavigation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ypb.Yak/AddOneNavigation",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).AddOneNavigation(ctx, req.(*AddOneNavigationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_QueryNavigationGroups_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryNavigationGroupsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).QueryNavigationGroups(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ypb.Yak/QueryNavigationGroups",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).QueryNavigationGroups(ctx, req.(*QueryNavigationGroupsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_SaveMarkdownDocument_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SaveMarkdownDocumentRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).SaveMarkdownDocument(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ypb.Yak/SaveMarkdownDocument",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).SaveMarkdownDocument(ctx, req.(*SaveMarkdownDocumentRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_GetMarkdownDocument_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetMarkdownDocumentRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).GetMarkdownDocument(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ypb.Yak/GetMarkdownDocument",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).GetMarkdownDocument(ctx, req.(*GetMarkdownDocumentRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_DeleteMarkdownDocument_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetMarkdownDocumentRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).DeleteMarkdownDocument(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ypb.Yak/DeleteMarkdownDocument",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).DeleteMarkdownDocument(ctx, req.(*GetMarkdownDocumentRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_StartBasicCrawler_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StartBasicCrawlerRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).StartBasicCrawler(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ypb.Yak/StartBasicCrawler",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).StartBasicCrawler(ctx, req.(*StartBasicCrawlerRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_ViewBasicCrawlerCode_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).ViewBasicCrawlerCode(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ypb.Yak/ViewBasicCrawlerCode",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).ViewBasicCrawlerCode(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_GenerateWebsiteTree_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GenerateWebsiteTreeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).GenerateWebsiteTree(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ypb.Yak/GenerateWebsiteTree",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).GenerateWebsiteTree(ctx, req.(*GenerateWebsiteTreeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_QueryYakScriptExecResult_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryYakScriptExecResultRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).QueryYakScriptExecResult(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ypb.Yak/QueryYakScriptExecResult",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).QueryYakScriptExecResult(ctx, req.(*QueryYakScriptExecResultRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_QueryYakScriptNameInExecResult_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).QueryYakScriptNameInExecResult(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ypb.Yak/QueryYakScriptNameInExecResult",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).QueryYakScriptNameInExecResult(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_DeleteYakScriptExecResult_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteYakScriptExecResultRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).DeleteYakScriptExecResult(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ypb.Yak/DeleteYakScriptExecResult",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).DeleteYakScriptExecResult(ctx, req.(*DeleteYakScriptExecResultRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_DeleteYakScriptExec_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).DeleteYakScriptExec(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ypb.Yak/DeleteYakScriptExec",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).DeleteYakScriptExec(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_StartBrute_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(StartBruteParams)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(YakServer).StartBrute(m, &yakStartBruteServer{stream})
}

type Yak_StartBruteServer interface {
	Send(*ExecResult) error
	grpc.ServerStream
}

type yakStartBruteServer struct {
	grpc.ServerStream
}

func (x *yakStartBruteServer) Send(m *ExecResult) error {
	return x.ServerStream.SendMsg(m)
}

func _Yak_GetAvailableBruteTypes_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).GetAvailableBruteTypes(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ypb.Yak/GetAvailableBruteTypes",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).GetAvailableBruteTypes(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_GetTunnelServerExternalIP_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetTunnelServerExternalIPParams)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).GetTunnelServerExternalIP(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ypb.Yak/GetTunnelServerExternalIP",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).GetTunnelServerExternalIP(ctx, req.(*GetTunnelServerExternalIPParams))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_VerifyTunnelServerDomain_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(VerifyTunnelServerDomainParams)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).VerifyTunnelServerDomain(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ypb.Yak/VerifyTunnelServerDomain",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).VerifyTunnelServerDomain(ctx, req.(*VerifyTunnelServerDomainParams))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_StartFacades_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(StartFacadesParams)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(YakServer).StartFacades(m, &yakStartFacadesServer{stream})
}

type Yak_StartFacadesServer interface {
	Send(*ExecResult) error
	grpc.ServerStream
}

type yakStartFacadesServer struct {
	grpc.ServerStream
}

func (x *yakStartFacadesServer) Send(m *ExecResult) error {
	return x.ServerStream.SendMsg(m)
}

func _Yak_StartFacadesWithYsoObject_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(StartFacadesWithYsoParams)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(YakServer).StartFacadesWithYsoObject(m, &yakStartFacadesWithYsoObjectServer{stream})
}

type Yak_StartFacadesWithYsoObjectServer interface {
	Send(*ExecResult) error
	grpc.ServerStream
}

type yakStartFacadesWithYsoObjectServer struct {
	grpc.ServerStream
}

func (x *yakStartFacadesWithYsoObjectServer) Send(m *ExecResult) error {
	return x.ServerStream.SendMsg(m)
}

func _Yak_ApplyClassToFacades_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ApplyClassToFacadesParamsWithVerbose)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).ApplyClassToFacades(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ypb.Yak/ApplyClassToFacades",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).ApplyClassToFacades(ctx, req.(*ApplyClassToFacadesParamsWithVerbose))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_BytesToBase64_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BytesToBase64Request)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).BytesToBase64(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ypb.Yak/BytesToBase64",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).BytesToBase64(ctx, req.(*BytesToBase64Request))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_ConfigGlobalReverse_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(ConfigGlobalReverseParams)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(YakServer).ConfigGlobalReverse(m, &yakConfigGlobalReverseServer{stream})
}

type Yak_ConfigGlobalReverseServer interface {
	Send(*Empty) error
	grpc.ServerStream
}

type yakConfigGlobalReverseServer struct {
	grpc.ServerStream
}

func (x *yakConfigGlobalReverseServer) Send(m *Empty) error {
	return x.ServerStream.SendMsg(m)
}

func _Yak_AvailableLocalAddr_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).AvailableLocalAddr(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ypb.Yak/AvailableLocalAddr",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).AvailableLocalAddr(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_GetGlobalReverseServer_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).GetGlobalReverseServer(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ypb.Yak/GetGlobalReverseServer",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).GetGlobalReverseServer(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_QueryRisks_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryRisksRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).QueryRisks(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ypb.Yak/QueryRisks",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).QueryRisks(ctx, req.(*QueryRisksRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_QueryRisk_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryRiskRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).QueryRisk(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ypb.Yak/QueryRisk",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).QueryRisk(ctx, req.(*QueryRiskRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_DeleteRisk_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteRiskRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).DeleteRisk(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ypb.Yak/DeleteRisk",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).DeleteRisk(ctx, req.(*DeleteRiskRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_QueryAvailableRiskType_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).QueryAvailableRiskType(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ypb.Yak/QueryAvailableRiskType",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).QueryAvailableRiskType(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_QueryAvailableRiskLevel_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).QueryAvailableRiskLevel(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ypb.Yak/QueryAvailableRiskLevel",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).QueryAvailableRiskLevel(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_QueryRiskTableStats_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).QueryRiskTableStats(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ypb.Yak/QueryRiskTableStats",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).QueryRiskTableStats(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_ResetRiskTableStats_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).ResetRiskTableStats(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ypb.Yak/ResetRiskTableStats",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).ResetRiskTableStats(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_QueryAvailableTarget_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).QueryAvailableTarget(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ypb.Yak/QueryAvailableTarget",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).QueryAvailableTarget(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_QueryNewRisk_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryNewRiskRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).QueryNewRisk(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ypb.Yak/QueryNewRisk",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).QueryNewRisk(ctx, req.(*QueryNewRiskRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_NewRiskRead_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NewRiskReadRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).NewRiskRead(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ypb.Yak/NewRiskRead",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).NewRiskRead(ctx, req.(*NewRiskReadRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_UploadRiskToOnline_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UploadRiskToOnlineRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).UploadRiskToOnline(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ypb.Yak/UploadRiskToOnline",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).UploadRiskToOnline(ctx, req.(*UploadRiskToOnlineRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_QueryReports_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryReportsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).QueryReports(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ypb.Yak/QueryReports",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).QueryReports(ctx, req.(*QueryReportsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_QueryReport_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryReportRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).QueryReport(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ypb.Yak/QueryReport",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).QueryReport(ctx, req.(*QueryReportRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_DeleteReport_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteReportRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).DeleteReport(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ypb.Yak/DeleteReport",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).DeleteReport(ctx, req.(*DeleteReportRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_QueryAvailableReportFrom_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).QueryAvailableReportFrom(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ypb.Yak/QueryAvailableReportFrom",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).QueryAvailableReportFrom(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_DownloadReport_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DownloadReportRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).DownloadReport(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ypb.Yak/DownloadReport",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).DownloadReport(ctx, req.(*DownloadReportRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_GetAllYsoGadgetOptions_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).GetAllYsoGadgetOptions(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ypb.Yak/GetAllYsoGadgetOptions",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).GetAllYsoGadgetOptions(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_GetAllYsoClassOptions_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(YsoOptionsRequerstWithVerbose)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).GetAllYsoClassOptions(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ypb.Yak/GetAllYsoClassOptions",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).GetAllYsoClassOptions(ctx, req.(*YsoOptionsRequerstWithVerbose))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_GetAllYsoClassGeneraterOptions_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(YsoOptionsRequerstWithVerbose)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).GetAllYsoClassGeneraterOptions(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ypb.Yak/GetAllYsoClassGeneraterOptions",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).GetAllYsoClassGeneraterOptions(ctx, req.(*YsoOptionsRequerstWithVerbose))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_GenerateYsoCode_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(YsoOptionsRequerstWithVerbose)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).GenerateYsoCode(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ypb.Yak/GenerateYsoCode",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).GenerateYsoCode(ctx, req.(*YsoOptionsRequerstWithVerbose))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_GenerateYsoBytes_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(YsoOptionsRequerstWithVerbose)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).GenerateYsoBytes(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ypb.Yak/GenerateYsoBytes",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).GenerateYsoBytes(ctx, req.(*YsoOptionsRequerstWithVerbose))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_YsoDump_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(YsoBytesObject)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).YsoDump(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ypb.Yak/YsoDump",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).YsoDump(ctx, req.(*YsoBytesObject))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_SetYakBridgeLogServer_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(YakDNSLogBridgeAddr)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).SetYakBridgeLogServer(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ypb.Yak/SetYakBridgeLogServer",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).SetYakBridgeLogServer(ctx, req.(*YakDNSLogBridgeAddr))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_GetCurrentYakBridgeLogServer_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).GetCurrentYakBridgeLogServer(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ypb.Yak/GetCurrentYakBridgeLogServer",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).GetCurrentYakBridgeLogServer(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_RequireDNSLogDomain_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(YakDNSLogBridgeAddr)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).RequireDNSLogDomain(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ypb.Yak/RequireDNSLogDomain",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).RequireDNSLogDomain(ctx, req.(*YakDNSLogBridgeAddr))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_RequireDNSLogDomainByScript_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RequireDNSLogDomainByScriptRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).RequireDNSLogDomainByScript(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ypb.Yak/RequireDNSLogDomainByScript",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).RequireDNSLogDomainByScript(ctx, req.(*RequireDNSLogDomainByScriptRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_QueryDNSLogByToken_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryDNSLogByTokenRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).QueryDNSLogByToken(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ypb.Yak/QueryDNSLogByToken",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).QueryDNSLogByToken(ctx, req.(*QueryDNSLogByTokenRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_QueryDNSLogTokenByScript_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RequireDNSLogDomainByScriptRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).QueryDNSLogTokenByScript(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ypb.Yak/QueryDNSLogTokenByScript",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).QueryDNSLogTokenByScript(ctx, req.(*RequireDNSLogDomainByScriptRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_RequireICMPRandomLength_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).RequireICMPRandomLength(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ypb.Yak/RequireICMPRandomLength",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).RequireICMPRandomLength(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_QueryICMPTrigger_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryICMPTriggerRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).QueryICMPTrigger(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ypb.Yak/QueryICMPTrigger",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).QueryICMPTrigger(ctx, req.(*QueryICMPTriggerRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_RequireRandomPortToken_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).RequireRandomPortToken(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ypb.Yak/RequireRandomPortToken",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).RequireRandomPortToken(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_QueryRandomPortTrigger_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryRandomPortTriggerRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).QueryRandomPortTrigger(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ypb.Yak/QueryRandomPortTrigger",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).QueryRandomPortTrigger(ctx, req.(*QueryRandomPortTriggerRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_QuerySupportedDnsLogPlatforms_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).QuerySupportedDnsLogPlatforms(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ypb.Yak/QuerySupportedDnsLogPlatforms",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).QuerySupportedDnsLogPlatforms(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_GetAvailableYakScriptTags_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).GetAvailableYakScriptTags(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ypb.Yak/GetAvailableYakScriptTags",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).GetAvailableYakScriptTags(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_ForceUpdateAvailableYakScriptTags_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).ForceUpdateAvailableYakScriptTags(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ypb.Yak/ForceUpdateAvailableYakScriptTags",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).ForceUpdateAvailableYakScriptTags(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_ExecYakitPluginsByYakScriptFilter_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(ExecYakitPluginsByYakScriptFilterRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(YakServer).ExecYakitPluginsByYakScriptFilter(m, &yakExecYakitPluginsByYakScriptFilterServer{stream})
}

type Yak_ExecYakitPluginsByYakScriptFilterServer interface {
	Send(*ExecResult) error
	grpc.ServerStream
}

type yakExecYakitPluginsByYakScriptFilterServer struct {
	grpc.ServerStream
}

func (x *yakExecYakitPluginsByYakScriptFilterServer) Send(m *ExecResult) error {
	return x.ServerStream.SendMsg(m)
}

func _Yak_GenerateYakCodeByPacket_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GenerateYakCodeByPacketRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).GenerateYakCodeByPacket(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ypb.Yak/GenerateYakCodeByPacket",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).GenerateYakCodeByPacket(ctx, req.(*GenerateYakCodeByPacketRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_GenerateCSRFPocByPacket_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GenerateCSRFPocByPacketRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).GenerateCSRFPocByPacket(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ypb.Yak/GenerateCSRFPocByPacket",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).GenerateCSRFPocByPacket(ctx, req.(*GenerateCSRFPocByPacketRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_ExportMITMReplacerRules_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).ExportMITMReplacerRules(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ypb.Yak/ExportMITMReplacerRules",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).ExportMITMReplacerRules(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_ImportMITMReplacerRules_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ImportMITMReplacerRulesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).ImportMITMReplacerRules(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ypb.Yak/ImportMITMReplacerRules",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).ImportMITMReplacerRules(ctx, req.(*ImportMITMReplacerRulesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_GetCurrentRules_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).GetCurrentRules(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ypb.Yak/GetCurrentRules",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).GetCurrentRules(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_SetCurrentRules_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MITMContentReplacers)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).SetCurrentRules(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ypb.Yak/SetCurrentRules",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).SetCurrentRules(ctx, req.(*MITMContentReplacers))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_ExtractDataToFile_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(YakServer).ExtractDataToFile(&yakExtractDataToFileServer{stream})
}

type Yak_ExtractDataToFileServer interface {
	Send(*ExtractDataToFileResult) error
	Recv() (*ExtractDataToFileRequest, error)
	grpc.ServerStream
}

type yakExtractDataToFileServer struct {
	grpc.ServerStream
}

func (x *yakExtractDataToFileServer) Send(m *ExtractDataToFileResult) error {
	return x.ServerStream.SendMsg(m)
}

func (x *yakExtractDataToFileServer) Recv() (*ExtractDataToFileRequest, error) {
	m := new(ExtractDataToFileRequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _Yak_AutoDecode_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AutoDecodeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).AutoDecode(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ypb.Yak/AutoDecode",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).AutoDecode(ctx, req.(*AutoDecodeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_GetSystemProxy_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).GetSystemProxy(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ypb.Yak/GetSystemProxy",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).GetSystemProxy(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_SetSystemProxy_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetSystemProxyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).SetSystemProxy(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ypb.Yak/SetSystemProxy",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).SetSystemProxy(ctx, req.(*SetSystemProxyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_GetKey_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetKeyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).GetKey(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ypb.Yak/GetKey",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).GetKey(ctx, req.(*GetKeyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_SetKey_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetKeyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).SetKey(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ypb.Yak/SetKey",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).SetKey(ctx, req.(*SetKeyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_DelKey_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetKeyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).DelKey(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ypb.Yak/DelKey",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).DelKey(ctx, req.(*GetKeyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_GetAllProcessEnvKey_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).GetAllProcessEnvKey(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ypb.Yak/GetAllProcessEnvKey",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).GetAllProcessEnvKey(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_SetProcessEnvKey_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetKeyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).SetProcessEnvKey(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ypb.Yak/SetProcessEnvKey",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).SetProcessEnvKey(ctx, req.(*SetKeyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_GetProjectKey_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetKeyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).GetProjectKey(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ypb.Yak/GetProjectKey",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).GetProjectKey(ctx, req.(*GetKeyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_SetProjectKey_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetKeyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).SetProjectKey(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ypb.Yak/SetProjectKey",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).SetProjectKey(ctx, req.(*SetKeyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_GetOnlineProfile_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).GetOnlineProfile(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ypb.Yak/GetOnlineProfile",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).GetOnlineProfile(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_SetOnlineProfile_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(OnlineProfile)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).SetOnlineProfile(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ypb.Yak/SetOnlineProfile",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).SetOnlineProfile(ctx, req.(*OnlineProfile))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_DownloadOnlinePluginById_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DownloadOnlinePluginByIdRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).DownloadOnlinePluginById(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ypb.Yak/DownloadOnlinePluginById",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).DownloadOnlinePluginById(ctx, req.(*DownloadOnlinePluginByIdRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_DownloadOnlinePluginByIds_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DownloadOnlinePluginByIdsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).DownloadOnlinePluginByIds(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ypb.Yak/DownloadOnlinePluginByIds",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).DownloadOnlinePluginByIds(ctx, req.(*DownloadOnlinePluginByIdsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_DownloadOnlinePluginAll_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(DownloadOnlinePluginByTokenRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(YakServer).DownloadOnlinePluginAll(m, &yakDownloadOnlinePluginAllServer{stream})
}

type Yak_DownloadOnlinePluginAllServer interface {
	Send(*DownloadOnlinePluginProgress) error
	grpc.ServerStream
}

type yakDownloadOnlinePluginAllServer struct {
	grpc.ServerStream
}

func (x *yakDownloadOnlinePluginAllServer) Send(m *DownloadOnlinePluginProgress) error {
	return x.ServerStream.SendMsg(m)
}

func _Yak_DeletePluginByUserID_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeletePluginByUserIDRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).DeletePluginByUserID(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ypb.Yak/DeletePluginByUserID",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).DeletePluginByUserID(ctx, req.(*DeletePluginByUserIDRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_DeleteAllLocalPlugins_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).DeleteAllLocalPlugins(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ypb.Yak/DeleteAllLocalPlugins",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).DeleteAllLocalPlugins(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_GetYakScriptTagsAndType_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).GetYakScriptTagsAndType(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ypb.Yak/GetYakScriptTagsAndType",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).GetYakScriptTagsAndType(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_DeleteLocalPluginsByWhere_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteLocalPluginsByWhereRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).DeleteLocalPluginsByWhere(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ypb.Yak/DeleteLocalPluginsByWhere",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).DeleteLocalPluginsByWhere(ctx, req.(*DeleteLocalPluginsByWhereRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_DownloadOnlinePluginByScriptNames_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DownloadOnlinePluginByScriptNamesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).DownloadOnlinePluginByScriptNames(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ypb.Yak/DownloadOnlinePluginByScriptNames",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).DownloadOnlinePluginByScriptNames(ctx, req.(*DownloadOnlinePluginByScriptNamesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_ExecPacketScan_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(ExecPacketScanRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(YakServer).ExecPacketScan(m, &yakExecPacketScanServer{stream})
}

type Yak_ExecPacketScanServer interface {
	Send(*ExecResult) error
	grpc.ServerStream
}

type yakExecPacketScanServer struct {
	grpc.ServerStream
}

func (x *yakExecPacketScanServer) Send(m *ExecResult) error {
	return x.ServerStream.SendMsg(m)
}

func _Yak_GetEngineDefaultProxy_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).GetEngineDefaultProxy(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ypb.Yak/GetEngineDefaultProxy",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).GetEngineDefaultProxy(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_SetEngineDefaultProxy_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DefaultProxyResult)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).SetEngineDefaultProxy(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ypb.Yak/SetEngineDefaultProxy",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).SetEngineDefaultProxy(ctx, req.(*DefaultProxyResult))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_GetMachineID_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).GetMachineID(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ypb.Yak/GetMachineID",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).GetMachineID(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_GetLicense_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).GetLicense(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ypb.Yak/GetLicense",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).GetLicense(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_CheckLicense_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CheckLicenseRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).CheckLicense(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ypb.Yak/CheckLicense",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).CheckLicense(ctx, req.(*CheckLicenseRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_GetRequestBodyByHTTPFlowID_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DownloadBodyByHTTPFlowIDRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).GetRequestBodyByHTTPFlowID(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ypb.Yak/GetRequestBodyByHTTPFlowID",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).GetRequestBodyByHTTPFlowID(ctx, req.(*DownloadBodyByHTTPFlowIDRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_GetResponseBodyByHTTPFlowID_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DownloadBodyByHTTPFlowIDRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).GetResponseBodyByHTTPFlowID(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ypb.Yak/GetResponseBodyByHTTPFlowID",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).GetResponseBodyByHTTPFlowID(ctx, req.(*DownloadBodyByHTTPFlowIDRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_GetHTTPPacketBody_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetHTTPPacketBodyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).GetHTTPPacketBody(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ypb.Yak/GetHTTPPacketBody",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).GetHTTPPacketBody(ctx, req.(*GetHTTPPacketBodyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_RegisterFacadesHTTP_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RegisterFacadesHTTPRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).RegisterFacadesHTTP(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ypb.Yak/RegisterFacadesHTTP",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).RegisterFacadesHTTP(ctx, req.(*RegisterFacadesHTTPRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_ResetAndInvalidUserData_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ResetAndInvalidUserDataRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).ResetAndInvalidUserData(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ypb.Yak/ResetAndInvalidUserData",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).ResetAndInvalidUserData(ctx, req.(*ResetAndInvalidUserDataRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_CreateYaklangShell_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(YakServer).CreateYaklangShell(&yakCreateYaklangShellServer{stream})
}

type Yak_CreateYaklangShellServer interface {
	Send(*YaklangShellResponse) error
	Recv() (*YaklangShellRequest, error)
	grpc.ServerStream
}

type yakCreateYaklangShellServer struct {
	grpc.ServerStream
}

func (x *yakCreateYaklangShellServer) Send(m *YaklangShellResponse) error {
	return x.ServerStream.SendMsg(m)
}

func (x *yakCreateYaklangShellServer) Recv() (*YaklangShellRequest, error) {
	m := new(YaklangShellRequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _Yak_AttachCombinedOutput_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(AttachCombinedOutputRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(YakServer).AttachCombinedOutput(m, &yakAttachCombinedOutputServer{stream})
}

type Yak_AttachCombinedOutputServer interface {
	Send(*ExecResult) error
	grpc.ServerStream
}

type yakAttachCombinedOutputServer struct {
	grpc.ServerStream
}

func (x *yakAttachCombinedOutputServer) Send(m *ExecResult) error {
	return x.ServerStream.SendMsg(m)
}

func _Yak_IsPrivilegedForNetRaw_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).IsPrivilegedForNetRaw(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ypb.Yak/IsPrivilegedForNetRaw",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).IsPrivilegedForNetRaw(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_PromotePermissionForUserPcap_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).PromotePermissionForUserPcap(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ypb.Yak/PromotePermissionForUserPcap",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).PromotePermissionForUserPcap(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_SetCurrentProject_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetCurrentProjectRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).SetCurrentProject(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ypb.Yak/SetCurrentProject",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).SetCurrentProject(ctx, req.(*SetCurrentProjectRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_GetCurrentProject_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).GetCurrentProject(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ypb.Yak/GetCurrentProject",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).GetCurrentProject(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_GetProjects_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetProjectsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).GetProjects(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ypb.Yak/GetProjects",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).GetProjects(ctx, req.(*GetProjectsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_NewProject_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NewProjectRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).NewProject(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ypb.Yak/NewProject",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).NewProject(ctx, req.(*NewProjectRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_IsProjectNameValid_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IsProjectNameValidRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).IsProjectNameValid(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ypb.Yak/IsProjectNameValid",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).IsProjectNameValid(ctx, req.(*IsProjectNameValidRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_RemoveProject_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RemoveProjectRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).RemoveProject(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ypb.Yak/RemoveProject",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).RemoveProject(ctx, req.(*RemoveProjectRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_DeleteProject_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteProjectRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).DeleteProject(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ypb.Yak/DeleteProject",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).DeleteProject(ctx, req.(*DeleteProjectRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_GetDefaultProject_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).GetDefaultProject(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ypb.Yak/GetDefaultProject",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).GetDefaultProject(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_QueryProjectDetail_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryProjectDetailRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).QueryProjectDetail(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ypb.Yak/QueryProjectDetail",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).QueryProjectDetail(ctx, req.(*QueryProjectDetailRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_ExportProject_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(ExportProjectRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(YakServer).ExportProject(m, &yakExportProjectServer{stream})
}

type Yak_ExportProjectServer interface {
	Send(*ProjectIOProgress) error
	grpc.ServerStream
}

type yakExportProjectServer struct {
	grpc.ServerStream
}

func (x *yakExportProjectServer) Send(m *ProjectIOProgress) error {
	return x.ServerStream.SendMsg(m)
}

func _Yak_ImportProject_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(ImportProjectRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(YakServer).ImportProject(m, &yakImportProjectServer{stream})
}

type Yak_ImportProjectServer interface {
	Send(*ProjectIOProgress) error
	grpc.ServerStream
}

type yakImportProjectServer struct {
	grpc.ServerStream
}

func (x *yakImportProjectServer) Send(m *ProjectIOProgress) error {
	return x.ServerStream.SendMsg(m)
}

func _Yak_MigrateLegacyDatabase_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).MigrateLegacyDatabase(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ypb.Yak/MigrateLegacyDatabase",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).MigrateLegacyDatabase(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_QueryMITMRuleExtractedData_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryMITMRuleExtractedDataRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).QueryMITMRuleExtractedData(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ypb.Yak/QueryMITMRuleExtractedData",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).QueryMITMRuleExtractedData(ctx, req.(*QueryMITMRuleExtractedDataRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_ImportChaosMakerRules_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ImportChaosMakerRulesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).ImportChaosMakerRules(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ypb.Yak/ImportChaosMakerRules",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).ImportChaosMakerRules(ctx, req.(*ImportChaosMakerRulesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_QueryChaosMakerRule_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryChaosMakerRuleRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).QueryChaosMakerRule(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ypb.Yak/QueryChaosMakerRule",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).QueryChaosMakerRule(ctx, req.(*QueryChaosMakerRuleRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_DeleteChaosMakerRuleByID_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteChaosMakerRuleByIDRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).DeleteChaosMakerRuleByID(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ypb.Yak/DeleteChaosMakerRuleByID",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).DeleteChaosMakerRuleByID(ctx, req.(*DeleteChaosMakerRuleByIDRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_ExecuteChaosMakerRule_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(ExecuteChaosMakerRuleRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(YakServer).ExecuteChaosMakerRule(m, &yakExecuteChaosMakerRuleServer{stream})
}

type Yak_ExecuteChaosMakerRuleServer interface {
	Send(*ExecResult) error
	grpc.ServerStream
}

type yakExecuteChaosMakerRuleServer struct {
	grpc.ServerStream
}

func (x *yakExecuteChaosMakerRuleServer) Send(m *ExecResult) error {
	return x.ServerStream.SendMsg(m)
}

func _Yak_IsRemoteAddrAvailable_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IsRemoteAddrAvailableRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).IsRemoteAddrAvailable(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ypb.Yak/IsRemoteAddrAvailable",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).IsRemoteAddrAvailable(ctx, req.(*IsRemoteAddrAvailableRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_ConnectVulinboxAgent_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IsRemoteAddrAvailableRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).ConnectVulinboxAgent(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ypb.Yak/ConnectVulinboxAgent",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).ConnectVulinboxAgent(ctx, req.(*IsRemoteAddrAvailableRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_GetRegisteredVulinboxAgent_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetRegisteredAgentRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).GetRegisteredVulinboxAgent(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ypb.Yak/GetRegisteredVulinboxAgent",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).GetRegisteredVulinboxAgent(ctx, req.(*GetRegisteredAgentRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_DisconnectVulinboxAgent_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DisconnectVulinboxAgentRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).DisconnectVulinboxAgent(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ypb.Yak/DisconnectVulinboxAgent",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).DisconnectVulinboxAgent(ctx, req.(*DisconnectVulinboxAgentRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_IsCVEDatabaseReady_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IsCVEDatabaseReadyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).IsCVEDatabaseReady(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ypb.Yak/IsCVEDatabaseReady",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).IsCVEDatabaseReady(ctx, req.(*IsCVEDatabaseReadyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_UpdateCVEDatabase_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(UpdateCVEDatabaseRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(YakServer).UpdateCVEDatabase(m, &yakUpdateCVEDatabaseServer{stream})
}

type Yak_UpdateCVEDatabaseServer interface {
	Send(*ExecResult) error
	grpc.ServerStream
}

type yakUpdateCVEDatabaseServer struct {
	grpc.ServerStream
}

func (x *yakUpdateCVEDatabaseServer) Send(m *ExecResult) error {
	return x.ServerStream.SendMsg(m)
}

func _Yak_ExportsProfileDatabase_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(ExportsProfileDatabaseRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(YakServer).ExportsProfileDatabase(m, &yakExportsProfileDatabaseServer{stream})
}

type Yak_ExportsProfileDatabaseServer interface {
	Send(*ExecResult) error
	grpc.ServerStream
}

type yakExportsProfileDatabaseServer struct {
	grpc.ServerStream
}

func (x *yakExportsProfileDatabaseServer) Send(m *ExecResult) error {
	return x.ServerStream.SendMsg(m)
}

func _Yak_ImportsProfileDatabase_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(ImportsProfileDatabaseRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(YakServer).ImportsProfileDatabase(m, &yakImportsProfileDatabaseServer{stream})
}

type Yak_ImportsProfileDatabaseServer interface {
	Send(*ExecResult) error
	grpc.ServerStream
}

type yakImportsProfileDatabaseServer struct {
	grpc.ServerStream
}

func (x *yakImportsProfileDatabaseServer) Send(m *ExecResult) error {
	return x.ServerStream.SendMsg(m)
}

func _Yak_QueryCVE_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryCVERequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).QueryCVE(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ypb.Yak/QueryCVE",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).QueryCVE(ctx, req.(*QueryCVERequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_GetCVE_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetCVERequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).GetCVE(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ypb.Yak/GetCVE",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).GetCVE(ctx, req.(*GetCVERequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_SaveTextToTemporalFile_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SaveTextToTemporalFileRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).SaveTextToTemporalFile(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ypb.Yak/SaveTextToTemporalFile",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).SaveTextToTemporalFile(ctx, req.(*SaveTextToTemporalFileRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_IsScrecorderReady_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IsScrecorderReadyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).IsScrecorderReady(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ypb.Yak/IsScrecorderReady",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).IsScrecorderReady(ctx, req.(*IsScrecorderReadyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_InstallScrecorder_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(InstallScrecorderRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(YakServer).InstallScrecorder(m, &yakInstallScrecorderServer{stream})
}

type Yak_InstallScrecorderServer interface {
	Send(*ExecResult) error
	grpc.ServerStream
}

type yakInstallScrecorderServer struct {
	grpc.ServerStream
}

func (x *yakInstallScrecorderServer) Send(m *ExecResult) error {
	return x.ServerStream.SendMsg(m)
}

func _Yak_StartScrecorder_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(StartScrecorderRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(YakServer).StartScrecorder(m, &yakStartScrecorderServer{stream})
}

type Yak_StartScrecorderServer interface {
	Send(*ExecResult) error
	grpc.ServerStream
}

type yakStartScrecorderServer struct {
	grpc.ServerStream
}

func (x *yakStartScrecorderServer) Send(m *ExecResult) error {
	return x.ServerStream.SendMsg(m)
}

func _Yak_QueryScreenRecorders_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryScreenRecorderRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).QueryScreenRecorders(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ypb.Yak/QueryScreenRecorders",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).QueryScreenRecorders(ctx, req.(*QueryScreenRecorderRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_DeleteScreenRecorders_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryScreenRecorderRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).DeleteScreenRecorders(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ypb.Yak/DeleteScreenRecorders",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).DeleteScreenRecorders(ctx, req.(*QueryScreenRecorderRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_UploadScreenRecorders_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UploadScreenRecorderRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).UploadScreenRecorders(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ypb.Yak/UploadScreenRecorders",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).UploadScreenRecorders(ctx, req.(*UploadScreenRecorderRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_GetOneScreenRecorders_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetOneScreenRecorderRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).GetOneScreenRecorders(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ypb.Yak/GetOneScreenRecorders",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).GetOneScreenRecorders(ctx, req.(*GetOneScreenRecorderRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_UpdateScreenRecorders_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateScreenRecorderRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).UpdateScreenRecorders(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ypb.Yak/UpdateScreenRecorders",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).UpdateScreenRecorders(ctx, req.(*UpdateScreenRecorderRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_IsVulinboxReady_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IsVulinboxReadyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).IsVulinboxReady(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ypb.Yak/IsVulinboxReady",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).IsVulinboxReady(ctx, req.(*IsVulinboxReadyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_InstallVulinbox_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(InstallVulinboxRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(YakServer).InstallVulinbox(m, &yakInstallVulinboxServer{stream})
}

type Yak_InstallVulinboxServer interface {
	Send(*ExecResult) error
	grpc.ServerStream
}

type yakInstallVulinboxServer struct {
	grpc.ServerStream
}

func (x *yakInstallVulinboxServer) Send(m *ExecResult) error {
	return x.ServerStream.SendMsg(m)
}

func _Yak_StartVulinbox_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(StartVulinboxRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(YakServer).StartVulinbox(m, &yakStartVulinboxServer{stream})
}

type Yak_StartVulinboxServer interface {
	Send(*ExecResult) error
	grpc.ServerStream
}

type yakStartVulinboxServer struct {
	grpc.ServerStream
}

func (x *yakStartVulinboxServer) Send(m *ExecResult) error {
	return x.ServerStream.SendMsg(m)
}

func _Yak_GenQualityInspectionReport_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(GenQualityInspectionReportRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(YakServer).GenQualityInspectionReport(m, &yakGenQualityInspectionReportServer{stream})
}

type Yak_GenQualityInspectionReportServer interface {
	Send(*ExecResult) error
	grpc.ServerStream
}

type yakGenQualityInspectionReportServer struct {
	grpc.ServerStream
}

func (x *yakGenQualityInspectionReportServer) Send(m *ExecResult) error {
	return x.ServerStream.SendMsg(m)
}

func _Yak_HTTPRequestBuilder_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(HTTPRequestBuilderParams)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).HTTPRequestBuilder(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ypb.Yak/HTTPRequestBuilder",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).HTTPRequestBuilder(ctx, req.(*HTTPRequestBuilderParams))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_DebugPlugin_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(DebugPluginRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(YakServer).DebugPlugin(m, &yakDebugPluginServer{stream})
}

type Yak_DebugPluginServer interface {
	Send(*ExecResult) error
	grpc.ServerStream
}

type yakDebugPluginServer struct {
	grpc.ServerStream
}

func (x *yakDebugPluginServer) Send(m *ExecResult) error {
	return x.ServerStream.SendMsg(m)
}

func _Yak_SmokingEvaluatePlugin_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SmokingEvaluatePluginRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).SmokingEvaluatePlugin(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ypb.Yak/SmokingEvaluatePlugin",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).SmokingEvaluatePlugin(ctx, req.(*SmokingEvaluatePluginRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_GetSystemDefaultDnsServers_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).GetSystemDefaultDnsServers(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ypb.Yak/GetSystemDefaultDnsServers",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).GetSystemDefaultDnsServers(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_DiagnoseNetwork_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(DiagnoseNetworkRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(YakServer).DiagnoseNetwork(m, &yakDiagnoseNetworkServer{stream})
}

type Yak_DiagnoseNetworkServer interface {
	Send(*DiagnoseNetworkResponse) error
	grpc.ServerStream
}

type yakDiagnoseNetworkServer struct {
	grpc.ServerStream
}

func (x *yakDiagnoseNetworkServer) Send(m *DiagnoseNetworkResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _Yak_DiagnoseNetworkDNS_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(DiagnoseNetworkDNSRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(YakServer).DiagnoseNetworkDNS(m, &yakDiagnoseNetworkDNSServer{stream})
}

type Yak_DiagnoseNetworkDNSServer interface {
	Send(*DiagnoseNetworkResponse) error
	grpc.ServerStream
}

type yakDiagnoseNetworkDNSServer struct {
	grpc.ServerStream
}

func (x *yakDiagnoseNetworkDNSServer) Send(m *DiagnoseNetworkResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _Yak_GetGlobalNetworkConfig_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetGlobalNetworkConfigRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).GetGlobalNetworkConfig(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ypb.Yak/GetGlobalNetworkConfig",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).GetGlobalNetworkConfig(ctx, req.(*GetGlobalNetworkConfigRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_SetGlobalNetworkConfig_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GlobalNetworkConfig)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).SetGlobalNetworkConfig(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ypb.Yak/SetGlobalNetworkConfig",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).SetGlobalNetworkConfig(ctx, req.(*GlobalNetworkConfig))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_ResetGlobalNetworkConfig_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ResetGlobalNetworkConfigRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).ResetGlobalNetworkConfig(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ypb.Yak/ResetGlobalNetworkConfig",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).ResetGlobalNetworkConfig(ctx, req.(*ResetGlobalNetworkConfigRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_ValidP12PassWord_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ValidP12PassWordRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).ValidP12PassWord(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ypb.Yak/ValidP12PassWord",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).ValidP12PassWord(ctx, req.(*ValidP12PassWordRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_RequestYakURL_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RequestYakURLParams)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).RequestYakURL(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ypb.Yak/RequestYakURL",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).RequestYakURL(ctx, req.(*RequestYakURLParams))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_GetPcapMetadata_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PcapMetadataRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).GetPcapMetadata(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ypb.Yak/GetPcapMetadata",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).GetPcapMetadata(ctx, req.(*PcapMetadataRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_PcapX_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(YakServer).PcapX(&yakPcapXServer{stream})
}

type Yak_PcapXServer interface {
	Send(*PcapXResponse) error
	Recv() (*PcapXRequest, error)
	grpc.ServerStream
}

type yakPcapXServer struct {
	grpc.ServerStream
}

func (x *yakPcapXServer) Send(m *PcapXResponse) error {
	return x.ServerStream.SendMsg(m)
}

func (x *yakPcapXServer) Recv() (*PcapXRequest, error) {
	m := new(PcapXRequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _Yak_QueryTrafficSession_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryTrafficSessionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).QueryTrafficSession(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ypb.Yak/QueryTrafficSession",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).QueryTrafficSession(ctx, req.(*QueryTrafficSessionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_QueryTrafficPacket_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryTrafficPacketRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).QueryTrafficPacket(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ypb.Yak/QueryTrafficPacket",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).QueryTrafficPacket(ctx, req.(*QueryTrafficPacketRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_QueryTrafficTCPReassembled_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryTrafficTCPReassembledRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).QueryTrafficTCPReassembled(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ypb.Yak/QueryTrafficTCPReassembled",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).QueryTrafficTCPReassembled(ctx, req.(*QueryTrafficTCPReassembledRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_DuplexConnection_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(YakServer).DuplexConnection(&yakDuplexConnectionServer{stream})
}

type Yak_DuplexConnectionServer interface {
	Send(*DuplexConnectionResponse) error
	Recv() (*DuplexConnectionRequest, error)
	grpc.ServerStream
}

type yakDuplexConnectionServer struct {
	grpc.ServerStream
}

func (x *yakDuplexConnectionServer) Send(m *DuplexConnectionResponse) error {
	return x.ServerStream.SendMsg(m)
}

func (x *yakDuplexConnectionServer) Recv() (*DuplexConnectionRequest, error) {
	m := new(DuplexConnectionRequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// Yak_ServiceDesc is the grpc.ServiceDesc for Yak service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Yak_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "ypb.Yak",
	HandlerType: (*YakServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Version",
			Handler:    _Yak_Version_Handler,
		},
		{
			MethodName: "Echo",
			Handler:    _Yak_Echo_Handler,
		},
		{
			MethodName: "SetMITMFilter",
			Handler:    _Yak_SetMITMFilter_Handler,
		},
		{
			MethodName: "GetMITMFilter",
			Handler:    _Yak_GetMITMFilter_Handler,
		},
		{
			MethodName: "DownloadMITMCert",
			Handler:    _Yak_DownloadMITMCert_Handler,
		},
		{
			MethodName: "QueryExecHistory",
			Handler:    _Yak_QueryExecHistory_Handler,
		},
		{
			MethodName: "RemoveExecHistory",
			Handler:    _Yak_RemoveExecHistory_Handler,
		},
		{
			MethodName: "LoadNucleiTemplates",
			Handler:    _Yak_LoadNucleiTemplates_Handler,
		},
		{
			MethodName: "GetExecBatchYakScriptUnfinishedTask",
			Handler:    _Yak_GetExecBatchYakScriptUnfinishedTask_Handler,
		},
		{
			MethodName: "GetExecBatchYakScriptUnfinishedTaskByUid",
			Handler:    _Yak_GetExecBatchYakScriptUnfinishedTaskByUid_Handler,
		},
		{
			MethodName: "PopExecBatchYakScriptUnfinishedTaskByUid",
			Handler:    _Yak_PopExecBatchYakScriptUnfinishedTaskByUid_Handler,
		},
		{
			MethodName: "QueryYakScript",
			Handler:    _Yak_QueryYakScript_Handler,
		},
		{
			MethodName: "SaveYakScript",
			Handler:    _Yak_SaveYakScript_Handler,
		},
		{
			MethodName: "DeleteYakScript",
			Handler:    _Yak_DeleteYakScript_Handler,
		},
		{
			MethodName: "GetYakScriptById",
			Handler:    _Yak_GetYakScriptById_Handler,
		},
		{
			MethodName: "GetYakScriptByName",
			Handler:    _Yak_GetYakScriptByName_Handler,
		},
		{
			MethodName: "GetYakScriptByOnlineID",
			Handler:    _Yak_GetYakScriptByOnlineID_Handler,
		},
		{
			MethodName: "IgnoreYakScript",
			Handler:    _Yak_IgnoreYakScript_Handler,
		},
		{
			MethodName: "UnIgnoreYakScript",
			Handler:    _Yak_UnIgnoreYakScript_Handler,
		},
		{
			MethodName: "ExportYakScript",
			Handler:    _Yak_ExportYakScript_Handler,
		},
		{
			MethodName: "GetYakScriptTags",
			Handler:    _Yak_GetYakScriptTags_Handler,
		},
		{
			MethodName: "QueryYakScriptLocalAndUser",
			Handler:    _Yak_QueryYakScriptLocalAndUser_Handler,
		},
		{
			MethodName: "QueryYakScriptByOnlineGroup",
			Handler:    _Yak_QueryYakScriptByOnlineGroup_Handler,
		},
		{
			MethodName: "QueryYakScriptLocalAll",
			Handler:    _Yak_QueryYakScriptLocalAll_Handler,
		},
		{
			MethodName: "QueryYakScriptByNames",
			Handler:    _Yak_QueryYakScriptByNames_Handler,
		},
		{
			MethodName: "QueryYakScriptByIsCore",
			Handler:    _Yak_QueryYakScriptByIsCore_Handler,
		},
		{
			MethodName: "GetHTTPFlowByHash",
			Handler:    _Yak_GetHTTPFlowByHash_Handler,
		},
		{
			MethodName: "GetHTTPFlowById",
			Handler:    _Yak_GetHTTPFlowById_Handler,
		},
		{
			MethodName: "GetHTTPFlowByIds",
			Handler:    _Yak_GetHTTPFlowByIds_Handler,
		},
		{
			MethodName: "QueryHTTPFlows",
			Handler:    _Yak_QueryHTTPFlows_Handler,
		},
		{
			MethodName: "DeleteHTTPFlows",
			Handler:    _Yak_DeleteHTTPFlows_Handler,
		},
		{
			MethodName: "SetTagForHTTPFlow",
			Handler:    _Yak_SetTagForHTTPFlow_Handler,
		},
		{
			MethodName: "QueryHTTPFlowsIds",
			Handler:    _Yak_QueryHTTPFlowsIds_Handler,
		},
		{
			MethodName: "HTTPFlowsFieldGroup",
			Handler:    _Yak_HTTPFlowsFieldGroup_Handler,
		},
		{
			MethodName: "HTTPFlowsShare",
			Handler:    _Yak_HTTPFlowsShare_Handler,
		},
		{
			MethodName: "HTTPFlowsExtract",
			Handler:    _Yak_HTTPFlowsExtract_Handler,
		},
		{
			MethodName: "GetHTTPFlowBare",
			Handler:    _Yak_GetHTTPFlowBare_Handler,
		},
		{
			MethodName: "ExtractUrl",
			Handler:    _Yak_ExtractUrl_Handler,
		},
		{
			MethodName: "GetHistoryHTTPFuzzerTask",
			Handler:    _Yak_GetHistoryHTTPFuzzerTask_Handler,
		},
		{
			MethodName: "QueryHistoryHTTPFuzzerTask",
			Handler:    _Yak_QueryHistoryHTTPFuzzerTask_Handler,
		},
		{
			MethodName: "QueryHistoryHTTPFuzzerTaskEx",
			Handler:    _Yak_QueryHistoryHTTPFuzzerTaskEx_Handler,
		},
		{
			MethodName: "DeleteHistoryHTTPFuzzerTask",
			Handler:    _Yak_DeleteHistoryHTTPFuzzerTask_Handler,
		},
		{
			MethodName: "PreloadHTTPFuzzerParams",
			Handler:    _Yak_PreloadHTTPFuzzerParams_Handler,
		},
		{
			MethodName: "RenderVariables",
			Handler:    _Yak_RenderVariables_Handler,
		},
		{
			MethodName: "MatchHTTPResponse",
			Handler:    _Yak_MatchHTTPResponse_Handler,
		},
		{
			MethodName: "ExtractHTTPResponse",
			Handler:    _Yak_ExtractHTTPResponse_Handler,
		},
		{
			MethodName: "RedirectRequest",
			Handler:    _Yak_RedirectRequest_Handler,
		},
		{
			MethodName: "HTTPRequestMutate",
			Handler:    _Yak_HTTPRequestMutate_Handler,
		},
		{
			MethodName: "HTTPResponseMutate",
			Handler:    _Yak_HTTPResponseMutate_Handler,
		},
		{
			MethodName: "FixUploadPacket",
			Handler:    _Yak_FixUploadPacket_Handler,
		},
		{
			MethodName: "IsMultipartFormDataRequest",
			Handler:    _Yak_IsMultipartFormDataRequest_Handler,
		},
		{
			MethodName: "GenerateExtractRule",
			Handler:    _Yak_GenerateExtractRule_Handler,
		},
		{
			MethodName: "ImportHTTPFuzzerTaskFromYaml",
			Handler:    _Yak_ImportHTTPFuzzerTaskFromYaml_Handler,
		},
		{
			MethodName: "ExportHTTPFuzzerTaskToYaml",
			Handler:    _Yak_ExportHTTPFuzzerTaskToYaml_Handler,
		},
		{
			MethodName: "SaveFuzzerLabel",
			Handler:    _Yak_SaveFuzzerLabel_Handler,
		},
		{
			MethodName: "QueryFuzzerLabel",
			Handler:    _Yak_QueryFuzzerLabel_Handler,
		},
		{
			MethodName: "DeleteFuzzerLabel",
			Handler:    _Yak_DeleteFuzzerLabel_Handler,
		},
		{
			MethodName: "QueryHTTPFuzzerResponseByTaskId",
			Handler:    _Yak_QueryHTTPFuzzerResponseByTaskId_Handler,
		},
		{
			MethodName: "QueryWebsocketFlowByHTTPFlowWebsocketHash",
			Handler:    _Yak_QueryWebsocketFlowByHTTPFlowWebsocketHash_Handler,
		},
		{
			MethodName: "DeleteWebsocketFlowByHTTPFlowWebsocketHash",
			Handler:    _Yak_DeleteWebsocketFlowByHTTPFlowWebsocketHash_Handler,
		},
		{
			MethodName: "DeleteWebsocketFlowAll",
			Handler:    _Yak_DeleteWebsocketFlowAll_Handler,
		},
		{
			MethodName: "ConvertFuzzerResponseToHTTPFlow",
			Handler:    _Yak_ConvertFuzzerResponseToHTTPFlow_Handler,
		},
		{
			MethodName: "StringFuzzer",
			Handler:    _Yak_StringFuzzer_Handler,
		},
		{
			MethodName: "HTTPRequestAnalyzer",
			Handler:    _Yak_HTTPRequestAnalyzer_Handler,
		},
		{
			MethodName: "Codec",
			Handler:    _Yak_Codec_Handler,
		},
		{
			MethodName: "NewCodec",
			Handler:    _Yak_NewCodec_Handler,
		},
		{
			MethodName: "PacketPrettifyHelper",
			Handler:    _Yak_PacketPrettifyHelper_Handler,
		},
		{
			MethodName: "QueryPayload",
			Handler:    _Yak_QueryPayload_Handler,
		},
		{
			MethodName: "DeletePayloadByGroup",
			Handler:    _Yak_DeletePayloadByGroup_Handler,
		},
		{
			MethodName: "DeletePayload",
			Handler:    _Yak_DeletePayload_Handler,
		},
		{
			MethodName: "SavePayload",
			Handler:    _Yak_SavePayload_Handler,
		},
		{
			MethodName: "GetAllPayloadGroup",
			Handler:    _Yak_GetAllPayloadGroup_Handler,
		},
		{
			MethodName: "UpdatePayload",
			Handler:    _Yak_UpdatePayload_Handler,
		},
		{
			MethodName: "GetAllPayload",
			Handler:    _Yak_GetAllPayload_Handler,
		},
		{
			MethodName: "GetYakitCompletionRaw",
			Handler:    _Yak_GetYakitCompletionRaw_Handler,
		},
		{
			MethodName: "GetYakVMBuildInMethodCompletion",
			Handler:    _Yak_GetYakVMBuildInMethodCompletion_Handler,
		},
		{
			MethodName: "StaticAnalyzeError",
			Handler:    _Yak_StaticAnalyzeError_Handler,
		},
		{
			MethodName: "YaklangCompileAndFormat",
			Handler:    _Yak_YaklangCompileAndFormat_Handler,
		},
		{
			MethodName: "ViewPortScanCode",
			Handler:    _Yak_ViewPortScanCode_Handler,
		},
		{
			MethodName: "SaveCancelSimpleDetect",
			Handler:    _Yak_SaveCancelSimpleDetect_Handler,
		},
		{
			MethodName: "GetSimpleDetectUnfinishedTask",
			Handler:    _Yak_GetSimpleDetectUnfinishedTask_Handler,
		},
		{
			MethodName: "GetSimpleDetectUnfinishedTaskByUid",
			Handler:    _Yak_GetSimpleDetectUnfinishedTaskByUid_Handler,
		},
		{
			MethodName: "PopSimpleDetectUnfinishedTaskByUid",
			Handler:    _Yak_PopSimpleDetectUnfinishedTaskByUid_Handler,
		},
		{
			MethodName: "QueryPorts",
			Handler:    _Yak_QueryPorts_Handler,
		},
		{
			MethodName: "DeletePorts",
			Handler:    _Yak_DeletePorts_Handler,
		},
		{
			MethodName: "QueryHosts",
			Handler:    _Yak_QueryHosts_Handler,
		},
		{
			MethodName: "DeleteHosts",
			Handler:    _Yak_DeleteHosts_Handler,
		},
		{
			MethodName: "QueryDomains",
			Handler:    _Yak_QueryDomains_Handler,
		},
		{
			MethodName: "DeleteDomains",
			Handler:    _Yak_DeleteDomains_Handler,
		},
		{
			MethodName: "QueryPortsGroup",
			Handler:    _Yak_QueryPortsGroup_Handler,
		},
		{
			MethodName: "UpdateFromYakitResource",
			Handler:    _Yak_UpdateFromYakitResource_Handler,
		},
		{
			MethodName: "UpdateFromGithub",
			Handler:    _Yak_UpdateFromGithub_Handler,
		},
		{
			MethodName: "AddToMenu",
			Handler:    _Yak_AddToMenu_Handler,
		},
		{
			MethodName: "RemoveFromMenu",
			Handler:    _Yak_RemoveFromMenu_Handler,
		},
		{
			MethodName: "YakScriptIsInMenu",
			Handler:    _Yak_YakScriptIsInMenu_Handler,
		},
		{
			MethodName: "GetAllMenuItem",
			Handler:    _Yak_GetAllMenuItem_Handler,
		},
		{
			MethodName: "DeleteAllMenuItem",
			Handler:    _Yak_DeleteAllMenuItem_Handler,
		},
		{
			MethodName: "ImportMenuItem",
			Handler:    _Yak_ImportMenuItem_Handler,
		},
		{
			MethodName: "ExportMenuItem",
			Handler:    _Yak_ExportMenuItem_Handler,
		},
		{
			MethodName: "GetMenuItemById",
			Handler:    _Yak_GetMenuItemById_Handler,
		},
		{
			MethodName: "QueryGroupsByYakScriptId",
			Handler:    _Yak_QueryGroupsByYakScriptId_Handler,
		},
		{
			MethodName: "AddMenus",
			Handler:    _Yak_AddMenus_Handler,
		},
		{
			MethodName: "QueryAllMenuItem",
			Handler:    _Yak_QueryAllMenuItem_Handler,
		},
		{
			MethodName: "DeleteAllMenu",
			Handler:    _Yak_DeleteAllMenu_Handler,
		},
		{
			MethodName: "AddToNavigation",
			Handler:    _Yak_AddToNavigation_Handler,
		},
		{
			MethodName: "GetAllNavigationItem",
			Handler:    _Yak_GetAllNavigationItem_Handler,
		},
		{
			MethodName: "DeleteAllNavigation",
			Handler:    _Yak_DeleteAllNavigation_Handler,
		},
		{
			MethodName: "AddOneNavigation",
			Handler:    _Yak_AddOneNavigation_Handler,
		},
		{
			MethodName: "QueryNavigationGroups",
			Handler:    _Yak_QueryNavigationGroups_Handler,
		},
		{
			MethodName: "SaveMarkdownDocument",
			Handler:    _Yak_SaveMarkdownDocument_Handler,
		},
		{
			MethodName: "GetMarkdownDocument",
			Handler:    _Yak_GetMarkdownDocument_Handler,
		},
		{
			MethodName: "DeleteMarkdownDocument",
			Handler:    _Yak_DeleteMarkdownDocument_Handler,
		},
		{
			MethodName: "StartBasicCrawler",
			Handler:    _Yak_StartBasicCrawler_Handler,
		},
		{
			MethodName: "ViewBasicCrawlerCode",
			Handler:    _Yak_ViewBasicCrawlerCode_Handler,
		},
		{
			MethodName: "GenerateWebsiteTree",
			Handler:    _Yak_GenerateWebsiteTree_Handler,
		},
		{
			MethodName: "QueryYakScriptExecResult",
			Handler:    _Yak_QueryYakScriptExecResult_Handler,
		},
		{
			MethodName: "QueryYakScriptNameInExecResult",
			Handler:    _Yak_QueryYakScriptNameInExecResult_Handler,
		},
		{
			MethodName: "DeleteYakScriptExecResult",
			Handler:    _Yak_DeleteYakScriptExecResult_Handler,
		},
		{
			MethodName: "DeleteYakScriptExec",
			Handler:    _Yak_DeleteYakScriptExec_Handler,
		},
		{
			MethodName: "GetAvailableBruteTypes",
			Handler:    _Yak_GetAvailableBruteTypes_Handler,
		},
		{
			MethodName: "GetTunnelServerExternalIP",
			Handler:    _Yak_GetTunnelServerExternalIP_Handler,
		},
		{
			MethodName: "VerifyTunnelServerDomain",
			Handler:    _Yak_VerifyTunnelServerDomain_Handler,
		},
		{
			MethodName: "ApplyClassToFacades",
			Handler:    _Yak_ApplyClassToFacades_Handler,
		},
		{
			MethodName: "BytesToBase64",
			Handler:    _Yak_BytesToBase64_Handler,
		},
		{
			MethodName: "AvailableLocalAddr",
			Handler:    _Yak_AvailableLocalAddr_Handler,
		},
		{
			MethodName: "GetGlobalReverseServer",
			Handler:    _Yak_GetGlobalReverseServer_Handler,
		},
		{
			MethodName: "QueryRisks",
			Handler:    _Yak_QueryRisks_Handler,
		},
		{
			MethodName: "QueryRisk",
			Handler:    _Yak_QueryRisk_Handler,
		},
		{
			MethodName: "DeleteRisk",
			Handler:    _Yak_DeleteRisk_Handler,
		},
		{
			MethodName: "QueryAvailableRiskType",
			Handler:    _Yak_QueryAvailableRiskType_Handler,
		},
		{
			MethodName: "QueryAvailableRiskLevel",
			Handler:    _Yak_QueryAvailableRiskLevel_Handler,
		},
		{
			MethodName: "QueryRiskTableStats",
			Handler:    _Yak_QueryRiskTableStats_Handler,
		},
		{
			MethodName: "ResetRiskTableStats",
			Handler:    _Yak_ResetRiskTableStats_Handler,
		},
		{
			MethodName: "QueryAvailableTarget",
			Handler:    _Yak_QueryAvailableTarget_Handler,
		},
		{
			MethodName: "QueryNewRisk",
			Handler:    _Yak_QueryNewRisk_Handler,
		},
		{
			MethodName: "NewRiskRead",
			Handler:    _Yak_NewRiskRead_Handler,
		},
		{
			MethodName: "UploadRiskToOnline",
			Handler:    _Yak_UploadRiskToOnline_Handler,
		},
		{
			MethodName: "QueryReports",
			Handler:    _Yak_QueryReports_Handler,
		},
		{
			MethodName: "QueryReport",
			Handler:    _Yak_QueryReport_Handler,
		},
		{
			MethodName: "DeleteReport",
			Handler:    _Yak_DeleteReport_Handler,
		},
		{
			MethodName: "QueryAvailableReportFrom",
			Handler:    _Yak_QueryAvailableReportFrom_Handler,
		},
		{
			MethodName: "DownloadReport",
			Handler:    _Yak_DownloadReport_Handler,
		},
		{
			MethodName: "GetAllYsoGadgetOptions",
			Handler:    _Yak_GetAllYsoGadgetOptions_Handler,
		},
		{
			MethodName: "GetAllYsoClassOptions",
			Handler:    _Yak_GetAllYsoClassOptions_Handler,
		},
		{
			MethodName: "GetAllYsoClassGeneraterOptions",
			Handler:    _Yak_GetAllYsoClassGeneraterOptions_Handler,
		},
		{
			MethodName: "GenerateYsoCode",
			Handler:    _Yak_GenerateYsoCode_Handler,
		},
		{
			MethodName: "GenerateYsoBytes",
			Handler:    _Yak_GenerateYsoBytes_Handler,
		},
		{
			MethodName: "YsoDump",
			Handler:    _Yak_YsoDump_Handler,
		},
		{
			MethodName: "SetYakBridgeLogServer",
			Handler:    _Yak_SetYakBridgeLogServer_Handler,
		},
		{
			MethodName: "GetCurrentYakBridgeLogServer",
			Handler:    _Yak_GetCurrentYakBridgeLogServer_Handler,
		},
		{
			MethodName: "RequireDNSLogDomain",
			Handler:    _Yak_RequireDNSLogDomain_Handler,
		},
		{
			MethodName: "RequireDNSLogDomainByScript",
			Handler:    _Yak_RequireDNSLogDomainByScript_Handler,
		},
		{
			MethodName: "QueryDNSLogByToken",
			Handler:    _Yak_QueryDNSLogByToken_Handler,
		},
		{
			MethodName: "QueryDNSLogTokenByScript",
			Handler:    _Yak_QueryDNSLogTokenByScript_Handler,
		},
		{
			MethodName: "RequireICMPRandomLength",
			Handler:    _Yak_RequireICMPRandomLength_Handler,
		},
		{
			MethodName: "QueryICMPTrigger",
			Handler:    _Yak_QueryICMPTrigger_Handler,
		},
		{
			MethodName: "RequireRandomPortToken",
			Handler:    _Yak_RequireRandomPortToken_Handler,
		},
		{
			MethodName: "QueryRandomPortTrigger",
			Handler:    _Yak_QueryRandomPortTrigger_Handler,
		},
		{
			MethodName: "QuerySupportedDnsLogPlatforms",
			Handler:    _Yak_QuerySupportedDnsLogPlatforms_Handler,
		},
		{
			MethodName: "GetAvailableYakScriptTags",
			Handler:    _Yak_GetAvailableYakScriptTags_Handler,
		},
		{
			MethodName: "ForceUpdateAvailableYakScriptTags",
			Handler:    _Yak_ForceUpdateAvailableYakScriptTags_Handler,
		},
		{
			MethodName: "GenerateYakCodeByPacket",
			Handler:    _Yak_GenerateYakCodeByPacket_Handler,
		},
		{
			MethodName: "GenerateCSRFPocByPacket",
			Handler:    _Yak_GenerateCSRFPocByPacket_Handler,
		},
		{
			MethodName: "ExportMITMReplacerRules",
			Handler:    _Yak_ExportMITMReplacerRules_Handler,
		},
		{
			MethodName: "ImportMITMReplacerRules",
			Handler:    _Yak_ImportMITMReplacerRules_Handler,
		},
		{
			MethodName: "GetCurrentRules",
			Handler:    _Yak_GetCurrentRules_Handler,
		},
		{
			MethodName: "SetCurrentRules",
			Handler:    _Yak_SetCurrentRules_Handler,
		},
		{
			MethodName: "AutoDecode",
			Handler:    _Yak_AutoDecode_Handler,
		},
		{
			MethodName: "GetSystemProxy",
			Handler:    _Yak_GetSystemProxy_Handler,
		},
		{
			MethodName: "SetSystemProxy",
			Handler:    _Yak_SetSystemProxy_Handler,
		},
		{
			MethodName: "GetKey",
			Handler:    _Yak_GetKey_Handler,
		},
		{
			MethodName: "SetKey",
			Handler:    _Yak_SetKey_Handler,
		},
		{
			MethodName: "DelKey",
			Handler:    _Yak_DelKey_Handler,
		},
		{
			MethodName: "GetAllProcessEnvKey",
			Handler:    _Yak_GetAllProcessEnvKey_Handler,
		},
		{
			MethodName: "SetProcessEnvKey",
			Handler:    _Yak_SetProcessEnvKey_Handler,
		},
		{
			MethodName: "GetProjectKey",
			Handler:    _Yak_GetProjectKey_Handler,
		},
		{
			MethodName: "SetProjectKey",
			Handler:    _Yak_SetProjectKey_Handler,
		},
		{
			MethodName: "GetOnlineProfile",
			Handler:    _Yak_GetOnlineProfile_Handler,
		},
		{
			MethodName: "SetOnlineProfile",
			Handler:    _Yak_SetOnlineProfile_Handler,
		},
		{
			MethodName: "DownloadOnlinePluginById",
			Handler:    _Yak_DownloadOnlinePluginById_Handler,
		},
		{
			MethodName: "DownloadOnlinePluginByIds",
			Handler:    _Yak_DownloadOnlinePluginByIds_Handler,
		},
		{
			MethodName: "DeletePluginByUserID",
			Handler:    _Yak_DeletePluginByUserID_Handler,
		},
		{
			MethodName: "DeleteAllLocalPlugins",
			Handler:    _Yak_DeleteAllLocalPlugins_Handler,
		},
		{
			MethodName: "GetYakScriptTagsAndType",
			Handler:    _Yak_GetYakScriptTagsAndType_Handler,
		},
		{
			MethodName: "DeleteLocalPluginsByWhere",
			Handler:    _Yak_DeleteLocalPluginsByWhere_Handler,
		},
		{
			MethodName: "DownloadOnlinePluginByScriptNames",
			Handler:    _Yak_DownloadOnlinePluginByScriptNames_Handler,
		},
		{
			MethodName: "GetEngineDefaultProxy",
			Handler:    _Yak_GetEngineDefaultProxy_Handler,
		},
		{
			MethodName: "SetEngineDefaultProxy",
			Handler:    _Yak_SetEngineDefaultProxy_Handler,
		},
		{
			MethodName: "GetMachineID",
			Handler:    _Yak_GetMachineID_Handler,
		},
		{
			MethodName: "GetLicense",
			Handler:    _Yak_GetLicense_Handler,
		},
		{
			MethodName: "CheckLicense",
			Handler:    _Yak_CheckLicense_Handler,
		},
		{
			MethodName: "GetRequestBodyByHTTPFlowID",
			Handler:    _Yak_GetRequestBodyByHTTPFlowID_Handler,
		},
		{
			MethodName: "GetResponseBodyByHTTPFlowID",
			Handler:    _Yak_GetResponseBodyByHTTPFlowID_Handler,
		},
		{
			MethodName: "GetHTTPPacketBody",
			Handler:    _Yak_GetHTTPPacketBody_Handler,
		},
		{
			MethodName: "RegisterFacadesHTTP",
			Handler:    _Yak_RegisterFacadesHTTP_Handler,
		},
		{
			MethodName: "ResetAndInvalidUserData",
			Handler:    _Yak_ResetAndInvalidUserData_Handler,
		},
		{
			MethodName: "IsPrivilegedForNetRaw",
			Handler:    _Yak_IsPrivilegedForNetRaw_Handler,
		},
		{
			MethodName: "PromotePermissionForUserPcap",
			Handler:    _Yak_PromotePermissionForUserPcap_Handler,
		},
		{
			MethodName: "SetCurrentProject",
			Handler:    _Yak_SetCurrentProject_Handler,
		},
		{
			MethodName: "GetCurrentProject",
			Handler:    _Yak_GetCurrentProject_Handler,
		},
		{
			MethodName: "GetProjects",
			Handler:    _Yak_GetProjects_Handler,
		},
		{
			MethodName: "NewProject",
			Handler:    _Yak_NewProject_Handler,
		},
		{
			MethodName: "IsProjectNameValid",
			Handler:    _Yak_IsProjectNameValid_Handler,
		},
		{
			MethodName: "RemoveProject",
			Handler:    _Yak_RemoveProject_Handler,
		},
		{
			MethodName: "DeleteProject",
			Handler:    _Yak_DeleteProject_Handler,
		},
		{
			MethodName: "GetDefaultProject",
			Handler:    _Yak_GetDefaultProject_Handler,
		},
		{
			MethodName: "QueryProjectDetail",
			Handler:    _Yak_QueryProjectDetail_Handler,
		},
		{
			MethodName: "MigrateLegacyDatabase",
			Handler:    _Yak_MigrateLegacyDatabase_Handler,
		},
		{
			MethodName: "QueryMITMRuleExtractedData",
			Handler:    _Yak_QueryMITMRuleExtractedData_Handler,
		},
		{
			MethodName: "ImportChaosMakerRules",
			Handler:    _Yak_ImportChaosMakerRules_Handler,
		},
		{
			MethodName: "QueryChaosMakerRule",
			Handler:    _Yak_QueryChaosMakerRule_Handler,
		},
		{
			MethodName: "DeleteChaosMakerRuleByID",
			Handler:    _Yak_DeleteChaosMakerRuleByID_Handler,
		},
		{
			MethodName: "IsRemoteAddrAvailable",
			Handler:    _Yak_IsRemoteAddrAvailable_Handler,
		},
		{
			MethodName: "ConnectVulinboxAgent",
			Handler:    _Yak_ConnectVulinboxAgent_Handler,
		},
		{
			MethodName: "GetRegisteredVulinboxAgent",
			Handler:    _Yak_GetRegisteredVulinboxAgent_Handler,
		},
		{
			MethodName: "DisconnectVulinboxAgent",
			Handler:    _Yak_DisconnectVulinboxAgent_Handler,
		},
		{
			MethodName: "IsCVEDatabaseReady",
			Handler:    _Yak_IsCVEDatabaseReady_Handler,
		},
		{
			MethodName: "QueryCVE",
			Handler:    _Yak_QueryCVE_Handler,
		},
		{
			MethodName: "GetCVE",
			Handler:    _Yak_GetCVE_Handler,
		},
		{
			MethodName: "SaveTextToTemporalFile",
			Handler:    _Yak_SaveTextToTemporalFile_Handler,
		},
		{
			MethodName: "IsScrecorderReady",
			Handler:    _Yak_IsScrecorderReady_Handler,
		},
		{
			MethodName: "QueryScreenRecorders",
			Handler:    _Yak_QueryScreenRecorders_Handler,
		},
		{
			MethodName: "DeleteScreenRecorders",
			Handler:    _Yak_DeleteScreenRecorders_Handler,
		},
		{
			MethodName: "UploadScreenRecorders",
			Handler:    _Yak_UploadScreenRecorders_Handler,
		},
		{
			MethodName: "GetOneScreenRecorders",
			Handler:    _Yak_GetOneScreenRecorders_Handler,
		},
		{
			MethodName: "UpdateScreenRecorders",
			Handler:    _Yak_UpdateScreenRecorders_Handler,
		},
		{
			MethodName: "IsVulinboxReady",
			Handler:    _Yak_IsVulinboxReady_Handler,
		},
		{
			MethodName: "HTTPRequestBuilder",
			Handler:    _Yak_HTTPRequestBuilder_Handler,
		},
		{
			MethodName: "SmokingEvaluatePlugin",
			Handler:    _Yak_SmokingEvaluatePlugin_Handler,
		},
		{
			MethodName: "GetSystemDefaultDnsServers",
			Handler:    _Yak_GetSystemDefaultDnsServers_Handler,
		},
		{
			MethodName: "GetGlobalNetworkConfig",
			Handler:    _Yak_GetGlobalNetworkConfig_Handler,
		},
		{
			MethodName: "SetGlobalNetworkConfig",
			Handler:    _Yak_SetGlobalNetworkConfig_Handler,
		},
		{
			MethodName: "ResetGlobalNetworkConfig",
			Handler:    _Yak_ResetGlobalNetworkConfig_Handler,
		},
		{
			MethodName: "ValidP12PassWord",
			Handler:    _Yak_ValidP12PassWord_Handler,
		},
		{
			MethodName: "RequestYakURL",
			Handler:    _Yak_RequestYakURL_Handler,
		},
		{
			MethodName: "GetPcapMetadata",
			Handler:    _Yak_GetPcapMetadata_Handler,
		},
		{
			MethodName: "QueryTrafficSession",
			Handler:    _Yak_QueryTrafficSession_Handler,
		},
		{
			MethodName: "QueryTrafficPacket",
			Handler:    _Yak_QueryTrafficPacket_Handler,
		},
		{
			MethodName: "QueryTrafficTCPReassembled",
			Handler:    _Yak_QueryTrafficTCPReassembled_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "MITM",
			Handler:       _Yak_MITM_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
		{
			StreamName:    "OpenPort",
			Handler:       _Yak_OpenPort_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
		{
			StreamName:    "Exec",
			Handler:       _Yak_Exec_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "AutoUpdateYakModule",
			Handler:       _Yak_AutoUpdateYakModule_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "ExecYakScript",
			Handler:       _Yak_ExecYakScript_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "ExecBatchYakScript",
			Handler:       _Yak_ExecBatchYakScript_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "RecoverExecBatchYakScriptUnfinishedTask",
			Handler:       _Yak_RecoverExecBatchYakScriptUnfinishedTask_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "QueryYakScriptByYakScriptName",
			Handler:       _Yak_QueryYakScriptByYakScriptName_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "ExecutePacketYakScript",
			Handler:       _Yak_ExecutePacketYakScript_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "ExecuteBatchPacketYakScript",
			Handler:       _Yak_ExecuteBatchPacketYakScript_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "HTTPFuzzer",
			Handler:       _Yak_HTTPFuzzer_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "HTTPFuzzerSequence",
			Handler:       _Yak_HTTPFuzzerSequence_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "ExtractData",
			Handler:       _Yak_ExtractData_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
		{
			StreamName:    "CreateWebsocketFuzzer",
			Handler:       _Yak_CreateWebsocketFuzzer_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
		{
			StreamName:    "SavePayloadStream",
			Handler:       _Yak_SavePayloadStream_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "PortScan",
			Handler:       _Yak_PortScan_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "SimpleDetect",
			Handler:       _Yak_SimpleDetect_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "RecoverSimpleDetectUnfinishedTask",
			Handler:       _Yak_RecoverSimpleDetectUnfinishedTask_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "StartBrute",
			Handler:       _Yak_StartBrute_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "StartFacades",
			Handler:       _Yak_StartFacades_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "StartFacadesWithYsoObject",
			Handler:       _Yak_StartFacadesWithYsoObject_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "ConfigGlobalReverse",
			Handler:       _Yak_ConfigGlobalReverse_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "ExecYakitPluginsByYakScriptFilter",
			Handler:       _Yak_ExecYakitPluginsByYakScriptFilter_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "ExtractDataToFile",
			Handler:       _Yak_ExtractDataToFile_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
		{
			StreamName:    "DownloadOnlinePluginAll",
			Handler:       _Yak_DownloadOnlinePluginAll_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "ExecPacketScan",
			Handler:       _Yak_ExecPacketScan_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "CreateYaklangShell",
			Handler:       _Yak_CreateYaklangShell_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
		{
			StreamName:    "AttachCombinedOutput",
			Handler:       _Yak_AttachCombinedOutput_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "ExportProject",
			Handler:       _Yak_ExportProject_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "ImportProject",
			Handler:       _Yak_ImportProject_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "ExecuteChaosMakerRule",
			Handler:       _Yak_ExecuteChaosMakerRule_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "UpdateCVEDatabase",
			Handler:       _Yak_UpdateCVEDatabase_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "ExportsProfileDatabase",
			Handler:       _Yak_ExportsProfileDatabase_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "ImportsProfileDatabase",
			Handler:       _Yak_ImportsProfileDatabase_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "InstallScrecorder",
			Handler:       _Yak_InstallScrecorder_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "StartScrecorder",
			Handler:       _Yak_StartScrecorder_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "InstallVulinbox",
			Handler:       _Yak_InstallVulinbox_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "StartVulinbox",
			Handler:       _Yak_StartVulinbox_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "GenQualityInspectionReport",
			Handler:       _Yak_GenQualityInspectionReport_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "DebugPlugin",
			Handler:       _Yak_DebugPlugin_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "DiagnoseNetwork",
			Handler:       _Yak_DiagnoseNetwork_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "DiagnoseNetworkDNS",
			Handler:       _Yak_DiagnoseNetworkDNS_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "PcapX",
			Handler:       _Yak_PcapX_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
		{
			StreamName:    "DuplexConnection",
			Handler:       _Yak_DuplexConnection_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
	},
	Metadata: "yakgrpc.proto",
}
