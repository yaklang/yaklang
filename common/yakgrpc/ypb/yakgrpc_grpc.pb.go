// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.5.1
// - protoc             v4.25.2
// source: yakgrpc.proto

package ypb

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	Yak_Version_FullMethodName                                    = "/ypb.Yak/Version"
	Yak_YakVersionAtLeast_FullMethodName                          = "/ypb.Yak/YakVersionAtLeast"
	Yak_Echo_FullMethodName                                       = "/ypb.Yak/Echo"
	Yak_Handshake_FullMethodName                                  = "/ypb.Yak/Handshake"
	Yak_VerifySystemCertificate_FullMethodName                    = "/ypb.Yak/VerifySystemCertificate"
	Yak_MITM_FullMethodName                                       = "/ypb.Yak/MITM"
	Yak_SetMITMFilter_FullMethodName                              = "/ypb.Yak/SetMITMFilter"
	Yak_GetMITMFilter_FullMethodName                              = "/ypb.Yak/GetMITMFilter"
	Yak_ResetMITMFilter_FullMethodName                            = "/ypb.Yak/ResetMITMFilter"
	Yak_DownloadMITMCert_FullMethodName                           = "/ypb.Yak/DownloadMITMCert"
	Yak_MITMV2_FullMethodName                                     = "/ypb.Yak/MITMV2"
	Yak_OpenPort_FullMethodName                                   = "/ypb.Yak/OpenPort"
	Yak_Exec_FullMethodName                                       = "/ypb.Yak/Exec"
	Yak_QueryExecHistory_FullMethodName                           = "/ypb.Yak/QueryExecHistory"
	Yak_RemoveExecHistory_FullMethodName                          = "/ypb.Yak/RemoveExecHistory"
	Yak_LoadNucleiTemplates_FullMethodName                        = "/ypb.Yak/LoadNucleiTemplates"
	Yak_AutoUpdateYakModule_FullMethodName                        = "/ypb.Yak/AutoUpdateYakModule"
	Yak_ExecYakScript_FullMethodName                              = "/ypb.Yak/ExecYakScript"
	Yak_ExecBatchYakScript_FullMethodName                         = "/ypb.Yak/ExecBatchYakScript"
	Yak_GetExecBatchYakScriptUnfinishedTask_FullMethodName        = "/ypb.Yak/GetExecBatchYakScriptUnfinishedTask"
	Yak_GetExecBatchYakScriptUnfinishedTaskByUid_FullMethodName   = "/ypb.Yak/GetExecBatchYakScriptUnfinishedTaskByUid"
	Yak_PopExecBatchYakScriptUnfinishedTaskByUid_FullMethodName   = "/ypb.Yak/PopExecBatchYakScriptUnfinishedTaskByUid"
	Yak_RecoverExecBatchYakScriptUnfinishedTask_FullMethodName    = "/ypb.Yak/RecoverExecBatchYakScriptUnfinishedTask"
	Yak_QueryYakScript_FullMethodName                             = "/ypb.Yak/QueryYakScript"
	Yak_QueryYakScriptByYakScriptName_FullMethodName              = "/ypb.Yak/QueryYakScriptByYakScriptName"
	Yak_SaveYakScript_FullMethodName                              = "/ypb.Yak/SaveYakScript"
	Yak_DeleteYakScript_FullMethodName                            = "/ypb.Yak/DeleteYakScript"
	Yak_GetYakScriptById_FullMethodName                           = "/ypb.Yak/GetYakScriptById"
	Yak_GetYakScriptByName_FullMethodName                         = "/ypb.Yak/GetYakScriptByName"
	Yak_GetYakScriptByOnlineID_FullMethodName                     = "/ypb.Yak/GetYakScriptByOnlineID"
	Yak_IgnoreYakScript_FullMethodName                            = "/ypb.Yak/IgnoreYakScript"
	Yak_UnIgnoreYakScript_FullMethodName                          = "/ypb.Yak/UnIgnoreYakScript"
	Yak_ExportYakScript_FullMethodName                            = "/ypb.Yak/ExportYakScript"
	Yak_ExportYakScriptStream_FullMethodName                      = "/ypb.Yak/ExportYakScriptStream"
	Yak_ImportYakScriptStream_FullMethodName                      = "/ypb.Yak/ImportYakScriptStream"
	Yak_ExecutePacketYakScript_FullMethodName                     = "/ypb.Yak/ExecutePacketYakScript"
	Yak_ExecuteBatchPacketYakScript_FullMethodName                = "/ypb.Yak/ExecuteBatchPacketYakScript"
	Yak_GetYakScriptTags_FullMethodName                           = "/ypb.Yak/GetYakScriptTags"
	Yak_QueryYakScriptLocalAndUser_FullMethodName                 = "/ypb.Yak/QueryYakScriptLocalAndUser"
	Yak_QueryYakScriptByOnlineGroup_FullMethodName                = "/ypb.Yak/QueryYakScriptByOnlineGroup"
	Yak_QueryYakScriptLocalAll_FullMethodName                     = "/ypb.Yak/QueryYakScriptLocalAll"
	Yak_QueryYakScriptByNames_FullMethodName                      = "/ypb.Yak/QueryYakScriptByNames"
	Yak_QueryYakScriptByIsCore_FullMethodName                     = "/ypb.Yak/QueryYakScriptByIsCore"
	Yak_QueryYakScriptRiskDetailByCWE_FullMethodName              = "/ypb.Yak/QueryYakScriptRiskDetailByCWE"
	Yak_YakScriptRiskTypeList_FullMethodName                      = "/ypb.Yak/YakScriptRiskTypeList"
	Yak_SaveNewYakScript_FullMethodName                           = "/ypb.Yak/SaveNewYakScript"
	Yak_SaveYakScriptToOnline_FullMethodName                      = "/ypb.Yak/SaveYakScriptToOnline"
	Yak_ExportLocalYakScript_FullMethodName                       = "/ypb.Yak/ExportLocalYakScript"
	Yak_ExportLocalYakScriptStream_FullMethodName                 = "/ypb.Yak/ExportLocalYakScriptStream"
	Yak_ImportYakScript_FullMethodName                            = "/ypb.Yak/ImportYakScript"
	Yak_SetYakScriptSkipUpdate_FullMethodName                     = "/ypb.Yak/SetYakScriptSkipUpdate"
	Yak_QueryYakScriptSkipUpdate_FullMethodName                   = "/ypb.Yak/QueryYakScriptSkipUpdate"
	Yak_QueryYakScriptGroup_FullMethodName                        = "/ypb.Yak/QueryYakScriptGroup"
	Yak_SaveYakScriptGroup_FullMethodName                         = "/ypb.Yak/SaveYakScriptGroup"
	Yak_RenameYakScriptGroup_FullMethodName                       = "/ypb.Yak/RenameYakScriptGroup"
	Yak_DeleteYakScriptGroup_FullMethodName                       = "/ypb.Yak/DeleteYakScriptGroup"
	Yak_GetYakScriptGroup_FullMethodName                          = "/ypb.Yak/GetYakScriptGroup"
	Yak_ResetYakScriptGroup_FullMethodName                        = "/ypb.Yak/ResetYakScriptGroup"
	Yak_SetGroup_FullMethodName                                   = "/ypb.Yak/SetGroup"
	Yak_GetHTTPFlowByHash_FullMethodName                          = "/ypb.Yak/GetHTTPFlowByHash"
	Yak_GetHTTPFlowById_FullMethodName                            = "/ypb.Yak/GetHTTPFlowById"
	Yak_GetHTTPFlowBodyById_FullMethodName                        = "/ypb.Yak/GetHTTPFlowBodyById"
	Yak_GetHTTPFlowByIds_FullMethodName                           = "/ypb.Yak/GetHTTPFlowByIds"
	Yak_QueryHTTPFlows_FullMethodName                             = "/ypb.Yak/QueryHTTPFlows"
	Yak_DeleteHTTPFlows_FullMethodName                            = "/ypb.Yak/DeleteHTTPFlows"
	Yak_SetTagForHTTPFlow_FullMethodName                          = "/ypb.Yak/SetTagForHTTPFlow"
	Yak_QueryHTTPFlowsIds_FullMethodName                          = "/ypb.Yak/QueryHTTPFlowsIds"
	Yak_HTTPFlowsFieldGroup_FullMethodName                        = "/ypb.Yak/HTTPFlowsFieldGroup"
	Yak_HTTPFlowsShare_FullMethodName                             = "/ypb.Yak/HTTPFlowsShare"
	Yak_HTTPFlowsExtract_FullMethodName                           = "/ypb.Yak/HTTPFlowsExtract"
	Yak_GetHTTPFlowBare_FullMethodName                            = "/ypb.Yak/GetHTTPFlowBare"
	Yak_ExportHTTPFlows_FullMethodName                            = "/ypb.Yak/ExportHTTPFlows"
	Yak_HTTPFlowsToOnline_FullMethodName                          = "/ypb.Yak/HTTPFlowsToOnline"
	Yak_QueryHTTPFlowsProcessNames_FullMethodName                 = "/ypb.Yak/QueryHTTPFlowsProcessNames"
	Yak_AnalyzeHTTPFlow_FullMethodName                            = "/ypb.Yak/AnalyzeHTTPFlow"
	Yak_ExtractUrl_FullMethodName                                 = "/ypb.Yak/ExtractUrl"
	Yak_GetHistoryHTTPFuzzerTask_FullMethodName                   = "/ypb.Yak/GetHistoryHTTPFuzzerTask"
	Yak_QueryHistoryHTTPFuzzerTask_FullMethodName                 = "/ypb.Yak/QueryHistoryHTTPFuzzerTask"
	Yak_QueryHistoryHTTPFuzzerTaskEx_FullMethodName               = "/ypb.Yak/QueryHistoryHTTPFuzzerTaskEx"
	Yak_DeleteHistoryHTTPFuzzerTask_FullMethodName                = "/ypb.Yak/DeleteHistoryHTTPFuzzerTask"
	Yak_HTTPFuzzer_FullMethodName                                 = "/ypb.Yak/HTTPFuzzer"
	Yak_HTTPFuzzerSequence_FullMethodName                         = "/ypb.Yak/HTTPFuzzerSequence"
	Yak_PreloadHTTPFuzzerParams_FullMethodName                    = "/ypb.Yak/PreloadHTTPFuzzerParams"
	Yak_RenderVariables_FullMethodName                            = "/ypb.Yak/RenderVariables"
	Yak_MatchHTTPResponse_FullMethodName                          = "/ypb.Yak/MatchHTTPResponse"
	Yak_ExtractHTTPResponse_FullMethodName                        = "/ypb.Yak/ExtractHTTPResponse"
	Yak_RedirectRequest_FullMethodName                            = "/ypb.Yak/RedirectRequest"
	Yak_HTTPRequestMutate_FullMethodName                          = "/ypb.Yak/HTTPRequestMutate"
	Yak_HTTPResponseMutate_FullMethodName                         = "/ypb.Yak/HTTPResponseMutate"
	Yak_FixUploadPacket_FullMethodName                            = "/ypb.Yak/FixUploadPacket"
	Yak_IsMultipartFormDataRequest_FullMethodName                 = "/ypb.Yak/IsMultipartFormDataRequest"
	Yak_GenerateExtractRule_FullMethodName                        = "/ypb.Yak/GenerateExtractRule"
	Yak_ExtractData_FullMethodName                                = "/ypb.Yak/ExtractData"
	Yak_ImportHTTPFuzzerTaskFromYaml_FullMethodName               = "/ypb.Yak/ImportHTTPFuzzerTaskFromYaml"
	Yak_ExportHTTPFuzzerTaskToYaml_FullMethodName                 = "/ypb.Yak/ExportHTTPFuzzerTaskToYaml"
	Yak_RenderHTTPFuzzerPacket_FullMethodName                     = "/ypb.Yak/RenderHTTPFuzzerPacket"
	Yak_SaveFuzzerLabel_FullMethodName                            = "/ypb.Yak/SaveFuzzerLabel"
	Yak_QueryFuzzerLabel_FullMethodName                           = "/ypb.Yak/QueryFuzzerLabel"
	Yak_DeleteFuzzerLabel_FullMethodName                          = "/ypb.Yak/DeleteFuzzerLabel"
	Yak_SaveFuzzerConfig_FullMethodName                           = "/ypb.Yak/SaveFuzzerConfig"
	Yak_QueryFuzzerConfig_FullMethodName                          = "/ypb.Yak/QueryFuzzerConfig"
	Yak_DeleteFuzzerConfig_FullMethodName                         = "/ypb.Yak/DeleteFuzzerConfig"
	Yak_QueryHTTPFuzzerResponseByTaskId_FullMethodName            = "/ypb.Yak/QueryHTTPFuzzerResponseByTaskId"
	Yak_CreateWebsocketFuzzer_FullMethodName                      = "/ypb.Yak/CreateWebsocketFuzzer"
	Yak_QueryWebsocketFlowByHTTPFlowWebsocketHash_FullMethodName  = "/ypb.Yak/QueryWebsocketFlowByHTTPFlowWebsocketHash"
	Yak_DeleteWebsocketFlowByHTTPFlowWebsocketHash_FullMethodName = "/ypb.Yak/DeleteWebsocketFlowByHTTPFlowWebsocketHash"
	Yak_DeleteWebsocketFlowAll_FullMethodName                     = "/ypb.Yak/DeleteWebsocketFlowAll"
	Yak_ConvertFuzzerResponseToHTTPFlow_FullMethodName            = "/ypb.Yak/ConvertFuzzerResponseToHTTPFlow"
	Yak_StringFuzzer_FullMethodName                               = "/ypb.Yak/StringFuzzer"
	Yak_HTTPRequestAnalyzer_FullMethodName                        = "/ypb.Yak/HTTPRequestAnalyzer"
	Yak_Codec_FullMethodName                                      = "/ypb.Yak/Codec"
	Yak_NewCodec_FullMethodName                                   = "/ypb.Yak/NewCodec"
	Yak_GetAllCodecMethods_FullMethodName                         = "/ypb.Yak/GetAllCodecMethods"
	Yak_SaveCodecFlow_FullMethodName                              = "/ypb.Yak/SaveCodecFlow"
	Yak_DeleteCodecFlow_FullMethodName                            = "/ypb.Yak/DeleteCodecFlow"
	Yak_GetAllCodecFlow_FullMethodName                            = "/ypb.Yak/GetAllCodecFlow"
	Yak_PacketPrettifyHelper_FullMethodName                       = "/ypb.Yak/PacketPrettifyHelper"
	Yak_QueryPayload_FullMethodName                               = "/ypb.Yak/QueryPayload"
	Yak_QueryPayloadFromFile_FullMethodName                       = "/ypb.Yak/QueryPayloadFromFile"
	Yak_DeletePayloadByFolder_FullMethodName                      = "/ypb.Yak/DeletePayloadByFolder"
	Yak_DeletePayloadByGroup_FullMethodName                       = "/ypb.Yak/DeletePayloadByGroup"
	Yak_DeletePayload_FullMethodName                              = "/ypb.Yak/DeletePayload"
	Yak_SavePayload_FullMethodName                                = "/ypb.Yak/SavePayload"
	Yak_SavePayloadStream_FullMethodName                          = "/ypb.Yak/SavePayloadStream"
	Yak_SavePayloadToFileStream_FullMethodName                    = "/ypb.Yak/SavePayloadToFileStream"
	Yak_SaveLargePayloadToFileStream_FullMethodName               = "/ypb.Yak/SaveLargePayloadToFileStream"
	Yak_RenamePayloadFolder_FullMethodName                        = "/ypb.Yak/RenamePayloadFolder"
	Yak_RenamePayloadGroup_FullMethodName                         = "/ypb.Yak/RenamePayloadGroup"
	Yak_UpdatePayload_FullMethodName                              = "/ypb.Yak/UpdatePayload"
	Yak_UpdatePayloadToFile_FullMethodName                        = "/ypb.Yak/UpdatePayloadToFile"
	Yak_BackUpOrCopyPayloads_FullMethodName                       = "/ypb.Yak/BackUpOrCopyPayloads"
	Yak_GetAllPayloadGroup_FullMethodName                         = "/ypb.Yak/GetAllPayloadGroup"
	Yak_UpdateAllPayloadGroup_FullMethodName                      = "/ypb.Yak/UpdateAllPayloadGroup"
	Yak_GetAllPayload_FullMethodName                              = "/ypb.Yak/GetAllPayload"
	Yak_GetAllPayloadFromFile_FullMethodName                      = "/ypb.Yak/GetAllPayloadFromFile"
	Yak_ExportAllPayload_FullMethodName                           = "/ypb.Yak/ExportAllPayload"
	Yak_ExportAllPayloadFromFile_FullMethodName                   = "/ypb.Yak/ExportAllPayloadFromFile"
	Yak_CreatePayloadFolder_FullMethodName                        = "/ypb.Yak/CreatePayloadFolder"
	Yak_RemoveDuplicatePayloads_FullMethodName                    = "/ypb.Yak/RemoveDuplicatePayloads"
	Yak_CoverPayloadGroupToDatabase_FullMethodName                = "/ypb.Yak/CoverPayloadGroupToDatabase"
	Yak_ConvertPayloadGroupToDatabase_FullMethodName              = "/ypb.Yak/ConvertPayloadGroupToDatabase"
	Yak_MigratePayloads_FullMethodName                            = "/ypb.Yak/MigratePayloads"
	Yak_GetYakitCompletionRaw_FullMethodName                      = "/ypb.Yak/GetYakitCompletionRaw"
	Yak_GetYakVMBuildInMethodCompletion_FullMethodName            = "/ypb.Yak/GetYakVMBuildInMethodCompletion"
	Yak_StaticAnalyzeError_FullMethodName                         = "/ypb.Yak/StaticAnalyzeError"
	Yak_YaklangCompileAndFormat_FullMethodName                    = "/ypb.Yak/YaklangCompileAndFormat"
	Yak_YaklangLanguageSuggestion_FullMethodName                  = "/ypb.Yak/YaklangLanguageSuggestion"
	Yak_YaklangLanguageFind_FullMethodName                        = "/ypb.Yak/YaklangLanguageFind"
	Yak_FuzzTagSuggestion_FullMethodName                          = "/ypb.Yak/FuzzTagSuggestion"
	Yak_YaklangInspectInformation_FullMethodName                  = "/ypb.Yak/YaklangInspectInformation"
	Yak_YaklangGetCliCodeFromDatabase_FullMethodName              = "/ypb.Yak/YaklangGetCliCodeFromDatabase"
	Yak_YaklangTerminal_FullMethodName                            = "/ypb.Yak/YaklangTerminal"
	Yak_PortScan_FullMethodName                                   = "/ypb.Yak/PortScan"
	Yak_ViewPortScanCode_FullMethodName                           = "/ypb.Yak/ViewPortScanCode"
	Yak_SimpleDetect_FullMethodName                               = "/ypb.Yak/SimpleDetect"
	Yak_SaveCancelSimpleDetect_FullMethodName                     = "/ypb.Yak/SaveCancelSimpleDetect"
	Yak_SimpleDetectCreatReport_FullMethodName                    = "/ypb.Yak/SimpleDetectCreatReport"
	Yak_QuerySimpleDetectUnfinishedTask_FullMethodName            = "/ypb.Yak/QuerySimpleDetectUnfinishedTask"
	Yak_GetSimpleDetectRecordRequestById_FullMethodName           = "/ypb.Yak/GetSimpleDetectRecordRequestById"
	Yak_DeleteSimpleDetectUnfinishedTask_FullMethodName           = "/ypb.Yak/DeleteSimpleDetectUnfinishedTask"
	Yak_RecoverSimpleDetectTask_FullMethodName                    = "/ypb.Yak/RecoverSimpleDetectTask"
	Yak_GetSimpleDetectUnfinishedTask_FullMethodName              = "/ypb.Yak/GetSimpleDetectUnfinishedTask"
	Yak_GetSimpleDetectUnfinishedTaskByUid_FullMethodName         = "/ypb.Yak/GetSimpleDetectUnfinishedTaskByUid"
	Yak_PopSimpleDetectUnfinishedTaskByUid_FullMethodName         = "/ypb.Yak/PopSimpleDetectUnfinishedTaskByUid"
	Yak_RecoverSimpleDetectUnfinishedTask_FullMethodName          = "/ypb.Yak/RecoverSimpleDetectUnfinishedTask"
	Yak_QueryPorts_FullMethodName                                 = "/ypb.Yak/QueryPorts"
	Yak_DeletePorts_FullMethodName                                = "/ypb.Yak/DeletePorts"
	Yak_QueryHosts_FullMethodName                                 = "/ypb.Yak/QueryHosts"
	Yak_DeleteHosts_FullMethodName                                = "/ypb.Yak/DeleteHosts"
	Yak_QueryDomains_FullMethodName                               = "/ypb.Yak/QueryDomains"
	Yak_DeleteDomains_FullMethodName                              = "/ypb.Yak/DeleteDomains"
	Yak_QueryPortsGroup_FullMethodName                            = "/ypb.Yak/QueryPortsGroup"
	Yak_UpdateFromYakitResource_FullMethodName                    = "/ypb.Yak/UpdateFromYakitResource"
	Yak_UpdateFromGithub_FullMethodName                           = "/ypb.Yak/UpdateFromGithub"
	Yak_AddToMenu_FullMethodName                                  = "/ypb.Yak/AddToMenu"
	Yak_RemoveFromMenu_FullMethodName                             = "/ypb.Yak/RemoveFromMenu"
	Yak_YakScriptIsInMenu_FullMethodName                          = "/ypb.Yak/YakScriptIsInMenu"
	Yak_GetAllMenuItem_FullMethodName                             = "/ypb.Yak/GetAllMenuItem"
	Yak_DeleteAllMenuItem_FullMethodName                          = "/ypb.Yak/DeleteAllMenuItem"
	Yak_ImportMenuItem_FullMethodName                             = "/ypb.Yak/ImportMenuItem"
	Yak_ExportMenuItem_FullMethodName                             = "/ypb.Yak/ExportMenuItem"
	Yak_GetMenuItemById_FullMethodName                            = "/ypb.Yak/GetMenuItemById"
	Yak_QueryGroupsByYakScriptId_FullMethodName                   = "/ypb.Yak/QueryGroupsByYakScriptId"
	Yak_AddMenus_FullMethodName                                   = "/ypb.Yak/AddMenus"
	Yak_QueryAllMenuItem_FullMethodName                           = "/ypb.Yak/QueryAllMenuItem"
	Yak_DeleteAllMenu_FullMethodName                              = "/ypb.Yak/DeleteAllMenu"
	Yak_AddToNavigation_FullMethodName                            = "/ypb.Yak/AddToNavigation"
	Yak_GetAllNavigationItem_FullMethodName                       = "/ypb.Yak/GetAllNavigationItem"
	Yak_DeleteAllNavigation_FullMethodName                        = "/ypb.Yak/DeleteAllNavigation"
	Yak_AddOneNavigation_FullMethodName                           = "/ypb.Yak/AddOneNavigation"
	Yak_QueryNavigationGroups_FullMethodName                      = "/ypb.Yak/QueryNavigationGroups"
	Yak_SaveMarkdownDocument_FullMethodName                       = "/ypb.Yak/SaveMarkdownDocument"
	Yak_GetMarkdownDocument_FullMethodName                        = "/ypb.Yak/GetMarkdownDocument"
	Yak_DeleteMarkdownDocument_FullMethodName                     = "/ypb.Yak/DeleteMarkdownDocument"
	Yak_StartBasicCrawler_FullMethodName                          = "/ypb.Yak/StartBasicCrawler"
	Yak_ViewBasicCrawlerCode_FullMethodName                       = "/ypb.Yak/ViewBasicCrawlerCode"
	Yak_GenerateWebsiteTree_FullMethodName                        = "/ypb.Yak/GenerateWebsiteTree"
	Yak_QueryYakScriptExecResult_FullMethodName                   = "/ypb.Yak/QueryYakScriptExecResult"
	Yak_QueryYakScriptNameInExecResult_FullMethodName             = "/ypb.Yak/QueryYakScriptNameInExecResult"
	Yak_DeleteYakScriptExecResult_FullMethodName                  = "/ypb.Yak/DeleteYakScriptExecResult"
	Yak_DeleteYakScriptExec_FullMethodName                        = "/ypb.Yak/DeleteYakScriptExec"
	Yak_StartBrute_FullMethodName                                 = "/ypb.Yak/StartBrute"
	Yak_GetAvailableBruteTypes_FullMethodName                     = "/ypb.Yak/GetAvailableBruteTypes"
	Yak_GetTunnelServerExternalIP_FullMethodName                  = "/ypb.Yak/GetTunnelServerExternalIP"
	Yak_VerifyTunnelServerDomain_FullMethodName                   = "/ypb.Yak/VerifyTunnelServerDomain"
	Yak_StartFacades_FullMethodName                               = "/ypb.Yak/StartFacades"
	Yak_StartFacadesWithYsoObject_FullMethodName                  = "/ypb.Yak/StartFacadesWithYsoObject"
	Yak_ApplyClassToFacades_FullMethodName                        = "/ypb.Yak/ApplyClassToFacades"
	Yak_BytesToBase64_FullMethodName                              = "/ypb.Yak/BytesToBase64"
	Yak_ConfigGlobalReverse_FullMethodName                        = "/ypb.Yak/ConfigGlobalReverse"
	Yak_AvailableLocalAddr_FullMethodName                         = "/ypb.Yak/AvailableLocalAddr"
	Yak_GetGlobalReverseServer_FullMethodName                     = "/ypb.Yak/GetGlobalReverseServer"
	Yak_QueryRisks_FullMethodName                                 = "/ypb.Yak/QueryRisks"
	Yak_QueryRisk_FullMethodName                                  = "/ypb.Yak/QueryRisk"
	Yak_DeleteRisk_FullMethodName                                 = "/ypb.Yak/DeleteRisk"
	Yak_QueryAvailableRiskType_FullMethodName                     = "/ypb.Yak/QueryAvailableRiskType"
	Yak_QueryAvailableRiskLevel_FullMethodName                    = "/ypb.Yak/QueryAvailableRiskLevel"
	Yak_QueryRiskTableStats_FullMethodName                        = "/ypb.Yak/QueryRiskTableStats"
	Yak_ResetRiskTableStats_FullMethodName                        = "/ypb.Yak/ResetRiskTableStats"
	Yak_QueryAvailableTarget_FullMethodName                       = "/ypb.Yak/QueryAvailableTarget"
	Yak_QueryNewRisk_FullMethodName                               = "/ypb.Yak/QueryNewRisk"
	Yak_NewRiskRead_FullMethodName                                = "/ypb.Yak/NewRiskRead"
	Yak_UploadRiskToOnline_FullMethodName                         = "/ypb.Yak/UploadRiskToOnline"
	Yak_SetTagForRisk_FullMethodName                              = "/ypb.Yak/SetTagForRisk"
	Yak_QueryRiskTags_FullMethodName                              = "/ypb.Yak/QueryRiskTags"
	Yak_RiskFieldGroup_FullMethodName                             = "/ypb.Yak/RiskFieldGroup"
	Yak_RiskFeedbackToOnline_FullMethodName                       = "/ypb.Yak/RiskFeedbackToOnline"
	Yak_QueryReports_FullMethodName                               = "/ypb.Yak/QueryReports"
	Yak_QueryReport_FullMethodName                                = "/ypb.Yak/QueryReport"
	Yak_DeleteReport_FullMethodName                               = "/ypb.Yak/DeleteReport"
	Yak_QueryAvailableReportFrom_FullMethodName                   = "/ypb.Yak/QueryAvailableReportFrom"
	Yak_DownloadReport_FullMethodName                             = "/ypb.Yak/DownloadReport"
	Yak_GetAllYsoGadgetOptions_FullMethodName                     = "/ypb.Yak/GetAllYsoGadgetOptions"
	Yak_GetAllYsoClassOptions_FullMethodName                      = "/ypb.Yak/GetAllYsoClassOptions"
	Yak_GetAllYsoClassGeneraterOptions_FullMethodName             = "/ypb.Yak/GetAllYsoClassGeneraterOptions"
	Yak_GenerateYsoCode_FullMethodName                            = "/ypb.Yak/GenerateYsoCode"
	Yak_GenerateYsoBytes_FullMethodName                           = "/ypb.Yak/GenerateYsoBytes"
	Yak_YsoDump_FullMethodName                                    = "/ypb.Yak/YsoDump"
	Yak_CreateWebShell_FullMethodName                             = "/ypb.Yak/CreateWebShell"
	Yak_DeleteWebShell_FullMethodName                             = "/ypb.Yak/DeleteWebShell"
	Yak_UpdateWebShell_FullMethodName                             = "/ypb.Yak/UpdateWebShell"
	Yak_QueryWebShells_FullMethodName                             = "/ypb.Yak/QueryWebShells"
	Yak_Ping_FullMethodName                                       = "/ypb.Yak/Ping"
	Yak_GetBasicInfo_FullMethodName                               = "/ypb.Yak/GetBasicInfo"
	Yak_GenerateWebShell_FullMethodName                           = "/ypb.Yak/GenerateWebShell"
	Yak_SetYakBridgeLogServer_FullMethodName                      = "/ypb.Yak/SetYakBridgeLogServer"
	Yak_GetCurrentYakBridgeLogServer_FullMethodName               = "/ypb.Yak/GetCurrentYakBridgeLogServer"
	Yak_RequireDNSLogDomain_FullMethodName                        = "/ypb.Yak/RequireDNSLogDomain"
	Yak_RequireDNSLogDomainByScript_FullMethodName                = "/ypb.Yak/RequireDNSLogDomainByScript"
	Yak_QueryDNSLogByToken_FullMethodName                         = "/ypb.Yak/QueryDNSLogByToken"
	Yak_QueryDNSLogTokenByScript_FullMethodName                   = "/ypb.Yak/QueryDNSLogTokenByScript"
	Yak_RequireICMPRandomLength_FullMethodName                    = "/ypb.Yak/RequireICMPRandomLength"
	Yak_QueryICMPTrigger_FullMethodName                           = "/ypb.Yak/QueryICMPTrigger"
	Yak_RequireRandomPortToken_FullMethodName                     = "/ypb.Yak/RequireRandomPortToken"
	Yak_QueryRandomPortTrigger_FullMethodName                     = "/ypb.Yak/QueryRandomPortTrigger"
	Yak_QuerySupportedDnsLogPlatforms_FullMethodName              = "/ypb.Yak/QuerySupportedDnsLogPlatforms"
	Yak_GetAvailableYakScriptTags_FullMethodName                  = "/ypb.Yak/GetAvailableYakScriptTags"
	Yak_ForceUpdateAvailableYakScriptTags_FullMethodName          = "/ypb.Yak/ForceUpdateAvailableYakScriptTags"
	Yak_ExecYakitPluginsByYakScriptFilter_FullMethodName          = "/ypb.Yak/ExecYakitPluginsByYakScriptFilter"
	Yak_GenerateYakCodeByPacket_FullMethodName                    = "/ypb.Yak/GenerateYakCodeByPacket"
	Yak_GenerateCSRFPocByPacket_FullMethodName                    = "/ypb.Yak/GenerateCSRFPocByPacket"
	Yak_ExportMITMReplacerRules_FullMethodName                    = "/ypb.Yak/ExportMITMReplacerRules"
	Yak_ImportMITMReplacerRules_FullMethodName                    = "/ypb.Yak/ImportMITMReplacerRules"
	Yak_GetCurrentRules_FullMethodName                            = "/ypb.Yak/GetCurrentRules"
	Yak_SetCurrentRules_FullMethodName                            = "/ypb.Yak/SetCurrentRules"
	Yak_GenerateURL_FullMethodName                                = "/ypb.Yak/GenerateURL"
	Yak_ExtractDataToFile_FullMethodName                          = "/ypb.Yak/ExtractDataToFile"
	Yak_AutoDecode_FullMethodName                                 = "/ypb.Yak/AutoDecode"
	Yak_GetSystemProxy_FullMethodName                             = "/ypb.Yak/GetSystemProxy"
	Yak_SetSystemProxy_FullMethodName                             = "/ypb.Yak/SetSystemProxy"
	Yak_GetKey_FullMethodName                                     = "/ypb.Yak/GetKey"
	Yak_SetKey_FullMethodName                                     = "/ypb.Yak/SetKey"
	Yak_DelKey_FullMethodName                                     = "/ypb.Yak/DelKey"
	Yak_GetAllProcessEnvKey_FullMethodName                        = "/ypb.Yak/GetAllProcessEnvKey"
	Yak_SetProcessEnvKey_FullMethodName                           = "/ypb.Yak/SetProcessEnvKey"
	Yak_GetProjectKey_FullMethodName                              = "/ypb.Yak/GetProjectKey"
	Yak_SetProjectKey_FullMethodName                              = "/ypb.Yak/SetProjectKey"
	Yak_GetOnlineProfile_FullMethodName                           = "/ypb.Yak/GetOnlineProfile"
	Yak_SetOnlineProfile_FullMethodName                           = "/ypb.Yak/SetOnlineProfile"
	Yak_DownloadOnlinePluginById_FullMethodName                   = "/ypb.Yak/DownloadOnlinePluginById"
	Yak_DownloadOnlinePluginByIds_FullMethodName                  = "/ypb.Yak/DownloadOnlinePluginByIds"
	Yak_DownloadOnlinePluginAll_FullMethodName                    = "/ypb.Yak/DownloadOnlinePluginAll"
	Yak_DeletePluginByUserID_FullMethodName                       = "/ypb.Yak/DeletePluginByUserID"
	Yak_DeleteAllLocalPlugins_FullMethodName                      = "/ypb.Yak/DeleteAllLocalPlugins"
	Yak_GetYakScriptTagsAndType_FullMethodName                    = "/ypb.Yak/GetYakScriptTagsAndType"
	Yak_DeleteLocalPluginsByWhere_FullMethodName                  = "/ypb.Yak/DeleteLocalPluginsByWhere"
	Yak_DownloadOnlinePluginByScriptNames_FullMethodName          = "/ypb.Yak/DownloadOnlinePluginByScriptNames"
	Yak_DownloadOnlinePlugins_FullMethodName                      = "/ypb.Yak/DownloadOnlinePlugins"
	Yak_DownloadOnlinePluginBatch_FullMethodName                  = "/ypb.Yak/DownloadOnlinePluginBatch"
	Yak_DownloadOnlinePluginByPluginName_FullMethodName           = "/ypb.Yak/DownloadOnlinePluginByPluginName"
	Yak_DownloadOnlinePluginByUUID_FullMethodName                 = "/ypb.Yak/DownloadOnlinePluginByUUID"
	Yak_QueryOnlinePlugins_FullMethodName                         = "/ypb.Yak/QueryOnlinePlugins"
	Yak_ExecPacketScan_FullMethodName                             = "/ypb.Yak/ExecPacketScan"
	Yak_GetEngineDefaultProxy_FullMethodName                      = "/ypb.Yak/GetEngineDefaultProxy"
	Yak_SetEngineDefaultProxy_FullMethodName                      = "/ypb.Yak/SetEngineDefaultProxy"
	Yak_GetMachineID_FullMethodName                               = "/ypb.Yak/GetMachineID"
	Yak_GetLicense_FullMethodName                                 = "/ypb.Yak/GetLicense"
	Yak_CheckLicense_FullMethodName                               = "/ypb.Yak/CheckLicense"
	Yak_GetRequestBodyByHTTPFlowID_FullMethodName                 = "/ypb.Yak/GetRequestBodyByHTTPFlowID"
	Yak_GetResponseBodyByHTTPFlowID_FullMethodName                = "/ypb.Yak/GetResponseBodyByHTTPFlowID"
	Yak_GetHTTPPacketBody_FullMethodName                          = "/ypb.Yak/GetHTTPPacketBody"
	Yak_RegisterFacadesHTTP_FullMethodName                        = "/ypb.Yak/RegisterFacadesHTTP"
	Yak_ResetAndInvalidUserData_FullMethodName                    = "/ypb.Yak/ResetAndInvalidUserData"
	Yak_CreateYaklangShell_FullMethodName                         = "/ypb.Yak/CreateYaklangShell"
	Yak_AttachCombinedOutput_FullMethodName                       = "/ypb.Yak/AttachCombinedOutput"
	Yak_IsPrivilegedForNetRaw_FullMethodName                      = "/ypb.Yak/IsPrivilegedForNetRaw"
	Yak_PromotePermissionForUserPcap_FullMethodName               = "/ypb.Yak/PromotePermissionForUserPcap"
	Yak_SetCurrentProject_FullMethodName                          = "/ypb.Yak/SetCurrentProject"
	Yak_GetCurrentProject_FullMethodName                          = "/ypb.Yak/GetCurrentProject"
	Yak_GetCurrentProjectEx_FullMethodName                        = "/ypb.Yak/GetCurrentProjectEx"
	Yak_GetProjects_FullMethodName                                = "/ypb.Yak/GetProjects"
	Yak_NewProject_FullMethodName                                 = "/ypb.Yak/NewProject"
	Yak_UpdateProject_FullMethodName                              = "/ypb.Yak/UpdateProject"
	Yak_IsProjectNameValid_FullMethodName                         = "/ypb.Yak/IsProjectNameValid"
	Yak_RemoveProject_FullMethodName                              = "/ypb.Yak/RemoveProject"
	Yak_DeleteProject_FullMethodName                              = "/ypb.Yak/DeleteProject"
	Yak_GetDefaultProject_FullMethodName                          = "/ypb.Yak/GetDefaultProject"
	Yak_GetDefaultProjectEx_FullMethodName                        = "/ypb.Yak/GetDefaultProjectEx"
	Yak_QueryProjectDetail_FullMethodName                         = "/ypb.Yak/QueryProjectDetail"
	Yak_GetTemporaryProject_FullMethodName                        = "/ypb.Yak/GetTemporaryProject"
	Yak_GetTemporaryProjectEx_FullMethodName                      = "/ypb.Yak/GetTemporaryProjectEx"
	Yak_ExportProject_FullMethodName                              = "/ypb.Yak/ExportProject"
	Yak_ImportProject_FullMethodName                              = "/ypb.Yak/ImportProject"
	Yak_MigrateLegacyDatabase_FullMethodName                      = "/ypb.Yak/MigrateLegacyDatabase"
	Yak_QueryMITMRuleExtractedData_FullMethodName                 = "/ypb.Yak/QueryMITMRuleExtractedData"
	Yak_ExportMITMRuleExtractedData_FullMethodName                = "/ypb.Yak/ExportMITMRuleExtractedData"
	Yak_ImportChaosMakerRules_FullMethodName                      = "/ypb.Yak/ImportChaosMakerRules"
	Yak_QueryChaosMakerRule_FullMethodName                        = "/ypb.Yak/QueryChaosMakerRule"
	Yak_DeleteChaosMakerRuleByID_FullMethodName                   = "/ypb.Yak/DeleteChaosMakerRuleByID"
	Yak_ExecuteChaosMakerRule_FullMethodName                      = "/ypb.Yak/ExecuteChaosMakerRule"
	Yak_IsRemoteAddrAvailable_FullMethodName                      = "/ypb.Yak/IsRemoteAddrAvailable"
	Yak_ConnectVulinboxAgent_FullMethodName                       = "/ypb.Yak/ConnectVulinboxAgent"
	Yak_GetRegisteredVulinboxAgent_FullMethodName                 = "/ypb.Yak/GetRegisteredVulinboxAgent"
	Yak_DisconnectVulinboxAgent_FullMethodName                    = "/ypb.Yak/DisconnectVulinboxAgent"
	Yak_IsCVEDatabaseReady_FullMethodName                         = "/ypb.Yak/IsCVEDatabaseReady"
	Yak_UpdateCVEDatabase_FullMethodName                          = "/ypb.Yak/UpdateCVEDatabase"
	Yak_ExportsProfileDatabase_FullMethodName                     = "/ypb.Yak/ExportsProfileDatabase"
	Yak_ImportsProfileDatabase_FullMethodName                     = "/ypb.Yak/ImportsProfileDatabase"
	Yak_QueryCVE_FullMethodName                                   = "/ypb.Yak/QueryCVE"
	Yak_GetCVE_FullMethodName                                     = "/ypb.Yak/GetCVE"
	Yak_SaveTextToTemporalFile_FullMethodName                     = "/ypb.Yak/SaveTextToTemporalFile"
	Yak_IsScrecorderReady_FullMethodName                          = "/ypb.Yak/IsScrecorderReady"
	Yak_InstallScrecorder_FullMethodName                          = "/ypb.Yak/InstallScrecorder"
	Yak_StartScrecorder_FullMethodName                            = "/ypb.Yak/StartScrecorder"
	Yak_QueryScreenRecorders_FullMethodName                       = "/ypb.Yak/QueryScreenRecorders"
	Yak_DeleteScreenRecorders_FullMethodName                      = "/ypb.Yak/DeleteScreenRecorders"
	Yak_UploadScreenRecorders_FullMethodName                      = "/ypb.Yak/UploadScreenRecorders"
	Yak_GetOneScreenRecorders_FullMethodName                      = "/ypb.Yak/GetOneScreenRecorders"
	Yak_UpdateScreenRecorders_FullMethodName                      = "/ypb.Yak/UpdateScreenRecorders"
	Yak_IsVulinboxReady_FullMethodName                            = "/ypb.Yak/IsVulinboxReady"
	Yak_InstallVulinbox_FullMethodName                            = "/ypb.Yak/InstallVulinbox"
	Yak_StartVulinbox_FullMethodName                              = "/ypb.Yak/StartVulinbox"
	Yak_GenQualityInspectionReport_FullMethodName                 = "/ypb.Yak/GenQualityInspectionReport"
	Yak_HTTPRequestBuilder_FullMethodName                         = "/ypb.Yak/HTTPRequestBuilder"
	Yak_DebugPlugin_FullMethodName                                = "/ypb.Yak/DebugPlugin"
	Yak_SmokingEvaluatePlugin_FullMethodName                      = "/ypb.Yak/SmokingEvaluatePlugin"
	Yak_SmokingEvaluatePluginBatch_FullMethodName                 = "/ypb.Yak/SmokingEvaluatePluginBatch"
	Yak_GetSystemDefaultDnsServers_FullMethodName                 = "/ypb.Yak/GetSystemDefaultDnsServers"
	Yak_DiagnoseNetwork_FullMethodName                            = "/ypb.Yak/DiagnoseNetwork"
	Yak_DiagnoseNetworkDNS_FullMethodName                         = "/ypb.Yak/DiagnoseNetworkDNS"
	Yak_TraceRoute_FullMethodName                                 = "/ypb.Yak/TraceRoute"
	Yak_GetGlobalNetworkConfig_FullMethodName                     = "/ypb.Yak/GetGlobalNetworkConfig"
	Yak_SetGlobalNetworkConfig_FullMethodName                     = "/ypb.Yak/SetGlobalNetworkConfig"
	Yak_ResetGlobalNetworkConfig_FullMethodName                   = "/ypb.Yak/ResetGlobalNetworkConfig"
	Yak_ValidP12PassWord_FullMethodName                           = "/ypb.Yak/ValidP12PassWord"
	Yak_RequestYakURL_FullMethodName                              = "/ypb.Yak/RequestYakURL"
	Yak_ReadFile_FullMethodName                                   = "/ypb.Yak/ReadFile"
	Yak_GetPcapMetadata_FullMethodName                            = "/ypb.Yak/GetPcapMetadata"
	Yak_PcapX_FullMethodName                                      = "/ypb.Yak/PcapX"
	Yak_QueryTrafficSession_FullMethodName                        = "/ypb.Yak/QueryTrafficSession"
	Yak_QueryTrafficPacket_FullMethodName                         = "/ypb.Yak/QueryTrafficPacket"
	Yak_QueryTrafficTCPReassembled_FullMethodName                 = "/ypb.Yak/QueryTrafficTCPReassembled"
	Yak_ParseTraffic_FullMethodName                               = "/ypb.Yak/ParseTraffic"
	Yak_DuplexConnection_FullMethodName                           = "/ypb.Yak/DuplexConnection"
	Yak_HybridScan_FullMethodName                                 = "/ypb.Yak/HybridScan"
	Yak_QueryHybridScanTask_FullMethodName                        = "/ypb.Yak/QueryHybridScanTask"
	Yak_DeleteHybridScanTask_FullMethodName                       = "/ypb.Yak/DeleteHybridScanTask"
	Yak_GetSpaceEngineStatus_FullMethodName                       = "/ypb.Yak/GetSpaceEngineStatus"
	Yak_GetSpaceEngineAccountStatus_FullMethodName                = "/ypb.Yak/GetSpaceEngineAccountStatus"
	Yak_GetSpaceEngineAccountStatusV2_FullMethodName              = "/ypb.Yak/GetSpaceEngineAccountStatusV2"
	Yak_FetchPortAssetFromSpaceEngine_FullMethodName              = "/ypb.Yak/FetchPortAssetFromSpaceEngine"
	Yak_EvaluateExpression_FullMethodName                         = "/ypb.Yak/EvaluateExpression"
	Yak_EvaluateMultiExpression_FullMethodName                    = "/ypb.Yak/EvaluateMultiExpression"
	Yak_GetThirdPartyAppConfigTemplate_FullMethodName             = "/ypb.Yak/GetThirdPartyAppConfigTemplate"
	Yak_CheckHahValidAiConfig_FullMethodName                      = "/ypb.Yak/CheckHahValidAiConfig"
	Yak_ListAiModel_FullMethodName                                = "/ypb.Yak/ListAiModel"
	Yak_GetFingerprint_FullMethodName                             = "/ypb.Yak/GetFingerprint"
	Yak_AddFingerprint_FullMethodName                             = "/ypb.Yak/AddFingerprint"
	Yak_ModifyFingerprint_FullMethodName                          = "/ypb.Yak/ModifyFingerprint"
	Yak_QueryFingerprint_FullMethodName                           = "/ypb.Yak/QueryFingerprint"
	Yak_DeleteFingerprint_FullMethodName                          = "/ypb.Yak/DeleteFingerprint"
	Yak_UpdateFingerprint_FullMethodName                          = "/ypb.Yak/UpdateFingerprint"
	Yak_CreateFingerprint_FullMethodName                          = "/ypb.Yak/CreateFingerprint"
	Yak_RecoverBuiltinFingerprint_FullMethodName                  = "/ypb.Yak/RecoverBuiltinFingerprint"
	Yak_CreateFingerprintGroup_FullMethodName                     = "/ypb.Yak/CreateFingerprintGroup"
	Yak_GetAllFingerprintGroup_FullMethodName                     = "/ypb.Yak/GetAllFingerprintGroup"
	Yak_RenameFingerprintGroup_FullMethodName                     = "/ypb.Yak/RenameFingerprintGroup"
	Yak_DeleteFingerprintGroup_FullMethodName                     = "/ypb.Yak/DeleteFingerprintGroup"
	Yak_BatchUpdateFingerprintToGroup_FullMethodName              = "/ypb.Yak/BatchUpdateFingerprintToGroup"
	Yak_GetFingerprintGroupSetByFilter_FullMethodName             = "/ypb.Yak/GetFingerprintGroupSetByFilter"
	Yak_ExportFingerprint_FullMethodName                          = "/ypb.Yak/ExportFingerprint"
	Yak_ImportFingerprint_FullMethodName                          = "/ypb.Yak/ImportFingerprint"
	Yak_GetReverseShellProgramList_FullMethodName                 = "/ypb.Yak/GetReverseShellProgramList"
	Yak_GenerateReverseShellCommand_FullMethodName                = "/ypb.Yak/GenerateReverseShellCommand"
	Yak_QuerySyntaxFlowRule_FullMethodName                        = "/ypb.Yak/QuerySyntaxFlowRule"
	Yak_CreateSyntaxFlowRule_FullMethodName                       = "/ypb.Yak/CreateSyntaxFlowRule"
	Yak_CreateSyntaxFlowRuleEx_FullMethodName                     = "/ypb.Yak/CreateSyntaxFlowRuleEx"
	Yak_UpdateSyntaxFlowRule_FullMethodName                       = "/ypb.Yak/UpdateSyntaxFlowRule"
	Yak_UpdateSyntaxFlowRuleEx_FullMethodName                     = "/ypb.Yak/UpdateSyntaxFlowRuleEx"
	Yak_DeleteSyntaxFlowRule_FullMethodName                       = "/ypb.Yak/DeleteSyntaxFlowRule"
	Yak_CheckSyntaxFlowRuleUpdate_FullMethodName                  = "/ypb.Yak/CheckSyntaxFlowRuleUpdate"
	Yak_ApplySyntaxFlowRuleUpdate_FullMethodName                  = "/ypb.Yak/ApplySyntaxFlowRuleUpdate"
	Yak_QuerySyntaxFlowRuleGroup_FullMethodName                   = "/ypb.Yak/QuerySyntaxFlowRuleGroup"
	Yak_DeleteSyntaxFlowRuleGroup_FullMethodName                  = "/ypb.Yak/DeleteSyntaxFlowRuleGroup"
	Yak_CreateSyntaxFlowRuleGroup_FullMethodName                  = "/ypb.Yak/CreateSyntaxFlowRuleGroup"
	Yak_UpdateSyntaxFlowRuleGroup_FullMethodName                  = "/ypb.Yak/UpdateSyntaxFlowRuleGroup"
	Yak_UpdateSyntaxFlowRuleAndGroup_FullMethodName               = "/ypb.Yak/UpdateSyntaxFlowRuleAndGroup"
	Yak_QuerySyntaxFlowSameGroup_FullMethodName                   = "/ypb.Yak/QuerySyntaxFlowSameGroup"
	Yak_SyntaxFlowRuleToOnline_FullMethodName                     = "/ypb.Yak/SyntaxFlowRuleToOnline"
	Yak_DownloadSyntaxFlowRule_FullMethodName                     = "/ypb.Yak/DownloadSyntaxFlowRule"
	Yak_SyntaxFlowScan_FullMethodName                             = "/ypb.Yak/SyntaxFlowScan"
	Yak_QuerySyntaxFlowScanTask_FullMethodName                    = "/ypb.Yak/QuerySyntaxFlowScanTask"
	Yak_DeleteSyntaxFlowScanTask_FullMethodName                   = "/ypb.Yak/DeleteSyntaxFlowScanTask"
	Yak_QuerySyntaxFlowResult_FullMethodName                      = "/ypb.Yak/QuerySyntaxFlowResult"
	Yak_DeleteSyntaxFlowResult_FullMethodName                     = "/ypb.Yak/DeleteSyntaxFlowResult"
	Yak_QuerySSAPrograms_FullMethodName                           = "/ypb.Yak/QuerySSAPrograms"
	Yak_UpdateSSAProgram_FullMethodName                           = "/ypb.Yak/UpdateSSAProgram"
	Yak_DeleteSSAPrograms_FullMethodName                          = "/ypb.Yak/DeleteSSAPrograms"
	Yak_QuerySSARisks_FullMethodName                              = "/ypb.Yak/QuerySSARisks"
	Yak_QueryNewSSARisks_FullMethodName                           = "/ypb.Yak/QueryNewSSARisks"
	Yak_DeleteSSARisks_FullMethodName                             = "/ypb.Yak/DeleteSSARisks"
	Yak_UpdateSSARiskTags_FullMethodName                          = "/ypb.Yak/UpdateSSARiskTags"
	Yak_GetSSARiskFieldGroup_FullMethodName                       = "/ypb.Yak/GetSSARiskFieldGroup"
	Yak_NewSSARiskRead_FullMethodName                             = "/ypb.Yak/NewSSARiskRead"
	Yak_SSARiskFeedbackToOnline_FullMethodName                    = "/ypb.Yak/SSARiskFeedbackToOnline"
	Yak_GetAllPluginEnv_FullMethodName                            = "/ypb.Yak/GetAllPluginEnv"
	Yak_QueryPluginEnv_FullMethodName                             = "/ypb.Yak/QueryPluginEnv"
	Yak_CreatePluginEnv_FullMethodName                            = "/ypb.Yak/CreatePluginEnv"
	Yak_SetPluginEnv_FullMethodName                               = "/ypb.Yak/SetPluginEnv"
	Yak_DeletePluginEnv_FullMethodName                            = "/ypb.Yak/DeletePluginEnv"
	Yak_GetAllFuzztagInfo_FullMethodName                          = "/ypb.Yak/GetAllFuzztagInfo"
	Yak_GenerateFuzztag_FullMethodName                            = "/ypb.Yak/GenerateFuzztag"
	Yak_ExportSyntaxFlows_FullMethodName                          = "/ypb.Yak/ExportSyntaxFlows"
	Yak_ImportSyntaxFlows_FullMethodName                          = "/ypb.Yak/ImportSyntaxFlows"
	Yak_CreateHotPatchTemplate_FullMethodName                     = "/ypb.Yak/CreateHotPatchTemplate"
	Yak_DeleteHotPatchTemplate_FullMethodName                     = "/ypb.Yak/DeleteHotPatchTemplate"
	Yak_UpdateHotPatchTemplate_FullMethodName                     = "/ypb.Yak/UpdateHotPatchTemplate"
	Yak_QueryHotPatchTemplate_FullMethodName                      = "/ypb.Yak/QueryHotPatchTemplate"
	Yak_QueryHotPatchTemplateList_FullMethodName                  = "/ypb.Yak/QueryHotPatchTemplateList"
	Yak_GroupTableColumn_FullMethodName                           = "/ypb.Yak/GroupTableColumn"
	Yak_UploadHotPatchTemplateToOnline_FullMethodName             = "/ypb.Yak/UploadHotPatchTemplateToOnline"
	Yak_DownloadHotPatchTemplate_FullMethodName                   = "/ypb.Yak/DownloadHotPatchTemplate"
	Yak_SetMITMHijackFilter_FullMethodName                        = "/ypb.Yak/SetMITMHijackFilter"
	Yak_GetMITMHijackFilter_FullMethodName                        = "/ypb.Yak/GetMITMHijackFilter"
	Yak_ResetMITMHijackFilter_FullMethodName                      = "/ypb.Yak/ResetMITMHijackFilter"
	Yak_ExportHTTPFlowStream_FullMethodName                       = "/ypb.Yak/ExportHTTPFlowStream"
	Yak_ImportHTTPFlowStream_FullMethodName                       = "/ypb.Yak/ImportHTTPFlowStream"
	Yak_CreateNote_FullMethodName                                 = "/ypb.Yak/CreateNote"
	Yak_UpdateNote_FullMethodName                                 = "/ypb.Yak/UpdateNote"
	Yak_DeleteNote_FullMethodName                                 = "/ypb.Yak/DeleteNote"
	Yak_QueryNote_FullMethodName                                  = "/ypb.Yak/QueryNote"
	Yak_SearchNoteContent_FullMethodName                          = "/ypb.Yak/SearchNoteContent"
	Yak_ImportNote_FullMethodName                                 = "/ypb.Yak/ImportNote"
	Yak_ExportNote_FullMethodName                                 = "/ypb.Yak/ExportNote"
	Yak_StartAITask_FullMethodName                                = "/ypb.Yak/StartAITask"
	Yak_QueryAITask_FullMethodName                                = "/ypb.Yak/QueryAITask"
	Yak_StartAITriage_FullMethodName                              = "/ypb.Yak/StartAITriage"
	Yak_CreateAIForge_FullMethodName                              = "/ypb.Yak/CreateAIForge"
	Yak_UpdateAIForge_FullMethodName                              = "/ypb.Yak/UpdateAIForge"
	Yak_DeleteAIForge_FullMethodName                              = "/ypb.Yak/DeleteAIForge"
	Yak_QueryAIForge_FullMethodName                               = "/ypb.Yak/QueryAIForge"
	Yak_StartMcpServer_FullMethodName                             = "/ypb.Yak/StartMcpServer"
	Yak_GetToolSetList_FullMethodName                             = "/ypb.Yak/GetToolSetList"
	Yak_GetAIToolList_FullMethodName                              = "/ypb.Yak/GetAIToolList"
	Yak_DeleteAITool_FullMethodName                               = "/ypb.Yak/DeleteAITool"
	Yak_SaveAITool_FullMethodName                                 = "/ypb.Yak/SaveAITool"
	Yak_ToggleAIToolFavorite_FullMethodName                       = "/ypb.Yak/ToggleAIToolFavorite"
	Yak_AIToolGenerateMetadata_FullMethodName                     = "/ypb.Yak/AIToolGenerateMetadata"
)

// YakClient is the client API for Yak service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type YakClient interface {
	// version
	Version(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*VersionResponse, error)
	YakVersionAtLeast(ctx context.Context, in *YakVersionAtLeastRequest, opts ...grpc.CallOption) (*GeneralResponse, error)
	// echo 通常用于测试服务是否通畅
	Echo(ctx context.Context, in *EchoRequest, opts ...grpc.CallOption) (*EchoResposne, error)
	// 握手 用于检查前端是否可以连接当前引擎
	Handshake(ctx context.Context, in *HandshakeRequest, opts ...grpc.CallOption) (*HandshakeResponse, error)
	VerifySystemCertificate(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*VerifySystemCertificateResponse, error)
	// 中间人劫持
	MITM(ctx context.Context, opts ...grpc.CallOption) (grpc.BidiStreamingClient[MITMRequest, MITMResponse], error)
	SetMITMFilter(ctx context.Context, in *SetMITMFilterRequest, opts ...grpc.CallOption) (*SetMITMFilterResponse, error)
	GetMITMFilter(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*SetMITMFilterRequest, error)
	ResetMITMFilter(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*SetMITMFilterRequest, error)
	DownloadMITMCert(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*MITMCert, error)
	MITMV2(ctx context.Context, opts ...grpc.CallOption) (grpc.BidiStreamingClient[MITMV2Request, MITMV2Response], error)
	// 开启端口
	OpenPort(ctx context.Context, opts ...grpc.CallOption) (grpc.BidiStreamingClient[Input, Output], error)
	// Exec
	Exec(ctx context.Context, in *ExecRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[ExecResult], error)
	QueryExecHistory(ctx context.Context, in *ExecHistoryRequest, opts ...grpc.CallOption) (*ExecHistoryRecordResponse, error)
	RemoveExecHistory(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*Empty, error)
	LoadNucleiTemplates(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*Empty, error)
	AutoUpdateYakModule(ctx context.Context, in *Empty, opts ...grpc.CallOption) (grpc.ServerStreamingClient[ExecResult], error)
	ExecYakScript(ctx context.Context, in *ExecRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[ExecResult], error)
	// ExecBatch Script
	ExecBatchYakScript(ctx context.Context, in *ExecBatchYakScriptRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[ExecBatchYakScriptResult], error)
	GetExecBatchYakScriptUnfinishedTask(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*GetExecBatchYakScriptUnfinishedTaskResponse, error)
	GetExecBatchYakScriptUnfinishedTaskByUid(ctx context.Context, in *GetExecBatchYakScriptUnfinishedTaskByUidRequest, opts ...grpc.CallOption) (*ExecBatchYakScriptRequest, error)
	PopExecBatchYakScriptUnfinishedTaskByUid(ctx context.Context, in *GetExecBatchYakScriptUnfinishedTaskByUidRequest, opts ...grpc.CallOption) (*ExecBatchYakScriptRequest, error)
	RecoverExecBatchYakScriptUnfinishedTask(ctx context.Context, in *RecoverExecBatchYakScriptUnfinishedTaskRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[ExecBatchYakScriptResult], error)
	// yakScript
	QueryYakScript(ctx context.Context, in *QueryYakScriptRequest, opts ...grpc.CallOption) (*QueryYakScriptResponse, error)
	QueryYakScriptByYakScriptName(ctx context.Context, in *QueryYakScriptRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[YakScript], error)
	SaveYakScript(ctx context.Context, in *YakScript, opts ...grpc.CallOption) (*YakScript, error)
	DeleteYakScript(ctx context.Context, in *DeleteYakScriptRequest, opts ...grpc.CallOption) (*Empty, error)
	GetYakScriptById(ctx context.Context, in *GetYakScriptByIdRequest, opts ...grpc.CallOption) (*YakScript, error)
	GetYakScriptByName(ctx context.Context, in *GetYakScriptByNameRequest, opts ...grpc.CallOption) (*YakScript, error)
	GetYakScriptByOnlineID(ctx context.Context, in *GetYakScriptByOnlineIDRequest, opts ...grpc.CallOption) (*YakScript, error)
	IgnoreYakScript(ctx context.Context, in *DeleteYakScriptRequest, opts ...grpc.CallOption) (*Empty, error)
	UnIgnoreYakScript(ctx context.Context, in *DeleteYakScriptRequest, opts ...grpc.CallOption) (*Empty, error)
	ExportYakScript(ctx context.Context, in *ExportYakScriptRequest, opts ...grpc.CallOption) (*ExportYakScriptResponse, error)
	ExportYakScriptStream(ctx context.Context, in *ExportYakScriptStreamRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[ExecResult], error)
	ImportYakScriptStream(ctx context.Context, in *ImportYakScriptStreamRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[ExecResult], error)
	ExecutePacketYakScript(ctx context.Context, in *ExecutePacketYakScriptParams, opts ...grpc.CallOption) (grpc.ServerStreamingClient[ExecResult], error)
	ExecuteBatchPacketYakScript(ctx context.Context, in *ExecuteBatchPacketYakScriptParams, opts ...grpc.CallOption) (grpc.ServerStreamingClient[ExecBatchYakScriptResult], error)
	GetYakScriptTags(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*GetYakScriptTagsResponse, error)
	QueryYakScriptLocalAndUser(ctx context.Context, in *QueryYakScriptLocalAndUserRequest, opts ...grpc.CallOption) (*QueryYakScriptLocalAndUserResponse, error)
	QueryYakScriptByOnlineGroup(ctx context.Context, in *QueryYakScriptByOnlineGroupRequest, opts ...grpc.CallOption) (*QueryYakScriptLocalAndUserResponse, error)
	QueryYakScriptLocalAll(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*QueryYakScriptLocalAndUserResponse, error)
	QueryYakScriptByNames(ctx context.Context, in *QueryYakScriptByNamesRequest, opts ...grpc.CallOption) (*QueryYakScriptByNamesResponse, error)
	QueryYakScriptByIsCore(ctx context.Context, in *QueryYakScriptByIsCoreRequest, opts ...grpc.CallOption) (*QueryYakScriptByIsCoreResponse, error)
	// 接口废弃
	QueryYakScriptRiskDetailByCWE(ctx context.Context, in *QueryYakScriptRiskDetailByCWERequest, opts ...grpc.CallOption) (*QueryYakScriptRiskDetailByCWEResponse, error)
	// 接口废弃
	YakScriptRiskTypeList(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*YakScriptRiskTypeListResponse, error)
	SaveNewYakScript(ctx context.Context, in *SaveNewYakScriptRequest, opts ...grpc.CallOption) (*YakScript, error)
	SaveYakScriptToOnline(ctx context.Context, in *SaveYakScriptToOnlineRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[SaveYakScriptToOnlineResponse], error)
	// 结构变化,接口废弃
	ExportLocalYakScript(ctx context.Context, in *ExportLocalYakScriptRequest, opts ...grpc.CallOption) (*ExportLocalYakScriptResponse, error)
	ExportLocalYakScriptStream(ctx context.Context, in *ExportLocalYakScriptRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[ExportYakScriptLocalResponse], error)
	ImportYakScript(ctx context.Context, in *ImportYakScriptRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[ImportYakScriptResult], error)
	SetYakScriptSkipUpdate(ctx context.Context, in *SetYakScriptSkipUpdateRequest, opts ...grpc.CallOption) (*Empty, error)
	QueryYakScriptSkipUpdate(ctx context.Context, in *QueryYakScriptRequest, opts ...grpc.CallOption) (*QueryYakScriptSkipUpdateResponse, error)
	// YakScript Group
	QueryYakScriptGroup(ctx context.Context, in *QueryYakScriptGroupRequest, opts ...grpc.CallOption) (*QueryYakScriptGroupResponse, error)
	SaveYakScriptGroup(ctx context.Context, in *SaveYakScriptGroupRequest, opts ...grpc.CallOption) (*Empty, error)
	RenameYakScriptGroup(ctx context.Context, in *RenameYakScriptGroupRequest, opts ...grpc.CallOption) (*Empty, error)
	DeleteYakScriptGroup(ctx context.Context, in *DeleteYakScriptGroupRequest, opts ...grpc.CallOption) (*Empty, error)
	GetYakScriptGroup(ctx context.Context, in *QueryYakScriptRequest, opts ...grpc.CallOption) (*GetYakScriptGroupResponse, error)
	ResetYakScriptGroup(ctx context.Context, in *ResetYakScriptGroupRequest, opts ...grpc.CallOption) (*Empty, error)
	SetGroup(ctx context.Context, in *SetGroupRequest, opts ...grpc.CallOption) (*Empty, error)
	// HTTPFlow
	GetHTTPFlowByHash(ctx context.Context, in *GetHTTPFlowByHashRequest, opts ...grpc.CallOption) (*HTTPFlow, error)
	GetHTTPFlowById(ctx context.Context, in *GetHTTPFlowByIdRequest, opts ...grpc.CallOption) (*HTTPFlow, error)
	GetHTTPFlowBodyById(ctx context.Context, in *GetHTTPFlowBodyByIdRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[GetHTTPFlowBodyByIdResponse], error)
	GetHTTPFlowByIds(ctx context.Context, in *GetHTTPFlowByIdsRequest, opts ...grpc.CallOption) (*HTTPFlows, error)
	QueryHTTPFlows(ctx context.Context, in *QueryHTTPFlowRequest, opts ...grpc.CallOption) (*QueryHTTPFlowResponse, error)
	DeleteHTTPFlows(ctx context.Context, in *DeleteHTTPFlowRequest, opts ...grpc.CallOption) (*Empty, error)
	SetTagForHTTPFlow(ctx context.Context, in *SetTagForHTTPFlowRequest, opts ...grpc.CallOption) (*Empty, error)
	QueryHTTPFlowsIds(ctx context.Context, in *QueryHTTPFlowsIdsRequest, opts ...grpc.CallOption) (*QueryHTTPFlowsIdsResponse, error)
	HTTPFlowsFieldGroup(ctx context.Context, in *HTTPFlowsFieldGroupRequest, opts ...grpc.CallOption) (*HTTPFlowsFieldGroupResponse, error)
	HTTPFlowsShare(ctx context.Context, in *HTTPFlowsShareRequest, opts ...grpc.CallOption) (*HTTPFlowsShareResponse, error)
	HTTPFlowsExtract(ctx context.Context, in *HTTPFlowsExtractRequest, opts ...grpc.CallOption) (*Empty, error)
	GetHTTPFlowBare(ctx context.Context, in *HTTPFlowBareRequest, opts ...grpc.CallOption) (*HTTPFlowBareResponse, error)
	ExportHTTPFlows(ctx context.Context, in *ExportHTTPFlowsRequest, opts ...grpc.CallOption) (*QueryHTTPFlowResponse, error)
	HTTPFlowsToOnline(ctx context.Context, in *HTTPFlowsToOnlineRequest, opts ...grpc.CallOption) (*Empty, error)
	QueryHTTPFlowsProcessNames(ctx context.Context, in *QueryHTTPFlowRequest, opts ...grpc.CallOption) (*QueryHTTPFlowsProcessNamesResponse, error)
	// 流量分析器
	AnalyzeHTTPFlow(ctx context.Context, in *AnalyzeHTTPFlowRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[AnalyzeHTTPFlowResponse], error)
	// 从一个 FuzzerRequest 中提取 Url
	ExtractUrl(ctx context.Context, in *FuzzerRequest, opts ...grpc.CallOption) (*ExtractedUrl, error)
	// Fuzzer
	GetHistoryHTTPFuzzerTask(ctx context.Context, in *GetHistoryHTTPFuzzerTaskRequest, opts ...grpc.CallOption) (*HistoryHTTPFuzzerTaskDetail, error)
	QueryHistoryHTTPFuzzerTask(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*HistoryHTTPFuzzerTasks, error)
	QueryHistoryHTTPFuzzerTaskEx(ctx context.Context, in *QueryHistoryHTTPFuzzerTaskExParams, opts ...grpc.CallOption) (*HistoryHTTPFuzzerTasksResponse, error)
	DeleteHistoryHTTPFuzzerTask(ctx context.Context, in *DeleteHistoryHTTPFuzzerTaskRequest, opts ...grpc.CallOption) (*Empty, error)
	HTTPFuzzer(ctx context.Context, in *FuzzerRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[FuzzerResponse], error)
	HTTPFuzzerSequence(ctx context.Context, in *FuzzerRequests, opts ...grpc.CallOption) (grpc.ServerStreamingClient[FuzzerSequenceResponse], error)
	PreloadHTTPFuzzerParams(ctx context.Context, in *PreloadHTTPFuzzerParamsRequest, opts ...grpc.CallOption) (*PreloadHTTPFuzzerParamsResponse, error)
	RenderVariables(ctx context.Context, in *RenderVariablesRequest, opts ...grpc.CallOption) (*RenderVariablesResponse, error)
	MatchHTTPResponse(ctx context.Context, in *MatchHTTPResponseParams, opts ...grpc.CallOption) (*MatchHTTPResponseResult, error)
	ExtractHTTPResponse(ctx context.Context, in *ExtractHTTPResponseParams, opts ...grpc.CallOption) (*ExtractHTTPResponseResult, error)
	RedirectRequest(ctx context.Context, in *RedirectRequestParams, opts ...grpc.CallOption) (*FuzzerResponse, error)
	HTTPRequestMutate(ctx context.Context, in *HTTPRequestMutateParams, opts ...grpc.CallOption) (*MutateResult, error)
	HTTPResponseMutate(ctx context.Context, in *HTTPResponseMutateParams, opts ...grpc.CallOption) (*MutateResult, error)
	FixUploadPacket(ctx context.Context, in *FixUploadPacketRequest, opts ...grpc.CallOption) (*FixUploadPacketResponse, error)
	IsMultipartFormDataRequest(ctx context.Context, in *FixUploadPacketRequest, opts ...grpc.CallOption) (*IsMultipartFormDataRequestResult, error)
	GenerateExtractRule(ctx context.Context, in *GenerateExtractRuleRequest, opts ...grpc.CallOption) (*GenerateExtractRuleResponse, error)
	ExtractData(ctx context.Context, opts ...grpc.CallOption) (grpc.BidiStreamingClient[ExtractDataRequest, ExtractDataResponse], error)
	ImportHTTPFuzzerTaskFromYaml(ctx context.Context, in *ImportHTTPFuzzerTaskFromYamlRequest, opts ...grpc.CallOption) (*ImportHTTPFuzzerTaskFromYamlResponse, error)
	ExportHTTPFuzzerTaskToYaml(ctx context.Context, in *ExportHTTPFuzzerTaskToYamlRequest, opts ...grpc.CallOption) (*ExportHTTPFuzzerTaskToYamlResponse, error)
	RenderHTTPFuzzerPacket(ctx context.Context, in *RenderHTTPFuzzerPacketRequest, opts ...grpc.CallOption) (*RenderHTTPFuzzerPacketResponse, error)
	SaveFuzzerLabel(ctx context.Context, in *SaveFuzzerLabelRequest, opts ...grpc.CallOption) (*Empty, error)
	QueryFuzzerLabel(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*QueryFuzzerLabelResponse, error)
	DeleteFuzzerLabel(ctx context.Context, in *DeleteFuzzerLabelRequest, opts ...grpc.CallOption) (*Empty, error)
	SaveFuzzerConfig(ctx context.Context, in *SaveFuzzerConfigRequest, opts ...grpc.CallOption) (*DbOperateMessage, error)
	QueryFuzzerConfig(ctx context.Context, in *QueryFuzzerConfigRequest, opts ...grpc.CallOption) (*QueryFuzzerConfigResponse, error)
	DeleteFuzzerConfig(ctx context.Context, in *DeleteFuzzerConfigRequest, opts ...grpc.CallOption) (*DbOperateMessage, error)
	// HTTPFuzzerResponse
	// 这个挺特殊的，因为数据包太多了，会卡，所以后端会保存一份，通过这个接口做缓存查询
	QueryHTTPFuzzerResponseByTaskId(ctx context.Context, in *QueryHTTPFuzzerResponseByTaskIdRequest, opts ...grpc.CallOption) (*QueryHTTPFuzzerResponseByTaskIdResponse, error)
	// WebSocket
	CreateWebsocketFuzzer(ctx context.Context, opts ...grpc.CallOption) (grpc.BidiStreamingClient[ClientWebsocketRequest, ClientWebsocketResponse], error)
	QueryWebsocketFlowByHTTPFlowWebsocketHash(ctx context.Context, in *QueryWebsocketFlowByHTTPFlowWebsocketHashRequest, opts ...grpc.CallOption) (*WebsocketFlows, error)
	DeleteWebsocketFlowByHTTPFlowWebsocketHash(ctx context.Context, in *DeleteWebsocketFlowByHTTPFlowWebsocketHashRequest, opts ...grpc.CallOption) (*Empty, error)
	DeleteWebsocketFlowAll(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*Empty, error)
	// FuzzerResponse 对象转 HTTPFlow：以便分析和模糊测试
	ConvertFuzzerResponseToHTTPFlow(ctx context.Context, in *FuzzerResponse, opts ...grpc.CallOption) (*HTTPFlow, error)
	// 渲染 Fuzzer 模版
	StringFuzzer(ctx context.Context, in *StringFuzzerRequest, opts ...grpc.CallOption) (*StringFuzzerResponse, error)
	// 分析一个 HTTP 请求详情
	HTTPRequestAnalyzer(ctx context.Context, in *HTTPRequestAnalysisMaterial, opts ...grpc.CallOption) (*HTTPRequestAnalysis, error)
	// 编码解码
	Codec(ctx context.Context, in *CodecRequest, opts ...grpc.CallOption) (*CodecResponse, error)
	NewCodec(ctx context.Context, in *CodecRequestFlow, opts ...grpc.CallOption) (*CodecResponse, error)
	GetAllCodecMethods(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*CodecMethods, error)
	SaveCodecFlow(ctx context.Context, in *CustomizeCodecFlow, opts ...grpc.CallOption) (*Empty, error)
	DeleteCodecFlow(ctx context.Context, in *DeleteCodecFlowRequest, opts ...grpc.CallOption) (*Empty, error)
	GetAllCodecFlow(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*GetCodecFlowResponse, error)
	PacketPrettifyHelper(ctx context.Context, in *PacketPrettifyHelperRequest, opts ...grpc.CallOption) (*PacketPrettifyHelperResponse, error)
	// Payload 相关接口
	// database payload group
	QueryPayload(ctx context.Context, in *QueryPayloadRequest, opts ...grpc.CallOption) (*QueryPayloadResponse, error)
	QueryPayloadFromFile(ctx context.Context, in *QueryPayloadFromFileRequest, opts ...grpc.CallOption) (*QueryPayloadFromFileResponse, error)
	// delete by [id/group/folder]
	DeletePayloadByFolder(ctx context.Context, in *NameRequest, opts ...grpc.CallOption) (*Empty, error)
	DeletePayloadByGroup(ctx context.Context, in *DeletePayloadByGroupRequest, opts ...grpc.CallOption) (*Empty, error)
	DeletePayload(ctx context.Context, in *DeletePayloadRequest, opts ...grpc.CallOption) (*Empty, error)
	// save payload to database
	SavePayload(ctx context.Context, in *SavePayloadRequest, opts ...grpc.CallOption) (*Empty, error)
	SavePayloadStream(ctx context.Context, in *SavePayloadRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[SavePayloadProgress], error)
	SavePayloadToFileStream(ctx context.Context, in *SavePayloadRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[SavePayloadProgress], error)
	SaveLargePayloadToFileStream(ctx context.Context, in *SavePayloadRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[SavePayloadProgress], error)
	// update group/folder/payload
	RenamePayloadFolder(ctx context.Context, in *RenameRequest, opts ...grpc.CallOption) (*Empty, error)
	RenamePayloadGroup(ctx context.Context, in *RenameRequest, opts ...grpc.CallOption) (*Empty, error)
	UpdatePayload(ctx context.Context, in *UpdatePayloadRequest, opts ...grpc.CallOption) (*Empty, error)
	UpdatePayloadToFile(ctx context.Context, in *UpdatePayloadToFileRequest, opts ...grpc.CallOption) (*Empty, error)
	BackUpOrCopyPayloads(ctx context.Context, in *BackUpOrCopyPayloadsRequest, opts ...grpc.CallOption) (*Empty, error)
	// Folder and Group
	// get and update all group with order
	GetAllPayloadGroup(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*GetAllPayloadGroupResponse, error)
	UpdateAllPayloadGroup(ctx context.Context, in *UpdateAllPayloadGroupRequest, opts ...grpc.CallOption) (*Empty, error)
	// get payload
	GetAllPayload(ctx context.Context, in *GetAllPayloadRequest, opts ...grpc.CallOption) (*GetAllPayloadResponse, error)
	GetAllPayloadFromFile(ctx context.Context, in *GetAllPayloadRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[GetAllPayloadFromFileResponse], error)
	// export payload
	ExportAllPayload(ctx context.Context, in *GetAllPayloadRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[GetAllPayloadResponse], error)
	ExportAllPayloadFromFile(ctx context.Context, in *GetAllPayloadRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[GetAllPayloadResponse], error)
	// create folder
	CreatePayloadFolder(ctx context.Context, in *NameRequest, opts ...grpc.CallOption) (*Empty, error)
	// 去重
	RemoveDuplicatePayloads(ctx context.Context, in *NameRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[SavePayloadProgress], error)
	// 转换为数据库保存
	CoverPayloadGroupToDatabase(ctx context.Context, in *NameRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[SavePayloadProgress], error)
	ConvertPayloadGroupToDatabase(ctx context.Context, in *NameRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[SavePayloadProgress], error)
	// 迁移旧的payload
	MigratePayloads(ctx context.Context, in *Empty, opts ...grpc.CallOption) (grpc.ServerStreamingClient[SavePayloadProgress], error)
	// 自动生成补全
	GetYakitCompletionRaw(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*YakitCompletionRawResponse, error)
	GetYakVMBuildInMethodCompletion(ctx context.Context, in *GetYakVMBuildInMethodCompletionRequest, opts ...grpc.CallOption) (*GetYakVMBuildInMethodCompletionResponse, error)
	StaticAnalyzeError(ctx context.Context, in *StaticAnalyzeErrorRequest, opts ...grpc.CallOption) (*StaticAnalyzeErrorResponse, error)
	YaklangCompileAndFormat(ctx context.Context, in *YaklangCompileAndFormatRequest, opts ...grpc.CallOption) (*YaklangCompileAndFormatResponse, error)
	// LSP
	YaklangLanguageSuggestion(ctx context.Context, in *YaklangLanguageSuggestionRequest, opts ...grpc.CallOption) (*YaklangLanguageSuggestionResponse, error)
	YaklangLanguageFind(ctx context.Context, in *YaklangLanguageSuggestionRequest, opts ...grpc.CallOption) (*YaklangLanguageFindResponse, error)
	// fuzztag suggestion
	FuzzTagSuggestion(ctx context.Context, in *FuzzTagSuggestionRequest, opts ...grpc.CallOption) (*YaklangLanguageSuggestionResponse, error)
	// 从代码中提取yaklang数据
	YaklangInspectInformation(ctx context.Context, in *YaklangInspectInformationRequest, opts ...grpc.CallOption) (*YaklangInspectInformationResponse, error)
	// 进行数据迁移使用
	YaklangGetCliCodeFromDatabase(ctx context.Context, in *YaklangGetCliCodeFromDatabaseRequest, opts ...grpc.CallOption) (*YaklangGetCliCodeFromDatabaseResponse, error)
	// editor terminal 交互
	YaklangTerminal(ctx context.Context, opts ...grpc.CallOption) (grpc.BidiStreamingClient[Input, Output], error)
	// 端口扫描的封装
	PortScan(ctx context.Context, in *PortScanRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[ExecResult], error)
	ViewPortScanCode(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*SimpleScript, error)
	SimpleDetect(ctx context.Context, in *RecordPortScanRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[ExecResult], error)
	SaveCancelSimpleDetect(ctx context.Context, in *RecordPortScanRequest, opts ...grpc.CallOption) (*Empty, error)
	SimpleDetectCreatReport(ctx context.Context, in *CreatReportRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[ExecResult], error)
	// new interface
	QuerySimpleDetectUnfinishedTask(ctx context.Context, in *QueryUnfinishedTaskRequest, opts ...grpc.CallOption) (*QueryUnfinishedTaskResponse, error)
	GetSimpleDetectRecordRequestById(ctx context.Context, in *GetUnfinishedTaskDetailByIdRequest, opts ...grpc.CallOption) (*RecordPortScanRequest, error)
	DeleteSimpleDetectUnfinishedTask(ctx context.Context, in *DeleteUnfinishedTaskRequest, opts ...grpc.CallOption) (*Empty, error)
	RecoverSimpleDetectTask(ctx context.Context, in *RecoverUnfinishedTaskRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[ExecResult], error)
	// Deprecated interface
	GetSimpleDetectUnfinishedTask(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*GetSimpleDetectUnfinishedTaskResponse, error)
	GetSimpleDetectUnfinishedTaskByUid(ctx context.Context, in *GetExecBatchYakScriptUnfinishedTaskByUidRequest, opts ...grpc.CallOption) (*RecordPortScanRequest, error)
	PopSimpleDetectUnfinishedTaskByUid(ctx context.Context, in *GetExecBatchYakScriptUnfinishedTaskByUidRequest, opts ...grpc.CallOption) (*RecordPortScanRequest, error)
	RecoverSimpleDetectUnfinishedTask(ctx context.Context, in *RecoverExecBatchYakScriptUnfinishedTaskRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[ExecResult], error)
	// 资产管理
	QueryPorts(ctx context.Context, in *QueryPortsRequest, opts ...grpc.CallOption) (*QueryPortsResponse, error)
	DeletePorts(ctx context.Context, in *DeletePortsRequest, opts ...grpc.CallOption) (*Empty, error)
	QueryHosts(ctx context.Context, in *QueryHostsRequest, opts ...grpc.CallOption) (*QueryHostsResponse, error)
	DeleteHosts(ctx context.Context, in *DeleteHostsRequest, opts ...grpc.CallOption) (*Empty, error)
	QueryDomains(ctx context.Context, in *QueryDomainsRequest, opts ...grpc.CallOption) (*QueryDomainsResponse, error)
	DeleteDomains(ctx context.Context, in *DeleteDomainsRequest, opts ...grpc.CallOption) (*Empty, error)
	QueryPortsGroup(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*QueryPortsGroupResponse, error)
	// Yakit Store
	UpdateFromYakitResource(ctx context.Context, in *UpdateFromYakitResourceRequest, opts ...grpc.CallOption) (*Empty, error)
	UpdateFromGithub(ctx context.Context, in *UpdateFromGithubRequest, opts ...grpc.CallOption) (*Empty, error)
	// Menu
	AddToMenu(ctx context.Context, in *AddToMenuRequest, opts ...grpc.CallOption) (*Empty, error)
	RemoveFromMenu(ctx context.Context, in *RemoveFromMenuRequest, opts ...grpc.CallOption) (*Empty, error)
	YakScriptIsInMenu(ctx context.Context, in *YakScriptIsInMenuRequest, opts ...grpc.CallOption) (*Empty, error)
	GetAllMenuItem(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*MenuByGroup, error)
	DeleteAllMenuItem(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*Empty, error)
	ImportMenuItem(ctx context.Context, in *ImportMenuItemRequest, opts ...grpc.CallOption) (*Empty, error)
	ExportMenuItem(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*ExportMenuItemResult, error)
	GetMenuItemById(ctx context.Context, in *GetMenuItemByIdRequest, opts ...grpc.CallOption) (*MenuItem, error)
	QueryGroupsByYakScriptId(ctx context.Context, in *QueryGroupsByYakScriptIdRequest, opts ...grpc.CallOption) (*GroupNames, error)
	AddMenus(ctx context.Context, in *AddMenuRequest, opts ...grpc.CallOption) (*Empty, error)
	QueryAllMenuItem(ctx context.Context, in *QueryAllMenuItemRequest, opts ...grpc.CallOption) (*MenuByGroup, error)
	DeleteAllMenu(ctx context.Context, in *QueryAllMenuItemRequest, opts ...grpc.CallOption) (*Empty, error)
	// NewMenu
	AddToNavigation(ctx context.Context, in *AddToNavigationRequest, opts ...grpc.CallOption) (*Empty, error)
	GetAllNavigationItem(ctx context.Context, in *GetAllNavigationRequest, opts ...grpc.CallOption) (*GetAllNavigationItemResponse, error)
	DeleteAllNavigation(ctx context.Context, in *GetAllNavigationRequest, opts ...grpc.CallOption) (*Empty, error)
	AddOneNavigation(ctx context.Context, in *AddOneNavigationRequest, opts ...grpc.CallOption) (*Empty, error)
	QueryNavigationGroups(ctx context.Context, in *QueryNavigationGroupsRequest, opts ...grpc.CallOption) (*GroupNames, error)
	// document
	SaveMarkdownDocument(ctx context.Context, in *SaveMarkdownDocumentRequest, opts ...grpc.CallOption) (*Empty, error)
	GetMarkdownDocument(ctx context.Context, in *GetMarkdownDocumentRequest, opts ...grpc.CallOption) (*GetMarkdownDocumentResponse, error)
	DeleteMarkdownDocument(ctx context.Context, in *GetMarkdownDocumentRequest, opts ...grpc.CallOption) (*Empty, error)
	// Crawler
	StartBasicCrawler(ctx context.Context, in *StartBasicCrawlerRequest, opts ...grpc.CallOption) (*ExecResult, error)
	ViewBasicCrawlerCode(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*SimpleScript, error)
	GenerateWebsiteTree(ctx context.Context, in *GenerateWebsiteTreeRequest, opts ...grpc.CallOption) (*GenerateWebsiteTreeResponse, error)
	// 对插件结果的操作
	QueryYakScriptExecResult(ctx context.Context, in *QueryYakScriptExecResultRequest, opts ...grpc.CallOption) (*QueryYakScriptExecResultResponse, error)
	QueryYakScriptNameInExecResult(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*YakScriptNames, error)
	DeleteYakScriptExecResult(ctx context.Context, in *DeleteYakScriptExecResultRequest, opts ...grpc.CallOption) (*Empty, error)
	DeleteYakScriptExec(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*Empty, error)
	// Bruter
	StartBrute(ctx context.Context, in *StartBruteParams, opts ...grpc.CallOption) (grpc.ServerStreamingClient[ExecResult], error)
	GetAvailableBruteTypes(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*GetAvailableBruteTypesResponse, error)
	// Tunnel Server RMI/DNSLog
	GetTunnelServerExternalIP(ctx context.Context, in *GetTunnelServerExternalIPParams, opts ...grpc.CallOption) (*GetTunnelServerExternalIPResponse, error)
	VerifyTunnelServerDomain(ctx context.Context, in *VerifyTunnelServerDomainParams, opts ...grpc.CallOption) (*VerifyTunnelServerDomainResponse, error)
	StartFacades(ctx context.Context, in *StartFacadesParams, opts ...grpc.CallOption) (grpc.ServerStreamingClient[ExecResult], error)
	StartFacadesWithYsoObject(ctx context.Context, in *StartFacadesWithYsoParams, opts ...grpc.CallOption) (grpc.ServerStreamingClient[ExecResult], error)
	ApplyClassToFacades(ctx context.Context, in *ApplyClassToFacadesParamsWithVerbose, opts ...grpc.CallOption) (*Empty, error)
	BytesToBase64(ctx context.Context, in *BytesToBase64Request, opts ...grpc.CallOption) (*BytesToBase64Response, error)
	ConfigGlobalReverse(ctx context.Context, in *ConfigGlobalReverseParams, opts ...grpc.CallOption) (grpc.ServerStreamingClient[Empty], error)
	AvailableLocalAddr(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*AvailableLocalAddrResponse, error)
	GetGlobalReverseServer(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*GetGlobalReverseServerResponse, error)
	// Risk
	QueryRisks(ctx context.Context, in *QueryRisksRequest, opts ...grpc.CallOption) (*QueryRisksResponse, error)
	QueryRisk(ctx context.Context, in *QueryRiskRequest, opts ...grpc.CallOption) (*Risk, error)
	DeleteRisk(ctx context.Context, in *DeleteRiskRequest, opts ...grpc.CallOption) (*Empty, error)
	QueryAvailableRiskType(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*Fields, error)
	QueryAvailableRiskLevel(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*Fields, error)
	QueryRiskTableStats(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*RiskTableStats, error)
	ResetRiskTableStats(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*Empty, error)
	QueryAvailableTarget(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*Fields, error)
	QueryNewRisk(ctx context.Context, in *QueryNewRiskRequest, opts ...grpc.CallOption) (*QueryNewRiskResponse, error)
	NewRiskRead(ctx context.Context, in *NewRiskReadRequest, opts ...grpc.CallOption) (*Empty, error)
	// 风险漏洞自动同步
	UploadRiskToOnline(ctx context.Context, in *UploadRiskToOnlineRequest, opts ...grpc.CallOption) (*Empty, error)
	SetTagForRisk(ctx context.Context, in *SetTagForRiskRequest, opts ...grpc.CallOption) (*Empty, error)
	QueryRiskTags(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*QueryRiskTagsResponse, error)
	RiskFieldGroup(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*RiskFieldGroupResponse, error)
	// 误报反馈
	RiskFeedbackToOnline(ctx context.Context, in *UploadRiskToOnlineRequest, opts ...grpc.CallOption) (*Empty, error)
	// Report
	QueryReports(ctx context.Context, in *QueryReportsRequest, opts ...grpc.CallOption) (*QueryReportsResponse, error)
	QueryReport(ctx context.Context, in *QueryReportRequest, opts ...grpc.CallOption) (*Report, error)
	DeleteReport(ctx context.Context, in *DeleteReportRequest, opts ...grpc.CallOption) (*Empty, error)
	QueryAvailableReportFrom(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*Fields, error)
	DownloadReport(ctx context.Context, in *DownloadReportRequest, opts ...grpc.CallOption) (*Empty, error)
	// Yso
	GetAllYsoGadgetOptions(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*YsoOptionsWithVerbose, error)
	GetAllYsoClassOptions(ctx context.Context, in *YsoOptionsRequerstWithVerbose, opts ...grpc.CallOption) (*YsoOptionsWithVerbose, error)
	GetAllYsoClassGeneraterOptions(ctx context.Context, in *YsoOptionsRequerstWithVerbose, opts ...grpc.CallOption) (*YsoClassOptionsResponseWithVerbose, error)
	GenerateYsoCode(ctx context.Context, in *YsoOptionsRequerstWithVerbose, opts ...grpc.CallOption) (*YsoCodeResponse, error)
	GenerateYsoBytes(ctx context.Context, in *YsoOptionsRequerstWithVerbose, opts ...grpc.CallOption) (*YsoBytesResponse, error)
	YsoDump(ctx context.Context, in *YsoBytesObject, opts ...grpc.CallOption) (*YsoDumpResponse, error)
	// WebShell
	CreateWebShell(ctx context.Context, in *WebShell, opts ...grpc.CallOption) (*WebShell, error)
	DeleteWebShell(ctx context.Context, in *DeleteWebShellRequest, opts ...grpc.CallOption) (*Empty, error)
	UpdateWebShell(ctx context.Context, in *WebShell, opts ...grpc.CallOption) (*WebShell, error)
	QueryWebShells(ctx context.Context, in *QueryWebShellsRequest, opts ...grpc.CallOption) (*QueryWebShellsResponse, error)
	Ping(ctx context.Context, in *WebShellRequest, opts ...grpc.CallOption) (*WebShellResponse, error)
	GetBasicInfo(ctx context.Context, in *WebShellRequest, opts ...grpc.CallOption) (*WebShellResponse, error)
	GenerateWebShell(ctx context.Context, in *ShellGenerate, opts ...grpc.CallOption) (*WebShellResponse, error)
	// DNSLog / ICMP / RandomTrigger
	SetYakBridgeLogServer(ctx context.Context, in *YakDNSLogBridgeAddr, opts ...grpc.CallOption) (*Empty, error)
	GetCurrentYakBridgeLogServer(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*YakDNSLogBridgeAddr, error)
	RequireDNSLogDomain(ctx context.Context, in *YakDNSLogBridgeAddr, opts ...grpc.CallOption) (*DNSLogRootDomain, error)
	RequireDNSLogDomainByScript(ctx context.Context, in *RequireDNSLogDomainByScriptRequest, opts ...grpc.CallOption) (*DNSLogRootDomain, error)
	QueryDNSLogByToken(ctx context.Context, in *QueryDNSLogByTokenRequest, opts ...grpc.CallOption) (*QueryDNSLogByTokenResponse, error)
	QueryDNSLogTokenByScript(ctx context.Context, in *RequireDNSLogDomainByScriptRequest, opts ...grpc.CallOption) (*QueryDNSLogByTokenResponse, error)
	RequireICMPRandomLength(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*RequireICMPRandomLengthResponse, error)
	QueryICMPTrigger(ctx context.Context, in *QueryICMPTriggerRequest, opts ...grpc.CallOption) (*QueryICMPTriggerResponse, error)
	RequireRandomPortToken(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*RandomPortInfo, error)
	QueryRandomPortTrigger(ctx context.Context, in *QueryRandomPortTriggerRequest, opts ...grpc.CallOption) (*RandomPortTriggerNotification, error)
	QuerySupportedDnsLogPlatforms(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*QuerySupportedDnsLogPlatformsResponse, error)
	// 获取 Tags
	GetAvailableYakScriptTags(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*Fields, error)
	ForceUpdateAvailableYakScriptTags(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*Empty, error)
	// 通用的漏洞检测技术方案
	ExecYakitPluginsByYakScriptFilter(ctx context.Context, in *ExecYakitPluginsByYakScriptFilterRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[ExecResult], error)
	// GenerateYakCodeByPacket
	GenerateYakCodeByPacket(ctx context.Context, in *GenerateYakCodeByPacketRequest, opts ...grpc.CallOption) (*GenerateYakCodeByPacketResponse, error)
	// CSRF Generator
	GenerateCSRFPocByPacket(ctx context.Context, in *GenerateCSRFPocByPacketRequest, opts ...grpc.CallOption) (*GenerateCSRFPocByPacketResponse, error)
	// MITM 衍生功能：
	// Replacers 管理
	ExportMITMReplacerRules(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*ExportMITMReplacerRulesResponse, error)
	ImportMITMReplacerRules(ctx context.Context, in *ImportMITMReplacerRulesRequest, opts ...grpc.CallOption) (*Empty, error)
	GetCurrentRules(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*MITMContentReplacers, error)
	SetCurrentRules(ctx context.Context, in *MITMContentReplacers, opts ...grpc.CallOption) (*Empty, error)
	GenerateURL(ctx context.Context, in *GenerateURLRequest, opts ...grpc.CallOption) (*GenerateURLResponse, error)
	ExtractDataToFile(ctx context.Context, opts ...grpc.CallOption) (grpc.BidiStreamingClient[ExtractDataToFileRequest, ExtractDataToFileResult], error)
	// 尝试自动解码
	AutoDecode(ctx context.Context, in *AutoDecodeRequest, opts ...grpc.CallOption) (*AutoDecodeResponse, error)
	GetSystemProxy(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*GetSystemProxyResult, error)
	SetSystemProxy(ctx context.Context, in *SetSystemProxyRequest, opts ...grpc.CallOption) (*Empty, error)
	// 设置通用存储
	GetKey(ctx context.Context, in *GetKeyRequest, opts ...grpc.CallOption) (*GetKeyResult, error)
	SetKey(ctx context.Context, in *SetKeyRequest, opts ...grpc.CallOption) (*Empty, error)
	DelKey(ctx context.Context, in *GetKeyRequest, opts ...grpc.CallOption) (*Empty, error)
	GetAllProcessEnvKey(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*GetProcessEnvKeyResult, error)
	SetProcessEnvKey(ctx context.Context, in *SetKeyRequest, opts ...grpc.CallOption) (*Empty, error)
	GetProjectKey(ctx context.Context, in *GetKeyRequest, opts ...grpc.CallOption) (*GetKeyResult, error)
	SetProjectKey(ctx context.Context, in *SetKeyRequest, opts ...grpc.CallOption) (*Empty, error)
	// Online
	GetOnlineProfile(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*OnlineProfile, error)
	SetOnlineProfile(ctx context.Context, in *OnlineProfile, opts ...grpc.CallOption) (*Empty, error)
	// 废弃接口
	DownloadOnlinePluginById(ctx context.Context, in *DownloadOnlinePluginByIdRequest, opts ...grpc.CallOption) (*Empty, error)
	// 废弃接口
	DownloadOnlinePluginByIds(ctx context.Context, in *DownloadOnlinePluginByIdsRequest, opts ...grpc.CallOption) (*Empty, error)
	// 废弃接口
	DownloadOnlinePluginAll(ctx context.Context, in *DownloadOnlinePluginByTokenRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[DownloadOnlinePluginProgress], error)
	DeletePluginByUserID(ctx context.Context, in *DeletePluginByUserIDRequest, opts ...grpc.CallOption) (*Empty, error)
	DeleteAllLocalPlugins(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*Empty, error)
	GetYakScriptTagsAndType(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*GetYakScriptTagsAndTypeResponse, error)
	DeleteLocalPluginsByWhere(ctx context.Context, in *DeleteLocalPluginsByWhereRequest, opts ...grpc.CallOption) (*Empty, error)
	// 废弃接口
	DownloadOnlinePluginByScriptNames(ctx context.Context, in *DownloadOnlinePluginByScriptNamesRequest, opts ...grpc.CallOption) (*DownloadOnlinePluginByScriptNamesResponse, error)
	// NewOnline 插件下载
	DownloadOnlinePlugins(ctx context.Context, in *DownloadOnlinePluginsRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[DownloadOnlinePluginProgress], error)
	DownloadOnlinePluginBatch(ctx context.Context, in *DownloadOnlinePluginsRequest, opts ...grpc.CallOption) (*Empty, error)
	DownloadOnlinePluginByPluginName(ctx context.Context, in *DownloadOnlinePluginByScriptNamesRequest, opts ...grpc.CallOption) (*DownloadOnlinePluginByScriptNamesResponse, error)
	DownloadOnlinePluginByUUID(ctx context.Context, in *DownloadOnlinePluginByUUIDRequest, opts ...grpc.CallOption) (*YakScript, error)
	QueryOnlinePlugins(ctx context.Context, in *QueryOnlinePluginsRequest, opts ...grpc.CallOption) (*QueryOnlinePluginsResponse, error)
	// 新的扫描模式
	ExecPacketScan(ctx context.Context, in *ExecPacketScanRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[ExecResult], error)
	GetEngineDefaultProxy(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*DefaultProxyResult, error)
	SetEngineDefaultProxy(ctx context.Context, in *DefaultProxyResult, opts ...grpc.CallOption) (*Empty, error)
	// machine id
	GetMachineID(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*GetMachineIDResponse, error)
	// license
	GetLicense(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*GetLicenseResponse, error)
	CheckLicense(ctx context.Context, in *CheckLicenseRequest, opts ...grpc.CallOption) (*Empty, error)
	// Response Body 的魔法操作
	GetRequestBodyByHTTPFlowID(ctx context.Context, in *DownloadBodyByHTTPFlowIDRequest, opts ...grpc.CallOption) (*Bytes, error)
	GetResponseBodyByHTTPFlowID(ctx context.Context, in *DownloadBodyByHTTPFlowIDRequest, opts ...grpc.CallOption) (*Bytes, error)
	GetHTTPPacketBody(ctx context.Context, in *GetHTTPPacketBodyRequest, opts ...grpc.CallOption) (*Bytes, error)
	// 注册一个 Facades HTTP 响应
	RegisterFacadesHTTP(ctx context.Context, in *RegisterFacadesHTTPRequest, opts ...grpc.CallOption) (*RegisterFacadesHTTPResponse, error)
	// 重置到恢复出厂设置
	ResetAndInvalidUserData(ctx context.Context, in *ResetAndInvalidUserDataRequest, opts ...grpc.CallOption) (*Empty, error)
	// Yaklang Shell
	// 创建一个交互式 Shell
	CreateYaklangShell(ctx context.Context, opts ...grpc.CallOption) (grpc.BidiStreamingClient[YaklangShellRequest, YaklangShellResponse], error)
	// 接入标准输出和标准错误流
	AttachCombinedOutput(ctx context.Context, in *AttachCombinedOutputRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[ExecResult], error)
	// 判断当前引擎对网卡是否有操作权限？
	// 主要是能否发包等敏感操作
	// Windows 判断是否是管理员即可 I Am Admin
	// Linux 和 MacOS 应该尝试 pcap 打开网卡就行
	IsPrivilegedForNetRaw(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*IsPrivilegedForNetRawResponse, error)
	PromotePermissionForUserPcap(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*Empty, error)
	// 操作项目的相关接口，通过设置 ProjectDatabase
	SetCurrentProject(ctx context.Context, in *SetCurrentProjectRequest, opts ...grpc.CallOption) (*Empty, error)
	GetCurrentProject(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*ProjectDescription, error)
	GetCurrentProjectEx(ctx context.Context, in *GetCurrentProjectExRequest, opts ...grpc.CallOption) (*ProjectDescription, error)
	GetProjects(ctx context.Context, in *GetProjectsRequest, opts ...grpc.CallOption) (*GetProjectsResponse, error)
	NewProject(ctx context.Context, in *NewProjectRequest, opts ...grpc.CallOption) (*NewProjectResponse, error)
	UpdateProject(ctx context.Context, in *NewProjectRequest, opts ...grpc.CallOption) (*NewProjectResponse, error)
	IsProjectNameValid(ctx context.Context, in *IsProjectNameValidRequest, opts ...grpc.CallOption) (*Empty, error)
	RemoveProject(ctx context.Context, in *RemoveProjectRequest, opts ...grpc.CallOption) (*Empty, error)
	DeleteProject(ctx context.Context, in *DeleteProjectRequest, opts ...grpc.CallOption) (*Empty, error)
	GetDefaultProject(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*ProjectDescription, error)
	GetDefaultProjectEx(ctx context.Context, in *GetDefaultProjectExRequest, opts ...grpc.CallOption) (*ProjectDescription, error)
	QueryProjectDetail(ctx context.Context, in *QueryProjectDetailRequest, opts ...grpc.CallOption) (*ProjectDescription, error)
	GetTemporaryProject(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*ProjectDescription, error)
	GetTemporaryProjectEx(ctx context.Context, in *GetTemporaryProjectExRequest, opts ...grpc.CallOption) (*ProjectDescription, error)
	// 导入导出项目，带密码，带进度
	ExportProject(ctx context.Context, in *ExportProjectRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[ProjectIOProgress], error)
	ImportProject(ctx context.Context, in *ImportProjectRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[ProjectIOProgress], error)
	// 迁移旧数据库
	MigrateLegacyDatabase(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*Empty, error)
	// 从规则中提取数据
	QueryMITMRuleExtractedData(ctx context.Context, in *QueryMITMRuleExtractedDataRequest, opts ...grpc.CallOption) (*QueryMITMRuleExtractedDataResponse, error)
	ExportMITMRuleExtractedData(ctx context.Context, in *ExportMITMRuleExtractedDataRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[ExportMITMRuleExtractedDataResponse], error)
	// ChaosMakerRule: Bas
	ImportChaosMakerRules(ctx context.Context, in *ImportChaosMakerRulesRequest, opts ...grpc.CallOption) (*Empty, error)
	QueryChaosMakerRule(ctx context.Context, in *QueryChaosMakerRuleRequest, opts ...grpc.CallOption) (*QueryChaosMakerRuleResponse, error)
	DeleteChaosMakerRuleByID(ctx context.Context, in *DeleteChaosMakerRuleByIDRequest, opts ...grpc.CallOption) (*Empty, error)
	ExecuteChaosMakerRule(ctx context.Context, in *ExecuteChaosMakerRuleRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[ExecResult], error)
	// 这个接口是判断 BAS Agent 远程端口是否可用的，使用 Vulinbox ws agent 协议连接
	// ConnectVulinboxAgent is the same as IsRemoteAddrAvailable
	IsRemoteAddrAvailable(ctx context.Context, in *IsRemoteAddrAvailableRequest, opts ...grpc.CallOption) (*IsRemoteAddrAvailableResponse, error)
	ConnectVulinboxAgent(ctx context.Context, in *IsRemoteAddrAvailableRequest, opts ...grpc.CallOption) (*IsRemoteAddrAvailableResponse, error)
	// vulinbox agent 的操作接口
	GetRegisteredVulinboxAgent(ctx context.Context, in *GetRegisteredAgentRequest, opts ...grpc.CallOption) (*GetRegisteredAgentResponse, error)
	DisconnectVulinboxAgent(ctx context.Context, in *DisconnectVulinboxAgentRequest, opts ...grpc.CallOption) (*Empty, error)
	// CVE
	IsCVEDatabaseReady(ctx context.Context, in *IsCVEDatabaseReadyRequest, opts ...grpc.CallOption) (*IsCVEDatabaseReadyResponse, error)
	UpdateCVEDatabase(ctx context.Context, in *UpdateCVEDatabaseRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[ExecResult], error)
	ExportsProfileDatabase(ctx context.Context, in *ExportsProfileDatabaseRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[ExecResult], error)
	ImportsProfileDatabase(ctx context.Context, in *ImportsProfileDatabaseRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[ExecResult], error)
	QueryCVE(ctx context.Context, in *QueryCVERequest, opts ...grpc.CallOption) (*QueryCVEResponse, error)
	GetCVE(ctx context.Context, in *GetCVERequest, opts ...grpc.CallOption) (*CVEDetailEx, error)
	SaveTextToTemporalFile(ctx context.Context, in *SaveTextToTemporalFileRequest, opts ...grpc.CallOption) (*SaveTextToTemporalFileResponse, error)
	// Screcorder
	IsScrecorderReady(ctx context.Context, in *IsScrecorderReadyRequest, opts ...grpc.CallOption) (*IsScrecorderReadyResponse, error)
	InstallScrecorder(ctx context.Context, in *InstallScrecorderRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[ExecResult], error)
	StartScrecorder(ctx context.Context, in *StartScrecorderRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[ExecResult], error)
	QueryScreenRecorders(ctx context.Context, in *QueryScreenRecorderRequest, opts ...grpc.CallOption) (*QueryScreenRecorderResponse, error)
	DeleteScreenRecorders(ctx context.Context, in *QueryScreenRecorderRequest, opts ...grpc.CallOption) (*Empty, error)
	UploadScreenRecorders(ctx context.Context, in *UploadScreenRecorderRequest, opts ...grpc.CallOption) (*Empty, error)
	GetOneScreenRecorders(ctx context.Context, in *GetOneScreenRecorderRequest, opts ...grpc.CallOption) (*ScreenRecorder, error)
	UpdateScreenRecorders(ctx context.Context, in *UpdateScreenRecorderRequest, opts ...grpc.CallOption) (*Empty, error)
	// Vulinbox
	IsVulinboxReady(ctx context.Context, in *IsVulinboxReadyRequest, opts ...grpc.CallOption) (*IsVulinboxReadyResponse, error)
	InstallVulinbox(ctx context.Context, in *InstallVulinboxRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[ExecResult], error)
	StartVulinbox(ctx context.Context, in *StartVulinboxRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[ExecResult], error)
	GenQualityInspectionReport(ctx context.Context, in *GenQualityInspectionReportRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[ExecResult], error)
	// 通过他可以构造一个 HTTP 请求
	// 这个请求可能是一个，也可能是一系列
	// 一般用来调试插件等
	HTTPRequestBuilder(ctx context.Context, in *HTTPRequestBuilderParams, opts ...grpc.CallOption) (*HTTPRequestBuilderResponse, error)
	// rpc QueryHTTPRequestBuilder(QueryHTTPRequestBuilderRequest) returns (QueryHTTPRequestBuilderResponse);
	// rpc DeleteHTTPRequestBuilder(DeleteHTTPRequestBuilderRequest) returns (Empty);
	DebugPlugin(ctx context.Context, in *DebugPluginRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[ExecResult], error)
	SmokingEvaluatePlugin(ctx context.Context, in *SmokingEvaluatePluginRequest, opts ...grpc.CallOption) (*SmokingEvaluatePluginResponse, error)
	SmokingEvaluatePluginBatch(ctx context.Context, in *SmokingEvaluatePluginBatchRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[SmokingEvaluatePluginBatchResponse], error)
	GetSystemDefaultDnsServers(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*DefaultDnsServerResponse, error)
	// 诊断网络发生的问题
	DiagnoseNetwork(ctx context.Context, in *DiagnoseNetworkRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[DiagnoseNetworkResponse], error)
	DiagnoseNetworkDNS(ctx context.Context, in *DiagnoseNetworkDNSRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[DiagnoseNetworkResponse], error)
	TraceRoute(ctx context.Context, in *TraceRouteRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[TraceRouteResponse], error)
	// Global Network Config
	GetGlobalNetworkConfig(ctx context.Context, in *GetGlobalNetworkConfigRequest, opts ...grpc.CallOption) (*GlobalNetworkConfig, error)
	SetGlobalNetworkConfig(ctx context.Context, in *GlobalNetworkConfig, opts ...grpc.CallOption) (*Empty, error)
	ResetGlobalNetworkConfig(ctx context.Context, in *ResetGlobalNetworkConfigRequest, opts ...grpc.CallOption) (*Empty, error)
	ValidP12PassWord(ctx context.Context, in *ValidP12PassWordRequest, opts ...grpc.CallOption) (*ValidP12PassWordResponse, error)
	// YAKURL
	RequestYakURL(ctx context.Context, in *RequestYakURLParams, opts ...grpc.CallOption) (*RequestYakURLResponse, error)
	// 文件IO
	ReadFile(ctx context.Context, in *ReadFileRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[ReadFileResponse], error)
	// Wireshark
	GetPcapMetadata(ctx context.Context, in *PcapMetadataRequest, opts ...grpc.CallOption) (*PcapMetadata, error)
	PcapX(ctx context.Context, opts ...grpc.CallOption) (grpc.BidiStreamingClient[PcapXRequest, PcapXResponse], error)
	QueryTrafficSession(ctx context.Context, in *QueryTrafficSessionRequest, opts ...grpc.CallOption) (*QueryTrafficSessionResponse, error)
	QueryTrafficPacket(ctx context.Context, in *QueryTrafficPacketRequest, opts ...grpc.CallOption) (*QueryTrafficPacketResponse, error)
	QueryTrafficTCPReassembled(ctx context.Context, in *QueryTrafficTCPReassembledRequest, opts ...grpc.CallOption) (*QueryTrafficTCPReassembledResponse, error)
	ParseTraffic(ctx context.Context, in *ParseTrafficRequest, opts ...grpc.CallOption) (*ParseTrafficResponse, error)
	// 与前端交互的双工长连接，用于通知某些消息
	DuplexConnection(ctx context.Context, opts ...grpc.CallOption) (grpc.BidiStreamingClient[DuplexConnectionRequest, DuplexConnectionResponse], error)
	// 混合批量扫描
	HybridScan(ctx context.Context, opts ...grpc.CallOption) (grpc.BidiStreamingClient[HybridScanRequest, HybridScanResponse], error)
	QueryHybridScanTask(ctx context.Context, in *QueryHybridScanTaskRequest, opts ...grpc.CallOption) (*QueryHybridScanTaskResponse, error)
	DeleteHybridScanTask(ctx context.Context, in *DeleteHybridScanTaskRequest, opts ...grpc.CallOption) (*Empty, error)
	GetSpaceEngineStatus(ctx context.Context, in *GetSpaceEngineStatusRequest, opts ...grpc.CallOption) (*SpaceEngineStatus, error)
	// 由于第三方应用配置改为从后端动态的获取表单字段名，所以弃用此接口改用GetSpaceEngineAccountStatusV2
	GetSpaceEngineAccountStatus(ctx context.Context, in *GetSpaceEngineAccountStatusRequest, opts ...grpc.CallOption) (*SpaceEngineStatus, error)
	GetSpaceEngineAccountStatusV2(ctx context.Context, in *ThirdPartyApplicationConfig, opts ...grpc.CallOption) (*SpaceEngineStatus, error)
	FetchPortAssetFromSpaceEngine(ctx context.Context, in *FetchPortAssetFromSpaceEngineRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[ExecResult], error)
	// 表达式执行
	EvaluateExpression(ctx context.Context, in *EvaluateExpressionRequest, opts ...grpc.CallOption) (*EvaluateExpressionResponse, error)
	EvaluateMultiExpression(ctx context.Context, in *EvaluateMultiExpressionRequest, opts ...grpc.CallOption) (*EvaluateMultiExpressionResponse, error)
	// 第三方应用配置模板
	GetThirdPartyAppConfigTemplate(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*GetThirdPartyAppConfigTemplateResponse, error)
	// AI相关
	CheckHahValidAiConfig(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*GeneralResponse, error)
	ListAiModel(ctx context.Context, in *ListAiModelRequest, opts ...grpc.CallOption) (*ListAiModelResponse, error)
	// 指纹库
	GetFingerprint(ctx context.Context, in *GetFingerprintRequest, opts ...grpc.CallOption) (*GetFingerprintResponse, error)
	AddFingerprint(ctx context.Context, in *AddFingerprintRequest, opts ...grpc.CallOption) (*AddFingerprintResponse, error)
	ModifyFingerprint(ctx context.Context, in *ModifyFingerprintRequest, opts ...grpc.CallOption) (*ModifyFingerprintResponse, error)
	QueryFingerprint(ctx context.Context, in *QueryFingerprintRequest, opts ...grpc.CallOption) (*QueryFingerprintResponse, error)
	DeleteFingerprint(ctx context.Context, in *DeleteFingerprintRequest, opts ...grpc.CallOption) (*DbOperateMessage, error)
	UpdateFingerprint(ctx context.Context, in *UpdateFingerprintRequest, opts ...grpc.CallOption) (*DbOperateMessage, error)
	CreateFingerprint(ctx context.Context, in *CreateFingerprintRequest, opts ...grpc.CallOption) (*DbOperateMessage, error)
	RecoverBuiltinFingerprint(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*DbOperateMessage, error)
	CreateFingerprintGroup(ctx context.Context, in *FingerprintGroup, opts ...grpc.CallOption) (*DbOperateMessage, error)
	GetAllFingerprintGroup(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*FingerprintGroups, error)
	RenameFingerprintGroup(ctx context.Context, in *RenameFingerprintGroupRequest, opts ...grpc.CallOption) (*DbOperateMessage, error)
	DeleteFingerprintGroup(ctx context.Context, in *DeleteFingerprintGroupRequest, opts ...grpc.CallOption) (*DbOperateMessage, error)
	// 指纹 与 组 工具接口
	BatchUpdateFingerprintToGroup(ctx context.Context, in *BatchUpdateFingerprintToGroupRequest, opts ...grpc.CallOption) (*DbOperateMessage, error)
	GetFingerprintGroupSetByFilter(ctx context.Context, in *GetFingerprintGroupSetRequest, opts ...grpc.CallOption) (*FingerprintGroups, error)
	// 导入导出指纹
	ExportFingerprint(ctx context.Context, in *ExportFingerprintRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[DataTransferProgress], error)
	ImportFingerprint(ctx context.Context, in *ImportFingerprintRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[DataTransferProgress], error)
	// 反弹shell命令生成
	GetReverseShellProgramList(ctx context.Context, in *GetReverseShellProgramListRequest, opts ...grpc.CallOption) (*GetReverseShellProgramListResponse, error)
	GenerateReverseShellCommand(ctx context.Context, in *GenerateReverseShellCommandRequest, opts ...grpc.CallOption) (*GenerateReverseShellCommandResponse, error)
	// SyntaxFlow Rule
	QuerySyntaxFlowRule(ctx context.Context, in *QuerySyntaxFlowRuleRequest, opts ...grpc.CallOption) (*QuerySyntaxFlowRuleResponse, error)
	CreateSyntaxFlowRule(ctx context.Context, in *CreateSyntaxFlowRuleRequest, opts ...grpc.CallOption) (*DbOperateMessage, error)
	CreateSyntaxFlowRuleEx(ctx context.Context, in *CreateSyntaxFlowRuleRequest, opts ...grpc.CallOption) (*CreateSyntaxFlowRuleResponse, error)
	UpdateSyntaxFlowRule(ctx context.Context, in *UpdateSyntaxFlowRuleRequest, opts ...grpc.CallOption) (*DbOperateMessage, error)
	UpdateSyntaxFlowRuleEx(ctx context.Context, in *UpdateSyntaxFlowRuleRequest, opts ...grpc.CallOption) (*UpdateSyntaxFlowRuleResponse, error)
	DeleteSyntaxFlowRule(ctx context.Context, in *DeleteSyntaxFlowRuleRequest, opts ...grpc.CallOption) (*DbOperateMessage, error)
	CheckSyntaxFlowRuleUpdate(ctx context.Context, in *CheckSyntaxFlowRuleUpdateRequest, opts ...grpc.CallOption) (*CheckSyntaxFlowRuleUpdateResponse, error)
	ApplySyntaxFlowRuleUpdate(ctx context.Context, in *ApplySyntaxFlowRuleUpdateRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[ApplySyntaxFlowRuleUpdateResponse], error)
	// SyntaxFlow Group
	QuerySyntaxFlowRuleGroup(ctx context.Context, in *QuerySyntaxFlowRuleGroupRequest, opts ...grpc.CallOption) (*QuerySyntaxFlowRuleGroupResponse, error)
	DeleteSyntaxFlowRuleGroup(ctx context.Context, in *DeleteSyntaxFlowRuleGroupRequest, opts ...grpc.CallOption) (*DbOperateMessage, error)
	CreateSyntaxFlowRuleGroup(ctx context.Context, in *CreateSyntaxFlowGroupRequest, opts ...grpc.CallOption) (*DbOperateMessage, error)
	UpdateSyntaxFlowRuleGroup(ctx context.Context, in *UpdateSyntaxFlowRuleGroupRequest, opts ...grpc.CallOption) (*DbOperateMessage, error)
	UpdateSyntaxFlowRuleAndGroup(ctx context.Context, in *UpdateSyntaxFlowRuleAndGroupRequest, opts ...grpc.CallOption) (*DbOperateMessage, error)
	// 查找多个规则的交集组，一个规则则为其组本身
	QuerySyntaxFlowSameGroup(ctx context.Context, in *QuerySyntaxFlowSameGroupRequest, opts ...grpc.CallOption) (*QuerySyntaxFlowSameGroupResponse, error)
	SyntaxFlowRuleToOnline(ctx context.Context, in *SyntaxFlowRuleToOnlineRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[SyntaxFlowRuleOnlineProgress], error)
	DownloadSyntaxFlowRule(ctx context.Context, in *DownloadSyntaxFlowRuleRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[SyntaxFlowRuleOnlineProgress], error)
	// syntaxflow scan
	SyntaxFlowScan(ctx context.Context, opts ...grpc.CallOption) (grpc.BidiStreamingClient[SyntaxFlowScanRequest, SyntaxFlowScanResponse], error)
	QuerySyntaxFlowScanTask(ctx context.Context, in *QuerySyntaxFlowScanTaskRequest, opts ...grpc.CallOption) (*QuerySyntaxFlowScanTaskResponse, error)
	DeleteSyntaxFlowScanTask(ctx context.Context, in *DeleteSyntaxFlowScanTaskRequest, opts ...grpc.CallOption) (*DbOperateMessage, error)
	// query result
	QuerySyntaxFlowResult(ctx context.Context, in *QuerySyntaxFlowResultRequest, opts ...grpc.CallOption) (*QuerySyntaxFlowResultResponse, error)
	DeleteSyntaxFlowResult(ctx context.Context, in *DeleteSyntaxFlowResultRequest, opts ...grpc.CallOption) (*DeleteSyntaxFlowResultResponse, error)
	// query ssa program
	QuerySSAPrograms(ctx context.Context, in *QuerySSAProgramRequest, opts ...grpc.CallOption) (*QuerySSAProgramResponse, error)
	UpdateSSAProgram(ctx context.Context, in *UpdateSSAProgramRequest, opts ...grpc.CallOption) (*DbOperateMessage, error)
	DeleteSSAPrograms(ctx context.Context, in *DeleteSSAProgramRequest, opts ...grpc.CallOption) (*DbOperateMessage, error)
	// SSA Risk CURD
	QuerySSARisks(ctx context.Context, in *QuerySSARisksRequest, opts ...grpc.CallOption) (*QuerySSARisksResponse, error)
	QueryNewSSARisks(ctx context.Context, in *QueryNewSSARisksRequest, opts ...grpc.CallOption) (*QueryNewSSARisksResponse, error)
	DeleteSSARisks(ctx context.Context, in *DeleteSSARisksRequest, opts ...grpc.CallOption) (*DbOperateMessage, error)
	UpdateSSARiskTags(ctx context.Context, in *UpdateSSARiskTagsRequest, opts ...grpc.CallOption) (*DbOperateMessage, error)
	GetSSARiskFieldGroup(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*SSARiskFieldGroupResponse, error)
	NewSSARiskRead(ctx context.Context, in *NewSSARiskReadRequest, opts ...grpc.CallOption) (*NewSSARiskReadResponse, error)
	SSARiskFeedbackToOnline(ctx context.Context, in *SSARiskFeedbackToOnlineRequest, opts ...grpc.CallOption) (*Empty, error)
	GetAllPluginEnv(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*PluginEnvData, error)
	QueryPluginEnv(ctx context.Context, in *QueryPluginEnvRequest, opts ...grpc.CallOption) (*PluginEnvData, error)
	CreatePluginEnv(ctx context.Context, in *PluginEnvData, opts ...grpc.CallOption) (*Empty, error)
	SetPluginEnv(ctx context.Context, in *PluginEnvData, opts ...grpc.CallOption) (*Empty, error)
	DeletePluginEnv(ctx context.Context, in *DeletePluginEnvRequest, opts ...grpc.CallOption) (*Empty, error)
	GetAllFuzztagInfo(ctx context.Context, in *GetAllFuzztagInfoRequest, opts ...grpc.CallOption) (*GetAllFuzztagInfoResponse, error)
	GenerateFuzztag(ctx context.Context, in *GenerateFuzztagRequest, opts ...grpc.CallOption) (*GenerateFuzztagResponse, error)
	// 导入导出SyntaxFlow规则
	ExportSyntaxFlows(ctx context.Context, in *ExportSyntaxFlowsRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[SyntaxflowsProgress], error)
	ImportSyntaxFlows(ctx context.Context, in *ImportSyntaxFlowsRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[SyntaxflowsProgress], error)
	// hot-patch template
	CreateHotPatchTemplate(ctx context.Context, in *HotPatchTemplate, opts ...grpc.CallOption) (*CreateHotPatchTemplateResponse, error)
	DeleteHotPatchTemplate(ctx context.Context, in *DeleteHotPatchTemplateRequest, opts ...grpc.CallOption) (*DeleteHotPatchTemplateResponse, error)
	UpdateHotPatchTemplate(ctx context.Context, in *UpdateHotPatchTemplateRequest, opts ...grpc.CallOption) (*UpdateHotPatchTemplateResponse, error)
	QueryHotPatchTemplate(ctx context.Context, in *HotPatchTemplateRequest, opts ...grpc.CallOption) (*QueryHotPatchTemplateResponse, error)
	QueryHotPatchTemplateList(ctx context.Context, in *QueryHotPatchTemplateListRequest, opts ...grpc.CallOption) (*QueryHotPatchTemplateListResponse, error)
	// db common rpc
	GroupTableColumn(ctx context.Context, in *GroupTableColumnRequest, opts ...grpc.CallOption) (*GroupTableColumnResponse, error)
	UploadHotPatchTemplateToOnline(ctx context.Context, in *UploadHotPatchTemplateToOnlineRequest, opts ...grpc.CallOption) (*Empty, error)
	DownloadHotPatchTemplate(ctx context.Context, in *DownloadHotPatchTemplateRequest, opts ...grpc.CallOption) (*Empty, error)
	// MITM hijack filter
	SetMITMHijackFilter(ctx context.Context, in *SetMITMFilterRequest, opts ...grpc.CallOption) (*SetMITMFilterResponse, error)
	GetMITMHijackFilter(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*SetMITMFilterRequest, error)
	ResetMITMHijackFilter(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*SetMITMFilterRequest, error)
	// HTTPFlow
	ExportHTTPFlowStream(ctx context.Context, in *ExportHTTPFlowStreamRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[ExportHTTPFlowStreamResponse], error)
	ImportHTTPFlowStream(ctx context.Context, in *ImportHTTPFlowStreamRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[ImportHTTPFlowStreamResponse], error)
	// Note
	CreateNote(ctx context.Context, in *CreateNoteRequest, opts ...grpc.CallOption) (*CreateNoteResponse, error)
	UpdateNote(ctx context.Context, in *UpdateNoteRequest, opts ...grpc.CallOption) (*DbOperateMessage, error)
	DeleteNote(ctx context.Context, in *DeleteNoteRequest, opts ...grpc.CallOption) (*DbOperateMessage, error)
	QueryNote(ctx context.Context, in *QueryNoteRequest, opts ...grpc.CallOption) (*QueryNoteResponse, error)
	SearchNoteContent(ctx context.Context, in *SearchNoteContentRequest, opts ...grpc.CallOption) (*SearchNoteContentResponse, error)
	ImportNote(ctx context.Context, in *ImportNoteRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[ImportNoteResponse], error)
	ExportNote(ctx context.Context, in *ExportNoteRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[ExportNoteResponse], error)
	// AI Task
	StartAITask(ctx context.Context, opts ...grpc.CallOption) (grpc.BidiStreamingClient[AIInputEvent, AIOutputEvent], error)
	QueryAITask(ctx context.Context, in *AITaskQueryRequest, opts ...grpc.CallOption) (*AITaskQueryResponse, error)
	StartAITriage(ctx context.Context, opts ...grpc.CallOption) (grpc.BidiStreamingClient[AITriageInputEvent, AIOutputEvent], error)
	// AI forge curd
	CreateAIForge(ctx context.Context, in *AIForge, opts ...grpc.CallOption) (*DbOperateMessage, error)
	UpdateAIForge(ctx context.Context, in *AIForge, opts ...grpc.CallOption) (*DbOperateMessage, error)
	DeleteAIForge(ctx context.Context, in *AIForgeFilter, opts ...grpc.CallOption) (*DbOperateMessage, error)
	QueryAIForge(ctx context.Context, in *QueryAIForgeRequest, opts ...grpc.CallOption) (*QueryAIForgeResponse, error)
	// mcp server
	StartMcpServer(ctx context.Context, in *StartMcpServerRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[StartMcpServerResponse], error)
	GetToolSetList(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*GetToolSetListResponse, error)
	GetAIToolList(ctx context.Context, in *GetAIToolListRequest, opts ...grpc.CallOption) (*GetAIToolListResponse, error)
	DeleteAITool(ctx context.Context, in *DeleteAIToolRequest, opts ...grpc.CallOption) (*DbOperateMessage, error)
	SaveAITool(ctx context.Context, in *SaveAIToolRequest, opts ...grpc.CallOption) (*DbOperateMessage, error)
	ToggleAIToolFavorite(ctx context.Context, in *ToggleAIToolFavoriteRequest, opts ...grpc.CallOption) (*ToggleAIToolFavoriteResponse, error)
	AIToolGenerateMetadata(ctx context.Context, in *AIToolGenerateMetadataRequest, opts ...grpc.CallOption) (*AIToolGenerateMetadataResponse, error)
}

type yakClient struct {
	cc grpc.ClientConnInterface
}

func NewYakClient(cc grpc.ClientConnInterface) YakClient {
	return &yakClient{cc}
}

func (c *yakClient) Version(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*VersionResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(VersionResponse)
	err := c.cc.Invoke(ctx, Yak_Version_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) YakVersionAtLeast(ctx context.Context, in *YakVersionAtLeastRequest, opts ...grpc.CallOption) (*GeneralResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GeneralResponse)
	err := c.cc.Invoke(ctx, Yak_YakVersionAtLeast_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) Echo(ctx context.Context, in *EchoRequest, opts ...grpc.CallOption) (*EchoResposne, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(EchoResposne)
	err := c.cc.Invoke(ctx, Yak_Echo_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) Handshake(ctx context.Context, in *HandshakeRequest, opts ...grpc.CallOption) (*HandshakeResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(HandshakeResponse)
	err := c.cc.Invoke(ctx, Yak_Handshake_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) VerifySystemCertificate(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*VerifySystemCertificateResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(VerifySystemCertificateResponse)
	err := c.cc.Invoke(ctx, Yak_VerifySystemCertificate_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) MITM(ctx context.Context, opts ...grpc.CallOption) (grpc.BidiStreamingClient[MITMRequest, MITMResponse], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &Yak_ServiceDesc.Streams[0], Yak_MITM_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[MITMRequest, MITMResponse]{ClientStream: stream}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Yak_MITMClient = grpc.BidiStreamingClient[MITMRequest, MITMResponse]

func (c *yakClient) SetMITMFilter(ctx context.Context, in *SetMITMFilterRequest, opts ...grpc.CallOption) (*SetMITMFilterResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SetMITMFilterResponse)
	err := c.cc.Invoke(ctx, Yak_SetMITMFilter_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) GetMITMFilter(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*SetMITMFilterRequest, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SetMITMFilterRequest)
	err := c.cc.Invoke(ctx, Yak_GetMITMFilter_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) ResetMITMFilter(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*SetMITMFilterRequest, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SetMITMFilterRequest)
	err := c.cc.Invoke(ctx, Yak_ResetMITMFilter_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) DownloadMITMCert(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*MITMCert, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(MITMCert)
	err := c.cc.Invoke(ctx, Yak_DownloadMITMCert_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) MITMV2(ctx context.Context, opts ...grpc.CallOption) (grpc.BidiStreamingClient[MITMV2Request, MITMV2Response], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &Yak_ServiceDesc.Streams[1], Yak_MITMV2_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[MITMV2Request, MITMV2Response]{ClientStream: stream}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Yak_MITMV2Client = grpc.BidiStreamingClient[MITMV2Request, MITMV2Response]

func (c *yakClient) OpenPort(ctx context.Context, opts ...grpc.CallOption) (grpc.BidiStreamingClient[Input, Output], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &Yak_ServiceDesc.Streams[2], Yak_OpenPort_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[Input, Output]{ClientStream: stream}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Yak_OpenPortClient = grpc.BidiStreamingClient[Input, Output]

func (c *yakClient) Exec(ctx context.Context, in *ExecRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[ExecResult], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &Yak_ServiceDesc.Streams[3], Yak_Exec_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[ExecRequest, ExecResult]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Yak_ExecClient = grpc.ServerStreamingClient[ExecResult]

func (c *yakClient) QueryExecHistory(ctx context.Context, in *ExecHistoryRequest, opts ...grpc.CallOption) (*ExecHistoryRecordResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ExecHistoryRecordResponse)
	err := c.cc.Invoke(ctx, Yak_QueryExecHistory_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) RemoveExecHistory(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, Yak_RemoveExecHistory_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) LoadNucleiTemplates(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, Yak_LoadNucleiTemplates_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) AutoUpdateYakModule(ctx context.Context, in *Empty, opts ...grpc.CallOption) (grpc.ServerStreamingClient[ExecResult], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &Yak_ServiceDesc.Streams[4], Yak_AutoUpdateYakModule_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[Empty, ExecResult]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Yak_AutoUpdateYakModuleClient = grpc.ServerStreamingClient[ExecResult]

func (c *yakClient) ExecYakScript(ctx context.Context, in *ExecRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[ExecResult], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &Yak_ServiceDesc.Streams[5], Yak_ExecYakScript_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[ExecRequest, ExecResult]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Yak_ExecYakScriptClient = grpc.ServerStreamingClient[ExecResult]

func (c *yakClient) ExecBatchYakScript(ctx context.Context, in *ExecBatchYakScriptRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[ExecBatchYakScriptResult], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &Yak_ServiceDesc.Streams[6], Yak_ExecBatchYakScript_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[ExecBatchYakScriptRequest, ExecBatchYakScriptResult]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Yak_ExecBatchYakScriptClient = grpc.ServerStreamingClient[ExecBatchYakScriptResult]

func (c *yakClient) GetExecBatchYakScriptUnfinishedTask(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*GetExecBatchYakScriptUnfinishedTaskResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetExecBatchYakScriptUnfinishedTaskResponse)
	err := c.cc.Invoke(ctx, Yak_GetExecBatchYakScriptUnfinishedTask_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) GetExecBatchYakScriptUnfinishedTaskByUid(ctx context.Context, in *GetExecBatchYakScriptUnfinishedTaskByUidRequest, opts ...grpc.CallOption) (*ExecBatchYakScriptRequest, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ExecBatchYakScriptRequest)
	err := c.cc.Invoke(ctx, Yak_GetExecBatchYakScriptUnfinishedTaskByUid_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) PopExecBatchYakScriptUnfinishedTaskByUid(ctx context.Context, in *GetExecBatchYakScriptUnfinishedTaskByUidRequest, opts ...grpc.CallOption) (*ExecBatchYakScriptRequest, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ExecBatchYakScriptRequest)
	err := c.cc.Invoke(ctx, Yak_PopExecBatchYakScriptUnfinishedTaskByUid_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) RecoverExecBatchYakScriptUnfinishedTask(ctx context.Context, in *RecoverExecBatchYakScriptUnfinishedTaskRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[ExecBatchYakScriptResult], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &Yak_ServiceDesc.Streams[7], Yak_RecoverExecBatchYakScriptUnfinishedTask_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[RecoverExecBatchYakScriptUnfinishedTaskRequest, ExecBatchYakScriptResult]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Yak_RecoverExecBatchYakScriptUnfinishedTaskClient = grpc.ServerStreamingClient[ExecBatchYakScriptResult]

func (c *yakClient) QueryYakScript(ctx context.Context, in *QueryYakScriptRequest, opts ...grpc.CallOption) (*QueryYakScriptResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(QueryYakScriptResponse)
	err := c.cc.Invoke(ctx, Yak_QueryYakScript_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) QueryYakScriptByYakScriptName(ctx context.Context, in *QueryYakScriptRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[YakScript], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &Yak_ServiceDesc.Streams[8], Yak_QueryYakScriptByYakScriptName_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[QueryYakScriptRequest, YakScript]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Yak_QueryYakScriptByYakScriptNameClient = grpc.ServerStreamingClient[YakScript]

func (c *yakClient) SaveYakScript(ctx context.Context, in *YakScript, opts ...grpc.CallOption) (*YakScript, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(YakScript)
	err := c.cc.Invoke(ctx, Yak_SaveYakScript_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) DeleteYakScript(ctx context.Context, in *DeleteYakScriptRequest, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, Yak_DeleteYakScript_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) GetYakScriptById(ctx context.Context, in *GetYakScriptByIdRequest, opts ...grpc.CallOption) (*YakScript, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(YakScript)
	err := c.cc.Invoke(ctx, Yak_GetYakScriptById_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) GetYakScriptByName(ctx context.Context, in *GetYakScriptByNameRequest, opts ...grpc.CallOption) (*YakScript, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(YakScript)
	err := c.cc.Invoke(ctx, Yak_GetYakScriptByName_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) GetYakScriptByOnlineID(ctx context.Context, in *GetYakScriptByOnlineIDRequest, opts ...grpc.CallOption) (*YakScript, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(YakScript)
	err := c.cc.Invoke(ctx, Yak_GetYakScriptByOnlineID_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) IgnoreYakScript(ctx context.Context, in *DeleteYakScriptRequest, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, Yak_IgnoreYakScript_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) UnIgnoreYakScript(ctx context.Context, in *DeleteYakScriptRequest, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, Yak_UnIgnoreYakScript_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) ExportYakScript(ctx context.Context, in *ExportYakScriptRequest, opts ...grpc.CallOption) (*ExportYakScriptResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ExportYakScriptResponse)
	err := c.cc.Invoke(ctx, Yak_ExportYakScript_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) ExportYakScriptStream(ctx context.Context, in *ExportYakScriptStreamRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[ExecResult], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &Yak_ServiceDesc.Streams[9], Yak_ExportYakScriptStream_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[ExportYakScriptStreamRequest, ExecResult]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Yak_ExportYakScriptStreamClient = grpc.ServerStreamingClient[ExecResult]

func (c *yakClient) ImportYakScriptStream(ctx context.Context, in *ImportYakScriptStreamRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[ExecResult], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &Yak_ServiceDesc.Streams[10], Yak_ImportYakScriptStream_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[ImportYakScriptStreamRequest, ExecResult]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Yak_ImportYakScriptStreamClient = grpc.ServerStreamingClient[ExecResult]

func (c *yakClient) ExecutePacketYakScript(ctx context.Context, in *ExecutePacketYakScriptParams, opts ...grpc.CallOption) (grpc.ServerStreamingClient[ExecResult], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &Yak_ServiceDesc.Streams[11], Yak_ExecutePacketYakScript_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[ExecutePacketYakScriptParams, ExecResult]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Yak_ExecutePacketYakScriptClient = grpc.ServerStreamingClient[ExecResult]

func (c *yakClient) ExecuteBatchPacketYakScript(ctx context.Context, in *ExecuteBatchPacketYakScriptParams, opts ...grpc.CallOption) (grpc.ServerStreamingClient[ExecBatchYakScriptResult], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &Yak_ServiceDesc.Streams[12], Yak_ExecuteBatchPacketYakScript_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[ExecuteBatchPacketYakScriptParams, ExecBatchYakScriptResult]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Yak_ExecuteBatchPacketYakScriptClient = grpc.ServerStreamingClient[ExecBatchYakScriptResult]

func (c *yakClient) GetYakScriptTags(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*GetYakScriptTagsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetYakScriptTagsResponse)
	err := c.cc.Invoke(ctx, Yak_GetYakScriptTags_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) QueryYakScriptLocalAndUser(ctx context.Context, in *QueryYakScriptLocalAndUserRequest, opts ...grpc.CallOption) (*QueryYakScriptLocalAndUserResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(QueryYakScriptLocalAndUserResponse)
	err := c.cc.Invoke(ctx, Yak_QueryYakScriptLocalAndUser_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) QueryYakScriptByOnlineGroup(ctx context.Context, in *QueryYakScriptByOnlineGroupRequest, opts ...grpc.CallOption) (*QueryYakScriptLocalAndUserResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(QueryYakScriptLocalAndUserResponse)
	err := c.cc.Invoke(ctx, Yak_QueryYakScriptByOnlineGroup_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) QueryYakScriptLocalAll(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*QueryYakScriptLocalAndUserResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(QueryYakScriptLocalAndUserResponse)
	err := c.cc.Invoke(ctx, Yak_QueryYakScriptLocalAll_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) QueryYakScriptByNames(ctx context.Context, in *QueryYakScriptByNamesRequest, opts ...grpc.CallOption) (*QueryYakScriptByNamesResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(QueryYakScriptByNamesResponse)
	err := c.cc.Invoke(ctx, Yak_QueryYakScriptByNames_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) QueryYakScriptByIsCore(ctx context.Context, in *QueryYakScriptByIsCoreRequest, opts ...grpc.CallOption) (*QueryYakScriptByIsCoreResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(QueryYakScriptByIsCoreResponse)
	err := c.cc.Invoke(ctx, Yak_QueryYakScriptByIsCore_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) QueryYakScriptRiskDetailByCWE(ctx context.Context, in *QueryYakScriptRiskDetailByCWERequest, opts ...grpc.CallOption) (*QueryYakScriptRiskDetailByCWEResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(QueryYakScriptRiskDetailByCWEResponse)
	err := c.cc.Invoke(ctx, Yak_QueryYakScriptRiskDetailByCWE_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) YakScriptRiskTypeList(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*YakScriptRiskTypeListResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(YakScriptRiskTypeListResponse)
	err := c.cc.Invoke(ctx, Yak_YakScriptRiskTypeList_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) SaveNewYakScript(ctx context.Context, in *SaveNewYakScriptRequest, opts ...grpc.CallOption) (*YakScript, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(YakScript)
	err := c.cc.Invoke(ctx, Yak_SaveNewYakScript_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) SaveYakScriptToOnline(ctx context.Context, in *SaveYakScriptToOnlineRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[SaveYakScriptToOnlineResponse], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &Yak_ServiceDesc.Streams[13], Yak_SaveYakScriptToOnline_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[SaveYakScriptToOnlineRequest, SaveYakScriptToOnlineResponse]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Yak_SaveYakScriptToOnlineClient = grpc.ServerStreamingClient[SaveYakScriptToOnlineResponse]

func (c *yakClient) ExportLocalYakScript(ctx context.Context, in *ExportLocalYakScriptRequest, opts ...grpc.CallOption) (*ExportLocalYakScriptResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ExportLocalYakScriptResponse)
	err := c.cc.Invoke(ctx, Yak_ExportLocalYakScript_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) ExportLocalYakScriptStream(ctx context.Context, in *ExportLocalYakScriptRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[ExportYakScriptLocalResponse], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &Yak_ServiceDesc.Streams[14], Yak_ExportLocalYakScriptStream_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[ExportLocalYakScriptRequest, ExportYakScriptLocalResponse]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Yak_ExportLocalYakScriptStreamClient = grpc.ServerStreamingClient[ExportYakScriptLocalResponse]

func (c *yakClient) ImportYakScript(ctx context.Context, in *ImportYakScriptRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[ImportYakScriptResult], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &Yak_ServiceDesc.Streams[15], Yak_ImportYakScript_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[ImportYakScriptRequest, ImportYakScriptResult]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Yak_ImportYakScriptClient = grpc.ServerStreamingClient[ImportYakScriptResult]

func (c *yakClient) SetYakScriptSkipUpdate(ctx context.Context, in *SetYakScriptSkipUpdateRequest, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, Yak_SetYakScriptSkipUpdate_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) QueryYakScriptSkipUpdate(ctx context.Context, in *QueryYakScriptRequest, opts ...grpc.CallOption) (*QueryYakScriptSkipUpdateResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(QueryYakScriptSkipUpdateResponse)
	err := c.cc.Invoke(ctx, Yak_QueryYakScriptSkipUpdate_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) QueryYakScriptGroup(ctx context.Context, in *QueryYakScriptGroupRequest, opts ...grpc.CallOption) (*QueryYakScriptGroupResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(QueryYakScriptGroupResponse)
	err := c.cc.Invoke(ctx, Yak_QueryYakScriptGroup_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) SaveYakScriptGroup(ctx context.Context, in *SaveYakScriptGroupRequest, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, Yak_SaveYakScriptGroup_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) RenameYakScriptGroup(ctx context.Context, in *RenameYakScriptGroupRequest, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, Yak_RenameYakScriptGroup_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) DeleteYakScriptGroup(ctx context.Context, in *DeleteYakScriptGroupRequest, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, Yak_DeleteYakScriptGroup_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) GetYakScriptGroup(ctx context.Context, in *QueryYakScriptRequest, opts ...grpc.CallOption) (*GetYakScriptGroupResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetYakScriptGroupResponse)
	err := c.cc.Invoke(ctx, Yak_GetYakScriptGroup_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) ResetYakScriptGroup(ctx context.Context, in *ResetYakScriptGroupRequest, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, Yak_ResetYakScriptGroup_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) SetGroup(ctx context.Context, in *SetGroupRequest, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, Yak_SetGroup_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) GetHTTPFlowByHash(ctx context.Context, in *GetHTTPFlowByHashRequest, opts ...grpc.CallOption) (*HTTPFlow, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(HTTPFlow)
	err := c.cc.Invoke(ctx, Yak_GetHTTPFlowByHash_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) GetHTTPFlowById(ctx context.Context, in *GetHTTPFlowByIdRequest, opts ...grpc.CallOption) (*HTTPFlow, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(HTTPFlow)
	err := c.cc.Invoke(ctx, Yak_GetHTTPFlowById_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) GetHTTPFlowBodyById(ctx context.Context, in *GetHTTPFlowBodyByIdRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[GetHTTPFlowBodyByIdResponse], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &Yak_ServiceDesc.Streams[16], Yak_GetHTTPFlowBodyById_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[GetHTTPFlowBodyByIdRequest, GetHTTPFlowBodyByIdResponse]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Yak_GetHTTPFlowBodyByIdClient = grpc.ServerStreamingClient[GetHTTPFlowBodyByIdResponse]

func (c *yakClient) GetHTTPFlowByIds(ctx context.Context, in *GetHTTPFlowByIdsRequest, opts ...grpc.CallOption) (*HTTPFlows, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(HTTPFlows)
	err := c.cc.Invoke(ctx, Yak_GetHTTPFlowByIds_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) QueryHTTPFlows(ctx context.Context, in *QueryHTTPFlowRequest, opts ...grpc.CallOption) (*QueryHTTPFlowResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(QueryHTTPFlowResponse)
	err := c.cc.Invoke(ctx, Yak_QueryHTTPFlows_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) DeleteHTTPFlows(ctx context.Context, in *DeleteHTTPFlowRequest, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, Yak_DeleteHTTPFlows_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) SetTagForHTTPFlow(ctx context.Context, in *SetTagForHTTPFlowRequest, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, Yak_SetTagForHTTPFlow_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) QueryHTTPFlowsIds(ctx context.Context, in *QueryHTTPFlowsIdsRequest, opts ...grpc.CallOption) (*QueryHTTPFlowsIdsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(QueryHTTPFlowsIdsResponse)
	err := c.cc.Invoke(ctx, Yak_QueryHTTPFlowsIds_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) HTTPFlowsFieldGroup(ctx context.Context, in *HTTPFlowsFieldGroupRequest, opts ...grpc.CallOption) (*HTTPFlowsFieldGroupResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(HTTPFlowsFieldGroupResponse)
	err := c.cc.Invoke(ctx, Yak_HTTPFlowsFieldGroup_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) HTTPFlowsShare(ctx context.Context, in *HTTPFlowsShareRequest, opts ...grpc.CallOption) (*HTTPFlowsShareResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(HTTPFlowsShareResponse)
	err := c.cc.Invoke(ctx, Yak_HTTPFlowsShare_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) HTTPFlowsExtract(ctx context.Context, in *HTTPFlowsExtractRequest, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, Yak_HTTPFlowsExtract_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) GetHTTPFlowBare(ctx context.Context, in *HTTPFlowBareRequest, opts ...grpc.CallOption) (*HTTPFlowBareResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(HTTPFlowBareResponse)
	err := c.cc.Invoke(ctx, Yak_GetHTTPFlowBare_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) ExportHTTPFlows(ctx context.Context, in *ExportHTTPFlowsRequest, opts ...grpc.CallOption) (*QueryHTTPFlowResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(QueryHTTPFlowResponse)
	err := c.cc.Invoke(ctx, Yak_ExportHTTPFlows_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) HTTPFlowsToOnline(ctx context.Context, in *HTTPFlowsToOnlineRequest, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, Yak_HTTPFlowsToOnline_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) QueryHTTPFlowsProcessNames(ctx context.Context, in *QueryHTTPFlowRequest, opts ...grpc.CallOption) (*QueryHTTPFlowsProcessNamesResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(QueryHTTPFlowsProcessNamesResponse)
	err := c.cc.Invoke(ctx, Yak_QueryHTTPFlowsProcessNames_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) AnalyzeHTTPFlow(ctx context.Context, in *AnalyzeHTTPFlowRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[AnalyzeHTTPFlowResponse], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &Yak_ServiceDesc.Streams[17], Yak_AnalyzeHTTPFlow_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[AnalyzeHTTPFlowRequest, AnalyzeHTTPFlowResponse]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Yak_AnalyzeHTTPFlowClient = grpc.ServerStreamingClient[AnalyzeHTTPFlowResponse]

func (c *yakClient) ExtractUrl(ctx context.Context, in *FuzzerRequest, opts ...grpc.CallOption) (*ExtractedUrl, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ExtractedUrl)
	err := c.cc.Invoke(ctx, Yak_ExtractUrl_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) GetHistoryHTTPFuzzerTask(ctx context.Context, in *GetHistoryHTTPFuzzerTaskRequest, opts ...grpc.CallOption) (*HistoryHTTPFuzzerTaskDetail, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(HistoryHTTPFuzzerTaskDetail)
	err := c.cc.Invoke(ctx, Yak_GetHistoryHTTPFuzzerTask_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) QueryHistoryHTTPFuzzerTask(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*HistoryHTTPFuzzerTasks, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(HistoryHTTPFuzzerTasks)
	err := c.cc.Invoke(ctx, Yak_QueryHistoryHTTPFuzzerTask_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) QueryHistoryHTTPFuzzerTaskEx(ctx context.Context, in *QueryHistoryHTTPFuzzerTaskExParams, opts ...grpc.CallOption) (*HistoryHTTPFuzzerTasksResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(HistoryHTTPFuzzerTasksResponse)
	err := c.cc.Invoke(ctx, Yak_QueryHistoryHTTPFuzzerTaskEx_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) DeleteHistoryHTTPFuzzerTask(ctx context.Context, in *DeleteHistoryHTTPFuzzerTaskRequest, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, Yak_DeleteHistoryHTTPFuzzerTask_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) HTTPFuzzer(ctx context.Context, in *FuzzerRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[FuzzerResponse], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &Yak_ServiceDesc.Streams[18], Yak_HTTPFuzzer_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[FuzzerRequest, FuzzerResponse]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Yak_HTTPFuzzerClient = grpc.ServerStreamingClient[FuzzerResponse]

func (c *yakClient) HTTPFuzzerSequence(ctx context.Context, in *FuzzerRequests, opts ...grpc.CallOption) (grpc.ServerStreamingClient[FuzzerSequenceResponse], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &Yak_ServiceDesc.Streams[19], Yak_HTTPFuzzerSequence_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[FuzzerRequests, FuzzerSequenceResponse]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Yak_HTTPFuzzerSequenceClient = grpc.ServerStreamingClient[FuzzerSequenceResponse]

func (c *yakClient) PreloadHTTPFuzzerParams(ctx context.Context, in *PreloadHTTPFuzzerParamsRequest, opts ...grpc.CallOption) (*PreloadHTTPFuzzerParamsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(PreloadHTTPFuzzerParamsResponse)
	err := c.cc.Invoke(ctx, Yak_PreloadHTTPFuzzerParams_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) RenderVariables(ctx context.Context, in *RenderVariablesRequest, opts ...grpc.CallOption) (*RenderVariablesResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RenderVariablesResponse)
	err := c.cc.Invoke(ctx, Yak_RenderVariables_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) MatchHTTPResponse(ctx context.Context, in *MatchHTTPResponseParams, opts ...grpc.CallOption) (*MatchHTTPResponseResult, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(MatchHTTPResponseResult)
	err := c.cc.Invoke(ctx, Yak_MatchHTTPResponse_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) ExtractHTTPResponse(ctx context.Context, in *ExtractHTTPResponseParams, opts ...grpc.CallOption) (*ExtractHTTPResponseResult, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ExtractHTTPResponseResult)
	err := c.cc.Invoke(ctx, Yak_ExtractHTTPResponse_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) RedirectRequest(ctx context.Context, in *RedirectRequestParams, opts ...grpc.CallOption) (*FuzzerResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(FuzzerResponse)
	err := c.cc.Invoke(ctx, Yak_RedirectRequest_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) HTTPRequestMutate(ctx context.Context, in *HTTPRequestMutateParams, opts ...grpc.CallOption) (*MutateResult, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(MutateResult)
	err := c.cc.Invoke(ctx, Yak_HTTPRequestMutate_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) HTTPResponseMutate(ctx context.Context, in *HTTPResponseMutateParams, opts ...grpc.CallOption) (*MutateResult, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(MutateResult)
	err := c.cc.Invoke(ctx, Yak_HTTPResponseMutate_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) FixUploadPacket(ctx context.Context, in *FixUploadPacketRequest, opts ...grpc.CallOption) (*FixUploadPacketResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(FixUploadPacketResponse)
	err := c.cc.Invoke(ctx, Yak_FixUploadPacket_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) IsMultipartFormDataRequest(ctx context.Context, in *FixUploadPacketRequest, opts ...grpc.CallOption) (*IsMultipartFormDataRequestResult, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(IsMultipartFormDataRequestResult)
	err := c.cc.Invoke(ctx, Yak_IsMultipartFormDataRequest_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) GenerateExtractRule(ctx context.Context, in *GenerateExtractRuleRequest, opts ...grpc.CallOption) (*GenerateExtractRuleResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GenerateExtractRuleResponse)
	err := c.cc.Invoke(ctx, Yak_GenerateExtractRule_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) ExtractData(ctx context.Context, opts ...grpc.CallOption) (grpc.BidiStreamingClient[ExtractDataRequest, ExtractDataResponse], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &Yak_ServiceDesc.Streams[20], Yak_ExtractData_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[ExtractDataRequest, ExtractDataResponse]{ClientStream: stream}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Yak_ExtractDataClient = grpc.BidiStreamingClient[ExtractDataRequest, ExtractDataResponse]

func (c *yakClient) ImportHTTPFuzzerTaskFromYaml(ctx context.Context, in *ImportHTTPFuzzerTaskFromYamlRequest, opts ...grpc.CallOption) (*ImportHTTPFuzzerTaskFromYamlResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ImportHTTPFuzzerTaskFromYamlResponse)
	err := c.cc.Invoke(ctx, Yak_ImportHTTPFuzzerTaskFromYaml_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) ExportHTTPFuzzerTaskToYaml(ctx context.Context, in *ExportHTTPFuzzerTaskToYamlRequest, opts ...grpc.CallOption) (*ExportHTTPFuzzerTaskToYamlResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ExportHTTPFuzzerTaskToYamlResponse)
	err := c.cc.Invoke(ctx, Yak_ExportHTTPFuzzerTaskToYaml_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) RenderHTTPFuzzerPacket(ctx context.Context, in *RenderHTTPFuzzerPacketRequest, opts ...grpc.CallOption) (*RenderHTTPFuzzerPacketResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RenderHTTPFuzzerPacketResponse)
	err := c.cc.Invoke(ctx, Yak_RenderHTTPFuzzerPacket_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) SaveFuzzerLabel(ctx context.Context, in *SaveFuzzerLabelRequest, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, Yak_SaveFuzzerLabel_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) QueryFuzzerLabel(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*QueryFuzzerLabelResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(QueryFuzzerLabelResponse)
	err := c.cc.Invoke(ctx, Yak_QueryFuzzerLabel_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) DeleteFuzzerLabel(ctx context.Context, in *DeleteFuzzerLabelRequest, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, Yak_DeleteFuzzerLabel_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) SaveFuzzerConfig(ctx context.Context, in *SaveFuzzerConfigRequest, opts ...grpc.CallOption) (*DbOperateMessage, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DbOperateMessage)
	err := c.cc.Invoke(ctx, Yak_SaveFuzzerConfig_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) QueryFuzzerConfig(ctx context.Context, in *QueryFuzzerConfigRequest, opts ...grpc.CallOption) (*QueryFuzzerConfigResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(QueryFuzzerConfigResponse)
	err := c.cc.Invoke(ctx, Yak_QueryFuzzerConfig_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) DeleteFuzzerConfig(ctx context.Context, in *DeleteFuzzerConfigRequest, opts ...grpc.CallOption) (*DbOperateMessage, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DbOperateMessage)
	err := c.cc.Invoke(ctx, Yak_DeleteFuzzerConfig_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) QueryHTTPFuzzerResponseByTaskId(ctx context.Context, in *QueryHTTPFuzzerResponseByTaskIdRequest, opts ...grpc.CallOption) (*QueryHTTPFuzzerResponseByTaskIdResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(QueryHTTPFuzzerResponseByTaskIdResponse)
	err := c.cc.Invoke(ctx, Yak_QueryHTTPFuzzerResponseByTaskId_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) CreateWebsocketFuzzer(ctx context.Context, opts ...grpc.CallOption) (grpc.BidiStreamingClient[ClientWebsocketRequest, ClientWebsocketResponse], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &Yak_ServiceDesc.Streams[21], Yak_CreateWebsocketFuzzer_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[ClientWebsocketRequest, ClientWebsocketResponse]{ClientStream: stream}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Yak_CreateWebsocketFuzzerClient = grpc.BidiStreamingClient[ClientWebsocketRequest, ClientWebsocketResponse]

func (c *yakClient) QueryWebsocketFlowByHTTPFlowWebsocketHash(ctx context.Context, in *QueryWebsocketFlowByHTTPFlowWebsocketHashRequest, opts ...grpc.CallOption) (*WebsocketFlows, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(WebsocketFlows)
	err := c.cc.Invoke(ctx, Yak_QueryWebsocketFlowByHTTPFlowWebsocketHash_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) DeleteWebsocketFlowByHTTPFlowWebsocketHash(ctx context.Context, in *DeleteWebsocketFlowByHTTPFlowWebsocketHashRequest, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, Yak_DeleteWebsocketFlowByHTTPFlowWebsocketHash_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) DeleteWebsocketFlowAll(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, Yak_DeleteWebsocketFlowAll_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) ConvertFuzzerResponseToHTTPFlow(ctx context.Context, in *FuzzerResponse, opts ...grpc.CallOption) (*HTTPFlow, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(HTTPFlow)
	err := c.cc.Invoke(ctx, Yak_ConvertFuzzerResponseToHTTPFlow_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) StringFuzzer(ctx context.Context, in *StringFuzzerRequest, opts ...grpc.CallOption) (*StringFuzzerResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(StringFuzzerResponse)
	err := c.cc.Invoke(ctx, Yak_StringFuzzer_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) HTTPRequestAnalyzer(ctx context.Context, in *HTTPRequestAnalysisMaterial, opts ...grpc.CallOption) (*HTTPRequestAnalysis, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(HTTPRequestAnalysis)
	err := c.cc.Invoke(ctx, Yak_HTTPRequestAnalyzer_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) Codec(ctx context.Context, in *CodecRequest, opts ...grpc.CallOption) (*CodecResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CodecResponse)
	err := c.cc.Invoke(ctx, Yak_Codec_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) NewCodec(ctx context.Context, in *CodecRequestFlow, opts ...grpc.CallOption) (*CodecResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CodecResponse)
	err := c.cc.Invoke(ctx, Yak_NewCodec_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) GetAllCodecMethods(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*CodecMethods, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CodecMethods)
	err := c.cc.Invoke(ctx, Yak_GetAllCodecMethods_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) SaveCodecFlow(ctx context.Context, in *CustomizeCodecFlow, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, Yak_SaveCodecFlow_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) DeleteCodecFlow(ctx context.Context, in *DeleteCodecFlowRequest, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, Yak_DeleteCodecFlow_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) GetAllCodecFlow(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*GetCodecFlowResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetCodecFlowResponse)
	err := c.cc.Invoke(ctx, Yak_GetAllCodecFlow_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) PacketPrettifyHelper(ctx context.Context, in *PacketPrettifyHelperRequest, opts ...grpc.CallOption) (*PacketPrettifyHelperResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(PacketPrettifyHelperResponse)
	err := c.cc.Invoke(ctx, Yak_PacketPrettifyHelper_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) QueryPayload(ctx context.Context, in *QueryPayloadRequest, opts ...grpc.CallOption) (*QueryPayloadResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(QueryPayloadResponse)
	err := c.cc.Invoke(ctx, Yak_QueryPayload_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) QueryPayloadFromFile(ctx context.Context, in *QueryPayloadFromFileRequest, opts ...grpc.CallOption) (*QueryPayloadFromFileResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(QueryPayloadFromFileResponse)
	err := c.cc.Invoke(ctx, Yak_QueryPayloadFromFile_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) DeletePayloadByFolder(ctx context.Context, in *NameRequest, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, Yak_DeletePayloadByFolder_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) DeletePayloadByGroup(ctx context.Context, in *DeletePayloadByGroupRequest, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, Yak_DeletePayloadByGroup_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) DeletePayload(ctx context.Context, in *DeletePayloadRequest, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, Yak_DeletePayload_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) SavePayload(ctx context.Context, in *SavePayloadRequest, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, Yak_SavePayload_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) SavePayloadStream(ctx context.Context, in *SavePayloadRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[SavePayloadProgress], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &Yak_ServiceDesc.Streams[22], Yak_SavePayloadStream_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[SavePayloadRequest, SavePayloadProgress]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Yak_SavePayloadStreamClient = grpc.ServerStreamingClient[SavePayloadProgress]

func (c *yakClient) SavePayloadToFileStream(ctx context.Context, in *SavePayloadRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[SavePayloadProgress], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &Yak_ServiceDesc.Streams[23], Yak_SavePayloadToFileStream_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[SavePayloadRequest, SavePayloadProgress]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Yak_SavePayloadToFileStreamClient = grpc.ServerStreamingClient[SavePayloadProgress]

func (c *yakClient) SaveLargePayloadToFileStream(ctx context.Context, in *SavePayloadRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[SavePayloadProgress], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &Yak_ServiceDesc.Streams[24], Yak_SaveLargePayloadToFileStream_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[SavePayloadRequest, SavePayloadProgress]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Yak_SaveLargePayloadToFileStreamClient = grpc.ServerStreamingClient[SavePayloadProgress]

func (c *yakClient) RenamePayloadFolder(ctx context.Context, in *RenameRequest, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, Yak_RenamePayloadFolder_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) RenamePayloadGroup(ctx context.Context, in *RenameRequest, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, Yak_RenamePayloadGroup_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) UpdatePayload(ctx context.Context, in *UpdatePayloadRequest, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, Yak_UpdatePayload_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) UpdatePayloadToFile(ctx context.Context, in *UpdatePayloadToFileRequest, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, Yak_UpdatePayloadToFile_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) BackUpOrCopyPayloads(ctx context.Context, in *BackUpOrCopyPayloadsRequest, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, Yak_BackUpOrCopyPayloads_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) GetAllPayloadGroup(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*GetAllPayloadGroupResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetAllPayloadGroupResponse)
	err := c.cc.Invoke(ctx, Yak_GetAllPayloadGroup_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) UpdateAllPayloadGroup(ctx context.Context, in *UpdateAllPayloadGroupRequest, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, Yak_UpdateAllPayloadGroup_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) GetAllPayload(ctx context.Context, in *GetAllPayloadRequest, opts ...grpc.CallOption) (*GetAllPayloadResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetAllPayloadResponse)
	err := c.cc.Invoke(ctx, Yak_GetAllPayload_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) GetAllPayloadFromFile(ctx context.Context, in *GetAllPayloadRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[GetAllPayloadFromFileResponse], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &Yak_ServiceDesc.Streams[25], Yak_GetAllPayloadFromFile_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[GetAllPayloadRequest, GetAllPayloadFromFileResponse]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Yak_GetAllPayloadFromFileClient = grpc.ServerStreamingClient[GetAllPayloadFromFileResponse]

func (c *yakClient) ExportAllPayload(ctx context.Context, in *GetAllPayloadRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[GetAllPayloadResponse], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &Yak_ServiceDesc.Streams[26], Yak_ExportAllPayload_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[GetAllPayloadRequest, GetAllPayloadResponse]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Yak_ExportAllPayloadClient = grpc.ServerStreamingClient[GetAllPayloadResponse]

func (c *yakClient) ExportAllPayloadFromFile(ctx context.Context, in *GetAllPayloadRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[GetAllPayloadResponse], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &Yak_ServiceDesc.Streams[27], Yak_ExportAllPayloadFromFile_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[GetAllPayloadRequest, GetAllPayloadResponse]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Yak_ExportAllPayloadFromFileClient = grpc.ServerStreamingClient[GetAllPayloadResponse]

func (c *yakClient) CreatePayloadFolder(ctx context.Context, in *NameRequest, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, Yak_CreatePayloadFolder_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) RemoveDuplicatePayloads(ctx context.Context, in *NameRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[SavePayloadProgress], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &Yak_ServiceDesc.Streams[28], Yak_RemoveDuplicatePayloads_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[NameRequest, SavePayloadProgress]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Yak_RemoveDuplicatePayloadsClient = grpc.ServerStreamingClient[SavePayloadProgress]

func (c *yakClient) CoverPayloadGroupToDatabase(ctx context.Context, in *NameRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[SavePayloadProgress], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &Yak_ServiceDesc.Streams[29], Yak_CoverPayloadGroupToDatabase_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[NameRequest, SavePayloadProgress]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Yak_CoverPayloadGroupToDatabaseClient = grpc.ServerStreamingClient[SavePayloadProgress]

func (c *yakClient) ConvertPayloadGroupToDatabase(ctx context.Context, in *NameRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[SavePayloadProgress], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &Yak_ServiceDesc.Streams[30], Yak_ConvertPayloadGroupToDatabase_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[NameRequest, SavePayloadProgress]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Yak_ConvertPayloadGroupToDatabaseClient = grpc.ServerStreamingClient[SavePayloadProgress]

func (c *yakClient) MigratePayloads(ctx context.Context, in *Empty, opts ...grpc.CallOption) (grpc.ServerStreamingClient[SavePayloadProgress], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &Yak_ServiceDesc.Streams[31], Yak_MigratePayloads_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[Empty, SavePayloadProgress]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Yak_MigratePayloadsClient = grpc.ServerStreamingClient[SavePayloadProgress]

func (c *yakClient) GetYakitCompletionRaw(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*YakitCompletionRawResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(YakitCompletionRawResponse)
	err := c.cc.Invoke(ctx, Yak_GetYakitCompletionRaw_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) GetYakVMBuildInMethodCompletion(ctx context.Context, in *GetYakVMBuildInMethodCompletionRequest, opts ...grpc.CallOption) (*GetYakVMBuildInMethodCompletionResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetYakVMBuildInMethodCompletionResponse)
	err := c.cc.Invoke(ctx, Yak_GetYakVMBuildInMethodCompletion_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) StaticAnalyzeError(ctx context.Context, in *StaticAnalyzeErrorRequest, opts ...grpc.CallOption) (*StaticAnalyzeErrorResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(StaticAnalyzeErrorResponse)
	err := c.cc.Invoke(ctx, Yak_StaticAnalyzeError_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) YaklangCompileAndFormat(ctx context.Context, in *YaklangCompileAndFormatRequest, opts ...grpc.CallOption) (*YaklangCompileAndFormatResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(YaklangCompileAndFormatResponse)
	err := c.cc.Invoke(ctx, Yak_YaklangCompileAndFormat_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) YaklangLanguageSuggestion(ctx context.Context, in *YaklangLanguageSuggestionRequest, opts ...grpc.CallOption) (*YaklangLanguageSuggestionResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(YaklangLanguageSuggestionResponse)
	err := c.cc.Invoke(ctx, Yak_YaklangLanguageSuggestion_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) YaklangLanguageFind(ctx context.Context, in *YaklangLanguageSuggestionRequest, opts ...grpc.CallOption) (*YaklangLanguageFindResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(YaklangLanguageFindResponse)
	err := c.cc.Invoke(ctx, Yak_YaklangLanguageFind_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) FuzzTagSuggestion(ctx context.Context, in *FuzzTagSuggestionRequest, opts ...grpc.CallOption) (*YaklangLanguageSuggestionResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(YaklangLanguageSuggestionResponse)
	err := c.cc.Invoke(ctx, Yak_FuzzTagSuggestion_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) YaklangInspectInformation(ctx context.Context, in *YaklangInspectInformationRequest, opts ...grpc.CallOption) (*YaklangInspectInformationResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(YaklangInspectInformationResponse)
	err := c.cc.Invoke(ctx, Yak_YaklangInspectInformation_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) YaklangGetCliCodeFromDatabase(ctx context.Context, in *YaklangGetCliCodeFromDatabaseRequest, opts ...grpc.CallOption) (*YaklangGetCliCodeFromDatabaseResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(YaklangGetCliCodeFromDatabaseResponse)
	err := c.cc.Invoke(ctx, Yak_YaklangGetCliCodeFromDatabase_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) YaklangTerminal(ctx context.Context, opts ...grpc.CallOption) (grpc.BidiStreamingClient[Input, Output], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &Yak_ServiceDesc.Streams[32], Yak_YaklangTerminal_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[Input, Output]{ClientStream: stream}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Yak_YaklangTerminalClient = grpc.BidiStreamingClient[Input, Output]

func (c *yakClient) PortScan(ctx context.Context, in *PortScanRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[ExecResult], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &Yak_ServiceDesc.Streams[33], Yak_PortScan_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[PortScanRequest, ExecResult]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Yak_PortScanClient = grpc.ServerStreamingClient[ExecResult]

func (c *yakClient) ViewPortScanCode(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*SimpleScript, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SimpleScript)
	err := c.cc.Invoke(ctx, Yak_ViewPortScanCode_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) SimpleDetect(ctx context.Context, in *RecordPortScanRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[ExecResult], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &Yak_ServiceDesc.Streams[34], Yak_SimpleDetect_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[RecordPortScanRequest, ExecResult]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Yak_SimpleDetectClient = grpc.ServerStreamingClient[ExecResult]

func (c *yakClient) SaveCancelSimpleDetect(ctx context.Context, in *RecordPortScanRequest, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, Yak_SaveCancelSimpleDetect_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) SimpleDetectCreatReport(ctx context.Context, in *CreatReportRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[ExecResult], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &Yak_ServiceDesc.Streams[35], Yak_SimpleDetectCreatReport_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[CreatReportRequest, ExecResult]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Yak_SimpleDetectCreatReportClient = grpc.ServerStreamingClient[ExecResult]

func (c *yakClient) QuerySimpleDetectUnfinishedTask(ctx context.Context, in *QueryUnfinishedTaskRequest, opts ...grpc.CallOption) (*QueryUnfinishedTaskResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(QueryUnfinishedTaskResponse)
	err := c.cc.Invoke(ctx, Yak_QuerySimpleDetectUnfinishedTask_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) GetSimpleDetectRecordRequestById(ctx context.Context, in *GetUnfinishedTaskDetailByIdRequest, opts ...grpc.CallOption) (*RecordPortScanRequest, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RecordPortScanRequest)
	err := c.cc.Invoke(ctx, Yak_GetSimpleDetectRecordRequestById_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) DeleteSimpleDetectUnfinishedTask(ctx context.Context, in *DeleteUnfinishedTaskRequest, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, Yak_DeleteSimpleDetectUnfinishedTask_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) RecoverSimpleDetectTask(ctx context.Context, in *RecoverUnfinishedTaskRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[ExecResult], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &Yak_ServiceDesc.Streams[36], Yak_RecoverSimpleDetectTask_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[RecoverUnfinishedTaskRequest, ExecResult]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Yak_RecoverSimpleDetectTaskClient = grpc.ServerStreamingClient[ExecResult]

func (c *yakClient) GetSimpleDetectUnfinishedTask(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*GetSimpleDetectUnfinishedTaskResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetSimpleDetectUnfinishedTaskResponse)
	err := c.cc.Invoke(ctx, Yak_GetSimpleDetectUnfinishedTask_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) GetSimpleDetectUnfinishedTaskByUid(ctx context.Context, in *GetExecBatchYakScriptUnfinishedTaskByUidRequest, opts ...grpc.CallOption) (*RecordPortScanRequest, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RecordPortScanRequest)
	err := c.cc.Invoke(ctx, Yak_GetSimpleDetectUnfinishedTaskByUid_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) PopSimpleDetectUnfinishedTaskByUid(ctx context.Context, in *GetExecBatchYakScriptUnfinishedTaskByUidRequest, opts ...grpc.CallOption) (*RecordPortScanRequest, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RecordPortScanRequest)
	err := c.cc.Invoke(ctx, Yak_PopSimpleDetectUnfinishedTaskByUid_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) RecoverSimpleDetectUnfinishedTask(ctx context.Context, in *RecoverExecBatchYakScriptUnfinishedTaskRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[ExecResult], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &Yak_ServiceDesc.Streams[37], Yak_RecoverSimpleDetectUnfinishedTask_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[RecoverExecBatchYakScriptUnfinishedTaskRequest, ExecResult]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Yak_RecoverSimpleDetectUnfinishedTaskClient = grpc.ServerStreamingClient[ExecResult]

func (c *yakClient) QueryPorts(ctx context.Context, in *QueryPortsRequest, opts ...grpc.CallOption) (*QueryPortsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(QueryPortsResponse)
	err := c.cc.Invoke(ctx, Yak_QueryPorts_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) DeletePorts(ctx context.Context, in *DeletePortsRequest, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, Yak_DeletePorts_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) QueryHosts(ctx context.Context, in *QueryHostsRequest, opts ...grpc.CallOption) (*QueryHostsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(QueryHostsResponse)
	err := c.cc.Invoke(ctx, Yak_QueryHosts_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) DeleteHosts(ctx context.Context, in *DeleteHostsRequest, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, Yak_DeleteHosts_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) QueryDomains(ctx context.Context, in *QueryDomainsRequest, opts ...grpc.CallOption) (*QueryDomainsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(QueryDomainsResponse)
	err := c.cc.Invoke(ctx, Yak_QueryDomains_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) DeleteDomains(ctx context.Context, in *DeleteDomainsRequest, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, Yak_DeleteDomains_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) QueryPortsGroup(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*QueryPortsGroupResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(QueryPortsGroupResponse)
	err := c.cc.Invoke(ctx, Yak_QueryPortsGroup_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) UpdateFromYakitResource(ctx context.Context, in *UpdateFromYakitResourceRequest, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, Yak_UpdateFromYakitResource_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) UpdateFromGithub(ctx context.Context, in *UpdateFromGithubRequest, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, Yak_UpdateFromGithub_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) AddToMenu(ctx context.Context, in *AddToMenuRequest, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, Yak_AddToMenu_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) RemoveFromMenu(ctx context.Context, in *RemoveFromMenuRequest, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, Yak_RemoveFromMenu_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) YakScriptIsInMenu(ctx context.Context, in *YakScriptIsInMenuRequest, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, Yak_YakScriptIsInMenu_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) GetAllMenuItem(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*MenuByGroup, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(MenuByGroup)
	err := c.cc.Invoke(ctx, Yak_GetAllMenuItem_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) DeleteAllMenuItem(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, Yak_DeleteAllMenuItem_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) ImportMenuItem(ctx context.Context, in *ImportMenuItemRequest, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, Yak_ImportMenuItem_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) ExportMenuItem(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*ExportMenuItemResult, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ExportMenuItemResult)
	err := c.cc.Invoke(ctx, Yak_ExportMenuItem_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) GetMenuItemById(ctx context.Context, in *GetMenuItemByIdRequest, opts ...grpc.CallOption) (*MenuItem, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(MenuItem)
	err := c.cc.Invoke(ctx, Yak_GetMenuItemById_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) QueryGroupsByYakScriptId(ctx context.Context, in *QueryGroupsByYakScriptIdRequest, opts ...grpc.CallOption) (*GroupNames, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GroupNames)
	err := c.cc.Invoke(ctx, Yak_QueryGroupsByYakScriptId_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) AddMenus(ctx context.Context, in *AddMenuRequest, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, Yak_AddMenus_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) QueryAllMenuItem(ctx context.Context, in *QueryAllMenuItemRequest, opts ...grpc.CallOption) (*MenuByGroup, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(MenuByGroup)
	err := c.cc.Invoke(ctx, Yak_QueryAllMenuItem_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) DeleteAllMenu(ctx context.Context, in *QueryAllMenuItemRequest, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, Yak_DeleteAllMenu_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) AddToNavigation(ctx context.Context, in *AddToNavigationRequest, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, Yak_AddToNavigation_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) GetAllNavigationItem(ctx context.Context, in *GetAllNavigationRequest, opts ...grpc.CallOption) (*GetAllNavigationItemResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetAllNavigationItemResponse)
	err := c.cc.Invoke(ctx, Yak_GetAllNavigationItem_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) DeleteAllNavigation(ctx context.Context, in *GetAllNavigationRequest, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, Yak_DeleteAllNavigation_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) AddOneNavigation(ctx context.Context, in *AddOneNavigationRequest, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, Yak_AddOneNavigation_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) QueryNavigationGroups(ctx context.Context, in *QueryNavigationGroupsRequest, opts ...grpc.CallOption) (*GroupNames, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GroupNames)
	err := c.cc.Invoke(ctx, Yak_QueryNavigationGroups_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) SaveMarkdownDocument(ctx context.Context, in *SaveMarkdownDocumentRequest, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, Yak_SaveMarkdownDocument_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) GetMarkdownDocument(ctx context.Context, in *GetMarkdownDocumentRequest, opts ...grpc.CallOption) (*GetMarkdownDocumentResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetMarkdownDocumentResponse)
	err := c.cc.Invoke(ctx, Yak_GetMarkdownDocument_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) DeleteMarkdownDocument(ctx context.Context, in *GetMarkdownDocumentRequest, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, Yak_DeleteMarkdownDocument_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) StartBasicCrawler(ctx context.Context, in *StartBasicCrawlerRequest, opts ...grpc.CallOption) (*ExecResult, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ExecResult)
	err := c.cc.Invoke(ctx, Yak_StartBasicCrawler_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) ViewBasicCrawlerCode(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*SimpleScript, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SimpleScript)
	err := c.cc.Invoke(ctx, Yak_ViewBasicCrawlerCode_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) GenerateWebsiteTree(ctx context.Context, in *GenerateWebsiteTreeRequest, opts ...grpc.CallOption) (*GenerateWebsiteTreeResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GenerateWebsiteTreeResponse)
	err := c.cc.Invoke(ctx, Yak_GenerateWebsiteTree_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) QueryYakScriptExecResult(ctx context.Context, in *QueryYakScriptExecResultRequest, opts ...grpc.CallOption) (*QueryYakScriptExecResultResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(QueryYakScriptExecResultResponse)
	err := c.cc.Invoke(ctx, Yak_QueryYakScriptExecResult_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) QueryYakScriptNameInExecResult(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*YakScriptNames, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(YakScriptNames)
	err := c.cc.Invoke(ctx, Yak_QueryYakScriptNameInExecResult_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) DeleteYakScriptExecResult(ctx context.Context, in *DeleteYakScriptExecResultRequest, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, Yak_DeleteYakScriptExecResult_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) DeleteYakScriptExec(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, Yak_DeleteYakScriptExec_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) StartBrute(ctx context.Context, in *StartBruteParams, opts ...grpc.CallOption) (grpc.ServerStreamingClient[ExecResult], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &Yak_ServiceDesc.Streams[38], Yak_StartBrute_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[StartBruteParams, ExecResult]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Yak_StartBruteClient = grpc.ServerStreamingClient[ExecResult]

func (c *yakClient) GetAvailableBruteTypes(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*GetAvailableBruteTypesResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetAvailableBruteTypesResponse)
	err := c.cc.Invoke(ctx, Yak_GetAvailableBruteTypes_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) GetTunnelServerExternalIP(ctx context.Context, in *GetTunnelServerExternalIPParams, opts ...grpc.CallOption) (*GetTunnelServerExternalIPResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetTunnelServerExternalIPResponse)
	err := c.cc.Invoke(ctx, Yak_GetTunnelServerExternalIP_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) VerifyTunnelServerDomain(ctx context.Context, in *VerifyTunnelServerDomainParams, opts ...grpc.CallOption) (*VerifyTunnelServerDomainResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(VerifyTunnelServerDomainResponse)
	err := c.cc.Invoke(ctx, Yak_VerifyTunnelServerDomain_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) StartFacades(ctx context.Context, in *StartFacadesParams, opts ...grpc.CallOption) (grpc.ServerStreamingClient[ExecResult], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &Yak_ServiceDesc.Streams[39], Yak_StartFacades_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[StartFacadesParams, ExecResult]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Yak_StartFacadesClient = grpc.ServerStreamingClient[ExecResult]

func (c *yakClient) StartFacadesWithYsoObject(ctx context.Context, in *StartFacadesWithYsoParams, opts ...grpc.CallOption) (grpc.ServerStreamingClient[ExecResult], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &Yak_ServiceDesc.Streams[40], Yak_StartFacadesWithYsoObject_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[StartFacadesWithYsoParams, ExecResult]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Yak_StartFacadesWithYsoObjectClient = grpc.ServerStreamingClient[ExecResult]

func (c *yakClient) ApplyClassToFacades(ctx context.Context, in *ApplyClassToFacadesParamsWithVerbose, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, Yak_ApplyClassToFacades_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) BytesToBase64(ctx context.Context, in *BytesToBase64Request, opts ...grpc.CallOption) (*BytesToBase64Response, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(BytesToBase64Response)
	err := c.cc.Invoke(ctx, Yak_BytesToBase64_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) ConfigGlobalReverse(ctx context.Context, in *ConfigGlobalReverseParams, opts ...grpc.CallOption) (grpc.ServerStreamingClient[Empty], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &Yak_ServiceDesc.Streams[41], Yak_ConfigGlobalReverse_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[ConfigGlobalReverseParams, Empty]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Yak_ConfigGlobalReverseClient = grpc.ServerStreamingClient[Empty]

func (c *yakClient) AvailableLocalAddr(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*AvailableLocalAddrResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(AvailableLocalAddrResponse)
	err := c.cc.Invoke(ctx, Yak_AvailableLocalAddr_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) GetGlobalReverseServer(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*GetGlobalReverseServerResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetGlobalReverseServerResponse)
	err := c.cc.Invoke(ctx, Yak_GetGlobalReverseServer_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) QueryRisks(ctx context.Context, in *QueryRisksRequest, opts ...grpc.CallOption) (*QueryRisksResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(QueryRisksResponse)
	err := c.cc.Invoke(ctx, Yak_QueryRisks_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) QueryRisk(ctx context.Context, in *QueryRiskRequest, opts ...grpc.CallOption) (*Risk, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Risk)
	err := c.cc.Invoke(ctx, Yak_QueryRisk_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) DeleteRisk(ctx context.Context, in *DeleteRiskRequest, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, Yak_DeleteRisk_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) QueryAvailableRiskType(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*Fields, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Fields)
	err := c.cc.Invoke(ctx, Yak_QueryAvailableRiskType_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) QueryAvailableRiskLevel(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*Fields, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Fields)
	err := c.cc.Invoke(ctx, Yak_QueryAvailableRiskLevel_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) QueryRiskTableStats(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*RiskTableStats, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RiskTableStats)
	err := c.cc.Invoke(ctx, Yak_QueryRiskTableStats_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) ResetRiskTableStats(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, Yak_ResetRiskTableStats_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) QueryAvailableTarget(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*Fields, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Fields)
	err := c.cc.Invoke(ctx, Yak_QueryAvailableTarget_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) QueryNewRisk(ctx context.Context, in *QueryNewRiskRequest, opts ...grpc.CallOption) (*QueryNewRiskResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(QueryNewRiskResponse)
	err := c.cc.Invoke(ctx, Yak_QueryNewRisk_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) NewRiskRead(ctx context.Context, in *NewRiskReadRequest, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, Yak_NewRiskRead_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) UploadRiskToOnline(ctx context.Context, in *UploadRiskToOnlineRequest, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, Yak_UploadRiskToOnline_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) SetTagForRisk(ctx context.Context, in *SetTagForRiskRequest, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, Yak_SetTagForRisk_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) QueryRiskTags(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*QueryRiskTagsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(QueryRiskTagsResponse)
	err := c.cc.Invoke(ctx, Yak_QueryRiskTags_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) RiskFieldGroup(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*RiskFieldGroupResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RiskFieldGroupResponse)
	err := c.cc.Invoke(ctx, Yak_RiskFieldGroup_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) RiskFeedbackToOnline(ctx context.Context, in *UploadRiskToOnlineRequest, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, Yak_RiskFeedbackToOnline_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) QueryReports(ctx context.Context, in *QueryReportsRequest, opts ...grpc.CallOption) (*QueryReportsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(QueryReportsResponse)
	err := c.cc.Invoke(ctx, Yak_QueryReports_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) QueryReport(ctx context.Context, in *QueryReportRequest, opts ...grpc.CallOption) (*Report, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Report)
	err := c.cc.Invoke(ctx, Yak_QueryReport_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) DeleteReport(ctx context.Context, in *DeleteReportRequest, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, Yak_DeleteReport_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) QueryAvailableReportFrom(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*Fields, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Fields)
	err := c.cc.Invoke(ctx, Yak_QueryAvailableReportFrom_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) DownloadReport(ctx context.Context, in *DownloadReportRequest, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, Yak_DownloadReport_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) GetAllYsoGadgetOptions(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*YsoOptionsWithVerbose, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(YsoOptionsWithVerbose)
	err := c.cc.Invoke(ctx, Yak_GetAllYsoGadgetOptions_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) GetAllYsoClassOptions(ctx context.Context, in *YsoOptionsRequerstWithVerbose, opts ...grpc.CallOption) (*YsoOptionsWithVerbose, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(YsoOptionsWithVerbose)
	err := c.cc.Invoke(ctx, Yak_GetAllYsoClassOptions_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) GetAllYsoClassGeneraterOptions(ctx context.Context, in *YsoOptionsRequerstWithVerbose, opts ...grpc.CallOption) (*YsoClassOptionsResponseWithVerbose, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(YsoClassOptionsResponseWithVerbose)
	err := c.cc.Invoke(ctx, Yak_GetAllYsoClassGeneraterOptions_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) GenerateYsoCode(ctx context.Context, in *YsoOptionsRequerstWithVerbose, opts ...grpc.CallOption) (*YsoCodeResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(YsoCodeResponse)
	err := c.cc.Invoke(ctx, Yak_GenerateYsoCode_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) GenerateYsoBytes(ctx context.Context, in *YsoOptionsRequerstWithVerbose, opts ...grpc.CallOption) (*YsoBytesResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(YsoBytesResponse)
	err := c.cc.Invoke(ctx, Yak_GenerateYsoBytes_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) YsoDump(ctx context.Context, in *YsoBytesObject, opts ...grpc.CallOption) (*YsoDumpResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(YsoDumpResponse)
	err := c.cc.Invoke(ctx, Yak_YsoDump_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) CreateWebShell(ctx context.Context, in *WebShell, opts ...grpc.CallOption) (*WebShell, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(WebShell)
	err := c.cc.Invoke(ctx, Yak_CreateWebShell_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) DeleteWebShell(ctx context.Context, in *DeleteWebShellRequest, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, Yak_DeleteWebShell_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) UpdateWebShell(ctx context.Context, in *WebShell, opts ...grpc.CallOption) (*WebShell, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(WebShell)
	err := c.cc.Invoke(ctx, Yak_UpdateWebShell_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) QueryWebShells(ctx context.Context, in *QueryWebShellsRequest, opts ...grpc.CallOption) (*QueryWebShellsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(QueryWebShellsResponse)
	err := c.cc.Invoke(ctx, Yak_QueryWebShells_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) Ping(ctx context.Context, in *WebShellRequest, opts ...grpc.CallOption) (*WebShellResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(WebShellResponse)
	err := c.cc.Invoke(ctx, Yak_Ping_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) GetBasicInfo(ctx context.Context, in *WebShellRequest, opts ...grpc.CallOption) (*WebShellResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(WebShellResponse)
	err := c.cc.Invoke(ctx, Yak_GetBasicInfo_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) GenerateWebShell(ctx context.Context, in *ShellGenerate, opts ...grpc.CallOption) (*WebShellResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(WebShellResponse)
	err := c.cc.Invoke(ctx, Yak_GenerateWebShell_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) SetYakBridgeLogServer(ctx context.Context, in *YakDNSLogBridgeAddr, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, Yak_SetYakBridgeLogServer_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) GetCurrentYakBridgeLogServer(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*YakDNSLogBridgeAddr, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(YakDNSLogBridgeAddr)
	err := c.cc.Invoke(ctx, Yak_GetCurrentYakBridgeLogServer_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) RequireDNSLogDomain(ctx context.Context, in *YakDNSLogBridgeAddr, opts ...grpc.CallOption) (*DNSLogRootDomain, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DNSLogRootDomain)
	err := c.cc.Invoke(ctx, Yak_RequireDNSLogDomain_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) RequireDNSLogDomainByScript(ctx context.Context, in *RequireDNSLogDomainByScriptRequest, opts ...grpc.CallOption) (*DNSLogRootDomain, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DNSLogRootDomain)
	err := c.cc.Invoke(ctx, Yak_RequireDNSLogDomainByScript_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) QueryDNSLogByToken(ctx context.Context, in *QueryDNSLogByTokenRequest, opts ...grpc.CallOption) (*QueryDNSLogByTokenResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(QueryDNSLogByTokenResponse)
	err := c.cc.Invoke(ctx, Yak_QueryDNSLogByToken_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) QueryDNSLogTokenByScript(ctx context.Context, in *RequireDNSLogDomainByScriptRequest, opts ...grpc.CallOption) (*QueryDNSLogByTokenResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(QueryDNSLogByTokenResponse)
	err := c.cc.Invoke(ctx, Yak_QueryDNSLogTokenByScript_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) RequireICMPRandomLength(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*RequireICMPRandomLengthResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RequireICMPRandomLengthResponse)
	err := c.cc.Invoke(ctx, Yak_RequireICMPRandomLength_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) QueryICMPTrigger(ctx context.Context, in *QueryICMPTriggerRequest, opts ...grpc.CallOption) (*QueryICMPTriggerResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(QueryICMPTriggerResponse)
	err := c.cc.Invoke(ctx, Yak_QueryICMPTrigger_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) RequireRandomPortToken(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*RandomPortInfo, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RandomPortInfo)
	err := c.cc.Invoke(ctx, Yak_RequireRandomPortToken_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) QueryRandomPortTrigger(ctx context.Context, in *QueryRandomPortTriggerRequest, opts ...grpc.CallOption) (*RandomPortTriggerNotification, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RandomPortTriggerNotification)
	err := c.cc.Invoke(ctx, Yak_QueryRandomPortTrigger_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) QuerySupportedDnsLogPlatforms(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*QuerySupportedDnsLogPlatformsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(QuerySupportedDnsLogPlatformsResponse)
	err := c.cc.Invoke(ctx, Yak_QuerySupportedDnsLogPlatforms_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) GetAvailableYakScriptTags(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*Fields, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Fields)
	err := c.cc.Invoke(ctx, Yak_GetAvailableYakScriptTags_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) ForceUpdateAvailableYakScriptTags(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, Yak_ForceUpdateAvailableYakScriptTags_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) ExecYakitPluginsByYakScriptFilter(ctx context.Context, in *ExecYakitPluginsByYakScriptFilterRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[ExecResult], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &Yak_ServiceDesc.Streams[42], Yak_ExecYakitPluginsByYakScriptFilter_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[ExecYakitPluginsByYakScriptFilterRequest, ExecResult]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Yak_ExecYakitPluginsByYakScriptFilterClient = grpc.ServerStreamingClient[ExecResult]

func (c *yakClient) GenerateYakCodeByPacket(ctx context.Context, in *GenerateYakCodeByPacketRequest, opts ...grpc.CallOption) (*GenerateYakCodeByPacketResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GenerateYakCodeByPacketResponse)
	err := c.cc.Invoke(ctx, Yak_GenerateYakCodeByPacket_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) GenerateCSRFPocByPacket(ctx context.Context, in *GenerateCSRFPocByPacketRequest, opts ...grpc.CallOption) (*GenerateCSRFPocByPacketResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GenerateCSRFPocByPacketResponse)
	err := c.cc.Invoke(ctx, Yak_GenerateCSRFPocByPacket_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) ExportMITMReplacerRules(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*ExportMITMReplacerRulesResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ExportMITMReplacerRulesResponse)
	err := c.cc.Invoke(ctx, Yak_ExportMITMReplacerRules_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) ImportMITMReplacerRules(ctx context.Context, in *ImportMITMReplacerRulesRequest, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, Yak_ImportMITMReplacerRules_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) GetCurrentRules(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*MITMContentReplacers, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(MITMContentReplacers)
	err := c.cc.Invoke(ctx, Yak_GetCurrentRules_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) SetCurrentRules(ctx context.Context, in *MITMContentReplacers, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, Yak_SetCurrentRules_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) GenerateURL(ctx context.Context, in *GenerateURLRequest, opts ...grpc.CallOption) (*GenerateURLResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GenerateURLResponse)
	err := c.cc.Invoke(ctx, Yak_GenerateURL_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) ExtractDataToFile(ctx context.Context, opts ...grpc.CallOption) (grpc.BidiStreamingClient[ExtractDataToFileRequest, ExtractDataToFileResult], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &Yak_ServiceDesc.Streams[43], Yak_ExtractDataToFile_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[ExtractDataToFileRequest, ExtractDataToFileResult]{ClientStream: stream}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Yak_ExtractDataToFileClient = grpc.BidiStreamingClient[ExtractDataToFileRequest, ExtractDataToFileResult]

func (c *yakClient) AutoDecode(ctx context.Context, in *AutoDecodeRequest, opts ...grpc.CallOption) (*AutoDecodeResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(AutoDecodeResponse)
	err := c.cc.Invoke(ctx, Yak_AutoDecode_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) GetSystemProxy(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*GetSystemProxyResult, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetSystemProxyResult)
	err := c.cc.Invoke(ctx, Yak_GetSystemProxy_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) SetSystemProxy(ctx context.Context, in *SetSystemProxyRequest, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, Yak_SetSystemProxy_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) GetKey(ctx context.Context, in *GetKeyRequest, opts ...grpc.CallOption) (*GetKeyResult, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetKeyResult)
	err := c.cc.Invoke(ctx, Yak_GetKey_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) SetKey(ctx context.Context, in *SetKeyRequest, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, Yak_SetKey_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) DelKey(ctx context.Context, in *GetKeyRequest, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, Yak_DelKey_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) GetAllProcessEnvKey(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*GetProcessEnvKeyResult, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetProcessEnvKeyResult)
	err := c.cc.Invoke(ctx, Yak_GetAllProcessEnvKey_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) SetProcessEnvKey(ctx context.Context, in *SetKeyRequest, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, Yak_SetProcessEnvKey_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) GetProjectKey(ctx context.Context, in *GetKeyRequest, opts ...grpc.CallOption) (*GetKeyResult, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetKeyResult)
	err := c.cc.Invoke(ctx, Yak_GetProjectKey_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) SetProjectKey(ctx context.Context, in *SetKeyRequest, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, Yak_SetProjectKey_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) GetOnlineProfile(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*OnlineProfile, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(OnlineProfile)
	err := c.cc.Invoke(ctx, Yak_GetOnlineProfile_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) SetOnlineProfile(ctx context.Context, in *OnlineProfile, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, Yak_SetOnlineProfile_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) DownloadOnlinePluginById(ctx context.Context, in *DownloadOnlinePluginByIdRequest, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, Yak_DownloadOnlinePluginById_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) DownloadOnlinePluginByIds(ctx context.Context, in *DownloadOnlinePluginByIdsRequest, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, Yak_DownloadOnlinePluginByIds_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) DownloadOnlinePluginAll(ctx context.Context, in *DownloadOnlinePluginByTokenRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[DownloadOnlinePluginProgress], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &Yak_ServiceDesc.Streams[44], Yak_DownloadOnlinePluginAll_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[DownloadOnlinePluginByTokenRequest, DownloadOnlinePluginProgress]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Yak_DownloadOnlinePluginAllClient = grpc.ServerStreamingClient[DownloadOnlinePluginProgress]

func (c *yakClient) DeletePluginByUserID(ctx context.Context, in *DeletePluginByUserIDRequest, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, Yak_DeletePluginByUserID_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) DeleteAllLocalPlugins(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, Yak_DeleteAllLocalPlugins_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) GetYakScriptTagsAndType(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*GetYakScriptTagsAndTypeResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetYakScriptTagsAndTypeResponse)
	err := c.cc.Invoke(ctx, Yak_GetYakScriptTagsAndType_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) DeleteLocalPluginsByWhere(ctx context.Context, in *DeleteLocalPluginsByWhereRequest, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, Yak_DeleteLocalPluginsByWhere_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) DownloadOnlinePluginByScriptNames(ctx context.Context, in *DownloadOnlinePluginByScriptNamesRequest, opts ...grpc.CallOption) (*DownloadOnlinePluginByScriptNamesResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DownloadOnlinePluginByScriptNamesResponse)
	err := c.cc.Invoke(ctx, Yak_DownloadOnlinePluginByScriptNames_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) DownloadOnlinePlugins(ctx context.Context, in *DownloadOnlinePluginsRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[DownloadOnlinePluginProgress], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &Yak_ServiceDesc.Streams[45], Yak_DownloadOnlinePlugins_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[DownloadOnlinePluginsRequest, DownloadOnlinePluginProgress]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Yak_DownloadOnlinePluginsClient = grpc.ServerStreamingClient[DownloadOnlinePluginProgress]

func (c *yakClient) DownloadOnlinePluginBatch(ctx context.Context, in *DownloadOnlinePluginsRequest, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, Yak_DownloadOnlinePluginBatch_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) DownloadOnlinePluginByPluginName(ctx context.Context, in *DownloadOnlinePluginByScriptNamesRequest, opts ...grpc.CallOption) (*DownloadOnlinePluginByScriptNamesResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DownloadOnlinePluginByScriptNamesResponse)
	err := c.cc.Invoke(ctx, Yak_DownloadOnlinePluginByPluginName_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) DownloadOnlinePluginByUUID(ctx context.Context, in *DownloadOnlinePluginByUUIDRequest, opts ...grpc.CallOption) (*YakScript, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(YakScript)
	err := c.cc.Invoke(ctx, Yak_DownloadOnlinePluginByUUID_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) QueryOnlinePlugins(ctx context.Context, in *QueryOnlinePluginsRequest, opts ...grpc.CallOption) (*QueryOnlinePluginsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(QueryOnlinePluginsResponse)
	err := c.cc.Invoke(ctx, Yak_QueryOnlinePlugins_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) ExecPacketScan(ctx context.Context, in *ExecPacketScanRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[ExecResult], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &Yak_ServiceDesc.Streams[46], Yak_ExecPacketScan_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[ExecPacketScanRequest, ExecResult]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Yak_ExecPacketScanClient = grpc.ServerStreamingClient[ExecResult]

func (c *yakClient) GetEngineDefaultProxy(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*DefaultProxyResult, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DefaultProxyResult)
	err := c.cc.Invoke(ctx, Yak_GetEngineDefaultProxy_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) SetEngineDefaultProxy(ctx context.Context, in *DefaultProxyResult, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, Yak_SetEngineDefaultProxy_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) GetMachineID(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*GetMachineIDResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetMachineIDResponse)
	err := c.cc.Invoke(ctx, Yak_GetMachineID_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) GetLicense(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*GetLicenseResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetLicenseResponse)
	err := c.cc.Invoke(ctx, Yak_GetLicense_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) CheckLicense(ctx context.Context, in *CheckLicenseRequest, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, Yak_CheckLicense_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) GetRequestBodyByHTTPFlowID(ctx context.Context, in *DownloadBodyByHTTPFlowIDRequest, opts ...grpc.CallOption) (*Bytes, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Bytes)
	err := c.cc.Invoke(ctx, Yak_GetRequestBodyByHTTPFlowID_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) GetResponseBodyByHTTPFlowID(ctx context.Context, in *DownloadBodyByHTTPFlowIDRequest, opts ...grpc.CallOption) (*Bytes, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Bytes)
	err := c.cc.Invoke(ctx, Yak_GetResponseBodyByHTTPFlowID_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) GetHTTPPacketBody(ctx context.Context, in *GetHTTPPacketBodyRequest, opts ...grpc.CallOption) (*Bytes, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Bytes)
	err := c.cc.Invoke(ctx, Yak_GetHTTPPacketBody_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) RegisterFacadesHTTP(ctx context.Context, in *RegisterFacadesHTTPRequest, opts ...grpc.CallOption) (*RegisterFacadesHTTPResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RegisterFacadesHTTPResponse)
	err := c.cc.Invoke(ctx, Yak_RegisterFacadesHTTP_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) ResetAndInvalidUserData(ctx context.Context, in *ResetAndInvalidUserDataRequest, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, Yak_ResetAndInvalidUserData_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) CreateYaklangShell(ctx context.Context, opts ...grpc.CallOption) (grpc.BidiStreamingClient[YaklangShellRequest, YaklangShellResponse], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &Yak_ServiceDesc.Streams[47], Yak_CreateYaklangShell_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[YaklangShellRequest, YaklangShellResponse]{ClientStream: stream}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Yak_CreateYaklangShellClient = grpc.BidiStreamingClient[YaklangShellRequest, YaklangShellResponse]

func (c *yakClient) AttachCombinedOutput(ctx context.Context, in *AttachCombinedOutputRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[ExecResult], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &Yak_ServiceDesc.Streams[48], Yak_AttachCombinedOutput_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[AttachCombinedOutputRequest, ExecResult]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Yak_AttachCombinedOutputClient = grpc.ServerStreamingClient[ExecResult]

func (c *yakClient) IsPrivilegedForNetRaw(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*IsPrivilegedForNetRawResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(IsPrivilegedForNetRawResponse)
	err := c.cc.Invoke(ctx, Yak_IsPrivilegedForNetRaw_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) PromotePermissionForUserPcap(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, Yak_PromotePermissionForUserPcap_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) SetCurrentProject(ctx context.Context, in *SetCurrentProjectRequest, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, Yak_SetCurrentProject_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) GetCurrentProject(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*ProjectDescription, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ProjectDescription)
	err := c.cc.Invoke(ctx, Yak_GetCurrentProject_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) GetCurrentProjectEx(ctx context.Context, in *GetCurrentProjectExRequest, opts ...grpc.CallOption) (*ProjectDescription, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ProjectDescription)
	err := c.cc.Invoke(ctx, Yak_GetCurrentProjectEx_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) GetProjects(ctx context.Context, in *GetProjectsRequest, opts ...grpc.CallOption) (*GetProjectsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetProjectsResponse)
	err := c.cc.Invoke(ctx, Yak_GetProjects_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) NewProject(ctx context.Context, in *NewProjectRequest, opts ...grpc.CallOption) (*NewProjectResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(NewProjectResponse)
	err := c.cc.Invoke(ctx, Yak_NewProject_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) UpdateProject(ctx context.Context, in *NewProjectRequest, opts ...grpc.CallOption) (*NewProjectResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(NewProjectResponse)
	err := c.cc.Invoke(ctx, Yak_UpdateProject_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) IsProjectNameValid(ctx context.Context, in *IsProjectNameValidRequest, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, Yak_IsProjectNameValid_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) RemoveProject(ctx context.Context, in *RemoveProjectRequest, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, Yak_RemoveProject_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) DeleteProject(ctx context.Context, in *DeleteProjectRequest, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, Yak_DeleteProject_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) GetDefaultProject(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*ProjectDescription, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ProjectDescription)
	err := c.cc.Invoke(ctx, Yak_GetDefaultProject_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) GetDefaultProjectEx(ctx context.Context, in *GetDefaultProjectExRequest, opts ...grpc.CallOption) (*ProjectDescription, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ProjectDescription)
	err := c.cc.Invoke(ctx, Yak_GetDefaultProjectEx_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) QueryProjectDetail(ctx context.Context, in *QueryProjectDetailRequest, opts ...grpc.CallOption) (*ProjectDescription, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ProjectDescription)
	err := c.cc.Invoke(ctx, Yak_QueryProjectDetail_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) GetTemporaryProject(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*ProjectDescription, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ProjectDescription)
	err := c.cc.Invoke(ctx, Yak_GetTemporaryProject_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) GetTemporaryProjectEx(ctx context.Context, in *GetTemporaryProjectExRequest, opts ...grpc.CallOption) (*ProjectDescription, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ProjectDescription)
	err := c.cc.Invoke(ctx, Yak_GetTemporaryProjectEx_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) ExportProject(ctx context.Context, in *ExportProjectRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[ProjectIOProgress], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &Yak_ServiceDesc.Streams[49], Yak_ExportProject_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[ExportProjectRequest, ProjectIOProgress]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Yak_ExportProjectClient = grpc.ServerStreamingClient[ProjectIOProgress]

func (c *yakClient) ImportProject(ctx context.Context, in *ImportProjectRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[ProjectIOProgress], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &Yak_ServiceDesc.Streams[50], Yak_ImportProject_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[ImportProjectRequest, ProjectIOProgress]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Yak_ImportProjectClient = grpc.ServerStreamingClient[ProjectIOProgress]

func (c *yakClient) MigrateLegacyDatabase(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, Yak_MigrateLegacyDatabase_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) QueryMITMRuleExtractedData(ctx context.Context, in *QueryMITMRuleExtractedDataRequest, opts ...grpc.CallOption) (*QueryMITMRuleExtractedDataResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(QueryMITMRuleExtractedDataResponse)
	err := c.cc.Invoke(ctx, Yak_QueryMITMRuleExtractedData_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) ExportMITMRuleExtractedData(ctx context.Context, in *ExportMITMRuleExtractedDataRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[ExportMITMRuleExtractedDataResponse], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &Yak_ServiceDesc.Streams[51], Yak_ExportMITMRuleExtractedData_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[ExportMITMRuleExtractedDataRequest, ExportMITMRuleExtractedDataResponse]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Yak_ExportMITMRuleExtractedDataClient = grpc.ServerStreamingClient[ExportMITMRuleExtractedDataResponse]

func (c *yakClient) ImportChaosMakerRules(ctx context.Context, in *ImportChaosMakerRulesRequest, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, Yak_ImportChaosMakerRules_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) QueryChaosMakerRule(ctx context.Context, in *QueryChaosMakerRuleRequest, opts ...grpc.CallOption) (*QueryChaosMakerRuleResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(QueryChaosMakerRuleResponse)
	err := c.cc.Invoke(ctx, Yak_QueryChaosMakerRule_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) DeleteChaosMakerRuleByID(ctx context.Context, in *DeleteChaosMakerRuleByIDRequest, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, Yak_DeleteChaosMakerRuleByID_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) ExecuteChaosMakerRule(ctx context.Context, in *ExecuteChaosMakerRuleRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[ExecResult], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &Yak_ServiceDesc.Streams[52], Yak_ExecuteChaosMakerRule_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[ExecuteChaosMakerRuleRequest, ExecResult]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Yak_ExecuteChaosMakerRuleClient = grpc.ServerStreamingClient[ExecResult]

func (c *yakClient) IsRemoteAddrAvailable(ctx context.Context, in *IsRemoteAddrAvailableRequest, opts ...grpc.CallOption) (*IsRemoteAddrAvailableResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(IsRemoteAddrAvailableResponse)
	err := c.cc.Invoke(ctx, Yak_IsRemoteAddrAvailable_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) ConnectVulinboxAgent(ctx context.Context, in *IsRemoteAddrAvailableRequest, opts ...grpc.CallOption) (*IsRemoteAddrAvailableResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(IsRemoteAddrAvailableResponse)
	err := c.cc.Invoke(ctx, Yak_ConnectVulinboxAgent_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) GetRegisteredVulinboxAgent(ctx context.Context, in *GetRegisteredAgentRequest, opts ...grpc.CallOption) (*GetRegisteredAgentResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetRegisteredAgentResponse)
	err := c.cc.Invoke(ctx, Yak_GetRegisteredVulinboxAgent_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) DisconnectVulinboxAgent(ctx context.Context, in *DisconnectVulinboxAgentRequest, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, Yak_DisconnectVulinboxAgent_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) IsCVEDatabaseReady(ctx context.Context, in *IsCVEDatabaseReadyRequest, opts ...grpc.CallOption) (*IsCVEDatabaseReadyResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(IsCVEDatabaseReadyResponse)
	err := c.cc.Invoke(ctx, Yak_IsCVEDatabaseReady_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) UpdateCVEDatabase(ctx context.Context, in *UpdateCVEDatabaseRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[ExecResult], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &Yak_ServiceDesc.Streams[53], Yak_UpdateCVEDatabase_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[UpdateCVEDatabaseRequest, ExecResult]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Yak_UpdateCVEDatabaseClient = grpc.ServerStreamingClient[ExecResult]

func (c *yakClient) ExportsProfileDatabase(ctx context.Context, in *ExportsProfileDatabaseRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[ExecResult], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &Yak_ServiceDesc.Streams[54], Yak_ExportsProfileDatabase_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[ExportsProfileDatabaseRequest, ExecResult]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Yak_ExportsProfileDatabaseClient = grpc.ServerStreamingClient[ExecResult]

func (c *yakClient) ImportsProfileDatabase(ctx context.Context, in *ImportsProfileDatabaseRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[ExecResult], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &Yak_ServiceDesc.Streams[55], Yak_ImportsProfileDatabase_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[ImportsProfileDatabaseRequest, ExecResult]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Yak_ImportsProfileDatabaseClient = grpc.ServerStreamingClient[ExecResult]

func (c *yakClient) QueryCVE(ctx context.Context, in *QueryCVERequest, opts ...grpc.CallOption) (*QueryCVEResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(QueryCVEResponse)
	err := c.cc.Invoke(ctx, Yak_QueryCVE_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) GetCVE(ctx context.Context, in *GetCVERequest, opts ...grpc.CallOption) (*CVEDetailEx, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CVEDetailEx)
	err := c.cc.Invoke(ctx, Yak_GetCVE_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) SaveTextToTemporalFile(ctx context.Context, in *SaveTextToTemporalFileRequest, opts ...grpc.CallOption) (*SaveTextToTemporalFileResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SaveTextToTemporalFileResponse)
	err := c.cc.Invoke(ctx, Yak_SaveTextToTemporalFile_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) IsScrecorderReady(ctx context.Context, in *IsScrecorderReadyRequest, opts ...grpc.CallOption) (*IsScrecorderReadyResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(IsScrecorderReadyResponse)
	err := c.cc.Invoke(ctx, Yak_IsScrecorderReady_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) InstallScrecorder(ctx context.Context, in *InstallScrecorderRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[ExecResult], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &Yak_ServiceDesc.Streams[56], Yak_InstallScrecorder_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[InstallScrecorderRequest, ExecResult]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Yak_InstallScrecorderClient = grpc.ServerStreamingClient[ExecResult]

func (c *yakClient) StartScrecorder(ctx context.Context, in *StartScrecorderRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[ExecResult], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &Yak_ServiceDesc.Streams[57], Yak_StartScrecorder_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[StartScrecorderRequest, ExecResult]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Yak_StartScrecorderClient = grpc.ServerStreamingClient[ExecResult]

func (c *yakClient) QueryScreenRecorders(ctx context.Context, in *QueryScreenRecorderRequest, opts ...grpc.CallOption) (*QueryScreenRecorderResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(QueryScreenRecorderResponse)
	err := c.cc.Invoke(ctx, Yak_QueryScreenRecorders_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) DeleteScreenRecorders(ctx context.Context, in *QueryScreenRecorderRequest, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, Yak_DeleteScreenRecorders_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) UploadScreenRecorders(ctx context.Context, in *UploadScreenRecorderRequest, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, Yak_UploadScreenRecorders_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) GetOneScreenRecorders(ctx context.Context, in *GetOneScreenRecorderRequest, opts ...grpc.CallOption) (*ScreenRecorder, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ScreenRecorder)
	err := c.cc.Invoke(ctx, Yak_GetOneScreenRecorders_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) UpdateScreenRecorders(ctx context.Context, in *UpdateScreenRecorderRequest, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, Yak_UpdateScreenRecorders_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) IsVulinboxReady(ctx context.Context, in *IsVulinboxReadyRequest, opts ...grpc.CallOption) (*IsVulinboxReadyResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(IsVulinboxReadyResponse)
	err := c.cc.Invoke(ctx, Yak_IsVulinboxReady_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) InstallVulinbox(ctx context.Context, in *InstallVulinboxRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[ExecResult], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &Yak_ServiceDesc.Streams[58], Yak_InstallVulinbox_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[InstallVulinboxRequest, ExecResult]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Yak_InstallVulinboxClient = grpc.ServerStreamingClient[ExecResult]

func (c *yakClient) StartVulinbox(ctx context.Context, in *StartVulinboxRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[ExecResult], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &Yak_ServiceDesc.Streams[59], Yak_StartVulinbox_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[StartVulinboxRequest, ExecResult]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Yak_StartVulinboxClient = grpc.ServerStreamingClient[ExecResult]

func (c *yakClient) GenQualityInspectionReport(ctx context.Context, in *GenQualityInspectionReportRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[ExecResult], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &Yak_ServiceDesc.Streams[60], Yak_GenQualityInspectionReport_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[GenQualityInspectionReportRequest, ExecResult]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Yak_GenQualityInspectionReportClient = grpc.ServerStreamingClient[ExecResult]

func (c *yakClient) HTTPRequestBuilder(ctx context.Context, in *HTTPRequestBuilderParams, opts ...grpc.CallOption) (*HTTPRequestBuilderResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(HTTPRequestBuilderResponse)
	err := c.cc.Invoke(ctx, Yak_HTTPRequestBuilder_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) DebugPlugin(ctx context.Context, in *DebugPluginRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[ExecResult], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &Yak_ServiceDesc.Streams[61], Yak_DebugPlugin_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[DebugPluginRequest, ExecResult]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Yak_DebugPluginClient = grpc.ServerStreamingClient[ExecResult]

func (c *yakClient) SmokingEvaluatePlugin(ctx context.Context, in *SmokingEvaluatePluginRequest, opts ...grpc.CallOption) (*SmokingEvaluatePluginResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SmokingEvaluatePluginResponse)
	err := c.cc.Invoke(ctx, Yak_SmokingEvaluatePlugin_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) SmokingEvaluatePluginBatch(ctx context.Context, in *SmokingEvaluatePluginBatchRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[SmokingEvaluatePluginBatchResponse], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &Yak_ServiceDesc.Streams[62], Yak_SmokingEvaluatePluginBatch_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[SmokingEvaluatePluginBatchRequest, SmokingEvaluatePluginBatchResponse]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Yak_SmokingEvaluatePluginBatchClient = grpc.ServerStreamingClient[SmokingEvaluatePluginBatchResponse]

func (c *yakClient) GetSystemDefaultDnsServers(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*DefaultDnsServerResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DefaultDnsServerResponse)
	err := c.cc.Invoke(ctx, Yak_GetSystemDefaultDnsServers_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) DiagnoseNetwork(ctx context.Context, in *DiagnoseNetworkRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[DiagnoseNetworkResponse], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &Yak_ServiceDesc.Streams[63], Yak_DiagnoseNetwork_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[DiagnoseNetworkRequest, DiagnoseNetworkResponse]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Yak_DiagnoseNetworkClient = grpc.ServerStreamingClient[DiagnoseNetworkResponse]

func (c *yakClient) DiagnoseNetworkDNS(ctx context.Context, in *DiagnoseNetworkDNSRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[DiagnoseNetworkResponse], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &Yak_ServiceDesc.Streams[64], Yak_DiagnoseNetworkDNS_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[DiagnoseNetworkDNSRequest, DiagnoseNetworkResponse]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Yak_DiagnoseNetworkDNSClient = grpc.ServerStreamingClient[DiagnoseNetworkResponse]

func (c *yakClient) TraceRoute(ctx context.Context, in *TraceRouteRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[TraceRouteResponse], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &Yak_ServiceDesc.Streams[65], Yak_TraceRoute_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[TraceRouteRequest, TraceRouteResponse]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Yak_TraceRouteClient = grpc.ServerStreamingClient[TraceRouteResponse]

func (c *yakClient) GetGlobalNetworkConfig(ctx context.Context, in *GetGlobalNetworkConfigRequest, opts ...grpc.CallOption) (*GlobalNetworkConfig, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GlobalNetworkConfig)
	err := c.cc.Invoke(ctx, Yak_GetGlobalNetworkConfig_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) SetGlobalNetworkConfig(ctx context.Context, in *GlobalNetworkConfig, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, Yak_SetGlobalNetworkConfig_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) ResetGlobalNetworkConfig(ctx context.Context, in *ResetGlobalNetworkConfigRequest, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, Yak_ResetGlobalNetworkConfig_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) ValidP12PassWord(ctx context.Context, in *ValidP12PassWordRequest, opts ...grpc.CallOption) (*ValidP12PassWordResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ValidP12PassWordResponse)
	err := c.cc.Invoke(ctx, Yak_ValidP12PassWord_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) RequestYakURL(ctx context.Context, in *RequestYakURLParams, opts ...grpc.CallOption) (*RequestYakURLResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RequestYakURLResponse)
	err := c.cc.Invoke(ctx, Yak_RequestYakURL_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) ReadFile(ctx context.Context, in *ReadFileRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[ReadFileResponse], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &Yak_ServiceDesc.Streams[66], Yak_ReadFile_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[ReadFileRequest, ReadFileResponse]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Yak_ReadFileClient = grpc.ServerStreamingClient[ReadFileResponse]

func (c *yakClient) GetPcapMetadata(ctx context.Context, in *PcapMetadataRequest, opts ...grpc.CallOption) (*PcapMetadata, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(PcapMetadata)
	err := c.cc.Invoke(ctx, Yak_GetPcapMetadata_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) PcapX(ctx context.Context, opts ...grpc.CallOption) (grpc.BidiStreamingClient[PcapXRequest, PcapXResponse], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &Yak_ServiceDesc.Streams[67], Yak_PcapX_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[PcapXRequest, PcapXResponse]{ClientStream: stream}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Yak_PcapXClient = grpc.BidiStreamingClient[PcapXRequest, PcapXResponse]

func (c *yakClient) QueryTrafficSession(ctx context.Context, in *QueryTrafficSessionRequest, opts ...grpc.CallOption) (*QueryTrafficSessionResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(QueryTrafficSessionResponse)
	err := c.cc.Invoke(ctx, Yak_QueryTrafficSession_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) QueryTrafficPacket(ctx context.Context, in *QueryTrafficPacketRequest, opts ...grpc.CallOption) (*QueryTrafficPacketResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(QueryTrafficPacketResponse)
	err := c.cc.Invoke(ctx, Yak_QueryTrafficPacket_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) QueryTrafficTCPReassembled(ctx context.Context, in *QueryTrafficTCPReassembledRequest, opts ...grpc.CallOption) (*QueryTrafficTCPReassembledResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(QueryTrafficTCPReassembledResponse)
	err := c.cc.Invoke(ctx, Yak_QueryTrafficTCPReassembled_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) ParseTraffic(ctx context.Context, in *ParseTrafficRequest, opts ...grpc.CallOption) (*ParseTrafficResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ParseTrafficResponse)
	err := c.cc.Invoke(ctx, Yak_ParseTraffic_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) DuplexConnection(ctx context.Context, opts ...grpc.CallOption) (grpc.BidiStreamingClient[DuplexConnectionRequest, DuplexConnectionResponse], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &Yak_ServiceDesc.Streams[68], Yak_DuplexConnection_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[DuplexConnectionRequest, DuplexConnectionResponse]{ClientStream: stream}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Yak_DuplexConnectionClient = grpc.BidiStreamingClient[DuplexConnectionRequest, DuplexConnectionResponse]

func (c *yakClient) HybridScan(ctx context.Context, opts ...grpc.CallOption) (grpc.BidiStreamingClient[HybridScanRequest, HybridScanResponse], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &Yak_ServiceDesc.Streams[69], Yak_HybridScan_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[HybridScanRequest, HybridScanResponse]{ClientStream: stream}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Yak_HybridScanClient = grpc.BidiStreamingClient[HybridScanRequest, HybridScanResponse]

func (c *yakClient) QueryHybridScanTask(ctx context.Context, in *QueryHybridScanTaskRequest, opts ...grpc.CallOption) (*QueryHybridScanTaskResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(QueryHybridScanTaskResponse)
	err := c.cc.Invoke(ctx, Yak_QueryHybridScanTask_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) DeleteHybridScanTask(ctx context.Context, in *DeleteHybridScanTaskRequest, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, Yak_DeleteHybridScanTask_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) GetSpaceEngineStatus(ctx context.Context, in *GetSpaceEngineStatusRequest, opts ...grpc.CallOption) (*SpaceEngineStatus, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SpaceEngineStatus)
	err := c.cc.Invoke(ctx, Yak_GetSpaceEngineStatus_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) GetSpaceEngineAccountStatus(ctx context.Context, in *GetSpaceEngineAccountStatusRequest, opts ...grpc.CallOption) (*SpaceEngineStatus, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SpaceEngineStatus)
	err := c.cc.Invoke(ctx, Yak_GetSpaceEngineAccountStatus_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) GetSpaceEngineAccountStatusV2(ctx context.Context, in *ThirdPartyApplicationConfig, opts ...grpc.CallOption) (*SpaceEngineStatus, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SpaceEngineStatus)
	err := c.cc.Invoke(ctx, Yak_GetSpaceEngineAccountStatusV2_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) FetchPortAssetFromSpaceEngine(ctx context.Context, in *FetchPortAssetFromSpaceEngineRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[ExecResult], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &Yak_ServiceDesc.Streams[70], Yak_FetchPortAssetFromSpaceEngine_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[FetchPortAssetFromSpaceEngineRequest, ExecResult]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Yak_FetchPortAssetFromSpaceEngineClient = grpc.ServerStreamingClient[ExecResult]

func (c *yakClient) EvaluateExpression(ctx context.Context, in *EvaluateExpressionRequest, opts ...grpc.CallOption) (*EvaluateExpressionResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(EvaluateExpressionResponse)
	err := c.cc.Invoke(ctx, Yak_EvaluateExpression_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) EvaluateMultiExpression(ctx context.Context, in *EvaluateMultiExpressionRequest, opts ...grpc.CallOption) (*EvaluateMultiExpressionResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(EvaluateMultiExpressionResponse)
	err := c.cc.Invoke(ctx, Yak_EvaluateMultiExpression_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) GetThirdPartyAppConfigTemplate(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*GetThirdPartyAppConfigTemplateResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetThirdPartyAppConfigTemplateResponse)
	err := c.cc.Invoke(ctx, Yak_GetThirdPartyAppConfigTemplate_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) CheckHahValidAiConfig(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*GeneralResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GeneralResponse)
	err := c.cc.Invoke(ctx, Yak_CheckHahValidAiConfig_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) ListAiModel(ctx context.Context, in *ListAiModelRequest, opts ...grpc.CallOption) (*ListAiModelResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListAiModelResponse)
	err := c.cc.Invoke(ctx, Yak_ListAiModel_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) GetFingerprint(ctx context.Context, in *GetFingerprintRequest, opts ...grpc.CallOption) (*GetFingerprintResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetFingerprintResponse)
	err := c.cc.Invoke(ctx, Yak_GetFingerprint_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) AddFingerprint(ctx context.Context, in *AddFingerprintRequest, opts ...grpc.CallOption) (*AddFingerprintResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(AddFingerprintResponse)
	err := c.cc.Invoke(ctx, Yak_AddFingerprint_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) ModifyFingerprint(ctx context.Context, in *ModifyFingerprintRequest, opts ...grpc.CallOption) (*ModifyFingerprintResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ModifyFingerprintResponse)
	err := c.cc.Invoke(ctx, Yak_ModifyFingerprint_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) QueryFingerprint(ctx context.Context, in *QueryFingerprintRequest, opts ...grpc.CallOption) (*QueryFingerprintResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(QueryFingerprintResponse)
	err := c.cc.Invoke(ctx, Yak_QueryFingerprint_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) DeleteFingerprint(ctx context.Context, in *DeleteFingerprintRequest, opts ...grpc.CallOption) (*DbOperateMessage, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DbOperateMessage)
	err := c.cc.Invoke(ctx, Yak_DeleteFingerprint_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) UpdateFingerprint(ctx context.Context, in *UpdateFingerprintRequest, opts ...grpc.CallOption) (*DbOperateMessage, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DbOperateMessage)
	err := c.cc.Invoke(ctx, Yak_UpdateFingerprint_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) CreateFingerprint(ctx context.Context, in *CreateFingerprintRequest, opts ...grpc.CallOption) (*DbOperateMessage, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DbOperateMessage)
	err := c.cc.Invoke(ctx, Yak_CreateFingerprint_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) RecoverBuiltinFingerprint(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*DbOperateMessage, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DbOperateMessage)
	err := c.cc.Invoke(ctx, Yak_RecoverBuiltinFingerprint_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) CreateFingerprintGroup(ctx context.Context, in *FingerprintGroup, opts ...grpc.CallOption) (*DbOperateMessage, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DbOperateMessage)
	err := c.cc.Invoke(ctx, Yak_CreateFingerprintGroup_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) GetAllFingerprintGroup(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*FingerprintGroups, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(FingerprintGroups)
	err := c.cc.Invoke(ctx, Yak_GetAllFingerprintGroup_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) RenameFingerprintGroup(ctx context.Context, in *RenameFingerprintGroupRequest, opts ...grpc.CallOption) (*DbOperateMessage, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DbOperateMessage)
	err := c.cc.Invoke(ctx, Yak_RenameFingerprintGroup_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) DeleteFingerprintGroup(ctx context.Context, in *DeleteFingerprintGroupRequest, opts ...grpc.CallOption) (*DbOperateMessage, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DbOperateMessage)
	err := c.cc.Invoke(ctx, Yak_DeleteFingerprintGroup_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) BatchUpdateFingerprintToGroup(ctx context.Context, in *BatchUpdateFingerprintToGroupRequest, opts ...grpc.CallOption) (*DbOperateMessage, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DbOperateMessage)
	err := c.cc.Invoke(ctx, Yak_BatchUpdateFingerprintToGroup_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) GetFingerprintGroupSetByFilter(ctx context.Context, in *GetFingerprintGroupSetRequest, opts ...grpc.CallOption) (*FingerprintGroups, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(FingerprintGroups)
	err := c.cc.Invoke(ctx, Yak_GetFingerprintGroupSetByFilter_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) ExportFingerprint(ctx context.Context, in *ExportFingerprintRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[DataTransferProgress], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &Yak_ServiceDesc.Streams[71], Yak_ExportFingerprint_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[ExportFingerprintRequest, DataTransferProgress]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Yak_ExportFingerprintClient = grpc.ServerStreamingClient[DataTransferProgress]

func (c *yakClient) ImportFingerprint(ctx context.Context, in *ImportFingerprintRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[DataTransferProgress], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &Yak_ServiceDesc.Streams[72], Yak_ImportFingerprint_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[ImportFingerprintRequest, DataTransferProgress]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Yak_ImportFingerprintClient = grpc.ServerStreamingClient[DataTransferProgress]

func (c *yakClient) GetReverseShellProgramList(ctx context.Context, in *GetReverseShellProgramListRequest, opts ...grpc.CallOption) (*GetReverseShellProgramListResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetReverseShellProgramListResponse)
	err := c.cc.Invoke(ctx, Yak_GetReverseShellProgramList_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) GenerateReverseShellCommand(ctx context.Context, in *GenerateReverseShellCommandRequest, opts ...grpc.CallOption) (*GenerateReverseShellCommandResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GenerateReverseShellCommandResponse)
	err := c.cc.Invoke(ctx, Yak_GenerateReverseShellCommand_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) QuerySyntaxFlowRule(ctx context.Context, in *QuerySyntaxFlowRuleRequest, opts ...grpc.CallOption) (*QuerySyntaxFlowRuleResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(QuerySyntaxFlowRuleResponse)
	err := c.cc.Invoke(ctx, Yak_QuerySyntaxFlowRule_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) CreateSyntaxFlowRule(ctx context.Context, in *CreateSyntaxFlowRuleRequest, opts ...grpc.CallOption) (*DbOperateMessage, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DbOperateMessage)
	err := c.cc.Invoke(ctx, Yak_CreateSyntaxFlowRule_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) CreateSyntaxFlowRuleEx(ctx context.Context, in *CreateSyntaxFlowRuleRequest, opts ...grpc.CallOption) (*CreateSyntaxFlowRuleResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CreateSyntaxFlowRuleResponse)
	err := c.cc.Invoke(ctx, Yak_CreateSyntaxFlowRuleEx_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) UpdateSyntaxFlowRule(ctx context.Context, in *UpdateSyntaxFlowRuleRequest, opts ...grpc.CallOption) (*DbOperateMessage, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DbOperateMessage)
	err := c.cc.Invoke(ctx, Yak_UpdateSyntaxFlowRule_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) UpdateSyntaxFlowRuleEx(ctx context.Context, in *UpdateSyntaxFlowRuleRequest, opts ...grpc.CallOption) (*UpdateSyntaxFlowRuleResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UpdateSyntaxFlowRuleResponse)
	err := c.cc.Invoke(ctx, Yak_UpdateSyntaxFlowRuleEx_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) DeleteSyntaxFlowRule(ctx context.Context, in *DeleteSyntaxFlowRuleRequest, opts ...grpc.CallOption) (*DbOperateMessage, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DbOperateMessage)
	err := c.cc.Invoke(ctx, Yak_DeleteSyntaxFlowRule_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) CheckSyntaxFlowRuleUpdate(ctx context.Context, in *CheckSyntaxFlowRuleUpdateRequest, opts ...grpc.CallOption) (*CheckSyntaxFlowRuleUpdateResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CheckSyntaxFlowRuleUpdateResponse)
	err := c.cc.Invoke(ctx, Yak_CheckSyntaxFlowRuleUpdate_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) ApplySyntaxFlowRuleUpdate(ctx context.Context, in *ApplySyntaxFlowRuleUpdateRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[ApplySyntaxFlowRuleUpdateResponse], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &Yak_ServiceDesc.Streams[73], Yak_ApplySyntaxFlowRuleUpdate_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[ApplySyntaxFlowRuleUpdateRequest, ApplySyntaxFlowRuleUpdateResponse]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Yak_ApplySyntaxFlowRuleUpdateClient = grpc.ServerStreamingClient[ApplySyntaxFlowRuleUpdateResponse]

func (c *yakClient) QuerySyntaxFlowRuleGroup(ctx context.Context, in *QuerySyntaxFlowRuleGroupRequest, opts ...grpc.CallOption) (*QuerySyntaxFlowRuleGroupResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(QuerySyntaxFlowRuleGroupResponse)
	err := c.cc.Invoke(ctx, Yak_QuerySyntaxFlowRuleGroup_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) DeleteSyntaxFlowRuleGroup(ctx context.Context, in *DeleteSyntaxFlowRuleGroupRequest, opts ...grpc.CallOption) (*DbOperateMessage, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DbOperateMessage)
	err := c.cc.Invoke(ctx, Yak_DeleteSyntaxFlowRuleGroup_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) CreateSyntaxFlowRuleGroup(ctx context.Context, in *CreateSyntaxFlowGroupRequest, opts ...grpc.CallOption) (*DbOperateMessage, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DbOperateMessage)
	err := c.cc.Invoke(ctx, Yak_CreateSyntaxFlowRuleGroup_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) UpdateSyntaxFlowRuleGroup(ctx context.Context, in *UpdateSyntaxFlowRuleGroupRequest, opts ...grpc.CallOption) (*DbOperateMessage, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DbOperateMessage)
	err := c.cc.Invoke(ctx, Yak_UpdateSyntaxFlowRuleGroup_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) UpdateSyntaxFlowRuleAndGroup(ctx context.Context, in *UpdateSyntaxFlowRuleAndGroupRequest, opts ...grpc.CallOption) (*DbOperateMessage, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DbOperateMessage)
	err := c.cc.Invoke(ctx, Yak_UpdateSyntaxFlowRuleAndGroup_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) QuerySyntaxFlowSameGroup(ctx context.Context, in *QuerySyntaxFlowSameGroupRequest, opts ...grpc.CallOption) (*QuerySyntaxFlowSameGroupResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(QuerySyntaxFlowSameGroupResponse)
	err := c.cc.Invoke(ctx, Yak_QuerySyntaxFlowSameGroup_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) SyntaxFlowRuleToOnline(ctx context.Context, in *SyntaxFlowRuleToOnlineRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[SyntaxFlowRuleOnlineProgress], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &Yak_ServiceDesc.Streams[74], Yak_SyntaxFlowRuleToOnline_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[SyntaxFlowRuleToOnlineRequest, SyntaxFlowRuleOnlineProgress]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Yak_SyntaxFlowRuleToOnlineClient = grpc.ServerStreamingClient[SyntaxFlowRuleOnlineProgress]

func (c *yakClient) DownloadSyntaxFlowRule(ctx context.Context, in *DownloadSyntaxFlowRuleRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[SyntaxFlowRuleOnlineProgress], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &Yak_ServiceDesc.Streams[75], Yak_DownloadSyntaxFlowRule_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[DownloadSyntaxFlowRuleRequest, SyntaxFlowRuleOnlineProgress]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Yak_DownloadSyntaxFlowRuleClient = grpc.ServerStreamingClient[SyntaxFlowRuleOnlineProgress]

func (c *yakClient) SyntaxFlowScan(ctx context.Context, opts ...grpc.CallOption) (grpc.BidiStreamingClient[SyntaxFlowScanRequest, SyntaxFlowScanResponse], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &Yak_ServiceDesc.Streams[76], Yak_SyntaxFlowScan_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[SyntaxFlowScanRequest, SyntaxFlowScanResponse]{ClientStream: stream}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Yak_SyntaxFlowScanClient = grpc.BidiStreamingClient[SyntaxFlowScanRequest, SyntaxFlowScanResponse]

func (c *yakClient) QuerySyntaxFlowScanTask(ctx context.Context, in *QuerySyntaxFlowScanTaskRequest, opts ...grpc.CallOption) (*QuerySyntaxFlowScanTaskResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(QuerySyntaxFlowScanTaskResponse)
	err := c.cc.Invoke(ctx, Yak_QuerySyntaxFlowScanTask_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) DeleteSyntaxFlowScanTask(ctx context.Context, in *DeleteSyntaxFlowScanTaskRequest, opts ...grpc.CallOption) (*DbOperateMessage, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DbOperateMessage)
	err := c.cc.Invoke(ctx, Yak_DeleteSyntaxFlowScanTask_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) QuerySyntaxFlowResult(ctx context.Context, in *QuerySyntaxFlowResultRequest, opts ...grpc.CallOption) (*QuerySyntaxFlowResultResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(QuerySyntaxFlowResultResponse)
	err := c.cc.Invoke(ctx, Yak_QuerySyntaxFlowResult_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) DeleteSyntaxFlowResult(ctx context.Context, in *DeleteSyntaxFlowResultRequest, opts ...grpc.CallOption) (*DeleteSyntaxFlowResultResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DeleteSyntaxFlowResultResponse)
	err := c.cc.Invoke(ctx, Yak_DeleteSyntaxFlowResult_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) QuerySSAPrograms(ctx context.Context, in *QuerySSAProgramRequest, opts ...grpc.CallOption) (*QuerySSAProgramResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(QuerySSAProgramResponse)
	err := c.cc.Invoke(ctx, Yak_QuerySSAPrograms_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) UpdateSSAProgram(ctx context.Context, in *UpdateSSAProgramRequest, opts ...grpc.CallOption) (*DbOperateMessage, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DbOperateMessage)
	err := c.cc.Invoke(ctx, Yak_UpdateSSAProgram_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) DeleteSSAPrograms(ctx context.Context, in *DeleteSSAProgramRequest, opts ...grpc.CallOption) (*DbOperateMessage, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DbOperateMessage)
	err := c.cc.Invoke(ctx, Yak_DeleteSSAPrograms_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) QuerySSARisks(ctx context.Context, in *QuerySSARisksRequest, opts ...grpc.CallOption) (*QuerySSARisksResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(QuerySSARisksResponse)
	err := c.cc.Invoke(ctx, Yak_QuerySSARisks_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) QueryNewSSARisks(ctx context.Context, in *QueryNewSSARisksRequest, opts ...grpc.CallOption) (*QueryNewSSARisksResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(QueryNewSSARisksResponse)
	err := c.cc.Invoke(ctx, Yak_QueryNewSSARisks_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) DeleteSSARisks(ctx context.Context, in *DeleteSSARisksRequest, opts ...grpc.CallOption) (*DbOperateMessage, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DbOperateMessage)
	err := c.cc.Invoke(ctx, Yak_DeleteSSARisks_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) UpdateSSARiskTags(ctx context.Context, in *UpdateSSARiskTagsRequest, opts ...grpc.CallOption) (*DbOperateMessage, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DbOperateMessage)
	err := c.cc.Invoke(ctx, Yak_UpdateSSARiskTags_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) GetSSARiskFieldGroup(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*SSARiskFieldGroupResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SSARiskFieldGroupResponse)
	err := c.cc.Invoke(ctx, Yak_GetSSARiskFieldGroup_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) NewSSARiskRead(ctx context.Context, in *NewSSARiskReadRequest, opts ...grpc.CallOption) (*NewSSARiskReadResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(NewSSARiskReadResponse)
	err := c.cc.Invoke(ctx, Yak_NewSSARiskRead_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) SSARiskFeedbackToOnline(ctx context.Context, in *SSARiskFeedbackToOnlineRequest, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, Yak_SSARiskFeedbackToOnline_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) GetAllPluginEnv(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*PluginEnvData, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(PluginEnvData)
	err := c.cc.Invoke(ctx, Yak_GetAllPluginEnv_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) QueryPluginEnv(ctx context.Context, in *QueryPluginEnvRequest, opts ...grpc.CallOption) (*PluginEnvData, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(PluginEnvData)
	err := c.cc.Invoke(ctx, Yak_QueryPluginEnv_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) CreatePluginEnv(ctx context.Context, in *PluginEnvData, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, Yak_CreatePluginEnv_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) SetPluginEnv(ctx context.Context, in *PluginEnvData, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, Yak_SetPluginEnv_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) DeletePluginEnv(ctx context.Context, in *DeletePluginEnvRequest, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, Yak_DeletePluginEnv_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) GetAllFuzztagInfo(ctx context.Context, in *GetAllFuzztagInfoRequest, opts ...grpc.CallOption) (*GetAllFuzztagInfoResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetAllFuzztagInfoResponse)
	err := c.cc.Invoke(ctx, Yak_GetAllFuzztagInfo_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) GenerateFuzztag(ctx context.Context, in *GenerateFuzztagRequest, opts ...grpc.CallOption) (*GenerateFuzztagResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GenerateFuzztagResponse)
	err := c.cc.Invoke(ctx, Yak_GenerateFuzztag_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) ExportSyntaxFlows(ctx context.Context, in *ExportSyntaxFlowsRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[SyntaxflowsProgress], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &Yak_ServiceDesc.Streams[77], Yak_ExportSyntaxFlows_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[ExportSyntaxFlowsRequest, SyntaxflowsProgress]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Yak_ExportSyntaxFlowsClient = grpc.ServerStreamingClient[SyntaxflowsProgress]

func (c *yakClient) ImportSyntaxFlows(ctx context.Context, in *ImportSyntaxFlowsRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[SyntaxflowsProgress], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &Yak_ServiceDesc.Streams[78], Yak_ImportSyntaxFlows_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[ImportSyntaxFlowsRequest, SyntaxflowsProgress]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Yak_ImportSyntaxFlowsClient = grpc.ServerStreamingClient[SyntaxflowsProgress]

func (c *yakClient) CreateHotPatchTemplate(ctx context.Context, in *HotPatchTemplate, opts ...grpc.CallOption) (*CreateHotPatchTemplateResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CreateHotPatchTemplateResponse)
	err := c.cc.Invoke(ctx, Yak_CreateHotPatchTemplate_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) DeleteHotPatchTemplate(ctx context.Context, in *DeleteHotPatchTemplateRequest, opts ...grpc.CallOption) (*DeleteHotPatchTemplateResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DeleteHotPatchTemplateResponse)
	err := c.cc.Invoke(ctx, Yak_DeleteHotPatchTemplate_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) UpdateHotPatchTemplate(ctx context.Context, in *UpdateHotPatchTemplateRequest, opts ...grpc.CallOption) (*UpdateHotPatchTemplateResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UpdateHotPatchTemplateResponse)
	err := c.cc.Invoke(ctx, Yak_UpdateHotPatchTemplate_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) QueryHotPatchTemplate(ctx context.Context, in *HotPatchTemplateRequest, opts ...grpc.CallOption) (*QueryHotPatchTemplateResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(QueryHotPatchTemplateResponse)
	err := c.cc.Invoke(ctx, Yak_QueryHotPatchTemplate_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) QueryHotPatchTemplateList(ctx context.Context, in *QueryHotPatchTemplateListRequest, opts ...grpc.CallOption) (*QueryHotPatchTemplateListResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(QueryHotPatchTemplateListResponse)
	err := c.cc.Invoke(ctx, Yak_QueryHotPatchTemplateList_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) GroupTableColumn(ctx context.Context, in *GroupTableColumnRequest, opts ...grpc.CallOption) (*GroupTableColumnResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GroupTableColumnResponse)
	err := c.cc.Invoke(ctx, Yak_GroupTableColumn_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) UploadHotPatchTemplateToOnline(ctx context.Context, in *UploadHotPatchTemplateToOnlineRequest, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, Yak_UploadHotPatchTemplateToOnline_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) DownloadHotPatchTemplate(ctx context.Context, in *DownloadHotPatchTemplateRequest, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, Yak_DownloadHotPatchTemplate_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) SetMITMHijackFilter(ctx context.Context, in *SetMITMFilterRequest, opts ...grpc.CallOption) (*SetMITMFilterResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SetMITMFilterResponse)
	err := c.cc.Invoke(ctx, Yak_SetMITMHijackFilter_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) GetMITMHijackFilter(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*SetMITMFilterRequest, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SetMITMFilterRequest)
	err := c.cc.Invoke(ctx, Yak_GetMITMHijackFilter_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) ResetMITMHijackFilter(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*SetMITMFilterRequest, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SetMITMFilterRequest)
	err := c.cc.Invoke(ctx, Yak_ResetMITMHijackFilter_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) ExportHTTPFlowStream(ctx context.Context, in *ExportHTTPFlowStreamRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[ExportHTTPFlowStreamResponse], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &Yak_ServiceDesc.Streams[79], Yak_ExportHTTPFlowStream_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[ExportHTTPFlowStreamRequest, ExportHTTPFlowStreamResponse]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Yak_ExportHTTPFlowStreamClient = grpc.ServerStreamingClient[ExportHTTPFlowStreamResponse]

func (c *yakClient) ImportHTTPFlowStream(ctx context.Context, in *ImportHTTPFlowStreamRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[ImportHTTPFlowStreamResponse], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &Yak_ServiceDesc.Streams[80], Yak_ImportHTTPFlowStream_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[ImportHTTPFlowStreamRequest, ImportHTTPFlowStreamResponse]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Yak_ImportHTTPFlowStreamClient = grpc.ServerStreamingClient[ImportHTTPFlowStreamResponse]

func (c *yakClient) CreateNote(ctx context.Context, in *CreateNoteRequest, opts ...grpc.CallOption) (*CreateNoteResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CreateNoteResponse)
	err := c.cc.Invoke(ctx, Yak_CreateNote_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) UpdateNote(ctx context.Context, in *UpdateNoteRequest, opts ...grpc.CallOption) (*DbOperateMessage, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DbOperateMessage)
	err := c.cc.Invoke(ctx, Yak_UpdateNote_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) DeleteNote(ctx context.Context, in *DeleteNoteRequest, opts ...grpc.CallOption) (*DbOperateMessage, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DbOperateMessage)
	err := c.cc.Invoke(ctx, Yak_DeleteNote_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) QueryNote(ctx context.Context, in *QueryNoteRequest, opts ...grpc.CallOption) (*QueryNoteResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(QueryNoteResponse)
	err := c.cc.Invoke(ctx, Yak_QueryNote_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) SearchNoteContent(ctx context.Context, in *SearchNoteContentRequest, opts ...grpc.CallOption) (*SearchNoteContentResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SearchNoteContentResponse)
	err := c.cc.Invoke(ctx, Yak_SearchNoteContent_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) ImportNote(ctx context.Context, in *ImportNoteRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[ImportNoteResponse], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &Yak_ServiceDesc.Streams[81], Yak_ImportNote_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[ImportNoteRequest, ImportNoteResponse]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Yak_ImportNoteClient = grpc.ServerStreamingClient[ImportNoteResponse]

func (c *yakClient) ExportNote(ctx context.Context, in *ExportNoteRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[ExportNoteResponse], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &Yak_ServiceDesc.Streams[82], Yak_ExportNote_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[ExportNoteRequest, ExportNoteResponse]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Yak_ExportNoteClient = grpc.ServerStreamingClient[ExportNoteResponse]

func (c *yakClient) StartAITask(ctx context.Context, opts ...grpc.CallOption) (grpc.BidiStreamingClient[AIInputEvent, AIOutputEvent], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &Yak_ServiceDesc.Streams[83], Yak_StartAITask_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[AIInputEvent, AIOutputEvent]{ClientStream: stream}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Yak_StartAITaskClient = grpc.BidiStreamingClient[AIInputEvent, AIOutputEvent]

func (c *yakClient) QueryAITask(ctx context.Context, in *AITaskQueryRequest, opts ...grpc.CallOption) (*AITaskQueryResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(AITaskQueryResponse)
	err := c.cc.Invoke(ctx, Yak_QueryAITask_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) StartAITriage(ctx context.Context, opts ...grpc.CallOption) (grpc.BidiStreamingClient[AITriageInputEvent, AIOutputEvent], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &Yak_ServiceDesc.Streams[84], Yak_StartAITriage_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[AITriageInputEvent, AIOutputEvent]{ClientStream: stream}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Yak_StartAITriageClient = grpc.BidiStreamingClient[AITriageInputEvent, AIOutputEvent]

func (c *yakClient) CreateAIForge(ctx context.Context, in *AIForge, opts ...grpc.CallOption) (*DbOperateMessage, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DbOperateMessage)
	err := c.cc.Invoke(ctx, Yak_CreateAIForge_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) UpdateAIForge(ctx context.Context, in *AIForge, opts ...grpc.CallOption) (*DbOperateMessage, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DbOperateMessage)
	err := c.cc.Invoke(ctx, Yak_UpdateAIForge_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) DeleteAIForge(ctx context.Context, in *AIForgeFilter, opts ...grpc.CallOption) (*DbOperateMessage, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DbOperateMessage)
	err := c.cc.Invoke(ctx, Yak_DeleteAIForge_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) QueryAIForge(ctx context.Context, in *QueryAIForgeRequest, opts ...grpc.CallOption) (*QueryAIForgeResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(QueryAIForgeResponse)
	err := c.cc.Invoke(ctx, Yak_QueryAIForge_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) StartMcpServer(ctx context.Context, in *StartMcpServerRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[StartMcpServerResponse], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &Yak_ServiceDesc.Streams[85], Yak_StartMcpServer_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[StartMcpServerRequest, StartMcpServerResponse]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Yak_StartMcpServerClient = grpc.ServerStreamingClient[StartMcpServerResponse]

func (c *yakClient) GetToolSetList(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*GetToolSetListResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetToolSetListResponse)
	err := c.cc.Invoke(ctx, Yak_GetToolSetList_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) GetAIToolList(ctx context.Context, in *GetAIToolListRequest, opts ...grpc.CallOption) (*GetAIToolListResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetAIToolListResponse)
	err := c.cc.Invoke(ctx, Yak_GetAIToolList_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) DeleteAITool(ctx context.Context, in *DeleteAIToolRequest, opts ...grpc.CallOption) (*DbOperateMessage, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DbOperateMessage)
	err := c.cc.Invoke(ctx, Yak_DeleteAITool_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) SaveAITool(ctx context.Context, in *SaveAIToolRequest, opts ...grpc.CallOption) (*DbOperateMessage, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DbOperateMessage)
	err := c.cc.Invoke(ctx, Yak_SaveAITool_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) ToggleAIToolFavorite(ctx context.Context, in *ToggleAIToolFavoriteRequest, opts ...grpc.CallOption) (*ToggleAIToolFavoriteResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ToggleAIToolFavoriteResponse)
	err := c.cc.Invoke(ctx, Yak_ToggleAIToolFavorite_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) AIToolGenerateMetadata(ctx context.Context, in *AIToolGenerateMetadataRequest, opts ...grpc.CallOption) (*AIToolGenerateMetadataResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(AIToolGenerateMetadataResponse)
	err := c.cc.Invoke(ctx, Yak_AIToolGenerateMetadata_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// YakServer is the server API for Yak service.
// All implementations must embed UnimplementedYakServer
// for forward compatibility.
type YakServer interface {
	// version
	Version(context.Context, *Empty) (*VersionResponse, error)
	YakVersionAtLeast(context.Context, *YakVersionAtLeastRequest) (*GeneralResponse, error)
	// echo 通常用于测试服务是否通畅
	Echo(context.Context, *EchoRequest) (*EchoResposne, error)
	// 握手 用于检查前端是否可以连接当前引擎
	Handshake(context.Context, *HandshakeRequest) (*HandshakeResponse, error)
	VerifySystemCertificate(context.Context, *Empty) (*VerifySystemCertificateResponse, error)
	// 中间人劫持
	MITM(grpc.BidiStreamingServer[MITMRequest, MITMResponse]) error
	SetMITMFilter(context.Context, *SetMITMFilterRequest) (*SetMITMFilterResponse, error)
	GetMITMFilter(context.Context, *Empty) (*SetMITMFilterRequest, error)
	ResetMITMFilter(context.Context, *Empty) (*SetMITMFilterRequest, error)
	DownloadMITMCert(context.Context, *Empty) (*MITMCert, error)
	MITMV2(grpc.BidiStreamingServer[MITMV2Request, MITMV2Response]) error
	// 开启端口
	OpenPort(grpc.BidiStreamingServer[Input, Output]) error
	// Exec
	Exec(*ExecRequest, grpc.ServerStreamingServer[ExecResult]) error
	QueryExecHistory(context.Context, *ExecHistoryRequest) (*ExecHistoryRecordResponse, error)
	RemoveExecHistory(context.Context, *Empty) (*Empty, error)
	LoadNucleiTemplates(context.Context, *Empty) (*Empty, error)
	AutoUpdateYakModule(*Empty, grpc.ServerStreamingServer[ExecResult]) error
	ExecYakScript(*ExecRequest, grpc.ServerStreamingServer[ExecResult]) error
	// ExecBatch Script
	ExecBatchYakScript(*ExecBatchYakScriptRequest, grpc.ServerStreamingServer[ExecBatchYakScriptResult]) error
	GetExecBatchYakScriptUnfinishedTask(context.Context, *Empty) (*GetExecBatchYakScriptUnfinishedTaskResponse, error)
	GetExecBatchYakScriptUnfinishedTaskByUid(context.Context, *GetExecBatchYakScriptUnfinishedTaskByUidRequest) (*ExecBatchYakScriptRequest, error)
	PopExecBatchYakScriptUnfinishedTaskByUid(context.Context, *GetExecBatchYakScriptUnfinishedTaskByUidRequest) (*ExecBatchYakScriptRequest, error)
	RecoverExecBatchYakScriptUnfinishedTask(*RecoverExecBatchYakScriptUnfinishedTaskRequest, grpc.ServerStreamingServer[ExecBatchYakScriptResult]) error
	// yakScript
	QueryYakScript(context.Context, *QueryYakScriptRequest) (*QueryYakScriptResponse, error)
	QueryYakScriptByYakScriptName(*QueryYakScriptRequest, grpc.ServerStreamingServer[YakScript]) error
	SaveYakScript(context.Context, *YakScript) (*YakScript, error)
	DeleteYakScript(context.Context, *DeleteYakScriptRequest) (*Empty, error)
	GetYakScriptById(context.Context, *GetYakScriptByIdRequest) (*YakScript, error)
	GetYakScriptByName(context.Context, *GetYakScriptByNameRequest) (*YakScript, error)
	GetYakScriptByOnlineID(context.Context, *GetYakScriptByOnlineIDRequest) (*YakScript, error)
	IgnoreYakScript(context.Context, *DeleteYakScriptRequest) (*Empty, error)
	UnIgnoreYakScript(context.Context, *DeleteYakScriptRequest) (*Empty, error)
	ExportYakScript(context.Context, *ExportYakScriptRequest) (*ExportYakScriptResponse, error)
	ExportYakScriptStream(*ExportYakScriptStreamRequest, grpc.ServerStreamingServer[ExecResult]) error
	ImportYakScriptStream(*ImportYakScriptStreamRequest, grpc.ServerStreamingServer[ExecResult]) error
	ExecutePacketYakScript(*ExecutePacketYakScriptParams, grpc.ServerStreamingServer[ExecResult]) error
	ExecuteBatchPacketYakScript(*ExecuteBatchPacketYakScriptParams, grpc.ServerStreamingServer[ExecBatchYakScriptResult]) error
	GetYakScriptTags(context.Context, *Empty) (*GetYakScriptTagsResponse, error)
	QueryYakScriptLocalAndUser(context.Context, *QueryYakScriptLocalAndUserRequest) (*QueryYakScriptLocalAndUserResponse, error)
	QueryYakScriptByOnlineGroup(context.Context, *QueryYakScriptByOnlineGroupRequest) (*QueryYakScriptLocalAndUserResponse, error)
	QueryYakScriptLocalAll(context.Context, *Empty) (*QueryYakScriptLocalAndUserResponse, error)
	QueryYakScriptByNames(context.Context, *QueryYakScriptByNamesRequest) (*QueryYakScriptByNamesResponse, error)
	QueryYakScriptByIsCore(context.Context, *QueryYakScriptByIsCoreRequest) (*QueryYakScriptByIsCoreResponse, error)
	// 接口废弃
	QueryYakScriptRiskDetailByCWE(context.Context, *QueryYakScriptRiskDetailByCWERequest) (*QueryYakScriptRiskDetailByCWEResponse, error)
	// 接口废弃
	YakScriptRiskTypeList(context.Context, *Empty) (*YakScriptRiskTypeListResponse, error)
	SaveNewYakScript(context.Context, *SaveNewYakScriptRequest) (*YakScript, error)
	SaveYakScriptToOnline(*SaveYakScriptToOnlineRequest, grpc.ServerStreamingServer[SaveYakScriptToOnlineResponse]) error
	// 结构变化,接口废弃
	ExportLocalYakScript(context.Context, *ExportLocalYakScriptRequest) (*ExportLocalYakScriptResponse, error)
	ExportLocalYakScriptStream(*ExportLocalYakScriptRequest, grpc.ServerStreamingServer[ExportYakScriptLocalResponse]) error
	ImportYakScript(*ImportYakScriptRequest, grpc.ServerStreamingServer[ImportYakScriptResult]) error
	SetYakScriptSkipUpdate(context.Context, *SetYakScriptSkipUpdateRequest) (*Empty, error)
	QueryYakScriptSkipUpdate(context.Context, *QueryYakScriptRequest) (*QueryYakScriptSkipUpdateResponse, error)
	// YakScript Group
	QueryYakScriptGroup(context.Context, *QueryYakScriptGroupRequest) (*QueryYakScriptGroupResponse, error)
	SaveYakScriptGroup(context.Context, *SaveYakScriptGroupRequest) (*Empty, error)
	RenameYakScriptGroup(context.Context, *RenameYakScriptGroupRequest) (*Empty, error)
	DeleteYakScriptGroup(context.Context, *DeleteYakScriptGroupRequest) (*Empty, error)
	GetYakScriptGroup(context.Context, *QueryYakScriptRequest) (*GetYakScriptGroupResponse, error)
	ResetYakScriptGroup(context.Context, *ResetYakScriptGroupRequest) (*Empty, error)
	SetGroup(context.Context, *SetGroupRequest) (*Empty, error)
	// HTTPFlow
	GetHTTPFlowByHash(context.Context, *GetHTTPFlowByHashRequest) (*HTTPFlow, error)
	GetHTTPFlowById(context.Context, *GetHTTPFlowByIdRequest) (*HTTPFlow, error)
	GetHTTPFlowBodyById(*GetHTTPFlowBodyByIdRequest, grpc.ServerStreamingServer[GetHTTPFlowBodyByIdResponse]) error
	GetHTTPFlowByIds(context.Context, *GetHTTPFlowByIdsRequest) (*HTTPFlows, error)
	QueryHTTPFlows(context.Context, *QueryHTTPFlowRequest) (*QueryHTTPFlowResponse, error)
	DeleteHTTPFlows(context.Context, *DeleteHTTPFlowRequest) (*Empty, error)
	SetTagForHTTPFlow(context.Context, *SetTagForHTTPFlowRequest) (*Empty, error)
	QueryHTTPFlowsIds(context.Context, *QueryHTTPFlowsIdsRequest) (*QueryHTTPFlowsIdsResponse, error)
	HTTPFlowsFieldGroup(context.Context, *HTTPFlowsFieldGroupRequest) (*HTTPFlowsFieldGroupResponse, error)
	HTTPFlowsShare(context.Context, *HTTPFlowsShareRequest) (*HTTPFlowsShareResponse, error)
	HTTPFlowsExtract(context.Context, *HTTPFlowsExtractRequest) (*Empty, error)
	GetHTTPFlowBare(context.Context, *HTTPFlowBareRequest) (*HTTPFlowBareResponse, error)
	ExportHTTPFlows(context.Context, *ExportHTTPFlowsRequest) (*QueryHTTPFlowResponse, error)
	HTTPFlowsToOnline(context.Context, *HTTPFlowsToOnlineRequest) (*Empty, error)
	QueryHTTPFlowsProcessNames(context.Context, *QueryHTTPFlowRequest) (*QueryHTTPFlowsProcessNamesResponse, error)
	// 流量分析器
	AnalyzeHTTPFlow(*AnalyzeHTTPFlowRequest, grpc.ServerStreamingServer[AnalyzeHTTPFlowResponse]) error
	// 从一个 FuzzerRequest 中提取 Url
	ExtractUrl(context.Context, *FuzzerRequest) (*ExtractedUrl, error)
	// Fuzzer
	GetHistoryHTTPFuzzerTask(context.Context, *GetHistoryHTTPFuzzerTaskRequest) (*HistoryHTTPFuzzerTaskDetail, error)
	QueryHistoryHTTPFuzzerTask(context.Context, *Empty) (*HistoryHTTPFuzzerTasks, error)
	QueryHistoryHTTPFuzzerTaskEx(context.Context, *QueryHistoryHTTPFuzzerTaskExParams) (*HistoryHTTPFuzzerTasksResponse, error)
	DeleteHistoryHTTPFuzzerTask(context.Context, *DeleteHistoryHTTPFuzzerTaskRequest) (*Empty, error)
	HTTPFuzzer(*FuzzerRequest, grpc.ServerStreamingServer[FuzzerResponse]) error
	HTTPFuzzerSequence(*FuzzerRequests, grpc.ServerStreamingServer[FuzzerSequenceResponse]) error
	PreloadHTTPFuzzerParams(context.Context, *PreloadHTTPFuzzerParamsRequest) (*PreloadHTTPFuzzerParamsResponse, error)
	RenderVariables(context.Context, *RenderVariablesRequest) (*RenderVariablesResponse, error)
	MatchHTTPResponse(context.Context, *MatchHTTPResponseParams) (*MatchHTTPResponseResult, error)
	ExtractHTTPResponse(context.Context, *ExtractHTTPResponseParams) (*ExtractHTTPResponseResult, error)
	RedirectRequest(context.Context, *RedirectRequestParams) (*FuzzerResponse, error)
	HTTPRequestMutate(context.Context, *HTTPRequestMutateParams) (*MutateResult, error)
	HTTPResponseMutate(context.Context, *HTTPResponseMutateParams) (*MutateResult, error)
	FixUploadPacket(context.Context, *FixUploadPacketRequest) (*FixUploadPacketResponse, error)
	IsMultipartFormDataRequest(context.Context, *FixUploadPacketRequest) (*IsMultipartFormDataRequestResult, error)
	GenerateExtractRule(context.Context, *GenerateExtractRuleRequest) (*GenerateExtractRuleResponse, error)
	ExtractData(grpc.BidiStreamingServer[ExtractDataRequest, ExtractDataResponse]) error
	ImportHTTPFuzzerTaskFromYaml(context.Context, *ImportHTTPFuzzerTaskFromYamlRequest) (*ImportHTTPFuzzerTaskFromYamlResponse, error)
	ExportHTTPFuzzerTaskToYaml(context.Context, *ExportHTTPFuzzerTaskToYamlRequest) (*ExportHTTPFuzzerTaskToYamlResponse, error)
	RenderHTTPFuzzerPacket(context.Context, *RenderHTTPFuzzerPacketRequest) (*RenderHTTPFuzzerPacketResponse, error)
	SaveFuzzerLabel(context.Context, *SaveFuzzerLabelRequest) (*Empty, error)
	QueryFuzzerLabel(context.Context, *Empty) (*QueryFuzzerLabelResponse, error)
	DeleteFuzzerLabel(context.Context, *DeleteFuzzerLabelRequest) (*Empty, error)
	SaveFuzzerConfig(context.Context, *SaveFuzzerConfigRequest) (*DbOperateMessage, error)
	QueryFuzzerConfig(context.Context, *QueryFuzzerConfigRequest) (*QueryFuzzerConfigResponse, error)
	DeleteFuzzerConfig(context.Context, *DeleteFuzzerConfigRequest) (*DbOperateMessage, error)
	// HTTPFuzzerResponse
	// 这个挺特殊的，因为数据包太多了，会卡，所以后端会保存一份，通过这个接口做缓存查询
	QueryHTTPFuzzerResponseByTaskId(context.Context, *QueryHTTPFuzzerResponseByTaskIdRequest) (*QueryHTTPFuzzerResponseByTaskIdResponse, error)
	// WebSocket
	CreateWebsocketFuzzer(grpc.BidiStreamingServer[ClientWebsocketRequest, ClientWebsocketResponse]) error
	QueryWebsocketFlowByHTTPFlowWebsocketHash(context.Context, *QueryWebsocketFlowByHTTPFlowWebsocketHashRequest) (*WebsocketFlows, error)
	DeleteWebsocketFlowByHTTPFlowWebsocketHash(context.Context, *DeleteWebsocketFlowByHTTPFlowWebsocketHashRequest) (*Empty, error)
	DeleteWebsocketFlowAll(context.Context, *Empty) (*Empty, error)
	// FuzzerResponse 对象转 HTTPFlow：以便分析和模糊测试
	ConvertFuzzerResponseToHTTPFlow(context.Context, *FuzzerResponse) (*HTTPFlow, error)
	// 渲染 Fuzzer 模版
	StringFuzzer(context.Context, *StringFuzzerRequest) (*StringFuzzerResponse, error)
	// 分析一个 HTTP 请求详情
	HTTPRequestAnalyzer(context.Context, *HTTPRequestAnalysisMaterial) (*HTTPRequestAnalysis, error)
	// 编码解码
	Codec(context.Context, *CodecRequest) (*CodecResponse, error)
	NewCodec(context.Context, *CodecRequestFlow) (*CodecResponse, error)
	GetAllCodecMethods(context.Context, *Empty) (*CodecMethods, error)
	SaveCodecFlow(context.Context, *CustomizeCodecFlow) (*Empty, error)
	DeleteCodecFlow(context.Context, *DeleteCodecFlowRequest) (*Empty, error)
	GetAllCodecFlow(context.Context, *Empty) (*GetCodecFlowResponse, error)
	PacketPrettifyHelper(context.Context, *PacketPrettifyHelperRequest) (*PacketPrettifyHelperResponse, error)
	// Payload 相关接口
	// database payload group
	QueryPayload(context.Context, *QueryPayloadRequest) (*QueryPayloadResponse, error)
	QueryPayloadFromFile(context.Context, *QueryPayloadFromFileRequest) (*QueryPayloadFromFileResponse, error)
	// delete by [id/group/folder]
	DeletePayloadByFolder(context.Context, *NameRequest) (*Empty, error)
	DeletePayloadByGroup(context.Context, *DeletePayloadByGroupRequest) (*Empty, error)
	DeletePayload(context.Context, *DeletePayloadRequest) (*Empty, error)
	// save payload to database
	SavePayload(context.Context, *SavePayloadRequest) (*Empty, error)
	SavePayloadStream(*SavePayloadRequest, grpc.ServerStreamingServer[SavePayloadProgress]) error
	SavePayloadToFileStream(*SavePayloadRequest, grpc.ServerStreamingServer[SavePayloadProgress]) error
	SaveLargePayloadToFileStream(*SavePayloadRequest, grpc.ServerStreamingServer[SavePayloadProgress]) error
	// update group/folder/payload
	RenamePayloadFolder(context.Context, *RenameRequest) (*Empty, error)
	RenamePayloadGroup(context.Context, *RenameRequest) (*Empty, error)
	UpdatePayload(context.Context, *UpdatePayloadRequest) (*Empty, error)
	UpdatePayloadToFile(context.Context, *UpdatePayloadToFileRequest) (*Empty, error)
	BackUpOrCopyPayloads(context.Context, *BackUpOrCopyPayloadsRequest) (*Empty, error)
	// Folder and Group
	// get and update all group with order
	GetAllPayloadGroup(context.Context, *Empty) (*GetAllPayloadGroupResponse, error)
	UpdateAllPayloadGroup(context.Context, *UpdateAllPayloadGroupRequest) (*Empty, error)
	// get payload
	GetAllPayload(context.Context, *GetAllPayloadRequest) (*GetAllPayloadResponse, error)
	GetAllPayloadFromFile(*GetAllPayloadRequest, grpc.ServerStreamingServer[GetAllPayloadFromFileResponse]) error
	// export payload
	ExportAllPayload(*GetAllPayloadRequest, grpc.ServerStreamingServer[GetAllPayloadResponse]) error
	ExportAllPayloadFromFile(*GetAllPayloadRequest, grpc.ServerStreamingServer[GetAllPayloadResponse]) error
	// create folder
	CreatePayloadFolder(context.Context, *NameRequest) (*Empty, error)
	// 去重
	RemoveDuplicatePayloads(*NameRequest, grpc.ServerStreamingServer[SavePayloadProgress]) error
	// 转换为数据库保存
	CoverPayloadGroupToDatabase(*NameRequest, grpc.ServerStreamingServer[SavePayloadProgress]) error
	ConvertPayloadGroupToDatabase(*NameRequest, grpc.ServerStreamingServer[SavePayloadProgress]) error
	// 迁移旧的payload
	MigratePayloads(*Empty, grpc.ServerStreamingServer[SavePayloadProgress]) error
	// 自动生成补全
	GetYakitCompletionRaw(context.Context, *Empty) (*YakitCompletionRawResponse, error)
	GetYakVMBuildInMethodCompletion(context.Context, *GetYakVMBuildInMethodCompletionRequest) (*GetYakVMBuildInMethodCompletionResponse, error)
	StaticAnalyzeError(context.Context, *StaticAnalyzeErrorRequest) (*StaticAnalyzeErrorResponse, error)
	YaklangCompileAndFormat(context.Context, *YaklangCompileAndFormatRequest) (*YaklangCompileAndFormatResponse, error)
	// LSP
	YaklangLanguageSuggestion(context.Context, *YaklangLanguageSuggestionRequest) (*YaklangLanguageSuggestionResponse, error)
	YaklangLanguageFind(context.Context, *YaklangLanguageSuggestionRequest) (*YaklangLanguageFindResponse, error)
	// fuzztag suggestion
	FuzzTagSuggestion(context.Context, *FuzzTagSuggestionRequest) (*YaklangLanguageSuggestionResponse, error)
	// 从代码中提取yaklang数据
	YaklangInspectInformation(context.Context, *YaklangInspectInformationRequest) (*YaklangInspectInformationResponse, error)
	// 进行数据迁移使用
	YaklangGetCliCodeFromDatabase(context.Context, *YaklangGetCliCodeFromDatabaseRequest) (*YaklangGetCliCodeFromDatabaseResponse, error)
	// editor terminal 交互
	YaklangTerminal(grpc.BidiStreamingServer[Input, Output]) error
	// 端口扫描的封装
	PortScan(*PortScanRequest, grpc.ServerStreamingServer[ExecResult]) error
	ViewPortScanCode(context.Context, *Empty) (*SimpleScript, error)
	SimpleDetect(*RecordPortScanRequest, grpc.ServerStreamingServer[ExecResult]) error
	SaveCancelSimpleDetect(context.Context, *RecordPortScanRequest) (*Empty, error)
	SimpleDetectCreatReport(*CreatReportRequest, grpc.ServerStreamingServer[ExecResult]) error
	// new interface
	QuerySimpleDetectUnfinishedTask(context.Context, *QueryUnfinishedTaskRequest) (*QueryUnfinishedTaskResponse, error)
	GetSimpleDetectRecordRequestById(context.Context, *GetUnfinishedTaskDetailByIdRequest) (*RecordPortScanRequest, error)
	DeleteSimpleDetectUnfinishedTask(context.Context, *DeleteUnfinishedTaskRequest) (*Empty, error)
	RecoverSimpleDetectTask(*RecoverUnfinishedTaskRequest, grpc.ServerStreamingServer[ExecResult]) error
	// Deprecated interface
	GetSimpleDetectUnfinishedTask(context.Context, *Empty) (*GetSimpleDetectUnfinishedTaskResponse, error)
	GetSimpleDetectUnfinishedTaskByUid(context.Context, *GetExecBatchYakScriptUnfinishedTaskByUidRequest) (*RecordPortScanRequest, error)
	PopSimpleDetectUnfinishedTaskByUid(context.Context, *GetExecBatchYakScriptUnfinishedTaskByUidRequest) (*RecordPortScanRequest, error)
	RecoverSimpleDetectUnfinishedTask(*RecoverExecBatchYakScriptUnfinishedTaskRequest, grpc.ServerStreamingServer[ExecResult]) error
	// 资产管理
	QueryPorts(context.Context, *QueryPortsRequest) (*QueryPortsResponse, error)
	DeletePorts(context.Context, *DeletePortsRequest) (*Empty, error)
	QueryHosts(context.Context, *QueryHostsRequest) (*QueryHostsResponse, error)
	DeleteHosts(context.Context, *DeleteHostsRequest) (*Empty, error)
	QueryDomains(context.Context, *QueryDomainsRequest) (*QueryDomainsResponse, error)
	DeleteDomains(context.Context, *DeleteDomainsRequest) (*Empty, error)
	QueryPortsGroup(context.Context, *Empty) (*QueryPortsGroupResponse, error)
	// Yakit Store
	UpdateFromYakitResource(context.Context, *UpdateFromYakitResourceRequest) (*Empty, error)
	UpdateFromGithub(context.Context, *UpdateFromGithubRequest) (*Empty, error)
	// Menu
	AddToMenu(context.Context, *AddToMenuRequest) (*Empty, error)
	RemoveFromMenu(context.Context, *RemoveFromMenuRequest) (*Empty, error)
	YakScriptIsInMenu(context.Context, *YakScriptIsInMenuRequest) (*Empty, error)
	GetAllMenuItem(context.Context, *Empty) (*MenuByGroup, error)
	DeleteAllMenuItem(context.Context, *Empty) (*Empty, error)
	ImportMenuItem(context.Context, *ImportMenuItemRequest) (*Empty, error)
	ExportMenuItem(context.Context, *Empty) (*ExportMenuItemResult, error)
	GetMenuItemById(context.Context, *GetMenuItemByIdRequest) (*MenuItem, error)
	QueryGroupsByYakScriptId(context.Context, *QueryGroupsByYakScriptIdRequest) (*GroupNames, error)
	AddMenus(context.Context, *AddMenuRequest) (*Empty, error)
	QueryAllMenuItem(context.Context, *QueryAllMenuItemRequest) (*MenuByGroup, error)
	DeleteAllMenu(context.Context, *QueryAllMenuItemRequest) (*Empty, error)
	// NewMenu
	AddToNavigation(context.Context, *AddToNavigationRequest) (*Empty, error)
	GetAllNavigationItem(context.Context, *GetAllNavigationRequest) (*GetAllNavigationItemResponse, error)
	DeleteAllNavigation(context.Context, *GetAllNavigationRequest) (*Empty, error)
	AddOneNavigation(context.Context, *AddOneNavigationRequest) (*Empty, error)
	QueryNavigationGroups(context.Context, *QueryNavigationGroupsRequest) (*GroupNames, error)
	// document
	SaveMarkdownDocument(context.Context, *SaveMarkdownDocumentRequest) (*Empty, error)
	GetMarkdownDocument(context.Context, *GetMarkdownDocumentRequest) (*GetMarkdownDocumentResponse, error)
	DeleteMarkdownDocument(context.Context, *GetMarkdownDocumentRequest) (*Empty, error)
	// Crawler
	StartBasicCrawler(context.Context, *StartBasicCrawlerRequest) (*ExecResult, error)
	ViewBasicCrawlerCode(context.Context, *Empty) (*SimpleScript, error)
	GenerateWebsiteTree(context.Context, *GenerateWebsiteTreeRequest) (*GenerateWebsiteTreeResponse, error)
	// 对插件结果的操作
	QueryYakScriptExecResult(context.Context, *QueryYakScriptExecResultRequest) (*QueryYakScriptExecResultResponse, error)
	QueryYakScriptNameInExecResult(context.Context, *Empty) (*YakScriptNames, error)
	DeleteYakScriptExecResult(context.Context, *DeleteYakScriptExecResultRequest) (*Empty, error)
	DeleteYakScriptExec(context.Context, *Empty) (*Empty, error)
	// Bruter
	StartBrute(*StartBruteParams, grpc.ServerStreamingServer[ExecResult]) error
	GetAvailableBruteTypes(context.Context, *Empty) (*GetAvailableBruteTypesResponse, error)
	// Tunnel Server RMI/DNSLog
	GetTunnelServerExternalIP(context.Context, *GetTunnelServerExternalIPParams) (*GetTunnelServerExternalIPResponse, error)
	VerifyTunnelServerDomain(context.Context, *VerifyTunnelServerDomainParams) (*VerifyTunnelServerDomainResponse, error)
	StartFacades(*StartFacadesParams, grpc.ServerStreamingServer[ExecResult]) error
	StartFacadesWithYsoObject(*StartFacadesWithYsoParams, grpc.ServerStreamingServer[ExecResult]) error
	ApplyClassToFacades(context.Context, *ApplyClassToFacadesParamsWithVerbose) (*Empty, error)
	BytesToBase64(context.Context, *BytesToBase64Request) (*BytesToBase64Response, error)
	ConfigGlobalReverse(*ConfigGlobalReverseParams, grpc.ServerStreamingServer[Empty]) error
	AvailableLocalAddr(context.Context, *Empty) (*AvailableLocalAddrResponse, error)
	GetGlobalReverseServer(context.Context, *Empty) (*GetGlobalReverseServerResponse, error)
	// Risk
	QueryRisks(context.Context, *QueryRisksRequest) (*QueryRisksResponse, error)
	QueryRisk(context.Context, *QueryRiskRequest) (*Risk, error)
	DeleteRisk(context.Context, *DeleteRiskRequest) (*Empty, error)
	QueryAvailableRiskType(context.Context, *Empty) (*Fields, error)
	QueryAvailableRiskLevel(context.Context, *Empty) (*Fields, error)
	QueryRiskTableStats(context.Context, *Empty) (*RiskTableStats, error)
	ResetRiskTableStats(context.Context, *Empty) (*Empty, error)
	QueryAvailableTarget(context.Context, *Empty) (*Fields, error)
	QueryNewRisk(context.Context, *QueryNewRiskRequest) (*QueryNewRiskResponse, error)
	NewRiskRead(context.Context, *NewRiskReadRequest) (*Empty, error)
	// 风险漏洞自动同步
	UploadRiskToOnline(context.Context, *UploadRiskToOnlineRequest) (*Empty, error)
	SetTagForRisk(context.Context, *SetTagForRiskRequest) (*Empty, error)
	QueryRiskTags(context.Context, *Empty) (*QueryRiskTagsResponse, error)
	RiskFieldGroup(context.Context, *Empty) (*RiskFieldGroupResponse, error)
	// 误报反馈
	RiskFeedbackToOnline(context.Context, *UploadRiskToOnlineRequest) (*Empty, error)
	// Report
	QueryReports(context.Context, *QueryReportsRequest) (*QueryReportsResponse, error)
	QueryReport(context.Context, *QueryReportRequest) (*Report, error)
	DeleteReport(context.Context, *DeleteReportRequest) (*Empty, error)
	QueryAvailableReportFrom(context.Context, *Empty) (*Fields, error)
	DownloadReport(context.Context, *DownloadReportRequest) (*Empty, error)
	// Yso
	GetAllYsoGadgetOptions(context.Context, *Empty) (*YsoOptionsWithVerbose, error)
	GetAllYsoClassOptions(context.Context, *YsoOptionsRequerstWithVerbose) (*YsoOptionsWithVerbose, error)
	GetAllYsoClassGeneraterOptions(context.Context, *YsoOptionsRequerstWithVerbose) (*YsoClassOptionsResponseWithVerbose, error)
	GenerateYsoCode(context.Context, *YsoOptionsRequerstWithVerbose) (*YsoCodeResponse, error)
	GenerateYsoBytes(context.Context, *YsoOptionsRequerstWithVerbose) (*YsoBytesResponse, error)
	YsoDump(context.Context, *YsoBytesObject) (*YsoDumpResponse, error)
	// WebShell
	CreateWebShell(context.Context, *WebShell) (*WebShell, error)
	DeleteWebShell(context.Context, *DeleteWebShellRequest) (*Empty, error)
	UpdateWebShell(context.Context, *WebShell) (*WebShell, error)
	QueryWebShells(context.Context, *QueryWebShellsRequest) (*QueryWebShellsResponse, error)
	Ping(context.Context, *WebShellRequest) (*WebShellResponse, error)
	GetBasicInfo(context.Context, *WebShellRequest) (*WebShellResponse, error)
	GenerateWebShell(context.Context, *ShellGenerate) (*WebShellResponse, error)
	// DNSLog / ICMP / RandomTrigger
	SetYakBridgeLogServer(context.Context, *YakDNSLogBridgeAddr) (*Empty, error)
	GetCurrentYakBridgeLogServer(context.Context, *Empty) (*YakDNSLogBridgeAddr, error)
	RequireDNSLogDomain(context.Context, *YakDNSLogBridgeAddr) (*DNSLogRootDomain, error)
	RequireDNSLogDomainByScript(context.Context, *RequireDNSLogDomainByScriptRequest) (*DNSLogRootDomain, error)
	QueryDNSLogByToken(context.Context, *QueryDNSLogByTokenRequest) (*QueryDNSLogByTokenResponse, error)
	QueryDNSLogTokenByScript(context.Context, *RequireDNSLogDomainByScriptRequest) (*QueryDNSLogByTokenResponse, error)
	RequireICMPRandomLength(context.Context, *Empty) (*RequireICMPRandomLengthResponse, error)
	QueryICMPTrigger(context.Context, *QueryICMPTriggerRequest) (*QueryICMPTriggerResponse, error)
	RequireRandomPortToken(context.Context, *Empty) (*RandomPortInfo, error)
	QueryRandomPortTrigger(context.Context, *QueryRandomPortTriggerRequest) (*RandomPortTriggerNotification, error)
	QuerySupportedDnsLogPlatforms(context.Context, *Empty) (*QuerySupportedDnsLogPlatformsResponse, error)
	// 获取 Tags
	GetAvailableYakScriptTags(context.Context, *Empty) (*Fields, error)
	ForceUpdateAvailableYakScriptTags(context.Context, *Empty) (*Empty, error)
	// 通用的漏洞检测技术方案
	ExecYakitPluginsByYakScriptFilter(*ExecYakitPluginsByYakScriptFilterRequest, grpc.ServerStreamingServer[ExecResult]) error
	// GenerateYakCodeByPacket
	GenerateYakCodeByPacket(context.Context, *GenerateYakCodeByPacketRequest) (*GenerateYakCodeByPacketResponse, error)
	// CSRF Generator
	GenerateCSRFPocByPacket(context.Context, *GenerateCSRFPocByPacketRequest) (*GenerateCSRFPocByPacketResponse, error)
	// MITM 衍生功能：
	// Replacers 管理
	ExportMITMReplacerRules(context.Context, *Empty) (*ExportMITMReplacerRulesResponse, error)
	ImportMITMReplacerRules(context.Context, *ImportMITMReplacerRulesRequest) (*Empty, error)
	GetCurrentRules(context.Context, *Empty) (*MITMContentReplacers, error)
	SetCurrentRules(context.Context, *MITMContentReplacers) (*Empty, error)
	GenerateURL(context.Context, *GenerateURLRequest) (*GenerateURLResponse, error)
	ExtractDataToFile(grpc.BidiStreamingServer[ExtractDataToFileRequest, ExtractDataToFileResult]) error
	// 尝试自动解码
	AutoDecode(context.Context, *AutoDecodeRequest) (*AutoDecodeResponse, error)
	GetSystemProxy(context.Context, *Empty) (*GetSystemProxyResult, error)
	SetSystemProxy(context.Context, *SetSystemProxyRequest) (*Empty, error)
	// 设置通用存储
	GetKey(context.Context, *GetKeyRequest) (*GetKeyResult, error)
	SetKey(context.Context, *SetKeyRequest) (*Empty, error)
	DelKey(context.Context, *GetKeyRequest) (*Empty, error)
	GetAllProcessEnvKey(context.Context, *Empty) (*GetProcessEnvKeyResult, error)
	SetProcessEnvKey(context.Context, *SetKeyRequest) (*Empty, error)
	GetProjectKey(context.Context, *GetKeyRequest) (*GetKeyResult, error)
	SetProjectKey(context.Context, *SetKeyRequest) (*Empty, error)
	// Online
	GetOnlineProfile(context.Context, *Empty) (*OnlineProfile, error)
	SetOnlineProfile(context.Context, *OnlineProfile) (*Empty, error)
	// 废弃接口
	DownloadOnlinePluginById(context.Context, *DownloadOnlinePluginByIdRequest) (*Empty, error)
	// 废弃接口
	DownloadOnlinePluginByIds(context.Context, *DownloadOnlinePluginByIdsRequest) (*Empty, error)
	// 废弃接口
	DownloadOnlinePluginAll(*DownloadOnlinePluginByTokenRequest, grpc.ServerStreamingServer[DownloadOnlinePluginProgress]) error
	DeletePluginByUserID(context.Context, *DeletePluginByUserIDRequest) (*Empty, error)
	DeleteAllLocalPlugins(context.Context, *Empty) (*Empty, error)
	GetYakScriptTagsAndType(context.Context, *Empty) (*GetYakScriptTagsAndTypeResponse, error)
	DeleteLocalPluginsByWhere(context.Context, *DeleteLocalPluginsByWhereRequest) (*Empty, error)
	// 废弃接口
	DownloadOnlinePluginByScriptNames(context.Context, *DownloadOnlinePluginByScriptNamesRequest) (*DownloadOnlinePluginByScriptNamesResponse, error)
	// NewOnline 插件下载
	DownloadOnlinePlugins(*DownloadOnlinePluginsRequest, grpc.ServerStreamingServer[DownloadOnlinePluginProgress]) error
	DownloadOnlinePluginBatch(context.Context, *DownloadOnlinePluginsRequest) (*Empty, error)
	DownloadOnlinePluginByPluginName(context.Context, *DownloadOnlinePluginByScriptNamesRequest) (*DownloadOnlinePluginByScriptNamesResponse, error)
	DownloadOnlinePluginByUUID(context.Context, *DownloadOnlinePluginByUUIDRequest) (*YakScript, error)
	QueryOnlinePlugins(context.Context, *QueryOnlinePluginsRequest) (*QueryOnlinePluginsResponse, error)
	// 新的扫描模式
	ExecPacketScan(*ExecPacketScanRequest, grpc.ServerStreamingServer[ExecResult]) error
	GetEngineDefaultProxy(context.Context, *Empty) (*DefaultProxyResult, error)
	SetEngineDefaultProxy(context.Context, *DefaultProxyResult) (*Empty, error)
	// machine id
	GetMachineID(context.Context, *Empty) (*GetMachineIDResponse, error)
	// license
	GetLicense(context.Context, *Empty) (*GetLicenseResponse, error)
	CheckLicense(context.Context, *CheckLicenseRequest) (*Empty, error)
	// Response Body 的魔法操作
	GetRequestBodyByHTTPFlowID(context.Context, *DownloadBodyByHTTPFlowIDRequest) (*Bytes, error)
	GetResponseBodyByHTTPFlowID(context.Context, *DownloadBodyByHTTPFlowIDRequest) (*Bytes, error)
	GetHTTPPacketBody(context.Context, *GetHTTPPacketBodyRequest) (*Bytes, error)
	// 注册一个 Facades HTTP 响应
	RegisterFacadesHTTP(context.Context, *RegisterFacadesHTTPRequest) (*RegisterFacadesHTTPResponse, error)
	// 重置到恢复出厂设置
	ResetAndInvalidUserData(context.Context, *ResetAndInvalidUserDataRequest) (*Empty, error)
	// Yaklang Shell
	// 创建一个交互式 Shell
	CreateYaklangShell(grpc.BidiStreamingServer[YaklangShellRequest, YaklangShellResponse]) error
	// 接入标准输出和标准错误流
	AttachCombinedOutput(*AttachCombinedOutputRequest, grpc.ServerStreamingServer[ExecResult]) error
	// 判断当前引擎对网卡是否有操作权限？
	// 主要是能否发包等敏感操作
	// Windows 判断是否是管理员即可 I Am Admin
	// Linux 和 MacOS 应该尝试 pcap 打开网卡就行
	IsPrivilegedForNetRaw(context.Context, *Empty) (*IsPrivilegedForNetRawResponse, error)
	PromotePermissionForUserPcap(context.Context, *Empty) (*Empty, error)
	// 操作项目的相关接口，通过设置 ProjectDatabase
	SetCurrentProject(context.Context, *SetCurrentProjectRequest) (*Empty, error)
	GetCurrentProject(context.Context, *Empty) (*ProjectDescription, error)
	GetCurrentProjectEx(context.Context, *GetCurrentProjectExRequest) (*ProjectDescription, error)
	GetProjects(context.Context, *GetProjectsRequest) (*GetProjectsResponse, error)
	NewProject(context.Context, *NewProjectRequest) (*NewProjectResponse, error)
	UpdateProject(context.Context, *NewProjectRequest) (*NewProjectResponse, error)
	IsProjectNameValid(context.Context, *IsProjectNameValidRequest) (*Empty, error)
	RemoveProject(context.Context, *RemoveProjectRequest) (*Empty, error)
	DeleteProject(context.Context, *DeleteProjectRequest) (*Empty, error)
	GetDefaultProject(context.Context, *Empty) (*ProjectDescription, error)
	GetDefaultProjectEx(context.Context, *GetDefaultProjectExRequest) (*ProjectDescription, error)
	QueryProjectDetail(context.Context, *QueryProjectDetailRequest) (*ProjectDescription, error)
	GetTemporaryProject(context.Context, *Empty) (*ProjectDescription, error)
	GetTemporaryProjectEx(context.Context, *GetTemporaryProjectExRequest) (*ProjectDescription, error)
	// 导入导出项目，带密码，带进度
	ExportProject(*ExportProjectRequest, grpc.ServerStreamingServer[ProjectIOProgress]) error
	ImportProject(*ImportProjectRequest, grpc.ServerStreamingServer[ProjectIOProgress]) error
	// 迁移旧数据库
	MigrateLegacyDatabase(context.Context, *Empty) (*Empty, error)
	// 从规则中提取数据
	QueryMITMRuleExtractedData(context.Context, *QueryMITMRuleExtractedDataRequest) (*QueryMITMRuleExtractedDataResponse, error)
	ExportMITMRuleExtractedData(*ExportMITMRuleExtractedDataRequest, grpc.ServerStreamingServer[ExportMITMRuleExtractedDataResponse]) error
	// ChaosMakerRule: Bas
	ImportChaosMakerRules(context.Context, *ImportChaosMakerRulesRequest) (*Empty, error)
	QueryChaosMakerRule(context.Context, *QueryChaosMakerRuleRequest) (*QueryChaosMakerRuleResponse, error)
	DeleteChaosMakerRuleByID(context.Context, *DeleteChaosMakerRuleByIDRequest) (*Empty, error)
	ExecuteChaosMakerRule(*ExecuteChaosMakerRuleRequest, grpc.ServerStreamingServer[ExecResult]) error
	// 这个接口是判断 BAS Agent 远程端口是否可用的，使用 Vulinbox ws agent 协议连接
	// ConnectVulinboxAgent is the same as IsRemoteAddrAvailable
	IsRemoteAddrAvailable(context.Context, *IsRemoteAddrAvailableRequest) (*IsRemoteAddrAvailableResponse, error)
	ConnectVulinboxAgent(context.Context, *IsRemoteAddrAvailableRequest) (*IsRemoteAddrAvailableResponse, error)
	// vulinbox agent 的操作接口
	GetRegisteredVulinboxAgent(context.Context, *GetRegisteredAgentRequest) (*GetRegisteredAgentResponse, error)
	DisconnectVulinboxAgent(context.Context, *DisconnectVulinboxAgentRequest) (*Empty, error)
	// CVE
	IsCVEDatabaseReady(context.Context, *IsCVEDatabaseReadyRequest) (*IsCVEDatabaseReadyResponse, error)
	UpdateCVEDatabase(*UpdateCVEDatabaseRequest, grpc.ServerStreamingServer[ExecResult]) error
	ExportsProfileDatabase(*ExportsProfileDatabaseRequest, grpc.ServerStreamingServer[ExecResult]) error
	ImportsProfileDatabase(*ImportsProfileDatabaseRequest, grpc.ServerStreamingServer[ExecResult]) error
	QueryCVE(context.Context, *QueryCVERequest) (*QueryCVEResponse, error)
	GetCVE(context.Context, *GetCVERequest) (*CVEDetailEx, error)
	SaveTextToTemporalFile(context.Context, *SaveTextToTemporalFileRequest) (*SaveTextToTemporalFileResponse, error)
	// Screcorder
	IsScrecorderReady(context.Context, *IsScrecorderReadyRequest) (*IsScrecorderReadyResponse, error)
	InstallScrecorder(*InstallScrecorderRequest, grpc.ServerStreamingServer[ExecResult]) error
	StartScrecorder(*StartScrecorderRequest, grpc.ServerStreamingServer[ExecResult]) error
	QueryScreenRecorders(context.Context, *QueryScreenRecorderRequest) (*QueryScreenRecorderResponse, error)
	DeleteScreenRecorders(context.Context, *QueryScreenRecorderRequest) (*Empty, error)
	UploadScreenRecorders(context.Context, *UploadScreenRecorderRequest) (*Empty, error)
	GetOneScreenRecorders(context.Context, *GetOneScreenRecorderRequest) (*ScreenRecorder, error)
	UpdateScreenRecorders(context.Context, *UpdateScreenRecorderRequest) (*Empty, error)
	// Vulinbox
	IsVulinboxReady(context.Context, *IsVulinboxReadyRequest) (*IsVulinboxReadyResponse, error)
	InstallVulinbox(*InstallVulinboxRequest, grpc.ServerStreamingServer[ExecResult]) error
	StartVulinbox(*StartVulinboxRequest, grpc.ServerStreamingServer[ExecResult]) error
	GenQualityInspectionReport(*GenQualityInspectionReportRequest, grpc.ServerStreamingServer[ExecResult]) error
	// 通过他可以构造一个 HTTP 请求
	// 这个请求可能是一个，也可能是一系列
	// 一般用来调试插件等
	HTTPRequestBuilder(context.Context, *HTTPRequestBuilderParams) (*HTTPRequestBuilderResponse, error)
	// rpc QueryHTTPRequestBuilder(QueryHTTPRequestBuilderRequest) returns (QueryHTTPRequestBuilderResponse);
	// rpc DeleteHTTPRequestBuilder(DeleteHTTPRequestBuilderRequest) returns (Empty);
	DebugPlugin(*DebugPluginRequest, grpc.ServerStreamingServer[ExecResult]) error
	SmokingEvaluatePlugin(context.Context, *SmokingEvaluatePluginRequest) (*SmokingEvaluatePluginResponse, error)
	SmokingEvaluatePluginBatch(*SmokingEvaluatePluginBatchRequest, grpc.ServerStreamingServer[SmokingEvaluatePluginBatchResponse]) error
	GetSystemDefaultDnsServers(context.Context, *Empty) (*DefaultDnsServerResponse, error)
	// 诊断网络发生的问题
	DiagnoseNetwork(*DiagnoseNetworkRequest, grpc.ServerStreamingServer[DiagnoseNetworkResponse]) error
	DiagnoseNetworkDNS(*DiagnoseNetworkDNSRequest, grpc.ServerStreamingServer[DiagnoseNetworkResponse]) error
	TraceRoute(*TraceRouteRequest, grpc.ServerStreamingServer[TraceRouteResponse]) error
	// Global Network Config
	GetGlobalNetworkConfig(context.Context, *GetGlobalNetworkConfigRequest) (*GlobalNetworkConfig, error)
	SetGlobalNetworkConfig(context.Context, *GlobalNetworkConfig) (*Empty, error)
	ResetGlobalNetworkConfig(context.Context, *ResetGlobalNetworkConfigRequest) (*Empty, error)
	ValidP12PassWord(context.Context, *ValidP12PassWordRequest) (*ValidP12PassWordResponse, error)
	// YAKURL
	RequestYakURL(context.Context, *RequestYakURLParams) (*RequestYakURLResponse, error)
	// 文件IO
	ReadFile(*ReadFileRequest, grpc.ServerStreamingServer[ReadFileResponse]) error
	// Wireshark
	GetPcapMetadata(context.Context, *PcapMetadataRequest) (*PcapMetadata, error)
	PcapX(grpc.BidiStreamingServer[PcapXRequest, PcapXResponse]) error
	QueryTrafficSession(context.Context, *QueryTrafficSessionRequest) (*QueryTrafficSessionResponse, error)
	QueryTrafficPacket(context.Context, *QueryTrafficPacketRequest) (*QueryTrafficPacketResponse, error)
	QueryTrafficTCPReassembled(context.Context, *QueryTrafficTCPReassembledRequest) (*QueryTrafficTCPReassembledResponse, error)
	ParseTraffic(context.Context, *ParseTrafficRequest) (*ParseTrafficResponse, error)
	// 与前端交互的双工长连接，用于通知某些消息
	DuplexConnection(grpc.BidiStreamingServer[DuplexConnectionRequest, DuplexConnectionResponse]) error
	// 混合批量扫描
	HybridScan(grpc.BidiStreamingServer[HybridScanRequest, HybridScanResponse]) error
	QueryHybridScanTask(context.Context, *QueryHybridScanTaskRequest) (*QueryHybridScanTaskResponse, error)
	DeleteHybridScanTask(context.Context, *DeleteHybridScanTaskRequest) (*Empty, error)
	GetSpaceEngineStatus(context.Context, *GetSpaceEngineStatusRequest) (*SpaceEngineStatus, error)
	// 由于第三方应用配置改为从后端动态的获取表单字段名，所以弃用此接口改用GetSpaceEngineAccountStatusV2
	GetSpaceEngineAccountStatus(context.Context, *GetSpaceEngineAccountStatusRequest) (*SpaceEngineStatus, error)
	GetSpaceEngineAccountStatusV2(context.Context, *ThirdPartyApplicationConfig) (*SpaceEngineStatus, error)
	FetchPortAssetFromSpaceEngine(*FetchPortAssetFromSpaceEngineRequest, grpc.ServerStreamingServer[ExecResult]) error
	// 表达式执行
	EvaluateExpression(context.Context, *EvaluateExpressionRequest) (*EvaluateExpressionResponse, error)
	EvaluateMultiExpression(context.Context, *EvaluateMultiExpressionRequest) (*EvaluateMultiExpressionResponse, error)
	// 第三方应用配置模板
	GetThirdPartyAppConfigTemplate(context.Context, *Empty) (*GetThirdPartyAppConfigTemplateResponse, error)
	// AI相关
	CheckHahValidAiConfig(context.Context, *Empty) (*GeneralResponse, error)
	ListAiModel(context.Context, *ListAiModelRequest) (*ListAiModelResponse, error)
	// 指纹库
	GetFingerprint(context.Context, *GetFingerprintRequest) (*GetFingerprintResponse, error)
	AddFingerprint(context.Context, *AddFingerprintRequest) (*AddFingerprintResponse, error)
	ModifyFingerprint(context.Context, *ModifyFingerprintRequest) (*ModifyFingerprintResponse, error)
	QueryFingerprint(context.Context, *QueryFingerprintRequest) (*QueryFingerprintResponse, error)
	DeleteFingerprint(context.Context, *DeleteFingerprintRequest) (*DbOperateMessage, error)
	UpdateFingerprint(context.Context, *UpdateFingerprintRequest) (*DbOperateMessage, error)
	CreateFingerprint(context.Context, *CreateFingerprintRequest) (*DbOperateMessage, error)
	RecoverBuiltinFingerprint(context.Context, *Empty) (*DbOperateMessage, error)
	CreateFingerprintGroup(context.Context, *FingerprintGroup) (*DbOperateMessage, error)
	GetAllFingerprintGroup(context.Context, *Empty) (*FingerprintGroups, error)
	RenameFingerprintGroup(context.Context, *RenameFingerprintGroupRequest) (*DbOperateMessage, error)
	DeleteFingerprintGroup(context.Context, *DeleteFingerprintGroupRequest) (*DbOperateMessage, error)
	// 指纹 与 组 工具接口
	BatchUpdateFingerprintToGroup(context.Context, *BatchUpdateFingerprintToGroupRequest) (*DbOperateMessage, error)
	GetFingerprintGroupSetByFilter(context.Context, *GetFingerprintGroupSetRequest) (*FingerprintGroups, error)
	// 导入导出指纹
	ExportFingerprint(*ExportFingerprintRequest, grpc.ServerStreamingServer[DataTransferProgress]) error
	ImportFingerprint(*ImportFingerprintRequest, grpc.ServerStreamingServer[DataTransferProgress]) error
	// 反弹shell命令生成
	GetReverseShellProgramList(context.Context, *GetReverseShellProgramListRequest) (*GetReverseShellProgramListResponse, error)
	GenerateReverseShellCommand(context.Context, *GenerateReverseShellCommandRequest) (*GenerateReverseShellCommandResponse, error)
	// SyntaxFlow Rule
	QuerySyntaxFlowRule(context.Context, *QuerySyntaxFlowRuleRequest) (*QuerySyntaxFlowRuleResponse, error)
	CreateSyntaxFlowRule(context.Context, *CreateSyntaxFlowRuleRequest) (*DbOperateMessage, error)
	CreateSyntaxFlowRuleEx(context.Context, *CreateSyntaxFlowRuleRequest) (*CreateSyntaxFlowRuleResponse, error)
	UpdateSyntaxFlowRule(context.Context, *UpdateSyntaxFlowRuleRequest) (*DbOperateMessage, error)
	UpdateSyntaxFlowRuleEx(context.Context, *UpdateSyntaxFlowRuleRequest) (*UpdateSyntaxFlowRuleResponse, error)
	DeleteSyntaxFlowRule(context.Context, *DeleteSyntaxFlowRuleRequest) (*DbOperateMessage, error)
	CheckSyntaxFlowRuleUpdate(context.Context, *CheckSyntaxFlowRuleUpdateRequest) (*CheckSyntaxFlowRuleUpdateResponse, error)
	ApplySyntaxFlowRuleUpdate(*ApplySyntaxFlowRuleUpdateRequest, grpc.ServerStreamingServer[ApplySyntaxFlowRuleUpdateResponse]) error
	// SyntaxFlow Group
	QuerySyntaxFlowRuleGroup(context.Context, *QuerySyntaxFlowRuleGroupRequest) (*QuerySyntaxFlowRuleGroupResponse, error)
	DeleteSyntaxFlowRuleGroup(context.Context, *DeleteSyntaxFlowRuleGroupRequest) (*DbOperateMessage, error)
	CreateSyntaxFlowRuleGroup(context.Context, *CreateSyntaxFlowGroupRequest) (*DbOperateMessage, error)
	UpdateSyntaxFlowRuleGroup(context.Context, *UpdateSyntaxFlowRuleGroupRequest) (*DbOperateMessage, error)
	UpdateSyntaxFlowRuleAndGroup(context.Context, *UpdateSyntaxFlowRuleAndGroupRequest) (*DbOperateMessage, error)
	// 查找多个规则的交集组，一个规则则为其组本身
	QuerySyntaxFlowSameGroup(context.Context, *QuerySyntaxFlowSameGroupRequest) (*QuerySyntaxFlowSameGroupResponse, error)
	SyntaxFlowRuleToOnline(*SyntaxFlowRuleToOnlineRequest, grpc.ServerStreamingServer[SyntaxFlowRuleOnlineProgress]) error
	DownloadSyntaxFlowRule(*DownloadSyntaxFlowRuleRequest, grpc.ServerStreamingServer[SyntaxFlowRuleOnlineProgress]) error
	// syntaxflow scan
	SyntaxFlowScan(grpc.BidiStreamingServer[SyntaxFlowScanRequest, SyntaxFlowScanResponse]) error
	QuerySyntaxFlowScanTask(context.Context, *QuerySyntaxFlowScanTaskRequest) (*QuerySyntaxFlowScanTaskResponse, error)
	DeleteSyntaxFlowScanTask(context.Context, *DeleteSyntaxFlowScanTaskRequest) (*DbOperateMessage, error)
	// query result
	QuerySyntaxFlowResult(context.Context, *QuerySyntaxFlowResultRequest) (*QuerySyntaxFlowResultResponse, error)
	DeleteSyntaxFlowResult(context.Context, *DeleteSyntaxFlowResultRequest) (*DeleteSyntaxFlowResultResponse, error)
	// query ssa program
	QuerySSAPrograms(context.Context, *QuerySSAProgramRequest) (*QuerySSAProgramResponse, error)
	UpdateSSAProgram(context.Context, *UpdateSSAProgramRequest) (*DbOperateMessage, error)
	DeleteSSAPrograms(context.Context, *DeleteSSAProgramRequest) (*DbOperateMessage, error)
	// SSA Risk CURD
	QuerySSARisks(context.Context, *QuerySSARisksRequest) (*QuerySSARisksResponse, error)
	QueryNewSSARisks(context.Context, *QueryNewSSARisksRequest) (*QueryNewSSARisksResponse, error)
	DeleteSSARisks(context.Context, *DeleteSSARisksRequest) (*DbOperateMessage, error)
	UpdateSSARiskTags(context.Context, *UpdateSSARiskTagsRequest) (*DbOperateMessage, error)
	GetSSARiskFieldGroup(context.Context, *Empty) (*SSARiskFieldGroupResponse, error)
	NewSSARiskRead(context.Context, *NewSSARiskReadRequest) (*NewSSARiskReadResponse, error)
	SSARiskFeedbackToOnline(context.Context, *SSARiskFeedbackToOnlineRequest) (*Empty, error)
	GetAllPluginEnv(context.Context, *Empty) (*PluginEnvData, error)
	QueryPluginEnv(context.Context, *QueryPluginEnvRequest) (*PluginEnvData, error)
	CreatePluginEnv(context.Context, *PluginEnvData) (*Empty, error)
	SetPluginEnv(context.Context, *PluginEnvData) (*Empty, error)
	DeletePluginEnv(context.Context, *DeletePluginEnvRequest) (*Empty, error)
	GetAllFuzztagInfo(context.Context, *GetAllFuzztagInfoRequest) (*GetAllFuzztagInfoResponse, error)
	GenerateFuzztag(context.Context, *GenerateFuzztagRequest) (*GenerateFuzztagResponse, error)
	// 导入导出SyntaxFlow规则
	ExportSyntaxFlows(*ExportSyntaxFlowsRequest, grpc.ServerStreamingServer[SyntaxflowsProgress]) error
	ImportSyntaxFlows(*ImportSyntaxFlowsRequest, grpc.ServerStreamingServer[SyntaxflowsProgress]) error
	// hot-patch template
	CreateHotPatchTemplate(context.Context, *HotPatchTemplate) (*CreateHotPatchTemplateResponse, error)
	DeleteHotPatchTemplate(context.Context, *DeleteHotPatchTemplateRequest) (*DeleteHotPatchTemplateResponse, error)
	UpdateHotPatchTemplate(context.Context, *UpdateHotPatchTemplateRequest) (*UpdateHotPatchTemplateResponse, error)
	QueryHotPatchTemplate(context.Context, *HotPatchTemplateRequest) (*QueryHotPatchTemplateResponse, error)
	QueryHotPatchTemplateList(context.Context, *QueryHotPatchTemplateListRequest) (*QueryHotPatchTemplateListResponse, error)
	// db common rpc
	GroupTableColumn(context.Context, *GroupTableColumnRequest) (*GroupTableColumnResponse, error)
	UploadHotPatchTemplateToOnline(context.Context, *UploadHotPatchTemplateToOnlineRequest) (*Empty, error)
	DownloadHotPatchTemplate(context.Context, *DownloadHotPatchTemplateRequest) (*Empty, error)
	// MITM hijack filter
	SetMITMHijackFilter(context.Context, *SetMITMFilterRequest) (*SetMITMFilterResponse, error)
	GetMITMHijackFilter(context.Context, *Empty) (*SetMITMFilterRequest, error)
	ResetMITMHijackFilter(context.Context, *Empty) (*SetMITMFilterRequest, error)
	// HTTPFlow
	ExportHTTPFlowStream(*ExportHTTPFlowStreamRequest, grpc.ServerStreamingServer[ExportHTTPFlowStreamResponse]) error
	ImportHTTPFlowStream(*ImportHTTPFlowStreamRequest, grpc.ServerStreamingServer[ImportHTTPFlowStreamResponse]) error
	// Note
	CreateNote(context.Context, *CreateNoteRequest) (*CreateNoteResponse, error)
	UpdateNote(context.Context, *UpdateNoteRequest) (*DbOperateMessage, error)
	DeleteNote(context.Context, *DeleteNoteRequest) (*DbOperateMessage, error)
	QueryNote(context.Context, *QueryNoteRequest) (*QueryNoteResponse, error)
	SearchNoteContent(context.Context, *SearchNoteContentRequest) (*SearchNoteContentResponse, error)
	ImportNote(*ImportNoteRequest, grpc.ServerStreamingServer[ImportNoteResponse]) error
	ExportNote(*ExportNoteRequest, grpc.ServerStreamingServer[ExportNoteResponse]) error
	// AI Task
	StartAITask(grpc.BidiStreamingServer[AIInputEvent, AIOutputEvent]) error
	QueryAITask(context.Context, *AITaskQueryRequest) (*AITaskQueryResponse, error)
	StartAITriage(grpc.BidiStreamingServer[AITriageInputEvent, AIOutputEvent]) error
	// AI forge curd
	CreateAIForge(context.Context, *AIForge) (*DbOperateMessage, error)
	UpdateAIForge(context.Context, *AIForge) (*DbOperateMessage, error)
	DeleteAIForge(context.Context, *AIForgeFilter) (*DbOperateMessage, error)
	QueryAIForge(context.Context, *QueryAIForgeRequest) (*QueryAIForgeResponse, error)
	// mcp server
	StartMcpServer(*StartMcpServerRequest, grpc.ServerStreamingServer[StartMcpServerResponse]) error
	GetToolSetList(context.Context, *Empty) (*GetToolSetListResponse, error)
	GetAIToolList(context.Context, *GetAIToolListRequest) (*GetAIToolListResponse, error)
	DeleteAITool(context.Context, *DeleteAIToolRequest) (*DbOperateMessage, error)
	SaveAITool(context.Context, *SaveAIToolRequest) (*DbOperateMessage, error)
	ToggleAIToolFavorite(context.Context, *ToggleAIToolFavoriteRequest) (*ToggleAIToolFavoriteResponse, error)
	AIToolGenerateMetadata(context.Context, *AIToolGenerateMetadataRequest) (*AIToolGenerateMetadataResponse, error)
	mustEmbedUnimplementedYakServer()
}

// UnimplementedYakServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedYakServer struct{}

func (UnimplementedYakServer) Version(context.Context, *Empty) (*VersionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Version not implemented")
}
func (UnimplementedYakServer) YakVersionAtLeast(context.Context, *YakVersionAtLeastRequest) (*GeneralResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method YakVersionAtLeast not implemented")
}
func (UnimplementedYakServer) Echo(context.Context, *EchoRequest) (*EchoResposne, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Echo not implemented")
}
func (UnimplementedYakServer) Handshake(context.Context, *HandshakeRequest) (*HandshakeResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Handshake not implemented")
}
func (UnimplementedYakServer) VerifySystemCertificate(context.Context, *Empty) (*VerifySystemCertificateResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method VerifySystemCertificate not implemented")
}
func (UnimplementedYakServer) MITM(grpc.BidiStreamingServer[MITMRequest, MITMResponse]) error {
	return status.Errorf(codes.Unimplemented, "method MITM not implemented")
}
func (UnimplementedYakServer) SetMITMFilter(context.Context, *SetMITMFilterRequest) (*SetMITMFilterResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetMITMFilter not implemented")
}
func (UnimplementedYakServer) GetMITMFilter(context.Context, *Empty) (*SetMITMFilterRequest, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetMITMFilter not implemented")
}
func (UnimplementedYakServer) ResetMITMFilter(context.Context, *Empty) (*SetMITMFilterRequest, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ResetMITMFilter not implemented")
}
func (UnimplementedYakServer) DownloadMITMCert(context.Context, *Empty) (*MITMCert, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DownloadMITMCert not implemented")
}
func (UnimplementedYakServer) MITMV2(grpc.BidiStreamingServer[MITMV2Request, MITMV2Response]) error {
	return status.Errorf(codes.Unimplemented, "method MITMV2 not implemented")
}
func (UnimplementedYakServer) OpenPort(grpc.BidiStreamingServer[Input, Output]) error {
	return status.Errorf(codes.Unimplemented, "method OpenPort not implemented")
}
func (UnimplementedYakServer) Exec(*ExecRequest, grpc.ServerStreamingServer[ExecResult]) error {
	return status.Errorf(codes.Unimplemented, "method Exec not implemented")
}
func (UnimplementedYakServer) QueryExecHistory(context.Context, *ExecHistoryRequest) (*ExecHistoryRecordResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QueryExecHistory not implemented")
}
func (UnimplementedYakServer) RemoveExecHistory(context.Context, *Empty) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RemoveExecHistory not implemented")
}
func (UnimplementedYakServer) LoadNucleiTemplates(context.Context, *Empty) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method LoadNucleiTemplates not implemented")
}
func (UnimplementedYakServer) AutoUpdateYakModule(*Empty, grpc.ServerStreamingServer[ExecResult]) error {
	return status.Errorf(codes.Unimplemented, "method AutoUpdateYakModule not implemented")
}
func (UnimplementedYakServer) ExecYakScript(*ExecRequest, grpc.ServerStreamingServer[ExecResult]) error {
	return status.Errorf(codes.Unimplemented, "method ExecYakScript not implemented")
}
func (UnimplementedYakServer) ExecBatchYakScript(*ExecBatchYakScriptRequest, grpc.ServerStreamingServer[ExecBatchYakScriptResult]) error {
	return status.Errorf(codes.Unimplemented, "method ExecBatchYakScript not implemented")
}
func (UnimplementedYakServer) GetExecBatchYakScriptUnfinishedTask(context.Context, *Empty) (*GetExecBatchYakScriptUnfinishedTaskResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetExecBatchYakScriptUnfinishedTask not implemented")
}
func (UnimplementedYakServer) GetExecBatchYakScriptUnfinishedTaskByUid(context.Context, *GetExecBatchYakScriptUnfinishedTaskByUidRequest) (*ExecBatchYakScriptRequest, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetExecBatchYakScriptUnfinishedTaskByUid not implemented")
}
func (UnimplementedYakServer) PopExecBatchYakScriptUnfinishedTaskByUid(context.Context, *GetExecBatchYakScriptUnfinishedTaskByUidRequest) (*ExecBatchYakScriptRequest, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PopExecBatchYakScriptUnfinishedTaskByUid not implemented")
}
func (UnimplementedYakServer) RecoverExecBatchYakScriptUnfinishedTask(*RecoverExecBatchYakScriptUnfinishedTaskRequest, grpc.ServerStreamingServer[ExecBatchYakScriptResult]) error {
	return status.Errorf(codes.Unimplemented, "method RecoverExecBatchYakScriptUnfinishedTask not implemented")
}
func (UnimplementedYakServer) QueryYakScript(context.Context, *QueryYakScriptRequest) (*QueryYakScriptResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QueryYakScript not implemented")
}
func (UnimplementedYakServer) QueryYakScriptByYakScriptName(*QueryYakScriptRequest, grpc.ServerStreamingServer[YakScript]) error {
	return status.Errorf(codes.Unimplemented, "method QueryYakScriptByYakScriptName not implemented")
}
func (UnimplementedYakServer) SaveYakScript(context.Context, *YakScript) (*YakScript, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SaveYakScript not implemented")
}
func (UnimplementedYakServer) DeleteYakScript(context.Context, *DeleteYakScriptRequest) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteYakScript not implemented")
}
func (UnimplementedYakServer) GetYakScriptById(context.Context, *GetYakScriptByIdRequest) (*YakScript, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetYakScriptById not implemented")
}
func (UnimplementedYakServer) GetYakScriptByName(context.Context, *GetYakScriptByNameRequest) (*YakScript, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetYakScriptByName not implemented")
}
func (UnimplementedYakServer) GetYakScriptByOnlineID(context.Context, *GetYakScriptByOnlineIDRequest) (*YakScript, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetYakScriptByOnlineID not implemented")
}
func (UnimplementedYakServer) IgnoreYakScript(context.Context, *DeleteYakScriptRequest) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method IgnoreYakScript not implemented")
}
func (UnimplementedYakServer) UnIgnoreYakScript(context.Context, *DeleteYakScriptRequest) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UnIgnoreYakScript not implemented")
}
func (UnimplementedYakServer) ExportYakScript(context.Context, *ExportYakScriptRequest) (*ExportYakScriptResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ExportYakScript not implemented")
}
func (UnimplementedYakServer) ExportYakScriptStream(*ExportYakScriptStreamRequest, grpc.ServerStreamingServer[ExecResult]) error {
	return status.Errorf(codes.Unimplemented, "method ExportYakScriptStream not implemented")
}
func (UnimplementedYakServer) ImportYakScriptStream(*ImportYakScriptStreamRequest, grpc.ServerStreamingServer[ExecResult]) error {
	return status.Errorf(codes.Unimplemented, "method ImportYakScriptStream not implemented")
}
func (UnimplementedYakServer) ExecutePacketYakScript(*ExecutePacketYakScriptParams, grpc.ServerStreamingServer[ExecResult]) error {
	return status.Errorf(codes.Unimplemented, "method ExecutePacketYakScript not implemented")
}
func (UnimplementedYakServer) ExecuteBatchPacketYakScript(*ExecuteBatchPacketYakScriptParams, grpc.ServerStreamingServer[ExecBatchYakScriptResult]) error {
	return status.Errorf(codes.Unimplemented, "method ExecuteBatchPacketYakScript not implemented")
}
func (UnimplementedYakServer) GetYakScriptTags(context.Context, *Empty) (*GetYakScriptTagsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetYakScriptTags not implemented")
}
func (UnimplementedYakServer) QueryYakScriptLocalAndUser(context.Context, *QueryYakScriptLocalAndUserRequest) (*QueryYakScriptLocalAndUserResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QueryYakScriptLocalAndUser not implemented")
}
func (UnimplementedYakServer) QueryYakScriptByOnlineGroup(context.Context, *QueryYakScriptByOnlineGroupRequest) (*QueryYakScriptLocalAndUserResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QueryYakScriptByOnlineGroup not implemented")
}
func (UnimplementedYakServer) QueryYakScriptLocalAll(context.Context, *Empty) (*QueryYakScriptLocalAndUserResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QueryYakScriptLocalAll not implemented")
}
func (UnimplementedYakServer) QueryYakScriptByNames(context.Context, *QueryYakScriptByNamesRequest) (*QueryYakScriptByNamesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QueryYakScriptByNames not implemented")
}
func (UnimplementedYakServer) QueryYakScriptByIsCore(context.Context, *QueryYakScriptByIsCoreRequest) (*QueryYakScriptByIsCoreResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QueryYakScriptByIsCore not implemented")
}
func (UnimplementedYakServer) QueryYakScriptRiskDetailByCWE(context.Context, *QueryYakScriptRiskDetailByCWERequest) (*QueryYakScriptRiskDetailByCWEResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QueryYakScriptRiskDetailByCWE not implemented")
}
func (UnimplementedYakServer) YakScriptRiskTypeList(context.Context, *Empty) (*YakScriptRiskTypeListResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method YakScriptRiskTypeList not implemented")
}
func (UnimplementedYakServer) SaveNewYakScript(context.Context, *SaveNewYakScriptRequest) (*YakScript, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SaveNewYakScript not implemented")
}
func (UnimplementedYakServer) SaveYakScriptToOnline(*SaveYakScriptToOnlineRequest, grpc.ServerStreamingServer[SaveYakScriptToOnlineResponse]) error {
	return status.Errorf(codes.Unimplemented, "method SaveYakScriptToOnline not implemented")
}
func (UnimplementedYakServer) ExportLocalYakScript(context.Context, *ExportLocalYakScriptRequest) (*ExportLocalYakScriptResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ExportLocalYakScript not implemented")
}
func (UnimplementedYakServer) ExportLocalYakScriptStream(*ExportLocalYakScriptRequest, grpc.ServerStreamingServer[ExportYakScriptLocalResponse]) error {
	return status.Errorf(codes.Unimplemented, "method ExportLocalYakScriptStream not implemented")
}
func (UnimplementedYakServer) ImportYakScript(*ImportYakScriptRequest, grpc.ServerStreamingServer[ImportYakScriptResult]) error {
	return status.Errorf(codes.Unimplemented, "method ImportYakScript not implemented")
}
func (UnimplementedYakServer) SetYakScriptSkipUpdate(context.Context, *SetYakScriptSkipUpdateRequest) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetYakScriptSkipUpdate not implemented")
}
func (UnimplementedYakServer) QueryYakScriptSkipUpdate(context.Context, *QueryYakScriptRequest) (*QueryYakScriptSkipUpdateResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QueryYakScriptSkipUpdate not implemented")
}
func (UnimplementedYakServer) QueryYakScriptGroup(context.Context, *QueryYakScriptGroupRequest) (*QueryYakScriptGroupResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QueryYakScriptGroup not implemented")
}
func (UnimplementedYakServer) SaveYakScriptGroup(context.Context, *SaveYakScriptGroupRequest) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SaveYakScriptGroup not implemented")
}
func (UnimplementedYakServer) RenameYakScriptGroup(context.Context, *RenameYakScriptGroupRequest) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RenameYakScriptGroup not implemented")
}
func (UnimplementedYakServer) DeleteYakScriptGroup(context.Context, *DeleteYakScriptGroupRequest) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteYakScriptGroup not implemented")
}
func (UnimplementedYakServer) GetYakScriptGroup(context.Context, *QueryYakScriptRequest) (*GetYakScriptGroupResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetYakScriptGroup not implemented")
}
func (UnimplementedYakServer) ResetYakScriptGroup(context.Context, *ResetYakScriptGroupRequest) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ResetYakScriptGroup not implemented")
}
func (UnimplementedYakServer) SetGroup(context.Context, *SetGroupRequest) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetGroup not implemented")
}
func (UnimplementedYakServer) GetHTTPFlowByHash(context.Context, *GetHTTPFlowByHashRequest) (*HTTPFlow, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetHTTPFlowByHash not implemented")
}
func (UnimplementedYakServer) GetHTTPFlowById(context.Context, *GetHTTPFlowByIdRequest) (*HTTPFlow, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetHTTPFlowById not implemented")
}
func (UnimplementedYakServer) GetHTTPFlowBodyById(*GetHTTPFlowBodyByIdRequest, grpc.ServerStreamingServer[GetHTTPFlowBodyByIdResponse]) error {
	return status.Errorf(codes.Unimplemented, "method GetHTTPFlowBodyById not implemented")
}
func (UnimplementedYakServer) GetHTTPFlowByIds(context.Context, *GetHTTPFlowByIdsRequest) (*HTTPFlows, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetHTTPFlowByIds not implemented")
}
func (UnimplementedYakServer) QueryHTTPFlows(context.Context, *QueryHTTPFlowRequest) (*QueryHTTPFlowResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QueryHTTPFlows not implemented")
}
func (UnimplementedYakServer) DeleteHTTPFlows(context.Context, *DeleteHTTPFlowRequest) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteHTTPFlows not implemented")
}
func (UnimplementedYakServer) SetTagForHTTPFlow(context.Context, *SetTagForHTTPFlowRequest) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetTagForHTTPFlow not implemented")
}
func (UnimplementedYakServer) QueryHTTPFlowsIds(context.Context, *QueryHTTPFlowsIdsRequest) (*QueryHTTPFlowsIdsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QueryHTTPFlowsIds not implemented")
}
func (UnimplementedYakServer) HTTPFlowsFieldGroup(context.Context, *HTTPFlowsFieldGroupRequest) (*HTTPFlowsFieldGroupResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method HTTPFlowsFieldGroup not implemented")
}
func (UnimplementedYakServer) HTTPFlowsShare(context.Context, *HTTPFlowsShareRequest) (*HTTPFlowsShareResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method HTTPFlowsShare not implemented")
}
func (UnimplementedYakServer) HTTPFlowsExtract(context.Context, *HTTPFlowsExtractRequest) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method HTTPFlowsExtract not implemented")
}
func (UnimplementedYakServer) GetHTTPFlowBare(context.Context, *HTTPFlowBareRequest) (*HTTPFlowBareResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetHTTPFlowBare not implemented")
}
func (UnimplementedYakServer) ExportHTTPFlows(context.Context, *ExportHTTPFlowsRequest) (*QueryHTTPFlowResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ExportHTTPFlows not implemented")
}
func (UnimplementedYakServer) HTTPFlowsToOnline(context.Context, *HTTPFlowsToOnlineRequest) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method HTTPFlowsToOnline not implemented")
}
func (UnimplementedYakServer) QueryHTTPFlowsProcessNames(context.Context, *QueryHTTPFlowRequest) (*QueryHTTPFlowsProcessNamesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QueryHTTPFlowsProcessNames not implemented")
}
func (UnimplementedYakServer) AnalyzeHTTPFlow(*AnalyzeHTTPFlowRequest, grpc.ServerStreamingServer[AnalyzeHTTPFlowResponse]) error {
	return status.Errorf(codes.Unimplemented, "method AnalyzeHTTPFlow not implemented")
}
func (UnimplementedYakServer) ExtractUrl(context.Context, *FuzzerRequest) (*ExtractedUrl, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ExtractUrl not implemented")
}
func (UnimplementedYakServer) GetHistoryHTTPFuzzerTask(context.Context, *GetHistoryHTTPFuzzerTaskRequest) (*HistoryHTTPFuzzerTaskDetail, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetHistoryHTTPFuzzerTask not implemented")
}
func (UnimplementedYakServer) QueryHistoryHTTPFuzzerTask(context.Context, *Empty) (*HistoryHTTPFuzzerTasks, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QueryHistoryHTTPFuzzerTask not implemented")
}
func (UnimplementedYakServer) QueryHistoryHTTPFuzzerTaskEx(context.Context, *QueryHistoryHTTPFuzzerTaskExParams) (*HistoryHTTPFuzzerTasksResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QueryHistoryHTTPFuzzerTaskEx not implemented")
}
func (UnimplementedYakServer) DeleteHistoryHTTPFuzzerTask(context.Context, *DeleteHistoryHTTPFuzzerTaskRequest) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteHistoryHTTPFuzzerTask not implemented")
}
func (UnimplementedYakServer) HTTPFuzzer(*FuzzerRequest, grpc.ServerStreamingServer[FuzzerResponse]) error {
	return status.Errorf(codes.Unimplemented, "method HTTPFuzzer not implemented")
}
func (UnimplementedYakServer) HTTPFuzzerSequence(*FuzzerRequests, grpc.ServerStreamingServer[FuzzerSequenceResponse]) error {
	return status.Errorf(codes.Unimplemented, "method HTTPFuzzerSequence not implemented")
}
func (UnimplementedYakServer) PreloadHTTPFuzzerParams(context.Context, *PreloadHTTPFuzzerParamsRequest) (*PreloadHTTPFuzzerParamsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PreloadHTTPFuzzerParams not implemented")
}
func (UnimplementedYakServer) RenderVariables(context.Context, *RenderVariablesRequest) (*RenderVariablesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RenderVariables not implemented")
}
func (UnimplementedYakServer) MatchHTTPResponse(context.Context, *MatchHTTPResponseParams) (*MatchHTTPResponseResult, error) {
	return nil, status.Errorf(codes.Unimplemented, "method MatchHTTPResponse not implemented")
}
func (UnimplementedYakServer) ExtractHTTPResponse(context.Context, *ExtractHTTPResponseParams) (*ExtractHTTPResponseResult, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ExtractHTTPResponse not implemented")
}
func (UnimplementedYakServer) RedirectRequest(context.Context, *RedirectRequestParams) (*FuzzerResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RedirectRequest not implemented")
}
func (UnimplementedYakServer) HTTPRequestMutate(context.Context, *HTTPRequestMutateParams) (*MutateResult, error) {
	return nil, status.Errorf(codes.Unimplemented, "method HTTPRequestMutate not implemented")
}
func (UnimplementedYakServer) HTTPResponseMutate(context.Context, *HTTPResponseMutateParams) (*MutateResult, error) {
	return nil, status.Errorf(codes.Unimplemented, "method HTTPResponseMutate not implemented")
}
func (UnimplementedYakServer) FixUploadPacket(context.Context, *FixUploadPacketRequest) (*FixUploadPacketResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method FixUploadPacket not implemented")
}
func (UnimplementedYakServer) IsMultipartFormDataRequest(context.Context, *FixUploadPacketRequest) (*IsMultipartFormDataRequestResult, error) {
	return nil, status.Errorf(codes.Unimplemented, "method IsMultipartFormDataRequest not implemented")
}
func (UnimplementedYakServer) GenerateExtractRule(context.Context, *GenerateExtractRuleRequest) (*GenerateExtractRuleResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GenerateExtractRule not implemented")
}
func (UnimplementedYakServer) ExtractData(grpc.BidiStreamingServer[ExtractDataRequest, ExtractDataResponse]) error {
	return status.Errorf(codes.Unimplemented, "method ExtractData not implemented")
}
func (UnimplementedYakServer) ImportHTTPFuzzerTaskFromYaml(context.Context, *ImportHTTPFuzzerTaskFromYamlRequest) (*ImportHTTPFuzzerTaskFromYamlResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ImportHTTPFuzzerTaskFromYaml not implemented")
}
func (UnimplementedYakServer) ExportHTTPFuzzerTaskToYaml(context.Context, *ExportHTTPFuzzerTaskToYamlRequest) (*ExportHTTPFuzzerTaskToYamlResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ExportHTTPFuzzerTaskToYaml not implemented")
}
func (UnimplementedYakServer) RenderHTTPFuzzerPacket(context.Context, *RenderHTTPFuzzerPacketRequest) (*RenderHTTPFuzzerPacketResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RenderHTTPFuzzerPacket not implemented")
}
func (UnimplementedYakServer) SaveFuzzerLabel(context.Context, *SaveFuzzerLabelRequest) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SaveFuzzerLabel not implemented")
}
func (UnimplementedYakServer) QueryFuzzerLabel(context.Context, *Empty) (*QueryFuzzerLabelResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QueryFuzzerLabel not implemented")
}
func (UnimplementedYakServer) DeleteFuzzerLabel(context.Context, *DeleteFuzzerLabelRequest) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteFuzzerLabel not implemented")
}
func (UnimplementedYakServer) SaveFuzzerConfig(context.Context, *SaveFuzzerConfigRequest) (*DbOperateMessage, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SaveFuzzerConfig not implemented")
}
func (UnimplementedYakServer) QueryFuzzerConfig(context.Context, *QueryFuzzerConfigRequest) (*QueryFuzzerConfigResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QueryFuzzerConfig not implemented")
}
func (UnimplementedYakServer) DeleteFuzzerConfig(context.Context, *DeleteFuzzerConfigRequest) (*DbOperateMessage, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteFuzzerConfig not implemented")
}
func (UnimplementedYakServer) QueryHTTPFuzzerResponseByTaskId(context.Context, *QueryHTTPFuzzerResponseByTaskIdRequest) (*QueryHTTPFuzzerResponseByTaskIdResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QueryHTTPFuzzerResponseByTaskId not implemented")
}
func (UnimplementedYakServer) CreateWebsocketFuzzer(grpc.BidiStreamingServer[ClientWebsocketRequest, ClientWebsocketResponse]) error {
	return status.Errorf(codes.Unimplemented, "method CreateWebsocketFuzzer not implemented")
}
func (UnimplementedYakServer) QueryWebsocketFlowByHTTPFlowWebsocketHash(context.Context, *QueryWebsocketFlowByHTTPFlowWebsocketHashRequest) (*WebsocketFlows, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QueryWebsocketFlowByHTTPFlowWebsocketHash not implemented")
}
func (UnimplementedYakServer) DeleteWebsocketFlowByHTTPFlowWebsocketHash(context.Context, *DeleteWebsocketFlowByHTTPFlowWebsocketHashRequest) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteWebsocketFlowByHTTPFlowWebsocketHash not implemented")
}
func (UnimplementedYakServer) DeleteWebsocketFlowAll(context.Context, *Empty) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteWebsocketFlowAll not implemented")
}
func (UnimplementedYakServer) ConvertFuzzerResponseToHTTPFlow(context.Context, *FuzzerResponse) (*HTTPFlow, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ConvertFuzzerResponseToHTTPFlow not implemented")
}
func (UnimplementedYakServer) StringFuzzer(context.Context, *StringFuzzerRequest) (*StringFuzzerResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method StringFuzzer not implemented")
}
func (UnimplementedYakServer) HTTPRequestAnalyzer(context.Context, *HTTPRequestAnalysisMaterial) (*HTTPRequestAnalysis, error) {
	return nil, status.Errorf(codes.Unimplemented, "method HTTPRequestAnalyzer not implemented")
}
func (UnimplementedYakServer) Codec(context.Context, *CodecRequest) (*CodecResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Codec not implemented")
}
func (UnimplementedYakServer) NewCodec(context.Context, *CodecRequestFlow) (*CodecResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method NewCodec not implemented")
}
func (UnimplementedYakServer) GetAllCodecMethods(context.Context, *Empty) (*CodecMethods, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetAllCodecMethods not implemented")
}
func (UnimplementedYakServer) SaveCodecFlow(context.Context, *CustomizeCodecFlow) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SaveCodecFlow not implemented")
}
func (UnimplementedYakServer) DeleteCodecFlow(context.Context, *DeleteCodecFlowRequest) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteCodecFlow not implemented")
}
func (UnimplementedYakServer) GetAllCodecFlow(context.Context, *Empty) (*GetCodecFlowResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetAllCodecFlow not implemented")
}
func (UnimplementedYakServer) PacketPrettifyHelper(context.Context, *PacketPrettifyHelperRequest) (*PacketPrettifyHelperResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PacketPrettifyHelper not implemented")
}
func (UnimplementedYakServer) QueryPayload(context.Context, *QueryPayloadRequest) (*QueryPayloadResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QueryPayload not implemented")
}
func (UnimplementedYakServer) QueryPayloadFromFile(context.Context, *QueryPayloadFromFileRequest) (*QueryPayloadFromFileResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QueryPayloadFromFile not implemented")
}
func (UnimplementedYakServer) DeletePayloadByFolder(context.Context, *NameRequest) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeletePayloadByFolder not implemented")
}
func (UnimplementedYakServer) DeletePayloadByGroup(context.Context, *DeletePayloadByGroupRequest) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeletePayloadByGroup not implemented")
}
func (UnimplementedYakServer) DeletePayload(context.Context, *DeletePayloadRequest) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeletePayload not implemented")
}
func (UnimplementedYakServer) SavePayload(context.Context, *SavePayloadRequest) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SavePayload not implemented")
}
func (UnimplementedYakServer) SavePayloadStream(*SavePayloadRequest, grpc.ServerStreamingServer[SavePayloadProgress]) error {
	return status.Errorf(codes.Unimplemented, "method SavePayloadStream not implemented")
}
func (UnimplementedYakServer) SavePayloadToFileStream(*SavePayloadRequest, grpc.ServerStreamingServer[SavePayloadProgress]) error {
	return status.Errorf(codes.Unimplemented, "method SavePayloadToFileStream not implemented")
}
func (UnimplementedYakServer) SaveLargePayloadToFileStream(*SavePayloadRequest, grpc.ServerStreamingServer[SavePayloadProgress]) error {
	return status.Errorf(codes.Unimplemented, "method SaveLargePayloadToFileStream not implemented")
}
func (UnimplementedYakServer) RenamePayloadFolder(context.Context, *RenameRequest) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RenamePayloadFolder not implemented")
}
func (UnimplementedYakServer) RenamePayloadGroup(context.Context, *RenameRequest) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RenamePayloadGroup not implemented")
}
func (UnimplementedYakServer) UpdatePayload(context.Context, *UpdatePayloadRequest) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdatePayload not implemented")
}
func (UnimplementedYakServer) UpdatePayloadToFile(context.Context, *UpdatePayloadToFileRequest) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdatePayloadToFile not implemented")
}
func (UnimplementedYakServer) BackUpOrCopyPayloads(context.Context, *BackUpOrCopyPayloadsRequest) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BackUpOrCopyPayloads not implemented")
}
func (UnimplementedYakServer) GetAllPayloadGroup(context.Context, *Empty) (*GetAllPayloadGroupResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetAllPayloadGroup not implemented")
}
func (UnimplementedYakServer) UpdateAllPayloadGroup(context.Context, *UpdateAllPayloadGroupRequest) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateAllPayloadGroup not implemented")
}
func (UnimplementedYakServer) GetAllPayload(context.Context, *GetAllPayloadRequest) (*GetAllPayloadResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetAllPayload not implemented")
}
func (UnimplementedYakServer) GetAllPayloadFromFile(*GetAllPayloadRequest, grpc.ServerStreamingServer[GetAllPayloadFromFileResponse]) error {
	return status.Errorf(codes.Unimplemented, "method GetAllPayloadFromFile not implemented")
}
func (UnimplementedYakServer) ExportAllPayload(*GetAllPayloadRequest, grpc.ServerStreamingServer[GetAllPayloadResponse]) error {
	return status.Errorf(codes.Unimplemented, "method ExportAllPayload not implemented")
}
func (UnimplementedYakServer) ExportAllPayloadFromFile(*GetAllPayloadRequest, grpc.ServerStreamingServer[GetAllPayloadResponse]) error {
	return status.Errorf(codes.Unimplemented, "method ExportAllPayloadFromFile not implemented")
}
func (UnimplementedYakServer) CreatePayloadFolder(context.Context, *NameRequest) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreatePayloadFolder not implemented")
}
func (UnimplementedYakServer) RemoveDuplicatePayloads(*NameRequest, grpc.ServerStreamingServer[SavePayloadProgress]) error {
	return status.Errorf(codes.Unimplemented, "method RemoveDuplicatePayloads not implemented")
}
func (UnimplementedYakServer) CoverPayloadGroupToDatabase(*NameRequest, grpc.ServerStreamingServer[SavePayloadProgress]) error {
	return status.Errorf(codes.Unimplemented, "method CoverPayloadGroupToDatabase not implemented")
}
func (UnimplementedYakServer) ConvertPayloadGroupToDatabase(*NameRequest, grpc.ServerStreamingServer[SavePayloadProgress]) error {
	return status.Errorf(codes.Unimplemented, "method ConvertPayloadGroupToDatabase not implemented")
}
func (UnimplementedYakServer) MigratePayloads(*Empty, grpc.ServerStreamingServer[SavePayloadProgress]) error {
	return status.Errorf(codes.Unimplemented, "method MigratePayloads not implemented")
}
func (UnimplementedYakServer) GetYakitCompletionRaw(context.Context, *Empty) (*YakitCompletionRawResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetYakitCompletionRaw not implemented")
}
func (UnimplementedYakServer) GetYakVMBuildInMethodCompletion(context.Context, *GetYakVMBuildInMethodCompletionRequest) (*GetYakVMBuildInMethodCompletionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetYakVMBuildInMethodCompletion not implemented")
}
func (UnimplementedYakServer) StaticAnalyzeError(context.Context, *StaticAnalyzeErrorRequest) (*StaticAnalyzeErrorResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method StaticAnalyzeError not implemented")
}
func (UnimplementedYakServer) YaklangCompileAndFormat(context.Context, *YaklangCompileAndFormatRequest) (*YaklangCompileAndFormatResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method YaklangCompileAndFormat not implemented")
}
func (UnimplementedYakServer) YaklangLanguageSuggestion(context.Context, *YaklangLanguageSuggestionRequest) (*YaklangLanguageSuggestionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method YaklangLanguageSuggestion not implemented")
}
func (UnimplementedYakServer) YaklangLanguageFind(context.Context, *YaklangLanguageSuggestionRequest) (*YaklangLanguageFindResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method YaklangLanguageFind not implemented")
}
func (UnimplementedYakServer) FuzzTagSuggestion(context.Context, *FuzzTagSuggestionRequest) (*YaklangLanguageSuggestionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method FuzzTagSuggestion not implemented")
}
func (UnimplementedYakServer) YaklangInspectInformation(context.Context, *YaklangInspectInformationRequest) (*YaklangInspectInformationResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method YaklangInspectInformation not implemented")
}
func (UnimplementedYakServer) YaklangGetCliCodeFromDatabase(context.Context, *YaklangGetCliCodeFromDatabaseRequest) (*YaklangGetCliCodeFromDatabaseResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method YaklangGetCliCodeFromDatabase not implemented")
}
func (UnimplementedYakServer) YaklangTerminal(grpc.BidiStreamingServer[Input, Output]) error {
	return status.Errorf(codes.Unimplemented, "method YaklangTerminal not implemented")
}
func (UnimplementedYakServer) PortScan(*PortScanRequest, grpc.ServerStreamingServer[ExecResult]) error {
	return status.Errorf(codes.Unimplemented, "method PortScan not implemented")
}
func (UnimplementedYakServer) ViewPortScanCode(context.Context, *Empty) (*SimpleScript, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ViewPortScanCode not implemented")
}
func (UnimplementedYakServer) SimpleDetect(*RecordPortScanRequest, grpc.ServerStreamingServer[ExecResult]) error {
	return status.Errorf(codes.Unimplemented, "method SimpleDetect not implemented")
}
func (UnimplementedYakServer) SaveCancelSimpleDetect(context.Context, *RecordPortScanRequest) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SaveCancelSimpleDetect not implemented")
}
func (UnimplementedYakServer) SimpleDetectCreatReport(*CreatReportRequest, grpc.ServerStreamingServer[ExecResult]) error {
	return status.Errorf(codes.Unimplemented, "method SimpleDetectCreatReport not implemented")
}
func (UnimplementedYakServer) QuerySimpleDetectUnfinishedTask(context.Context, *QueryUnfinishedTaskRequest) (*QueryUnfinishedTaskResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QuerySimpleDetectUnfinishedTask not implemented")
}
func (UnimplementedYakServer) GetSimpleDetectRecordRequestById(context.Context, *GetUnfinishedTaskDetailByIdRequest) (*RecordPortScanRequest, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetSimpleDetectRecordRequestById not implemented")
}
func (UnimplementedYakServer) DeleteSimpleDetectUnfinishedTask(context.Context, *DeleteUnfinishedTaskRequest) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteSimpleDetectUnfinishedTask not implemented")
}
func (UnimplementedYakServer) RecoverSimpleDetectTask(*RecoverUnfinishedTaskRequest, grpc.ServerStreamingServer[ExecResult]) error {
	return status.Errorf(codes.Unimplemented, "method RecoverSimpleDetectTask not implemented")
}
func (UnimplementedYakServer) GetSimpleDetectUnfinishedTask(context.Context, *Empty) (*GetSimpleDetectUnfinishedTaskResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetSimpleDetectUnfinishedTask not implemented")
}
func (UnimplementedYakServer) GetSimpleDetectUnfinishedTaskByUid(context.Context, *GetExecBatchYakScriptUnfinishedTaskByUidRequest) (*RecordPortScanRequest, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetSimpleDetectUnfinishedTaskByUid not implemented")
}
func (UnimplementedYakServer) PopSimpleDetectUnfinishedTaskByUid(context.Context, *GetExecBatchYakScriptUnfinishedTaskByUidRequest) (*RecordPortScanRequest, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PopSimpleDetectUnfinishedTaskByUid not implemented")
}
func (UnimplementedYakServer) RecoverSimpleDetectUnfinishedTask(*RecoverExecBatchYakScriptUnfinishedTaskRequest, grpc.ServerStreamingServer[ExecResult]) error {
	return status.Errorf(codes.Unimplemented, "method RecoverSimpleDetectUnfinishedTask not implemented")
}
func (UnimplementedYakServer) QueryPorts(context.Context, *QueryPortsRequest) (*QueryPortsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QueryPorts not implemented")
}
func (UnimplementedYakServer) DeletePorts(context.Context, *DeletePortsRequest) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeletePorts not implemented")
}
func (UnimplementedYakServer) QueryHosts(context.Context, *QueryHostsRequest) (*QueryHostsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QueryHosts not implemented")
}
func (UnimplementedYakServer) DeleteHosts(context.Context, *DeleteHostsRequest) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteHosts not implemented")
}
func (UnimplementedYakServer) QueryDomains(context.Context, *QueryDomainsRequest) (*QueryDomainsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QueryDomains not implemented")
}
func (UnimplementedYakServer) DeleteDomains(context.Context, *DeleteDomainsRequest) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteDomains not implemented")
}
func (UnimplementedYakServer) QueryPortsGroup(context.Context, *Empty) (*QueryPortsGroupResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QueryPortsGroup not implemented")
}
func (UnimplementedYakServer) UpdateFromYakitResource(context.Context, *UpdateFromYakitResourceRequest) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateFromYakitResource not implemented")
}
func (UnimplementedYakServer) UpdateFromGithub(context.Context, *UpdateFromGithubRequest) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateFromGithub not implemented")
}
func (UnimplementedYakServer) AddToMenu(context.Context, *AddToMenuRequest) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddToMenu not implemented")
}
func (UnimplementedYakServer) RemoveFromMenu(context.Context, *RemoveFromMenuRequest) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RemoveFromMenu not implemented")
}
func (UnimplementedYakServer) YakScriptIsInMenu(context.Context, *YakScriptIsInMenuRequest) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method YakScriptIsInMenu not implemented")
}
func (UnimplementedYakServer) GetAllMenuItem(context.Context, *Empty) (*MenuByGroup, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetAllMenuItem not implemented")
}
func (UnimplementedYakServer) DeleteAllMenuItem(context.Context, *Empty) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteAllMenuItem not implemented")
}
func (UnimplementedYakServer) ImportMenuItem(context.Context, *ImportMenuItemRequest) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ImportMenuItem not implemented")
}
func (UnimplementedYakServer) ExportMenuItem(context.Context, *Empty) (*ExportMenuItemResult, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ExportMenuItem not implemented")
}
func (UnimplementedYakServer) GetMenuItemById(context.Context, *GetMenuItemByIdRequest) (*MenuItem, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetMenuItemById not implemented")
}
func (UnimplementedYakServer) QueryGroupsByYakScriptId(context.Context, *QueryGroupsByYakScriptIdRequest) (*GroupNames, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QueryGroupsByYakScriptId not implemented")
}
func (UnimplementedYakServer) AddMenus(context.Context, *AddMenuRequest) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddMenus not implemented")
}
func (UnimplementedYakServer) QueryAllMenuItem(context.Context, *QueryAllMenuItemRequest) (*MenuByGroup, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QueryAllMenuItem not implemented")
}
func (UnimplementedYakServer) DeleteAllMenu(context.Context, *QueryAllMenuItemRequest) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteAllMenu not implemented")
}
func (UnimplementedYakServer) AddToNavigation(context.Context, *AddToNavigationRequest) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddToNavigation not implemented")
}
func (UnimplementedYakServer) GetAllNavigationItem(context.Context, *GetAllNavigationRequest) (*GetAllNavigationItemResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetAllNavigationItem not implemented")
}
func (UnimplementedYakServer) DeleteAllNavigation(context.Context, *GetAllNavigationRequest) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteAllNavigation not implemented")
}
func (UnimplementedYakServer) AddOneNavigation(context.Context, *AddOneNavigationRequest) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddOneNavigation not implemented")
}
func (UnimplementedYakServer) QueryNavigationGroups(context.Context, *QueryNavigationGroupsRequest) (*GroupNames, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QueryNavigationGroups not implemented")
}
func (UnimplementedYakServer) SaveMarkdownDocument(context.Context, *SaveMarkdownDocumentRequest) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SaveMarkdownDocument not implemented")
}
func (UnimplementedYakServer) GetMarkdownDocument(context.Context, *GetMarkdownDocumentRequest) (*GetMarkdownDocumentResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetMarkdownDocument not implemented")
}
func (UnimplementedYakServer) DeleteMarkdownDocument(context.Context, *GetMarkdownDocumentRequest) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteMarkdownDocument not implemented")
}
func (UnimplementedYakServer) StartBasicCrawler(context.Context, *StartBasicCrawlerRequest) (*ExecResult, error) {
	return nil, status.Errorf(codes.Unimplemented, "method StartBasicCrawler not implemented")
}
func (UnimplementedYakServer) ViewBasicCrawlerCode(context.Context, *Empty) (*SimpleScript, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ViewBasicCrawlerCode not implemented")
}
func (UnimplementedYakServer) GenerateWebsiteTree(context.Context, *GenerateWebsiteTreeRequest) (*GenerateWebsiteTreeResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GenerateWebsiteTree not implemented")
}
func (UnimplementedYakServer) QueryYakScriptExecResult(context.Context, *QueryYakScriptExecResultRequest) (*QueryYakScriptExecResultResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QueryYakScriptExecResult not implemented")
}
func (UnimplementedYakServer) QueryYakScriptNameInExecResult(context.Context, *Empty) (*YakScriptNames, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QueryYakScriptNameInExecResult not implemented")
}
func (UnimplementedYakServer) DeleteYakScriptExecResult(context.Context, *DeleteYakScriptExecResultRequest) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteYakScriptExecResult not implemented")
}
func (UnimplementedYakServer) DeleteYakScriptExec(context.Context, *Empty) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteYakScriptExec not implemented")
}
func (UnimplementedYakServer) StartBrute(*StartBruteParams, grpc.ServerStreamingServer[ExecResult]) error {
	return status.Errorf(codes.Unimplemented, "method StartBrute not implemented")
}
func (UnimplementedYakServer) GetAvailableBruteTypes(context.Context, *Empty) (*GetAvailableBruteTypesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetAvailableBruteTypes not implemented")
}
func (UnimplementedYakServer) GetTunnelServerExternalIP(context.Context, *GetTunnelServerExternalIPParams) (*GetTunnelServerExternalIPResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetTunnelServerExternalIP not implemented")
}
func (UnimplementedYakServer) VerifyTunnelServerDomain(context.Context, *VerifyTunnelServerDomainParams) (*VerifyTunnelServerDomainResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method VerifyTunnelServerDomain not implemented")
}
func (UnimplementedYakServer) StartFacades(*StartFacadesParams, grpc.ServerStreamingServer[ExecResult]) error {
	return status.Errorf(codes.Unimplemented, "method StartFacades not implemented")
}
func (UnimplementedYakServer) StartFacadesWithYsoObject(*StartFacadesWithYsoParams, grpc.ServerStreamingServer[ExecResult]) error {
	return status.Errorf(codes.Unimplemented, "method StartFacadesWithYsoObject not implemented")
}
func (UnimplementedYakServer) ApplyClassToFacades(context.Context, *ApplyClassToFacadesParamsWithVerbose) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ApplyClassToFacades not implemented")
}
func (UnimplementedYakServer) BytesToBase64(context.Context, *BytesToBase64Request) (*BytesToBase64Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BytesToBase64 not implemented")
}
func (UnimplementedYakServer) ConfigGlobalReverse(*ConfigGlobalReverseParams, grpc.ServerStreamingServer[Empty]) error {
	return status.Errorf(codes.Unimplemented, "method ConfigGlobalReverse not implemented")
}
func (UnimplementedYakServer) AvailableLocalAddr(context.Context, *Empty) (*AvailableLocalAddrResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AvailableLocalAddr not implemented")
}
func (UnimplementedYakServer) GetGlobalReverseServer(context.Context, *Empty) (*GetGlobalReverseServerResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetGlobalReverseServer not implemented")
}
func (UnimplementedYakServer) QueryRisks(context.Context, *QueryRisksRequest) (*QueryRisksResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QueryRisks not implemented")
}
func (UnimplementedYakServer) QueryRisk(context.Context, *QueryRiskRequest) (*Risk, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QueryRisk not implemented")
}
func (UnimplementedYakServer) DeleteRisk(context.Context, *DeleteRiskRequest) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteRisk not implemented")
}
func (UnimplementedYakServer) QueryAvailableRiskType(context.Context, *Empty) (*Fields, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QueryAvailableRiskType not implemented")
}
func (UnimplementedYakServer) QueryAvailableRiskLevel(context.Context, *Empty) (*Fields, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QueryAvailableRiskLevel not implemented")
}
func (UnimplementedYakServer) QueryRiskTableStats(context.Context, *Empty) (*RiskTableStats, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QueryRiskTableStats not implemented")
}
func (UnimplementedYakServer) ResetRiskTableStats(context.Context, *Empty) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ResetRiskTableStats not implemented")
}
func (UnimplementedYakServer) QueryAvailableTarget(context.Context, *Empty) (*Fields, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QueryAvailableTarget not implemented")
}
func (UnimplementedYakServer) QueryNewRisk(context.Context, *QueryNewRiskRequest) (*QueryNewRiskResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QueryNewRisk not implemented")
}
func (UnimplementedYakServer) NewRiskRead(context.Context, *NewRiskReadRequest) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method NewRiskRead not implemented")
}
func (UnimplementedYakServer) UploadRiskToOnline(context.Context, *UploadRiskToOnlineRequest) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UploadRiskToOnline not implemented")
}
func (UnimplementedYakServer) SetTagForRisk(context.Context, *SetTagForRiskRequest) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetTagForRisk not implemented")
}
func (UnimplementedYakServer) QueryRiskTags(context.Context, *Empty) (*QueryRiskTagsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QueryRiskTags not implemented")
}
func (UnimplementedYakServer) RiskFieldGroup(context.Context, *Empty) (*RiskFieldGroupResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RiskFieldGroup not implemented")
}
func (UnimplementedYakServer) RiskFeedbackToOnline(context.Context, *UploadRiskToOnlineRequest) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RiskFeedbackToOnline not implemented")
}
func (UnimplementedYakServer) QueryReports(context.Context, *QueryReportsRequest) (*QueryReportsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QueryReports not implemented")
}
func (UnimplementedYakServer) QueryReport(context.Context, *QueryReportRequest) (*Report, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QueryReport not implemented")
}
func (UnimplementedYakServer) DeleteReport(context.Context, *DeleteReportRequest) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteReport not implemented")
}
func (UnimplementedYakServer) QueryAvailableReportFrom(context.Context, *Empty) (*Fields, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QueryAvailableReportFrom not implemented")
}
func (UnimplementedYakServer) DownloadReport(context.Context, *DownloadReportRequest) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DownloadReport not implemented")
}
func (UnimplementedYakServer) GetAllYsoGadgetOptions(context.Context, *Empty) (*YsoOptionsWithVerbose, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetAllYsoGadgetOptions not implemented")
}
func (UnimplementedYakServer) GetAllYsoClassOptions(context.Context, *YsoOptionsRequerstWithVerbose) (*YsoOptionsWithVerbose, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetAllYsoClassOptions not implemented")
}
func (UnimplementedYakServer) GetAllYsoClassGeneraterOptions(context.Context, *YsoOptionsRequerstWithVerbose) (*YsoClassOptionsResponseWithVerbose, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetAllYsoClassGeneraterOptions not implemented")
}
func (UnimplementedYakServer) GenerateYsoCode(context.Context, *YsoOptionsRequerstWithVerbose) (*YsoCodeResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GenerateYsoCode not implemented")
}
func (UnimplementedYakServer) GenerateYsoBytes(context.Context, *YsoOptionsRequerstWithVerbose) (*YsoBytesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GenerateYsoBytes not implemented")
}
func (UnimplementedYakServer) YsoDump(context.Context, *YsoBytesObject) (*YsoDumpResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method YsoDump not implemented")
}
func (UnimplementedYakServer) CreateWebShell(context.Context, *WebShell) (*WebShell, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateWebShell not implemented")
}
func (UnimplementedYakServer) DeleteWebShell(context.Context, *DeleteWebShellRequest) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteWebShell not implemented")
}
func (UnimplementedYakServer) UpdateWebShell(context.Context, *WebShell) (*WebShell, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateWebShell not implemented")
}
func (UnimplementedYakServer) QueryWebShells(context.Context, *QueryWebShellsRequest) (*QueryWebShellsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QueryWebShells not implemented")
}
func (UnimplementedYakServer) Ping(context.Context, *WebShellRequest) (*WebShellResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Ping not implemented")
}
func (UnimplementedYakServer) GetBasicInfo(context.Context, *WebShellRequest) (*WebShellResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetBasicInfo not implemented")
}
func (UnimplementedYakServer) GenerateWebShell(context.Context, *ShellGenerate) (*WebShellResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GenerateWebShell not implemented")
}
func (UnimplementedYakServer) SetYakBridgeLogServer(context.Context, *YakDNSLogBridgeAddr) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetYakBridgeLogServer not implemented")
}
func (UnimplementedYakServer) GetCurrentYakBridgeLogServer(context.Context, *Empty) (*YakDNSLogBridgeAddr, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetCurrentYakBridgeLogServer not implemented")
}
func (UnimplementedYakServer) RequireDNSLogDomain(context.Context, *YakDNSLogBridgeAddr) (*DNSLogRootDomain, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RequireDNSLogDomain not implemented")
}
func (UnimplementedYakServer) RequireDNSLogDomainByScript(context.Context, *RequireDNSLogDomainByScriptRequest) (*DNSLogRootDomain, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RequireDNSLogDomainByScript not implemented")
}
func (UnimplementedYakServer) QueryDNSLogByToken(context.Context, *QueryDNSLogByTokenRequest) (*QueryDNSLogByTokenResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QueryDNSLogByToken not implemented")
}
func (UnimplementedYakServer) QueryDNSLogTokenByScript(context.Context, *RequireDNSLogDomainByScriptRequest) (*QueryDNSLogByTokenResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QueryDNSLogTokenByScript not implemented")
}
func (UnimplementedYakServer) RequireICMPRandomLength(context.Context, *Empty) (*RequireICMPRandomLengthResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RequireICMPRandomLength not implemented")
}
func (UnimplementedYakServer) QueryICMPTrigger(context.Context, *QueryICMPTriggerRequest) (*QueryICMPTriggerResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QueryICMPTrigger not implemented")
}
func (UnimplementedYakServer) RequireRandomPortToken(context.Context, *Empty) (*RandomPortInfo, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RequireRandomPortToken not implemented")
}
func (UnimplementedYakServer) QueryRandomPortTrigger(context.Context, *QueryRandomPortTriggerRequest) (*RandomPortTriggerNotification, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QueryRandomPortTrigger not implemented")
}
func (UnimplementedYakServer) QuerySupportedDnsLogPlatforms(context.Context, *Empty) (*QuerySupportedDnsLogPlatformsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QuerySupportedDnsLogPlatforms not implemented")
}
func (UnimplementedYakServer) GetAvailableYakScriptTags(context.Context, *Empty) (*Fields, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetAvailableYakScriptTags not implemented")
}
func (UnimplementedYakServer) ForceUpdateAvailableYakScriptTags(context.Context, *Empty) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ForceUpdateAvailableYakScriptTags not implemented")
}
func (UnimplementedYakServer) ExecYakitPluginsByYakScriptFilter(*ExecYakitPluginsByYakScriptFilterRequest, grpc.ServerStreamingServer[ExecResult]) error {
	return status.Errorf(codes.Unimplemented, "method ExecYakitPluginsByYakScriptFilter not implemented")
}
func (UnimplementedYakServer) GenerateYakCodeByPacket(context.Context, *GenerateYakCodeByPacketRequest) (*GenerateYakCodeByPacketResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GenerateYakCodeByPacket not implemented")
}
func (UnimplementedYakServer) GenerateCSRFPocByPacket(context.Context, *GenerateCSRFPocByPacketRequest) (*GenerateCSRFPocByPacketResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GenerateCSRFPocByPacket not implemented")
}
func (UnimplementedYakServer) ExportMITMReplacerRules(context.Context, *Empty) (*ExportMITMReplacerRulesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ExportMITMReplacerRules not implemented")
}
func (UnimplementedYakServer) ImportMITMReplacerRules(context.Context, *ImportMITMReplacerRulesRequest) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ImportMITMReplacerRules not implemented")
}
func (UnimplementedYakServer) GetCurrentRules(context.Context, *Empty) (*MITMContentReplacers, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetCurrentRules not implemented")
}
func (UnimplementedYakServer) SetCurrentRules(context.Context, *MITMContentReplacers) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetCurrentRules not implemented")
}
func (UnimplementedYakServer) GenerateURL(context.Context, *GenerateURLRequest) (*GenerateURLResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GenerateURL not implemented")
}
func (UnimplementedYakServer) ExtractDataToFile(grpc.BidiStreamingServer[ExtractDataToFileRequest, ExtractDataToFileResult]) error {
	return status.Errorf(codes.Unimplemented, "method ExtractDataToFile not implemented")
}
func (UnimplementedYakServer) AutoDecode(context.Context, *AutoDecodeRequest) (*AutoDecodeResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AutoDecode not implemented")
}
func (UnimplementedYakServer) GetSystemProxy(context.Context, *Empty) (*GetSystemProxyResult, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetSystemProxy not implemented")
}
func (UnimplementedYakServer) SetSystemProxy(context.Context, *SetSystemProxyRequest) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetSystemProxy not implemented")
}
func (UnimplementedYakServer) GetKey(context.Context, *GetKeyRequest) (*GetKeyResult, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetKey not implemented")
}
func (UnimplementedYakServer) SetKey(context.Context, *SetKeyRequest) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetKey not implemented")
}
func (UnimplementedYakServer) DelKey(context.Context, *GetKeyRequest) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DelKey not implemented")
}
func (UnimplementedYakServer) GetAllProcessEnvKey(context.Context, *Empty) (*GetProcessEnvKeyResult, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetAllProcessEnvKey not implemented")
}
func (UnimplementedYakServer) SetProcessEnvKey(context.Context, *SetKeyRequest) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetProcessEnvKey not implemented")
}
func (UnimplementedYakServer) GetProjectKey(context.Context, *GetKeyRequest) (*GetKeyResult, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetProjectKey not implemented")
}
func (UnimplementedYakServer) SetProjectKey(context.Context, *SetKeyRequest) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetProjectKey not implemented")
}
func (UnimplementedYakServer) GetOnlineProfile(context.Context, *Empty) (*OnlineProfile, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetOnlineProfile not implemented")
}
func (UnimplementedYakServer) SetOnlineProfile(context.Context, *OnlineProfile) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetOnlineProfile not implemented")
}
func (UnimplementedYakServer) DownloadOnlinePluginById(context.Context, *DownloadOnlinePluginByIdRequest) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DownloadOnlinePluginById not implemented")
}
func (UnimplementedYakServer) DownloadOnlinePluginByIds(context.Context, *DownloadOnlinePluginByIdsRequest) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DownloadOnlinePluginByIds not implemented")
}
func (UnimplementedYakServer) DownloadOnlinePluginAll(*DownloadOnlinePluginByTokenRequest, grpc.ServerStreamingServer[DownloadOnlinePluginProgress]) error {
	return status.Errorf(codes.Unimplemented, "method DownloadOnlinePluginAll not implemented")
}
func (UnimplementedYakServer) DeletePluginByUserID(context.Context, *DeletePluginByUserIDRequest) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeletePluginByUserID not implemented")
}
func (UnimplementedYakServer) DeleteAllLocalPlugins(context.Context, *Empty) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteAllLocalPlugins not implemented")
}
func (UnimplementedYakServer) GetYakScriptTagsAndType(context.Context, *Empty) (*GetYakScriptTagsAndTypeResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetYakScriptTagsAndType not implemented")
}
func (UnimplementedYakServer) DeleteLocalPluginsByWhere(context.Context, *DeleteLocalPluginsByWhereRequest) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteLocalPluginsByWhere not implemented")
}
func (UnimplementedYakServer) DownloadOnlinePluginByScriptNames(context.Context, *DownloadOnlinePluginByScriptNamesRequest) (*DownloadOnlinePluginByScriptNamesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DownloadOnlinePluginByScriptNames not implemented")
}
func (UnimplementedYakServer) DownloadOnlinePlugins(*DownloadOnlinePluginsRequest, grpc.ServerStreamingServer[DownloadOnlinePluginProgress]) error {
	return status.Errorf(codes.Unimplemented, "method DownloadOnlinePlugins not implemented")
}
func (UnimplementedYakServer) DownloadOnlinePluginBatch(context.Context, *DownloadOnlinePluginsRequest) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DownloadOnlinePluginBatch not implemented")
}
func (UnimplementedYakServer) DownloadOnlinePluginByPluginName(context.Context, *DownloadOnlinePluginByScriptNamesRequest) (*DownloadOnlinePluginByScriptNamesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DownloadOnlinePluginByPluginName not implemented")
}
func (UnimplementedYakServer) DownloadOnlinePluginByUUID(context.Context, *DownloadOnlinePluginByUUIDRequest) (*YakScript, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DownloadOnlinePluginByUUID not implemented")
}
func (UnimplementedYakServer) QueryOnlinePlugins(context.Context, *QueryOnlinePluginsRequest) (*QueryOnlinePluginsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QueryOnlinePlugins not implemented")
}
func (UnimplementedYakServer) ExecPacketScan(*ExecPacketScanRequest, grpc.ServerStreamingServer[ExecResult]) error {
	return status.Errorf(codes.Unimplemented, "method ExecPacketScan not implemented")
}
func (UnimplementedYakServer) GetEngineDefaultProxy(context.Context, *Empty) (*DefaultProxyResult, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetEngineDefaultProxy not implemented")
}
func (UnimplementedYakServer) SetEngineDefaultProxy(context.Context, *DefaultProxyResult) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetEngineDefaultProxy not implemented")
}
func (UnimplementedYakServer) GetMachineID(context.Context, *Empty) (*GetMachineIDResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetMachineID not implemented")
}
func (UnimplementedYakServer) GetLicense(context.Context, *Empty) (*GetLicenseResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetLicense not implemented")
}
func (UnimplementedYakServer) CheckLicense(context.Context, *CheckLicenseRequest) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CheckLicense not implemented")
}
func (UnimplementedYakServer) GetRequestBodyByHTTPFlowID(context.Context, *DownloadBodyByHTTPFlowIDRequest) (*Bytes, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetRequestBodyByHTTPFlowID not implemented")
}
func (UnimplementedYakServer) GetResponseBodyByHTTPFlowID(context.Context, *DownloadBodyByHTTPFlowIDRequest) (*Bytes, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetResponseBodyByHTTPFlowID not implemented")
}
func (UnimplementedYakServer) GetHTTPPacketBody(context.Context, *GetHTTPPacketBodyRequest) (*Bytes, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetHTTPPacketBody not implemented")
}
func (UnimplementedYakServer) RegisterFacadesHTTP(context.Context, *RegisterFacadesHTTPRequest) (*RegisterFacadesHTTPResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RegisterFacadesHTTP not implemented")
}
func (UnimplementedYakServer) ResetAndInvalidUserData(context.Context, *ResetAndInvalidUserDataRequest) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ResetAndInvalidUserData not implemented")
}
func (UnimplementedYakServer) CreateYaklangShell(grpc.BidiStreamingServer[YaklangShellRequest, YaklangShellResponse]) error {
	return status.Errorf(codes.Unimplemented, "method CreateYaklangShell not implemented")
}
func (UnimplementedYakServer) AttachCombinedOutput(*AttachCombinedOutputRequest, grpc.ServerStreamingServer[ExecResult]) error {
	return status.Errorf(codes.Unimplemented, "method AttachCombinedOutput not implemented")
}
func (UnimplementedYakServer) IsPrivilegedForNetRaw(context.Context, *Empty) (*IsPrivilegedForNetRawResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method IsPrivilegedForNetRaw not implemented")
}
func (UnimplementedYakServer) PromotePermissionForUserPcap(context.Context, *Empty) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PromotePermissionForUserPcap not implemented")
}
func (UnimplementedYakServer) SetCurrentProject(context.Context, *SetCurrentProjectRequest) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetCurrentProject not implemented")
}
func (UnimplementedYakServer) GetCurrentProject(context.Context, *Empty) (*ProjectDescription, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetCurrentProject not implemented")
}
func (UnimplementedYakServer) GetCurrentProjectEx(context.Context, *GetCurrentProjectExRequest) (*ProjectDescription, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetCurrentProjectEx not implemented")
}
func (UnimplementedYakServer) GetProjects(context.Context, *GetProjectsRequest) (*GetProjectsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetProjects not implemented")
}
func (UnimplementedYakServer) NewProject(context.Context, *NewProjectRequest) (*NewProjectResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method NewProject not implemented")
}
func (UnimplementedYakServer) UpdateProject(context.Context, *NewProjectRequest) (*NewProjectResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateProject not implemented")
}
func (UnimplementedYakServer) IsProjectNameValid(context.Context, *IsProjectNameValidRequest) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method IsProjectNameValid not implemented")
}
func (UnimplementedYakServer) RemoveProject(context.Context, *RemoveProjectRequest) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RemoveProject not implemented")
}
func (UnimplementedYakServer) DeleteProject(context.Context, *DeleteProjectRequest) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteProject not implemented")
}
func (UnimplementedYakServer) GetDefaultProject(context.Context, *Empty) (*ProjectDescription, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetDefaultProject not implemented")
}
func (UnimplementedYakServer) GetDefaultProjectEx(context.Context, *GetDefaultProjectExRequest) (*ProjectDescription, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetDefaultProjectEx not implemented")
}
func (UnimplementedYakServer) QueryProjectDetail(context.Context, *QueryProjectDetailRequest) (*ProjectDescription, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QueryProjectDetail not implemented")
}
func (UnimplementedYakServer) GetTemporaryProject(context.Context, *Empty) (*ProjectDescription, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetTemporaryProject not implemented")
}
func (UnimplementedYakServer) GetTemporaryProjectEx(context.Context, *GetTemporaryProjectExRequest) (*ProjectDescription, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetTemporaryProjectEx not implemented")
}
func (UnimplementedYakServer) ExportProject(*ExportProjectRequest, grpc.ServerStreamingServer[ProjectIOProgress]) error {
	return status.Errorf(codes.Unimplemented, "method ExportProject not implemented")
}
func (UnimplementedYakServer) ImportProject(*ImportProjectRequest, grpc.ServerStreamingServer[ProjectIOProgress]) error {
	return status.Errorf(codes.Unimplemented, "method ImportProject not implemented")
}
func (UnimplementedYakServer) MigrateLegacyDatabase(context.Context, *Empty) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method MigrateLegacyDatabase not implemented")
}
func (UnimplementedYakServer) QueryMITMRuleExtractedData(context.Context, *QueryMITMRuleExtractedDataRequest) (*QueryMITMRuleExtractedDataResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QueryMITMRuleExtractedData not implemented")
}
func (UnimplementedYakServer) ExportMITMRuleExtractedData(*ExportMITMRuleExtractedDataRequest, grpc.ServerStreamingServer[ExportMITMRuleExtractedDataResponse]) error {
	return status.Errorf(codes.Unimplemented, "method ExportMITMRuleExtractedData not implemented")
}
func (UnimplementedYakServer) ImportChaosMakerRules(context.Context, *ImportChaosMakerRulesRequest) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ImportChaosMakerRules not implemented")
}
func (UnimplementedYakServer) QueryChaosMakerRule(context.Context, *QueryChaosMakerRuleRequest) (*QueryChaosMakerRuleResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QueryChaosMakerRule not implemented")
}
func (UnimplementedYakServer) DeleteChaosMakerRuleByID(context.Context, *DeleteChaosMakerRuleByIDRequest) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteChaosMakerRuleByID not implemented")
}
func (UnimplementedYakServer) ExecuteChaosMakerRule(*ExecuteChaosMakerRuleRequest, grpc.ServerStreamingServer[ExecResult]) error {
	return status.Errorf(codes.Unimplemented, "method ExecuteChaosMakerRule not implemented")
}
func (UnimplementedYakServer) IsRemoteAddrAvailable(context.Context, *IsRemoteAddrAvailableRequest) (*IsRemoteAddrAvailableResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method IsRemoteAddrAvailable not implemented")
}
func (UnimplementedYakServer) ConnectVulinboxAgent(context.Context, *IsRemoteAddrAvailableRequest) (*IsRemoteAddrAvailableResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ConnectVulinboxAgent not implemented")
}
func (UnimplementedYakServer) GetRegisteredVulinboxAgent(context.Context, *GetRegisteredAgentRequest) (*GetRegisteredAgentResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetRegisteredVulinboxAgent not implemented")
}
func (UnimplementedYakServer) DisconnectVulinboxAgent(context.Context, *DisconnectVulinboxAgentRequest) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DisconnectVulinboxAgent not implemented")
}
func (UnimplementedYakServer) IsCVEDatabaseReady(context.Context, *IsCVEDatabaseReadyRequest) (*IsCVEDatabaseReadyResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method IsCVEDatabaseReady not implemented")
}
func (UnimplementedYakServer) UpdateCVEDatabase(*UpdateCVEDatabaseRequest, grpc.ServerStreamingServer[ExecResult]) error {
	return status.Errorf(codes.Unimplemented, "method UpdateCVEDatabase not implemented")
}
func (UnimplementedYakServer) ExportsProfileDatabase(*ExportsProfileDatabaseRequest, grpc.ServerStreamingServer[ExecResult]) error {
	return status.Errorf(codes.Unimplemented, "method ExportsProfileDatabase not implemented")
}
func (UnimplementedYakServer) ImportsProfileDatabase(*ImportsProfileDatabaseRequest, grpc.ServerStreamingServer[ExecResult]) error {
	return status.Errorf(codes.Unimplemented, "method ImportsProfileDatabase not implemented")
}
func (UnimplementedYakServer) QueryCVE(context.Context, *QueryCVERequest) (*QueryCVEResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QueryCVE not implemented")
}
func (UnimplementedYakServer) GetCVE(context.Context, *GetCVERequest) (*CVEDetailEx, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetCVE not implemented")
}
func (UnimplementedYakServer) SaveTextToTemporalFile(context.Context, *SaveTextToTemporalFileRequest) (*SaveTextToTemporalFileResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SaveTextToTemporalFile not implemented")
}
func (UnimplementedYakServer) IsScrecorderReady(context.Context, *IsScrecorderReadyRequest) (*IsScrecorderReadyResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method IsScrecorderReady not implemented")
}
func (UnimplementedYakServer) InstallScrecorder(*InstallScrecorderRequest, grpc.ServerStreamingServer[ExecResult]) error {
	return status.Errorf(codes.Unimplemented, "method InstallScrecorder not implemented")
}
func (UnimplementedYakServer) StartScrecorder(*StartScrecorderRequest, grpc.ServerStreamingServer[ExecResult]) error {
	return status.Errorf(codes.Unimplemented, "method StartScrecorder not implemented")
}
func (UnimplementedYakServer) QueryScreenRecorders(context.Context, *QueryScreenRecorderRequest) (*QueryScreenRecorderResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QueryScreenRecorders not implemented")
}
func (UnimplementedYakServer) DeleteScreenRecorders(context.Context, *QueryScreenRecorderRequest) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteScreenRecorders not implemented")
}
func (UnimplementedYakServer) UploadScreenRecorders(context.Context, *UploadScreenRecorderRequest) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UploadScreenRecorders not implemented")
}
func (UnimplementedYakServer) GetOneScreenRecorders(context.Context, *GetOneScreenRecorderRequest) (*ScreenRecorder, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetOneScreenRecorders not implemented")
}
func (UnimplementedYakServer) UpdateScreenRecorders(context.Context, *UpdateScreenRecorderRequest) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateScreenRecorders not implemented")
}
func (UnimplementedYakServer) IsVulinboxReady(context.Context, *IsVulinboxReadyRequest) (*IsVulinboxReadyResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method IsVulinboxReady not implemented")
}
func (UnimplementedYakServer) InstallVulinbox(*InstallVulinboxRequest, grpc.ServerStreamingServer[ExecResult]) error {
	return status.Errorf(codes.Unimplemented, "method InstallVulinbox not implemented")
}
func (UnimplementedYakServer) StartVulinbox(*StartVulinboxRequest, grpc.ServerStreamingServer[ExecResult]) error {
	return status.Errorf(codes.Unimplemented, "method StartVulinbox not implemented")
}
func (UnimplementedYakServer) GenQualityInspectionReport(*GenQualityInspectionReportRequest, grpc.ServerStreamingServer[ExecResult]) error {
	return status.Errorf(codes.Unimplemented, "method GenQualityInspectionReport not implemented")
}
func (UnimplementedYakServer) HTTPRequestBuilder(context.Context, *HTTPRequestBuilderParams) (*HTTPRequestBuilderResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method HTTPRequestBuilder not implemented")
}
func (UnimplementedYakServer) DebugPlugin(*DebugPluginRequest, grpc.ServerStreamingServer[ExecResult]) error {
	return status.Errorf(codes.Unimplemented, "method DebugPlugin not implemented")
}
func (UnimplementedYakServer) SmokingEvaluatePlugin(context.Context, *SmokingEvaluatePluginRequest) (*SmokingEvaluatePluginResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SmokingEvaluatePlugin not implemented")
}
func (UnimplementedYakServer) SmokingEvaluatePluginBatch(*SmokingEvaluatePluginBatchRequest, grpc.ServerStreamingServer[SmokingEvaluatePluginBatchResponse]) error {
	return status.Errorf(codes.Unimplemented, "method SmokingEvaluatePluginBatch not implemented")
}
func (UnimplementedYakServer) GetSystemDefaultDnsServers(context.Context, *Empty) (*DefaultDnsServerResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetSystemDefaultDnsServers not implemented")
}
func (UnimplementedYakServer) DiagnoseNetwork(*DiagnoseNetworkRequest, grpc.ServerStreamingServer[DiagnoseNetworkResponse]) error {
	return status.Errorf(codes.Unimplemented, "method DiagnoseNetwork not implemented")
}
func (UnimplementedYakServer) DiagnoseNetworkDNS(*DiagnoseNetworkDNSRequest, grpc.ServerStreamingServer[DiagnoseNetworkResponse]) error {
	return status.Errorf(codes.Unimplemented, "method DiagnoseNetworkDNS not implemented")
}
func (UnimplementedYakServer) TraceRoute(*TraceRouteRequest, grpc.ServerStreamingServer[TraceRouteResponse]) error {
	return status.Errorf(codes.Unimplemented, "method TraceRoute not implemented")
}
func (UnimplementedYakServer) GetGlobalNetworkConfig(context.Context, *GetGlobalNetworkConfigRequest) (*GlobalNetworkConfig, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetGlobalNetworkConfig not implemented")
}
func (UnimplementedYakServer) SetGlobalNetworkConfig(context.Context, *GlobalNetworkConfig) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetGlobalNetworkConfig not implemented")
}
func (UnimplementedYakServer) ResetGlobalNetworkConfig(context.Context, *ResetGlobalNetworkConfigRequest) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ResetGlobalNetworkConfig not implemented")
}
func (UnimplementedYakServer) ValidP12PassWord(context.Context, *ValidP12PassWordRequest) (*ValidP12PassWordResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ValidP12PassWord not implemented")
}
func (UnimplementedYakServer) RequestYakURL(context.Context, *RequestYakURLParams) (*RequestYakURLResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RequestYakURL not implemented")
}
func (UnimplementedYakServer) ReadFile(*ReadFileRequest, grpc.ServerStreamingServer[ReadFileResponse]) error {
	return status.Errorf(codes.Unimplemented, "method ReadFile not implemented")
}
func (UnimplementedYakServer) GetPcapMetadata(context.Context, *PcapMetadataRequest) (*PcapMetadata, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetPcapMetadata not implemented")
}
func (UnimplementedYakServer) PcapX(grpc.BidiStreamingServer[PcapXRequest, PcapXResponse]) error {
	return status.Errorf(codes.Unimplemented, "method PcapX not implemented")
}
func (UnimplementedYakServer) QueryTrafficSession(context.Context, *QueryTrafficSessionRequest) (*QueryTrafficSessionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QueryTrafficSession not implemented")
}
func (UnimplementedYakServer) QueryTrafficPacket(context.Context, *QueryTrafficPacketRequest) (*QueryTrafficPacketResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QueryTrafficPacket not implemented")
}
func (UnimplementedYakServer) QueryTrafficTCPReassembled(context.Context, *QueryTrafficTCPReassembledRequest) (*QueryTrafficTCPReassembledResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QueryTrafficTCPReassembled not implemented")
}
func (UnimplementedYakServer) ParseTraffic(context.Context, *ParseTrafficRequest) (*ParseTrafficResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ParseTraffic not implemented")
}
func (UnimplementedYakServer) DuplexConnection(grpc.BidiStreamingServer[DuplexConnectionRequest, DuplexConnectionResponse]) error {
	return status.Errorf(codes.Unimplemented, "method DuplexConnection not implemented")
}
func (UnimplementedYakServer) HybridScan(grpc.BidiStreamingServer[HybridScanRequest, HybridScanResponse]) error {
	return status.Errorf(codes.Unimplemented, "method HybridScan not implemented")
}
func (UnimplementedYakServer) QueryHybridScanTask(context.Context, *QueryHybridScanTaskRequest) (*QueryHybridScanTaskResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QueryHybridScanTask not implemented")
}
func (UnimplementedYakServer) DeleteHybridScanTask(context.Context, *DeleteHybridScanTaskRequest) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteHybridScanTask not implemented")
}
func (UnimplementedYakServer) GetSpaceEngineStatus(context.Context, *GetSpaceEngineStatusRequest) (*SpaceEngineStatus, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetSpaceEngineStatus not implemented")
}
func (UnimplementedYakServer) GetSpaceEngineAccountStatus(context.Context, *GetSpaceEngineAccountStatusRequest) (*SpaceEngineStatus, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetSpaceEngineAccountStatus not implemented")
}
func (UnimplementedYakServer) GetSpaceEngineAccountStatusV2(context.Context, *ThirdPartyApplicationConfig) (*SpaceEngineStatus, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetSpaceEngineAccountStatusV2 not implemented")
}
func (UnimplementedYakServer) FetchPortAssetFromSpaceEngine(*FetchPortAssetFromSpaceEngineRequest, grpc.ServerStreamingServer[ExecResult]) error {
	return status.Errorf(codes.Unimplemented, "method FetchPortAssetFromSpaceEngine not implemented")
}
func (UnimplementedYakServer) EvaluateExpression(context.Context, *EvaluateExpressionRequest) (*EvaluateExpressionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method EvaluateExpression not implemented")
}
func (UnimplementedYakServer) EvaluateMultiExpression(context.Context, *EvaluateMultiExpressionRequest) (*EvaluateMultiExpressionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method EvaluateMultiExpression not implemented")
}
func (UnimplementedYakServer) GetThirdPartyAppConfigTemplate(context.Context, *Empty) (*GetThirdPartyAppConfigTemplateResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetThirdPartyAppConfigTemplate not implemented")
}
func (UnimplementedYakServer) CheckHahValidAiConfig(context.Context, *Empty) (*GeneralResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CheckHahValidAiConfig not implemented")
}
func (UnimplementedYakServer) ListAiModel(context.Context, *ListAiModelRequest) (*ListAiModelResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListAiModel not implemented")
}
func (UnimplementedYakServer) GetFingerprint(context.Context, *GetFingerprintRequest) (*GetFingerprintResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetFingerprint not implemented")
}
func (UnimplementedYakServer) AddFingerprint(context.Context, *AddFingerprintRequest) (*AddFingerprintResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddFingerprint not implemented")
}
func (UnimplementedYakServer) ModifyFingerprint(context.Context, *ModifyFingerprintRequest) (*ModifyFingerprintResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ModifyFingerprint not implemented")
}
func (UnimplementedYakServer) QueryFingerprint(context.Context, *QueryFingerprintRequest) (*QueryFingerprintResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QueryFingerprint not implemented")
}
func (UnimplementedYakServer) DeleteFingerprint(context.Context, *DeleteFingerprintRequest) (*DbOperateMessage, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteFingerprint not implemented")
}
func (UnimplementedYakServer) UpdateFingerprint(context.Context, *UpdateFingerprintRequest) (*DbOperateMessage, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateFingerprint not implemented")
}
func (UnimplementedYakServer) CreateFingerprint(context.Context, *CreateFingerprintRequest) (*DbOperateMessage, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateFingerprint not implemented")
}
func (UnimplementedYakServer) RecoverBuiltinFingerprint(context.Context, *Empty) (*DbOperateMessage, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RecoverBuiltinFingerprint not implemented")
}
func (UnimplementedYakServer) CreateFingerprintGroup(context.Context, *FingerprintGroup) (*DbOperateMessage, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateFingerprintGroup not implemented")
}
func (UnimplementedYakServer) GetAllFingerprintGroup(context.Context, *Empty) (*FingerprintGroups, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetAllFingerprintGroup not implemented")
}
func (UnimplementedYakServer) RenameFingerprintGroup(context.Context, *RenameFingerprintGroupRequest) (*DbOperateMessage, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RenameFingerprintGroup not implemented")
}
func (UnimplementedYakServer) DeleteFingerprintGroup(context.Context, *DeleteFingerprintGroupRequest) (*DbOperateMessage, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteFingerprintGroup not implemented")
}
func (UnimplementedYakServer) BatchUpdateFingerprintToGroup(context.Context, *BatchUpdateFingerprintToGroupRequest) (*DbOperateMessage, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BatchUpdateFingerprintToGroup not implemented")
}
func (UnimplementedYakServer) GetFingerprintGroupSetByFilter(context.Context, *GetFingerprintGroupSetRequest) (*FingerprintGroups, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetFingerprintGroupSetByFilter not implemented")
}
func (UnimplementedYakServer) ExportFingerprint(*ExportFingerprintRequest, grpc.ServerStreamingServer[DataTransferProgress]) error {
	return status.Errorf(codes.Unimplemented, "method ExportFingerprint not implemented")
}
func (UnimplementedYakServer) ImportFingerprint(*ImportFingerprintRequest, grpc.ServerStreamingServer[DataTransferProgress]) error {
	return status.Errorf(codes.Unimplemented, "method ImportFingerprint not implemented")
}
func (UnimplementedYakServer) GetReverseShellProgramList(context.Context, *GetReverseShellProgramListRequest) (*GetReverseShellProgramListResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetReverseShellProgramList not implemented")
}
func (UnimplementedYakServer) GenerateReverseShellCommand(context.Context, *GenerateReverseShellCommandRequest) (*GenerateReverseShellCommandResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GenerateReverseShellCommand not implemented")
}
func (UnimplementedYakServer) QuerySyntaxFlowRule(context.Context, *QuerySyntaxFlowRuleRequest) (*QuerySyntaxFlowRuleResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QuerySyntaxFlowRule not implemented")
}
func (UnimplementedYakServer) CreateSyntaxFlowRule(context.Context, *CreateSyntaxFlowRuleRequest) (*DbOperateMessage, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateSyntaxFlowRule not implemented")
}
func (UnimplementedYakServer) CreateSyntaxFlowRuleEx(context.Context, *CreateSyntaxFlowRuleRequest) (*CreateSyntaxFlowRuleResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateSyntaxFlowRuleEx not implemented")
}
func (UnimplementedYakServer) UpdateSyntaxFlowRule(context.Context, *UpdateSyntaxFlowRuleRequest) (*DbOperateMessage, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateSyntaxFlowRule not implemented")
}
func (UnimplementedYakServer) UpdateSyntaxFlowRuleEx(context.Context, *UpdateSyntaxFlowRuleRequest) (*UpdateSyntaxFlowRuleResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateSyntaxFlowRuleEx not implemented")
}
func (UnimplementedYakServer) DeleteSyntaxFlowRule(context.Context, *DeleteSyntaxFlowRuleRequest) (*DbOperateMessage, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteSyntaxFlowRule not implemented")
}
func (UnimplementedYakServer) CheckSyntaxFlowRuleUpdate(context.Context, *CheckSyntaxFlowRuleUpdateRequest) (*CheckSyntaxFlowRuleUpdateResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CheckSyntaxFlowRuleUpdate not implemented")
}
func (UnimplementedYakServer) ApplySyntaxFlowRuleUpdate(*ApplySyntaxFlowRuleUpdateRequest, grpc.ServerStreamingServer[ApplySyntaxFlowRuleUpdateResponse]) error {
	return status.Errorf(codes.Unimplemented, "method ApplySyntaxFlowRuleUpdate not implemented")
}
func (UnimplementedYakServer) QuerySyntaxFlowRuleGroup(context.Context, *QuerySyntaxFlowRuleGroupRequest) (*QuerySyntaxFlowRuleGroupResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QuerySyntaxFlowRuleGroup not implemented")
}
func (UnimplementedYakServer) DeleteSyntaxFlowRuleGroup(context.Context, *DeleteSyntaxFlowRuleGroupRequest) (*DbOperateMessage, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteSyntaxFlowRuleGroup not implemented")
}
func (UnimplementedYakServer) CreateSyntaxFlowRuleGroup(context.Context, *CreateSyntaxFlowGroupRequest) (*DbOperateMessage, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateSyntaxFlowRuleGroup not implemented")
}
func (UnimplementedYakServer) UpdateSyntaxFlowRuleGroup(context.Context, *UpdateSyntaxFlowRuleGroupRequest) (*DbOperateMessage, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateSyntaxFlowRuleGroup not implemented")
}
func (UnimplementedYakServer) UpdateSyntaxFlowRuleAndGroup(context.Context, *UpdateSyntaxFlowRuleAndGroupRequest) (*DbOperateMessage, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateSyntaxFlowRuleAndGroup not implemented")
}
func (UnimplementedYakServer) QuerySyntaxFlowSameGroup(context.Context, *QuerySyntaxFlowSameGroupRequest) (*QuerySyntaxFlowSameGroupResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QuerySyntaxFlowSameGroup not implemented")
}
func (UnimplementedYakServer) SyntaxFlowRuleToOnline(*SyntaxFlowRuleToOnlineRequest, grpc.ServerStreamingServer[SyntaxFlowRuleOnlineProgress]) error {
	return status.Errorf(codes.Unimplemented, "method SyntaxFlowRuleToOnline not implemented")
}
func (UnimplementedYakServer) DownloadSyntaxFlowRule(*DownloadSyntaxFlowRuleRequest, grpc.ServerStreamingServer[SyntaxFlowRuleOnlineProgress]) error {
	return status.Errorf(codes.Unimplemented, "method DownloadSyntaxFlowRule not implemented")
}
func (UnimplementedYakServer) SyntaxFlowScan(grpc.BidiStreamingServer[SyntaxFlowScanRequest, SyntaxFlowScanResponse]) error {
	return status.Errorf(codes.Unimplemented, "method SyntaxFlowScan not implemented")
}
func (UnimplementedYakServer) QuerySyntaxFlowScanTask(context.Context, *QuerySyntaxFlowScanTaskRequest) (*QuerySyntaxFlowScanTaskResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QuerySyntaxFlowScanTask not implemented")
}
func (UnimplementedYakServer) DeleteSyntaxFlowScanTask(context.Context, *DeleteSyntaxFlowScanTaskRequest) (*DbOperateMessage, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteSyntaxFlowScanTask not implemented")
}
func (UnimplementedYakServer) QuerySyntaxFlowResult(context.Context, *QuerySyntaxFlowResultRequest) (*QuerySyntaxFlowResultResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QuerySyntaxFlowResult not implemented")
}
func (UnimplementedYakServer) DeleteSyntaxFlowResult(context.Context, *DeleteSyntaxFlowResultRequest) (*DeleteSyntaxFlowResultResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteSyntaxFlowResult not implemented")
}
func (UnimplementedYakServer) QuerySSAPrograms(context.Context, *QuerySSAProgramRequest) (*QuerySSAProgramResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QuerySSAPrograms not implemented")
}
func (UnimplementedYakServer) UpdateSSAProgram(context.Context, *UpdateSSAProgramRequest) (*DbOperateMessage, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateSSAProgram not implemented")
}
func (UnimplementedYakServer) DeleteSSAPrograms(context.Context, *DeleteSSAProgramRequest) (*DbOperateMessage, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteSSAPrograms not implemented")
}
func (UnimplementedYakServer) QuerySSARisks(context.Context, *QuerySSARisksRequest) (*QuerySSARisksResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QuerySSARisks not implemented")
}
func (UnimplementedYakServer) QueryNewSSARisks(context.Context, *QueryNewSSARisksRequest) (*QueryNewSSARisksResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QueryNewSSARisks not implemented")
}
func (UnimplementedYakServer) DeleteSSARisks(context.Context, *DeleteSSARisksRequest) (*DbOperateMessage, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteSSARisks not implemented")
}
func (UnimplementedYakServer) UpdateSSARiskTags(context.Context, *UpdateSSARiskTagsRequest) (*DbOperateMessage, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateSSARiskTags not implemented")
}
func (UnimplementedYakServer) GetSSARiskFieldGroup(context.Context, *Empty) (*SSARiskFieldGroupResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetSSARiskFieldGroup not implemented")
}
func (UnimplementedYakServer) NewSSARiskRead(context.Context, *NewSSARiskReadRequest) (*NewSSARiskReadResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method NewSSARiskRead not implemented")
}
func (UnimplementedYakServer) SSARiskFeedbackToOnline(context.Context, *SSARiskFeedbackToOnlineRequest) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SSARiskFeedbackToOnline not implemented")
}
func (UnimplementedYakServer) GetAllPluginEnv(context.Context, *Empty) (*PluginEnvData, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetAllPluginEnv not implemented")
}
func (UnimplementedYakServer) QueryPluginEnv(context.Context, *QueryPluginEnvRequest) (*PluginEnvData, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QueryPluginEnv not implemented")
}
func (UnimplementedYakServer) CreatePluginEnv(context.Context, *PluginEnvData) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreatePluginEnv not implemented")
}
func (UnimplementedYakServer) SetPluginEnv(context.Context, *PluginEnvData) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetPluginEnv not implemented")
}
func (UnimplementedYakServer) DeletePluginEnv(context.Context, *DeletePluginEnvRequest) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeletePluginEnv not implemented")
}
func (UnimplementedYakServer) GetAllFuzztagInfo(context.Context, *GetAllFuzztagInfoRequest) (*GetAllFuzztagInfoResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetAllFuzztagInfo not implemented")
}
func (UnimplementedYakServer) GenerateFuzztag(context.Context, *GenerateFuzztagRequest) (*GenerateFuzztagResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GenerateFuzztag not implemented")
}
func (UnimplementedYakServer) ExportSyntaxFlows(*ExportSyntaxFlowsRequest, grpc.ServerStreamingServer[SyntaxflowsProgress]) error {
	return status.Errorf(codes.Unimplemented, "method ExportSyntaxFlows not implemented")
}
func (UnimplementedYakServer) ImportSyntaxFlows(*ImportSyntaxFlowsRequest, grpc.ServerStreamingServer[SyntaxflowsProgress]) error {
	return status.Errorf(codes.Unimplemented, "method ImportSyntaxFlows not implemented")
}
func (UnimplementedYakServer) CreateHotPatchTemplate(context.Context, *HotPatchTemplate) (*CreateHotPatchTemplateResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateHotPatchTemplate not implemented")
}
func (UnimplementedYakServer) DeleteHotPatchTemplate(context.Context, *DeleteHotPatchTemplateRequest) (*DeleteHotPatchTemplateResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteHotPatchTemplate not implemented")
}
func (UnimplementedYakServer) UpdateHotPatchTemplate(context.Context, *UpdateHotPatchTemplateRequest) (*UpdateHotPatchTemplateResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateHotPatchTemplate not implemented")
}
func (UnimplementedYakServer) QueryHotPatchTemplate(context.Context, *HotPatchTemplateRequest) (*QueryHotPatchTemplateResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QueryHotPatchTemplate not implemented")
}
func (UnimplementedYakServer) QueryHotPatchTemplateList(context.Context, *QueryHotPatchTemplateListRequest) (*QueryHotPatchTemplateListResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QueryHotPatchTemplateList not implemented")
}
func (UnimplementedYakServer) GroupTableColumn(context.Context, *GroupTableColumnRequest) (*GroupTableColumnResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GroupTableColumn not implemented")
}
func (UnimplementedYakServer) UploadHotPatchTemplateToOnline(context.Context, *UploadHotPatchTemplateToOnlineRequest) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UploadHotPatchTemplateToOnline not implemented")
}
func (UnimplementedYakServer) DownloadHotPatchTemplate(context.Context, *DownloadHotPatchTemplateRequest) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DownloadHotPatchTemplate not implemented")
}
func (UnimplementedYakServer) SetMITMHijackFilter(context.Context, *SetMITMFilterRequest) (*SetMITMFilterResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetMITMHijackFilter not implemented")
}
func (UnimplementedYakServer) GetMITMHijackFilter(context.Context, *Empty) (*SetMITMFilterRequest, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetMITMHijackFilter not implemented")
}
func (UnimplementedYakServer) ResetMITMHijackFilter(context.Context, *Empty) (*SetMITMFilterRequest, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ResetMITMHijackFilter not implemented")
}
func (UnimplementedYakServer) ExportHTTPFlowStream(*ExportHTTPFlowStreamRequest, grpc.ServerStreamingServer[ExportHTTPFlowStreamResponse]) error {
	return status.Errorf(codes.Unimplemented, "method ExportHTTPFlowStream not implemented")
}
func (UnimplementedYakServer) ImportHTTPFlowStream(*ImportHTTPFlowStreamRequest, grpc.ServerStreamingServer[ImportHTTPFlowStreamResponse]) error {
	return status.Errorf(codes.Unimplemented, "method ImportHTTPFlowStream not implemented")
}
func (UnimplementedYakServer) CreateNote(context.Context, *CreateNoteRequest) (*CreateNoteResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateNote not implemented")
}
func (UnimplementedYakServer) UpdateNote(context.Context, *UpdateNoteRequest) (*DbOperateMessage, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateNote not implemented")
}
func (UnimplementedYakServer) DeleteNote(context.Context, *DeleteNoteRequest) (*DbOperateMessage, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteNote not implemented")
}
func (UnimplementedYakServer) QueryNote(context.Context, *QueryNoteRequest) (*QueryNoteResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QueryNote not implemented")
}
func (UnimplementedYakServer) SearchNoteContent(context.Context, *SearchNoteContentRequest) (*SearchNoteContentResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SearchNoteContent not implemented")
}
func (UnimplementedYakServer) ImportNote(*ImportNoteRequest, grpc.ServerStreamingServer[ImportNoteResponse]) error {
	return status.Errorf(codes.Unimplemented, "method ImportNote not implemented")
}
func (UnimplementedYakServer) ExportNote(*ExportNoteRequest, grpc.ServerStreamingServer[ExportNoteResponse]) error {
	return status.Errorf(codes.Unimplemented, "method ExportNote not implemented")
}
func (UnimplementedYakServer) StartAITask(grpc.BidiStreamingServer[AIInputEvent, AIOutputEvent]) error {
	return status.Errorf(codes.Unimplemented, "method StartAITask not implemented")
}
func (UnimplementedYakServer) QueryAITask(context.Context, *AITaskQueryRequest) (*AITaskQueryResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QueryAITask not implemented")
}
func (UnimplementedYakServer) StartAITriage(grpc.BidiStreamingServer[AITriageInputEvent, AIOutputEvent]) error {
	return status.Errorf(codes.Unimplemented, "method StartAITriage not implemented")
}
func (UnimplementedYakServer) CreateAIForge(context.Context, *AIForge) (*DbOperateMessage, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateAIForge not implemented")
}
func (UnimplementedYakServer) UpdateAIForge(context.Context, *AIForge) (*DbOperateMessage, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateAIForge not implemented")
}
func (UnimplementedYakServer) DeleteAIForge(context.Context, *AIForgeFilter) (*DbOperateMessage, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteAIForge not implemented")
}
func (UnimplementedYakServer) QueryAIForge(context.Context, *QueryAIForgeRequest) (*QueryAIForgeResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QueryAIForge not implemented")
}
func (UnimplementedYakServer) StartMcpServer(*StartMcpServerRequest, grpc.ServerStreamingServer[StartMcpServerResponse]) error {
	return status.Errorf(codes.Unimplemented, "method StartMcpServer not implemented")
}
func (UnimplementedYakServer) GetToolSetList(context.Context, *Empty) (*GetToolSetListResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetToolSetList not implemented")
}
func (UnimplementedYakServer) GetAIToolList(context.Context, *GetAIToolListRequest) (*GetAIToolListResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetAIToolList not implemented")
}
func (UnimplementedYakServer) DeleteAITool(context.Context, *DeleteAIToolRequest) (*DbOperateMessage, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteAITool not implemented")
}
func (UnimplementedYakServer) SaveAITool(context.Context, *SaveAIToolRequest) (*DbOperateMessage, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SaveAITool not implemented")
}
func (UnimplementedYakServer) ToggleAIToolFavorite(context.Context, *ToggleAIToolFavoriteRequest) (*ToggleAIToolFavoriteResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ToggleAIToolFavorite not implemented")
}
func (UnimplementedYakServer) AIToolGenerateMetadata(context.Context, *AIToolGenerateMetadataRequest) (*AIToolGenerateMetadataResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AIToolGenerateMetadata not implemented")
}
func (UnimplementedYakServer) mustEmbedUnimplementedYakServer() {}
func (UnimplementedYakServer) testEmbeddedByValue()             {}

// UnsafeYakServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to YakServer will
// result in compilation errors.
type UnsafeYakServer interface {
	mustEmbedUnimplementedYakServer()
}

func RegisterYakServer(s grpc.ServiceRegistrar, srv YakServer) {
	// If the following call pancis, it indicates UnimplementedYakServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&Yak_ServiceDesc, srv)
}

func _Yak_Version_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).Version(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_Version_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).Version(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_YakVersionAtLeast_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(YakVersionAtLeastRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).YakVersionAtLeast(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_YakVersionAtLeast_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).YakVersionAtLeast(ctx, req.(*YakVersionAtLeastRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_Echo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EchoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).Echo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_Echo_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).Echo(ctx, req.(*EchoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_Handshake_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(HandshakeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).Handshake(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_Handshake_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).Handshake(ctx, req.(*HandshakeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_VerifySystemCertificate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).VerifySystemCertificate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_VerifySystemCertificate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).VerifySystemCertificate(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_MITM_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(YakServer).MITM(&grpc.GenericServerStream[MITMRequest, MITMResponse]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Yak_MITMServer = grpc.BidiStreamingServer[MITMRequest, MITMResponse]

func _Yak_SetMITMFilter_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetMITMFilterRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).SetMITMFilter(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_SetMITMFilter_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).SetMITMFilter(ctx, req.(*SetMITMFilterRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_GetMITMFilter_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).GetMITMFilter(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_GetMITMFilter_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).GetMITMFilter(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_ResetMITMFilter_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).ResetMITMFilter(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_ResetMITMFilter_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).ResetMITMFilter(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_DownloadMITMCert_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).DownloadMITMCert(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_DownloadMITMCert_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).DownloadMITMCert(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_MITMV2_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(YakServer).MITMV2(&grpc.GenericServerStream[MITMV2Request, MITMV2Response]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Yak_MITMV2Server = grpc.BidiStreamingServer[MITMV2Request, MITMV2Response]

func _Yak_OpenPort_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(YakServer).OpenPort(&grpc.GenericServerStream[Input, Output]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Yak_OpenPortServer = grpc.BidiStreamingServer[Input, Output]

func _Yak_Exec_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(ExecRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(YakServer).Exec(m, &grpc.GenericServerStream[ExecRequest, ExecResult]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Yak_ExecServer = grpc.ServerStreamingServer[ExecResult]

func _Yak_QueryExecHistory_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ExecHistoryRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).QueryExecHistory(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_QueryExecHistory_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).QueryExecHistory(ctx, req.(*ExecHistoryRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_RemoveExecHistory_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).RemoveExecHistory(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_RemoveExecHistory_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).RemoveExecHistory(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_LoadNucleiTemplates_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).LoadNucleiTemplates(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_LoadNucleiTemplates_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).LoadNucleiTemplates(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_AutoUpdateYakModule_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(Empty)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(YakServer).AutoUpdateYakModule(m, &grpc.GenericServerStream[Empty, ExecResult]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Yak_AutoUpdateYakModuleServer = grpc.ServerStreamingServer[ExecResult]

func _Yak_ExecYakScript_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(ExecRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(YakServer).ExecYakScript(m, &grpc.GenericServerStream[ExecRequest, ExecResult]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Yak_ExecYakScriptServer = grpc.ServerStreamingServer[ExecResult]

func _Yak_ExecBatchYakScript_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(ExecBatchYakScriptRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(YakServer).ExecBatchYakScript(m, &grpc.GenericServerStream[ExecBatchYakScriptRequest, ExecBatchYakScriptResult]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Yak_ExecBatchYakScriptServer = grpc.ServerStreamingServer[ExecBatchYakScriptResult]

func _Yak_GetExecBatchYakScriptUnfinishedTask_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).GetExecBatchYakScriptUnfinishedTask(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_GetExecBatchYakScriptUnfinishedTask_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).GetExecBatchYakScriptUnfinishedTask(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_GetExecBatchYakScriptUnfinishedTaskByUid_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetExecBatchYakScriptUnfinishedTaskByUidRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).GetExecBatchYakScriptUnfinishedTaskByUid(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_GetExecBatchYakScriptUnfinishedTaskByUid_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).GetExecBatchYakScriptUnfinishedTaskByUid(ctx, req.(*GetExecBatchYakScriptUnfinishedTaskByUidRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_PopExecBatchYakScriptUnfinishedTaskByUid_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetExecBatchYakScriptUnfinishedTaskByUidRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).PopExecBatchYakScriptUnfinishedTaskByUid(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_PopExecBatchYakScriptUnfinishedTaskByUid_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).PopExecBatchYakScriptUnfinishedTaskByUid(ctx, req.(*GetExecBatchYakScriptUnfinishedTaskByUidRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_RecoverExecBatchYakScriptUnfinishedTask_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(RecoverExecBatchYakScriptUnfinishedTaskRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(YakServer).RecoverExecBatchYakScriptUnfinishedTask(m, &grpc.GenericServerStream[RecoverExecBatchYakScriptUnfinishedTaskRequest, ExecBatchYakScriptResult]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Yak_RecoverExecBatchYakScriptUnfinishedTaskServer = grpc.ServerStreamingServer[ExecBatchYakScriptResult]

func _Yak_QueryYakScript_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryYakScriptRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).QueryYakScript(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_QueryYakScript_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).QueryYakScript(ctx, req.(*QueryYakScriptRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_QueryYakScriptByYakScriptName_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(QueryYakScriptRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(YakServer).QueryYakScriptByYakScriptName(m, &grpc.GenericServerStream[QueryYakScriptRequest, YakScript]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Yak_QueryYakScriptByYakScriptNameServer = grpc.ServerStreamingServer[YakScript]

func _Yak_SaveYakScript_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(YakScript)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).SaveYakScript(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_SaveYakScript_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).SaveYakScript(ctx, req.(*YakScript))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_DeleteYakScript_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteYakScriptRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).DeleteYakScript(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_DeleteYakScript_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).DeleteYakScript(ctx, req.(*DeleteYakScriptRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_GetYakScriptById_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetYakScriptByIdRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).GetYakScriptById(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_GetYakScriptById_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).GetYakScriptById(ctx, req.(*GetYakScriptByIdRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_GetYakScriptByName_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetYakScriptByNameRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).GetYakScriptByName(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_GetYakScriptByName_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).GetYakScriptByName(ctx, req.(*GetYakScriptByNameRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_GetYakScriptByOnlineID_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetYakScriptByOnlineIDRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).GetYakScriptByOnlineID(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_GetYakScriptByOnlineID_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).GetYakScriptByOnlineID(ctx, req.(*GetYakScriptByOnlineIDRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_IgnoreYakScript_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteYakScriptRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).IgnoreYakScript(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_IgnoreYakScript_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).IgnoreYakScript(ctx, req.(*DeleteYakScriptRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_UnIgnoreYakScript_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteYakScriptRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).UnIgnoreYakScript(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_UnIgnoreYakScript_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).UnIgnoreYakScript(ctx, req.(*DeleteYakScriptRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_ExportYakScript_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ExportYakScriptRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).ExportYakScript(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_ExportYakScript_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).ExportYakScript(ctx, req.(*ExportYakScriptRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_ExportYakScriptStream_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(ExportYakScriptStreamRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(YakServer).ExportYakScriptStream(m, &grpc.GenericServerStream[ExportYakScriptStreamRequest, ExecResult]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Yak_ExportYakScriptStreamServer = grpc.ServerStreamingServer[ExecResult]

func _Yak_ImportYakScriptStream_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(ImportYakScriptStreamRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(YakServer).ImportYakScriptStream(m, &grpc.GenericServerStream[ImportYakScriptStreamRequest, ExecResult]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Yak_ImportYakScriptStreamServer = grpc.ServerStreamingServer[ExecResult]

func _Yak_ExecutePacketYakScript_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(ExecutePacketYakScriptParams)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(YakServer).ExecutePacketYakScript(m, &grpc.GenericServerStream[ExecutePacketYakScriptParams, ExecResult]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Yak_ExecutePacketYakScriptServer = grpc.ServerStreamingServer[ExecResult]

func _Yak_ExecuteBatchPacketYakScript_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(ExecuteBatchPacketYakScriptParams)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(YakServer).ExecuteBatchPacketYakScript(m, &grpc.GenericServerStream[ExecuteBatchPacketYakScriptParams, ExecBatchYakScriptResult]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Yak_ExecuteBatchPacketYakScriptServer = grpc.ServerStreamingServer[ExecBatchYakScriptResult]

func _Yak_GetYakScriptTags_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).GetYakScriptTags(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_GetYakScriptTags_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).GetYakScriptTags(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_QueryYakScriptLocalAndUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryYakScriptLocalAndUserRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).QueryYakScriptLocalAndUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_QueryYakScriptLocalAndUser_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).QueryYakScriptLocalAndUser(ctx, req.(*QueryYakScriptLocalAndUserRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_QueryYakScriptByOnlineGroup_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryYakScriptByOnlineGroupRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).QueryYakScriptByOnlineGroup(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_QueryYakScriptByOnlineGroup_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).QueryYakScriptByOnlineGroup(ctx, req.(*QueryYakScriptByOnlineGroupRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_QueryYakScriptLocalAll_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).QueryYakScriptLocalAll(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_QueryYakScriptLocalAll_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).QueryYakScriptLocalAll(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_QueryYakScriptByNames_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryYakScriptByNamesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).QueryYakScriptByNames(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_QueryYakScriptByNames_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).QueryYakScriptByNames(ctx, req.(*QueryYakScriptByNamesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_QueryYakScriptByIsCore_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryYakScriptByIsCoreRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).QueryYakScriptByIsCore(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_QueryYakScriptByIsCore_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).QueryYakScriptByIsCore(ctx, req.(*QueryYakScriptByIsCoreRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_QueryYakScriptRiskDetailByCWE_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryYakScriptRiskDetailByCWERequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).QueryYakScriptRiskDetailByCWE(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_QueryYakScriptRiskDetailByCWE_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).QueryYakScriptRiskDetailByCWE(ctx, req.(*QueryYakScriptRiskDetailByCWERequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_YakScriptRiskTypeList_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).YakScriptRiskTypeList(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_YakScriptRiskTypeList_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).YakScriptRiskTypeList(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_SaveNewYakScript_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SaveNewYakScriptRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).SaveNewYakScript(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_SaveNewYakScript_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).SaveNewYakScript(ctx, req.(*SaveNewYakScriptRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_SaveYakScriptToOnline_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(SaveYakScriptToOnlineRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(YakServer).SaveYakScriptToOnline(m, &grpc.GenericServerStream[SaveYakScriptToOnlineRequest, SaveYakScriptToOnlineResponse]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Yak_SaveYakScriptToOnlineServer = grpc.ServerStreamingServer[SaveYakScriptToOnlineResponse]

func _Yak_ExportLocalYakScript_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ExportLocalYakScriptRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).ExportLocalYakScript(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_ExportLocalYakScript_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).ExportLocalYakScript(ctx, req.(*ExportLocalYakScriptRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_ExportLocalYakScriptStream_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(ExportLocalYakScriptRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(YakServer).ExportLocalYakScriptStream(m, &grpc.GenericServerStream[ExportLocalYakScriptRequest, ExportYakScriptLocalResponse]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Yak_ExportLocalYakScriptStreamServer = grpc.ServerStreamingServer[ExportYakScriptLocalResponse]

func _Yak_ImportYakScript_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(ImportYakScriptRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(YakServer).ImportYakScript(m, &grpc.GenericServerStream[ImportYakScriptRequest, ImportYakScriptResult]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Yak_ImportYakScriptServer = grpc.ServerStreamingServer[ImportYakScriptResult]

func _Yak_SetYakScriptSkipUpdate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetYakScriptSkipUpdateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).SetYakScriptSkipUpdate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_SetYakScriptSkipUpdate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).SetYakScriptSkipUpdate(ctx, req.(*SetYakScriptSkipUpdateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_QueryYakScriptSkipUpdate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryYakScriptRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).QueryYakScriptSkipUpdate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_QueryYakScriptSkipUpdate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).QueryYakScriptSkipUpdate(ctx, req.(*QueryYakScriptRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_QueryYakScriptGroup_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryYakScriptGroupRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).QueryYakScriptGroup(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_QueryYakScriptGroup_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).QueryYakScriptGroup(ctx, req.(*QueryYakScriptGroupRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_SaveYakScriptGroup_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SaveYakScriptGroupRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).SaveYakScriptGroup(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_SaveYakScriptGroup_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).SaveYakScriptGroup(ctx, req.(*SaveYakScriptGroupRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_RenameYakScriptGroup_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RenameYakScriptGroupRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).RenameYakScriptGroup(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_RenameYakScriptGroup_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).RenameYakScriptGroup(ctx, req.(*RenameYakScriptGroupRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_DeleteYakScriptGroup_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteYakScriptGroupRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).DeleteYakScriptGroup(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_DeleteYakScriptGroup_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).DeleteYakScriptGroup(ctx, req.(*DeleteYakScriptGroupRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_GetYakScriptGroup_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryYakScriptRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).GetYakScriptGroup(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_GetYakScriptGroup_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).GetYakScriptGroup(ctx, req.(*QueryYakScriptRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_ResetYakScriptGroup_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ResetYakScriptGroupRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).ResetYakScriptGroup(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_ResetYakScriptGroup_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).ResetYakScriptGroup(ctx, req.(*ResetYakScriptGroupRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_SetGroup_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetGroupRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).SetGroup(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_SetGroup_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).SetGroup(ctx, req.(*SetGroupRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_GetHTTPFlowByHash_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetHTTPFlowByHashRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).GetHTTPFlowByHash(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_GetHTTPFlowByHash_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).GetHTTPFlowByHash(ctx, req.(*GetHTTPFlowByHashRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_GetHTTPFlowById_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetHTTPFlowByIdRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).GetHTTPFlowById(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_GetHTTPFlowById_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).GetHTTPFlowById(ctx, req.(*GetHTTPFlowByIdRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_GetHTTPFlowBodyById_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(GetHTTPFlowBodyByIdRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(YakServer).GetHTTPFlowBodyById(m, &grpc.GenericServerStream[GetHTTPFlowBodyByIdRequest, GetHTTPFlowBodyByIdResponse]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Yak_GetHTTPFlowBodyByIdServer = grpc.ServerStreamingServer[GetHTTPFlowBodyByIdResponse]

func _Yak_GetHTTPFlowByIds_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetHTTPFlowByIdsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).GetHTTPFlowByIds(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_GetHTTPFlowByIds_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).GetHTTPFlowByIds(ctx, req.(*GetHTTPFlowByIdsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_QueryHTTPFlows_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryHTTPFlowRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).QueryHTTPFlows(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_QueryHTTPFlows_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).QueryHTTPFlows(ctx, req.(*QueryHTTPFlowRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_DeleteHTTPFlows_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteHTTPFlowRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).DeleteHTTPFlows(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_DeleteHTTPFlows_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).DeleteHTTPFlows(ctx, req.(*DeleteHTTPFlowRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_SetTagForHTTPFlow_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetTagForHTTPFlowRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).SetTagForHTTPFlow(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_SetTagForHTTPFlow_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).SetTagForHTTPFlow(ctx, req.(*SetTagForHTTPFlowRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_QueryHTTPFlowsIds_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryHTTPFlowsIdsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).QueryHTTPFlowsIds(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_QueryHTTPFlowsIds_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).QueryHTTPFlowsIds(ctx, req.(*QueryHTTPFlowsIdsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_HTTPFlowsFieldGroup_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(HTTPFlowsFieldGroupRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).HTTPFlowsFieldGroup(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_HTTPFlowsFieldGroup_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).HTTPFlowsFieldGroup(ctx, req.(*HTTPFlowsFieldGroupRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_HTTPFlowsShare_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(HTTPFlowsShareRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).HTTPFlowsShare(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_HTTPFlowsShare_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).HTTPFlowsShare(ctx, req.(*HTTPFlowsShareRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_HTTPFlowsExtract_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(HTTPFlowsExtractRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).HTTPFlowsExtract(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_HTTPFlowsExtract_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).HTTPFlowsExtract(ctx, req.(*HTTPFlowsExtractRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_GetHTTPFlowBare_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(HTTPFlowBareRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).GetHTTPFlowBare(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_GetHTTPFlowBare_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).GetHTTPFlowBare(ctx, req.(*HTTPFlowBareRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_ExportHTTPFlows_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ExportHTTPFlowsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).ExportHTTPFlows(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_ExportHTTPFlows_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).ExportHTTPFlows(ctx, req.(*ExportHTTPFlowsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_HTTPFlowsToOnline_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(HTTPFlowsToOnlineRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).HTTPFlowsToOnline(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_HTTPFlowsToOnline_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).HTTPFlowsToOnline(ctx, req.(*HTTPFlowsToOnlineRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_QueryHTTPFlowsProcessNames_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryHTTPFlowRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).QueryHTTPFlowsProcessNames(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_QueryHTTPFlowsProcessNames_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).QueryHTTPFlowsProcessNames(ctx, req.(*QueryHTTPFlowRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_AnalyzeHTTPFlow_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(AnalyzeHTTPFlowRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(YakServer).AnalyzeHTTPFlow(m, &grpc.GenericServerStream[AnalyzeHTTPFlowRequest, AnalyzeHTTPFlowResponse]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Yak_AnalyzeHTTPFlowServer = grpc.ServerStreamingServer[AnalyzeHTTPFlowResponse]

func _Yak_ExtractUrl_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FuzzerRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).ExtractUrl(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_ExtractUrl_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).ExtractUrl(ctx, req.(*FuzzerRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_GetHistoryHTTPFuzzerTask_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetHistoryHTTPFuzzerTaskRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).GetHistoryHTTPFuzzerTask(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_GetHistoryHTTPFuzzerTask_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).GetHistoryHTTPFuzzerTask(ctx, req.(*GetHistoryHTTPFuzzerTaskRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_QueryHistoryHTTPFuzzerTask_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).QueryHistoryHTTPFuzzerTask(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_QueryHistoryHTTPFuzzerTask_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).QueryHistoryHTTPFuzzerTask(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_QueryHistoryHTTPFuzzerTaskEx_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryHistoryHTTPFuzzerTaskExParams)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).QueryHistoryHTTPFuzzerTaskEx(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_QueryHistoryHTTPFuzzerTaskEx_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).QueryHistoryHTTPFuzzerTaskEx(ctx, req.(*QueryHistoryHTTPFuzzerTaskExParams))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_DeleteHistoryHTTPFuzzerTask_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteHistoryHTTPFuzzerTaskRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).DeleteHistoryHTTPFuzzerTask(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_DeleteHistoryHTTPFuzzerTask_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).DeleteHistoryHTTPFuzzerTask(ctx, req.(*DeleteHistoryHTTPFuzzerTaskRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_HTTPFuzzer_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(FuzzerRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(YakServer).HTTPFuzzer(m, &grpc.GenericServerStream[FuzzerRequest, FuzzerResponse]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Yak_HTTPFuzzerServer = grpc.ServerStreamingServer[FuzzerResponse]

func _Yak_HTTPFuzzerSequence_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(FuzzerRequests)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(YakServer).HTTPFuzzerSequence(m, &grpc.GenericServerStream[FuzzerRequests, FuzzerSequenceResponse]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Yak_HTTPFuzzerSequenceServer = grpc.ServerStreamingServer[FuzzerSequenceResponse]

func _Yak_PreloadHTTPFuzzerParams_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PreloadHTTPFuzzerParamsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).PreloadHTTPFuzzerParams(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_PreloadHTTPFuzzerParams_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).PreloadHTTPFuzzerParams(ctx, req.(*PreloadHTTPFuzzerParamsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_RenderVariables_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RenderVariablesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).RenderVariables(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_RenderVariables_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).RenderVariables(ctx, req.(*RenderVariablesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_MatchHTTPResponse_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MatchHTTPResponseParams)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).MatchHTTPResponse(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_MatchHTTPResponse_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).MatchHTTPResponse(ctx, req.(*MatchHTTPResponseParams))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_ExtractHTTPResponse_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ExtractHTTPResponseParams)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).ExtractHTTPResponse(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_ExtractHTTPResponse_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).ExtractHTTPResponse(ctx, req.(*ExtractHTTPResponseParams))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_RedirectRequest_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RedirectRequestParams)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).RedirectRequest(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_RedirectRequest_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).RedirectRequest(ctx, req.(*RedirectRequestParams))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_HTTPRequestMutate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(HTTPRequestMutateParams)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).HTTPRequestMutate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_HTTPRequestMutate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).HTTPRequestMutate(ctx, req.(*HTTPRequestMutateParams))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_HTTPResponseMutate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(HTTPResponseMutateParams)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).HTTPResponseMutate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_HTTPResponseMutate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).HTTPResponseMutate(ctx, req.(*HTTPResponseMutateParams))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_FixUploadPacket_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FixUploadPacketRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).FixUploadPacket(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_FixUploadPacket_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).FixUploadPacket(ctx, req.(*FixUploadPacketRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_IsMultipartFormDataRequest_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FixUploadPacketRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).IsMultipartFormDataRequest(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_IsMultipartFormDataRequest_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).IsMultipartFormDataRequest(ctx, req.(*FixUploadPacketRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_GenerateExtractRule_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GenerateExtractRuleRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).GenerateExtractRule(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_GenerateExtractRule_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).GenerateExtractRule(ctx, req.(*GenerateExtractRuleRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_ExtractData_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(YakServer).ExtractData(&grpc.GenericServerStream[ExtractDataRequest, ExtractDataResponse]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Yak_ExtractDataServer = grpc.BidiStreamingServer[ExtractDataRequest, ExtractDataResponse]

func _Yak_ImportHTTPFuzzerTaskFromYaml_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ImportHTTPFuzzerTaskFromYamlRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).ImportHTTPFuzzerTaskFromYaml(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_ImportHTTPFuzzerTaskFromYaml_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).ImportHTTPFuzzerTaskFromYaml(ctx, req.(*ImportHTTPFuzzerTaskFromYamlRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_ExportHTTPFuzzerTaskToYaml_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ExportHTTPFuzzerTaskToYamlRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).ExportHTTPFuzzerTaskToYaml(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_ExportHTTPFuzzerTaskToYaml_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).ExportHTTPFuzzerTaskToYaml(ctx, req.(*ExportHTTPFuzzerTaskToYamlRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_RenderHTTPFuzzerPacket_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RenderHTTPFuzzerPacketRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).RenderHTTPFuzzerPacket(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_RenderHTTPFuzzerPacket_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).RenderHTTPFuzzerPacket(ctx, req.(*RenderHTTPFuzzerPacketRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_SaveFuzzerLabel_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SaveFuzzerLabelRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).SaveFuzzerLabel(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_SaveFuzzerLabel_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).SaveFuzzerLabel(ctx, req.(*SaveFuzzerLabelRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_QueryFuzzerLabel_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).QueryFuzzerLabel(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_QueryFuzzerLabel_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).QueryFuzzerLabel(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_DeleteFuzzerLabel_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteFuzzerLabelRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).DeleteFuzzerLabel(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_DeleteFuzzerLabel_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).DeleteFuzzerLabel(ctx, req.(*DeleteFuzzerLabelRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_SaveFuzzerConfig_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SaveFuzzerConfigRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).SaveFuzzerConfig(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_SaveFuzzerConfig_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).SaveFuzzerConfig(ctx, req.(*SaveFuzzerConfigRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_QueryFuzzerConfig_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryFuzzerConfigRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).QueryFuzzerConfig(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_QueryFuzzerConfig_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).QueryFuzzerConfig(ctx, req.(*QueryFuzzerConfigRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_DeleteFuzzerConfig_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteFuzzerConfigRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).DeleteFuzzerConfig(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_DeleteFuzzerConfig_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).DeleteFuzzerConfig(ctx, req.(*DeleteFuzzerConfigRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_QueryHTTPFuzzerResponseByTaskId_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryHTTPFuzzerResponseByTaskIdRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).QueryHTTPFuzzerResponseByTaskId(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_QueryHTTPFuzzerResponseByTaskId_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).QueryHTTPFuzzerResponseByTaskId(ctx, req.(*QueryHTTPFuzzerResponseByTaskIdRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_CreateWebsocketFuzzer_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(YakServer).CreateWebsocketFuzzer(&grpc.GenericServerStream[ClientWebsocketRequest, ClientWebsocketResponse]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Yak_CreateWebsocketFuzzerServer = grpc.BidiStreamingServer[ClientWebsocketRequest, ClientWebsocketResponse]

func _Yak_QueryWebsocketFlowByHTTPFlowWebsocketHash_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryWebsocketFlowByHTTPFlowWebsocketHashRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).QueryWebsocketFlowByHTTPFlowWebsocketHash(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_QueryWebsocketFlowByHTTPFlowWebsocketHash_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).QueryWebsocketFlowByHTTPFlowWebsocketHash(ctx, req.(*QueryWebsocketFlowByHTTPFlowWebsocketHashRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_DeleteWebsocketFlowByHTTPFlowWebsocketHash_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteWebsocketFlowByHTTPFlowWebsocketHashRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).DeleteWebsocketFlowByHTTPFlowWebsocketHash(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_DeleteWebsocketFlowByHTTPFlowWebsocketHash_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).DeleteWebsocketFlowByHTTPFlowWebsocketHash(ctx, req.(*DeleteWebsocketFlowByHTTPFlowWebsocketHashRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_DeleteWebsocketFlowAll_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).DeleteWebsocketFlowAll(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_DeleteWebsocketFlowAll_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).DeleteWebsocketFlowAll(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_ConvertFuzzerResponseToHTTPFlow_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FuzzerResponse)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).ConvertFuzzerResponseToHTTPFlow(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_ConvertFuzzerResponseToHTTPFlow_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).ConvertFuzzerResponseToHTTPFlow(ctx, req.(*FuzzerResponse))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_StringFuzzer_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StringFuzzerRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).StringFuzzer(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_StringFuzzer_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).StringFuzzer(ctx, req.(*StringFuzzerRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_HTTPRequestAnalyzer_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(HTTPRequestAnalysisMaterial)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).HTTPRequestAnalyzer(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_HTTPRequestAnalyzer_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).HTTPRequestAnalyzer(ctx, req.(*HTTPRequestAnalysisMaterial))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_Codec_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CodecRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).Codec(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_Codec_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).Codec(ctx, req.(*CodecRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_NewCodec_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CodecRequestFlow)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).NewCodec(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_NewCodec_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).NewCodec(ctx, req.(*CodecRequestFlow))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_GetAllCodecMethods_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).GetAllCodecMethods(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_GetAllCodecMethods_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).GetAllCodecMethods(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_SaveCodecFlow_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CustomizeCodecFlow)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).SaveCodecFlow(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_SaveCodecFlow_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).SaveCodecFlow(ctx, req.(*CustomizeCodecFlow))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_DeleteCodecFlow_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteCodecFlowRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).DeleteCodecFlow(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_DeleteCodecFlow_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).DeleteCodecFlow(ctx, req.(*DeleteCodecFlowRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_GetAllCodecFlow_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).GetAllCodecFlow(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_GetAllCodecFlow_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).GetAllCodecFlow(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_PacketPrettifyHelper_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PacketPrettifyHelperRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).PacketPrettifyHelper(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_PacketPrettifyHelper_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).PacketPrettifyHelper(ctx, req.(*PacketPrettifyHelperRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_QueryPayload_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryPayloadRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).QueryPayload(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_QueryPayload_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).QueryPayload(ctx, req.(*QueryPayloadRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_QueryPayloadFromFile_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryPayloadFromFileRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).QueryPayloadFromFile(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_QueryPayloadFromFile_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).QueryPayloadFromFile(ctx, req.(*QueryPayloadFromFileRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_DeletePayloadByFolder_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NameRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).DeletePayloadByFolder(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_DeletePayloadByFolder_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).DeletePayloadByFolder(ctx, req.(*NameRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_DeletePayloadByGroup_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeletePayloadByGroupRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).DeletePayloadByGroup(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_DeletePayloadByGroup_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).DeletePayloadByGroup(ctx, req.(*DeletePayloadByGroupRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_DeletePayload_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeletePayloadRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).DeletePayload(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_DeletePayload_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).DeletePayload(ctx, req.(*DeletePayloadRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_SavePayload_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SavePayloadRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).SavePayload(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_SavePayload_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).SavePayload(ctx, req.(*SavePayloadRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_SavePayloadStream_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(SavePayloadRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(YakServer).SavePayloadStream(m, &grpc.GenericServerStream[SavePayloadRequest, SavePayloadProgress]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Yak_SavePayloadStreamServer = grpc.ServerStreamingServer[SavePayloadProgress]

func _Yak_SavePayloadToFileStream_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(SavePayloadRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(YakServer).SavePayloadToFileStream(m, &grpc.GenericServerStream[SavePayloadRequest, SavePayloadProgress]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Yak_SavePayloadToFileStreamServer = grpc.ServerStreamingServer[SavePayloadProgress]

func _Yak_SaveLargePayloadToFileStream_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(SavePayloadRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(YakServer).SaveLargePayloadToFileStream(m, &grpc.GenericServerStream[SavePayloadRequest, SavePayloadProgress]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Yak_SaveLargePayloadToFileStreamServer = grpc.ServerStreamingServer[SavePayloadProgress]

func _Yak_RenamePayloadFolder_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RenameRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).RenamePayloadFolder(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_RenamePayloadFolder_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).RenamePayloadFolder(ctx, req.(*RenameRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_RenamePayloadGroup_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RenameRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).RenamePayloadGroup(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_RenamePayloadGroup_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).RenamePayloadGroup(ctx, req.(*RenameRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_UpdatePayload_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdatePayloadRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).UpdatePayload(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_UpdatePayload_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).UpdatePayload(ctx, req.(*UpdatePayloadRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_UpdatePayloadToFile_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdatePayloadToFileRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).UpdatePayloadToFile(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_UpdatePayloadToFile_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).UpdatePayloadToFile(ctx, req.(*UpdatePayloadToFileRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_BackUpOrCopyPayloads_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BackUpOrCopyPayloadsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).BackUpOrCopyPayloads(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_BackUpOrCopyPayloads_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).BackUpOrCopyPayloads(ctx, req.(*BackUpOrCopyPayloadsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_GetAllPayloadGroup_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).GetAllPayloadGroup(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_GetAllPayloadGroup_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).GetAllPayloadGroup(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_UpdateAllPayloadGroup_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateAllPayloadGroupRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).UpdateAllPayloadGroup(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_UpdateAllPayloadGroup_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).UpdateAllPayloadGroup(ctx, req.(*UpdateAllPayloadGroupRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_GetAllPayload_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetAllPayloadRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).GetAllPayload(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_GetAllPayload_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).GetAllPayload(ctx, req.(*GetAllPayloadRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_GetAllPayloadFromFile_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(GetAllPayloadRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(YakServer).GetAllPayloadFromFile(m, &grpc.GenericServerStream[GetAllPayloadRequest, GetAllPayloadFromFileResponse]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Yak_GetAllPayloadFromFileServer = grpc.ServerStreamingServer[GetAllPayloadFromFileResponse]

func _Yak_ExportAllPayload_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(GetAllPayloadRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(YakServer).ExportAllPayload(m, &grpc.GenericServerStream[GetAllPayloadRequest, GetAllPayloadResponse]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Yak_ExportAllPayloadServer = grpc.ServerStreamingServer[GetAllPayloadResponse]

func _Yak_ExportAllPayloadFromFile_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(GetAllPayloadRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(YakServer).ExportAllPayloadFromFile(m, &grpc.GenericServerStream[GetAllPayloadRequest, GetAllPayloadResponse]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Yak_ExportAllPayloadFromFileServer = grpc.ServerStreamingServer[GetAllPayloadResponse]

func _Yak_CreatePayloadFolder_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NameRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).CreatePayloadFolder(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_CreatePayloadFolder_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).CreatePayloadFolder(ctx, req.(*NameRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_RemoveDuplicatePayloads_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(NameRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(YakServer).RemoveDuplicatePayloads(m, &grpc.GenericServerStream[NameRequest, SavePayloadProgress]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Yak_RemoveDuplicatePayloadsServer = grpc.ServerStreamingServer[SavePayloadProgress]

func _Yak_CoverPayloadGroupToDatabase_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(NameRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(YakServer).CoverPayloadGroupToDatabase(m, &grpc.GenericServerStream[NameRequest, SavePayloadProgress]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Yak_CoverPayloadGroupToDatabaseServer = grpc.ServerStreamingServer[SavePayloadProgress]

func _Yak_ConvertPayloadGroupToDatabase_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(NameRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(YakServer).ConvertPayloadGroupToDatabase(m, &grpc.GenericServerStream[NameRequest, SavePayloadProgress]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Yak_ConvertPayloadGroupToDatabaseServer = grpc.ServerStreamingServer[SavePayloadProgress]

func _Yak_MigratePayloads_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(Empty)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(YakServer).MigratePayloads(m, &grpc.GenericServerStream[Empty, SavePayloadProgress]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Yak_MigratePayloadsServer = grpc.ServerStreamingServer[SavePayloadProgress]

func _Yak_GetYakitCompletionRaw_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).GetYakitCompletionRaw(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_GetYakitCompletionRaw_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).GetYakitCompletionRaw(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_GetYakVMBuildInMethodCompletion_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetYakVMBuildInMethodCompletionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).GetYakVMBuildInMethodCompletion(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_GetYakVMBuildInMethodCompletion_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).GetYakVMBuildInMethodCompletion(ctx, req.(*GetYakVMBuildInMethodCompletionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_StaticAnalyzeError_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StaticAnalyzeErrorRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).StaticAnalyzeError(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_StaticAnalyzeError_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).StaticAnalyzeError(ctx, req.(*StaticAnalyzeErrorRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_YaklangCompileAndFormat_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(YaklangCompileAndFormatRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).YaklangCompileAndFormat(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_YaklangCompileAndFormat_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).YaklangCompileAndFormat(ctx, req.(*YaklangCompileAndFormatRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_YaklangLanguageSuggestion_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(YaklangLanguageSuggestionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).YaklangLanguageSuggestion(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_YaklangLanguageSuggestion_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).YaklangLanguageSuggestion(ctx, req.(*YaklangLanguageSuggestionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_YaklangLanguageFind_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(YaklangLanguageSuggestionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).YaklangLanguageFind(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_YaklangLanguageFind_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).YaklangLanguageFind(ctx, req.(*YaklangLanguageSuggestionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_FuzzTagSuggestion_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FuzzTagSuggestionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).FuzzTagSuggestion(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_FuzzTagSuggestion_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).FuzzTagSuggestion(ctx, req.(*FuzzTagSuggestionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_YaklangInspectInformation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(YaklangInspectInformationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).YaklangInspectInformation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_YaklangInspectInformation_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).YaklangInspectInformation(ctx, req.(*YaklangInspectInformationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_YaklangGetCliCodeFromDatabase_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(YaklangGetCliCodeFromDatabaseRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).YaklangGetCliCodeFromDatabase(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_YaklangGetCliCodeFromDatabase_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).YaklangGetCliCodeFromDatabase(ctx, req.(*YaklangGetCliCodeFromDatabaseRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_YaklangTerminal_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(YakServer).YaklangTerminal(&grpc.GenericServerStream[Input, Output]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Yak_YaklangTerminalServer = grpc.BidiStreamingServer[Input, Output]

func _Yak_PortScan_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(PortScanRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(YakServer).PortScan(m, &grpc.GenericServerStream[PortScanRequest, ExecResult]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Yak_PortScanServer = grpc.ServerStreamingServer[ExecResult]

func _Yak_ViewPortScanCode_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).ViewPortScanCode(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_ViewPortScanCode_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).ViewPortScanCode(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_SimpleDetect_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(RecordPortScanRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(YakServer).SimpleDetect(m, &grpc.GenericServerStream[RecordPortScanRequest, ExecResult]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Yak_SimpleDetectServer = grpc.ServerStreamingServer[ExecResult]

func _Yak_SaveCancelSimpleDetect_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RecordPortScanRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).SaveCancelSimpleDetect(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_SaveCancelSimpleDetect_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).SaveCancelSimpleDetect(ctx, req.(*RecordPortScanRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_SimpleDetectCreatReport_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(CreatReportRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(YakServer).SimpleDetectCreatReport(m, &grpc.GenericServerStream[CreatReportRequest, ExecResult]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Yak_SimpleDetectCreatReportServer = grpc.ServerStreamingServer[ExecResult]

func _Yak_QuerySimpleDetectUnfinishedTask_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryUnfinishedTaskRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).QuerySimpleDetectUnfinishedTask(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_QuerySimpleDetectUnfinishedTask_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).QuerySimpleDetectUnfinishedTask(ctx, req.(*QueryUnfinishedTaskRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_GetSimpleDetectRecordRequestById_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetUnfinishedTaskDetailByIdRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).GetSimpleDetectRecordRequestById(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_GetSimpleDetectRecordRequestById_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).GetSimpleDetectRecordRequestById(ctx, req.(*GetUnfinishedTaskDetailByIdRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_DeleteSimpleDetectUnfinishedTask_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteUnfinishedTaskRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).DeleteSimpleDetectUnfinishedTask(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_DeleteSimpleDetectUnfinishedTask_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).DeleteSimpleDetectUnfinishedTask(ctx, req.(*DeleteUnfinishedTaskRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_RecoverSimpleDetectTask_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(RecoverUnfinishedTaskRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(YakServer).RecoverSimpleDetectTask(m, &grpc.GenericServerStream[RecoverUnfinishedTaskRequest, ExecResult]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Yak_RecoverSimpleDetectTaskServer = grpc.ServerStreamingServer[ExecResult]

func _Yak_GetSimpleDetectUnfinishedTask_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).GetSimpleDetectUnfinishedTask(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_GetSimpleDetectUnfinishedTask_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).GetSimpleDetectUnfinishedTask(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_GetSimpleDetectUnfinishedTaskByUid_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetExecBatchYakScriptUnfinishedTaskByUidRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).GetSimpleDetectUnfinishedTaskByUid(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_GetSimpleDetectUnfinishedTaskByUid_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).GetSimpleDetectUnfinishedTaskByUid(ctx, req.(*GetExecBatchYakScriptUnfinishedTaskByUidRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_PopSimpleDetectUnfinishedTaskByUid_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetExecBatchYakScriptUnfinishedTaskByUidRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).PopSimpleDetectUnfinishedTaskByUid(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_PopSimpleDetectUnfinishedTaskByUid_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).PopSimpleDetectUnfinishedTaskByUid(ctx, req.(*GetExecBatchYakScriptUnfinishedTaskByUidRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_RecoverSimpleDetectUnfinishedTask_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(RecoverExecBatchYakScriptUnfinishedTaskRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(YakServer).RecoverSimpleDetectUnfinishedTask(m, &grpc.GenericServerStream[RecoverExecBatchYakScriptUnfinishedTaskRequest, ExecResult]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Yak_RecoverSimpleDetectUnfinishedTaskServer = grpc.ServerStreamingServer[ExecResult]

func _Yak_QueryPorts_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryPortsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).QueryPorts(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_QueryPorts_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).QueryPorts(ctx, req.(*QueryPortsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_DeletePorts_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeletePortsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).DeletePorts(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_DeletePorts_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).DeletePorts(ctx, req.(*DeletePortsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_QueryHosts_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryHostsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).QueryHosts(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_QueryHosts_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).QueryHosts(ctx, req.(*QueryHostsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_DeleteHosts_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteHostsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).DeleteHosts(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_DeleteHosts_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).DeleteHosts(ctx, req.(*DeleteHostsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_QueryDomains_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryDomainsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).QueryDomains(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_QueryDomains_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).QueryDomains(ctx, req.(*QueryDomainsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_DeleteDomains_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteDomainsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).DeleteDomains(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_DeleteDomains_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).DeleteDomains(ctx, req.(*DeleteDomainsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_QueryPortsGroup_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).QueryPortsGroup(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_QueryPortsGroup_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).QueryPortsGroup(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_UpdateFromYakitResource_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateFromYakitResourceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).UpdateFromYakitResource(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_UpdateFromYakitResource_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).UpdateFromYakitResource(ctx, req.(*UpdateFromYakitResourceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_UpdateFromGithub_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateFromGithubRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).UpdateFromGithub(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_UpdateFromGithub_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).UpdateFromGithub(ctx, req.(*UpdateFromGithubRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_AddToMenu_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddToMenuRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).AddToMenu(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_AddToMenu_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).AddToMenu(ctx, req.(*AddToMenuRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_RemoveFromMenu_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RemoveFromMenuRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).RemoveFromMenu(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_RemoveFromMenu_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).RemoveFromMenu(ctx, req.(*RemoveFromMenuRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_YakScriptIsInMenu_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(YakScriptIsInMenuRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).YakScriptIsInMenu(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_YakScriptIsInMenu_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).YakScriptIsInMenu(ctx, req.(*YakScriptIsInMenuRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_GetAllMenuItem_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).GetAllMenuItem(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_GetAllMenuItem_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).GetAllMenuItem(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_DeleteAllMenuItem_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).DeleteAllMenuItem(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_DeleteAllMenuItem_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).DeleteAllMenuItem(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_ImportMenuItem_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ImportMenuItemRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).ImportMenuItem(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_ImportMenuItem_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).ImportMenuItem(ctx, req.(*ImportMenuItemRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_ExportMenuItem_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).ExportMenuItem(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_ExportMenuItem_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).ExportMenuItem(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_GetMenuItemById_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetMenuItemByIdRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).GetMenuItemById(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_GetMenuItemById_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).GetMenuItemById(ctx, req.(*GetMenuItemByIdRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_QueryGroupsByYakScriptId_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryGroupsByYakScriptIdRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).QueryGroupsByYakScriptId(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_QueryGroupsByYakScriptId_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).QueryGroupsByYakScriptId(ctx, req.(*QueryGroupsByYakScriptIdRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_AddMenus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddMenuRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).AddMenus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_AddMenus_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).AddMenus(ctx, req.(*AddMenuRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_QueryAllMenuItem_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryAllMenuItemRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).QueryAllMenuItem(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_QueryAllMenuItem_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).QueryAllMenuItem(ctx, req.(*QueryAllMenuItemRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_DeleteAllMenu_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryAllMenuItemRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).DeleteAllMenu(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_DeleteAllMenu_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).DeleteAllMenu(ctx, req.(*QueryAllMenuItemRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_AddToNavigation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddToNavigationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).AddToNavigation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_AddToNavigation_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).AddToNavigation(ctx, req.(*AddToNavigationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_GetAllNavigationItem_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetAllNavigationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).GetAllNavigationItem(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_GetAllNavigationItem_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).GetAllNavigationItem(ctx, req.(*GetAllNavigationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_DeleteAllNavigation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetAllNavigationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).DeleteAllNavigation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_DeleteAllNavigation_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).DeleteAllNavigation(ctx, req.(*GetAllNavigationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_AddOneNavigation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddOneNavigationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).AddOneNavigation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_AddOneNavigation_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).AddOneNavigation(ctx, req.(*AddOneNavigationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_QueryNavigationGroups_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryNavigationGroupsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).QueryNavigationGroups(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_QueryNavigationGroups_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).QueryNavigationGroups(ctx, req.(*QueryNavigationGroupsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_SaveMarkdownDocument_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SaveMarkdownDocumentRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).SaveMarkdownDocument(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_SaveMarkdownDocument_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).SaveMarkdownDocument(ctx, req.(*SaveMarkdownDocumentRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_GetMarkdownDocument_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetMarkdownDocumentRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).GetMarkdownDocument(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_GetMarkdownDocument_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).GetMarkdownDocument(ctx, req.(*GetMarkdownDocumentRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_DeleteMarkdownDocument_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetMarkdownDocumentRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).DeleteMarkdownDocument(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_DeleteMarkdownDocument_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).DeleteMarkdownDocument(ctx, req.(*GetMarkdownDocumentRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_StartBasicCrawler_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StartBasicCrawlerRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).StartBasicCrawler(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_StartBasicCrawler_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).StartBasicCrawler(ctx, req.(*StartBasicCrawlerRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_ViewBasicCrawlerCode_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).ViewBasicCrawlerCode(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_ViewBasicCrawlerCode_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).ViewBasicCrawlerCode(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_GenerateWebsiteTree_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GenerateWebsiteTreeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).GenerateWebsiteTree(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_GenerateWebsiteTree_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).GenerateWebsiteTree(ctx, req.(*GenerateWebsiteTreeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_QueryYakScriptExecResult_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryYakScriptExecResultRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).QueryYakScriptExecResult(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_QueryYakScriptExecResult_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).QueryYakScriptExecResult(ctx, req.(*QueryYakScriptExecResultRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_QueryYakScriptNameInExecResult_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).QueryYakScriptNameInExecResult(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_QueryYakScriptNameInExecResult_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).QueryYakScriptNameInExecResult(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_DeleteYakScriptExecResult_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteYakScriptExecResultRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).DeleteYakScriptExecResult(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_DeleteYakScriptExecResult_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).DeleteYakScriptExecResult(ctx, req.(*DeleteYakScriptExecResultRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_DeleteYakScriptExec_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).DeleteYakScriptExec(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_DeleteYakScriptExec_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).DeleteYakScriptExec(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_StartBrute_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(StartBruteParams)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(YakServer).StartBrute(m, &grpc.GenericServerStream[StartBruteParams, ExecResult]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Yak_StartBruteServer = grpc.ServerStreamingServer[ExecResult]

func _Yak_GetAvailableBruteTypes_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).GetAvailableBruteTypes(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_GetAvailableBruteTypes_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).GetAvailableBruteTypes(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_GetTunnelServerExternalIP_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetTunnelServerExternalIPParams)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).GetTunnelServerExternalIP(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_GetTunnelServerExternalIP_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).GetTunnelServerExternalIP(ctx, req.(*GetTunnelServerExternalIPParams))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_VerifyTunnelServerDomain_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(VerifyTunnelServerDomainParams)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).VerifyTunnelServerDomain(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_VerifyTunnelServerDomain_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).VerifyTunnelServerDomain(ctx, req.(*VerifyTunnelServerDomainParams))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_StartFacades_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(StartFacadesParams)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(YakServer).StartFacades(m, &grpc.GenericServerStream[StartFacadesParams, ExecResult]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Yak_StartFacadesServer = grpc.ServerStreamingServer[ExecResult]

func _Yak_StartFacadesWithYsoObject_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(StartFacadesWithYsoParams)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(YakServer).StartFacadesWithYsoObject(m, &grpc.GenericServerStream[StartFacadesWithYsoParams, ExecResult]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Yak_StartFacadesWithYsoObjectServer = grpc.ServerStreamingServer[ExecResult]

func _Yak_ApplyClassToFacades_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ApplyClassToFacadesParamsWithVerbose)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).ApplyClassToFacades(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_ApplyClassToFacades_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).ApplyClassToFacades(ctx, req.(*ApplyClassToFacadesParamsWithVerbose))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_BytesToBase64_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BytesToBase64Request)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).BytesToBase64(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_BytesToBase64_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).BytesToBase64(ctx, req.(*BytesToBase64Request))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_ConfigGlobalReverse_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(ConfigGlobalReverseParams)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(YakServer).ConfigGlobalReverse(m, &grpc.GenericServerStream[ConfigGlobalReverseParams, Empty]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Yak_ConfigGlobalReverseServer = grpc.ServerStreamingServer[Empty]

func _Yak_AvailableLocalAddr_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).AvailableLocalAddr(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_AvailableLocalAddr_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).AvailableLocalAddr(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_GetGlobalReverseServer_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).GetGlobalReverseServer(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_GetGlobalReverseServer_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).GetGlobalReverseServer(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_QueryRisks_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryRisksRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).QueryRisks(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_QueryRisks_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).QueryRisks(ctx, req.(*QueryRisksRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_QueryRisk_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryRiskRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).QueryRisk(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_QueryRisk_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).QueryRisk(ctx, req.(*QueryRiskRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_DeleteRisk_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteRiskRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).DeleteRisk(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_DeleteRisk_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).DeleteRisk(ctx, req.(*DeleteRiskRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_QueryAvailableRiskType_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).QueryAvailableRiskType(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_QueryAvailableRiskType_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).QueryAvailableRiskType(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_QueryAvailableRiskLevel_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).QueryAvailableRiskLevel(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_QueryAvailableRiskLevel_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).QueryAvailableRiskLevel(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_QueryRiskTableStats_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).QueryRiskTableStats(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_QueryRiskTableStats_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).QueryRiskTableStats(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_ResetRiskTableStats_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).ResetRiskTableStats(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_ResetRiskTableStats_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).ResetRiskTableStats(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_QueryAvailableTarget_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).QueryAvailableTarget(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_QueryAvailableTarget_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).QueryAvailableTarget(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_QueryNewRisk_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryNewRiskRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).QueryNewRisk(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_QueryNewRisk_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).QueryNewRisk(ctx, req.(*QueryNewRiskRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_NewRiskRead_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NewRiskReadRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).NewRiskRead(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_NewRiskRead_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).NewRiskRead(ctx, req.(*NewRiskReadRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_UploadRiskToOnline_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UploadRiskToOnlineRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).UploadRiskToOnline(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_UploadRiskToOnline_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).UploadRiskToOnline(ctx, req.(*UploadRiskToOnlineRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_SetTagForRisk_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetTagForRiskRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).SetTagForRisk(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_SetTagForRisk_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).SetTagForRisk(ctx, req.(*SetTagForRiskRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_QueryRiskTags_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).QueryRiskTags(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_QueryRiskTags_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).QueryRiskTags(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_RiskFieldGroup_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).RiskFieldGroup(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_RiskFieldGroup_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).RiskFieldGroup(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_RiskFeedbackToOnline_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UploadRiskToOnlineRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).RiskFeedbackToOnline(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_RiskFeedbackToOnline_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).RiskFeedbackToOnline(ctx, req.(*UploadRiskToOnlineRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_QueryReports_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryReportsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).QueryReports(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_QueryReports_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).QueryReports(ctx, req.(*QueryReportsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_QueryReport_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryReportRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).QueryReport(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_QueryReport_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).QueryReport(ctx, req.(*QueryReportRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_DeleteReport_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteReportRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).DeleteReport(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_DeleteReport_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).DeleteReport(ctx, req.(*DeleteReportRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_QueryAvailableReportFrom_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).QueryAvailableReportFrom(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_QueryAvailableReportFrom_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).QueryAvailableReportFrom(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_DownloadReport_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DownloadReportRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).DownloadReport(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_DownloadReport_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).DownloadReport(ctx, req.(*DownloadReportRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_GetAllYsoGadgetOptions_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).GetAllYsoGadgetOptions(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_GetAllYsoGadgetOptions_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).GetAllYsoGadgetOptions(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_GetAllYsoClassOptions_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(YsoOptionsRequerstWithVerbose)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).GetAllYsoClassOptions(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_GetAllYsoClassOptions_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).GetAllYsoClassOptions(ctx, req.(*YsoOptionsRequerstWithVerbose))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_GetAllYsoClassGeneraterOptions_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(YsoOptionsRequerstWithVerbose)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).GetAllYsoClassGeneraterOptions(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_GetAllYsoClassGeneraterOptions_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).GetAllYsoClassGeneraterOptions(ctx, req.(*YsoOptionsRequerstWithVerbose))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_GenerateYsoCode_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(YsoOptionsRequerstWithVerbose)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).GenerateYsoCode(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_GenerateYsoCode_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).GenerateYsoCode(ctx, req.(*YsoOptionsRequerstWithVerbose))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_GenerateYsoBytes_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(YsoOptionsRequerstWithVerbose)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).GenerateYsoBytes(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_GenerateYsoBytes_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).GenerateYsoBytes(ctx, req.(*YsoOptionsRequerstWithVerbose))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_YsoDump_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(YsoBytesObject)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).YsoDump(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_YsoDump_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).YsoDump(ctx, req.(*YsoBytesObject))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_CreateWebShell_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(WebShell)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).CreateWebShell(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_CreateWebShell_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).CreateWebShell(ctx, req.(*WebShell))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_DeleteWebShell_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteWebShellRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).DeleteWebShell(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_DeleteWebShell_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).DeleteWebShell(ctx, req.(*DeleteWebShellRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_UpdateWebShell_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(WebShell)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).UpdateWebShell(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_UpdateWebShell_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).UpdateWebShell(ctx, req.(*WebShell))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_QueryWebShells_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryWebShellsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).QueryWebShells(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_QueryWebShells_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).QueryWebShells(ctx, req.(*QueryWebShellsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_Ping_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(WebShellRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).Ping(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_Ping_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).Ping(ctx, req.(*WebShellRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_GetBasicInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(WebShellRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).GetBasicInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_GetBasicInfo_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).GetBasicInfo(ctx, req.(*WebShellRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_GenerateWebShell_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ShellGenerate)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).GenerateWebShell(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_GenerateWebShell_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).GenerateWebShell(ctx, req.(*ShellGenerate))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_SetYakBridgeLogServer_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(YakDNSLogBridgeAddr)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).SetYakBridgeLogServer(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_SetYakBridgeLogServer_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).SetYakBridgeLogServer(ctx, req.(*YakDNSLogBridgeAddr))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_GetCurrentYakBridgeLogServer_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).GetCurrentYakBridgeLogServer(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_GetCurrentYakBridgeLogServer_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).GetCurrentYakBridgeLogServer(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_RequireDNSLogDomain_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(YakDNSLogBridgeAddr)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).RequireDNSLogDomain(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_RequireDNSLogDomain_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).RequireDNSLogDomain(ctx, req.(*YakDNSLogBridgeAddr))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_RequireDNSLogDomainByScript_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RequireDNSLogDomainByScriptRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).RequireDNSLogDomainByScript(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_RequireDNSLogDomainByScript_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).RequireDNSLogDomainByScript(ctx, req.(*RequireDNSLogDomainByScriptRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_QueryDNSLogByToken_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryDNSLogByTokenRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).QueryDNSLogByToken(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_QueryDNSLogByToken_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).QueryDNSLogByToken(ctx, req.(*QueryDNSLogByTokenRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_QueryDNSLogTokenByScript_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RequireDNSLogDomainByScriptRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).QueryDNSLogTokenByScript(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_QueryDNSLogTokenByScript_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).QueryDNSLogTokenByScript(ctx, req.(*RequireDNSLogDomainByScriptRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_RequireICMPRandomLength_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).RequireICMPRandomLength(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_RequireICMPRandomLength_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).RequireICMPRandomLength(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_QueryICMPTrigger_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryICMPTriggerRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).QueryICMPTrigger(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_QueryICMPTrigger_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).QueryICMPTrigger(ctx, req.(*QueryICMPTriggerRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_RequireRandomPortToken_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).RequireRandomPortToken(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_RequireRandomPortToken_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).RequireRandomPortToken(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_QueryRandomPortTrigger_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryRandomPortTriggerRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).QueryRandomPortTrigger(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_QueryRandomPortTrigger_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).QueryRandomPortTrigger(ctx, req.(*QueryRandomPortTriggerRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_QuerySupportedDnsLogPlatforms_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).QuerySupportedDnsLogPlatforms(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_QuerySupportedDnsLogPlatforms_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).QuerySupportedDnsLogPlatforms(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_GetAvailableYakScriptTags_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).GetAvailableYakScriptTags(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_GetAvailableYakScriptTags_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).GetAvailableYakScriptTags(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_ForceUpdateAvailableYakScriptTags_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).ForceUpdateAvailableYakScriptTags(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_ForceUpdateAvailableYakScriptTags_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).ForceUpdateAvailableYakScriptTags(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_ExecYakitPluginsByYakScriptFilter_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(ExecYakitPluginsByYakScriptFilterRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(YakServer).ExecYakitPluginsByYakScriptFilter(m, &grpc.GenericServerStream[ExecYakitPluginsByYakScriptFilterRequest, ExecResult]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Yak_ExecYakitPluginsByYakScriptFilterServer = grpc.ServerStreamingServer[ExecResult]

func _Yak_GenerateYakCodeByPacket_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GenerateYakCodeByPacketRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).GenerateYakCodeByPacket(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_GenerateYakCodeByPacket_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).GenerateYakCodeByPacket(ctx, req.(*GenerateYakCodeByPacketRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_GenerateCSRFPocByPacket_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GenerateCSRFPocByPacketRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).GenerateCSRFPocByPacket(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_GenerateCSRFPocByPacket_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).GenerateCSRFPocByPacket(ctx, req.(*GenerateCSRFPocByPacketRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_ExportMITMReplacerRules_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).ExportMITMReplacerRules(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_ExportMITMReplacerRules_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).ExportMITMReplacerRules(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_ImportMITMReplacerRules_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ImportMITMReplacerRulesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).ImportMITMReplacerRules(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_ImportMITMReplacerRules_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).ImportMITMReplacerRules(ctx, req.(*ImportMITMReplacerRulesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_GetCurrentRules_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).GetCurrentRules(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_GetCurrentRules_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).GetCurrentRules(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_SetCurrentRules_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MITMContentReplacers)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).SetCurrentRules(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_SetCurrentRules_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).SetCurrentRules(ctx, req.(*MITMContentReplacers))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_GenerateURL_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GenerateURLRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).GenerateURL(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_GenerateURL_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).GenerateURL(ctx, req.(*GenerateURLRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_ExtractDataToFile_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(YakServer).ExtractDataToFile(&grpc.GenericServerStream[ExtractDataToFileRequest, ExtractDataToFileResult]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Yak_ExtractDataToFileServer = grpc.BidiStreamingServer[ExtractDataToFileRequest, ExtractDataToFileResult]

func _Yak_AutoDecode_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AutoDecodeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).AutoDecode(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_AutoDecode_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).AutoDecode(ctx, req.(*AutoDecodeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_GetSystemProxy_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).GetSystemProxy(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_GetSystemProxy_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).GetSystemProxy(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_SetSystemProxy_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetSystemProxyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).SetSystemProxy(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_SetSystemProxy_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).SetSystemProxy(ctx, req.(*SetSystemProxyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_GetKey_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetKeyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).GetKey(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_GetKey_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).GetKey(ctx, req.(*GetKeyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_SetKey_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetKeyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).SetKey(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_SetKey_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).SetKey(ctx, req.(*SetKeyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_DelKey_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetKeyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).DelKey(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_DelKey_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).DelKey(ctx, req.(*GetKeyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_GetAllProcessEnvKey_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).GetAllProcessEnvKey(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_GetAllProcessEnvKey_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).GetAllProcessEnvKey(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_SetProcessEnvKey_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetKeyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).SetProcessEnvKey(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_SetProcessEnvKey_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).SetProcessEnvKey(ctx, req.(*SetKeyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_GetProjectKey_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetKeyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).GetProjectKey(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_GetProjectKey_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).GetProjectKey(ctx, req.(*GetKeyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_SetProjectKey_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetKeyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).SetProjectKey(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_SetProjectKey_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).SetProjectKey(ctx, req.(*SetKeyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_GetOnlineProfile_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).GetOnlineProfile(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_GetOnlineProfile_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).GetOnlineProfile(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_SetOnlineProfile_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(OnlineProfile)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).SetOnlineProfile(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_SetOnlineProfile_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).SetOnlineProfile(ctx, req.(*OnlineProfile))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_DownloadOnlinePluginById_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DownloadOnlinePluginByIdRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).DownloadOnlinePluginById(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_DownloadOnlinePluginById_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).DownloadOnlinePluginById(ctx, req.(*DownloadOnlinePluginByIdRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_DownloadOnlinePluginByIds_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DownloadOnlinePluginByIdsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).DownloadOnlinePluginByIds(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_DownloadOnlinePluginByIds_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).DownloadOnlinePluginByIds(ctx, req.(*DownloadOnlinePluginByIdsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_DownloadOnlinePluginAll_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(DownloadOnlinePluginByTokenRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(YakServer).DownloadOnlinePluginAll(m, &grpc.GenericServerStream[DownloadOnlinePluginByTokenRequest, DownloadOnlinePluginProgress]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Yak_DownloadOnlinePluginAllServer = grpc.ServerStreamingServer[DownloadOnlinePluginProgress]

func _Yak_DeletePluginByUserID_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeletePluginByUserIDRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).DeletePluginByUserID(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_DeletePluginByUserID_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).DeletePluginByUserID(ctx, req.(*DeletePluginByUserIDRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_DeleteAllLocalPlugins_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).DeleteAllLocalPlugins(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_DeleteAllLocalPlugins_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).DeleteAllLocalPlugins(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_GetYakScriptTagsAndType_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).GetYakScriptTagsAndType(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_GetYakScriptTagsAndType_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).GetYakScriptTagsAndType(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_DeleteLocalPluginsByWhere_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteLocalPluginsByWhereRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).DeleteLocalPluginsByWhere(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_DeleteLocalPluginsByWhere_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).DeleteLocalPluginsByWhere(ctx, req.(*DeleteLocalPluginsByWhereRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_DownloadOnlinePluginByScriptNames_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DownloadOnlinePluginByScriptNamesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).DownloadOnlinePluginByScriptNames(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_DownloadOnlinePluginByScriptNames_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).DownloadOnlinePluginByScriptNames(ctx, req.(*DownloadOnlinePluginByScriptNamesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_DownloadOnlinePlugins_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(DownloadOnlinePluginsRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(YakServer).DownloadOnlinePlugins(m, &grpc.GenericServerStream[DownloadOnlinePluginsRequest, DownloadOnlinePluginProgress]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Yak_DownloadOnlinePluginsServer = grpc.ServerStreamingServer[DownloadOnlinePluginProgress]

func _Yak_DownloadOnlinePluginBatch_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DownloadOnlinePluginsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).DownloadOnlinePluginBatch(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_DownloadOnlinePluginBatch_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).DownloadOnlinePluginBatch(ctx, req.(*DownloadOnlinePluginsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_DownloadOnlinePluginByPluginName_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DownloadOnlinePluginByScriptNamesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).DownloadOnlinePluginByPluginName(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_DownloadOnlinePluginByPluginName_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).DownloadOnlinePluginByPluginName(ctx, req.(*DownloadOnlinePluginByScriptNamesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_DownloadOnlinePluginByUUID_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DownloadOnlinePluginByUUIDRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).DownloadOnlinePluginByUUID(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_DownloadOnlinePluginByUUID_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).DownloadOnlinePluginByUUID(ctx, req.(*DownloadOnlinePluginByUUIDRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_QueryOnlinePlugins_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryOnlinePluginsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).QueryOnlinePlugins(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_QueryOnlinePlugins_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).QueryOnlinePlugins(ctx, req.(*QueryOnlinePluginsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_ExecPacketScan_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(ExecPacketScanRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(YakServer).ExecPacketScan(m, &grpc.GenericServerStream[ExecPacketScanRequest, ExecResult]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Yak_ExecPacketScanServer = grpc.ServerStreamingServer[ExecResult]

func _Yak_GetEngineDefaultProxy_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).GetEngineDefaultProxy(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_GetEngineDefaultProxy_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).GetEngineDefaultProxy(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_SetEngineDefaultProxy_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DefaultProxyResult)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).SetEngineDefaultProxy(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_SetEngineDefaultProxy_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).SetEngineDefaultProxy(ctx, req.(*DefaultProxyResult))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_GetMachineID_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).GetMachineID(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_GetMachineID_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).GetMachineID(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_GetLicense_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).GetLicense(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_GetLicense_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).GetLicense(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_CheckLicense_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CheckLicenseRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).CheckLicense(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_CheckLicense_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).CheckLicense(ctx, req.(*CheckLicenseRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_GetRequestBodyByHTTPFlowID_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DownloadBodyByHTTPFlowIDRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).GetRequestBodyByHTTPFlowID(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_GetRequestBodyByHTTPFlowID_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).GetRequestBodyByHTTPFlowID(ctx, req.(*DownloadBodyByHTTPFlowIDRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_GetResponseBodyByHTTPFlowID_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DownloadBodyByHTTPFlowIDRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).GetResponseBodyByHTTPFlowID(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_GetResponseBodyByHTTPFlowID_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).GetResponseBodyByHTTPFlowID(ctx, req.(*DownloadBodyByHTTPFlowIDRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_GetHTTPPacketBody_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetHTTPPacketBodyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).GetHTTPPacketBody(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_GetHTTPPacketBody_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).GetHTTPPacketBody(ctx, req.(*GetHTTPPacketBodyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_RegisterFacadesHTTP_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RegisterFacadesHTTPRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).RegisterFacadesHTTP(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_RegisterFacadesHTTP_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).RegisterFacadesHTTP(ctx, req.(*RegisterFacadesHTTPRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_ResetAndInvalidUserData_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ResetAndInvalidUserDataRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).ResetAndInvalidUserData(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_ResetAndInvalidUserData_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).ResetAndInvalidUserData(ctx, req.(*ResetAndInvalidUserDataRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_CreateYaklangShell_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(YakServer).CreateYaklangShell(&grpc.GenericServerStream[YaklangShellRequest, YaklangShellResponse]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Yak_CreateYaklangShellServer = grpc.BidiStreamingServer[YaklangShellRequest, YaklangShellResponse]

func _Yak_AttachCombinedOutput_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(AttachCombinedOutputRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(YakServer).AttachCombinedOutput(m, &grpc.GenericServerStream[AttachCombinedOutputRequest, ExecResult]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Yak_AttachCombinedOutputServer = grpc.ServerStreamingServer[ExecResult]

func _Yak_IsPrivilegedForNetRaw_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).IsPrivilegedForNetRaw(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_IsPrivilegedForNetRaw_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).IsPrivilegedForNetRaw(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_PromotePermissionForUserPcap_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).PromotePermissionForUserPcap(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_PromotePermissionForUserPcap_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).PromotePermissionForUserPcap(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_SetCurrentProject_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetCurrentProjectRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).SetCurrentProject(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_SetCurrentProject_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).SetCurrentProject(ctx, req.(*SetCurrentProjectRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_GetCurrentProject_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).GetCurrentProject(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_GetCurrentProject_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).GetCurrentProject(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_GetCurrentProjectEx_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetCurrentProjectExRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).GetCurrentProjectEx(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_GetCurrentProjectEx_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).GetCurrentProjectEx(ctx, req.(*GetCurrentProjectExRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_GetProjects_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetProjectsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).GetProjects(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_GetProjects_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).GetProjects(ctx, req.(*GetProjectsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_NewProject_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NewProjectRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).NewProject(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_NewProject_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).NewProject(ctx, req.(*NewProjectRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_UpdateProject_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NewProjectRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).UpdateProject(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_UpdateProject_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).UpdateProject(ctx, req.(*NewProjectRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_IsProjectNameValid_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IsProjectNameValidRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).IsProjectNameValid(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_IsProjectNameValid_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).IsProjectNameValid(ctx, req.(*IsProjectNameValidRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_RemoveProject_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RemoveProjectRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).RemoveProject(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_RemoveProject_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).RemoveProject(ctx, req.(*RemoveProjectRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_DeleteProject_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteProjectRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).DeleteProject(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_DeleteProject_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).DeleteProject(ctx, req.(*DeleteProjectRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_GetDefaultProject_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).GetDefaultProject(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_GetDefaultProject_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).GetDefaultProject(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_GetDefaultProjectEx_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetDefaultProjectExRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).GetDefaultProjectEx(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_GetDefaultProjectEx_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).GetDefaultProjectEx(ctx, req.(*GetDefaultProjectExRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_QueryProjectDetail_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryProjectDetailRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).QueryProjectDetail(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_QueryProjectDetail_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).QueryProjectDetail(ctx, req.(*QueryProjectDetailRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_GetTemporaryProject_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).GetTemporaryProject(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_GetTemporaryProject_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).GetTemporaryProject(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_GetTemporaryProjectEx_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetTemporaryProjectExRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).GetTemporaryProjectEx(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_GetTemporaryProjectEx_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).GetTemporaryProjectEx(ctx, req.(*GetTemporaryProjectExRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_ExportProject_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(ExportProjectRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(YakServer).ExportProject(m, &grpc.GenericServerStream[ExportProjectRequest, ProjectIOProgress]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Yak_ExportProjectServer = grpc.ServerStreamingServer[ProjectIOProgress]

func _Yak_ImportProject_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(ImportProjectRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(YakServer).ImportProject(m, &grpc.GenericServerStream[ImportProjectRequest, ProjectIOProgress]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Yak_ImportProjectServer = grpc.ServerStreamingServer[ProjectIOProgress]

func _Yak_MigrateLegacyDatabase_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).MigrateLegacyDatabase(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_MigrateLegacyDatabase_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).MigrateLegacyDatabase(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_QueryMITMRuleExtractedData_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryMITMRuleExtractedDataRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).QueryMITMRuleExtractedData(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_QueryMITMRuleExtractedData_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).QueryMITMRuleExtractedData(ctx, req.(*QueryMITMRuleExtractedDataRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_ExportMITMRuleExtractedData_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(ExportMITMRuleExtractedDataRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(YakServer).ExportMITMRuleExtractedData(m, &grpc.GenericServerStream[ExportMITMRuleExtractedDataRequest, ExportMITMRuleExtractedDataResponse]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Yak_ExportMITMRuleExtractedDataServer = grpc.ServerStreamingServer[ExportMITMRuleExtractedDataResponse]

func _Yak_ImportChaosMakerRules_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ImportChaosMakerRulesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).ImportChaosMakerRules(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_ImportChaosMakerRules_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).ImportChaosMakerRules(ctx, req.(*ImportChaosMakerRulesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_QueryChaosMakerRule_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryChaosMakerRuleRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).QueryChaosMakerRule(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_QueryChaosMakerRule_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).QueryChaosMakerRule(ctx, req.(*QueryChaosMakerRuleRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_DeleteChaosMakerRuleByID_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteChaosMakerRuleByIDRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).DeleteChaosMakerRuleByID(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_DeleteChaosMakerRuleByID_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).DeleteChaosMakerRuleByID(ctx, req.(*DeleteChaosMakerRuleByIDRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_ExecuteChaosMakerRule_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(ExecuteChaosMakerRuleRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(YakServer).ExecuteChaosMakerRule(m, &grpc.GenericServerStream[ExecuteChaosMakerRuleRequest, ExecResult]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Yak_ExecuteChaosMakerRuleServer = grpc.ServerStreamingServer[ExecResult]

func _Yak_IsRemoteAddrAvailable_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IsRemoteAddrAvailableRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).IsRemoteAddrAvailable(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_IsRemoteAddrAvailable_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).IsRemoteAddrAvailable(ctx, req.(*IsRemoteAddrAvailableRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_ConnectVulinboxAgent_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IsRemoteAddrAvailableRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).ConnectVulinboxAgent(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_ConnectVulinboxAgent_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).ConnectVulinboxAgent(ctx, req.(*IsRemoteAddrAvailableRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_GetRegisteredVulinboxAgent_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetRegisteredAgentRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).GetRegisteredVulinboxAgent(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_GetRegisteredVulinboxAgent_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).GetRegisteredVulinboxAgent(ctx, req.(*GetRegisteredAgentRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_DisconnectVulinboxAgent_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DisconnectVulinboxAgentRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).DisconnectVulinboxAgent(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_DisconnectVulinboxAgent_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).DisconnectVulinboxAgent(ctx, req.(*DisconnectVulinboxAgentRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_IsCVEDatabaseReady_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IsCVEDatabaseReadyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).IsCVEDatabaseReady(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_IsCVEDatabaseReady_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).IsCVEDatabaseReady(ctx, req.(*IsCVEDatabaseReadyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_UpdateCVEDatabase_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(UpdateCVEDatabaseRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(YakServer).UpdateCVEDatabase(m, &grpc.GenericServerStream[UpdateCVEDatabaseRequest, ExecResult]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Yak_UpdateCVEDatabaseServer = grpc.ServerStreamingServer[ExecResult]

func _Yak_ExportsProfileDatabase_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(ExportsProfileDatabaseRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(YakServer).ExportsProfileDatabase(m, &grpc.GenericServerStream[ExportsProfileDatabaseRequest, ExecResult]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Yak_ExportsProfileDatabaseServer = grpc.ServerStreamingServer[ExecResult]

func _Yak_ImportsProfileDatabase_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(ImportsProfileDatabaseRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(YakServer).ImportsProfileDatabase(m, &grpc.GenericServerStream[ImportsProfileDatabaseRequest, ExecResult]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Yak_ImportsProfileDatabaseServer = grpc.ServerStreamingServer[ExecResult]

func _Yak_QueryCVE_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryCVERequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).QueryCVE(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_QueryCVE_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).QueryCVE(ctx, req.(*QueryCVERequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_GetCVE_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetCVERequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).GetCVE(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_GetCVE_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).GetCVE(ctx, req.(*GetCVERequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_SaveTextToTemporalFile_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SaveTextToTemporalFileRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).SaveTextToTemporalFile(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_SaveTextToTemporalFile_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).SaveTextToTemporalFile(ctx, req.(*SaveTextToTemporalFileRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_IsScrecorderReady_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IsScrecorderReadyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).IsScrecorderReady(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_IsScrecorderReady_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).IsScrecorderReady(ctx, req.(*IsScrecorderReadyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_InstallScrecorder_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(InstallScrecorderRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(YakServer).InstallScrecorder(m, &grpc.GenericServerStream[InstallScrecorderRequest, ExecResult]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Yak_InstallScrecorderServer = grpc.ServerStreamingServer[ExecResult]

func _Yak_StartScrecorder_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(StartScrecorderRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(YakServer).StartScrecorder(m, &grpc.GenericServerStream[StartScrecorderRequest, ExecResult]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Yak_StartScrecorderServer = grpc.ServerStreamingServer[ExecResult]

func _Yak_QueryScreenRecorders_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryScreenRecorderRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).QueryScreenRecorders(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_QueryScreenRecorders_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).QueryScreenRecorders(ctx, req.(*QueryScreenRecorderRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_DeleteScreenRecorders_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryScreenRecorderRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).DeleteScreenRecorders(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_DeleteScreenRecorders_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).DeleteScreenRecorders(ctx, req.(*QueryScreenRecorderRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_UploadScreenRecorders_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UploadScreenRecorderRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).UploadScreenRecorders(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_UploadScreenRecorders_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).UploadScreenRecorders(ctx, req.(*UploadScreenRecorderRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_GetOneScreenRecorders_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetOneScreenRecorderRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).GetOneScreenRecorders(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_GetOneScreenRecorders_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).GetOneScreenRecorders(ctx, req.(*GetOneScreenRecorderRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_UpdateScreenRecorders_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateScreenRecorderRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).UpdateScreenRecorders(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_UpdateScreenRecorders_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).UpdateScreenRecorders(ctx, req.(*UpdateScreenRecorderRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_IsVulinboxReady_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IsVulinboxReadyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).IsVulinboxReady(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_IsVulinboxReady_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).IsVulinboxReady(ctx, req.(*IsVulinboxReadyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_InstallVulinbox_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(InstallVulinboxRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(YakServer).InstallVulinbox(m, &grpc.GenericServerStream[InstallVulinboxRequest, ExecResult]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Yak_InstallVulinboxServer = grpc.ServerStreamingServer[ExecResult]

func _Yak_StartVulinbox_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(StartVulinboxRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(YakServer).StartVulinbox(m, &grpc.GenericServerStream[StartVulinboxRequest, ExecResult]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Yak_StartVulinboxServer = grpc.ServerStreamingServer[ExecResult]

func _Yak_GenQualityInspectionReport_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(GenQualityInspectionReportRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(YakServer).GenQualityInspectionReport(m, &grpc.GenericServerStream[GenQualityInspectionReportRequest, ExecResult]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Yak_GenQualityInspectionReportServer = grpc.ServerStreamingServer[ExecResult]

func _Yak_HTTPRequestBuilder_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(HTTPRequestBuilderParams)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).HTTPRequestBuilder(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_HTTPRequestBuilder_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).HTTPRequestBuilder(ctx, req.(*HTTPRequestBuilderParams))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_DebugPlugin_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(DebugPluginRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(YakServer).DebugPlugin(m, &grpc.GenericServerStream[DebugPluginRequest, ExecResult]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Yak_DebugPluginServer = grpc.ServerStreamingServer[ExecResult]

func _Yak_SmokingEvaluatePlugin_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SmokingEvaluatePluginRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).SmokingEvaluatePlugin(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_SmokingEvaluatePlugin_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).SmokingEvaluatePlugin(ctx, req.(*SmokingEvaluatePluginRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_SmokingEvaluatePluginBatch_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(SmokingEvaluatePluginBatchRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(YakServer).SmokingEvaluatePluginBatch(m, &grpc.GenericServerStream[SmokingEvaluatePluginBatchRequest, SmokingEvaluatePluginBatchResponse]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Yak_SmokingEvaluatePluginBatchServer = grpc.ServerStreamingServer[SmokingEvaluatePluginBatchResponse]

func _Yak_GetSystemDefaultDnsServers_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).GetSystemDefaultDnsServers(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_GetSystemDefaultDnsServers_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).GetSystemDefaultDnsServers(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_DiagnoseNetwork_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(DiagnoseNetworkRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(YakServer).DiagnoseNetwork(m, &grpc.GenericServerStream[DiagnoseNetworkRequest, DiagnoseNetworkResponse]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Yak_DiagnoseNetworkServer = grpc.ServerStreamingServer[DiagnoseNetworkResponse]

func _Yak_DiagnoseNetworkDNS_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(DiagnoseNetworkDNSRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(YakServer).DiagnoseNetworkDNS(m, &grpc.GenericServerStream[DiagnoseNetworkDNSRequest, DiagnoseNetworkResponse]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Yak_DiagnoseNetworkDNSServer = grpc.ServerStreamingServer[DiagnoseNetworkResponse]

func _Yak_TraceRoute_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(TraceRouteRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(YakServer).TraceRoute(m, &grpc.GenericServerStream[TraceRouteRequest, TraceRouteResponse]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Yak_TraceRouteServer = grpc.ServerStreamingServer[TraceRouteResponse]

func _Yak_GetGlobalNetworkConfig_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetGlobalNetworkConfigRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).GetGlobalNetworkConfig(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_GetGlobalNetworkConfig_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).GetGlobalNetworkConfig(ctx, req.(*GetGlobalNetworkConfigRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_SetGlobalNetworkConfig_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GlobalNetworkConfig)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).SetGlobalNetworkConfig(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_SetGlobalNetworkConfig_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).SetGlobalNetworkConfig(ctx, req.(*GlobalNetworkConfig))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_ResetGlobalNetworkConfig_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ResetGlobalNetworkConfigRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).ResetGlobalNetworkConfig(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_ResetGlobalNetworkConfig_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).ResetGlobalNetworkConfig(ctx, req.(*ResetGlobalNetworkConfigRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_ValidP12PassWord_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ValidP12PassWordRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).ValidP12PassWord(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_ValidP12PassWord_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).ValidP12PassWord(ctx, req.(*ValidP12PassWordRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_RequestYakURL_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RequestYakURLParams)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).RequestYakURL(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_RequestYakURL_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).RequestYakURL(ctx, req.(*RequestYakURLParams))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_ReadFile_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(ReadFileRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(YakServer).ReadFile(m, &grpc.GenericServerStream[ReadFileRequest, ReadFileResponse]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Yak_ReadFileServer = grpc.ServerStreamingServer[ReadFileResponse]

func _Yak_GetPcapMetadata_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PcapMetadataRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).GetPcapMetadata(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_GetPcapMetadata_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).GetPcapMetadata(ctx, req.(*PcapMetadataRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_PcapX_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(YakServer).PcapX(&grpc.GenericServerStream[PcapXRequest, PcapXResponse]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Yak_PcapXServer = grpc.BidiStreamingServer[PcapXRequest, PcapXResponse]

func _Yak_QueryTrafficSession_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryTrafficSessionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).QueryTrafficSession(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_QueryTrafficSession_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).QueryTrafficSession(ctx, req.(*QueryTrafficSessionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_QueryTrafficPacket_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryTrafficPacketRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).QueryTrafficPacket(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_QueryTrafficPacket_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).QueryTrafficPacket(ctx, req.(*QueryTrafficPacketRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_QueryTrafficTCPReassembled_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryTrafficTCPReassembledRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).QueryTrafficTCPReassembled(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_QueryTrafficTCPReassembled_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).QueryTrafficTCPReassembled(ctx, req.(*QueryTrafficTCPReassembledRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_ParseTraffic_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ParseTrafficRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).ParseTraffic(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_ParseTraffic_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).ParseTraffic(ctx, req.(*ParseTrafficRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_DuplexConnection_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(YakServer).DuplexConnection(&grpc.GenericServerStream[DuplexConnectionRequest, DuplexConnectionResponse]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Yak_DuplexConnectionServer = grpc.BidiStreamingServer[DuplexConnectionRequest, DuplexConnectionResponse]

func _Yak_HybridScan_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(YakServer).HybridScan(&grpc.GenericServerStream[HybridScanRequest, HybridScanResponse]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Yak_HybridScanServer = grpc.BidiStreamingServer[HybridScanRequest, HybridScanResponse]

func _Yak_QueryHybridScanTask_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryHybridScanTaskRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).QueryHybridScanTask(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_QueryHybridScanTask_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).QueryHybridScanTask(ctx, req.(*QueryHybridScanTaskRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_DeleteHybridScanTask_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteHybridScanTaskRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).DeleteHybridScanTask(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_DeleteHybridScanTask_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).DeleteHybridScanTask(ctx, req.(*DeleteHybridScanTaskRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_GetSpaceEngineStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetSpaceEngineStatusRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).GetSpaceEngineStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_GetSpaceEngineStatus_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).GetSpaceEngineStatus(ctx, req.(*GetSpaceEngineStatusRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_GetSpaceEngineAccountStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetSpaceEngineAccountStatusRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).GetSpaceEngineAccountStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_GetSpaceEngineAccountStatus_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).GetSpaceEngineAccountStatus(ctx, req.(*GetSpaceEngineAccountStatusRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_GetSpaceEngineAccountStatusV2_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ThirdPartyApplicationConfig)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).GetSpaceEngineAccountStatusV2(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_GetSpaceEngineAccountStatusV2_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).GetSpaceEngineAccountStatusV2(ctx, req.(*ThirdPartyApplicationConfig))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_FetchPortAssetFromSpaceEngine_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(FetchPortAssetFromSpaceEngineRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(YakServer).FetchPortAssetFromSpaceEngine(m, &grpc.GenericServerStream[FetchPortAssetFromSpaceEngineRequest, ExecResult]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Yak_FetchPortAssetFromSpaceEngineServer = grpc.ServerStreamingServer[ExecResult]

func _Yak_EvaluateExpression_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EvaluateExpressionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).EvaluateExpression(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_EvaluateExpression_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).EvaluateExpression(ctx, req.(*EvaluateExpressionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_EvaluateMultiExpression_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EvaluateMultiExpressionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).EvaluateMultiExpression(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_EvaluateMultiExpression_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).EvaluateMultiExpression(ctx, req.(*EvaluateMultiExpressionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_GetThirdPartyAppConfigTemplate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).GetThirdPartyAppConfigTemplate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_GetThirdPartyAppConfigTemplate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).GetThirdPartyAppConfigTemplate(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_CheckHahValidAiConfig_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).CheckHahValidAiConfig(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_CheckHahValidAiConfig_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).CheckHahValidAiConfig(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_ListAiModel_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListAiModelRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).ListAiModel(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_ListAiModel_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).ListAiModel(ctx, req.(*ListAiModelRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_GetFingerprint_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetFingerprintRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).GetFingerprint(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_GetFingerprint_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).GetFingerprint(ctx, req.(*GetFingerprintRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_AddFingerprint_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddFingerprintRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).AddFingerprint(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_AddFingerprint_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).AddFingerprint(ctx, req.(*AddFingerprintRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_ModifyFingerprint_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ModifyFingerprintRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).ModifyFingerprint(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_ModifyFingerprint_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).ModifyFingerprint(ctx, req.(*ModifyFingerprintRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_QueryFingerprint_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryFingerprintRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).QueryFingerprint(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_QueryFingerprint_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).QueryFingerprint(ctx, req.(*QueryFingerprintRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_DeleteFingerprint_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteFingerprintRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).DeleteFingerprint(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_DeleteFingerprint_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).DeleteFingerprint(ctx, req.(*DeleteFingerprintRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_UpdateFingerprint_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateFingerprintRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).UpdateFingerprint(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_UpdateFingerprint_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).UpdateFingerprint(ctx, req.(*UpdateFingerprintRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_CreateFingerprint_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateFingerprintRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).CreateFingerprint(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_CreateFingerprint_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).CreateFingerprint(ctx, req.(*CreateFingerprintRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_RecoverBuiltinFingerprint_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).RecoverBuiltinFingerprint(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_RecoverBuiltinFingerprint_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).RecoverBuiltinFingerprint(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_CreateFingerprintGroup_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FingerprintGroup)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).CreateFingerprintGroup(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_CreateFingerprintGroup_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).CreateFingerprintGroup(ctx, req.(*FingerprintGroup))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_GetAllFingerprintGroup_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).GetAllFingerprintGroup(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_GetAllFingerprintGroup_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).GetAllFingerprintGroup(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_RenameFingerprintGroup_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RenameFingerprintGroupRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).RenameFingerprintGroup(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_RenameFingerprintGroup_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).RenameFingerprintGroup(ctx, req.(*RenameFingerprintGroupRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_DeleteFingerprintGroup_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteFingerprintGroupRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).DeleteFingerprintGroup(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_DeleteFingerprintGroup_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).DeleteFingerprintGroup(ctx, req.(*DeleteFingerprintGroupRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_BatchUpdateFingerprintToGroup_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BatchUpdateFingerprintToGroupRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).BatchUpdateFingerprintToGroup(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_BatchUpdateFingerprintToGroup_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).BatchUpdateFingerprintToGroup(ctx, req.(*BatchUpdateFingerprintToGroupRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_GetFingerprintGroupSetByFilter_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetFingerprintGroupSetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).GetFingerprintGroupSetByFilter(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_GetFingerprintGroupSetByFilter_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).GetFingerprintGroupSetByFilter(ctx, req.(*GetFingerprintGroupSetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_ExportFingerprint_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(ExportFingerprintRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(YakServer).ExportFingerprint(m, &grpc.GenericServerStream[ExportFingerprintRequest, DataTransferProgress]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Yak_ExportFingerprintServer = grpc.ServerStreamingServer[DataTransferProgress]

func _Yak_ImportFingerprint_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(ImportFingerprintRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(YakServer).ImportFingerprint(m, &grpc.GenericServerStream[ImportFingerprintRequest, DataTransferProgress]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Yak_ImportFingerprintServer = grpc.ServerStreamingServer[DataTransferProgress]

func _Yak_GetReverseShellProgramList_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetReverseShellProgramListRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).GetReverseShellProgramList(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_GetReverseShellProgramList_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).GetReverseShellProgramList(ctx, req.(*GetReverseShellProgramListRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_GenerateReverseShellCommand_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GenerateReverseShellCommandRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).GenerateReverseShellCommand(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_GenerateReverseShellCommand_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).GenerateReverseShellCommand(ctx, req.(*GenerateReverseShellCommandRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_QuerySyntaxFlowRule_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QuerySyntaxFlowRuleRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).QuerySyntaxFlowRule(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_QuerySyntaxFlowRule_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).QuerySyntaxFlowRule(ctx, req.(*QuerySyntaxFlowRuleRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_CreateSyntaxFlowRule_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateSyntaxFlowRuleRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).CreateSyntaxFlowRule(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_CreateSyntaxFlowRule_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).CreateSyntaxFlowRule(ctx, req.(*CreateSyntaxFlowRuleRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_CreateSyntaxFlowRuleEx_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateSyntaxFlowRuleRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).CreateSyntaxFlowRuleEx(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_CreateSyntaxFlowRuleEx_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).CreateSyntaxFlowRuleEx(ctx, req.(*CreateSyntaxFlowRuleRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_UpdateSyntaxFlowRule_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateSyntaxFlowRuleRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).UpdateSyntaxFlowRule(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_UpdateSyntaxFlowRule_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).UpdateSyntaxFlowRule(ctx, req.(*UpdateSyntaxFlowRuleRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_UpdateSyntaxFlowRuleEx_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateSyntaxFlowRuleRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).UpdateSyntaxFlowRuleEx(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_UpdateSyntaxFlowRuleEx_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).UpdateSyntaxFlowRuleEx(ctx, req.(*UpdateSyntaxFlowRuleRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_DeleteSyntaxFlowRule_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteSyntaxFlowRuleRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).DeleteSyntaxFlowRule(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_DeleteSyntaxFlowRule_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).DeleteSyntaxFlowRule(ctx, req.(*DeleteSyntaxFlowRuleRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_CheckSyntaxFlowRuleUpdate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CheckSyntaxFlowRuleUpdateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).CheckSyntaxFlowRuleUpdate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_CheckSyntaxFlowRuleUpdate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).CheckSyntaxFlowRuleUpdate(ctx, req.(*CheckSyntaxFlowRuleUpdateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_ApplySyntaxFlowRuleUpdate_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(ApplySyntaxFlowRuleUpdateRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(YakServer).ApplySyntaxFlowRuleUpdate(m, &grpc.GenericServerStream[ApplySyntaxFlowRuleUpdateRequest, ApplySyntaxFlowRuleUpdateResponse]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Yak_ApplySyntaxFlowRuleUpdateServer = grpc.ServerStreamingServer[ApplySyntaxFlowRuleUpdateResponse]

func _Yak_QuerySyntaxFlowRuleGroup_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QuerySyntaxFlowRuleGroupRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).QuerySyntaxFlowRuleGroup(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_QuerySyntaxFlowRuleGroup_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).QuerySyntaxFlowRuleGroup(ctx, req.(*QuerySyntaxFlowRuleGroupRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_DeleteSyntaxFlowRuleGroup_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteSyntaxFlowRuleGroupRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).DeleteSyntaxFlowRuleGroup(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_DeleteSyntaxFlowRuleGroup_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).DeleteSyntaxFlowRuleGroup(ctx, req.(*DeleteSyntaxFlowRuleGroupRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_CreateSyntaxFlowRuleGroup_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateSyntaxFlowGroupRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).CreateSyntaxFlowRuleGroup(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_CreateSyntaxFlowRuleGroup_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).CreateSyntaxFlowRuleGroup(ctx, req.(*CreateSyntaxFlowGroupRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_UpdateSyntaxFlowRuleGroup_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateSyntaxFlowRuleGroupRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).UpdateSyntaxFlowRuleGroup(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_UpdateSyntaxFlowRuleGroup_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).UpdateSyntaxFlowRuleGroup(ctx, req.(*UpdateSyntaxFlowRuleGroupRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_UpdateSyntaxFlowRuleAndGroup_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateSyntaxFlowRuleAndGroupRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).UpdateSyntaxFlowRuleAndGroup(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_UpdateSyntaxFlowRuleAndGroup_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).UpdateSyntaxFlowRuleAndGroup(ctx, req.(*UpdateSyntaxFlowRuleAndGroupRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_QuerySyntaxFlowSameGroup_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QuerySyntaxFlowSameGroupRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).QuerySyntaxFlowSameGroup(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_QuerySyntaxFlowSameGroup_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).QuerySyntaxFlowSameGroup(ctx, req.(*QuerySyntaxFlowSameGroupRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_SyntaxFlowRuleToOnline_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(SyntaxFlowRuleToOnlineRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(YakServer).SyntaxFlowRuleToOnline(m, &grpc.GenericServerStream[SyntaxFlowRuleToOnlineRequest, SyntaxFlowRuleOnlineProgress]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Yak_SyntaxFlowRuleToOnlineServer = grpc.ServerStreamingServer[SyntaxFlowRuleOnlineProgress]

func _Yak_DownloadSyntaxFlowRule_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(DownloadSyntaxFlowRuleRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(YakServer).DownloadSyntaxFlowRule(m, &grpc.GenericServerStream[DownloadSyntaxFlowRuleRequest, SyntaxFlowRuleOnlineProgress]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Yak_DownloadSyntaxFlowRuleServer = grpc.ServerStreamingServer[SyntaxFlowRuleOnlineProgress]

func _Yak_SyntaxFlowScan_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(YakServer).SyntaxFlowScan(&grpc.GenericServerStream[SyntaxFlowScanRequest, SyntaxFlowScanResponse]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Yak_SyntaxFlowScanServer = grpc.BidiStreamingServer[SyntaxFlowScanRequest, SyntaxFlowScanResponse]

func _Yak_QuerySyntaxFlowScanTask_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QuerySyntaxFlowScanTaskRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).QuerySyntaxFlowScanTask(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_QuerySyntaxFlowScanTask_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).QuerySyntaxFlowScanTask(ctx, req.(*QuerySyntaxFlowScanTaskRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_DeleteSyntaxFlowScanTask_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteSyntaxFlowScanTaskRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).DeleteSyntaxFlowScanTask(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_DeleteSyntaxFlowScanTask_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).DeleteSyntaxFlowScanTask(ctx, req.(*DeleteSyntaxFlowScanTaskRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_QuerySyntaxFlowResult_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QuerySyntaxFlowResultRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).QuerySyntaxFlowResult(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_QuerySyntaxFlowResult_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).QuerySyntaxFlowResult(ctx, req.(*QuerySyntaxFlowResultRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_DeleteSyntaxFlowResult_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteSyntaxFlowResultRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).DeleteSyntaxFlowResult(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_DeleteSyntaxFlowResult_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).DeleteSyntaxFlowResult(ctx, req.(*DeleteSyntaxFlowResultRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_QuerySSAPrograms_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QuerySSAProgramRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).QuerySSAPrograms(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_QuerySSAPrograms_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).QuerySSAPrograms(ctx, req.(*QuerySSAProgramRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_UpdateSSAProgram_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateSSAProgramRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).UpdateSSAProgram(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_UpdateSSAProgram_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).UpdateSSAProgram(ctx, req.(*UpdateSSAProgramRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_DeleteSSAPrograms_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteSSAProgramRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).DeleteSSAPrograms(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_DeleteSSAPrograms_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).DeleteSSAPrograms(ctx, req.(*DeleteSSAProgramRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_QuerySSARisks_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QuerySSARisksRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).QuerySSARisks(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_QuerySSARisks_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).QuerySSARisks(ctx, req.(*QuerySSARisksRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_QueryNewSSARisks_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryNewSSARisksRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).QueryNewSSARisks(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_QueryNewSSARisks_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).QueryNewSSARisks(ctx, req.(*QueryNewSSARisksRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_DeleteSSARisks_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteSSARisksRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).DeleteSSARisks(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_DeleteSSARisks_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).DeleteSSARisks(ctx, req.(*DeleteSSARisksRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_UpdateSSARiskTags_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateSSARiskTagsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).UpdateSSARiskTags(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_UpdateSSARiskTags_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).UpdateSSARiskTags(ctx, req.(*UpdateSSARiskTagsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_GetSSARiskFieldGroup_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).GetSSARiskFieldGroup(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_GetSSARiskFieldGroup_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).GetSSARiskFieldGroup(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_NewSSARiskRead_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NewSSARiskReadRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).NewSSARiskRead(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_NewSSARiskRead_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).NewSSARiskRead(ctx, req.(*NewSSARiskReadRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_SSARiskFeedbackToOnline_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SSARiskFeedbackToOnlineRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).SSARiskFeedbackToOnline(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_SSARiskFeedbackToOnline_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).SSARiskFeedbackToOnline(ctx, req.(*SSARiskFeedbackToOnlineRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_GetAllPluginEnv_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).GetAllPluginEnv(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_GetAllPluginEnv_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).GetAllPluginEnv(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_QueryPluginEnv_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryPluginEnvRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).QueryPluginEnv(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_QueryPluginEnv_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).QueryPluginEnv(ctx, req.(*QueryPluginEnvRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_CreatePluginEnv_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PluginEnvData)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).CreatePluginEnv(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_CreatePluginEnv_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).CreatePluginEnv(ctx, req.(*PluginEnvData))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_SetPluginEnv_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PluginEnvData)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).SetPluginEnv(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_SetPluginEnv_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).SetPluginEnv(ctx, req.(*PluginEnvData))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_DeletePluginEnv_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeletePluginEnvRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).DeletePluginEnv(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_DeletePluginEnv_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).DeletePluginEnv(ctx, req.(*DeletePluginEnvRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_GetAllFuzztagInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetAllFuzztagInfoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).GetAllFuzztagInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_GetAllFuzztagInfo_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).GetAllFuzztagInfo(ctx, req.(*GetAllFuzztagInfoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_GenerateFuzztag_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GenerateFuzztagRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).GenerateFuzztag(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_GenerateFuzztag_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).GenerateFuzztag(ctx, req.(*GenerateFuzztagRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_ExportSyntaxFlows_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(ExportSyntaxFlowsRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(YakServer).ExportSyntaxFlows(m, &grpc.GenericServerStream[ExportSyntaxFlowsRequest, SyntaxflowsProgress]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Yak_ExportSyntaxFlowsServer = grpc.ServerStreamingServer[SyntaxflowsProgress]

func _Yak_ImportSyntaxFlows_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(ImportSyntaxFlowsRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(YakServer).ImportSyntaxFlows(m, &grpc.GenericServerStream[ImportSyntaxFlowsRequest, SyntaxflowsProgress]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Yak_ImportSyntaxFlowsServer = grpc.ServerStreamingServer[SyntaxflowsProgress]

func _Yak_CreateHotPatchTemplate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(HotPatchTemplate)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).CreateHotPatchTemplate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_CreateHotPatchTemplate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).CreateHotPatchTemplate(ctx, req.(*HotPatchTemplate))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_DeleteHotPatchTemplate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteHotPatchTemplateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).DeleteHotPatchTemplate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_DeleteHotPatchTemplate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).DeleteHotPatchTemplate(ctx, req.(*DeleteHotPatchTemplateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_UpdateHotPatchTemplate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateHotPatchTemplateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).UpdateHotPatchTemplate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_UpdateHotPatchTemplate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).UpdateHotPatchTemplate(ctx, req.(*UpdateHotPatchTemplateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_QueryHotPatchTemplate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(HotPatchTemplateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).QueryHotPatchTemplate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_QueryHotPatchTemplate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).QueryHotPatchTemplate(ctx, req.(*HotPatchTemplateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_QueryHotPatchTemplateList_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryHotPatchTemplateListRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).QueryHotPatchTemplateList(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_QueryHotPatchTemplateList_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).QueryHotPatchTemplateList(ctx, req.(*QueryHotPatchTemplateListRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_GroupTableColumn_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GroupTableColumnRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).GroupTableColumn(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_GroupTableColumn_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).GroupTableColumn(ctx, req.(*GroupTableColumnRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_UploadHotPatchTemplateToOnline_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UploadHotPatchTemplateToOnlineRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).UploadHotPatchTemplateToOnline(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_UploadHotPatchTemplateToOnline_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).UploadHotPatchTemplateToOnline(ctx, req.(*UploadHotPatchTemplateToOnlineRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_DownloadHotPatchTemplate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DownloadHotPatchTemplateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).DownloadHotPatchTemplate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_DownloadHotPatchTemplate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).DownloadHotPatchTemplate(ctx, req.(*DownloadHotPatchTemplateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_SetMITMHijackFilter_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetMITMFilterRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).SetMITMHijackFilter(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_SetMITMHijackFilter_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).SetMITMHijackFilter(ctx, req.(*SetMITMFilterRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_GetMITMHijackFilter_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).GetMITMHijackFilter(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_GetMITMHijackFilter_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).GetMITMHijackFilter(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_ResetMITMHijackFilter_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).ResetMITMHijackFilter(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_ResetMITMHijackFilter_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).ResetMITMHijackFilter(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_ExportHTTPFlowStream_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(ExportHTTPFlowStreamRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(YakServer).ExportHTTPFlowStream(m, &grpc.GenericServerStream[ExportHTTPFlowStreamRequest, ExportHTTPFlowStreamResponse]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Yak_ExportHTTPFlowStreamServer = grpc.ServerStreamingServer[ExportHTTPFlowStreamResponse]

func _Yak_ImportHTTPFlowStream_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(ImportHTTPFlowStreamRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(YakServer).ImportHTTPFlowStream(m, &grpc.GenericServerStream[ImportHTTPFlowStreamRequest, ImportHTTPFlowStreamResponse]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Yak_ImportHTTPFlowStreamServer = grpc.ServerStreamingServer[ImportHTTPFlowStreamResponse]

func _Yak_CreateNote_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateNoteRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).CreateNote(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_CreateNote_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).CreateNote(ctx, req.(*CreateNoteRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_UpdateNote_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateNoteRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).UpdateNote(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_UpdateNote_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).UpdateNote(ctx, req.(*UpdateNoteRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_DeleteNote_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteNoteRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).DeleteNote(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_DeleteNote_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).DeleteNote(ctx, req.(*DeleteNoteRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_QueryNote_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryNoteRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).QueryNote(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_QueryNote_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).QueryNote(ctx, req.(*QueryNoteRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_SearchNoteContent_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SearchNoteContentRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).SearchNoteContent(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_SearchNoteContent_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).SearchNoteContent(ctx, req.(*SearchNoteContentRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_ImportNote_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(ImportNoteRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(YakServer).ImportNote(m, &grpc.GenericServerStream[ImportNoteRequest, ImportNoteResponse]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Yak_ImportNoteServer = grpc.ServerStreamingServer[ImportNoteResponse]

func _Yak_ExportNote_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(ExportNoteRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(YakServer).ExportNote(m, &grpc.GenericServerStream[ExportNoteRequest, ExportNoteResponse]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Yak_ExportNoteServer = grpc.ServerStreamingServer[ExportNoteResponse]

func _Yak_StartAITask_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(YakServer).StartAITask(&grpc.GenericServerStream[AIInputEvent, AIOutputEvent]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Yak_StartAITaskServer = grpc.BidiStreamingServer[AIInputEvent, AIOutputEvent]

func _Yak_QueryAITask_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AITaskQueryRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).QueryAITask(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_QueryAITask_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).QueryAITask(ctx, req.(*AITaskQueryRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_StartAITriage_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(YakServer).StartAITriage(&grpc.GenericServerStream[AITriageInputEvent, AIOutputEvent]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Yak_StartAITriageServer = grpc.BidiStreamingServer[AITriageInputEvent, AIOutputEvent]

func _Yak_CreateAIForge_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AIForge)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).CreateAIForge(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_CreateAIForge_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).CreateAIForge(ctx, req.(*AIForge))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_UpdateAIForge_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AIForge)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).UpdateAIForge(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_UpdateAIForge_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).UpdateAIForge(ctx, req.(*AIForge))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_DeleteAIForge_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AIForgeFilter)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).DeleteAIForge(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_DeleteAIForge_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).DeleteAIForge(ctx, req.(*AIForgeFilter))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_QueryAIForge_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryAIForgeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).QueryAIForge(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_QueryAIForge_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).QueryAIForge(ctx, req.(*QueryAIForgeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_StartMcpServer_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(StartMcpServerRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(YakServer).StartMcpServer(m, &grpc.GenericServerStream[StartMcpServerRequest, StartMcpServerResponse]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Yak_StartMcpServerServer = grpc.ServerStreamingServer[StartMcpServerResponse]

func _Yak_GetToolSetList_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).GetToolSetList(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_GetToolSetList_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).GetToolSetList(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_GetAIToolList_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetAIToolListRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).GetAIToolList(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_GetAIToolList_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).GetAIToolList(ctx, req.(*GetAIToolListRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_DeleteAITool_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteAIToolRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).DeleteAITool(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_DeleteAITool_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).DeleteAITool(ctx, req.(*DeleteAIToolRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_SaveAITool_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SaveAIToolRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).SaveAITool(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_SaveAITool_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).SaveAITool(ctx, req.(*SaveAIToolRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_ToggleAIToolFavorite_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ToggleAIToolFavoriteRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).ToggleAIToolFavorite(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_ToggleAIToolFavorite_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).ToggleAIToolFavorite(ctx, req.(*ToggleAIToolFavoriteRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_AIToolGenerateMetadata_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AIToolGenerateMetadataRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).AIToolGenerateMetadata(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_AIToolGenerateMetadata_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).AIToolGenerateMetadata(ctx, req.(*AIToolGenerateMetadataRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// Yak_ServiceDesc is the grpc.ServiceDesc for Yak service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Yak_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "ypb.Yak",
	HandlerType: (*YakServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Version",
			Handler:    _Yak_Version_Handler,
		},
		{
			MethodName: "YakVersionAtLeast",
			Handler:    _Yak_YakVersionAtLeast_Handler,
		},
		{
			MethodName: "Echo",
			Handler:    _Yak_Echo_Handler,
		},
		{
			MethodName: "Handshake",
			Handler:    _Yak_Handshake_Handler,
		},
		{
			MethodName: "VerifySystemCertificate",
			Handler:    _Yak_VerifySystemCertificate_Handler,
		},
		{
			MethodName: "SetMITMFilter",
			Handler:    _Yak_SetMITMFilter_Handler,
		},
		{
			MethodName: "GetMITMFilter",
			Handler:    _Yak_GetMITMFilter_Handler,
		},
		{
			MethodName: "ResetMITMFilter",
			Handler:    _Yak_ResetMITMFilter_Handler,
		},
		{
			MethodName: "DownloadMITMCert",
			Handler:    _Yak_DownloadMITMCert_Handler,
		},
		{
			MethodName: "QueryExecHistory",
			Handler:    _Yak_QueryExecHistory_Handler,
		},
		{
			MethodName: "RemoveExecHistory",
			Handler:    _Yak_RemoveExecHistory_Handler,
		},
		{
			MethodName: "LoadNucleiTemplates",
			Handler:    _Yak_LoadNucleiTemplates_Handler,
		},
		{
			MethodName: "GetExecBatchYakScriptUnfinishedTask",
			Handler:    _Yak_GetExecBatchYakScriptUnfinishedTask_Handler,
		},
		{
			MethodName: "GetExecBatchYakScriptUnfinishedTaskByUid",
			Handler:    _Yak_GetExecBatchYakScriptUnfinishedTaskByUid_Handler,
		},
		{
			MethodName: "PopExecBatchYakScriptUnfinishedTaskByUid",
			Handler:    _Yak_PopExecBatchYakScriptUnfinishedTaskByUid_Handler,
		},
		{
			MethodName: "QueryYakScript",
			Handler:    _Yak_QueryYakScript_Handler,
		},
		{
			MethodName: "SaveYakScript",
			Handler:    _Yak_SaveYakScript_Handler,
		},
		{
			MethodName: "DeleteYakScript",
			Handler:    _Yak_DeleteYakScript_Handler,
		},
		{
			MethodName: "GetYakScriptById",
			Handler:    _Yak_GetYakScriptById_Handler,
		},
		{
			MethodName: "GetYakScriptByName",
			Handler:    _Yak_GetYakScriptByName_Handler,
		},
		{
			MethodName: "GetYakScriptByOnlineID",
			Handler:    _Yak_GetYakScriptByOnlineID_Handler,
		},
		{
			MethodName: "IgnoreYakScript",
			Handler:    _Yak_IgnoreYakScript_Handler,
		},
		{
			MethodName: "UnIgnoreYakScript",
			Handler:    _Yak_UnIgnoreYakScript_Handler,
		},
		{
			MethodName: "ExportYakScript",
			Handler:    _Yak_ExportYakScript_Handler,
		},
		{
			MethodName: "GetYakScriptTags",
			Handler:    _Yak_GetYakScriptTags_Handler,
		},
		{
			MethodName: "QueryYakScriptLocalAndUser",
			Handler:    _Yak_QueryYakScriptLocalAndUser_Handler,
		},
		{
			MethodName: "QueryYakScriptByOnlineGroup",
			Handler:    _Yak_QueryYakScriptByOnlineGroup_Handler,
		},
		{
			MethodName: "QueryYakScriptLocalAll",
			Handler:    _Yak_QueryYakScriptLocalAll_Handler,
		},
		{
			MethodName: "QueryYakScriptByNames",
			Handler:    _Yak_QueryYakScriptByNames_Handler,
		},
		{
			MethodName: "QueryYakScriptByIsCore",
			Handler:    _Yak_QueryYakScriptByIsCore_Handler,
		},
		{
			MethodName: "QueryYakScriptRiskDetailByCWE",
			Handler:    _Yak_QueryYakScriptRiskDetailByCWE_Handler,
		},
		{
			MethodName: "YakScriptRiskTypeList",
			Handler:    _Yak_YakScriptRiskTypeList_Handler,
		},
		{
			MethodName: "SaveNewYakScript",
			Handler:    _Yak_SaveNewYakScript_Handler,
		},
		{
			MethodName: "ExportLocalYakScript",
			Handler:    _Yak_ExportLocalYakScript_Handler,
		},
		{
			MethodName: "SetYakScriptSkipUpdate",
			Handler:    _Yak_SetYakScriptSkipUpdate_Handler,
		},
		{
			MethodName: "QueryYakScriptSkipUpdate",
			Handler:    _Yak_QueryYakScriptSkipUpdate_Handler,
		},
		{
			MethodName: "QueryYakScriptGroup",
			Handler:    _Yak_QueryYakScriptGroup_Handler,
		},
		{
			MethodName: "SaveYakScriptGroup",
			Handler:    _Yak_SaveYakScriptGroup_Handler,
		},
		{
			MethodName: "RenameYakScriptGroup",
			Handler:    _Yak_RenameYakScriptGroup_Handler,
		},
		{
			MethodName: "DeleteYakScriptGroup",
			Handler:    _Yak_DeleteYakScriptGroup_Handler,
		},
		{
			MethodName: "GetYakScriptGroup",
			Handler:    _Yak_GetYakScriptGroup_Handler,
		},
		{
			MethodName: "ResetYakScriptGroup",
			Handler:    _Yak_ResetYakScriptGroup_Handler,
		},
		{
			MethodName: "SetGroup",
			Handler:    _Yak_SetGroup_Handler,
		},
		{
			MethodName: "GetHTTPFlowByHash",
			Handler:    _Yak_GetHTTPFlowByHash_Handler,
		},
		{
			MethodName: "GetHTTPFlowById",
			Handler:    _Yak_GetHTTPFlowById_Handler,
		},
		{
			MethodName: "GetHTTPFlowByIds",
			Handler:    _Yak_GetHTTPFlowByIds_Handler,
		},
		{
			MethodName: "QueryHTTPFlows",
			Handler:    _Yak_QueryHTTPFlows_Handler,
		},
		{
			MethodName: "DeleteHTTPFlows",
			Handler:    _Yak_DeleteHTTPFlows_Handler,
		},
		{
			MethodName: "SetTagForHTTPFlow",
			Handler:    _Yak_SetTagForHTTPFlow_Handler,
		},
		{
			MethodName: "QueryHTTPFlowsIds",
			Handler:    _Yak_QueryHTTPFlowsIds_Handler,
		},
		{
			MethodName: "HTTPFlowsFieldGroup",
			Handler:    _Yak_HTTPFlowsFieldGroup_Handler,
		},
		{
			MethodName: "HTTPFlowsShare",
			Handler:    _Yak_HTTPFlowsShare_Handler,
		},
		{
			MethodName: "HTTPFlowsExtract",
			Handler:    _Yak_HTTPFlowsExtract_Handler,
		},
		{
			MethodName: "GetHTTPFlowBare",
			Handler:    _Yak_GetHTTPFlowBare_Handler,
		},
		{
			MethodName: "ExportHTTPFlows",
			Handler:    _Yak_ExportHTTPFlows_Handler,
		},
		{
			MethodName: "HTTPFlowsToOnline",
			Handler:    _Yak_HTTPFlowsToOnline_Handler,
		},
		{
			MethodName: "QueryHTTPFlowsProcessNames",
			Handler:    _Yak_QueryHTTPFlowsProcessNames_Handler,
		},
		{
			MethodName: "ExtractUrl",
			Handler:    _Yak_ExtractUrl_Handler,
		},
		{
			MethodName: "GetHistoryHTTPFuzzerTask",
			Handler:    _Yak_GetHistoryHTTPFuzzerTask_Handler,
		},
		{
			MethodName: "QueryHistoryHTTPFuzzerTask",
			Handler:    _Yak_QueryHistoryHTTPFuzzerTask_Handler,
		},
		{
			MethodName: "QueryHistoryHTTPFuzzerTaskEx",
			Handler:    _Yak_QueryHistoryHTTPFuzzerTaskEx_Handler,
		},
		{
			MethodName: "DeleteHistoryHTTPFuzzerTask",
			Handler:    _Yak_DeleteHistoryHTTPFuzzerTask_Handler,
		},
		{
			MethodName: "PreloadHTTPFuzzerParams",
			Handler:    _Yak_PreloadHTTPFuzzerParams_Handler,
		},
		{
			MethodName: "RenderVariables",
			Handler:    _Yak_RenderVariables_Handler,
		},
		{
			MethodName: "MatchHTTPResponse",
			Handler:    _Yak_MatchHTTPResponse_Handler,
		},
		{
			MethodName: "ExtractHTTPResponse",
			Handler:    _Yak_ExtractHTTPResponse_Handler,
		},
		{
			MethodName: "RedirectRequest",
			Handler:    _Yak_RedirectRequest_Handler,
		},
		{
			MethodName: "HTTPRequestMutate",
			Handler:    _Yak_HTTPRequestMutate_Handler,
		},
		{
			MethodName: "HTTPResponseMutate",
			Handler:    _Yak_HTTPResponseMutate_Handler,
		},
		{
			MethodName: "FixUploadPacket",
			Handler:    _Yak_FixUploadPacket_Handler,
		},
		{
			MethodName: "IsMultipartFormDataRequest",
			Handler:    _Yak_IsMultipartFormDataRequest_Handler,
		},
		{
			MethodName: "GenerateExtractRule",
			Handler:    _Yak_GenerateExtractRule_Handler,
		},
		{
			MethodName: "ImportHTTPFuzzerTaskFromYaml",
			Handler:    _Yak_ImportHTTPFuzzerTaskFromYaml_Handler,
		},
		{
			MethodName: "ExportHTTPFuzzerTaskToYaml",
			Handler:    _Yak_ExportHTTPFuzzerTaskToYaml_Handler,
		},
		{
			MethodName: "RenderHTTPFuzzerPacket",
			Handler:    _Yak_RenderHTTPFuzzerPacket_Handler,
		},
		{
			MethodName: "SaveFuzzerLabel",
			Handler:    _Yak_SaveFuzzerLabel_Handler,
		},
		{
			MethodName: "QueryFuzzerLabel",
			Handler:    _Yak_QueryFuzzerLabel_Handler,
		},
		{
			MethodName: "DeleteFuzzerLabel",
			Handler:    _Yak_DeleteFuzzerLabel_Handler,
		},
		{
			MethodName: "SaveFuzzerConfig",
			Handler:    _Yak_SaveFuzzerConfig_Handler,
		},
		{
			MethodName: "QueryFuzzerConfig",
			Handler:    _Yak_QueryFuzzerConfig_Handler,
		},
		{
			MethodName: "DeleteFuzzerConfig",
			Handler:    _Yak_DeleteFuzzerConfig_Handler,
		},
		{
			MethodName: "QueryHTTPFuzzerResponseByTaskId",
			Handler:    _Yak_QueryHTTPFuzzerResponseByTaskId_Handler,
		},
		{
			MethodName: "QueryWebsocketFlowByHTTPFlowWebsocketHash",
			Handler:    _Yak_QueryWebsocketFlowByHTTPFlowWebsocketHash_Handler,
		},
		{
			MethodName: "DeleteWebsocketFlowByHTTPFlowWebsocketHash",
			Handler:    _Yak_DeleteWebsocketFlowByHTTPFlowWebsocketHash_Handler,
		},
		{
			MethodName: "DeleteWebsocketFlowAll",
			Handler:    _Yak_DeleteWebsocketFlowAll_Handler,
		},
		{
			MethodName: "ConvertFuzzerResponseToHTTPFlow",
			Handler:    _Yak_ConvertFuzzerResponseToHTTPFlow_Handler,
		},
		{
			MethodName: "StringFuzzer",
			Handler:    _Yak_StringFuzzer_Handler,
		},
		{
			MethodName: "HTTPRequestAnalyzer",
			Handler:    _Yak_HTTPRequestAnalyzer_Handler,
		},
		{
			MethodName: "Codec",
			Handler:    _Yak_Codec_Handler,
		},
		{
			MethodName: "NewCodec",
			Handler:    _Yak_NewCodec_Handler,
		},
		{
			MethodName: "GetAllCodecMethods",
			Handler:    _Yak_GetAllCodecMethods_Handler,
		},
		{
			MethodName: "SaveCodecFlow",
			Handler:    _Yak_SaveCodecFlow_Handler,
		},
		{
			MethodName: "DeleteCodecFlow",
			Handler:    _Yak_DeleteCodecFlow_Handler,
		},
		{
			MethodName: "GetAllCodecFlow",
			Handler:    _Yak_GetAllCodecFlow_Handler,
		},
		{
			MethodName: "PacketPrettifyHelper",
			Handler:    _Yak_PacketPrettifyHelper_Handler,
		},
		{
			MethodName: "QueryPayload",
			Handler:    _Yak_QueryPayload_Handler,
		},
		{
			MethodName: "QueryPayloadFromFile",
			Handler:    _Yak_QueryPayloadFromFile_Handler,
		},
		{
			MethodName: "DeletePayloadByFolder",
			Handler:    _Yak_DeletePayloadByFolder_Handler,
		},
		{
			MethodName: "DeletePayloadByGroup",
			Handler:    _Yak_DeletePayloadByGroup_Handler,
		},
		{
			MethodName: "DeletePayload",
			Handler:    _Yak_DeletePayload_Handler,
		},
		{
			MethodName: "SavePayload",
			Handler:    _Yak_SavePayload_Handler,
		},
		{
			MethodName: "RenamePayloadFolder",
			Handler:    _Yak_RenamePayloadFolder_Handler,
		},
		{
			MethodName: "RenamePayloadGroup",
			Handler:    _Yak_RenamePayloadGroup_Handler,
		},
		{
			MethodName: "UpdatePayload",
			Handler:    _Yak_UpdatePayload_Handler,
		},
		{
			MethodName: "UpdatePayloadToFile",
			Handler:    _Yak_UpdatePayloadToFile_Handler,
		},
		{
			MethodName: "BackUpOrCopyPayloads",
			Handler:    _Yak_BackUpOrCopyPayloads_Handler,
		},
		{
			MethodName: "GetAllPayloadGroup",
			Handler:    _Yak_GetAllPayloadGroup_Handler,
		},
		{
			MethodName: "UpdateAllPayloadGroup",
			Handler:    _Yak_UpdateAllPayloadGroup_Handler,
		},
		{
			MethodName: "GetAllPayload",
			Handler:    _Yak_GetAllPayload_Handler,
		},
		{
			MethodName: "CreatePayloadFolder",
			Handler:    _Yak_CreatePayloadFolder_Handler,
		},
		{
			MethodName: "GetYakitCompletionRaw",
			Handler:    _Yak_GetYakitCompletionRaw_Handler,
		},
		{
			MethodName: "GetYakVMBuildInMethodCompletion",
			Handler:    _Yak_GetYakVMBuildInMethodCompletion_Handler,
		},
		{
			MethodName: "StaticAnalyzeError",
			Handler:    _Yak_StaticAnalyzeError_Handler,
		},
		{
			MethodName: "YaklangCompileAndFormat",
			Handler:    _Yak_YaklangCompileAndFormat_Handler,
		},
		{
			MethodName: "YaklangLanguageSuggestion",
			Handler:    _Yak_YaklangLanguageSuggestion_Handler,
		},
		{
			MethodName: "YaklangLanguageFind",
			Handler:    _Yak_YaklangLanguageFind_Handler,
		},
		{
			MethodName: "FuzzTagSuggestion",
			Handler:    _Yak_FuzzTagSuggestion_Handler,
		},
		{
			MethodName: "YaklangInspectInformation",
			Handler:    _Yak_YaklangInspectInformation_Handler,
		},
		{
			MethodName: "YaklangGetCliCodeFromDatabase",
			Handler:    _Yak_YaklangGetCliCodeFromDatabase_Handler,
		},
		{
			MethodName: "ViewPortScanCode",
			Handler:    _Yak_ViewPortScanCode_Handler,
		},
		{
			MethodName: "SaveCancelSimpleDetect",
			Handler:    _Yak_SaveCancelSimpleDetect_Handler,
		},
		{
			MethodName: "QuerySimpleDetectUnfinishedTask",
			Handler:    _Yak_QuerySimpleDetectUnfinishedTask_Handler,
		},
		{
			MethodName: "GetSimpleDetectRecordRequestById",
			Handler:    _Yak_GetSimpleDetectRecordRequestById_Handler,
		},
		{
			MethodName: "DeleteSimpleDetectUnfinishedTask",
			Handler:    _Yak_DeleteSimpleDetectUnfinishedTask_Handler,
		},
		{
			MethodName: "GetSimpleDetectUnfinishedTask",
			Handler:    _Yak_GetSimpleDetectUnfinishedTask_Handler,
		},
		{
			MethodName: "GetSimpleDetectUnfinishedTaskByUid",
			Handler:    _Yak_GetSimpleDetectUnfinishedTaskByUid_Handler,
		},
		{
			MethodName: "PopSimpleDetectUnfinishedTaskByUid",
			Handler:    _Yak_PopSimpleDetectUnfinishedTaskByUid_Handler,
		},
		{
			MethodName: "QueryPorts",
			Handler:    _Yak_QueryPorts_Handler,
		},
		{
			MethodName: "DeletePorts",
			Handler:    _Yak_DeletePorts_Handler,
		},
		{
			MethodName: "QueryHosts",
			Handler:    _Yak_QueryHosts_Handler,
		},
		{
			MethodName: "DeleteHosts",
			Handler:    _Yak_DeleteHosts_Handler,
		},
		{
			MethodName: "QueryDomains",
			Handler:    _Yak_QueryDomains_Handler,
		},
		{
			MethodName: "DeleteDomains",
			Handler:    _Yak_DeleteDomains_Handler,
		},
		{
			MethodName: "QueryPortsGroup",
			Handler:    _Yak_QueryPortsGroup_Handler,
		},
		{
			MethodName: "UpdateFromYakitResource",
			Handler:    _Yak_UpdateFromYakitResource_Handler,
		},
		{
			MethodName: "UpdateFromGithub",
			Handler:    _Yak_UpdateFromGithub_Handler,
		},
		{
			MethodName: "AddToMenu",
			Handler:    _Yak_AddToMenu_Handler,
		},
		{
			MethodName: "RemoveFromMenu",
			Handler:    _Yak_RemoveFromMenu_Handler,
		},
		{
			MethodName: "YakScriptIsInMenu",
			Handler:    _Yak_YakScriptIsInMenu_Handler,
		},
		{
			MethodName: "GetAllMenuItem",
			Handler:    _Yak_GetAllMenuItem_Handler,
		},
		{
			MethodName: "DeleteAllMenuItem",
			Handler:    _Yak_DeleteAllMenuItem_Handler,
		},
		{
			MethodName: "ImportMenuItem",
			Handler:    _Yak_ImportMenuItem_Handler,
		},
		{
			MethodName: "ExportMenuItem",
			Handler:    _Yak_ExportMenuItem_Handler,
		},
		{
			MethodName: "GetMenuItemById",
			Handler:    _Yak_GetMenuItemById_Handler,
		},
		{
			MethodName: "QueryGroupsByYakScriptId",
			Handler:    _Yak_QueryGroupsByYakScriptId_Handler,
		},
		{
			MethodName: "AddMenus",
			Handler:    _Yak_AddMenus_Handler,
		},
		{
			MethodName: "QueryAllMenuItem",
			Handler:    _Yak_QueryAllMenuItem_Handler,
		},
		{
			MethodName: "DeleteAllMenu",
			Handler:    _Yak_DeleteAllMenu_Handler,
		},
		{
			MethodName: "AddToNavigation",
			Handler:    _Yak_AddToNavigation_Handler,
		},
		{
			MethodName: "GetAllNavigationItem",
			Handler:    _Yak_GetAllNavigationItem_Handler,
		},
		{
			MethodName: "DeleteAllNavigation",
			Handler:    _Yak_DeleteAllNavigation_Handler,
		},
		{
			MethodName: "AddOneNavigation",
			Handler:    _Yak_AddOneNavigation_Handler,
		},
		{
			MethodName: "QueryNavigationGroups",
			Handler:    _Yak_QueryNavigationGroups_Handler,
		},
		{
			MethodName: "SaveMarkdownDocument",
			Handler:    _Yak_SaveMarkdownDocument_Handler,
		},
		{
			MethodName: "GetMarkdownDocument",
			Handler:    _Yak_GetMarkdownDocument_Handler,
		},
		{
			MethodName: "DeleteMarkdownDocument",
			Handler:    _Yak_DeleteMarkdownDocument_Handler,
		},
		{
			MethodName: "StartBasicCrawler",
			Handler:    _Yak_StartBasicCrawler_Handler,
		},
		{
			MethodName: "ViewBasicCrawlerCode",
			Handler:    _Yak_ViewBasicCrawlerCode_Handler,
		},
		{
			MethodName: "GenerateWebsiteTree",
			Handler:    _Yak_GenerateWebsiteTree_Handler,
		},
		{
			MethodName: "QueryYakScriptExecResult",
			Handler:    _Yak_QueryYakScriptExecResult_Handler,
		},
		{
			MethodName: "QueryYakScriptNameInExecResult",
			Handler:    _Yak_QueryYakScriptNameInExecResult_Handler,
		},
		{
			MethodName: "DeleteYakScriptExecResult",
			Handler:    _Yak_DeleteYakScriptExecResult_Handler,
		},
		{
			MethodName: "DeleteYakScriptExec",
			Handler:    _Yak_DeleteYakScriptExec_Handler,
		},
		{
			MethodName: "GetAvailableBruteTypes",
			Handler:    _Yak_GetAvailableBruteTypes_Handler,
		},
		{
			MethodName: "GetTunnelServerExternalIP",
			Handler:    _Yak_GetTunnelServerExternalIP_Handler,
		},
		{
			MethodName: "VerifyTunnelServerDomain",
			Handler:    _Yak_VerifyTunnelServerDomain_Handler,
		},
		{
			MethodName: "ApplyClassToFacades",
			Handler:    _Yak_ApplyClassToFacades_Handler,
		},
		{
			MethodName: "BytesToBase64",
			Handler:    _Yak_BytesToBase64_Handler,
		},
		{
			MethodName: "AvailableLocalAddr",
			Handler:    _Yak_AvailableLocalAddr_Handler,
		},
		{
			MethodName: "GetGlobalReverseServer",
			Handler:    _Yak_GetGlobalReverseServer_Handler,
		},
		{
			MethodName: "QueryRisks",
			Handler:    _Yak_QueryRisks_Handler,
		},
		{
			MethodName: "QueryRisk",
			Handler:    _Yak_QueryRisk_Handler,
		},
		{
			MethodName: "DeleteRisk",
			Handler:    _Yak_DeleteRisk_Handler,
		},
		{
			MethodName: "QueryAvailableRiskType",
			Handler:    _Yak_QueryAvailableRiskType_Handler,
		},
		{
			MethodName: "QueryAvailableRiskLevel",
			Handler:    _Yak_QueryAvailableRiskLevel_Handler,
		},
		{
			MethodName: "QueryRiskTableStats",
			Handler:    _Yak_QueryRiskTableStats_Handler,
		},
		{
			MethodName: "ResetRiskTableStats",
			Handler:    _Yak_ResetRiskTableStats_Handler,
		},
		{
			MethodName: "QueryAvailableTarget",
			Handler:    _Yak_QueryAvailableTarget_Handler,
		},
		{
			MethodName: "QueryNewRisk",
			Handler:    _Yak_QueryNewRisk_Handler,
		},
		{
			MethodName: "NewRiskRead",
			Handler:    _Yak_NewRiskRead_Handler,
		},
		{
			MethodName: "UploadRiskToOnline",
			Handler:    _Yak_UploadRiskToOnline_Handler,
		},
		{
			MethodName: "SetTagForRisk",
			Handler:    _Yak_SetTagForRisk_Handler,
		},
		{
			MethodName: "QueryRiskTags",
			Handler:    _Yak_QueryRiskTags_Handler,
		},
		{
			MethodName: "RiskFieldGroup",
			Handler:    _Yak_RiskFieldGroup_Handler,
		},
		{
			MethodName: "RiskFeedbackToOnline",
			Handler:    _Yak_RiskFeedbackToOnline_Handler,
		},
		{
			MethodName: "QueryReports",
			Handler:    _Yak_QueryReports_Handler,
		},
		{
			MethodName: "QueryReport",
			Handler:    _Yak_QueryReport_Handler,
		},
		{
			MethodName: "DeleteReport",
			Handler:    _Yak_DeleteReport_Handler,
		},
		{
			MethodName: "QueryAvailableReportFrom",
			Handler:    _Yak_QueryAvailableReportFrom_Handler,
		},
		{
			MethodName: "DownloadReport",
			Handler:    _Yak_DownloadReport_Handler,
		},
		{
			MethodName: "GetAllYsoGadgetOptions",
			Handler:    _Yak_GetAllYsoGadgetOptions_Handler,
		},
		{
			MethodName: "GetAllYsoClassOptions",
			Handler:    _Yak_GetAllYsoClassOptions_Handler,
		},
		{
			MethodName: "GetAllYsoClassGeneraterOptions",
			Handler:    _Yak_GetAllYsoClassGeneraterOptions_Handler,
		},
		{
			MethodName: "GenerateYsoCode",
			Handler:    _Yak_GenerateYsoCode_Handler,
		},
		{
			MethodName: "GenerateYsoBytes",
			Handler:    _Yak_GenerateYsoBytes_Handler,
		},
		{
			MethodName: "YsoDump",
			Handler:    _Yak_YsoDump_Handler,
		},
		{
			MethodName: "CreateWebShell",
			Handler:    _Yak_CreateWebShell_Handler,
		},
		{
			MethodName: "DeleteWebShell",
			Handler:    _Yak_DeleteWebShell_Handler,
		},
		{
			MethodName: "UpdateWebShell",
			Handler:    _Yak_UpdateWebShell_Handler,
		},
		{
			MethodName: "QueryWebShells",
			Handler:    _Yak_QueryWebShells_Handler,
		},
		{
			MethodName: "Ping",
			Handler:    _Yak_Ping_Handler,
		},
		{
			MethodName: "GetBasicInfo",
			Handler:    _Yak_GetBasicInfo_Handler,
		},
		{
			MethodName: "GenerateWebShell",
			Handler:    _Yak_GenerateWebShell_Handler,
		},
		{
			MethodName: "SetYakBridgeLogServer",
			Handler:    _Yak_SetYakBridgeLogServer_Handler,
		},
		{
			MethodName: "GetCurrentYakBridgeLogServer",
			Handler:    _Yak_GetCurrentYakBridgeLogServer_Handler,
		},
		{
			MethodName: "RequireDNSLogDomain",
			Handler:    _Yak_RequireDNSLogDomain_Handler,
		},
		{
			MethodName: "RequireDNSLogDomainByScript",
			Handler:    _Yak_RequireDNSLogDomainByScript_Handler,
		},
		{
			MethodName: "QueryDNSLogByToken",
			Handler:    _Yak_QueryDNSLogByToken_Handler,
		},
		{
			MethodName: "QueryDNSLogTokenByScript",
			Handler:    _Yak_QueryDNSLogTokenByScript_Handler,
		},
		{
			MethodName: "RequireICMPRandomLength",
			Handler:    _Yak_RequireICMPRandomLength_Handler,
		},
		{
			MethodName: "QueryICMPTrigger",
			Handler:    _Yak_QueryICMPTrigger_Handler,
		},
		{
			MethodName: "RequireRandomPortToken",
			Handler:    _Yak_RequireRandomPortToken_Handler,
		},
		{
			MethodName: "QueryRandomPortTrigger",
			Handler:    _Yak_QueryRandomPortTrigger_Handler,
		},
		{
			MethodName: "QuerySupportedDnsLogPlatforms",
			Handler:    _Yak_QuerySupportedDnsLogPlatforms_Handler,
		},
		{
			MethodName: "GetAvailableYakScriptTags",
			Handler:    _Yak_GetAvailableYakScriptTags_Handler,
		},
		{
			MethodName: "ForceUpdateAvailableYakScriptTags",
			Handler:    _Yak_ForceUpdateAvailableYakScriptTags_Handler,
		},
		{
			MethodName: "GenerateYakCodeByPacket",
			Handler:    _Yak_GenerateYakCodeByPacket_Handler,
		},
		{
			MethodName: "GenerateCSRFPocByPacket",
			Handler:    _Yak_GenerateCSRFPocByPacket_Handler,
		},
		{
			MethodName: "ExportMITMReplacerRules",
			Handler:    _Yak_ExportMITMReplacerRules_Handler,
		},
		{
			MethodName: "ImportMITMReplacerRules",
			Handler:    _Yak_ImportMITMReplacerRules_Handler,
		},
		{
			MethodName: "GetCurrentRules",
			Handler:    _Yak_GetCurrentRules_Handler,
		},
		{
			MethodName: "SetCurrentRules",
			Handler:    _Yak_SetCurrentRules_Handler,
		},
		{
			MethodName: "GenerateURL",
			Handler:    _Yak_GenerateURL_Handler,
		},
		{
			MethodName: "AutoDecode",
			Handler:    _Yak_AutoDecode_Handler,
		},
		{
			MethodName: "GetSystemProxy",
			Handler:    _Yak_GetSystemProxy_Handler,
		},
		{
			MethodName: "SetSystemProxy",
			Handler:    _Yak_SetSystemProxy_Handler,
		},
		{
			MethodName: "GetKey",
			Handler:    _Yak_GetKey_Handler,
		},
		{
			MethodName: "SetKey",
			Handler:    _Yak_SetKey_Handler,
		},
		{
			MethodName: "DelKey",
			Handler:    _Yak_DelKey_Handler,
		},
		{
			MethodName: "GetAllProcessEnvKey",
			Handler:    _Yak_GetAllProcessEnvKey_Handler,
		},
		{
			MethodName: "SetProcessEnvKey",
			Handler:    _Yak_SetProcessEnvKey_Handler,
		},
		{
			MethodName: "GetProjectKey",
			Handler:    _Yak_GetProjectKey_Handler,
		},
		{
			MethodName: "SetProjectKey",
			Handler:    _Yak_SetProjectKey_Handler,
		},
		{
			MethodName: "GetOnlineProfile",
			Handler:    _Yak_GetOnlineProfile_Handler,
		},
		{
			MethodName: "SetOnlineProfile",
			Handler:    _Yak_SetOnlineProfile_Handler,
		},
		{
			MethodName: "DownloadOnlinePluginById",
			Handler:    _Yak_DownloadOnlinePluginById_Handler,
		},
		{
			MethodName: "DownloadOnlinePluginByIds",
			Handler:    _Yak_DownloadOnlinePluginByIds_Handler,
		},
		{
			MethodName: "DeletePluginByUserID",
			Handler:    _Yak_DeletePluginByUserID_Handler,
		},
		{
			MethodName: "DeleteAllLocalPlugins",
			Handler:    _Yak_DeleteAllLocalPlugins_Handler,
		},
		{
			MethodName: "GetYakScriptTagsAndType",
			Handler:    _Yak_GetYakScriptTagsAndType_Handler,
		},
		{
			MethodName: "DeleteLocalPluginsByWhere",
			Handler:    _Yak_DeleteLocalPluginsByWhere_Handler,
		},
		{
			MethodName: "DownloadOnlinePluginByScriptNames",
			Handler:    _Yak_DownloadOnlinePluginByScriptNames_Handler,
		},
		{
			MethodName: "DownloadOnlinePluginBatch",
			Handler:    _Yak_DownloadOnlinePluginBatch_Handler,
		},
		{
			MethodName: "DownloadOnlinePluginByPluginName",
			Handler:    _Yak_DownloadOnlinePluginByPluginName_Handler,
		},
		{
			MethodName: "DownloadOnlinePluginByUUID",
			Handler:    _Yak_DownloadOnlinePluginByUUID_Handler,
		},
		{
			MethodName: "QueryOnlinePlugins",
			Handler:    _Yak_QueryOnlinePlugins_Handler,
		},
		{
			MethodName: "GetEngineDefaultProxy",
			Handler:    _Yak_GetEngineDefaultProxy_Handler,
		},
		{
			MethodName: "SetEngineDefaultProxy",
			Handler:    _Yak_SetEngineDefaultProxy_Handler,
		},
		{
			MethodName: "GetMachineID",
			Handler:    _Yak_GetMachineID_Handler,
		},
		{
			MethodName: "GetLicense",
			Handler:    _Yak_GetLicense_Handler,
		},
		{
			MethodName: "CheckLicense",
			Handler:    _Yak_CheckLicense_Handler,
		},
		{
			MethodName: "GetRequestBodyByHTTPFlowID",
			Handler:    _Yak_GetRequestBodyByHTTPFlowID_Handler,
		},
		{
			MethodName: "GetResponseBodyByHTTPFlowID",
			Handler:    _Yak_GetResponseBodyByHTTPFlowID_Handler,
		},
		{
			MethodName: "GetHTTPPacketBody",
			Handler:    _Yak_GetHTTPPacketBody_Handler,
		},
		{
			MethodName: "RegisterFacadesHTTP",
			Handler:    _Yak_RegisterFacadesHTTP_Handler,
		},
		{
			MethodName: "ResetAndInvalidUserData",
			Handler:    _Yak_ResetAndInvalidUserData_Handler,
		},
		{
			MethodName: "IsPrivilegedForNetRaw",
			Handler:    _Yak_IsPrivilegedForNetRaw_Handler,
		},
		{
			MethodName: "PromotePermissionForUserPcap",
			Handler:    _Yak_PromotePermissionForUserPcap_Handler,
		},
		{
			MethodName: "SetCurrentProject",
			Handler:    _Yak_SetCurrentProject_Handler,
		},
		{
			MethodName: "GetCurrentProject",
			Handler:    _Yak_GetCurrentProject_Handler,
		},
		{
			MethodName: "GetCurrentProjectEx",
			Handler:    _Yak_GetCurrentProjectEx_Handler,
		},
		{
			MethodName: "GetProjects",
			Handler:    _Yak_GetProjects_Handler,
		},
		{
			MethodName: "NewProject",
			Handler:    _Yak_NewProject_Handler,
		},
		{
			MethodName: "UpdateProject",
			Handler:    _Yak_UpdateProject_Handler,
		},
		{
			MethodName: "IsProjectNameValid",
			Handler:    _Yak_IsProjectNameValid_Handler,
		},
		{
			MethodName: "RemoveProject",
			Handler:    _Yak_RemoveProject_Handler,
		},
		{
			MethodName: "DeleteProject",
			Handler:    _Yak_DeleteProject_Handler,
		},
		{
			MethodName: "GetDefaultProject",
			Handler:    _Yak_GetDefaultProject_Handler,
		},
		{
			MethodName: "GetDefaultProjectEx",
			Handler:    _Yak_GetDefaultProjectEx_Handler,
		},
		{
			MethodName: "QueryProjectDetail",
			Handler:    _Yak_QueryProjectDetail_Handler,
		},
		{
			MethodName: "GetTemporaryProject",
			Handler:    _Yak_GetTemporaryProject_Handler,
		},
		{
			MethodName: "GetTemporaryProjectEx",
			Handler:    _Yak_GetTemporaryProjectEx_Handler,
		},
		{
			MethodName: "MigrateLegacyDatabase",
			Handler:    _Yak_MigrateLegacyDatabase_Handler,
		},
		{
			MethodName: "QueryMITMRuleExtractedData",
			Handler:    _Yak_QueryMITMRuleExtractedData_Handler,
		},
		{
			MethodName: "ImportChaosMakerRules",
			Handler:    _Yak_ImportChaosMakerRules_Handler,
		},
		{
			MethodName: "QueryChaosMakerRule",
			Handler:    _Yak_QueryChaosMakerRule_Handler,
		},
		{
			MethodName: "DeleteChaosMakerRuleByID",
			Handler:    _Yak_DeleteChaosMakerRuleByID_Handler,
		},
		{
			MethodName: "IsRemoteAddrAvailable",
			Handler:    _Yak_IsRemoteAddrAvailable_Handler,
		},
		{
			MethodName: "ConnectVulinboxAgent",
			Handler:    _Yak_ConnectVulinboxAgent_Handler,
		},
		{
			MethodName: "GetRegisteredVulinboxAgent",
			Handler:    _Yak_GetRegisteredVulinboxAgent_Handler,
		},
		{
			MethodName: "DisconnectVulinboxAgent",
			Handler:    _Yak_DisconnectVulinboxAgent_Handler,
		},
		{
			MethodName: "IsCVEDatabaseReady",
			Handler:    _Yak_IsCVEDatabaseReady_Handler,
		},
		{
			MethodName: "QueryCVE",
			Handler:    _Yak_QueryCVE_Handler,
		},
		{
			MethodName: "GetCVE",
			Handler:    _Yak_GetCVE_Handler,
		},
		{
			MethodName: "SaveTextToTemporalFile",
			Handler:    _Yak_SaveTextToTemporalFile_Handler,
		},
		{
			MethodName: "IsScrecorderReady",
			Handler:    _Yak_IsScrecorderReady_Handler,
		},
		{
			MethodName: "QueryScreenRecorders",
			Handler:    _Yak_QueryScreenRecorders_Handler,
		},
		{
			MethodName: "DeleteScreenRecorders",
			Handler:    _Yak_DeleteScreenRecorders_Handler,
		},
		{
			MethodName: "UploadScreenRecorders",
			Handler:    _Yak_UploadScreenRecorders_Handler,
		},
		{
			MethodName: "GetOneScreenRecorders",
			Handler:    _Yak_GetOneScreenRecorders_Handler,
		},
		{
			MethodName: "UpdateScreenRecorders",
			Handler:    _Yak_UpdateScreenRecorders_Handler,
		},
		{
			MethodName: "IsVulinboxReady",
			Handler:    _Yak_IsVulinboxReady_Handler,
		},
		{
			MethodName: "HTTPRequestBuilder",
			Handler:    _Yak_HTTPRequestBuilder_Handler,
		},
		{
			MethodName: "SmokingEvaluatePlugin",
			Handler:    _Yak_SmokingEvaluatePlugin_Handler,
		},
		{
			MethodName: "GetSystemDefaultDnsServers",
			Handler:    _Yak_GetSystemDefaultDnsServers_Handler,
		},
		{
			MethodName: "GetGlobalNetworkConfig",
			Handler:    _Yak_GetGlobalNetworkConfig_Handler,
		},
		{
			MethodName: "SetGlobalNetworkConfig",
			Handler:    _Yak_SetGlobalNetworkConfig_Handler,
		},
		{
			MethodName: "ResetGlobalNetworkConfig",
			Handler:    _Yak_ResetGlobalNetworkConfig_Handler,
		},
		{
			MethodName: "ValidP12PassWord",
			Handler:    _Yak_ValidP12PassWord_Handler,
		},
		{
			MethodName: "RequestYakURL",
			Handler:    _Yak_RequestYakURL_Handler,
		},
		{
			MethodName: "GetPcapMetadata",
			Handler:    _Yak_GetPcapMetadata_Handler,
		},
		{
			MethodName: "QueryTrafficSession",
			Handler:    _Yak_QueryTrafficSession_Handler,
		},
		{
			MethodName: "QueryTrafficPacket",
			Handler:    _Yak_QueryTrafficPacket_Handler,
		},
		{
			MethodName: "QueryTrafficTCPReassembled",
			Handler:    _Yak_QueryTrafficTCPReassembled_Handler,
		},
		{
			MethodName: "ParseTraffic",
			Handler:    _Yak_ParseTraffic_Handler,
		},
		{
			MethodName: "QueryHybridScanTask",
			Handler:    _Yak_QueryHybridScanTask_Handler,
		},
		{
			MethodName: "DeleteHybridScanTask",
			Handler:    _Yak_DeleteHybridScanTask_Handler,
		},
		{
			MethodName: "GetSpaceEngineStatus",
			Handler:    _Yak_GetSpaceEngineStatus_Handler,
		},
		{
			MethodName: "GetSpaceEngineAccountStatus",
			Handler:    _Yak_GetSpaceEngineAccountStatus_Handler,
		},
		{
			MethodName: "GetSpaceEngineAccountStatusV2",
			Handler:    _Yak_GetSpaceEngineAccountStatusV2_Handler,
		},
		{
			MethodName: "EvaluateExpression",
			Handler:    _Yak_EvaluateExpression_Handler,
		},
		{
			MethodName: "EvaluateMultiExpression",
			Handler:    _Yak_EvaluateMultiExpression_Handler,
		},
		{
			MethodName: "GetThirdPartyAppConfigTemplate",
			Handler:    _Yak_GetThirdPartyAppConfigTemplate_Handler,
		},
		{
			MethodName: "CheckHahValidAiConfig",
			Handler:    _Yak_CheckHahValidAiConfig_Handler,
		},
		{
			MethodName: "ListAiModel",
			Handler:    _Yak_ListAiModel_Handler,
		},
		{
			MethodName: "GetFingerprint",
			Handler:    _Yak_GetFingerprint_Handler,
		},
		{
			MethodName: "AddFingerprint",
			Handler:    _Yak_AddFingerprint_Handler,
		},
		{
			MethodName: "ModifyFingerprint",
			Handler:    _Yak_ModifyFingerprint_Handler,
		},
		{
			MethodName: "QueryFingerprint",
			Handler:    _Yak_QueryFingerprint_Handler,
		},
		{
			MethodName: "DeleteFingerprint",
			Handler:    _Yak_DeleteFingerprint_Handler,
		},
		{
			MethodName: "UpdateFingerprint",
			Handler:    _Yak_UpdateFingerprint_Handler,
		},
		{
			MethodName: "CreateFingerprint",
			Handler:    _Yak_CreateFingerprint_Handler,
		},
		{
			MethodName: "RecoverBuiltinFingerprint",
			Handler:    _Yak_RecoverBuiltinFingerprint_Handler,
		},
		{
			MethodName: "CreateFingerprintGroup",
			Handler:    _Yak_CreateFingerprintGroup_Handler,
		},
		{
			MethodName: "GetAllFingerprintGroup",
			Handler:    _Yak_GetAllFingerprintGroup_Handler,
		},
		{
			MethodName: "RenameFingerprintGroup",
			Handler:    _Yak_RenameFingerprintGroup_Handler,
		},
		{
			MethodName: "DeleteFingerprintGroup",
			Handler:    _Yak_DeleteFingerprintGroup_Handler,
		},
		{
			MethodName: "BatchUpdateFingerprintToGroup",
			Handler:    _Yak_BatchUpdateFingerprintToGroup_Handler,
		},
		{
			MethodName: "GetFingerprintGroupSetByFilter",
			Handler:    _Yak_GetFingerprintGroupSetByFilter_Handler,
		},
		{
			MethodName: "GetReverseShellProgramList",
			Handler:    _Yak_GetReverseShellProgramList_Handler,
		},
		{
			MethodName: "GenerateReverseShellCommand",
			Handler:    _Yak_GenerateReverseShellCommand_Handler,
		},
		{
			MethodName: "QuerySyntaxFlowRule",
			Handler:    _Yak_QuerySyntaxFlowRule_Handler,
		},
		{
			MethodName: "CreateSyntaxFlowRule",
			Handler:    _Yak_CreateSyntaxFlowRule_Handler,
		},
		{
			MethodName: "CreateSyntaxFlowRuleEx",
			Handler:    _Yak_CreateSyntaxFlowRuleEx_Handler,
		},
		{
			MethodName: "UpdateSyntaxFlowRule",
			Handler:    _Yak_UpdateSyntaxFlowRule_Handler,
		},
		{
			MethodName: "UpdateSyntaxFlowRuleEx",
			Handler:    _Yak_UpdateSyntaxFlowRuleEx_Handler,
		},
		{
			MethodName: "DeleteSyntaxFlowRule",
			Handler:    _Yak_DeleteSyntaxFlowRule_Handler,
		},
		{
			MethodName: "CheckSyntaxFlowRuleUpdate",
			Handler:    _Yak_CheckSyntaxFlowRuleUpdate_Handler,
		},
		{
			MethodName: "QuerySyntaxFlowRuleGroup",
			Handler:    _Yak_QuerySyntaxFlowRuleGroup_Handler,
		},
		{
			MethodName: "DeleteSyntaxFlowRuleGroup",
			Handler:    _Yak_DeleteSyntaxFlowRuleGroup_Handler,
		},
		{
			MethodName: "CreateSyntaxFlowRuleGroup",
			Handler:    _Yak_CreateSyntaxFlowRuleGroup_Handler,
		},
		{
			MethodName: "UpdateSyntaxFlowRuleGroup",
			Handler:    _Yak_UpdateSyntaxFlowRuleGroup_Handler,
		},
		{
			MethodName: "UpdateSyntaxFlowRuleAndGroup",
			Handler:    _Yak_UpdateSyntaxFlowRuleAndGroup_Handler,
		},
		{
			MethodName: "QuerySyntaxFlowSameGroup",
			Handler:    _Yak_QuerySyntaxFlowSameGroup_Handler,
		},
		{
			MethodName: "QuerySyntaxFlowScanTask",
			Handler:    _Yak_QuerySyntaxFlowScanTask_Handler,
		},
		{
			MethodName: "DeleteSyntaxFlowScanTask",
			Handler:    _Yak_DeleteSyntaxFlowScanTask_Handler,
		},
		{
			MethodName: "QuerySyntaxFlowResult",
			Handler:    _Yak_QuerySyntaxFlowResult_Handler,
		},
		{
			MethodName: "DeleteSyntaxFlowResult",
			Handler:    _Yak_DeleteSyntaxFlowResult_Handler,
		},
		{
			MethodName: "QuerySSAPrograms",
			Handler:    _Yak_QuerySSAPrograms_Handler,
		},
		{
			MethodName: "UpdateSSAProgram",
			Handler:    _Yak_UpdateSSAProgram_Handler,
		},
		{
			MethodName: "DeleteSSAPrograms",
			Handler:    _Yak_DeleteSSAPrograms_Handler,
		},
		{
			MethodName: "QuerySSARisks",
			Handler:    _Yak_QuerySSARisks_Handler,
		},
		{
			MethodName: "QueryNewSSARisks",
			Handler:    _Yak_QueryNewSSARisks_Handler,
		},
		{
			MethodName: "DeleteSSARisks",
			Handler:    _Yak_DeleteSSARisks_Handler,
		},
		{
			MethodName: "UpdateSSARiskTags",
			Handler:    _Yak_UpdateSSARiskTags_Handler,
		},
		{
			MethodName: "GetSSARiskFieldGroup",
			Handler:    _Yak_GetSSARiskFieldGroup_Handler,
		},
		{
			MethodName: "NewSSARiskRead",
			Handler:    _Yak_NewSSARiskRead_Handler,
		},
		{
			MethodName: "SSARiskFeedbackToOnline",
			Handler:    _Yak_SSARiskFeedbackToOnline_Handler,
		},
		{
			MethodName: "GetAllPluginEnv",
			Handler:    _Yak_GetAllPluginEnv_Handler,
		},
		{
			MethodName: "QueryPluginEnv",
			Handler:    _Yak_QueryPluginEnv_Handler,
		},
		{
			MethodName: "CreatePluginEnv",
			Handler:    _Yak_CreatePluginEnv_Handler,
		},
		{
			MethodName: "SetPluginEnv",
			Handler:    _Yak_SetPluginEnv_Handler,
		},
		{
			MethodName: "DeletePluginEnv",
			Handler:    _Yak_DeletePluginEnv_Handler,
		},
		{
			MethodName: "GetAllFuzztagInfo",
			Handler:    _Yak_GetAllFuzztagInfo_Handler,
		},
		{
			MethodName: "GenerateFuzztag",
			Handler:    _Yak_GenerateFuzztag_Handler,
		},
		{
			MethodName: "CreateHotPatchTemplate",
			Handler:    _Yak_CreateHotPatchTemplate_Handler,
		},
		{
			MethodName: "DeleteHotPatchTemplate",
			Handler:    _Yak_DeleteHotPatchTemplate_Handler,
		},
		{
			MethodName: "UpdateHotPatchTemplate",
			Handler:    _Yak_UpdateHotPatchTemplate_Handler,
		},
		{
			MethodName: "QueryHotPatchTemplate",
			Handler:    _Yak_QueryHotPatchTemplate_Handler,
		},
		{
			MethodName: "QueryHotPatchTemplateList",
			Handler:    _Yak_QueryHotPatchTemplateList_Handler,
		},
		{
			MethodName: "GroupTableColumn",
			Handler:    _Yak_GroupTableColumn_Handler,
		},
		{
			MethodName: "UploadHotPatchTemplateToOnline",
			Handler:    _Yak_UploadHotPatchTemplateToOnline_Handler,
		},
		{
			MethodName: "DownloadHotPatchTemplate",
			Handler:    _Yak_DownloadHotPatchTemplate_Handler,
		},
		{
			MethodName: "SetMITMHijackFilter",
			Handler:    _Yak_SetMITMHijackFilter_Handler,
		},
		{
			MethodName: "GetMITMHijackFilter",
			Handler:    _Yak_GetMITMHijackFilter_Handler,
		},
		{
			MethodName: "ResetMITMHijackFilter",
			Handler:    _Yak_ResetMITMHijackFilter_Handler,
		},
		{
			MethodName: "CreateNote",
			Handler:    _Yak_CreateNote_Handler,
		},
		{
			MethodName: "UpdateNote",
			Handler:    _Yak_UpdateNote_Handler,
		},
		{
			MethodName: "DeleteNote",
			Handler:    _Yak_DeleteNote_Handler,
		},
		{
			MethodName: "QueryNote",
			Handler:    _Yak_QueryNote_Handler,
		},
		{
			MethodName: "SearchNoteContent",
			Handler:    _Yak_SearchNoteContent_Handler,
		},
		{
			MethodName: "QueryAITask",
			Handler:    _Yak_QueryAITask_Handler,
		},
		{
			MethodName: "CreateAIForge",
			Handler:    _Yak_CreateAIForge_Handler,
		},
		{
			MethodName: "UpdateAIForge",
			Handler:    _Yak_UpdateAIForge_Handler,
		},
		{
			MethodName: "DeleteAIForge",
			Handler:    _Yak_DeleteAIForge_Handler,
		},
		{
			MethodName: "QueryAIForge",
			Handler:    _Yak_QueryAIForge_Handler,
		},
		{
			MethodName: "GetToolSetList",
			Handler:    _Yak_GetToolSetList_Handler,
		},
		{
			MethodName: "GetAIToolList",
			Handler:    _Yak_GetAIToolList_Handler,
		},
		{
			MethodName: "DeleteAITool",
			Handler:    _Yak_DeleteAITool_Handler,
		},
		{
			MethodName: "SaveAITool",
			Handler:    _Yak_SaveAITool_Handler,
		},
		{
			MethodName: "ToggleAIToolFavorite",
			Handler:    _Yak_ToggleAIToolFavorite_Handler,
		},
		{
			MethodName: "AIToolGenerateMetadata",
			Handler:    _Yak_AIToolGenerateMetadata_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "MITM",
			Handler:       _Yak_MITM_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
		{
			StreamName:    "MITMV2",
			Handler:       _Yak_MITMV2_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
		{
			StreamName:    "OpenPort",
			Handler:       _Yak_OpenPort_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
		{
			StreamName:    "Exec",
			Handler:       _Yak_Exec_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "AutoUpdateYakModule",
			Handler:       _Yak_AutoUpdateYakModule_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "ExecYakScript",
			Handler:       _Yak_ExecYakScript_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "ExecBatchYakScript",
			Handler:       _Yak_ExecBatchYakScript_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "RecoverExecBatchYakScriptUnfinishedTask",
			Handler:       _Yak_RecoverExecBatchYakScriptUnfinishedTask_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "QueryYakScriptByYakScriptName",
			Handler:       _Yak_QueryYakScriptByYakScriptName_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "ExportYakScriptStream",
			Handler:       _Yak_ExportYakScriptStream_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "ImportYakScriptStream",
			Handler:       _Yak_ImportYakScriptStream_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "ExecutePacketYakScript",
			Handler:       _Yak_ExecutePacketYakScript_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "ExecuteBatchPacketYakScript",
			Handler:       _Yak_ExecuteBatchPacketYakScript_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "SaveYakScriptToOnline",
			Handler:       _Yak_SaveYakScriptToOnline_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "ExportLocalYakScriptStream",
			Handler:       _Yak_ExportLocalYakScriptStream_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "ImportYakScript",
			Handler:       _Yak_ImportYakScript_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "GetHTTPFlowBodyById",
			Handler:       _Yak_GetHTTPFlowBodyById_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "AnalyzeHTTPFlow",
			Handler:       _Yak_AnalyzeHTTPFlow_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "HTTPFuzzer",
			Handler:       _Yak_HTTPFuzzer_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "HTTPFuzzerSequence",
			Handler:       _Yak_HTTPFuzzerSequence_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "ExtractData",
			Handler:       _Yak_ExtractData_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
		{
			StreamName:    "CreateWebsocketFuzzer",
			Handler:       _Yak_CreateWebsocketFuzzer_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
		{
			StreamName:    "SavePayloadStream",
			Handler:       _Yak_SavePayloadStream_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "SavePayloadToFileStream",
			Handler:       _Yak_SavePayloadToFileStream_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "SaveLargePayloadToFileStream",
			Handler:       _Yak_SaveLargePayloadToFileStream_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "GetAllPayloadFromFile",
			Handler:       _Yak_GetAllPayloadFromFile_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "ExportAllPayload",
			Handler:       _Yak_ExportAllPayload_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "ExportAllPayloadFromFile",
			Handler:       _Yak_ExportAllPayloadFromFile_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "RemoveDuplicatePayloads",
			Handler:       _Yak_RemoveDuplicatePayloads_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "CoverPayloadGroupToDatabase",
			Handler:       _Yak_CoverPayloadGroupToDatabase_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "ConvertPayloadGroupToDatabase",
			Handler:       _Yak_ConvertPayloadGroupToDatabase_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "MigratePayloads",
			Handler:       _Yak_MigratePayloads_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "YaklangTerminal",
			Handler:       _Yak_YaklangTerminal_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
		{
			StreamName:    "PortScan",
			Handler:       _Yak_PortScan_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "SimpleDetect",
			Handler:       _Yak_SimpleDetect_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "SimpleDetectCreatReport",
			Handler:       _Yak_SimpleDetectCreatReport_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "RecoverSimpleDetectTask",
			Handler:       _Yak_RecoverSimpleDetectTask_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "RecoverSimpleDetectUnfinishedTask",
			Handler:       _Yak_RecoverSimpleDetectUnfinishedTask_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "StartBrute",
			Handler:       _Yak_StartBrute_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "StartFacades",
			Handler:       _Yak_StartFacades_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "StartFacadesWithYsoObject",
			Handler:       _Yak_StartFacadesWithYsoObject_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "ConfigGlobalReverse",
			Handler:       _Yak_ConfigGlobalReverse_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "ExecYakitPluginsByYakScriptFilter",
			Handler:       _Yak_ExecYakitPluginsByYakScriptFilter_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "ExtractDataToFile",
			Handler:       _Yak_ExtractDataToFile_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
		{
			StreamName:    "DownloadOnlinePluginAll",
			Handler:       _Yak_DownloadOnlinePluginAll_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "DownloadOnlinePlugins",
			Handler:       _Yak_DownloadOnlinePlugins_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "ExecPacketScan",
			Handler:       _Yak_ExecPacketScan_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "CreateYaklangShell",
			Handler:       _Yak_CreateYaklangShell_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
		{
			StreamName:    "AttachCombinedOutput",
			Handler:       _Yak_AttachCombinedOutput_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "ExportProject",
			Handler:       _Yak_ExportProject_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "ImportProject",
			Handler:       _Yak_ImportProject_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "ExportMITMRuleExtractedData",
			Handler:       _Yak_ExportMITMRuleExtractedData_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "ExecuteChaosMakerRule",
			Handler:       _Yak_ExecuteChaosMakerRule_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "UpdateCVEDatabase",
			Handler:       _Yak_UpdateCVEDatabase_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "ExportsProfileDatabase",
			Handler:       _Yak_ExportsProfileDatabase_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "ImportsProfileDatabase",
			Handler:       _Yak_ImportsProfileDatabase_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "InstallScrecorder",
			Handler:       _Yak_InstallScrecorder_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "StartScrecorder",
			Handler:       _Yak_StartScrecorder_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "InstallVulinbox",
			Handler:       _Yak_InstallVulinbox_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "StartVulinbox",
			Handler:       _Yak_StartVulinbox_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "GenQualityInspectionReport",
			Handler:       _Yak_GenQualityInspectionReport_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "DebugPlugin",
			Handler:       _Yak_DebugPlugin_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "SmokingEvaluatePluginBatch",
			Handler:       _Yak_SmokingEvaluatePluginBatch_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "DiagnoseNetwork",
			Handler:       _Yak_DiagnoseNetwork_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "DiagnoseNetworkDNS",
			Handler:       _Yak_DiagnoseNetworkDNS_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "TraceRoute",
			Handler:       _Yak_TraceRoute_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "ReadFile",
			Handler:       _Yak_ReadFile_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "PcapX",
			Handler:       _Yak_PcapX_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
		{
			StreamName:    "DuplexConnection",
			Handler:       _Yak_DuplexConnection_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
		{
			StreamName:    "HybridScan",
			Handler:       _Yak_HybridScan_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
		{
			StreamName:    "FetchPortAssetFromSpaceEngine",
			Handler:       _Yak_FetchPortAssetFromSpaceEngine_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "ExportFingerprint",
			Handler:       _Yak_ExportFingerprint_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "ImportFingerprint",
			Handler:       _Yak_ImportFingerprint_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "ApplySyntaxFlowRuleUpdate",
			Handler:       _Yak_ApplySyntaxFlowRuleUpdate_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "SyntaxFlowRuleToOnline",
			Handler:       _Yak_SyntaxFlowRuleToOnline_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "DownloadSyntaxFlowRule",
			Handler:       _Yak_DownloadSyntaxFlowRule_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "SyntaxFlowScan",
			Handler:       _Yak_SyntaxFlowScan_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
		{
			StreamName:    "ExportSyntaxFlows",
			Handler:       _Yak_ExportSyntaxFlows_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "ImportSyntaxFlows",
			Handler:       _Yak_ImportSyntaxFlows_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "ExportHTTPFlowStream",
			Handler:       _Yak_ExportHTTPFlowStream_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "ImportHTTPFlowStream",
			Handler:       _Yak_ImportHTTPFlowStream_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "ImportNote",
			Handler:       _Yak_ImportNote_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "ExportNote",
			Handler:       _Yak_ExportNote_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "StartAITask",
			Handler:       _Yak_StartAITask_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
		{
			StreamName:    "StartAITriage",
			Handler:       _Yak_StartAITriage_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
		{
			StreamName:    "StartMcpServer",
			Handler:       _Yak_StartMcpServer_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "yakgrpc.proto",
}
