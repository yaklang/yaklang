// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.3.0
// - protoc             v3.21.12
// source: yakgrpc.proto

package ypb

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

const (
	Yak_Version_FullMethodName                                    = "/ypb.Yak/Version"
	Yak_Echo_FullMethodName                                       = "/ypb.Yak/Echo"
	Yak_MITM_FullMethodName                                       = "/ypb.Yak/MITM"
	Yak_SetMITMFilter_FullMethodName                              = "/ypb.Yak/SetMITMFilter"
	Yak_GetMITMFilter_FullMethodName                              = "/ypb.Yak/GetMITMFilter"
	Yak_DownloadMITMCert_FullMethodName                           = "/ypb.Yak/DownloadMITMCert"
	Yak_OpenPort_FullMethodName                                   = "/ypb.Yak/OpenPort"
	Yak_Exec_FullMethodName                                       = "/ypb.Yak/Exec"
	Yak_QueryExecHistory_FullMethodName                           = "/ypb.Yak/QueryExecHistory"
	Yak_RemoveExecHistory_FullMethodName                          = "/ypb.Yak/RemoveExecHistory"
	Yak_LoadNucleiTemplates_FullMethodName                        = "/ypb.Yak/LoadNucleiTemplates"
	Yak_AutoUpdateYakModule_FullMethodName                        = "/ypb.Yak/AutoUpdateYakModule"
	Yak_ExecYakScript_FullMethodName                              = "/ypb.Yak/ExecYakScript"
	Yak_ExecBatchYakScript_FullMethodName                         = "/ypb.Yak/ExecBatchYakScript"
	Yak_GetExecBatchYakScriptUnfinishedTask_FullMethodName        = "/ypb.Yak/GetExecBatchYakScriptUnfinishedTask"
	Yak_GetExecBatchYakScriptUnfinishedTaskByUid_FullMethodName   = "/ypb.Yak/GetExecBatchYakScriptUnfinishedTaskByUid"
	Yak_PopExecBatchYakScriptUnfinishedTaskByUid_FullMethodName   = "/ypb.Yak/PopExecBatchYakScriptUnfinishedTaskByUid"
	Yak_RecoverExecBatchYakScriptUnfinishedTask_FullMethodName    = "/ypb.Yak/RecoverExecBatchYakScriptUnfinishedTask"
	Yak_QueryYakScript_FullMethodName                             = "/ypb.Yak/QueryYakScript"
	Yak_QueryYakScriptByYakScriptName_FullMethodName              = "/ypb.Yak/QueryYakScriptByYakScriptName"
	Yak_SaveYakScript_FullMethodName                              = "/ypb.Yak/SaveYakScript"
	Yak_DeleteYakScript_FullMethodName                            = "/ypb.Yak/DeleteYakScript"
	Yak_GetYakScriptById_FullMethodName                           = "/ypb.Yak/GetYakScriptById"
	Yak_GetYakScriptByName_FullMethodName                         = "/ypb.Yak/GetYakScriptByName"
	Yak_GetYakScriptByOnlineID_FullMethodName                     = "/ypb.Yak/GetYakScriptByOnlineID"
	Yak_IgnoreYakScript_FullMethodName                            = "/ypb.Yak/IgnoreYakScript"
	Yak_UnIgnoreYakScript_FullMethodName                          = "/ypb.Yak/UnIgnoreYakScript"
	Yak_ExportYakScript_FullMethodName                            = "/ypb.Yak/ExportYakScript"
	Yak_ExecutePacketYakScript_FullMethodName                     = "/ypb.Yak/ExecutePacketYakScript"
	Yak_ExecuteBatchPacketYakScript_FullMethodName                = "/ypb.Yak/ExecuteBatchPacketYakScript"
	Yak_GetYakScriptTags_FullMethodName                           = "/ypb.Yak/GetYakScriptTags"
	Yak_QueryYakScriptLocalAndUser_FullMethodName                 = "/ypb.Yak/QueryYakScriptLocalAndUser"
	Yak_QueryYakScriptByOnlineGroup_FullMethodName                = "/ypb.Yak/QueryYakScriptByOnlineGroup"
	Yak_QueryYakScriptLocalAll_FullMethodName                     = "/ypb.Yak/QueryYakScriptLocalAll"
	Yak_QueryYakScriptByNames_FullMethodName                      = "/ypb.Yak/QueryYakScriptByNames"
	Yak_GetHTTPFlowByHash_FullMethodName                          = "/ypb.Yak/GetHTTPFlowByHash"
	Yak_GetHTTPFlowById_FullMethodName                            = "/ypb.Yak/GetHTTPFlowById"
	Yak_GetHTTPFlowByIds_FullMethodName                           = "/ypb.Yak/GetHTTPFlowByIds"
	Yak_QueryHTTPFlows_FullMethodName                             = "/ypb.Yak/QueryHTTPFlows"
	Yak_DeleteHTTPFlows_FullMethodName                            = "/ypb.Yak/DeleteHTTPFlows"
	Yak_SetTagForHTTPFlow_FullMethodName                          = "/ypb.Yak/SetTagForHTTPFlow"
	Yak_QueryHTTPFlowsIds_FullMethodName                          = "/ypb.Yak/QueryHTTPFlowsIds"
	Yak_HTTPFlowsFieldGroup_FullMethodName                        = "/ypb.Yak/HTTPFlowsFieldGroup"
	Yak_HTTPFlowsShare_FullMethodName                             = "/ypb.Yak/HTTPFlowsShare"
	Yak_HTTPFlowsExtract_FullMethodName                           = "/ypb.Yak/HTTPFlowsExtract"
	Yak_ExtractUrl_FullMethodName                                 = "/ypb.Yak/ExtractUrl"
	Yak_GetHistoryHTTPFuzzerTask_FullMethodName                   = "/ypb.Yak/GetHistoryHTTPFuzzerTask"
	Yak_QueryHistoryHTTPFuzzerTask_FullMethodName                 = "/ypb.Yak/QueryHistoryHTTPFuzzerTask"
	Yak_QueryHistoryHTTPFuzzerTaskEx_FullMethodName               = "/ypb.Yak/QueryHistoryHTTPFuzzerTaskEx"
	Yak_DeleteHistoryHTTPFuzzerTask_FullMethodName                = "/ypb.Yak/DeleteHistoryHTTPFuzzerTask"
	Yak_HTTPFuzzer_FullMethodName                                 = "/ypb.Yak/HTTPFuzzer"
	Yak_PreloadHTTPFuzzerParams_FullMethodName                    = "/ypb.Yak/PreloadHTTPFuzzerParams"
	Yak_RenderVariables_FullMethodName                            = "/ypb.Yak/RenderVariables"
	Yak_MatchHTTPResponse_FullMethodName                          = "/ypb.Yak/MatchHTTPResponse"
	Yak_ExtractHTTPResponse_FullMethodName                        = "/ypb.Yak/ExtractHTTPResponse"
	Yak_RedirectRequest_FullMethodName                            = "/ypb.Yak/RedirectRequest"
	Yak_HTTPRequestMutate_FullMethodName                          = "/ypb.Yak/HTTPRequestMutate"
	Yak_HTTPResponseMutate_FullMethodName                         = "/ypb.Yak/HTTPResponseMutate"
	Yak_FixUploadPacket_FullMethodName                            = "/ypb.Yak/FixUploadPacket"
	Yak_IsMultipartFormDataRequest_FullMethodName                 = "/ypb.Yak/IsMultipartFormDataRequest"
	Yak_GenerateExtractRule_FullMethodName                        = "/ypb.Yak/GenerateExtractRule"
	Yak_ExtractData_FullMethodName                                = "/ypb.Yak/ExtractData"
	Yak_SaveFuzzerLabel_FullMethodName                            = "/ypb.Yak/SaveFuzzerLabel"
	Yak_QueryFuzzerLabel_FullMethodName                           = "/ypb.Yak/QueryFuzzerLabel"
	Yak_DeleteFuzzerLabel_FullMethodName                          = "/ypb.Yak/DeleteFuzzerLabel"
	Yak_QueryHTTPFuzzerResponseByTaskId_FullMethodName            = "/ypb.Yak/QueryHTTPFuzzerResponseByTaskId"
	Yak_CreateWebsocketFuzzer_FullMethodName                      = "/ypb.Yak/CreateWebsocketFuzzer"
	Yak_QueryWebsocketFlowByHTTPFlowWebsocketHash_FullMethodName  = "/ypb.Yak/QueryWebsocketFlowByHTTPFlowWebsocketHash"
	Yak_DeleteWebsocketFlowByHTTPFlowWebsocketHash_FullMethodName = "/ypb.Yak/DeleteWebsocketFlowByHTTPFlowWebsocketHash"
	Yak_DeleteWebsocketFlowAll_FullMethodName                     = "/ypb.Yak/DeleteWebsocketFlowAll"
	Yak_ConvertFuzzerResponseToHTTPFlow_FullMethodName            = "/ypb.Yak/ConvertFuzzerResponseToHTTPFlow"
	Yak_StringFuzzer_FullMethodName                               = "/ypb.Yak/StringFuzzer"
	Yak_HTTPRequestAnalyzer_FullMethodName                        = "/ypb.Yak/HTTPRequestAnalyzer"
	Yak_Codec_FullMethodName                                      = "/ypb.Yak/Codec"
	Yak_QueryPayload_FullMethodName                               = "/ypb.Yak/QueryPayload"
	Yak_DeletePayloadByGroup_FullMethodName                       = "/ypb.Yak/DeletePayloadByGroup"
	Yak_DeletePayload_FullMethodName                              = "/ypb.Yak/DeletePayload"
	Yak_SavePayload_FullMethodName                                = "/ypb.Yak/SavePayload"
	Yak_SavePayloadStream_FullMethodName                          = "/ypb.Yak/SavePayloadStream"
	Yak_GetAllPayloadGroup_FullMethodName                         = "/ypb.Yak/GetAllPayloadGroup"
	Yak_UpdatePayload_FullMethodName                              = "/ypb.Yak/UpdatePayload"
	Yak_GetAllPayload_FullMethodName                              = "/ypb.Yak/GetAllPayload"
	Yak_GetYakitCompletionRaw_FullMethodName                      = "/ypb.Yak/GetYakitCompletionRaw"
	Yak_GetYakVMBuildInMethodCompletion_FullMethodName            = "/ypb.Yak/GetYakVMBuildInMethodCompletion"
	Yak_StaticAnalyzeError_FullMethodName                         = "/ypb.Yak/StaticAnalyzeError"
	Yak_YaklangCompileAndFormat_FullMethodName                    = "/ypb.Yak/YaklangCompileAndFormat"
	Yak_PortScan_FullMethodName                                   = "/ypb.Yak/PortScan"
	Yak_ViewPortScanCode_FullMethodName                           = "/ypb.Yak/ViewPortScanCode"
	Yak_SimpleDetect_FullMethodName                               = "/ypb.Yak/SimpleDetect"
	Yak_SaveCancelSimpleDetect_FullMethodName                     = "/ypb.Yak/SaveCancelSimpleDetect"
	Yak_GetSimpleDetectUnfinishedTask_FullMethodName              = "/ypb.Yak/GetSimpleDetectUnfinishedTask"
	Yak_GetSimpleDetectUnfinishedTaskByUid_FullMethodName         = "/ypb.Yak/GetSimpleDetectUnfinishedTaskByUid"
	Yak_PopSimpleDetectUnfinishedTaskByUid_FullMethodName         = "/ypb.Yak/PopSimpleDetectUnfinishedTaskByUid"
	Yak_RecoverSimpleDetectUnfinishedTask_FullMethodName          = "/ypb.Yak/RecoverSimpleDetectUnfinishedTask"
	Yak_QueryPorts_FullMethodName                                 = "/ypb.Yak/QueryPorts"
	Yak_DeletePorts_FullMethodName                                = "/ypb.Yak/DeletePorts"
	Yak_QueryHosts_FullMethodName                                 = "/ypb.Yak/QueryHosts"
	Yak_DeleteHosts_FullMethodName                                = "/ypb.Yak/DeleteHosts"
	Yak_QueryDomains_FullMethodName                               = "/ypb.Yak/QueryDomains"
	Yak_DeleteDomains_FullMethodName                              = "/ypb.Yak/DeleteDomains"
	Yak_QueryPortsGroup_FullMethodName                            = "/ypb.Yak/QueryPortsGroup"
	Yak_UpdateFromYakitResource_FullMethodName                    = "/ypb.Yak/UpdateFromYakitResource"
	Yak_UpdateFromGithub_FullMethodName                           = "/ypb.Yak/UpdateFromGithub"
	Yak_AddToMenu_FullMethodName                                  = "/ypb.Yak/AddToMenu"
	Yak_RemoveFromMenu_FullMethodName                             = "/ypb.Yak/RemoveFromMenu"
	Yak_YakScriptIsInMenu_FullMethodName                          = "/ypb.Yak/YakScriptIsInMenu"
	Yak_GetAllMenuItem_FullMethodName                             = "/ypb.Yak/GetAllMenuItem"
	Yak_DeleteAllMenuItem_FullMethodName                          = "/ypb.Yak/DeleteAllMenuItem"
	Yak_ImportMenuItem_FullMethodName                             = "/ypb.Yak/ImportMenuItem"
	Yak_ExportMenuItem_FullMethodName                             = "/ypb.Yak/ExportMenuItem"
	Yak_GetMenuItemById_FullMethodName                            = "/ypb.Yak/GetMenuItemById"
	Yak_QueryGroupsByYakScriptId_FullMethodName                   = "/ypb.Yak/QueryGroupsByYakScriptId"
	Yak_AddMenus_FullMethodName                                   = "/ypb.Yak/AddMenus"
	Yak_QueryAllMenuItem_FullMethodName                           = "/ypb.Yak/QueryAllMenuItem"
	Yak_DeleteAllMenu_FullMethodName                              = "/ypb.Yak/DeleteAllMenu"
	Yak_AddToNavigation_FullMethodName                            = "/ypb.Yak/AddToNavigation"
	Yak_GetAllNavigationItem_FullMethodName                       = "/ypb.Yak/GetAllNavigationItem"
	Yak_DeleteAllNavigation_FullMethodName                        = "/ypb.Yak/DeleteAllNavigation"
	Yak_AddOneNavigation_FullMethodName                           = "/ypb.Yak/AddOneNavigation"
	Yak_QueryNavigationGroups_FullMethodName                      = "/ypb.Yak/QueryNavigationGroups"
	Yak_SaveMarkdownDocument_FullMethodName                       = "/ypb.Yak/SaveMarkdownDocument"
	Yak_GetMarkdownDocument_FullMethodName                        = "/ypb.Yak/GetMarkdownDocument"
	Yak_DeleteMarkdownDocument_FullMethodName                     = "/ypb.Yak/DeleteMarkdownDocument"
	Yak_StartBasicCrawler_FullMethodName                          = "/ypb.Yak/StartBasicCrawler"
	Yak_ViewBasicCrawlerCode_FullMethodName                       = "/ypb.Yak/ViewBasicCrawlerCode"
	Yak_GenerateWebsiteTree_FullMethodName                        = "/ypb.Yak/GenerateWebsiteTree"
	Yak_QueryYakScriptExecResult_FullMethodName                   = "/ypb.Yak/QueryYakScriptExecResult"
	Yak_QueryYakScriptNameInExecResult_FullMethodName             = "/ypb.Yak/QueryYakScriptNameInExecResult"
	Yak_DeleteYakScriptExecResult_FullMethodName                  = "/ypb.Yak/DeleteYakScriptExecResult"
	Yak_DeleteYakScriptExec_FullMethodName                        = "/ypb.Yak/DeleteYakScriptExec"
	Yak_StartBrute_FullMethodName                                 = "/ypb.Yak/StartBrute"
	Yak_GetAvailableBruteTypes_FullMethodName                     = "/ypb.Yak/GetAvailableBruteTypes"
	Yak_GetTunnelServerExternalIP_FullMethodName                  = "/ypb.Yak/GetTunnelServerExternalIP"
	Yak_VerifyTunnelServerDomain_FullMethodName                   = "/ypb.Yak/VerifyTunnelServerDomain"
	Yak_StartFacades_FullMethodName                               = "/ypb.Yak/StartFacades"
	Yak_StartFacadesWithYsoObject_FullMethodName                  = "/ypb.Yak/StartFacadesWithYsoObject"
	Yak_ApplyClassToFacades_FullMethodName                        = "/ypb.Yak/ApplyClassToFacades"
	Yak_BytesToBase64_FullMethodName                              = "/ypb.Yak/BytesToBase64"
	Yak_ConfigGlobalReverse_FullMethodName                        = "/ypb.Yak/ConfigGlobalReverse"
	Yak_AvailableLocalAddr_FullMethodName                         = "/ypb.Yak/AvailableLocalAddr"
	Yak_GetGlobalReverseServer_FullMethodName                     = "/ypb.Yak/GetGlobalReverseServer"
	Yak_QueryRisks_FullMethodName                                 = "/ypb.Yak/QueryRisks"
	Yak_QueryRisk_FullMethodName                                  = "/ypb.Yak/QueryRisk"
	Yak_DeleteRisk_FullMethodName                                 = "/ypb.Yak/DeleteRisk"
	Yak_QueryAvailableRiskType_FullMethodName                     = "/ypb.Yak/QueryAvailableRiskType"
	Yak_QueryAvailableRiskLevel_FullMethodName                    = "/ypb.Yak/QueryAvailableRiskLevel"
	Yak_QueryRiskTableStats_FullMethodName                        = "/ypb.Yak/QueryRiskTableStats"
	Yak_ResetRiskTableStats_FullMethodName                        = "/ypb.Yak/ResetRiskTableStats"
	Yak_QueryAvailableTarget_FullMethodName                       = "/ypb.Yak/QueryAvailableTarget"
	Yak_QueryNewRisk_FullMethodName                               = "/ypb.Yak/QueryNewRisk"
	Yak_NewRiskRead_FullMethodName                                = "/ypb.Yak/NewRiskRead"
	Yak_UploadRiskToOnline_FullMethodName                         = "/ypb.Yak/UploadRiskToOnline"
	Yak_QueryReports_FullMethodName                               = "/ypb.Yak/QueryReports"
	Yak_QueryReport_FullMethodName                                = "/ypb.Yak/QueryReport"
	Yak_DeleteReport_FullMethodName                               = "/ypb.Yak/DeleteReport"
	Yak_QueryAvailableReportFrom_FullMethodName                   = "/ypb.Yak/QueryAvailableReportFrom"
	Yak_DownloadReport_FullMethodName                             = "/ypb.Yak/DownloadReport"
	Yak_GetAllYsoGadgetOptions_FullMethodName                     = "/ypb.Yak/GetAllYsoGadgetOptions"
	Yak_GetAllYsoClassOptions_FullMethodName                      = "/ypb.Yak/GetAllYsoClassOptions"
	Yak_GetAllYsoClassGeneraterOptions_FullMethodName             = "/ypb.Yak/GetAllYsoClassGeneraterOptions"
	Yak_GenerateYsoCode_FullMethodName                            = "/ypb.Yak/GenerateYsoCode"
	Yak_GenerateYsoBytes_FullMethodName                           = "/ypb.Yak/GenerateYsoBytes"
	Yak_YsoDump_FullMethodName                                    = "/ypb.Yak/YsoDump"
	Yak_SetYakBridgeLogServer_FullMethodName                      = "/ypb.Yak/SetYakBridgeLogServer"
	Yak_GetCurrentYakBridgeLogServer_FullMethodName               = "/ypb.Yak/GetCurrentYakBridgeLogServer"
	Yak_RequireDNSLogDomain_FullMethodName                        = "/ypb.Yak/RequireDNSLogDomain"
	Yak_QueryDNSLogByToken_FullMethodName                         = "/ypb.Yak/QueryDNSLogByToken"
	Yak_RequireICMPRandomLength_FullMethodName                    = "/ypb.Yak/RequireICMPRandomLength"
	Yak_QueryICMPTrigger_FullMethodName                           = "/ypb.Yak/QueryICMPTrigger"
	Yak_RequireRandomPortToken_FullMethodName                     = "/ypb.Yak/RequireRandomPortToken"
	Yak_QueryRandomPortTrigger_FullMethodName                     = "/ypb.Yak/QueryRandomPortTrigger"
	Yak_GetAvailableYakScriptTags_FullMethodName                  = "/ypb.Yak/GetAvailableYakScriptTags"
	Yak_ForceUpdateAvailableYakScriptTags_FullMethodName          = "/ypb.Yak/ForceUpdateAvailableYakScriptTags"
	Yak_ExecYakitPluginsByYakScriptFilter_FullMethodName          = "/ypb.Yak/ExecYakitPluginsByYakScriptFilter"
	Yak_GenerateYakCodeByPacket_FullMethodName                    = "/ypb.Yak/GenerateYakCodeByPacket"
	Yak_GenerateCSRFPocByPacket_FullMethodName                    = "/ypb.Yak/GenerateCSRFPocByPacket"
	Yak_ExportMITMReplacerRules_FullMethodName                    = "/ypb.Yak/ExportMITMReplacerRules"
	Yak_ImportMITMReplacerRules_FullMethodName                    = "/ypb.Yak/ImportMITMReplacerRules"
	Yak_GetCurrentRules_FullMethodName                            = "/ypb.Yak/GetCurrentRules"
	Yak_SetCurrentRules_FullMethodName                            = "/ypb.Yak/SetCurrentRules"
	Yak_ExtractDataToFile_FullMethodName                          = "/ypb.Yak/ExtractDataToFile"
	Yak_AutoDecode_FullMethodName                                 = "/ypb.Yak/AutoDecode"
	Yak_GetSystemProxy_FullMethodName                             = "/ypb.Yak/GetSystemProxy"
	Yak_SetSystemProxy_FullMethodName                             = "/ypb.Yak/SetSystemProxy"
	Yak_GetKey_FullMethodName                                     = "/ypb.Yak/GetKey"
	Yak_SetKey_FullMethodName                                     = "/ypb.Yak/SetKey"
	Yak_DelKey_FullMethodName                                     = "/ypb.Yak/DelKey"
	Yak_GetAllProcessEnvKey_FullMethodName                        = "/ypb.Yak/GetAllProcessEnvKey"
	Yak_SetProcessEnvKey_FullMethodName                           = "/ypb.Yak/SetProcessEnvKey"
	Yak_GetProjectKey_FullMethodName                              = "/ypb.Yak/GetProjectKey"
	Yak_SetProjectKey_FullMethodName                              = "/ypb.Yak/SetProjectKey"
	Yak_GetOnlineProfile_FullMethodName                           = "/ypb.Yak/GetOnlineProfile"
	Yak_SetOnlineProfile_FullMethodName                           = "/ypb.Yak/SetOnlineProfile"
	Yak_DownloadOnlinePluginById_FullMethodName                   = "/ypb.Yak/DownloadOnlinePluginById"
	Yak_DownloadOnlinePluginByIds_FullMethodName                  = "/ypb.Yak/DownloadOnlinePluginByIds"
	Yak_DownloadOnlinePluginAll_FullMethodName                    = "/ypb.Yak/DownloadOnlinePluginAll"
	Yak_DeletePluginByUserID_FullMethodName                       = "/ypb.Yak/DeletePluginByUserID"
	Yak_DeleteAllLocalPlugins_FullMethodName                      = "/ypb.Yak/DeleteAllLocalPlugins"
	Yak_GetYakScriptTagsAndType_FullMethodName                    = "/ypb.Yak/GetYakScriptTagsAndType"
	Yak_DeleteLocalPluginsByWhere_FullMethodName                  = "/ypb.Yak/DeleteLocalPluginsByWhere"
	Yak_DownloadOnlinePluginByScriptNames_FullMethodName          = "/ypb.Yak/DownloadOnlinePluginByScriptNames"
	Yak_ExecPacketScan_FullMethodName                             = "/ypb.Yak/ExecPacketScan"
	Yak_GetEngineDefaultProxy_FullMethodName                      = "/ypb.Yak/GetEngineDefaultProxy"
	Yak_SetEngineDefaultProxy_FullMethodName                      = "/ypb.Yak/SetEngineDefaultProxy"
	Yak_GetMachineID_FullMethodName                               = "/ypb.Yak/GetMachineID"
	Yak_GetLicense_FullMethodName                                 = "/ypb.Yak/GetLicense"
	Yak_CheckLicense_FullMethodName                               = "/ypb.Yak/CheckLicense"
	Yak_GetRequestBodyByHTTPFlowID_FullMethodName                 = "/ypb.Yak/GetRequestBodyByHTTPFlowID"
	Yak_GetResponseBodyByHTTPFlowID_FullMethodName                = "/ypb.Yak/GetResponseBodyByHTTPFlowID"
	Yak_GetHTTPPacketBody_FullMethodName                          = "/ypb.Yak/GetHTTPPacketBody"
	Yak_RegisterFacadesHTTP_FullMethodName                        = "/ypb.Yak/RegisterFacadesHTTP"
	Yak_ResetAndInvalidUserData_FullMethodName                    = "/ypb.Yak/ResetAndInvalidUserData"
	Yak_CreateYaklangShell_FullMethodName                         = "/ypb.Yak/CreateYaklangShell"
	Yak_AttachCombinedOutput_FullMethodName                       = "/ypb.Yak/AttachCombinedOutput"
	Yak_IsPrivilegedForNetRaw_FullMethodName                      = "/ypb.Yak/IsPrivilegedForNetRaw"
	Yak_PromotePermissionForUserPcap_FullMethodName               = "/ypb.Yak/PromotePermissionForUserPcap"
	Yak_SetCurrentProject_FullMethodName                          = "/ypb.Yak/SetCurrentProject"
	Yak_GetCurrentProject_FullMethodName                          = "/ypb.Yak/GetCurrentProject"
	Yak_GetProjects_FullMethodName                                = "/ypb.Yak/GetProjects"
	Yak_NewProject_FullMethodName                                 = "/ypb.Yak/NewProject"
	Yak_IsProjectNameValid_FullMethodName                         = "/ypb.Yak/IsProjectNameValid"
	Yak_RemoveProject_FullMethodName                              = "/ypb.Yak/RemoveProject"
	Yak_DeleteProject_FullMethodName                              = "/ypb.Yak/DeleteProject"
	Yak_GetDefaultProject_FullMethodName                          = "/ypb.Yak/GetDefaultProject"
	Yak_QueryProjectDetail_FullMethodName                         = "/ypb.Yak/QueryProjectDetail"
	Yak_ExportProject_FullMethodName                              = "/ypb.Yak/ExportProject"
	Yak_ImportProject_FullMethodName                              = "/ypb.Yak/ImportProject"
	Yak_MigrateLegacyDatabase_FullMethodName                      = "/ypb.Yak/MigrateLegacyDatabase"
	Yak_QueryMITMRuleExtractedData_FullMethodName                 = "/ypb.Yak/QueryMITMRuleExtractedData"
	Yak_ImportChaosMakerRules_FullMethodName                      = "/ypb.Yak/ImportChaosMakerRules"
	Yak_QueryChaosMakerRule_FullMethodName                        = "/ypb.Yak/QueryChaosMakerRule"
	Yak_DeleteChaosMakerRuleByID_FullMethodName                   = "/ypb.Yak/DeleteChaosMakerRuleByID"
	Yak_ExecuteChaosMakerRule_FullMethodName                      = "/ypb.Yak/ExecuteChaosMakerRule"
	Yak_IsRemoteAddrAvailable_FullMethodName                      = "/ypb.Yak/IsRemoteAddrAvailable"
	Yak_ConnectVulinboxAgent_FullMethodName                       = "/ypb.Yak/ConnectVulinboxAgent"
	Yak_GetRegisteredVulinboxAgent_FullMethodName                 = "/ypb.Yak/GetRegisteredVulinboxAgent"
	Yak_DisconnectVulinboxAgent_FullMethodName                    = "/ypb.Yak/DisconnectVulinboxAgent"
	Yak_IsCVEDatabaseReady_FullMethodName                         = "/ypb.Yak/IsCVEDatabaseReady"
	Yak_UpdateCVEDatabase_FullMethodName                          = "/ypb.Yak/UpdateCVEDatabase"
	Yak_ExportsProfileDatabase_FullMethodName                     = "/ypb.Yak/ExportsProfileDatabase"
	Yak_ImportsProfileDatabase_FullMethodName                     = "/ypb.Yak/ImportsProfileDatabase"
	Yak_QueryCVE_FullMethodName                                   = "/ypb.Yak/QueryCVE"
	Yak_GetCVE_FullMethodName                                     = "/ypb.Yak/GetCVE"
	Yak_SaveTextToTemporalFile_FullMethodName                     = "/ypb.Yak/SaveTextToTemporalFile"
	Yak_IsScrecorderReady_FullMethodName                          = "/ypb.Yak/IsScrecorderReady"
	Yak_InstallScrecorder_FullMethodName                          = "/ypb.Yak/InstallScrecorder"
	Yak_StartScrecorder_FullMethodName                            = "/ypb.Yak/StartScrecorder"
	Yak_QueryScreenRecorders_FullMethodName                       = "/ypb.Yak/QueryScreenRecorders"
	Yak_DeleteScreenRecorders_FullMethodName                      = "/ypb.Yak/DeleteScreenRecorders"
	Yak_UploadScreenRecorders_FullMethodName                      = "/ypb.Yak/UploadScreenRecorders"
	Yak_GetOneScreenRecorders_FullMethodName                      = "/ypb.Yak/GetOneScreenRecorders"
	Yak_UpdateScreenRecorders_FullMethodName                      = "/ypb.Yak/UpdateScreenRecorders"
	Yak_IsVulinboxReady_FullMethodName                            = "/ypb.Yak/IsVulinboxReady"
	Yak_InstallVulinbox_FullMethodName                            = "/ypb.Yak/InstallVulinbox"
	Yak_StartVulinbox_FullMethodName                              = "/ypb.Yak/StartVulinbox"
	Yak_HTTPRequestBuilder_FullMethodName                         = "/ypb.Yak/HTTPRequestBuilder"
	Yak_DebugPlugin_FullMethodName                                = "/ypb.Yak/DebugPlugin"
	Yak_SmokingEvaluatePlugin_FullMethodName                      = "/ypb.Yak/SmokingEvaluatePlugin"
	Yak_GetSystemDefaultDnsServers_FullMethodName                 = "/ypb.Yak/GetSystemDefaultDnsServers"
)

// YakClient is the client API for Yak service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type YakClient interface {
	// version
	Version(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*VersionResponse, error)
	// echo 通常用于测试服务是否通畅
	Echo(ctx context.Context, in *EchoRequest, opts ...grpc.CallOption) (*EchoResposne, error)
	// 中间人劫持
	MITM(ctx context.Context, opts ...grpc.CallOption) (Yak_MITMClient, error)
	SetMITMFilter(ctx context.Context, in *SetMITMFilterRequest, opts ...grpc.CallOption) (*SetMITMFilterResponse, error)
	GetMITMFilter(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*SetMITMFilterRequest, error)
	DownloadMITMCert(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*MITMCert, error)
	// 开启端口
	OpenPort(ctx context.Context, opts ...grpc.CallOption) (Yak_OpenPortClient, error)
	// Exec
	Exec(ctx context.Context, in *ExecRequest, opts ...grpc.CallOption) (Yak_ExecClient, error)
	QueryExecHistory(ctx context.Context, in *ExecHistoryRequest, opts ...grpc.CallOption) (*ExecHistoryRecordResponse, error)
	RemoveExecHistory(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*Empty, error)
	LoadNucleiTemplates(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*Empty, error)
	AutoUpdateYakModule(ctx context.Context, in *Empty, opts ...grpc.CallOption) (Yak_AutoUpdateYakModuleClient, error)
	ExecYakScript(ctx context.Context, in *ExecRequest, opts ...grpc.CallOption) (Yak_ExecYakScriptClient, error)
	ExecBatchYakScript(ctx context.Context, in *ExecBatchYakScriptRequest, opts ...grpc.CallOption) (Yak_ExecBatchYakScriptClient, error)
	GetExecBatchYakScriptUnfinishedTask(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*GetExecBatchYakScriptUnfinishedTaskResponse, error)
	GetExecBatchYakScriptUnfinishedTaskByUid(ctx context.Context, in *GetExecBatchYakScriptUnfinishedTaskByUidRequest, opts ...grpc.CallOption) (*ExecBatchYakScriptRequest, error)
	PopExecBatchYakScriptUnfinishedTaskByUid(ctx context.Context, in *GetExecBatchYakScriptUnfinishedTaskByUidRequest, opts ...grpc.CallOption) (*ExecBatchYakScriptRequest, error)
	RecoverExecBatchYakScriptUnfinishedTask(ctx context.Context, in *RecoverExecBatchYakScriptUnfinishedTaskRequest, opts ...grpc.CallOption) (Yak_RecoverExecBatchYakScriptUnfinishedTaskClient, error)
	// yakScript
	QueryYakScript(ctx context.Context, in *QueryYakScriptRequest, opts ...grpc.CallOption) (*QueryYakScriptResponse, error)
	QueryYakScriptByYakScriptName(ctx context.Context, in *QueryYakScriptRequest, opts ...grpc.CallOption) (Yak_QueryYakScriptByYakScriptNameClient, error)
	SaveYakScript(ctx context.Context, in *YakScript, opts ...grpc.CallOption) (*YakScript, error)
	DeleteYakScript(ctx context.Context, in *DeleteYakScriptRequest, opts ...grpc.CallOption) (*Empty, error)
	GetYakScriptById(ctx context.Context, in *GetYakScriptByIdRequest, opts ...grpc.CallOption) (*YakScript, error)
	GetYakScriptByName(ctx context.Context, in *GetYakScriptByNameRequest, opts ...grpc.CallOption) (*YakScript, error)
	GetYakScriptByOnlineID(ctx context.Context, in *GetYakScriptByOnlineIDRequest, opts ...grpc.CallOption) (*YakScript, error)
	IgnoreYakScript(ctx context.Context, in *DeleteYakScriptRequest, opts ...grpc.CallOption) (*Empty, error)
	UnIgnoreYakScript(ctx context.Context, in *DeleteYakScriptRequest, opts ...grpc.CallOption) (*Empty, error)
	ExportYakScript(ctx context.Context, in *ExportYakScriptRequest, opts ...grpc.CallOption) (*ExportYakScriptResponse, error)
	ExecutePacketYakScript(ctx context.Context, in *ExecutePacketYakScriptParams, opts ...grpc.CallOption) (Yak_ExecutePacketYakScriptClient, error)
	ExecuteBatchPacketYakScript(ctx context.Context, in *ExecuteBatchPacketYakScriptParams, opts ...grpc.CallOption) (Yak_ExecuteBatchPacketYakScriptClient, error)
	GetYakScriptTags(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*GetYakScriptTagsResponse, error)
	QueryYakScriptLocalAndUser(ctx context.Context, in *QueryYakScriptLocalAndUserRequest, opts ...grpc.CallOption) (*QueryYakScriptLocalAndUserResponse, error)
	QueryYakScriptByOnlineGroup(ctx context.Context, in *QueryYakScriptByOnlineGroupRequest, opts ...grpc.CallOption) (*QueryYakScriptLocalAndUserResponse, error)
	QueryYakScriptLocalAll(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*QueryYakScriptLocalAndUserResponse, error)
	QueryYakScriptByNames(ctx context.Context, in *QueryYakScriptByNamesRequest, opts ...grpc.CallOption) (*QueryYakScriptByNamesResponse, error)
	// HTTPFlow
	GetHTTPFlowByHash(ctx context.Context, in *GetHTTPFlowByHashRequest, opts ...grpc.CallOption) (*HTTPFlow, error)
	GetHTTPFlowById(ctx context.Context, in *GetHTTPFlowByIdRequest, opts ...grpc.CallOption) (*HTTPFlow, error)
	GetHTTPFlowByIds(ctx context.Context, in *GetHTTPFlowByIdsRequest, opts ...grpc.CallOption) (*HTTPFlows, error)
	QueryHTTPFlows(ctx context.Context, in *QueryHTTPFlowRequest, opts ...grpc.CallOption) (*QueryHTTPFlowResponse, error)
	DeleteHTTPFlows(ctx context.Context, in *DeleteHTTPFlowRequest, opts ...grpc.CallOption) (*Empty, error)
	SetTagForHTTPFlow(ctx context.Context, in *SetTagForHTTPFlowRequest, opts ...grpc.CallOption) (*Empty, error)
	QueryHTTPFlowsIds(ctx context.Context, in *QueryHTTPFlowsIdsRequest, opts ...grpc.CallOption) (*QueryHTTPFlowsIdsResponse, error)
	HTTPFlowsFieldGroup(ctx context.Context, in *HTTPFlowsFieldGroupRequest, opts ...grpc.CallOption) (*HTTPFlowsFieldGroupResponse, error)
	HTTPFlowsShare(ctx context.Context, in *HTTPFlowsShareRequest, opts ...grpc.CallOption) (*HTTPFlowsShareResponse, error)
	HTTPFlowsExtract(ctx context.Context, in *HTTPFlowsExtractRequest, opts ...grpc.CallOption) (*Empty, error)
	// 从一个 FuzzerRequest 中提取 Url
	ExtractUrl(ctx context.Context, in *FuzzerRequest, opts ...grpc.CallOption) (*ExtractedUrl, error)
	// Fuzzer
	GetHistoryHTTPFuzzerTask(ctx context.Context, in *GetHistoryHTTPFuzzerTaskRequest, opts ...grpc.CallOption) (*HistoryHTTPFuzzerTaskDetail, error)
	QueryHistoryHTTPFuzzerTask(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*HistoryHTTPFuzzerTasks, error)
	QueryHistoryHTTPFuzzerTaskEx(ctx context.Context, in *QueryHistoryHTTPFuzzerTaskExParams, opts ...grpc.CallOption) (*HistoryHTTPFuzzerTasksResponse, error)
	DeleteHistoryHTTPFuzzerTask(ctx context.Context, in *DeleteHistoryHTTPFuzzerTaskRequest, opts ...grpc.CallOption) (*Empty, error)
	HTTPFuzzer(ctx context.Context, in *FuzzerRequest, opts ...grpc.CallOption) (Yak_HTTPFuzzerClient, error)
	PreloadHTTPFuzzerParams(ctx context.Context, in *PreloadHTTPFuzzerParamsRequest, opts ...grpc.CallOption) (*PreloadHTTPFuzzerParamsResponse, error)
	RenderVariables(ctx context.Context, in *RenderVariablesRequest, opts ...grpc.CallOption) (*RenderVariablesResponse, error)
	MatchHTTPResponse(ctx context.Context, in *MatchHTTPResponseParams, opts ...grpc.CallOption) (*MatchHTTPResponseResult, error)
	ExtractHTTPResponse(ctx context.Context, in *ExtractHTTPResponseParams, opts ...grpc.CallOption) (*ExtractHTTPResponseResult, error)
	RedirectRequest(ctx context.Context, in *RedirectRequestParams, opts ...grpc.CallOption) (*FuzzerResponse, error)
	HTTPRequestMutate(ctx context.Context, in *HTTPRequestMutateParams, opts ...grpc.CallOption) (*MutateResult, error)
	HTTPResponseMutate(ctx context.Context, in *HTTPResponseMutateParams, opts ...grpc.CallOption) (*MutateResult, error)
	FixUploadPacket(ctx context.Context, in *FixUploadPacketRequest, opts ...grpc.CallOption) (*FixUploadPacketResponse, error)
	IsMultipartFormDataRequest(ctx context.Context, in *FixUploadPacketRequest, opts ...grpc.CallOption) (*IsMultipartFormDataRequestResult, error)
	GenerateExtractRule(ctx context.Context, in *GenerateExtractRuleRequest, opts ...grpc.CallOption) (*GenerateExtractRuleResponse, error)
	ExtractData(ctx context.Context, opts ...grpc.CallOption) (Yak_ExtractDataClient, error)
	SaveFuzzerLabel(ctx context.Context, in *SaveFuzzerLabelRequest, opts ...grpc.CallOption) (*Empty, error)
	QueryFuzzerLabel(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*QueryFuzzerLabelResponse, error)
	DeleteFuzzerLabel(ctx context.Context, in *DeleteFuzzerLabelRequest, opts ...grpc.CallOption) (*Empty, error)
	// HTTPFuzzerResponse
	// 这个挺特殊的，因为数据包太多了，会卡，所以后端会保存一份，通过这个接口做缓存查询
	QueryHTTPFuzzerResponseByTaskId(ctx context.Context, in *QueryHTTPFuzzerResponseByTaskIdRequest, opts ...grpc.CallOption) (*QueryHTTPFuzzerResponseByTaskIdResponse, error)
	// WebSocket
	CreateWebsocketFuzzer(ctx context.Context, opts ...grpc.CallOption) (Yak_CreateWebsocketFuzzerClient, error)
	QueryWebsocketFlowByHTTPFlowWebsocketHash(ctx context.Context, in *QueryWebsocketFlowByHTTPFlowWebsocketHashRequest, opts ...grpc.CallOption) (*WebsocketFlows, error)
	DeleteWebsocketFlowByHTTPFlowWebsocketHash(ctx context.Context, in *DeleteWebsocketFlowByHTTPFlowWebsocketHashRequest, opts ...grpc.CallOption) (*Empty, error)
	DeleteWebsocketFlowAll(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*Empty, error)
	// FuzzerResponse 对象转 HTTPFlow：以便分析和模糊测试
	ConvertFuzzerResponseToHTTPFlow(ctx context.Context, in *FuzzerResponse, opts ...grpc.CallOption) (*HTTPFlow, error)
	// 渲染 Fuzzer 模版
	StringFuzzer(ctx context.Context, in *StringFuzzerRequest, opts ...grpc.CallOption) (*StringFuzzerResponse, error)
	// 分析一个 HTTP 请求详情
	HTTPRequestAnalyzer(ctx context.Context, in *HTTPRequestAnalysisMaterial, opts ...grpc.CallOption) (*HTTPRequestAnalysis, error)
	// 编码解码
	Codec(ctx context.Context, in *CodecRequest, opts ...grpc.CallOption) (*CodecResponse, error)
	// Payload 相关接口
	QueryPayload(ctx context.Context, in *QueryPayloadRequest, opts ...grpc.CallOption) (*QueryPayloadResponse, error)
	DeletePayloadByGroup(ctx context.Context, in *DeletePayloadByGroupRequest, opts ...grpc.CallOption) (*Empty, error)
	DeletePayload(ctx context.Context, in *DeletePayloadRequest, opts ...grpc.CallOption) (*Empty, error)
	SavePayload(ctx context.Context, in *SavePayloadRequest, opts ...grpc.CallOption) (*Empty, error)
	SavePayloadStream(ctx context.Context, in *SavePayloadRequest, opts ...grpc.CallOption) (Yak_SavePayloadStreamClient, error)
	GetAllPayloadGroup(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*GetAllPayloadGroupResponse, error)
	UpdatePayload(ctx context.Context, in *UpdatePayloadRequest, opts ...grpc.CallOption) (*Empty, error)
	GetAllPayload(ctx context.Context, in *GetAllPayloadRequest, opts ...grpc.CallOption) (*GetAllPayloadResponse, error)
	// 自动生成补全
	GetYakitCompletionRaw(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*YakitCompletionRawResponse, error)
	GetYakVMBuildInMethodCompletion(ctx context.Context, in *GetYakVMBuildInMethodCompletionRequest, opts ...grpc.CallOption) (*GetYakVMBuildInMethodCompletionResponse, error)
	StaticAnalyzeError(ctx context.Context, in *StaticAnalyzeErrorRequest, opts ...grpc.CallOption) (*StaticAnalyzeErrorResponse, error)
	YaklangCompileAndFormat(ctx context.Context, in *YaklangCompileAndFormatRequest, opts ...grpc.CallOption) (*YaklangCompileAndFormatResponse, error)
	// 端口扫描的封装
	PortScan(ctx context.Context, in *PortScanRequest, opts ...grpc.CallOption) (Yak_PortScanClient, error)
	ViewPortScanCode(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*SimpleScript, error)
	SimpleDetect(ctx context.Context, in *RecordPortScanRequest, opts ...grpc.CallOption) (Yak_SimpleDetectClient, error)
	SaveCancelSimpleDetect(ctx context.Context, in *RecordPortScanRequest, opts ...grpc.CallOption) (*Empty, error)
	GetSimpleDetectUnfinishedTask(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*GetSimpleDetectUnfinishedTaskResponse, error)
	GetSimpleDetectUnfinishedTaskByUid(ctx context.Context, in *GetExecBatchYakScriptUnfinishedTaskByUidRequest, opts ...grpc.CallOption) (*RecordPortScanRequest, error)
	PopSimpleDetectUnfinishedTaskByUid(ctx context.Context, in *GetExecBatchYakScriptUnfinishedTaskByUidRequest, opts ...grpc.CallOption) (*RecordPortScanRequest, error)
	RecoverSimpleDetectUnfinishedTask(ctx context.Context, in *RecoverExecBatchYakScriptUnfinishedTaskRequest, opts ...grpc.CallOption) (Yak_RecoverSimpleDetectUnfinishedTaskClient, error)
	// 资产管理
	QueryPorts(ctx context.Context, in *QueryPortsRequest, opts ...grpc.CallOption) (*QueryPortsResponse, error)
	DeletePorts(ctx context.Context, in *DeletePortsRequest, opts ...grpc.CallOption) (*Empty, error)
	QueryHosts(ctx context.Context, in *QueryHostsRequest, opts ...grpc.CallOption) (*QueryHostsResponse, error)
	DeleteHosts(ctx context.Context, in *DeleteHostsRequest, opts ...grpc.CallOption) (*Empty, error)
	QueryDomains(ctx context.Context, in *QueryDomainsRequest, opts ...grpc.CallOption) (*QueryDomainsResponse, error)
	DeleteDomains(ctx context.Context, in *DeleteDomainsRequest, opts ...grpc.CallOption) (*Empty, error)
	QueryPortsGroup(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*QueryPortsGroupResponse, error)
	// Yakit Store
	UpdateFromYakitResource(ctx context.Context, in *UpdateFromYakitResourceRequest, opts ...grpc.CallOption) (*Empty, error)
	UpdateFromGithub(ctx context.Context, in *UpdateFromGithubRequest, opts ...grpc.CallOption) (*Empty, error)
	// Menu
	AddToMenu(ctx context.Context, in *AddToMenuRequest, opts ...grpc.CallOption) (*Empty, error)
	RemoveFromMenu(ctx context.Context, in *RemoveFromMenuRequest, opts ...grpc.CallOption) (*Empty, error)
	YakScriptIsInMenu(ctx context.Context, in *YakScriptIsInMenuRequest, opts ...grpc.CallOption) (*Empty, error)
	GetAllMenuItem(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*MenuByGroup, error)
	DeleteAllMenuItem(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*Empty, error)
	ImportMenuItem(ctx context.Context, in *ImportMenuItemRequest, opts ...grpc.CallOption) (*Empty, error)
	ExportMenuItem(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*ExportMenuItemResult, error)
	GetMenuItemById(ctx context.Context, in *GetMenuItemByIdRequest, opts ...grpc.CallOption) (*MenuItem, error)
	QueryGroupsByYakScriptId(ctx context.Context, in *QueryGroupsByYakScriptIdRequest, opts ...grpc.CallOption) (*GroupNames, error)
	AddMenus(ctx context.Context, in *AddMenuRequest, opts ...grpc.CallOption) (*Empty, error)
	QueryAllMenuItem(ctx context.Context, in *QueryAllMenuItemRequest, opts ...grpc.CallOption) (*MenuByGroup, error)
	DeleteAllMenu(ctx context.Context, in *QueryAllMenuItemRequest, opts ...grpc.CallOption) (*Empty, error)
	// NewMenu
	AddToNavigation(ctx context.Context, in *AddToNavigationRequest, opts ...grpc.CallOption) (*Empty, error)
	GetAllNavigationItem(ctx context.Context, in *GetAllNavigationRequest, opts ...grpc.CallOption) (*GetAllNavigationItemResponse, error)
	DeleteAllNavigation(ctx context.Context, in *GetAllNavigationRequest, opts ...grpc.CallOption) (*Empty, error)
	AddOneNavigation(ctx context.Context, in *AddOneNavigationRequest, opts ...grpc.CallOption) (*Empty, error)
	QueryNavigationGroups(ctx context.Context, in *QueryNavigationGroupsRequest, opts ...grpc.CallOption) (*GroupNames, error)
	// document
	SaveMarkdownDocument(ctx context.Context, in *SaveMarkdownDocumentRequest, opts ...grpc.CallOption) (*Empty, error)
	GetMarkdownDocument(ctx context.Context, in *GetMarkdownDocumentRequest, opts ...grpc.CallOption) (*GetMarkdownDocumentResponse, error)
	DeleteMarkdownDocument(ctx context.Context, in *GetMarkdownDocumentRequest, opts ...grpc.CallOption) (*Empty, error)
	// Crawler
	StartBasicCrawler(ctx context.Context, in *StartBasicCrawlerRequest, opts ...grpc.CallOption) (*ExecResult, error)
	ViewBasicCrawlerCode(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*SimpleScript, error)
	GenerateWebsiteTree(ctx context.Context, in *GenerateWebsiteTreeRequest, opts ...grpc.CallOption) (*GenerateWebsiteTreeResponse, error)
	// 对插件结果的操作
	QueryYakScriptExecResult(ctx context.Context, in *QueryYakScriptExecResultRequest, opts ...grpc.CallOption) (*QueryYakScriptExecResultResponse, error)
	QueryYakScriptNameInExecResult(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*YakScriptNames, error)
	DeleteYakScriptExecResult(ctx context.Context, in *DeleteYakScriptExecResultRequest, opts ...grpc.CallOption) (*Empty, error)
	DeleteYakScriptExec(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*Empty, error)
	// Bruter
	StartBrute(ctx context.Context, in *StartBruteParams, opts ...grpc.CallOption) (Yak_StartBruteClient, error)
	GetAvailableBruteTypes(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*GetAvailableBruteTypesResponse, error)
	// Tunnel Server RMI/DNSLog
	GetTunnelServerExternalIP(ctx context.Context, in *GetTunnelServerExternalIPParams, opts ...grpc.CallOption) (*GetTunnelServerExternalIPResponse, error)
	VerifyTunnelServerDomain(ctx context.Context, in *VerifyTunnelServerDomainParams, opts ...grpc.CallOption) (*VerifyTunnelServerDomainResponse, error)
	StartFacades(ctx context.Context, in *StartFacadesParams, opts ...grpc.CallOption) (Yak_StartFacadesClient, error)
	StartFacadesWithYsoObject(ctx context.Context, in *StartFacadesWithYsoParams, opts ...grpc.CallOption) (Yak_StartFacadesWithYsoObjectClient, error)
	ApplyClassToFacades(ctx context.Context, in *ApplyClassToFacadesParamsWithVerbose, opts ...grpc.CallOption) (*Empty, error)
	BytesToBase64(ctx context.Context, in *BytesToBase64Request, opts ...grpc.CallOption) (*BytesToBase64Response, error)
	ConfigGlobalReverse(ctx context.Context, in *ConfigGlobalReverseParams, opts ...grpc.CallOption) (Yak_ConfigGlobalReverseClient, error)
	AvailableLocalAddr(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*AvailableLocalAddrResponse, error)
	GetGlobalReverseServer(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*GetGlobalReverseServerResponse, error)
	// Risk
	QueryRisks(ctx context.Context, in *QueryRisksRequest, opts ...grpc.CallOption) (*QueryRisksResponse, error)
	QueryRisk(ctx context.Context, in *QueryRiskRequest, opts ...grpc.CallOption) (*Risk, error)
	DeleteRisk(ctx context.Context, in *DeleteRiskRequest, opts ...grpc.CallOption) (*Empty, error)
	QueryAvailableRiskType(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*Fields, error)
	QueryAvailableRiskLevel(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*Fields, error)
	QueryRiskTableStats(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*RiskTableStats, error)
	ResetRiskTableStats(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*Empty, error)
	QueryAvailableTarget(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*Fields, error)
	QueryNewRisk(ctx context.Context, in *QueryNewRiskRequest, opts ...grpc.CallOption) (*QueryNewRiskResponse, error)
	NewRiskRead(ctx context.Context, in *NewRiskReadRequest, opts ...grpc.CallOption) (*Empty, error)
	UploadRiskToOnline(ctx context.Context, in *UploadRiskToOnlineRequest, opts ...grpc.CallOption) (*Empty, error)
	// Report
	QueryReports(ctx context.Context, in *QueryReportsRequest, opts ...grpc.CallOption) (*QueryReportsResponse, error)
	QueryReport(ctx context.Context, in *QueryReportRequest, opts ...grpc.CallOption) (*Report, error)
	DeleteReport(ctx context.Context, in *DeleteReportRequest, opts ...grpc.CallOption) (*Empty, error)
	QueryAvailableReportFrom(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*Fields, error)
	DownloadReport(ctx context.Context, in *DownloadReportRequest, opts ...grpc.CallOption) (*Empty, error)
	// Yso
	GetAllYsoGadgetOptions(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*YsoOptionsWithVerbose, error)
	GetAllYsoClassOptions(ctx context.Context, in *YsoOptionsRequerstWithVerbose, opts ...grpc.CallOption) (*YsoOptionsWithVerbose, error)
	GetAllYsoClassGeneraterOptions(ctx context.Context, in *YsoOptionsRequerstWithVerbose, opts ...grpc.CallOption) (*YsoClassOptionsResponseWithVerbose, error)
	GenerateYsoCode(ctx context.Context, in *YsoOptionsRequerstWithVerbose, opts ...grpc.CallOption) (*YsoCodeResponse, error)
	GenerateYsoBytes(ctx context.Context, in *YsoOptionsRequerstWithVerbose, opts ...grpc.CallOption) (*YsoBytesResponse, error)
	YsoDump(ctx context.Context, in *YsoBytesObject, opts ...grpc.CallOption) (*YsoDumpResponse, error)
	// DNSLog / ICMP / RandomTrigger
	SetYakBridgeLogServer(ctx context.Context, in *YakDNSLogBridgeAddr, opts ...grpc.CallOption) (*Empty, error)
	GetCurrentYakBridgeLogServer(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*YakDNSLogBridgeAddr, error)
	RequireDNSLogDomain(ctx context.Context, in *YakDNSLogBridgeAddr, opts ...grpc.CallOption) (*DNSLogRootDomain, error)
	QueryDNSLogByToken(ctx context.Context, in *QueryDNSLogByTokenRequest, opts ...grpc.CallOption) (*QueryDNSLogByTokenResponse, error)
	RequireICMPRandomLength(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*RequireICMPRandomLengthResponse, error)
	QueryICMPTrigger(ctx context.Context, in *QueryICMPTriggerRequest, opts ...grpc.CallOption) (*QueryICMPTriggerResponse, error)
	RequireRandomPortToken(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*RandomPortInfo, error)
	QueryRandomPortTrigger(ctx context.Context, in *QueryRandomPortTriggerRequest, opts ...grpc.CallOption) (*RandomPortTriggerNotification, error)
	// 获取 Tags
	GetAvailableYakScriptTags(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*Fields, error)
	ForceUpdateAvailableYakScriptTags(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*Empty, error)
	// 通用的漏洞检测技术方案
	ExecYakitPluginsByYakScriptFilter(ctx context.Context, in *ExecYakitPluginsByYakScriptFilterRequest, opts ...grpc.CallOption) (Yak_ExecYakitPluginsByYakScriptFilterClient, error)
	// GenerateYakCodeByPacket
	GenerateYakCodeByPacket(ctx context.Context, in *GenerateYakCodeByPacketRequest, opts ...grpc.CallOption) (*GenerateYakCodeByPacketResponse, error)
	// CSRF Generator
	GenerateCSRFPocByPacket(ctx context.Context, in *GenerateCSRFPocByPacketRequest, opts ...grpc.CallOption) (*GenerateCSRFPocByPacketResponse, error)
	// MITM 衍生功能：
	// Replacers 管理
	ExportMITMReplacerRules(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*ExportMITMReplacerRulesResponse, error)
	ImportMITMReplacerRules(ctx context.Context, in *ImportMITMReplacerRulesRequest, opts ...grpc.CallOption) (*Empty, error)
	GetCurrentRules(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*MITMContentReplacers, error)
	SetCurrentRules(ctx context.Context, in *MITMContentReplacers, opts ...grpc.CallOption) (*Empty, error)
	ExtractDataToFile(ctx context.Context, opts ...grpc.CallOption) (Yak_ExtractDataToFileClient, error)
	// 尝试自动解码
	AutoDecode(ctx context.Context, in *AutoDecodeRequest, opts ...grpc.CallOption) (*AutoDecodeResponse, error)
	GetSystemProxy(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*GetSystemProxyResult, error)
	SetSystemProxy(ctx context.Context, in *SetSystemProxyRequest, opts ...grpc.CallOption) (*Empty, error)
	// 设置通用存储
	GetKey(ctx context.Context, in *GetKeyRequest, opts ...grpc.CallOption) (*GetKeyResult, error)
	SetKey(ctx context.Context, in *SetKeyRequest, opts ...grpc.CallOption) (*Empty, error)
	DelKey(ctx context.Context, in *GetKeyRequest, opts ...grpc.CallOption) (*Empty, error)
	GetAllProcessEnvKey(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*GetProcessEnvKeyResult, error)
	SetProcessEnvKey(ctx context.Context, in *SetKeyRequest, opts ...grpc.CallOption) (*Empty, error)
	GetProjectKey(ctx context.Context, in *GetKeyRequest, opts ...grpc.CallOption) (*GetKeyResult, error)
	SetProjectKey(ctx context.Context, in *SetKeyRequest, opts ...grpc.CallOption) (*Empty, error)
	// Online
	GetOnlineProfile(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*OnlineProfile, error)
	SetOnlineProfile(ctx context.Context, in *OnlineProfile, opts ...grpc.CallOption) (*Empty, error)
	DownloadOnlinePluginById(ctx context.Context, in *DownloadOnlinePluginByIdRequest, opts ...grpc.CallOption) (*Empty, error)
	DownloadOnlinePluginByIds(ctx context.Context, in *DownloadOnlinePluginByIdsRequest, opts ...grpc.CallOption) (*Empty, error)
	DownloadOnlinePluginAll(ctx context.Context, in *DownloadOnlinePluginByTokenRequest, opts ...grpc.CallOption) (Yak_DownloadOnlinePluginAllClient, error)
	DeletePluginByUserID(ctx context.Context, in *DeletePluginByUserIDRequest, opts ...grpc.CallOption) (*Empty, error)
	DeleteAllLocalPlugins(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*Empty, error)
	GetYakScriptTagsAndType(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*GetYakScriptTagsAndTypeResponse, error)
	DeleteLocalPluginsByWhere(ctx context.Context, in *DeleteLocalPluginsByWhereRequest, opts ...grpc.CallOption) (*Empty, error)
	DownloadOnlinePluginByScriptNames(ctx context.Context, in *DownloadOnlinePluginByScriptNamesRequest, opts ...grpc.CallOption) (*DownloadOnlinePluginByScriptNamesResponse, error)
	// 新的扫描模式
	ExecPacketScan(ctx context.Context, in *ExecPacketScanRequest, opts ...grpc.CallOption) (Yak_ExecPacketScanClient, error)
	GetEngineDefaultProxy(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*DefaultProxyResult, error)
	SetEngineDefaultProxy(ctx context.Context, in *DefaultProxyResult, opts ...grpc.CallOption) (*Empty, error)
	// machine id
	GetMachineID(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*GetMachineIDResponse, error)
	// license
	GetLicense(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*GetLicenseResponse, error)
	CheckLicense(ctx context.Context, in *CheckLicenseRequest, opts ...grpc.CallOption) (*Empty, error)
	// Response Body 的魔法操作
	GetRequestBodyByHTTPFlowID(ctx context.Context, in *DownloadBodyByHTTPFlowIDRequest, opts ...grpc.CallOption) (*Bytes, error)
	GetResponseBodyByHTTPFlowID(ctx context.Context, in *DownloadBodyByHTTPFlowIDRequest, opts ...grpc.CallOption) (*Bytes, error)
	GetHTTPPacketBody(ctx context.Context, in *GetHTTPPacketBodyRequest, opts ...grpc.CallOption) (*Bytes, error)
	// 注册一个 Facades HTTP 响应
	RegisterFacadesHTTP(ctx context.Context, in *RegisterFacadesHTTPRequest, opts ...grpc.CallOption) (*RegisterFacadesHTTPResponse, error)
	// 重置到恢复出厂设置
	ResetAndInvalidUserData(ctx context.Context, in *ResetAndInvalidUserDataRequest, opts ...grpc.CallOption) (*Empty, error)
	// Yaklang Shell
	// 创建一个交互式 Shell
	CreateYaklangShell(ctx context.Context, opts ...grpc.CallOption) (Yak_CreateYaklangShellClient, error)
	// 接入标准输出和标准错误流
	AttachCombinedOutput(ctx context.Context, in *AttachCombinedOutputRequest, opts ...grpc.CallOption) (Yak_AttachCombinedOutputClient, error)
	// 判断当前引擎对网卡是否有操作权限？
	// 主要是能否发包等敏感操作
	// Windows 判断是否是管理员即可 I Am Admin
	// Linux 和 MacOS 应该尝试 pcap 打开网卡就行
	IsPrivilegedForNetRaw(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*IsPrivilegedForNetRawResponse, error)
	PromotePermissionForUserPcap(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*Empty, error)
	// 操作项目的相关接口，通过设置 ProjectDatabase
	SetCurrentProject(ctx context.Context, in *SetCurrentProjectRequest, opts ...grpc.CallOption) (*Empty, error)
	GetCurrentProject(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*ProjectDescription, error)
	GetProjects(ctx context.Context, in *GetProjectsRequest, opts ...grpc.CallOption) (*GetProjectsResponse, error)
	NewProject(ctx context.Context, in *NewProjectRequest, opts ...grpc.CallOption) (*NewProjectResponse, error)
	IsProjectNameValid(ctx context.Context, in *IsProjectNameValidRequest, opts ...grpc.CallOption) (*Empty, error)
	RemoveProject(ctx context.Context, in *RemoveProjectRequest, opts ...grpc.CallOption) (*Empty, error)
	DeleteProject(ctx context.Context, in *DeleteProjectRequest, opts ...grpc.CallOption) (*Empty, error)
	GetDefaultProject(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*ProjectDescription, error)
	QueryProjectDetail(ctx context.Context, in *QueryProjectDetailRequest, opts ...grpc.CallOption) (*ProjectDescription, error)
	// 导入导出项目，带密码，带进度
	ExportProject(ctx context.Context, in *ExportProjectRequest, opts ...grpc.CallOption) (Yak_ExportProjectClient, error)
	ImportProject(ctx context.Context, in *ImportProjectRequest, opts ...grpc.CallOption) (Yak_ImportProjectClient, error)
	// 迁移旧数据库
	MigrateLegacyDatabase(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*Empty, error)
	// 从规则中提取数据
	QueryMITMRuleExtractedData(ctx context.Context, in *QueryMITMRuleExtractedDataRequest, opts ...grpc.CallOption) (*QueryMITMRuleExtractedDataResponse, error)
	// ChaosMakerRule: Bas
	ImportChaosMakerRules(ctx context.Context, in *ImportChaosMakerRulesRequest, opts ...grpc.CallOption) (*Empty, error)
	QueryChaosMakerRule(ctx context.Context, in *QueryChaosMakerRuleRequest, opts ...grpc.CallOption) (*QueryChaosMakerRuleResponse, error)
	DeleteChaosMakerRuleByID(ctx context.Context, in *DeleteChaosMakerRuleByIDRequest, opts ...grpc.CallOption) (*Empty, error)
	ExecuteChaosMakerRule(ctx context.Context, in *ExecuteChaosMakerRuleRequest, opts ...grpc.CallOption) (Yak_ExecuteChaosMakerRuleClient, error)
	// 这个接口是判断 BAS Agent 远程端口是否可用的，使用 Vulinbox ws agent 协议连接
	// ConnectVulinboxAgent is the same as IsRemoteAddrAvailable
	IsRemoteAddrAvailable(ctx context.Context, in *IsRemoteAddrAvailableRequest, opts ...grpc.CallOption) (*IsRemoteAddrAvailableResponse, error)
	ConnectVulinboxAgent(ctx context.Context, in *IsRemoteAddrAvailableRequest, opts ...grpc.CallOption) (*IsRemoteAddrAvailableResponse, error)
	// vulinbox agent 的操作接口
	GetRegisteredVulinboxAgent(ctx context.Context, in *GetRegisteredAgentRequest, opts ...grpc.CallOption) (*GetRegisteredAgentResponse, error)
	DisconnectVulinboxAgent(ctx context.Context, in *DisconnectVulinboxAgentRequest, opts ...grpc.CallOption) (*Empty, error)
	// CVE
	IsCVEDatabaseReady(ctx context.Context, in *IsCVEDatabaseReadyRequest, opts ...grpc.CallOption) (*IsCVEDatabaseReadyResponse, error)
	UpdateCVEDatabase(ctx context.Context, in *UpdateCVEDatabaseRequest, opts ...grpc.CallOption) (Yak_UpdateCVEDatabaseClient, error)
	ExportsProfileDatabase(ctx context.Context, in *ExportsProfileDatabaseRequest, opts ...grpc.CallOption) (Yak_ExportsProfileDatabaseClient, error)
	ImportsProfileDatabase(ctx context.Context, in *ImportsProfileDatabaseRequest, opts ...grpc.CallOption) (Yak_ImportsProfileDatabaseClient, error)
	QueryCVE(ctx context.Context, in *QueryCVERequest, opts ...grpc.CallOption) (*QueryCVEResponse, error)
	GetCVE(ctx context.Context, in *GetCVERequest, opts ...grpc.CallOption) (*CVEDetailEx, error)
	SaveTextToTemporalFile(ctx context.Context, in *SaveTextToTemporalFileRequest, opts ...grpc.CallOption) (*SaveTextToTemporalFileResponse, error)
	// Screcorder
	IsScrecorderReady(ctx context.Context, in *IsScrecorderReadyRequest, opts ...grpc.CallOption) (*IsScrecorderReadyResponse, error)
	InstallScrecorder(ctx context.Context, in *InstallScrecorderRequest, opts ...grpc.CallOption) (Yak_InstallScrecorderClient, error)
	StartScrecorder(ctx context.Context, in *StartScrecorderRequest, opts ...grpc.CallOption) (Yak_StartScrecorderClient, error)
	QueryScreenRecorders(ctx context.Context, in *QueryScreenRecorderRequest, opts ...grpc.CallOption) (*QueryScreenRecorderResponse, error)
	DeleteScreenRecorders(ctx context.Context, in *QueryScreenRecorderRequest, opts ...grpc.CallOption) (*Empty, error)
	UploadScreenRecorders(ctx context.Context, in *UploadScreenRecorderRequest, opts ...grpc.CallOption) (*Empty, error)
	GetOneScreenRecorders(ctx context.Context, in *GetOneScreenRecorderRequest, opts ...grpc.CallOption) (*ScreenRecorder, error)
	UpdateScreenRecorders(ctx context.Context, in *UpdateScreenRecorderRequest, opts ...grpc.CallOption) (*Empty, error)
	// Vulinbox
	IsVulinboxReady(ctx context.Context, in *IsVulinboxReadyRequest, opts ...grpc.CallOption) (*IsVulinboxReadyResponse, error)
	InstallVulinbox(ctx context.Context, in *InstallVulinboxRequest, opts ...grpc.CallOption) (Yak_InstallVulinboxClient, error)
	StartVulinbox(ctx context.Context, in *StartVulinboxRequest, opts ...grpc.CallOption) (Yak_StartVulinboxClient, error)
	// 通过他可以构造一个 HTTP 请求
	// 这个请求可能是一个，也可能是一系列
	// 一般用来调试插件等
	HTTPRequestBuilder(ctx context.Context, in *HTTPRequestBuilderParams, opts ...grpc.CallOption) (*HTTPRequestBuilderResponse, error)
	// rpc QueryHTTPRequestBuilder(QueryHTTPRequestBuilderRequest) returns (QueryHTTPRequestBuilderResponse);
	// rpc DeleteHTTPRequestBuilder(DeleteHTTPRequestBuilderRequest) returns (Empty);
	DebugPlugin(ctx context.Context, in *DebugPluginRequest, opts ...grpc.CallOption) (Yak_DebugPluginClient, error)
	SmokingEvaluatePlugin(ctx context.Context, in *SmokingEvaluatePluginRequest, opts ...grpc.CallOption) (*SmokingEvaluatePluginResponse, error)
	GetSystemDefaultDnsServers(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*DefaultDnsServerResponse, error)
}

type yakClient struct {
	cc grpc.ClientConnInterface
}

func NewYakClient(cc grpc.ClientConnInterface) YakClient {
	return &yakClient{cc}
}

func (c *yakClient) Version(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*VersionResponse, error) {
	out := new(VersionResponse)
	err := c.cc.Invoke(ctx, Yak_Version_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) Echo(ctx context.Context, in *EchoRequest, opts ...grpc.CallOption) (*EchoResposne, error) {
	out := new(EchoResposne)
	err := c.cc.Invoke(ctx, Yak_Echo_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) MITM(ctx context.Context, opts ...grpc.CallOption) (Yak_MITMClient, error) {
	stream, err := c.cc.NewStream(ctx, &Yak_ServiceDesc.Streams[0], Yak_MITM_FullMethodName, opts...)
	if err != nil {
		return nil, err
	}
	x := &yakMITMClient{stream}
	return x, nil
}

type Yak_MITMClient interface {
	Send(*MITMRequest) error
	Recv() (*MITMResponse, error)
	grpc.ClientStream
}

type yakMITMClient struct {
	grpc.ClientStream
}

func (x *yakMITMClient) Send(m *MITMRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *yakMITMClient) Recv() (*MITMResponse, error) {
	m := new(MITMResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *yakClient) SetMITMFilter(ctx context.Context, in *SetMITMFilterRequest, opts ...grpc.CallOption) (*SetMITMFilterResponse, error) {
	out := new(SetMITMFilterResponse)
	err := c.cc.Invoke(ctx, Yak_SetMITMFilter_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) GetMITMFilter(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*SetMITMFilterRequest, error) {
	out := new(SetMITMFilterRequest)
	err := c.cc.Invoke(ctx, Yak_GetMITMFilter_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) DownloadMITMCert(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*MITMCert, error) {
	out := new(MITMCert)
	err := c.cc.Invoke(ctx, Yak_DownloadMITMCert_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) OpenPort(ctx context.Context, opts ...grpc.CallOption) (Yak_OpenPortClient, error) {
	stream, err := c.cc.NewStream(ctx, &Yak_ServiceDesc.Streams[1], Yak_OpenPort_FullMethodName, opts...)
	if err != nil {
		return nil, err
	}
	x := &yakOpenPortClient{stream}
	return x, nil
}

type Yak_OpenPortClient interface {
	Send(*Input) error
	Recv() (*Output, error)
	grpc.ClientStream
}

type yakOpenPortClient struct {
	grpc.ClientStream
}

func (x *yakOpenPortClient) Send(m *Input) error {
	return x.ClientStream.SendMsg(m)
}

func (x *yakOpenPortClient) Recv() (*Output, error) {
	m := new(Output)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *yakClient) Exec(ctx context.Context, in *ExecRequest, opts ...grpc.CallOption) (Yak_ExecClient, error) {
	stream, err := c.cc.NewStream(ctx, &Yak_ServiceDesc.Streams[2], Yak_Exec_FullMethodName, opts...)
	if err != nil {
		return nil, err
	}
	x := &yakExecClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Yak_ExecClient interface {
	Recv() (*ExecResult, error)
	grpc.ClientStream
}

type yakExecClient struct {
	grpc.ClientStream
}

func (x *yakExecClient) Recv() (*ExecResult, error) {
	m := new(ExecResult)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *yakClient) QueryExecHistory(ctx context.Context, in *ExecHistoryRequest, opts ...grpc.CallOption) (*ExecHistoryRecordResponse, error) {
	out := new(ExecHistoryRecordResponse)
	err := c.cc.Invoke(ctx, Yak_QueryExecHistory_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) RemoveExecHistory(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, Yak_RemoveExecHistory_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) LoadNucleiTemplates(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, Yak_LoadNucleiTemplates_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) AutoUpdateYakModule(ctx context.Context, in *Empty, opts ...grpc.CallOption) (Yak_AutoUpdateYakModuleClient, error) {
	stream, err := c.cc.NewStream(ctx, &Yak_ServiceDesc.Streams[3], Yak_AutoUpdateYakModule_FullMethodName, opts...)
	if err != nil {
		return nil, err
	}
	x := &yakAutoUpdateYakModuleClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Yak_AutoUpdateYakModuleClient interface {
	Recv() (*ExecResult, error)
	grpc.ClientStream
}

type yakAutoUpdateYakModuleClient struct {
	grpc.ClientStream
}

func (x *yakAutoUpdateYakModuleClient) Recv() (*ExecResult, error) {
	m := new(ExecResult)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *yakClient) ExecYakScript(ctx context.Context, in *ExecRequest, opts ...grpc.CallOption) (Yak_ExecYakScriptClient, error) {
	stream, err := c.cc.NewStream(ctx, &Yak_ServiceDesc.Streams[4], Yak_ExecYakScript_FullMethodName, opts...)
	if err != nil {
		return nil, err
	}
	x := &yakExecYakScriptClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Yak_ExecYakScriptClient interface {
	Recv() (*ExecResult, error)
	grpc.ClientStream
}

type yakExecYakScriptClient struct {
	grpc.ClientStream
}

func (x *yakExecYakScriptClient) Recv() (*ExecResult, error) {
	m := new(ExecResult)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *yakClient) ExecBatchYakScript(ctx context.Context, in *ExecBatchYakScriptRequest, opts ...grpc.CallOption) (Yak_ExecBatchYakScriptClient, error) {
	stream, err := c.cc.NewStream(ctx, &Yak_ServiceDesc.Streams[5], Yak_ExecBatchYakScript_FullMethodName, opts...)
	if err != nil {
		return nil, err
	}
	x := &yakExecBatchYakScriptClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Yak_ExecBatchYakScriptClient interface {
	Recv() (*ExecBatchYakScriptResult, error)
	grpc.ClientStream
}

type yakExecBatchYakScriptClient struct {
	grpc.ClientStream
}

func (x *yakExecBatchYakScriptClient) Recv() (*ExecBatchYakScriptResult, error) {
	m := new(ExecBatchYakScriptResult)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *yakClient) GetExecBatchYakScriptUnfinishedTask(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*GetExecBatchYakScriptUnfinishedTaskResponse, error) {
	out := new(GetExecBatchYakScriptUnfinishedTaskResponse)
	err := c.cc.Invoke(ctx, Yak_GetExecBatchYakScriptUnfinishedTask_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) GetExecBatchYakScriptUnfinishedTaskByUid(ctx context.Context, in *GetExecBatchYakScriptUnfinishedTaskByUidRequest, opts ...grpc.CallOption) (*ExecBatchYakScriptRequest, error) {
	out := new(ExecBatchYakScriptRequest)
	err := c.cc.Invoke(ctx, Yak_GetExecBatchYakScriptUnfinishedTaskByUid_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) PopExecBatchYakScriptUnfinishedTaskByUid(ctx context.Context, in *GetExecBatchYakScriptUnfinishedTaskByUidRequest, opts ...grpc.CallOption) (*ExecBatchYakScriptRequest, error) {
	out := new(ExecBatchYakScriptRequest)
	err := c.cc.Invoke(ctx, Yak_PopExecBatchYakScriptUnfinishedTaskByUid_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) RecoverExecBatchYakScriptUnfinishedTask(ctx context.Context, in *RecoverExecBatchYakScriptUnfinishedTaskRequest, opts ...grpc.CallOption) (Yak_RecoverExecBatchYakScriptUnfinishedTaskClient, error) {
	stream, err := c.cc.NewStream(ctx, &Yak_ServiceDesc.Streams[6], Yak_RecoverExecBatchYakScriptUnfinishedTask_FullMethodName, opts...)
	if err != nil {
		return nil, err
	}
	x := &yakRecoverExecBatchYakScriptUnfinishedTaskClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Yak_RecoverExecBatchYakScriptUnfinishedTaskClient interface {
	Recv() (*ExecBatchYakScriptResult, error)
	grpc.ClientStream
}

type yakRecoverExecBatchYakScriptUnfinishedTaskClient struct {
	grpc.ClientStream
}

func (x *yakRecoverExecBatchYakScriptUnfinishedTaskClient) Recv() (*ExecBatchYakScriptResult, error) {
	m := new(ExecBatchYakScriptResult)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *yakClient) QueryYakScript(ctx context.Context, in *QueryYakScriptRequest, opts ...grpc.CallOption) (*QueryYakScriptResponse, error) {
	out := new(QueryYakScriptResponse)
	err := c.cc.Invoke(ctx, Yak_QueryYakScript_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) QueryYakScriptByYakScriptName(ctx context.Context, in *QueryYakScriptRequest, opts ...grpc.CallOption) (Yak_QueryYakScriptByYakScriptNameClient, error) {
	stream, err := c.cc.NewStream(ctx, &Yak_ServiceDesc.Streams[7], Yak_QueryYakScriptByYakScriptName_FullMethodName, opts...)
	if err != nil {
		return nil, err
	}
	x := &yakQueryYakScriptByYakScriptNameClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Yak_QueryYakScriptByYakScriptNameClient interface {
	Recv() (*YakScript, error)
	grpc.ClientStream
}

type yakQueryYakScriptByYakScriptNameClient struct {
	grpc.ClientStream
}

func (x *yakQueryYakScriptByYakScriptNameClient) Recv() (*YakScript, error) {
	m := new(YakScript)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *yakClient) SaveYakScript(ctx context.Context, in *YakScript, opts ...grpc.CallOption) (*YakScript, error) {
	out := new(YakScript)
	err := c.cc.Invoke(ctx, Yak_SaveYakScript_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) DeleteYakScript(ctx context.Context, in *DeleteYakScriptRequest, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, Yak_DeleteYakScript_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) GetYakScriptById(ctx context.Context, in *GetYakScriptByIdRequest, opts ...grpc.CallOption) (*YakScript, error) {
	out := new(YakScript)
	err := c.cc.Invoke(ctx, Yak_GetYakScriptById_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) GetYakScriptByName(ctx context.Context, in *GetYakScriptByNameRequest, opts ...grpc.CallOption) (*YakScript, error) {
	out := new(YakScript)
	err := c.cc.Invoke(ctx, Yak_GetYakScriptByName_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) GetYakScriptByOnlineID(ctx context.Context, in *GetYakScriptByOnlineIDRequest, opts ...grpc.CallOption) (*YakScript, error) {
	out := new(YakScript)
	err := c.cc.Invoke(ctx, Yak_GetYakScriptByOnlineID_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) IgnoreYakScript(ctx context.Context, in *DeleteYakScriptRequest, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, Yak_IgnoreYakScript_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) UnIgnoreYakScript(ctx context.Context, in *DeleteYakScriptRequest, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, Yak_UnIgnoreYakScript_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) ExportYakScript(ctx context.Context, in *ExportYakScriptRequest, opts ...grpc.CallOption) (*ExportYakScriptResponse, error) {
	out := new(ExportYakScriptResponse)
	err := c.cc.Invoke(ctx, Yak_ExportYakScript_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) ExecutePacketYakScript(ctx context.Context, in *ExecutePacketYakScriptParams, opts ...grpc.CallOption) (Yak_ExecutePacketYakScriptClient, error) {
	stream, err := c.cc.NewStream(ctx, &Yak_ServiceDesc.Streams[8], Yak_ExecutePacketYakScript_FullMethodName, opts...)
	if err != nil {
		return nil, err
	}
	x := &yakExecutePacketYakScriptClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Yak_ExecutePacketYakScriptClient interface {
	Recv() (*ExecResult, error)
	grpc.ClientStream
}

type yakExecutePacketYakScriptClient struct {
	grpc.ClientStream
}

func (x *yakExecutePacketYakScriptClient) Recv() (*ExecResult, error) {
	m := new(ExecResult)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *yakClient) ExecuteBatchPacketYakScript(ctx context.Context, in *ExecuteBatchPacketYakScriptParams, opts ...grpc.CallOption) (Yak_ExecuteBatchPacketYakScriptClient, error) {
	stream, err := c.cc.NewStream(ctx, &Yak_ServiceDesc.Streams[9], Yak_ExecuteBatchPacketYakScript_FullMethodName, opts...)
	if err != nil {
		return nil, err
	}
	x := &yakExecuteBatchPacketYakScriptClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Yak_ExecuteBatchPacketYakScriptClient interface {
	Recv() (*ExecBatchYakScriptResult, error)
	grpc.ClientStream
}

type yakExecuteBatchPacketYakScriptClient struct {
	grpc.ClientStream
}

func (x *yakExecuteBatchPacketYakScriptClient) Recv() (*ExecBatchYakScriptResult, error) {
	m := new(ExecBatchYakScriptResult)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *yakClient) GetYakScriptTags(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*GetYakScriptTagsResponse, error) {
	out := new(GetYakScriptTagsResponse)
	err := c.cc.Invoke(ctx, Yak_GetYakScriptTags_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) QueryYakScriptLocalAndUser(ctx context.Context, in *QueryYakScriptLocalAndUserRequest, opts ...grpc.CallOption) (*QueryYakScriptLocalAndUserResponse, error) {
	out := new(QueryYakScriptLocalAndUserResponse)
	err := c.cc.Invoke(ctx, Yak_QueryYakScriptLocalAndUser_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) QueryYakScriptByOnlineGroup(ctx context.Context, in *QueryYakScriptByOnlineGroupRequest, opts ...grpc.CallOption) (*QueryYakScriptLocalAndUserResponse, error) {
	out := new(QueryYakScriptLocalAndUserResponse)
	err := c.cc.Invoke(ctx, Yak_QueryYakScriptByOnlineGroup_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) QueryYakScriptLocalAll(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*QueryYakScriptLocalAndUserResponse, error) {
	out := new(QueryYakScriptLocalAndUserResponse)
	err := c.cc.Invoke(ctx, Yak_QueryYakScriptLocalAll_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) QueryYakScriptByNames(ctx context.Context, in *QueryYakScriptByNamesRequest, opts ...grpc.CallOption) (*QueryYakScriptByNamesResponse, error) {
	out := new(QueryYakScriptByNamesResponse)
	err := c.cc.Invoke(ctx, Yak_QueryYakScriptByNames_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) GetHTTPFlowByHash(ctx context.Context, in *GetHTTPFlowByHashRequest, opts ...grpc.CallOption) (*HTTPFlow, error) {
	out := new(HTTPFlow)
	err := c.cc.Invoke(ctx, Yak_GetHTTPFlowByHash_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) GetHTTPFlowById(ctx context.Context, in *GetHTTPFlowByIdRequest, opts ...grpc.CallOption) (*HTTPFlow, error) {
	out := new(HTTPFlow)
	err := c.cc.Invoke(ctx, Yak_GetHTTPFlowById_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) GetHTTPFlowByIds(ctx context.Context, in *GetHTTPFlowByIdsRequest, opts ...grpc.CallOption) (*HTTPFlows, error) {
	out := new(HTTPFlows)
	err := c.cc.Invoke(ctx, Yak_GetHTTPFlowByIds_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) QueryHTTPFlows(ctx context.Context, in *QueryHTTPFlowRequest, opts ...grpc.CallOption) (*QueryHTTPFlowResponse, error) {
	out := new(QueryHTTPFlowResponse)
	err := c.cc.Invoke(ctx, Yak_QueryHTTPFlows_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) DeleteHTTPFlows(ctx context.Context, in *DeleteHTTPFlowRequest, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, Yak_DeleteHTTPFlows_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) SetTagForHTTPFlow(ctx context.Context, in *SetTagForHTTPFlowRequest, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, Yak_SetTagForHTTPFlow_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) QueryHTTPFlowsIds(ctx context.Context, in *QueryHTTPFlowsIdsRequest, opts ...grpc.CallOption) (*QueryHTTPFlowsIdsResponse, error) {
	out := new(QueryHTTPFlowsIdsResponse)
	err := c.cc.Invoke(ctx, Yak_QueryHTTPFlowsIds_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) HTTPFlowsFieldGroup(ctx context.Context, in *HTTPFlowsFieldGroupRequest, opts ...grpc.CallOption) (*HTTPFlowsFieldGroupResponse, error) {
	out := new(HTTPFlowsFieldGroupResponse)
	err := c.cc.Invoke(ctx, Yak_HTTPFlowsFieldGroup_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) HTTPFlowsShare(ctx context.Context, in *HTTPFlowsShareRequest, opts ...grpc.CallOption) (*HTTPFlowsShareResponse, error) {
	out := new(HTTPFlowsShareResponse)
	err := c.cc.Invoke(ctx, Yak_HTTPFlowsShare_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) HTTPFlowsExtract(ctx context.Context, in *HTTPFlowsExtractRequest, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, Yak_HTTPFlowsExtract_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) ExtractUrl(ctx context.Context, in *FuzzerRequest, opts ...grpc.CallOption) (*ExtractedUrl, error) {
	out := new(ExtractedUrl)
	err := c.cc.Invoke(ctx, Yak_ExtractUrl_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) GetHistoryHTTPFuzzerTask(ctx context.Context, in *GetHistoryHTTPFuzzerTaskRequest, opts ...grpc.CallOption) (*HistoryHTTPFuzzerTaskDetail, error) {
	out := new(HistoryHTTPFuzzerTaskDetail)
	err := c.cc.Invoke(ctx, Yak_GetHistoryHTTPFuzzerTask_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) QueryHistoryHTTPFuzzerTask(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*HistoryHTTPFuzzerTasks, error) {
	out := new(HistoryHTTPFuzzerTasks)
	err := c.cc.Invoke(ctx, Yak_QueryHistoryHTTPFuzzerTask_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) QueryHistoryHTTPFuzzerTaskEx(ctx context.Context, in *QueryHistoryHTTPFuzzerTaskExParams, opts ...grpc.CallOption) (*HistoryHTTPFuzzerTasksResponse, error) {
	out := new(HistoryHTTPFuzzerTasksResponse)
	err := c.cc.Invoke(ctx, Yak_QueryHistoryHTTPFuzzerTaskEx_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) DeleteHistoryHTTPFuzzerTask(ctx context.Context, in *DeleteHistoryHTTPFuzzerTaskRequest, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, Yak_DeleteHistoryHTTPFuzzerTask_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) HTTPFuzzer(ctx context.Context, in *FuzzerRequest, opts ...grpc.CallOption) (Yak_HTTPFuzzerClient, error) {
	stream, err := c.cc.NewStream(ctx, &Yak_ServiceDesc.Streams[10], Yak_HTTPFuzzer_FullMethodName, opts...)
	if err != nil {
		return nil, err
	}
	x := &yakHTTPFuzzerClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Yak_HTTPFuzzerClient interface {
	Recv() (*FuzzerResponse, error)
	grpc.ClientStream
}

type yakHTTPFuzzerClient struct {
	grpc.ClientStream
}

func (x *yakHTTPFuzzerClient) Recv() (*FuzzerResponse, error) {
	m := new(FuzzerResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *yakClient) PreloadHTTPFuzzerParams(ctx context.Context, in *PreloadHTTPFuzzerParamsRequest, opts ...grpc.CallOption) (*PreloadHTTPFuzzerParamsResponse, error) {
	out := new(PreloadHTTPFuzzerParamsResponse)
	err := c.cc.Invoke(ctx, Yak_PreloadHTTPFuzzerParams_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) RenderVariables(ctx context.Context, in *RenderVariablesRequest, opts ...grpc.CallOption) (*RenderVariablesResponse, error) {
	out := new(RenderVariablesResponse)
	err := c.cc.Invoke(ctx, Yak_RenderVariables_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) MatchHTTPResponse(ctx context.Context, in *MatchHTTPResponseParams, opts ...grpc.CallOption) (*MatchHTTPResponseResult, error) {
	out := new(MatchHTTPResponseResult)
	err := c.cc.Invoke(ctx, Yak_MatchHTTPResponse_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) ExtractHTTPResponse(ctx context.Context, in *ExtractHTTPResponseParams, opts ...grpc.CallOption) (*ExtractHTTPResponseResult, error) {
	out := new(ExtractHTTPResponseResult)
	err := c.cc.Invoke(ctx, Yak_ExtractHTTPResponse_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) RedirectRequest(ctx context.Context, in *RedirectRequestParams, opts ...grpc.CallOption) (*FuzzerResponse, error) {
	out := new(FuzzerResponse)
	err := c.cc.Invoke(ctx, Yak_RedirectRequest_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) HTTPRequestMutate(ctx context.Context, in *HTTPRequestMutateParams, opts ...grpc.CallOption) (*MutateResult, error) {
	out := new(MutateResult)
	err := c.cc.Invoke(ctx, Yak_HTTPRequestMutate_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) HTTPResponseMutate(ctx context.Context, in *HTTPResponseMutateParams, opts ...grpc.CallOption) (*MutateResult, error) {
	out := new(MutateResult)
	err := c.cc.Invoke(ctx, Yak_HTTPResponseMutate_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) FixUploadPacket(ctx context.Context, in *FixUploadPacketRequest, opts ...grpc.CallOption) (*FixUploadPacketResponse, error) {
	out := new(FixUploadPacketResponse)
	err := c.cc.Invoke(ctx, Yak_FixUploadPacket_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) IsMultipartFormDataRequest(ctx context.Context, in *FixUploadPacketRequest, opts ...grpc.CallOption) (*IsMultipartFormDataRequestResult, error) {
	out := new(IsMultipartFormDataRequestResult)
	err := c.cc.Invoke(ctx, Yak_IsMultipartFormDataRequest_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) GenerateExtractRule(ctx context.Context, in *GenerateExtractRuleRequest, opts ...grpc.CallOption) (*GenerateExtractRuleResponse, error) {
	out := new(GenerateExtractRuleResponse)
	err := c.cc.Invoke(ctx, Yak_GenerateExtractRule_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) ExtractData(ctx context.Context, opts ...grpc.CallOption) (Yak_ExtractDataClient, error) {
	stream, err := c.cc.NewStream(ctx, &Yak_ServiceDesc.Streams[11], Yak_ExtractData_FullMethodName, opts...)
	if err != nil {
		return nil, err
	}
	x := &yakExtractDataClient{stream}
	return x, nil
}

type Yak_ExtractDataClient interface {
	Send(*ExtractDataRequest) error
	Recv() (*ExtractDataResponse, error)
	grpc.ClientStream
}

type yakExtractDataClient struct {
	grpc.ClientStream
}

func (x *yakExtractDataClient) Send(m *ExtractDataRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *yakExtractDataClient) Recv() (*ExtractDataResponse, error) {
	m := new(ExtractDataResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *yakClient) SaveFuzzerLabel(ctx context.Context, in *SaveFuzzerLabelRequest, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, Yak_SaveFuzzerLabel_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) QueryFuzzerLabel(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*QueryFuzzerLabelResponse, error) {
	out := new(QueryFuzzerLabelResponse)
	err := c.cc.Invoke(ctx, Yak_QueryFuzzerLabel_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) DeleteFuzzerLabel(ctx context.Context, in *DeleteFuzzerLabelRequest, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, Yak_DeleteFuzzerLabel_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) QueryHTTPFuzzerResponseByTaskId(ctx context.Context, in *QueryHTTPFuzzerResponseByTaskIdRequest, opts ...grpc.CallOption) (*QueryHTTPFuzzerResponseByTaskIdResponse, error) {
	out := new(QueryHTTPFuzzerResponseByTaskIdResponse)
	err := c.cc.Invoke(ctx, Yak_QueryHTTPFuzzerResponseByTaskId_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) CreateWebsocketFuzzer(ctx context.Context, opts ...grpc.CallOption) (Yak_CreateWebsocketFuzzerClient, error) {
	stream, err := c.cc.NewStream(ctx, &Yak_ServiceDesc.Streams[12], Yak_CreateWebsocketFuzzer_FullMethodName, opts...)
	if err != nil {
		return nil, err
	}
	x := &yakCreateWebsocketFuzzerClient{stream}
	return x, nil
}

type Yak_CreateWebsocketFuzzerClient interface {
	Send(*ClientWebsocketRequest) error
	Recv() (*ClientWebsocketResponse, error)
	grpc.ClientStream
}

type yakCreateWebsocketFuzzerClient struct {
	grpc.ClientStream
}

func (x *yakCreateWebsocketFuzzerClient) Send(m *ClientWebsocketRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *yakCreateWebsocketFuzzerClient) Recv() (*ClientWebsocketResponse, error) {
	m := new(ClientWebsocketResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *yakClient) QueryWebsocketFlowByHTTPFlowWebsocketHash(ctx context.Context, in *QueryWebsocketFlowByHTTPFlowWebsocketHashRequest, opts ...grpc.CallOption) (*WebsocketFlows, error) {
	out := new(WebsocketFlows)
	err := c.cc.Invoke(ctx, Yak_QueryWebsocketFlowByHTTPFlowWebsocketHash_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) DeleteWebsocketFlowByHTTPFlowWebsocketHash(ctx context.Context, in *DeleteWebsocketFlowByHTTPFlowWebsocketHashRequest, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, Yak_DeleteWebsocketFlowByHTTPFlowWebsocketHash_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) DeleteWebsocketFlowAll(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, Yak_DeleteWebsocketFlowAll_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) ConvertFuzzerResponseToHTTPFlow(ctx context.Context, in *FuzzerResponse, opts ...grpc.CallOption) (*HTTPFlow, error) {
	out := new(HTTPFlow)
	err := c.cc.Invoke(ctx, Yak_ConvertFuzzerResponseToHTTPFlow_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) StringFuzzer(ctx context.Context, in *StringFuzzerRequest, opts ...grpc.CallOption) (*StringFuzzerResponse, error) {
	out := new(StringFuzzerResponse)
	err := c.cc.Invoke(ctx, Yak_StringFuzzer_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) HTTPRequestAnalyzer(ctx context.Context, in *HTTPRequestAnalysisMaterial, opts ...grpc.CallOption) (*HTTPRequestAnalysis, error) {
	out := new(HTTPRequestAnalysis)
	err := c.cc.Invoke(ctx, Yak_HTTPRequestAnalyzer_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) Codec(ctx context.Context, in *CodecRequest, opts ...grpc.CallOption) (*CodecResponse, error) {
	out := new(CodecResponse)
	err := c.cc.Invoke(ctx, Yak_Codec_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) QueryPayload(ctx context.Context, in *QueryPayloadRequest, opts ...grpc.CallOption) (*QueryPayloadResponse, error) {
	out := new(QueryPayloadResponse)
	err := c.cc.Invoke(ctx, Yak_QueryPayload_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) DeletePayloadByGroup(ctx context.Context, in *DeletePayloadByGroupRequest, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, Yak_DeletePayloadByGroup_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) DeletePayload(ctx context.Context, in *DeletePayloadRequest, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, Yak_DeletePayload_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) SavePayload(ctx context.Context, in *SavePayloadRequest, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, Yak_SavePayload_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) SavePayloadStream(ctx context.Context, in *SavePayloadRequest, opts ...grpc.CallOption) (Yak_SavePayloadStreamClient, error) {
	stream, err := c.cc.NewStream(ctx, &Yak_ServiceDesc.Streams[13], Yak_SavePayloadStream_FullMethodName, opts...)
	if err != nil {
		return nil, err
	}
	x := &yakSavePayloadStreamClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Yak_SavePayloadStreamClient interface {
	Recv() (*SavePayloadProgress, error)
	grpc.ClientStream
}

type yakSavePayloadStreamClient struct {
	grpc.ClientStream
}

func (x *yakSavePayloadStreamClient) Recv() (*SavePayloadProgress, error) {
	m := new(SavePayloadProgress)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *yakClient) GetAllPayloadGroup(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*GetAllPayloadGroupResponse, error) {
	out := new(GetAllPayloadGroupResponse)
	err := c.cc.Invoke(ctx, Yak_GetAllPayloadGroup_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) UpdatePayload(ctx context.Context, in *UpdatePayloadRequest, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, Yak_UpdatePayload_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) GetAllPayload(ctx context.Context, in *GetAllPayloadRequest, opts ...grpc.CallOption) (*GetAllPayloadResponse, error) {
	out := new(GetAllPayloadResponse)
	err := c.cc.Invoke(ctx, Yak_GetAllPayload_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) GetYakitCompletionRaw(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*YakitCompletionRawResponse, error) {
	out := new(YakitCompletionRawResponse)
	err := c.cc.Invoke(ctx, Yak_GetYakitCompletionRaw_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) GetYakVMBuildInMethodCompletion(ctx context.Context, in *GetYakVMBuildInMethodCompletionRequest, opts ...grpc.CallOption) (*GetYakVMBuildInMethodCompletionResponse, error) {
	out := new(GetYakVMBuildInMethodCompletionResponse)
	err := c.cc.Invoke(ctx, Yak_GetYakVMBuildInMethodCompletion_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) StaticAnalyzeError(ctx context.Context, in *StaticAnalyzeErrorRequest, opts ...grpc.CallOption) (*StaticAnalyzeErrorResponse, error) {
	out := new(StaticAnalyzeErrorResponse)
	err := c.cc.Invoke(ctx, Yak_StaticAnalyzeError_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) YaklangCompileAndFormat(ctx context.Context, in *YaklangCompileAndFormatRequest, opts ...grpc.CallOption) (*YaklangCompileAndFormatResponse, error) {
	out := new(YaklangCompileAndFormatResponse)
	err := c.cc.Invoke(ctx, Yak_YaklangCompileAndFormat_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) PortScan(ctx context.Context, in *PortScanRequest, opts ...grpc.CallOption) (Yak_PortScanClient, error) {
	stream, err := c.cc.NewStream(ctx, &Yak_ServiceDesc.Streams[14], Yak_PortScan_FullMethodName, opts...)
	if err != nil {
		return nil, err
	}
	x := &yakPortScanClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Yak_PortScanClient interface {
	Recv() (*ExecResult, error)
	grpc.ClientStream
}

type yakPortScanClient struct {
	grpc.ClientStream
}

func (x *yakPortScanClient) Recv() (*ExecResult, error) {
	m := new(ExecResult)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *yakClient) ViewPortScanCode(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*SimpleScript, error) {
	out := new(SimpleScript)
	err := c.cc.Invoke(ctx, Yak_ViewPortScanCode_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) SimpleDetect(ctx context.Context, in *RecordPortScanRequest, opts ...grpc.CallOption) (Yak_SimpleDetectClient, error) {
	stream, err := c.cc.NewStream(ctx, &Yak_ServiceDesc.Streams[15], Yak_SimpleDetect_FullMethodName, opts...)
	if err != nil {
		return nil, err
	}
	x := &yakSimpleDetectClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Yak_SimpleDetectClient interface {
	Recv() (*ExecResult, error)
	grpc.ClientStream
}

type yakSimpleDetectClient struct {
	grpc.ClientStream
}

func (x *yakSimpleDetectClient) Recv() (*ExecResult, error) {
	m := new(ExecResult)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *yakClient) SaveCancelSimpleDetect(ctx context.Context, in *RecordPortScanRequest, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, Yak_SaveCancelSimpleDetect_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) GetSimpleDetectUnfinishedTask(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*GetSimpleDetectUnfinishedTaskResponse, error) {
	out := new(GetSimpleDetectUnfinishedTaskResponse)
	err := c.cc.Invoke(ctx, Yak_GetSimpleDetectUnfinishedTask_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) GetSimpleDetectUnfinishedTaskByUid(ctx context.Context, in *GetExecBatchYakScriptUnfinishedTaskByUidRequest, opts ...grpc.CallOption) (*RecordPortScanRequest, error) {
	out := new(RecordPortScanRequest)
	err := c.cc.Invoke(ctx, Yak_GetSimpleDetectUnfinishedTaskByUid_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) PopSimpleDetectUnfinishedTaskByUid(ctx context.Context, in *GetExecBatchYakScriptUnfinishedTaskByUidRequest, opts ...grpc.CallOption) (*RecordPortScanRequest, error) {
	out := new(RecordPortScanRequest)
	err := c.cc.Invoke(ctx, Yak_PopSimpleDetectUnfinishedTaskByUid_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) RecoverSimpleDetectUnfinishedTask(ctx context.Context, in *RecoverExecBatchYakScriptUnfinishedTaskRequest, opts ...grpc.CallOption) (Yak_RecoverSimpleDetectUnfinishedTaskClient, error) {
	stream, err := c.cc.NewStream(ctx, &Yak_ServiceDesc.Streams[16], Yak_RecoverSimpleDetectUnfinishedTask_FullMethodName, opts...)
	if err != nil {
		return nil, err
	}
	x := &yakRecoverSimpleDetectUnfinishedTaskClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Yak_RecoverSimpleDetectUnfinishedTaskClient interface {
	Recv() (*ExecResult, error)
	grpc.ClientStream
}

type yakRecoverSimpleDetectUnfinishedTaskClient struct {
	grpc.ClientStream
}

func (x *yakRecoverSimpleDetectUnfinishedTaskClient) Recv() (*ExecResult, error) {
	m := new(ExecResult)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *yakClient) QueryPorts(ctx context.Context, in *QueryPortsRequest, opts ...grpc.CallOption) (*QueryPortsResponse, error) {
	out := new(QueryPortsResponse)
	err := c.cc.Invoke(ctx, Yak_QueryPorts_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) DeletePorts(ctx context.Context, in *DeletePortsRequest, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, Yak_DeletePorts_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) QueryHosts(ctx context.Context, in *QueryHostsRequest, opts ...grpc.CallOption) (*QueryHostsResponse, error) {
	out := new(QueryHostsResponse)
	err := c.cc.Invoke(ctx, Yak_QueryHosts_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) DeleteHosts(ctx context.Context, in *DeleteHostsRequest, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, Yak_DeleteHosts_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) QueryDomains(ctx context.Context, in *QueryDomainsRequest, opts ...grpc.CallOption) (*QueryDomainsResponse, error) {
	out := new(QueryDomainsResponse)
	err := c.cc.Invoke(ctx, Yak_QueryDomains_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) DeleteDomains(ctx context.Context, in *DeleteDomainsRequest, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, Yak_DeleteDomains_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) QueryPortsGroup(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*QueryPortsGroupResponse, error) {
	out := new(QueryPortsGroupResponse)
	err := c.cc.Invoke(ctx, Yak_QueryPortsGroup_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) UpdateFromYakitResource(ctx context.Context, in *UpdateFromYakitResourceRequest, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, Yak_UpdateFromYakitResource_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) UpdateFromGithub(ctx context.Context, in *UpdateFromGithubRequest, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, Yak_UpdateFromGithub_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) AddToMenu(ctx context.Context, in *AddToMenuRequest, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, Yak_AddToMenu_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) RemoveFromMenu(ctx context.Context, in *RemoveFromMenuRequest, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, Yak_RemoveFromMenu_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) YakScriptIsInMenu(ctx context.Context, in *YakScriptIsInMenuRequest, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, Yak_YakScriptIsInMenu_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) GetAllMenuItem(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*MenuByGroup, error) {
	out := new(MenuByGroup)
	err := c.cc.Invoke(ctx, Yak_GetAllMenuItem_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) DeleteAllMenuItem(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, Yak_DeleteAllMenuItem_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) ImportMenuItem(ctx context.Context, in *ImportMenuItemRequest, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, Yak_ImportMenuItem_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) ExportMenuItem(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*ExportMenuItemResult, error) {
	out := new(ExportMenuItemResult)
	err := c.cc.Invoke(ctx, Yak_ExportMenuItem_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) GetMenuItemById(ctx context.Context, in *GetMenuItemByIdRequest, opts ...grpc.CallOption) (*MenuItem, error) {
	out := new(MenuItem)
	err := c.cc.Invoke(ctx, Yak_GetMenuItemById_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) QueryGroupsByYakScriptId(ctx context.Context, in *QueryGroupsByYakScriptIdRequest, opts ...grpc.CallOption) (*GroupNames, error) {
	out := new(GroupNames)
	err := c.cc.Invoke(ctx, Yak_QueryGroupsByYakScriptId_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) AddMenus(ctx context.Context, in *AddMenuRequest, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, Yak_AddMenus_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) QueryAllMenuItem(ctx context.Context, in *QueryAllMenuItemRequest, opts ...grpc.CallOption) (*MenuByGroup, error) {
	out := new(MenuByGroup)
	err := c.cc.Invoke(ctx, Yak_QueryAllMenuItem_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) DeleteAllMenu(ctx context.Context, in *QueryAllMenuItemRequest, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, Yak_DeleteAllMenu_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) AddToNavigation(ctx context.Context, in *AddToNavigationRequest, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, Yak_AddToNavigation_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) GetAllNavigationItem(ctx context.Context, in *GetAllNavigationRequest, opts ...grpc.CallOption) (*GetAllNavigationItemResponse, error) {
	out := new(GetAllNavigationItemResponse)
	err := c.cc.Invoke(ctx, Yak_GetAllNavigationItem_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) DeleteAllNavigation(ctx context.Context, in *GetAllNavigationRequest, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, Yak_DeleteAllNavigation_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) AddOneNavigation(ctx context.Context, in *AddOneNavigationRequest, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, Yak_AddOneNavigation_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) QueryNavigationGroups(ctx context.Context, in *QueryNavigationGroupsRequest, opts ...grpc.CallOption) (*GroupNames, error) {
	out := new(GroupNames)
	err := c.cc.Invoke(ctx, Yak_QueryNavigationGroups_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) SaveMarkdownDocument(ctx context.Context, in *SaveMarkdownDocumentRequest, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, Yak_SaveMarkdownDocument_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) GetMarkdownDocument(ctx context.Context, in *GetMarkdownDocumentRequest, opts ...grpc.CallOption) (*GetMarkdownDocumentResponse, error) {
	out := new(GetMarkdownDocumentResponse)
	err := c.cc.Invoke(ctx, Yak_GetMarkdownDocument_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) DeleteMarkdownDocument(ctx context.Context, in *GetMarkdownDocumentRequest, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, Yak_DeleteMarkdownDocument_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) StartBasicCrawler(ctx context.Context, in *StartBasicCrawlerRequest, opts ...grpc.CallOption) (*ExecResult, error) {
	out := new(ExecResult)
	err := c.cc.Invoke(ctx, Yak_StartBasicCrawler_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) ViewBasicCrawlerCode(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*SimpleScript, error) {
	out := new(SimpleScript)
	err := c.cc.Invoke(ctx, Yak_ViewBasicCrawlerCode_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) GenerateWebsiteTree(ctx context.Context, in *GenerateWebsiteTreeRequest, opts ...grpc.CallOption) (*GenerateWebsiteTreeResponse, error) {
	out := new(GenerateWebsiteTreeResponse)
	err := c.cc.Invoke(ctx, Yak_GenerateWebsiteTree_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) QueryYakScriptExecResult(ctx context.Context, in *QueryYakScriptExecResultRequest, opts ...grpc.CallOption) (*QueryYakScriptExecResultResponse, error) {
	out := new(QueryYakScriptExecResultResponse)
	err := c.cc.Invoke(ctx, Yak_QueryYakScriptExecResult_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) QueryYakScriptNameInExecResult(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*YakScriptNames, error) {
	out := new(YakScriptNames)
	err := c.cc.Invoke(ctx, Yak_QueryYakScriptNameInExecResult_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) DeleteYakScriptExecResult(ctx context.Context, in *DeleteYakScriptExecResultRequest, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, Yak_DeleteYakScriptExecResult_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) DeleteYakScriptExec(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, Yak_DeleteYakScriptExec_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) StartBrute(ctx context.Context, in *StartBruteParams, opts ...grpc.CallOption) (Yak_StartBruteClient, error) {
	stream, err := c.cc.NewStream(ctx, &Yak_ServiceDesc.Streams[17], Yak_StartBrute_FullMethodName, opts...)
	if err != nil {
		return nil, err
	}
	x := &yakStartBruteClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Yak_StartBruteClient interface {
	Recv() (*ExecResult, error)
	grpc.ClientStream
}

type yakStartBruteClient struct {
	grpc.ClientStream
}

func (x *yakStartBruteClient) Recv() (*ExecResult, error) {
	m := new(ExecResult)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *yakClient) GetAvailableBruteTypes(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*GetAvailableBruteTypesResponse, error) {
	out := new(GetAvailableBruteTypesResponse)
	err := c.cc.Invoke(ctx, Yak_GetAvailableBruteTypes_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) GetTunnelServerExternalIP(ctx context.Context, in *GetTunnelServerExternalIPParams, opts ...grpc.CallOption) (*GetTunnelServerExternalIPResponse, error) {
	out := new(GetTunnelServerExternalIPResponse)
	err := c.cc.Invoke(ctx, Yak_GetTunnelServerExternalIP_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) VerifyTunnelServerDomain(ctx context.Context, in *VerifyTunnelServerDomainParams, opts ...grpc.CallOption) (*VerifyTunnelServerDomainResponse, error) {
	out := new(VerifyTunnelServerDomainResponse)
	err := c.cc.Invoke(ctx, Yak_VerifyTunnelServerDomain_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) StartFacades(ctx context.Context, in *StartFacadesParams, opts ...grpc.CallOption) (Yak_StartFacadesClient, error) {
	stream, err := c.cc.NewStream(ctx, &Yak_ServiceDesc.Streams[18], Yak_StartFacades_FullMethodName, opts...)
	if err != nil {
		return nil, err
	}
	x := &yakStartFacadesClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Yak_StartFacadesClient interface {
	Recv() (*ExecResult, error)
	grpc.ClientStream
}

type yakStartFacadesClient struct {
	grpc.ClientStream
}

func (x *yakStartFacadesClient) Recv() (*ExecResult, error) {
	m := new(ExecResult)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *yakClient) StartFacadesWithYsoObject(ctx context.Context, in *StartFacadesWithYsoParams, opts ...grpc.CallOption) (Yak_StartFacadesWithYsoObjectClient, error) {
	stream, err := c.cc.NewStream(ctx, &Yak_ServiceDesc.Streams[19], Yak_StartFacadesWithYsoObject_FullMethodName, opts...)
	if err != nil {
		return nil, err
	}
	x := &yakStartFacadesWithYsoObjectClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Yak_StartFacadesWithYsoObjectClient interface {
	Recv() (*ExecResult, error)
	grpc.ClientStream
}

type yakStartFacadesWithYsoObjectClient struct {
	grpc.ClientStream
}

func (x *yakStartFacadesWithYsoObjectClient) Recv() (*ExecResult, error) {
	m := new(ExecResult)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *yakClient) ApplyClassToFacades(ctx context.Context, in *ApplyClassToFacadesParamsWithVerbose, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, Yak_ApplyClassToFacades_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) BytesToBase64(ctx context.Context, in *BytesToBase64Request, opts ...grpc.CallOption) (*BytesToBase64Response, error) {
	out := new(BytesToBase64Response)
	err := c.cc.Invoke(ctx, Yak_BytesToBase64_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) ConfigGlobalReverse(ctx context.Context, in *ConfigGlobalReverseParams, opts ...grpc.CallOption) (Yak_ConfigGlobalReverseClient, error) {
	stream, err := c.cc.NewStream(ctx, &Yak_ServiceDesc.Streams[20], Yak_ConfigGlobalReverse_FullMethodName, opts...)
	if err != nil {
		return nil, err
	}
	x := &yakConfigGlobalReverseClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Yak_ConfigGlobalReverseClient interface {
	Recv() (*Empty, error)
	grpc.ClientStream
}

type yakConfigGlobalReverseClient struct {
	grpc.ClientStream
}

func (x *yakConfigGlobalReverseClient) Recv() (*Empty, error) {
	m := new(Empty)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *yakClient) AvailableLocalAddr(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*AvailableLocalAddrResponse, error) {
	out := new(AvailableLocalAddrResponse)
	err := c.cc.Invoke(ctx, Yak_AvailableLocalAddr_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) GetGlobalReverseServer(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*GetGlobalReverseServerResponse, error) {
	out := new(GetGlobalReverseServerResponse)
	err := c.cc.Invoke(ctx, Yak_GetGlobalReverseServer_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) QueryRisks(ctx context.Context, in *QueryRisksRequest, opts ...grpc.CallOption) (*QueryRisksResponse, error) {
	out := new(QueryRisksResponse)
	err := c.cc.Invoke(ctx, Yak_QueryRisks_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) QueryRisk(ctx context.Context, in *QueryRiskRequest, opts ...grpc.CallOption) (*Risk, error) {
	out := new(Risk)
	err := c.cc.Invoke(ctx, Yak_QueryRisk_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) DeleteRisk(ctx context.Context, in *DeleteRiskRequest, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, Yak_DeleteRisk_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) QueryAvailableRiskType(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*Fields, error) {
	out := new(Fields)
	err := c.cc.Invoke(ctx, Yak_QueryAvailableRiskType_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) QueryAvailableRiskLevel(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*Fields, error) {
	out := new(Fields)
	err := c.cc.Invoke(ctx, Yak_QueryAvailableRiskLevel_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) QueryRiskTableStats(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*RiskTableStats, error) {
	out := new(RiskTableStats)
	err := c.cc.Invoke(ctx, Yak_QueryRiskTableStats_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) ResetRiskTableStats(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, Yak_ResetRiskTableStats_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) QueryAvailableTarget(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*Fields, error) {
	out := new(Fields)
	err := c.cc.Invoke(ctx, Yak_QueryAvailableTarget_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) QueryNewRisk(ctx context.Context, in *QueryNewRiskRequest, opts ...grpc.CallOption) (*QueryNewRiskResponse, error) {
	out := new(QueryNewRiskResponse)
	err := c.cc.Invoke(ctx, Yak_QueryNewRisk_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) NewRiskRead(ctx context.Context, in *NewRiskReadRequest, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, Yak_NewRiskRead_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) UploadRiskToOnline(ctx context.Context, in *UploadRiskToOnlineRequest, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, Yak_UploadRiskToOnline_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) QueryReports(ctx context.Context, in *QueryReportsRequest, opts ...grpc.CallOption) (*QueryReportsResponse, error) {
	out := new(QueryReportsResponse)
	err := c.cc.Invoke(ctx, Yak_QueryReports_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) QueryReport(ctx context.Context, in *QueryReportRequest, opts ...grpc.CallOption) (*Report, error) {
	out := new(Report)
	err := c.cc.Invoke(ctx, Yak_QueryReport_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) DeleteReport(ctx context.Context, in *DeleteReportRequest, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, Yak_DeleteReport_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) QueryAvailableReportFrom(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*Fields, error) {
	out := new(Fields)
	err := c.cc.Invoke(ctx, Yak_QueryAvailableReportFrom_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) DownloadReport(ctx context.Context, in *DownloadReportRequest, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, Yak_DownloadReport_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) GetAllYsoGadgetOptions(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*YsoOptionsWithVerbose, error) {
	out := new(YsoOptionsWithVerbose)
	err := c.cc.Invoke(ctx, Yak_GetAllYsoGadgetOptions_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) GetAllYsoClassOptions(ctx context.Context, in *YsoOptionsRequerstWithVerbose, opts ...grpc.CallOption) (*YsoOptionsWithVerbose, error) {
	out := new(YsoOptionsWithVerbose)
	err := c.cc.Invoke(ctx, Yak_GetAllYsoClassOptions_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) GetAllYsoClassGeneraterOptions(ctx context.Context, in *YsoOptionsRequerstWithVerbose, opts ...grpc.CallOption) (*YsoClassOptionsResponseWithVerbose, error) {
	out := new(YsoClassOptionsResponseWithVerbose)
	err := c.cc.Invoke(ctx, Yak_GetAllYsoClassGeneraterOptions_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) GenerateYsoCode(ctx context.Context, in *YsoOptionsRequerstWithVerbose, opts ...grpc.CallOption) (*YsoCodeResponse, error) {
	out := new(YsoCodeResponse)
	err := c.cc.Invoke(ctx, Yak_GenerateYsoCode_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) GenerateYsoBytes(ctx context.Context, in *YsoOptionsRequerstWithVerbose, opts ...grpc.CallOption) (*YsoBytesResponse, error) {
	out := new(YsoBytesResponse)
	err := c.cc.Invoke(ctx, Yak_GenerateYsoBytes_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) YsoDump(ctx context.Context, in *YsoBytesObject, opts ...grpc.CallOption) (*YsoDumpResponse, error) {
	out := new(YsoDumpResponse)
	err := c.cc.Invoke(ctx, Yak_YsoDump_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) SetYakBridgeLogServer(ctx context.Context, in *YakDNSLogBridgeAddr, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, Yak_SetYakBridgeLogServer_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) GetCurrentYakBridgeLogServer(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*YakDNSLogBridgeAddr, error) {
	out := new(YakDNSLogBridgeAddr)
	err := c.cc.Invoke(ctx, Yak_GetCurrentYakBridgeLogServer_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) RequireDNSLogDomain(ctx context.Context, in *YakDNSLogBridgeAddr, opts ...grpc.CallOption) (*DNSLogRootDomain, error) {
	out := new(DNSLogRootDomain)
	err := c.cc.Invoke(ctx, Yak_RequireDNSLogDomain_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) QueryDNSLogByToken(ctx context.Context, in *QueryDNSLogByTokenRequest, opts ...grpc.CallOption) (*QueryDNSLogByTokenResponse, error) {
	out := new(QueryDNSLogByTokenResponse)
	err := c.cc.Invoke(ctx, Yak_QueryDNSLogByToken_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) RequireICMPRandomLength(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*RequireICMPRandomLengthResponse, error) {
	out := new(RequireICMPRandomLengthResponse)
	err := c.cc.Invoke(ctx, Yak_RequireICMPRandomLength_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) QueryICMPTrigger(ctx context.Context, in *QueryICMPTriggerRequest, opts ...grpc.CallOption) (*QueryICMPTriggerResponse, error) {
	out := new(QueryICMPTriggerResponse)
	err := c.cc.Invoke(ctx, Yak_QueryICMPTrigger_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) RequireRandomPortToken(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*RandomPortInfo, error) {
	out := new(RandomPortInfo)
	err := c.cc.Invoke(ctx, Yak_RequireRandomPortToken_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) QueryRandomPortTrigger(ctx context.Context, in *QueryRandomPortTriggerRequest, opts ...grpc.CallOption) (*RandomPortTriggerNotification, error) {
	out := new(RandomPortTriggerNotification)
	err := c.cc.Invoke(ctx, Yak_QueryRandomPortTrigger_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) GetAvailableYakScriptTags(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*Fields, error) {
	out := new(Fields)
	err := c.cc.Invoke(ctx, Yak_GetAvailableYakScriptTags_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) ForceUpdateAvailableYakScriptTags(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, Yak_ForceUpdateAvailableYakScriptTags_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) ExecYakitPluginsByYakScriptFilter(ctx context.Context, in *ExecYakitPluginsByYakScriptFilterRequest, opts ...grpc.CallOption) (Yak_ExecYakitPluginsByYakScriptFilterClient, error) {
	stream, err := c.cc.NewStream(ctx, &Yak_ServiceDesc.Streams[21], Yak_ExecYakitPluginsByYakScriptFilter_FullMethodName, opts...)
	if err != nil {
		return nil, err
	}
	x := &yakExecYakitPluginsByYakScriptFilterClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Yak_ExecYakitPluginsByYakScriptFilterClient interface {
	Recv() (*ExecResult, error)
	grpc.ClientStream
}

type yakExecYakitPluginsByYakScriptFilterClient struct {
	grpc.ClientStream
}

func (x *yakExecYakitPluginsByYakScriptFilterClient) Recv() (*ExecResult, error) {
	m := new(ExecResult)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *yakClient) GenerateYakCodeByPacket(ctx context.Context, in *GenerateYakCodeByPacketRequest, opts ...grpc.CallOption) (*GenerateYakCodeByPacketResponse, error) {
	out := new(GenerateYakCodeByPacketResponse)
	err := c.cc.Invoke(ctx, Yak_GenerateYakCodeByPacket_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) GenerateCSRFPocByPacket(ctx context.Context, in *GenerateCSRFPocByPacketRequest, opts ...grpc.CallOption) (*GenerateCSRFPocByPacketResponse, error) {
	out := new(GenerateCSRFPocByPacketResponse)
	err := c.cc.Invoke(ctx, Yak_GenerateCSRFPocByPacket_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) ExportMITMReplacerRules(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*ExportMITMReplacerRulesResponse, error) {
	out := new(ExportMITMReplacerRulesResponse)
	err := c.cc.Invoke(ctx, Yak_ExportMITMReplacerRules_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) ImportMITMReplacerRules(ctx context.Context, in *ImportMITMReplacerRulesRequest, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, Yak_ImportMITMReplacerRules_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) GetCurrentRules(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*MITMContentReplacers, error) {
	out := new(MITMContentReplacers)
	err := c.cc.Invoke(ctx, Yak_GetCurrentRules_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) SetCurrentRules(ctx context.Context, in *MITMContentReplacers, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, Yak_SetCurrentRules_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) ExtractDataToFile(ctx context.Context, opts ...grpc.CallOption) (Yak_ExtractDataToFileClient, error) {
	stream, err := c.cc.NewStream(ctx, &Yak_ServiceDesc.Streams[22], Yak_ExtractDataToFile_FullMethodName, opts...)
	if err != nil {
		return nil, err
	}
	x := &yakExtractDataToFileClient{stream}
	return x, nil
}

type Yak_ExtractDataToFileClient interface {
	Send(*ExtractDataToFileRequest) error
	Recv() (*ExtractDataToFileResult, error)
	grpc.ClientStream
}

type yakExtractDataToFileClient struct {
	grpc.ClientStream
}

func (x *yakExtractDataToFileClient) Send(m *ExtractDataToFileRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *yakExtractDataToFileClient) Recv() (*ExtractDataToFileResult, error) {
	m := new(ExtractDataToFileResult)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *yakClient) AutoDecode(ctx context.Context, in *AutoDecodeRequest, opts ...grpc.CallOption) (*AutoDecodeResponse, error) {
	out := new(AutoDecodeResponse)
	err := c.cc.Invoke(ctx, Yak_AutoDecode_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) GetSystemProxy(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*GetSystemProxyResult, error) {
	out := new(GetSystemProxyResult)
	err := c.cc.Invoke(ctx, Yak_GetSystemProxy_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) SetSystemProxy(ctx context.Context, in *SetSystemProxyRequest, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, Yak_SetSystemProxy_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) GetKey(ctx context.Context, in *GetKeyRequest, opts ...grpc.CallOption) (*GetKeyResult, error) {
	out := new(GetKeyResult)
	err := c.cc.Invoke(ctx, Yak_GetKey_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) SetKey(ctx context.Context, in *SetKeyRequest, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, Yak_SetKey_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) DelKey(ctx context.Context, in *GetKeyRequest, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, Yak_DelKey_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) GetAllProcessEnvKey(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*GetProcessEnvKeyResult, error) {
	out := new(GetProcessEnvKeyResult)
	err := c.cc.Invoke(ctx, Yak_GetAllProcessEnvKey_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) SetProcessEnvKey(ctx context.Context, in *SetKeyRequest, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, Yak_SetProcessEnvKey_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) GetProjectKey(ctx context.Context, in *GetKeyRequest, opts ...grpc.CallOption) (*GetKeyResult, error) {
	out := new(GetKeyResult)
	err := c.cc.Invoke(ctx, Yak_GetProjectKey_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) SetProjectKey(ctx context.Context, in *SetKeyRequest, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, Yak_SetProjectKey_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) GetOnlineProfile(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*OnlineProfile, error) {
	out := new(OnlineProfile)
	err := c.cc.Invoke(ctx, Yak_GetOnlineProfile_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) SetOnlineProfile(ctx context.Context, in *OnlineProfile, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, Yak_SetOnlineProfile_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) DownloadOnlinePluginById(ctx context.Context, in *DownloadOnlinePluginByIdRequest, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, Yak_DownloadOnlinePluginById_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) DownloadOnlinePluginByIds(ctx context.Context, in *DownloadOnlinePluginByIdsRequest, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, Yak_DownloadOnlinePluginByIds_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) DownloadOnlinePluginAll(ctx context.Context, in *DownloadOnlinePluginByTokenRequest, opts ...grpc.CallOption) (Yak_DownloadOnlinePluginAllClient, error) {
	stream, err := c.cc.NewStream(ctx, &Yak_ServiceDesc.Streams[23], Yak_DownloadOnlinePluginAll_FullMethodName, opts...)
	if err != nil {
		return nil, err
	}
	x := &yakDownloadOnlinePluginAllClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Yak_DownloadOnlinePluginAllClient interface {
	Recv() (*DownloadOnlinePluginProgress, error)
	grpc.ClientStream
}

type yakDownloadOnlinePluginAllClient struct {
	grpc.ClientStream
}

func (x *yakDownloadOnlinePluginAllClient) Recv() (*DownloadOnlinePluginProgress, error) {
	m := new(DownloadOnlinePluginProgress)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *yakClient) DeletePluginByUserID(ctx context.Context, in *DeletePluginByUserIDRequest, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, Yak_DeletePluginByUserID_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) DeleteAllLocalPlugins(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, Yak_DeleteAllLocalPlugins_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) GetYakScriptTagsAndType(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*GetYakScriptTagsAndTypeResponse, error) {
	out := new(GetYakScriptTagsAndTypeResponse)
	err := c.cc.Invoke(ctx, Yak_GetYakScriptTagsAndType_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) DeleteLocalPluginsByWhere(ctx context.Context, in *DeleteLocalPluginsByWhereRequest, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, Yak_DeleteLocalPluginsByWhere_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) DownloadOnlinePluginByScriptNames(ctx context.Context, in *DownloadOnlinePluginByScriptNamesRequest, opts ...grpc.CallOption) (*DownloadOnlinePluginByScriptNamesResponse, error) {
	out := new(DownloadOnlinePluginByScriptNamesResponse)
	err := c.cc.Invoke(ctx, Yak_DownloadOnlinePluginByScriptNames_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) ExecPacketScan(ctx context.Context, in *ExecPacketScanRequest, opts ...grpc.CallOption) (Yak_ExecPacketScanClient, error) {
	stream, err := c.cc.NewStream(ctx, &Yak_ServiceDesc.Streams[24], Yak_ExecPacketScan_FullMethodName, opts...)
	if err != nil {
		return nil, err
	}
	x := &yakExecPacketScanClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Yak_ExecPacketScanClient interface {
	Recv() (*ExecResult, error)
	grpc.ClientStream
}

type yakExecPacketScanClient struct {
	grpc.ClientStream
}

func (x *yakExecPacketScanClient) Recv() (*ExecResult, error) {
	m := new(ExecResult)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *yakClient) GetEngineDefaultProxy(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*DefaultProxyResult, error) {
	out := new(DefaultProxyResult)
	err := c.cc.Invoke(ctx, Yak_GetEngineDefaultProxy_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) SetEngineDefaultProxy(ctx context.Context, in *DefaultProxyResult, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, Yak_SetEngineDefaultProxy_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) GetMachineID(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*GetMachineIDResponse, error) {
	out := new(GetMachineIDResponse)
	err := c.cc.Invoke(ctx, Yak_GetMachineID_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) GetLicense(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*GetLicenseResponse, error) {
	out := new(GetLicenseResponse)
	err := c.cc.Invoke(ctx, Yak_GetLicense_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) CheckLicense(ctx context.Context, in *CheckLicenseRequest, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, Yak_CheckLicense_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) GetRequestBodyByHTTPFlowID(ctx context.Context, in *DownloadBodyByHTTPFlowIDRequest, opts ...grpc.CallOption) (*Bytes, error) {
	out := new(Bytes)
	err := c.cc.Invoke(ctx, Yak_GetRequestBodyByHTTPFlowID_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) GetResponseBodyByHTTPFlowID(ctx context.Context, in *DownloadBodyByHTTPFlowIDRequest, opts ...grpc.CallOption) (*Bytes, error) {
	out := new(Bytes)
	err := c.cc.Invoke(ctx, Yak_GetResponseBodyByHTTPFlowID_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) GetHTTPPacketBody(ctx context.Context, in *GetHTTPPacketBodyRequest, opts ...grpc.CallOption) (*Bytes, error) {
	out := new(Bytes)
	err := c.cc.Invoke(ctx, Yak_GetHTTPPacketBody_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) RegisterFacadesHTTP(ctx context.Context, in *RegisterFacadesHTTPRequest, opts ...grpc.CallOption) (*RegisterFacadesHTTPResponse, error) {
	out := new(RegisterFacadesHTTPResponse)
	err := c.cc.Invoke(ctx, Yak_RegisterFacadesHTTP_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) ResetAndInvalidUserData(ctx context.Context, in *ResetAndInvalidUserDataRequest, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, Yak_ResetAndInvalidUserData_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) CreateYaklangShell(ctx context.Context, opts ...grpc.CallOption) (Yak_CreateYaklangShellClient, error) {
	stream, err := c.cc.NewStream(ctx, &Yak_ServiceDesc.Streams[25], Yak_CreateYaklangShell_FullMethodName, opts...)
	if err != nil {
		return nil, err
	}
	x := &yakCreateYaklangShellClient{stream}
	return x, nil
}

type Yak_CreateYaklangShellClient interface {
	Send(*YaklangShellRequest) error
	Recv() (*YaklangShellResponse, error)
	grpc.ClientStream
}

type yakCreateYaklangShellClient struct {
	grpc.ClientStream
}

func (x *yakCreateYaklangShellClient) Send(m *YaklangShellRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *yakCreateYaklangShellClient) Recv() (*YaklangShellResponse, error) {
	m := new(YaklangShellResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *yakClient) AttachCombinedOutput(ctx context.Context, in *AttachCombinedOutputRequest, opts ...grpc.CallOption) (Yak_AttachCombinedOutputClient, error) {
	stream, err := c.cc.NewStream(ctx, &Yak_ServiceDesc.Streams[26], Yak_AttachCombinedOutput_FullMethodName, opts...)
	if err != nil {
		return nil, err
	}
	x := &yakAttachCombinedOutputClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Yak_AttachCombinedOutputClient interface {
	Recv() (*ExecResult, error)
	grpc.ClientStream
}

type yakAttachCombinedOutputClient struct {
	grpc.ClientStream
}

func (x *yakAttachCombinedOutputClient) Recv() (*ExecResult, error) {
	m := new(ExecResult)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *yakClient) IsPrivilegedForNetRaw(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*IsPrivilegedForNetRawResponse, error) {
	out := new(IsPrivilegedForNetRawResponse)
	err := c.cc.Invoke(ctx, Yak_IsPrivilegedForNetRaw_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) PromotePermissionForUserPcap(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, Yak_PromotePermissionForUserPcap_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) SetCurrentProject(ctx context.Context, in *SetCurrentProjectRequest, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, Yak_SetCurrentProject_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) GetCurrentProject(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*ProjectDescription, error) {
	out := new(ProjectDescription)
	err := c.cc.Invoke(ctx, Yak_GetCurrentProject_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) GetProjects(ctx context.Context, in *GetProjectsRequest, opts ...grpc.CallOption) (*GetProjectsResponse, error) {
	out := new(GetProjectsResponse)
	err := c.cc.Invoke(ctx, Yak_GetProjects_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) NewProject(ctx context.Context, in *NewProjectRequest, opts ...grpc.CallOption) (*NewProjectResponse, error) {
	out := new(NewProjectResponse)
	err := c.cc.Invoke(ctx, Yak_NewProject_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) IsProjectNameValid(ctx context.Context, in *IsProjectNameValidRequest, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, Yak_IsProjectNameValid_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) RemoveProject(ctx context.Context, in *RemoveProjectRequest, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, Yak_RemoveProject_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) DeleteProject(ctx context.Context, in *DeleteProjectRequest, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, Yak_DeleteProject_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) GetDefaultProject(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*ProjectDescription, error) {
	out := new(ProjectDescription)
	err := c.cc.Invoke(ctx, Yak_GetDefaultProject_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) QueryProjectDetail(ctx context.Context, in *QueryProjectDetailRequest, opts ...grpc.CallOption) (*ProjectDescription, error) {
	out := new(ProjectDescription)
	err := c.cc.Invoke(ctx, Yak_QueryProjectDetail_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) ExportProject(ctx context.Context, in *ExportProjectRequest, opts ...grpc.CallOption) (Yak_ExportProjectClient, error) {
	stream, err := c.cc.NewStream(ctx, &Yak_ServiceDesc.Streams[27], Yak_ExportProject_FullMethodName, opts...)
	if err != nil {
		return nil, err
	}
	x := &yakExportProjectClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Yak_ExportProjectClient interface {
	Recv() (*ProjectIOProgress, error)
	grpc.ClientStream
}

type yakExportProjectClient struct {
	grpc.ClientStream
}

func (x *yakExportProjectClient) Recv() (*ProjectIOProgress, error) {
	m := new(ProjectIOProgress)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *yakClient) ImportProject(ctx context.Context, in *ImportProjectRequest, opts ...grpc.CallOption) (Yak_ImportProjectClient, error) {
	stream, err := c.cc.NewStream(ctx, &Yak_ServiceDesc.Streams[28], Yak_ImportProject_FullMethodName, opts...)
	if err != nil {
		return nil, err
	}
	x := &yakImportProjectClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Yak_ImportProjectClient interface {
	Recv() (*ProjectIOProgress, error)
	grpc.ClientStream
}

type yakImportProjectClient struct {
	grpc.ClientStream
}

func (x *yakImportProjectClient) Recv() (*ProjectIOProgress, error) {
	m := new(ProjectIOProgress)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *yakClient) MigrateLegacyDatabase(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, Yak_MigrateLegacyDatabase_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) QueryMITMRuleExtractedData(ctx context.Context, in *QueryMITMRuleExtractedDataRequest, opts ...grpc.CallOption) (*QueryMITMRuleExtractedDataResponse, error) {
	out := new(QueryMITMRuleExtractedDataResponse)
	err := c.cc.Invoke(ctx, Yak_QueryMITMRuleExtractedData_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) ImportChaosMakerRules(ctx context.Context, in *ImportChaosMakerRulesRequest, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, Yak_ImportChaosMakerRules_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) QueryChaosMakerRule(ctx context.Context, in *QueryChaosMakerRuleRequest, opts ...grpc.CallOption) (*QueryChaosMakerRuleResponse, error) {
	out := new(QueryChaosMakerRuleResponse)
	err := c.cc.Invoke(ctx, Yak_QueryChaosMakerRule_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) DeleteChaosMakerRuleByID(ctx context.Context, in *DeleteChaosMakerRuleByIDRequest, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, Yak_DeleteChaosMakerRuleByID_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) ExecuteChaosMakerRule(ctx context.Context, in *ExecuteChaosMakerRuleRequest, opts ...grpc.CallOption) (Yak_ExecuteChaosMakerRuleClient, error) {
	stream, err := c.cc.NewStream(ctx, &Yak_ServiceDesc.Streams[29], Yak_ExecuteChaosMakerRule_FullMethodName, opts...)
	if err != nil {
		return nil, err
	}
	x := &yakExecuteChaosMakerRuleClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Yak_ExecuteChaosMakerRuleClient interface {
	Recv() (*ExecResult, error)
	grpc.ClientStream
}

type yakExecuteChaosMakerRuleClient struct {
	grpc.ClientStream
}

func (x *yakExecuteChaosMakerRuleClient) Recv() (*ExecResult, error) {
	m := new(ExecResult)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *yakClient) IsRemoteAddrAvailable(ctx context.Context, in *IsRemoteAddrAvailableRequest, opts ...grpc.CallOption) (*IsRemoteAddrAvailableResponse, error) {
	out := new(IsRemoteAddrAvailableResponse)
	err := c.cc.Invoke(ctx, Yak_IsRemoteAddrAvailable_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) ConnectVulinboxAgent(ctx context.Context, in *IsRemoteAddrAvailableRequest, opts ...grpc.CallOption) (*IsRemoteAddrAvailableResponse, error) {
	out := new(IsRemoteAddrAvailableResponse)
	err := c.cc.Invoke(ctx, Yak_ConnectVulinboxAgent_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) GetRegisteredVulinboxAgent(ctx context.Context, in *GetRegisteredAgentRequest, opts ...grpc.CallOption) (*GetRegisteredAgentResponse, error) {
	out := new(GetRegisteredAgentResponse)
	err := c.cc.Invoke(ctx, Yak_GetRegisteredVulinboxAgent_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) DisconnectVulinboxAgent(ctx context.Context, in *DisconnectVulinboxAgentRequest, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, Yak_DisconnectVulinboxAgent_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) IsCVEDatabaseReady(ctx context.Context, in *IsCVEDatabaseReadyRequest, opts ...grpc.CallOption) (*IsCVEDatabaseReadyResponse, error) {
	out := new(IsCVEDatabaseReadyResponse)
	err := c.cc.Invoke(ctx, Yak_IsCVEDatabaseReady_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) UpdateCVEDatabase(ctx context.Context, in *UpdateCVEDatabaseRequest, opts ...grpc.CallOption) (Yak_UpdateCVEDatabaseClient, error) {
	stream, err := c.cc.NewStream(ctx, &Yak_ServiceDesc.Streams[30], Yak_UpdateCVEDatabase_FullMethodName, opts...)
	if err != nil {
		return nil, err
	}
	x := &yakUpdateCVEDatabaseClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Yak_UpdateCVEDatabaseClient interface {
	Recv() (*ExecResult, error)
	grpc.ClientStream
}

type yakUpdateCVEDatabaseClient struct {
	grpc.ClientStream
}

func (x *yakUpdateCVEDatabaseClient) Recv() (*ExecResult, error) {
	m := new(ExecResult)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *yakClient) ExportsProfileDatabase(ctx context.Context, in *ExportsProfileDatabaseRequest, opts ...grpc.CallOption) (Yak_ExportsProfileDatabaseClient, error) {
	stream, err := c.cc.NewStream(ctx, &Yak_ServiceDesc.Streams[31], Yak_ExportsProfileDatabase_FullMethodName, opts...)
	if err != nil {
		return nil, err
	}
	x := &yakExportsProfileDatabaseClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Yak_ExportsProfileDatabaseClient interface {
	Recv() (*ExecResult, error)
	grpc.ClientStream
}

type yakExportsProfileDatabaseClient struct {
	grpc.ClientStream
}

func (x *yakExportsProfileDatabaseClient) Recv() (*ExecResult, error) {
	m := new(ExecResult)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *yakClient) ImportsProfileDatabase(ctx context.Context, in *ImportsProfileDatabaseRequest, opts ...grpc.CallOption) (Yak_ImportsProfileDatabaseClient, error) {
	stream, err := c.cc.NewStream(ctx, &Yak_ServiceDesc.Streams[32], Yak_ImportsProfileDatabase_FullMethodName, opts...)
	if err != nil {
		return nil, err
	}
	x := &yakImportsProfileDatabaseClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Yak_ImportsProfileDatabaseClient interface {
	Recv() (*ExecResult, error)
	grpc.ClientStream
}

type yakImportsProfileDatabaseClient struct {
	grpc.ClientStream
}

func (x *yakImportsProfileDatabaseClient) Recv() (*ExecResult, error) {
	m := new(ExecResult)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *yakClient) QueryCVE(ctx context.Context, in *QueryCVERequest, opts ...grpc.CallOption) (*QueryCVEResponse, error) {
	out := new(QueryCVEResponse)
	err := c.cc.Invoke(ctx, Yak_QueryCVE_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) GetCVE(ctx context.Context, in *GetCVERequest, opts ...grpc.CallOption) (*CVEDetailEx, error) {
	out := new(CVEDetailEx)
	err := c.cc.Invoke(ctx, Yak_GetCVE_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) SaveTextToTemporalFile(ctx context.Context, in *SaveTextToTemporalFileRequest, opts ...grpc.CallOption) (*SaveTextToTemporalFileResponse, error) {
	out := new(SaveTextToTemporalFileResponse)
	err := c.cc.Invoke(ctx, Yak_SaveTextToTemporalFile_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) IsScrecorderReady(ctx context.Context, in *IsScrecorderReadyRequest, opts ...grpc.CallOption) (*IsScrecorderReadyResponse, error) {
	out := new(IsScrecorderReadyResponse)
	err := c.cc.Invoke(ctx, Yak_IsScrecorderReady_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) InstallScrecorder(ctx context.Context, in *InstallScrecorderRequest, opts ...grpc.CallOption) (Yak_InstallScrecorderClient, error) {
	stream, err := c.cc.NewStream(ctx, &Yak_ServiceDesc.Streams[33], Yak_InstallScrecorder_FullMethodName, opts...)
	if err != nil {
		return nil, err
	}
	x := &yakInstallScrecorderClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Yak_InstallScrecorderClient interface {
	Recv() (*ExecResult, error)
	grpc.ClientStream
}

type yakInstallScrecorderClient struct {
	grpc.ClientStream
}

func (x *yakInstallScrecorderClient) Recv() (*ExecResult, error) {
	m := new(ExecResult)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *yakClient) StartScrecorder(ctx context.Context, in *StartScrecorderRequest, opts ...grpc.CallOption) (Yak_StartScrecorderClient, error) {
	stream, err := c.cc.NewStream(ctx, &Yak_ServiceDesc.Streams[34], Yak_StartScrecorder_FullMethodName, opts...)
	if err != nil {
		return nil, err
	}
	x := &yakStartScrecorderClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Yak_StartScrecorderClient interface {
	Recv() (*ExecResult, error)
	grpc.ClientStream
}

type yakStartScrecorderClient struct {
	grpc.ClientStream
}

func (x *yakStartScrecorderClient) Recv() (*ExecResult, error) {
	m := new(ExecResult)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *yakClient) QueryScreenRecorders(ctx context.Context, in *QueryScreenRecorderRequest, opts ...grpc.CallOption) (*QueryScreenRecorderResponse, error) {
	out := new(QueryScreenRecorderResponse)
	err := c.cc.Invoke(ctx, Yak_QueryScreenRecorders_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) DeleteScreenRecorders(ctx context.Context, in *QueryScreenRecorderRequest, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, Yak_DeleteScreenRecorders_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) UploadScreenRecorders(ctx context.Context, in *UploadScreenRecorderRequest, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, Yak_UploadScreenRecorders_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) GetOneScreenRecorders(ctx context.Context, in *GetOneScreenRecorderRequest, opts ...grpc.CallOption) (*ScreenRecorder, error) {
	out := new(ScreenRecorder)
	err := c.cc.Invoke(ctx, Yak_GetOneScreenRecorders_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) UpdateScreenRecorders(ctx context.Context, in *UpdateScreenRecorderRequest, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, Yak_UpdateScreenRecorders_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) IsVulinboxReady(ctx context.Context, in *IsVulinboxReadyRequest, opts ...grpc.CallOption) (*IsVulinboxReadyResponse, error) {
	out := new(IsVulinboxReadyResponse)
	err := c.cc.Invoke(ctx, Yak_IsVulinboxReady_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) InstallVulinbox(ctx context.Context, in *InstallVulinboxRequest, opts ...grpc.CallOption) (Yak_InstallVulinboxClient, error) {
	stream, err := c.cc.NewStream(ctx, &Yak_ServiceDesc.Streams[35], Yak_InstallVulinbox_FullMethodName, opts...)
	if err != nil {
		return nil, err
	}
	x := &yakInstallVulinboxClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Yak_InstallVulinboxClient interface {
	Recv() (*ExecResult, error)
	grpc.ClientStream
}

type yakInstallVulinboxClient struct {
	grpc.ClientStream
}

func (x *yakInstallVulinboxClient) Recv() (*ExecResult, error) {
	m := new(ExecResult)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *yakClient) StartVulinbox(ctx context.Context, in *StartVulinboxRequest, opts ...grpc.CallOption) (Yak_StartVulinboxClient, error) {
	stream, err := c.cc.NewStream(ctx, &Yak_ServiceDesc.Streams[36], Yak_StartVulinbox_FullMethodName, opts...)
	if err != nil {
		return nil, err
	}
	x := &yakStartVulinboxClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Yak_StartVulinboxClient interface {
	Recv() (*ExecResult, error)
	grpc.ClientStream
}

type yakStartVulinboxClient struct {
	grpc.ClientStream
}

func (x *yakStartVulinboxClient) Recv() (*ExecResult, error) {
	m := new(ExecResult)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *yakClient) HTTPRequestBuilder(ctx context.Context, in *HTTPRequestBuilderParams, opts ...grpc.CallOption) (*HTTPRequestBuilderResponse, error) {
	out := new(HTTPRequestBuilderResponse)
	err := c.cc.Invoke(ctx, Yak_HTTPRequestBuilder_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) DebugPlugin(ctx context.Context, in *DebugPluginRequest, opts ...grpc.CallOption) (Yak_DebugPluginClient, error) {
	stream, err := c.cc.NewStream(ctx, &Yak_ServiceDesc.Streams[37], Yak_DebugPlugin_FullMethodName, opts...)
	if err != nil {
		return nil, err
	}
	x := &yakDebugPluginClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Yak_DebugPluginClient interface {
	Recv() (*ExecResult, error)
	grpc.ClientStream
}

type yakDebugPluginClient struct {
	grpc.ClientStream
}

func (x *yakDebugPluginClient) Recv() (*ExecResult, error) {
	m := new(ExecResult)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *yakClient) SmokingEvaluatePlugin(ctx context.Context, in *SmokingEvaluatePluginRequest, opts ...grpc.CallOption) (*SmokingEvaluatePluginResponse, error) {
	out := new(SmokingEvaluatePluginResponse)
	err := c.cc.Invoke(ctx, Yak_SmokingEvaluatePlugin_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yakClient) GetSystemDefaultDnsServers(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*DefaultDnsServerResponse, error) {
	out := new(DefaultDnsServerResponse)
	err := c.cc.Invoke(ctx, Yak_GetSystemDefaultDnsServers_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// YakServer is the server API for Yak service.
// All implementations must embed UnimplementedYakServer
// for forward compatibility
type YakServer interface {
	// version
	Version(context.Context, *Empty) (*VersionResponse, error)
	// echo 通常用于测试服务是否通畅
	Echo(context.Context, *EchoRequest) (*EchoResposne, error)
	// 中间人劫持
	MITM(Yak_MITMServer) error
	SetMITMFilter(context.Context, *SetMITMFilterRequest) (*SetMITMFilterResponse, error)
	GetMITMFilter(context.Context, *Empty) (*SetMITMFilterRequest, error)
	DownloadMITMCert(context.Context, *Empty) (*MITMCert, error)
	// 开启端口
	OpenPort(Yak_OpenPortServer) error
	// Exec
	Exec(*ExecRequest, Yak_ExecServer) error
	QueryExecHistory(context.Context, *ExecHistoryRequest) (*ExecHistoryRecordResponse, error)
	RemoveExecHistory(context.Context, *Empty) (*Empty, error)
	LoadNucleiTemplates(context.Context, *Empty) (*Empty, error)
	AutoUpdateYakModule(*Empty, Yak_AutoUpdateYakModuleServer) error
	ExecYakScript(*ExecRequest, Yak_ExecYakScriptServer) error
	ExecBatchYakScript(*ExecBatchYakScriptRequest, Yak_ExecBatchYakScriptServer) error
	GetExecBatchYakScriptUnfinishedTask(context.Context, *Empty) (*GetExecBatchYakScriptUnfinishedTaskResponse, error)
	GetExecBatchYakScriptUnfinishedTaskByUid(context.Context, *GetExecBatchYakScriptUnfinishedTaskByUidRequest) (*ExecBatchYakScriptRequest, error)
	PopExecBatchYakScriptUnfinishedTaskByUid(context.Context, *GetExecBatchYakScriptUnfinishedTaskByUidRequest) (*ExecBatchYakScriptRequest, error)
	RecoverExecBatchYakScriptUnfinishedTask(*RecoverExecBatchYakScriptUnfinishedTaskRequest, Yak_RecoverExecBatchYakScriptUnfinishedTaskServer) error
	// yakScript
	QueryYakScript(context.Context, *QueryYakScriptRequest) (*QueryYakScriptResponse, error)
	QueryYakScriptByYakScriptName(*QueryYakScriptRequest, Yak_QueryYakScriptByYakScriptNameServer) error
	SaveYakScript(context.Context, *YakScript) (*YakScript, error)
	DeleteYakScript(context.Context, *DeleteYakScriptRequest) (*Empty, error)
	GetYakScriptById(context.Context, *GetYakScriptByIdRequest) (*YakScript, error)
	GetYakScriptByName(context.Context, *GetYakScriptByNameRequest) (*YakScript, error)
	GetYakScriptByOnlineID(context.Context, *GetYakScriptByOnlineIDRequest) (*YakScript, error)
	IgnoreYakScript(context.Context, *DeleteYakScriptRequest) (*Empty, error)
	UnIgnoreYakScript(context.Context, *DeleteYakScriptRequest) (*Empty, error)
	ExportYakScript(context.Context, *ExportYakScriptRequest) (*ExportYakScriptResponse, error)
	ExecutePacketYakScript(*ExecutePacketYakScriptParams, Yak_ExecutePacketYakScriptServer) error
	ExecuteBatchPacketYakScript(*ExecuteBatchPacketYakScriptParams, Yak_ExecuteBatchPacketYakScriptServer) error
	GetYakScriptTags(context.Context, *Empty) (*GetYakScriptTagsResponse, error)
	QueryYakScriptLocalAndUser(context.Context, *QueryYakScriptLocalAndUserRequest) (*QueryYakScriptLocalAndUserResponse, error)
	QueryYakScriptByOnlineGroup(context.Context, *QueryYakScriptByOnlineGroupRequest) (*QueryYakScriptLocalAndUserResponse, error)
	QueryYakScriptLocalAll(context.Context, *Empty) (*QueryYakScriptLocalAndUserResponse, error)
	QueryYakScriptByNames(context.Context, *QueryYakScriptByNamesRequest) (*QueryYakScriptByNamesResponse, error)
	// HTTPFlow
	GetHTTPFlowByHash(context.Context, *GetHTTPFlowByHashRequest) (*HTTPFlow, error)
	GetHTTPFlowById(context.Context, *GetHTTPFlowByIdRequest) (*HTTPFlow, error)
	GetHTTPFlowByIds(context.Context, *GetHTTPFlowByIdsRequest) (*HTTPFlows, error)
	QueryHTTPFlows(context.Context, *QueryHTTPFlowRequest) (*QueryHTTPFlowResponse, error)
	DeleteHTTPFlows(context.Context, *DeleteHTTPFlowRequest) (*Empty, error)
	SetTagForHTTPFlow(context.Context, *SetTagForHTTPFlowRequest) (*Empty, error)
	QueryHTTPFlowsIds(context.Context, *QueryHTTPFlowsIdsRequest) (*QueryHTTPFlowsIdsResponse, error)
	HTTPFlowsFieldGroup(context.Context, *HTTPFlowsFieldGroupRequest) (*HTTPFlowsFieldGroupResponse, error)
	HTTPFlowsShare(context.Context, *HTTPFlowsShareRequest) (*HTTPFlowsShareResponse, error)
	HTTPFlowsExtract(context.Context, *HTTPFlowsExtractRequest) (*Empty, error)
	// 从一个 FuzzerRequest 中提取 Url
	ExtractUrl(context.Context, *FuzzerRequest) (*ExtractedUrl, error)
	// Fuzzer
	GetHistoryHTTPFuzzerTask(context.Context, *GetHistoryHTTPFuzzerTaskRequest) (*HistoryHTTPFuzzerTaskDetail, error)
	QueryHistoryHTTPFuzzerTask(context.Context, *Empty) (*HistoryHTTPFuzzerTasks, error)
	QueryHistoryHTTPFuzzerTaskEx(context.Context, *QueryHistoryHTTPFuzzerTaskExParams) (*HistoryHTTPFuzzerTasksResponse, error)
	DeleteHistoryHTTPFuzzerTask(context.Context, *DeleteHistoryHTTPFuzzerTaskRequest) (*Empty, error)
	HTTPFuzzer(*FuzzerRequest, Yak_HTTPFuzzerServer) error
	PreloadHTTPFuzzerParams(context.Context, *PreloadHTTPFuzzerParamsRequest) (*PreloadHTTPFuzzerParamsResponse, error)
	RenderVariables(context.Context, *RenderVariablesRequest) (*RenderVariablesResponse, error)
	MatchHTTPResponse(context.Context, *MatchHTTPResponseParams) (*MatchHTTPResponseResult, error)
	ExtractHTTPResponse(context.Context, *ExtractHTTPResponseParams) (*ExtractHTTPResponseResult, error)
	RedirectRequest(context.Context, *RedirectRequestParams) (*FuzzerResponse, error)
	HTTPRequestMutate(context.Context, *HTTPRequestMutateParams) (*MutateResult, error)
	HTTPResponseMutate(context.Context, *HTTPResponseMutateParams) (*MutateResult, error)
	FixUploadPacket(context.Context, *FixUploadPacketRequest) (*FixUploadPacketResponse, error)
	IsMultipartFormDataRequest(context.Context, *FixUploadPacketRequest) (*IsMultipartFormDataRequestResult, error)
	GenerateExtractRule(context.Context, *GenerateExtractRuleRequest) (*GenerateExtractRuleResponse, error)
	ExtractData(Yak_ExtractDataServer) error
	SaveFuzzerLabel(context.Context, *SaveFuzzerLabelRequest) (*Empty, error)
	QueryFuzzerLabel(context.Context, *Empty) (*QueryFuzzerLabelResponse, error)
	DeleteFuzzerLabel(context.Context, *DeleteFuzzerLabelRequest) (*Empty, error)
	// HTTPFuzzerResponse
	// 这个挺特殊的，因为数据包太多了，会卡，所以后端会保存一份，通过这个接口做缓存查询
	QueryHTTPFuzzerResponseByTaskId(context.Context, *QueryHTTPFuzzerResponseByTaskIdRequest) (*QueryHTTPFuzzerResponseByTaskIdResponse, error)
	// WebSocket
	CreateWebsocketFuzzer(Yak_CreateWebsocketFuzzerServer) error
	QueryWebsocketFlowByHTTPFlowWebsocketHash(context.Context, *QueryWebsocketFlowByHTTPFlowWebsocketHashRequest) (*WebsocketFlows, error)
	DeleteWebsocketFlowByHTTPFlowWebsocketHash(context.Context, *DeleteWebsocketFlowByHTTPFlowWebsocketHashRequest) (*Empty, error)
	DeleteWebsocketFlowAll(context.Context, *Empty) (*Empty, error)
	// FuzzerResponse 对象转 HTTPFlow：以便分析和模糊测试
	ConvertFuzzerResponseToHTTPFlow(context.Context, *FuzzerResponse) (*HTTPFlow, error)
	// 渲染 Fuzzer 模版
	StringFuzzer(context.Context, *StringFuzzerRequest) (*StringFuzzerResponse, error)
	// 分析一个 HTTP 请求详情
	HTTPRequestAnalyzer(context.Context, *HTTPRequestAnalysisMaterial) (*HTTPRequestAnalysis, error)
	// 编码解码
	Codec(context.Context, *CodecRequest) (*CodecResponse, error)
	// Payload 相关接口
	QueryPayload(context.Context, *QueryPayloadRequest) (*QueryPayloadResponse, error)
	DeletePayloadByGroup(context.Context, *DeletePayloadByGroupRequest) (*Empty, error)
	DeletePayload(context.Context, *DeletePayloadRequest) (*Empty, error)
	SavePayload(context.Context, *SavePayloadRequest) (*Empty, error)
	SavePayloadStream(*SavePayloadRequest, Yak_SavePayloadStreamServer) error
	GetAllPayloadGroup(context.Context, *Empty) (*GetAllPayloadGroupResponse, error)
	UpdatePayload(context.Context, *UpdatePayloadRequest) (*Empty, error)
	GetAllPayload(context.Context, *GetAllPayloadRequest) (*GetAllPayloadResponse, error)
	// 自动生成补全
	GetYakitCompletionRaw(context.Context, *Empty) (*YakitCompletionRawResponse, error)
	GetYakVMBuildInMethodCompletion(context.Context, *GetYakVMBuildInMethodCompletionRequest) (*GetYakVMBuildInMethodCompletionResponse, error)
	StaticAnalyzeError(context.Context, *StaticAnalyzeErrorRequest) (*StaticAnalyzeErrorResponse, error)
	YaklangCompileAndFormat(context.Context, *YaklangCompileAndFormatRequest) (*YaklangCompileAndFormatResponse, error)
	// 端口扫描的封装
	PortScan(*PortScanRequest, Yak_PortScanServer) error
	ViewPortScanCode(context.Context, *Empty) (*SimpleScript, error)
	SimpleDetect(*RecordPortScanRequest, Yak_SimpleDetectServer) error
	SaveCancelSimpleDetect(context.Context, *RecordPortScanRequest) (*Empty, error)
	GetSimpleDetectUnfinishedTask(context.Context, *Empty) (*GetSimpleDetectUnfinishedTaskResponse, error)
	GetSimpleDetectUnfinishedTaskByUid(context.Context, *GetExecBatchYakScriptUnfinishedTaskByUidRequest) (*RecordPortScanRequest, error)
	PopSimpleDetectUnfinishedTaskByUid(context.Context, *GetExecBatchYakScriptUnfinishedTaskByUidRequest) (*RecordPortScanRequest, error)
	RecoverSimpleDetectUnfinishedTask(*RecoverExecBatchYakScriptUnfinishedTaskRequest, Yak_RecoverSimpleDetectUnfinishedTaskServer) error
	// 资产管理
	QueryPorts(context.Context, *QueryPortsRequest) (*QueryPortsResponse, error)
	DeletePorts(context.Context, *DeletePortsRequest) (*Empty, error)
	QueryHosts(context.Context, *QueryHostsRequest) (*QueryHostsResponse, error)
	DeleteHosts(context.Context, *DeleteHostsRequest) (*Empty, error)
	QueryDomains(context.Context, *QueryDomainsRequest) (*QueryDomainsResponse, error)
	DeleteDomains(context.Context, *DeleteDomainsRequest) (*Empty, error)
	QueryPortsGroup(context.Context, *Empty) (*QueryPortsGroupResponse, error)
	// Yakit Store
	UpdateFromYakitResource(context.Context, *UpdateFromYakitResourceRequest) (*Empty, error)
	UpdateFromGithub(context.Context, *UpdateFromGithubRequest) (*Empty, error)
	// Menu
	AddToMenu(context.Context, *AddToMenuRequest) (*Empty, error)
	RemoveFromMenu(context.Context, *RemoveFromMenuRequest) (*Empty, error)
	YakScriptIsInMenu(context.Context, *YakScriptIsInMenuRequest) (*Empty, error)
	GetAllMenuItem(context.Context, *Empty) (*MenuByGroup, error)
	DeleteAllMenuItem(context.Context, *Empty) (*Empty, error)
	ImportMenuItem(context.Context, *ImportMenuItemRequest) (*Empty, error)
	ExportMenuItem(context.Context, *Empty) (*ExportMenuItemResult, error)
	GetMenuItemById(context.Context, *GetMenuItemByIdRequest) (*MenuItem, error)
	QueryGroupsByYakScriptId(context.Context, *QueryGroupsByYakScriptIdRequest) (*GroupNames, error)
	AddMenus(context.Context, *AddMenuRequest) (*Empty, error)
	QueryAllMenuItem(context.Context, *QueryAllMenuItemRequest) (*MenuByGroup, error)
	DeleteAllMenu(context.Context, *QueryAllMenuItemRequest) (*Empty, error)
	// NewMenu
	AddToNavigation(context.Context, *AddToNavigationRequest) (*Empty, error)
	GetAllNavigationItem(context.Context, *GetAllNavigationRequest) (*GetAllNavigationItemResponse, error)
	DeleteAllNavigation(context.Context, *GetAllNavigationRequest) (*Empty, error)
	AddOneNavigation(context.Context, *AddOneNavigationRequest) (*Empty, error)
	QueryNavigationGroups(context.Context, *QueryNavigationGroupsRequest) (*GroupNames, error)
	// document
	SaveMarkdownDocument(context.Context, *SaveMarkdownDocumentRequest) (*Empty, error)
	GetMarkdownDocument(context.Context, *GetMarkdownDocumentRequest) (*GetMarkdownDocumentResponse, error)
	DeleteMarkdownDocument(context.Context, *GetMarkdownDocumentRequest) (*Empty, error)
	// Crawler
	StartBasicCrawler(context.Context, *StartBasicCrawlerRequest) (*ExecResult, error)
	ViewBasicCrawlerCode(context.Context, *Empty) (*SimpleScript, error)
	GenerateWebsiteTree(context.Context, *GenerateWebsiteTreeRequest) (*GenerateWebsiteTreeResponse, error)
	// 对插件结果的操作
	QueryYakScriptExecResult(context.Context, *QueryYakScriptExecResultRequest) (*QueryYakScriptExecResultResponse, error)
	QueryYakScriptNameInExecResult(context.Context, *Empty) (*YakScriptNames, error)
	DeleteYakScriptExecResult(context.Context, *DeleteYakScriptExecResultRequest) (*Empty, error)
	DeleteYakScriptExec(context.Context, *Empty) (*Empty, error)
	// Bruter
	StartBrute(*StartBruteParams, Yak_StartBruteServer) error
	GetAvailableBruteTypes(context.Context, *Empty) (*GetAvailableBruteTypesResponse, error)
	// Tunnel Server RMI/DNSLog
	GetTunnelServerExternalIP(context.Context, *GetTunnelServerExternalIPParams) (*GetTunnelServerExternalIPResponse, error)
	VerifyTunnelServerDomain(context.Context, *VerifyTunnelServerDomainParams) (*VerifyTunnelServerDomainResponse, error)
	StartFacades(*StartFacadesParams, Yak_StartFacadesServer) error
	StartFacadesWithYsoObject(*StartFacadesWithYsoParams, Yak_StartFacadesWithYsoObjectServer) error
	ApplyClassToFacades(context.Context, *ApplyClassToFacadesParamsWithVerbose) (*Empty, error)
	BytesToBase64(context.Context, *BytesToBase64Request) (*BytesToBase64Response, error)
	ConfigGlobalReverse(*ConfigGlobalReverseParams, Yak_ConfigGlobalReverseServer) error
	AvailableLocalAddr(context.Context, *Empty) (*AvailableLocalAddrResponse, error)
	GetGlobalReverseServer(context.Context, *Empty) (*GetGlobalReverseServerResponse, error)
	// Risk
	QueryRisks(context.Context, *QueryRisksRequest) (*QueryRisksResponse, error)
	QueryRisk(context.Context, *QueryRiskRequest) (*Risk, error)
	DeleteRisk(context.Context, *DeleteRiskRequest) (*Empty, error)
	QueryAvailableRiskType(context.Context, *Empty) (*Fields, error)
	QueryAvailableRiskLevel(context.Context, *Empty) (*Fields, error)
	QueryRiskTableStats(context.Context, *Empty) (*RiskTableStats, error)
	ResetRiskTableStats(context.Context, *Empty) (*Empty, error)
	QueryAvailableTarget(context.Context, *Empty) (*Fields, error)
	QueryNewRisk(context.Context, *QueryNewRiskRequest) (*QueryNewRiskResponse, error)
	NewRiskRead(context.Context, *NewRiskReadRequest) (*Empty, error)
	UploadRiskToOnline(context.Context, *UploadRiskToOnlineRequest) (*Empty, error)
	// Report
	QueryReports(context.Context, *QueryReportsRequest) (*QueryReportsResponse, error)
	QueryReport(context.Context, *QueryReportRequest) (*Report, error)
	DeleteReport(context.Context, *DeleteReportRequest) (*Empty, error)
	QueryAvailableReportFrom(context.Context, *Empty) (*Fields, error)
	DownloadReport(context.Context, *DownloadReportRequest) (*Empty, error)
	// Yso
	GetAllYsoGadgetOptions(context.Context, *Empty) (*YsoOptionsWithVerbose, error)
	GetAllYsoClassOptions(context.Context, *YsoOptionsRequerstWithVerbose) (*YsoOptionsWithVerbose, error)
	GetAllYsoClassGeneraterOptions(context.Context, *YsoOptionsRequerstWithVerbose) (*YsoClassOptionsResponseWithVerbose, error)
	GenerateYsoCode(context.Context, *YsoOptionsRequerstWithVerbose) (*YsoCodeResponse, error)
	GenerateYsoBytes(context.Context, *YsoOptionsRequerstWithVerbose) (*YsoBytesResponse, error)
	YsoDump(context.Context, *YsoBytesObject) (*YsoDumpResponse, error)
	// DNSLog / ICMP / RandomTrigger
	SetYakBridgeLogServer(context.Context, *YakDNSLogBridgeAddr) (*Empty, error)
	GetCurrentYakBridgeLogServer(context.Context, *Empty) (*YakDNSLogBridgeAddr, error)
	RequireDNSLogDomain(context.Context, *YakDNSLogBridgeAddr) (*DNSLogRootDomain, error)
	QueryDNSLogByToken(context.Context, *QueryDNSLogByTokenRequest) (*QueryDNSLogByTokenResponse, error)
	RequireICMPRandomLength(context.Context, *Empty) (*RequireICMPRandomLengthResponse, error)
	QueryICMPTrigger(context.Context, *QueryICMPTriggerRequest) (*QueryICMPTriggerResponse, error)
	RequireRandomPortToken(context.Context, *Empty) (*RandomPortInfo, error)
	QueryRandomPortTrigger(context.Context, *QueryRandomPortTriggerRequest) (*RandomPortTriggerNotification, error)
	// 获取 Tags
	GetAvailableYakScriptTags(context.Context, *Empty) (*Fields, error)
	ForceUpdateAvailableYakScriptTags(context.Context, *Empty) (*Empty, error)
	// 通用的漏洞检测技术方案
	ExecYakitPluginsByYakScriptFilter(*ExecYakitPluginsByYakScriptFilterRequest, Yak_ExecYakitPluginsByYakScriptFilterServer) error
	// GenerateYakCodeByPacket
	GenerateYakCodeByPacket(context.Context, *GenerateYakCodeByPacketRequest) (*GenerateYakCodeByPacketResponse, error)
	// CSRF Generator
	GenerateCSRFPocByPacket(context.Context, *GenerateCSRFPocByPacketRequest) (*GenerateCSRFPocByPacketResponse, error)
	// MITM 衍生功能：
	// Replacers 管理
	ExportMITMReplacerRules(context.Context, *Empty) (*ExportMITMReplacerRulesResponse, error)
	ImportMITMReplacerRules(context.Context, *ImportMITMReplacerRulesRequest) (*Empty, error)
	GetCurrentRules(context.Context, *Empty) (*MITMContentReplacers, error)
	SetCurrentRules(context.Context, *MITMContentReplacers) (*Empty, error)
	ExtractDataToFile(Yak_ExtractDataToFileServer) error
	// 尝试自动解码
	AutoDecode(context.Context, *AutoDecodeRequest) (*AutoDecodeResponse, error)
	GetSystemProxy(context.Context, *Empty) (*GetSystemProxyResult, error)
	SetSystemProxy(context.Context, *SetSystemProxyRequest) (*Empty, error)
	// 设置通用存储
	GetKey(context.Context, *GetKeyRequest) (*GetKeyResult, error)
	SetKey(context.Context, *SetKeyRequest) (*Empty, error)
	DelKey(context.Context, *GetKeyRequest) (*Empty, error)
	GetAllProcessEnvKey(context.Context, *Empty) (*GetProcessEnvKeyResult, error)
	SetProcessEnvKey(context.Context, *SetKeyRequest) (*Empty, error)
	GetProjectKey(context.Context, *GetKeyRequest) (*GetKeyResult, error)
	SetProjectKey(context.Context, *SetKeyRequest) (*Empty, error)
	// Online
	GetOnlineProfile(context.Context, *Empty) (*OnlineProfile, error)
	SetOnlineProfile(context.Context, *OnlineProfile) (*Empty, error)
	DownloadOnlinePluginById(context.Context, *DownloadOnlinePluginByIdRequest) (*Empty, error)
	DownloadOnlinePluginByIds(context.Context, *DownloadOnlinePluginByIdsRequest) (*Empty, error)
	DownloadOnlinePluginAll(*DownloadOnlinePluginByTokenRequest, Yak_DownloadOnlinePluginAllServer) error
	DeletePluginByUserID(context.Context, *DeletePluginByUserIDRequest) (*Empty, error)
	DeleteAllLocalPlugins(context.Context, *Empty) (*Empty, error)
	GetYakScriptTagsAndType(context.Context, *Empty) (*GetYakScriptTagsAndTypeResponse, error)
	DeleteLocalPluginsByWhere(context.Context, *DeleteLocalPluginsByWhereRequest) (*Empty, error)
	DownloadOnlinePluginByScriptNames(context.Context, *DownloadOnlinePluginByScriptNamesRequest) (*DownloadOnlinePluginByScriptNamesResponse, error)
	// 新的扫描模式
	ExecPacketScan(*ExecPacketScanRequest, Yak_ExecPacketScanServer) error
	GetEngineDefaultProxy(context.Context, *Empty) (*DefaultProxyResult, error)
	SetEngineDefaultProxy(context.Context, *DefaultProxyResult) (*Empty, error)
	// machine id
	GetMachineID(context.Context, *Empty) (*GetMachineIDResponse, error)
	// license
	GetLicense(context.Context, *Empty) (*GetLicenseResponse, error)
	CheckLicense(context.Context, *CheckLicenseRequest) (*Empty, error)
	// Response Body 的魔法操作
	GetRequestBodyByHTTPFlowID(context.Context, *DownloadBodyByHTTPFlowIDRequest) (*Bytes, error)
	GetResponseBodyByHTTPFlowID(context.Context, *DownloadBodyByHTTPFlowIDRequest) (*Bytes, error)
	GetHTTPPacketBody(context.Context, *GetHTTPPacketBodyRequest) (*Bytes, error)
	// 注册一个 Facades HTTP 响应
	RegisterFacadesHTTP(context.Context, *RegisterFacadesHTTPRequest) (*RegisterFacadesHTTPResponse, error)
	// 重置到恢复出厂设置
	ResetAndInvalidUserData(context.Context, *ResetAndInvalidUserDataRequest) (*Empty, error)
	// Yaklang Shell
	// 创建一个交互式 Shell
	CreateYaklangShell(Yak_CreateYaklangShellServer) error
	// 接入标准输出和标准错误流
	AttachCombinedOutput(*AttachCombinedOutputRequest, Yak_AttachCombinedOutputServer) error
	// 判断当前引擎对网卡是否有操作权限？
	// 主要是能否发包等敏感操作
	// Windows 判断是否是管理员即可 I Am Admin
	// Linux 和 MacOS 应该尝试 pcap 打开网卡就行
	IsPrivilegedForNetRaw(context.Context, *Empty) (*IsPrivilegedForNetRawResponse, error)
	PromotePermissionForUserPcap(context.Context, *Empty) (*Empty, error)
	// 操作项目的相关接口，通过设置 ProjectDatabase
	SetCurrentProject(context.Context, *SetCurrentProjectRequest) (*Empty, error)
	GetCurrentProject(context.Context, *Empty) (*ProjectDescription, error)
	GetProjects(context.Context, *GetProjectsRequest) (*GetProjectsResponse, error)
	NewProject(context.Context, *NewProjectRequest) (*NewProjectResponse, error)
	IsProjectNameValid(context.Context, *IsProjectNameValidRequest) (*Empty, error)
	RemoveProject(context.Context, *RemoveProjectRequest) (*Empty, error)
	DeleteProject(context.Context, *DeleteProjectRequest) (*Empty, error)
	GetDefaultProject(context.Context, *Empty) (*ProjectDescription, error)
	QueryProjectDetail(context.Context, *QueryProjectDetailRequest) (*ProjectDescription, error)
	// 导入导出项目，带密码，带进度
	ExportProject(*ExportProjectRequest, Yak_ExportProjectServer) error
	ImportProject(*ImportProjectRequest, Yak_ImportProjectServer) error
	// 迁移旧数据库
	MigrateLegacyDatabase(context.Context, *Empty) (*Empty, error)
	// 从规则中提取数据
	QueryMITMRuleExtractedData(context.Context, *QueryMITMRuleExtractedDataRequest) (*QueryMITMRuleExtractedDataResponse, error)
	// ChaosMakerRule: Bas
	ImportChaosMakerRules(context.Context, *ImportChaosMakerRulesRequest) (*Empty, error)
	QueryChaosMakerRule(context.Context, *QueryChaosMakerRuleRequest) (*QueryChaosMakerRuleResponse, error)
	DeleteChaosMakerRuleByID(context.Context, *DeleteChaosMakerRuleByIDRequest) (*Empty, error)
	ExecuteChaosMakerRule(*ExecuteChaosMakerRuleRequest, Yak_ExecuteChaosMakerRuleServer) error
	// 这个接口是判断 BAS Agent 远程端口是否可用的，使用 Vulinbox ws agent 协议连接
	// ConnectVulinboxAgent is the same as IsRemoteAddrAvailable
	IsRemoteAddrAvailable(context.Context, *IsRemoteAddrAvailableRequest) (*IsRemoteAddrAvailableResponse, error)
	ConnectVulinboxAgent(context.Context, *IsRemoteAddrAvailableRequest) (*IsRemoteAddrAvailableResponse, error)
	// vulinbox agent 的操作接口
	GetRegisteredVulinboxAgent(context.Context, *GetRegisteredAgentRequest) (*GetRegisteredAgentResponse, error)
	DisconnectVulinboxAgent(context.Context, *DisconnectVulinboxAgentRequest) (*Empty, error)
	// CVE
	IsCVEDatabaseReady(context.Context, *IsCVEDatabaseReadyRequest) (*IsCVEDatabaseReadyResponse, error)
	UpdateCVEDatabase(*UpdateCVEDatabaseRequest, Yak_UpdateCVEDatabaseServer) error
	ExportsProfileDatabase(*ExportsProfileDatabaseRequest, Yak_ExportsProfileDatabaseServer) error
	ImportsProfileDatabase(*ImportsProfileDatabaseRequest, Yak_ImportsProfileDatabaseServer) error
	QueryCVE(context.Context, *QueryCVERequest) (*QueryCVEResponse, error)
	GetCVE(context.Context, *GetCVERequest) (*CVEDetailEx, error)
	SaveTextToTemporalFile(context.Context, *SaveTextToTemporalFileRequest) (*SaveTextToTemporalFileResponse, error)
	// Screcorder
	IsScrecorderReady(context.Context, *IsScrecorderReadyRequest) (*IsScrecorderReadyResponse, error)
	InstallScrecorder(*InstallScrecorderRequest, Yak_InstallScrecorderServer) error
	StartScrecorder(*StartScrecorderRequest, Yak_StartScrecorderServer) error
	QueryScreenRecorders(context.Context, *QueryScreenRecorderRequest) (*QueryScreenRecorderResponse, error)
	DeleteScreenRecorders(context.Context, *QueryScreenRecorderRequest) (*Empty, error)
	UploadScreenRecorders(context.Context, *UploadScreenRecorderRequest) (*Empty, error)
	GetOneScreenRecorders(context.Context, *GetOneScreenRecorderRequest) (*ScreenRecorder, error)
	UpdateScreenRecorders(context.Context, *UpdateScreenRecorderRequest) (*Empty, error)
	// Vulinbox
	IsVulinboxReady(context.Context, *IsVulinboxReadyRequest) (*IsVulinboxReadyResponse, error)
	InstallVulinbox(*InstallVulinboxRequest, Yak_InstallVulinboxServer) error
	StartVulinbox(*StartVulinboxRequest, Yak_StartVulinboxServer) error
	// 通过他可以构造一个 HTTP 请求
	// 这个请求可能是一个，也可能是一系列
	// 一般用来调试插件等
	HTTPRequestBuilder(context.Context, *HTTPRequestBuilderParams) (*HTTPRequestBuilderResponse, error)
	// rpc QueryHTTPRequestBuilder(QueryHTTPRequestBuilderRequest) returns (QueryHTTPRequestBuilderResponse);
	// rpc DeleteHTTPRequestBuilder(DeleteHTTPRequestBuilderRequest) returns (Empty);
	DebugPlugin(*DebugPluginRequest, Yak_DebugPluginServer) error
	SmokingEvaluatePlugin(context.Context, *SmokingEvaluatePluginRequest) (*SmokingEvaluatePluginResponse, error)
	GetSystemDefaultDnsServers(context.Context, *Empty) (*DefaultDnsServerResponse, error)
	mustEmbedUnimplementedYakServer()
}

// UnimplementedYakServer must be embedded to have forward compatible implementations.
type UnimplementedYakServer struct {
}

func (UnimplementedYakServer) Version(context.Context, *Empty) (*VersionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Version not implemented")
}
func (UnimplementedYakServer) Echo(context.Context, *EchoRequest) (*EchoResposne, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Echo not implemented")
}
func (UnimplementedYakServer) MITM(Yak_MITMServer) error {
	return status.Errorf(codes.Unimplemented, "method MITM not implemented")
}
func (UnimplementedYakServer) SetMITMFilter(context.Context, *SetMITMFilterRequest) (*SetMITMFilterResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetMITMFilter not implemented")
}
func (UnimplementedYakServer) GetMITMFilter(context.Context, *Empty) (*SetMITMFilterRequest, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetMITMFilter not implemented")
}
func (UnimplementedYakServer) DownloadMITMCert(context.Context, *Empty) (*MITMCert, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DownloadMITMCert not implemented")
}
func (UnimplementedYakServer) OpenPort(Yak_OpenPortServer) error {
	return status.Errorf(codes.Unimplemented, "method OpenPort not implemented")
}
func (UnimplementedYakServer) Exec(*ExecRequest, Yak_ExecServer) error {
	return status.Errorf(codes.Unimplemented, "method Exec not implemented")
}
func (UnimplementedYakServer) QueryExecHistory(context.Context, *ExecHistoryRequest) (*ExecHistoryRecordResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QueryExecHistory not implemented")
}
func (UnimplementedYakServer) RemoveExecHistory(context.Context, *Empty) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RemoveExecHistory not implemented")
}
func (UnimplementedYakServer) LoadNucleiTemplates(context.Context, *Empty) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method LoadNucleiTemplates not implemented")
}
func (UnimplementedYakServer) AutoUpdateYakModule(*Empty, Yak_AutoUpdateYakModuleServer) error {
	return status.Errorf(codes.Unimplemented, "method AutoUpdateYakModule not implemented")
}
func (UnimplementedYakServer) ExecYakScript(*ExecRequest, Yak_ExecYakScriptServer) error {
	return status.Errorf(codes.Unimplemented, "method ExecYakScript not implemented")
}
func (UnimplementedYakServer) ExecBatchYakScript(*ExecBatchYakScriptRequest, Yak_ExecBatchYakScriptServer) error {
	return status.Errorf(codes.Unimplemented, "method ExecBatchYakScript not implemented")
}
func (UnimplementedYakServer) GetExecBatchYakScriptUnfinishedTask(context.Context, *Empty) (*GetExecBatchYakScriptUnfinishedTaskResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetExecBatchYakScriptUnfinishedTask not implemented")
}
func (UnimplementedYakServer) GetExecBatchYakScriptUnfinishedTaskByUid(context.Context, *GetExecBatchYakScriptUnfinishedTaskByUidRequest) (*ExecBatchYakScriptRequest, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetExecBatchYakScriptUnfinishedTaskByUid not implemented")
}
func (UnimplementedYakServer) PopExecBatchYakScriptUnfinishedTaskByUid(context.Context, *GetExecBatchYakScriptUnfinishedTaskByUidRequest) (*ExecBatchYakScriptRequest, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PopExecBatchYakScriptUnfinishedTaskByUid not implemented")
}
func (UnimplementedYakServer) RecoverExecBatchYakScriptUnfinishedTask(*RecoverExecBatchYakScriptUnfinishedTaskRequest, Yak_RecoverExecBatchYakScriptUnfinishedTaskServer) error {
	return status.Errorf(codes.Unimplemented, "method RecoverExecBatchYakScriptUnfinishedTask not implemented")
}
func (UnimplementedYakServer) QueryYakScript(context.Context, *QueryYakScriptRequest) (*QueryYakScriptResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QueryYakScript not implemented")
}
func (UnimplementedYakServer) QueryYakScriptByYakScriptName(*QueryYakScriptRequest, Yak_QueryYakScriptByYakScriptNameServer) error {
	return status.Errorf(codes.Unimplemented, "method QueryYakScriptByYakScriptName not implemented")
}
func (UnimplementedYakServer) SaveYakScript(context.Context, *YakScript) (*YakScript, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SaveYakScript not implemented")
}
func (UnimplementedYakServer) DeleteYakScript(context.Context, *DeleteYakScriptRequest) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteYakScript not implemented")
}
func (UnimplementedYakServer) GetYakScriptById(context.Context, *GetYakScriptByIdRequest) (*YakScript, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetYakScriptById not implemented")
}
func (UnimplementedYakServer) GetYakScriptByName(context.Context, *GetYakScriptByNameRequest) (*YakScript, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetYakScriptByName not implemented")
}
func (UnimplementedYakServer) GetYakScriptByOnlineID(context.Context, *GetYakScriptByOnlineIDRequest) (*YakScript, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetYakScriptByOnlineID not implemented")
}
func (UnimplementedYakServer) IgnoreYakScript(context.Context, *DeleteYakScriptRequest) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method IgnoreYakScript not implemented")
}
func (UnimplementedYakServer) UnIgnoreYakScript(context.Context, *DeleteYakScriptRequest) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UnIgnoreYakScript not implemented")
}
func (UnimplementedYakServer) ExportYakScript(context.Context, *ExportYakScriptRequest) (*ExportYakScriptResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ExportYakScript not implemented")
}
func (UnimplementedYakServer) ExecutePacketYakScript(*ExecutePacketYakScriptParams, Yak_ExecutePacketYakScriptServer) error {
	return status.Errorf(codes.Unimplemented, "method ExecutePacketYakScript not implemented")
}
func (UnimplementedYakServer) ExecuteBatchPacketYakScript(*ExecuteBatchPacketYakScriptParams, Yak_ExecuteBatchPacketYakScriptServer) error {
	return status.Errorf(codes.Unimplemented, "method ExecuteBatchPacketYakScript not implemented")
}
func (UnimplementedYakServer) GetYakScriptTags(context.Context, *Empty) (*GetYakScriptTagsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetYakScriptTags not implemented")
}
func (UnimplementedYakServer) QueryYakScriptLocalAndUser(context.Context, *QueryYakScriptLocalAndUserRequest) (*QueryYakScriptLocalAndUserResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QueryYakScriptLocalAndUser not implemented")
}
func (UnimplementedYakServer) QueryYakScriptByOnlineGroup(context.Context, *QueryYakScriptByOnlineGroupRequest) (*QueryYakScriptLocalAndUserResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QueryYakScriptByOnlineGroup not implemented")
}
func (UnimplementedYakServer) QueryYakScriptLocalAll(context.Context, *Empty) (*QueryYakScriptLocalAndUserResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QueryYakScriptLocalAll not implemented")
}
func (UnimplementedYakServer) QueryYakScriptByNames(context.Context, *QueryYakScriptByNamesRequest) (*QueryYakScriptByNamesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QueryYakScriptByNames not implemented")
}
func (UnimplementedYakServer) GetHTTPFlowByHash(context.Context, *GetHTTPFlowByHashRequest) (*HTTPFlow, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetHTTPFlowByHash not implemented")
}
func (UnimplementedYakServer) GetHTTPFlowById(context.Context, *GetHTTPFlowByIdRequest) (*HTTPFlow, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetHTTPFlowById not implemented")
}
func (UnimplementedYakServer) GetHTTPFlowByIds(context.Context, *GetHTTPFlowByIdsRequest) (*HTTPFlows, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetHTTPFlowByIds not implemented")
}
func (UnimplementedYakServer) QueryHTTPFlows(context.Context, *QueryHTTPFlowRequest) (*QueryHTTPFlowResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QueryHTTPFlows not implemented")
}
func (UnimplementedYakServer) DeleteHTTPFlows(context.Context, *DeleteHTTPFlowRequest) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteHTTPFlows not implemented")
}
func (UnimplementedYakServer) SetTagForHTTPFlow(context.Context, *SetTagForHTTPFlowRequest) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetTagForHTTPFlow not implemented")
}
func (UnimplementedYakServer) QueryHTTPFlowsIds(context.Context, *QueryHTTPFlowsIdsRequest) (*QueryHTTPFlowsIdsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QueryHTTPFlowsIds not implemented")
}
func (UnimplementedYakServer) HTTPFlowsFieldGroup(context.Context, *HTTPFlowsFieldGroupRequest) (*HTTPFlowsFieldGroupResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method HTTPFlowsFieldGroup not implemented")
}
func (UnimplementedYakServer) HTTPFlowsShare(context.Context, *HTTPFlowsShareRequest) (*HTTPFlowsShareResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method HTTPFlowsShare not implemented")
}
func (UnimplementedYakServer) HTTPFlowsExtract(context.Context, *HTTPFlowsExtractRequest) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method HTTPFlowsExtract not implemented")
}
func (UnimplementedYakServer) ExtractUrl(context.Context, *FuzzerRequest) (*ExtractedUrl, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ExtractUrl not implemented")
}
func (UnimplementedYakServer) GetHistoryHTTPFuzzerTask(context.Context, *GetHistoryHTTPFuzzerTaskRequest) (*HistoryHTTPFuzzerTaskDetail, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetHistoryHTTPFuzzerTask not implemented")
}
func (UnimplementedYakServer) QueryHistoryHTTPFuzzerTask(context.Context, *Empty) (*HistoryHTTPFuzzerTasks, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QueryHistoryHTTPFuzzerTask not implemented")
}
func (UnimplementedYakServer) QueryHistoryHTTPFuzzerTaskEx(context.Context, *QueryHistoryHTTPFuzzerTaskExParams) (*HistoryHTTPFuzzerTasksResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QueryHistoryHTTPFuzzerTaskEx not implemented")
}
func (UnimplementedYakServer) DeleteHistoryHTTPFuzzerTask(context.Context, *DeleteHistoryHTTPFuzzerTaskRequest) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteHistoryHTTPFuzzerTask not implemented")
}
func (UnimplementedYakServer) HTTPFuzzer(*FuzzerRequest, Yak_HTTPFuzzerServer) error {
	return status.Errorf(codes.Unimplemented, "method HTTPFuzzer not implemented")
}
func (UnimplementedYakServer) PreloadHTTPFuzzerParams(context.Context, *PreloadHTTPFuzzerParamsRequest) (*PreloadHTTPFuzzerParamsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PreloadHTTPFuzzerParams not implemented")
}
func (UnimplementedYakServer) RenderVariables(context.Context, *RenderVariablesRequest) (*RenderVariablesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RenderVariables not implemented")
}
func (UnimplementedYakServer) MatchHTTPResponse(context.Context, *MatchHTTPResponseParams) (*MatchHTTPResponseResult, error) {
	return nil, status.Errorf(codes.Unimplemented, "method MatchHTTPResponse not implemented")
}
func (UnimplementedYakServer) ExtractHTTPResponse(context.Context, *ExtractHTTPResponseParams) (*ExtractHTTPResponseResult, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ExtractHTTPResponse not implemented")
}
func (UnimplementedYakServer) RedirectRequest(context.Context, *RedirectRequestParams) (*FuzzerResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RedirectRequest not implemented")
}
func (UnimplementedYakServer) HTTPRequestMutate(context.Context, *HTTPRequestMutateParams) (*MutateResult, error) {
	return nil, status.Errorf(codes.Unimplemented, "method HTTPRequestMutate not implemented")
}
func (UnimplementedYakServer) HTTPResponseMutate(context.Context, *HTTPResponseMutateParams) (*MutateResult, error) {
	return nil, status.Errorf(codes.Unimplemented, "method HTTPResponseMutate not implemented")
}
func (UnimplementedYakServer) FixUploadPacket(context.Context, *FixUploadPacketRequest) (*FixUploadPacketResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method FixUploadPacket not implemented")
}
func (UnimplementedYakServer) IsMultipartFormDataRequest(context.Context, *FixUploadPacketRequest) (*IsMultipartFormDataRequestResult, error) {
	return nil, status.Errorf(codes.Unimplemented, "method IsMultipartFormDataRequest not implemented")
}
func (UnimplementedYakServer) GenerateExtractRule(context.Context, *GenerateExtractRuleRequest) (*GenerateExtractRuleResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GenerateExtractRule not implemented")
}
func (UnimplementedYakServer) ExtractData(Yak_ExtractDataServer) error {
	return status.Errorf(codes.Unimplemented, "method ExtractData not implemented")
}
func (UnimplementedYakServer) SaveFuzzerLabel(context.Context, *SaveFuzzerLabelRequest) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SaveFuzzerLabel not implemented")
}
func (UnimplementedYakServer) QueryFuzzerLabel(context.Context, *Empty) (*QueryFuzzerLabelResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QueryFuzzerLabel not implemented")
}
func (UnimplementedYakServer) DeleteFuzzerLabel(context.Context, *DeleteFuzzerLabelRequest) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteFuzzerLabel not implemented")
}
func (UnimplementedYakServer) QueryHTTPFuzzerResponseByTaskId(context.Context, *QueryHTTPFuzzerResponseByTaskIdRequest) (*QueryHTTPFuzzerResponseByTaskIdResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QueryHTTPFuzzerResponseByTaskId not implemented")
}
func (UnimplementedYakServer) CreateWebsocketFuzzer(Yak_CreateWebsocketFuzzerServer) error {
	return status.Errorf(codes.Unimplemented, "method CreateWebsocketFuzzer not implemented")
}
func (UnimplementedYakServer) QueryWebsocketFlowByHTTPFlowWebsocketHash(context.Context, *QueryWebsocketFlowByHTTPFlowWebsocketHashRequest) (*WebsocketFlows, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QueryWebsocketFlowByHTTPFlowWebsocketHash not implemented")
}
func (UnimplementedYakServer) DeleteWebsocketFlowByHTTPFlowWebsocketHash(context.Context, *DeleteWebsocketFlowByHTTPFlowWebsocketHashRequest) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteWebsocketFlowByHTTPFlowWebsocketHash not implemented")
}
func (UnimplementedYakServer) DeleteWebsocketFlowAll(context.Context, *Empty) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteWebsocketFlowAll not implemented")
}
func (UnimplementedYakServer) ConvertFuzzerResponseToHTTPFlow(context.Context, *FuzzerResponse) (*HTTPFlow, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ConvertFuzzerResponseToHTTPFlow not implemented")
}
func (UnimplementedYakServer) StringFuzzer(context.Context, *StringFuzzerRequest) (*StringFuzzerResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method StringFuzzer not implemented")
}
func (UnimplementedYakServer) HTTPRequestAnalyzer(context.Context, *HTTPRequestAnalysisMaterial) (*HTTPRequestAnalysis, error) {
	return nil, status.Errorf(codes.Unimplemented, "method HTTPRequestAnalyzer not implemented")
}
func (UnimplementedYakServer) Codec(context.Context, *CodecRequest) (*CodecResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Codec not implemented")
}
func (UnimplementedYakServer) QueryPayload(context.Context, *QueryPayloadRequest) (*QueryPayloadResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QueryPayload not implemented")
}
func (UnimplementedYakServer) DeletePayloadByGroup(context.Context, *DeletePayloadByGroupRequest) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeletePayloadByGroup not implemented")
}
func (UnimplementedYakServer) DeletePayload(context.Context, *DeletePayloadRequest) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeletePayload not implemented")
}
func (UnimplementedYakServer) SavePayload(context.Context, *SavePayloadRequest) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SavePayload not implemented")
}
func (UnimplementedYakServer) SavePayloadStream(*SavePayloadRequest, Yak_SavePayloadStreamServer) error {
	return status.Errorf(codes.Unimplemented, "method SavePayloadStream not implemented")
}
func (UnimplementedYakServer) GetAllPayloadGroup(context.Context, *Empty) (*GetAllPayloadGroupResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetAllPayloadGroup not implemented")
}
func (UnimplementedYakServer) UpdatePayload(context.Context, *UpdatePayloadRequest) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdatePayload not implemented")
}
func (UnimplementedYakServer) GetAllPayload(context.Context, *GetAllPayloadRequest) (*GetAllPayloadResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetAllPayload not implemented")
}
func (UnimplementedYakServer) GetYakitCompletionRaw(context.Context, *Empty) (*YakitCompletionRawResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetYakitCompletionRaw not implemented")
}
func (UnimplementedYakServer) GetYakVMBuildInMethodCompletion(context.Context, *GetYakVMBuildInMethodCompletionRequest) (*GetYakVMBuildInMethodCompletionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetYakVMBuildInMethodCompletion not implemented")
}
func (UnimplementedYakServer) StaticAnalyzeError(context.Context, *StaticAnalyzeErrorRequest) (*StaticAnalyzeErrorResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method StaticAnalyzeError not implemented")
}
func (UnimplementedYakServer) YaklangCompileAndFormat(context.Context, *YaklangCompileAndFormatRequest) (*YaklangCompileAndFormatResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method YaklangCompileAndFormat not implemented")
}
func (UnimplementedYakServer) PortScan(*PortScanRequest, Yak_PortScanServer) error {
	return status.Errorf(codes.Unimplemented, "method PortScan not implemented")
}
func (UnimplementedYakServer) ViewPortScanCode(context.Context, *Empty) (*SimpleScript, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ViewPortScanCode not implemented")
}
func (UnimplementedYakServer) SimpleDetect(*RecordPortScanRequest, Yak_SimpleDetectServer) error {
	return status.Errorf(codes.Unimplemented, "method SimpleDetect not implemented")
}
func (UnimplementedYakServer) SaveCancelSimpleDetect(context.Context, *RecordPortScanRequest) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SaveCancelSimpleDetect not implemented")
}
func (UnimplementedYakServer) GetSimpleDetectUnfinishedTask(context.Context, *Empty) (*GetSimpleDetectUnfinishedTaskResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetSimpleDetectUnfinishedTask not implemented")
}
func (UnimplementedYakServer) GetSimpleDetectUnfinishedTaskByUid(context.Context, *GetExecBatchYakScriptUnfinishedTaskByUidRequest) (*RecordPortScanRequest, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetSimpleDetectUnfinishedTaskByUid not implemented")
}
func (UnimplementedYakServer) PopSimpleDetectUnfinishedTaskByUid(context.Context, *GetExecBatchYakScriptUnfinishedTaskByUidRequest) (*RecordPortScanRequest, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PopSimpleDetectUnfinishedTaskByUid not implemented")
}
func (UnimplementedYakServer) RecoverSimpleDetectUnfinishedTask(*RecoverExecBatchYakScriptUnfinishedTaskRequest, Yak_RecoverSimpleDetectUnfinishedTaskServer) error {
	return status.Errorf(codes.Unimplemented, "method RecoverSimpleDetectUnfinishedTask not implemented")
}
func (UnimplementedYakServer) QueryPorts(context.Context, *QueryPortsRequest) (*QueryPortsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QueryPorts not implemented")
}
func (UnimplementedYakServer) DeletePorts(context.Context, *DeletePortsRequest) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeletePorts not implemented")
}
func (UnimplementedYakServer) QueryHosts(context.Context, *QueryHostsRequest) (*QueryHostsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QueryHosts not implemented")
}
func (UnimplementedYakServer) DeleteHosts(context.Context, *DeleteHostsRequest) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteHosts not implemented")
}
func (UnimplementedYakServer) QueryDomains(context.Context, *QueryDomainsRequest) (*QueryDomainsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QueryDomains not implemented")
}
func (UnimplementedYakServer) DeleteDomains(context.Context, *DeleteDomainsRequest) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteDomains not implemented")
}
func (UnimplementedYakServer) QueryPortsGroup(context.Context, *Empty) (*QueryPortsGroupResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QueryPortsGroup not implemented")
}
func (UnimplementedYakServer) UpdateFromYakitResource(context.Context, *UpdateFromYakitResourceRequest) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateFromYakitResource not implemented")
}
func (UnimplementedYakServer) UpdateFromGithub(context.Context, *UpdateFromGithubRequest) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateFromGithub not implemented")
}
func (UnimplementedYakServer) AddToMenu(context.Context, *AddToMenuRequest) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddToMenu not implemented")
}
func (UnimplementedYakServer) RemoveFromMenu(context.Context, *RemoveFromMenuRequest) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RemoveFromMenu not implemented")
}
func (UnimplementedYakServer) YakScriptIsInMenu(context.Context, *YakScriptIsInMenuRequest) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method YakScriptIsInMenu not implemented")
}
func (UnimplementedYakServer) GetAllMenuItem(context.Context, *Empty) (*MenuByGroup, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetAllMenuItem not implemented")
}
func (UnimplementedYakServer) DeleteAllMenuItem(context.Context, *Empty) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteAllMenuItem not implemented")
}
func (UnimplementedYakServer) ImportMenuItem(context.Context, *ImportMenuItemRequest) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ImportMenuItem not implemented")
}
func (UnimplementedYakServer) ExportMenuItem(context.Context, *Empty) (*ExportMenuItemResult, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ExportMenuItem not implemented")
}
func (UnimplementedYakServer) GetMenuItemById(context.Context, *GetMenuItemByIdRequest) (*MenuItem, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetMenuItemById not implemented")
}
func (UnimplementedYakServer) QueryGroupsByYakScriptId(context.Context, *QueryGroupsByYakScriptIdRequest) (*GroupNames, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QueryGroupsByYakScriptId not implemented")
}
func (UnimplementedYakServer) AddMenus(context.Context, *AddMenuRequest) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddMenus not implemented")
}
func (UnimplementedYakServer) QueryAllMenuItem(context.Context, *QueryAllMenuItemRequest) (*MenuByGroup, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QueryAllMenuItem not implemented")
}
func (UnimplementedYakServer) DeleteAllMenu(context.Context, *QueryAllMenuItemRequest) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteAllMenu not implemented")
}
func (UnimplementedYakServer) AddToNavigation(context.Context, *AddToNavigationRequest) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddToNavigation not implemented")
}
func (UnimplementedYakServer) GetAllNavigationItem(context.Context, *GetAllNavigationRequest) (*GetAllNavigationItemResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetAllNavigationItem not implemented")
}
func (UnimplementedYakServer) DeleteAllNavigation(context.Context, *GetAllNavigationRequest) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteAllNavigation not implemented")
}
func (UnimplementedYakServer) AddOneNavigation(context.Context, *AddOneNavigationRequest) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddOneNavigation not implemented")
}
func (UnimplementedYakServer) QueryNavigationGroups(context.Context, *QueryNavigationGroupsRequest) (*GroupNames, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QueryNavigationGroups not implemented")
}
func (UnimplementedYakServer) SaveMarkdownDocument(context.Context, *SaveMarkdownDocumentRequest) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SaveMarkdownDocument not implemented")
}
func (UnimplementedYakServer) GetMarkdownDocument(context.Context, *GetMarkdownDocumentRequest) (*GetMarkdownDocumentResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetMarkdownDocument not implemented")
}
func (UnimplementedYakServer) DeleteMarkdownDocument(context.Context, *GetMarkdownDocumentRequest) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteMarkdownDocument not implemented")
}
func (UnimplementedYakServer) StartBasicCrawler(context.Context, *StartBasicCrawlerRequest) (*ExecResult, error) {
	return nil, status.Errorf(codes.Unimplemented, "method StartBasicCrawler not implemented")
}
func (UnimplementedYakServer) ViewBasicCrawlerCode(context.Context, *Empty) (*SimpleScript, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ViewBasicCrawlerCode not implemented")
}
func (UnimplementedYakServer) GenerateWebsiteTree(context.Context, *GenerateWebsiteTreeRequest) (*GenerateWebsiteTreeResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GenerateWebsiteTree not implemented")
}
func (UnimplementedYakServer) QueryYakScriptExecResult(context.Context, *QueryYakScriptExecResultRequest) (*QueryYakScriptExecResultResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QueryYakScriptExecResult not implemented")
}
func (UnimplementedYakServer) QueryYakScriptNameInExecResult(context.Context, *Empty) (*YakScriptNames, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QueryYakScriptNameInExecResult not implemented")
}
func (UnimplementedYakServer) DeleteYakScriptExecResult(context.Context, *DeleteYakScriptExecResultRequest) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteYakScriptExecResult not implemented")
}
func (UnimplementedYakServer) DeleteYakScriptExec(context.Context, *Empty) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteYakScriptExec not implemented")
}
func (UnimplementedYakServer) StartBrute(*StartBruteParams, Yak_StartBruteServer) error {
	return status.Errorf(codes.Unimplemented, "method StartBrute not implemented")
}
func (UnimplementedYakServer) GetAvailableBruteTypes(context.Context, *Empty) (*GetAvailableBruteTypesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetAvailableBruteTypes not implemented")
}
func (UnimplementedYakServer) GetTunnelServerExternalIP(context.Context, *GetTunnelServerExternalIPParams) (*GetTunnelServerExternalIPResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetTunnelServerExternalIP not implemented")
}
func (UnimplementedYakServer) VerifyTunnelServerDomain(context.Context, *VerifyTunnelServerDomainParams) (*VerifyTunnelServerDomainResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method VerifyTunnelServerDomain not implemented")
}
func (UnimplementedYakServer) StartFacades(*StartFacadesParams, Yak_StartFacadesServer) error {
	return status.Errorf(codes.Unimplemented, "method StartFacades not implemented")
}
func (UnimplementedYakServer) StartFacadesWithYsoObject(*StartFacadesWithYsoParams, Yak_StartFacadesWithYsoObjectServer) error {
	return status.Errorf(codes.Unimplemented, "method StartFacadesWithYsoObject not implemented")
}
func (UnimplementedYakServer) ApplyClassToFacades(context.Context, *ApplyClassToFacadesParamsWithVerbose) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ApplyClassToFacades not implemented")
}
func (UnimplementedYakServer) BytesToBase64(context.Context, *BytesToBase64Request) (*BytesToBase64Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BytesToBase64 not implemented")
}
func (UnimplementedYakServer) ConfigGlobalReverse(*ConfigGlobalReverseParams, Yak_ConfigGlobalReverseServer) error {
	return status.Errorf(codes.Unimplemented, "method ConfigGlobalReverse not implemented")
}
func (UnimplementedYakServer) AvailableLocalAddr(context.Context, *Empty) (*AvailableLocalAddrResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AvailableLocalAddr not implemented")
}
func (UnimplementedYakServer) GetGlobalReverseServer(context.Context, *Empty) (*GetGlobalReverseServerResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetGlobalReverseServer not implemented")
}
func (UnimplementedYakServer) QueryRisks(context.Context, *QueryRisksRequest) (*QueryRisksResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QueryRisks not implemented")
}
func (UnimplementedYakServer) QueryRisk(context.Context, *QueryRiskRequest) (*Risk, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QueryRisk not implemented")
}
func (UnimplementedYakServer) DeleteRisk(context.Context, *DeleteRiskRequest) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteRisk not implemented")
}
func (UnimplementedYakServer) QueryAvailableRiskType(context.Context, *Empty) (*Fields, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QueryAvailableRiskType not implemented")
}
func (UnimplementedYakServer) QueryAvailableRiskLevel(context.Context, *Empty) (*Fields, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QueryAvailableRiskLevel not implemented")
}
func (UnimplementedYakServer) QueryRiskTableStats(context.Context, *Empty) (*RiskTableStats, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QueryRiskTableStats not implemented")
}
func (UnimplementedYakServer) ResetRiskTableStats(context.Context, *Empty) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ResetRiskTableStats not implemented")
}
func (UnimplementedYakServer) QueryAvailableTarget(context.Context, *Empty) (*Fields, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QueryAvailableTarget not implemented")
}
func (UnimplementedYakServer) QueryNewRisk(context.Context, *QueryNewRiskRequest) (*QueryNewRiskResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QueryNewRisk not implemented")
}
func (UnimplementedYakServer) NewRiskRead(context.Context, *NewRiskReadRequest) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method NewRiskRead not implemented")
}
func (UnimplementedYakServer) UploadRiskToOnline(context.Context, *UploadRiskToOnlineRequest) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UploadRiskToOnline not implemented")
}
func (UnimplementedYakServer) QueryReports(context.Context, *QueryReportsRequest) (*QueryReportsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QueryReports not implemented")
}
func (UnimplementedYakServer) QueryReport(context.Context, *QueryReportRequest) (*Report, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QueryReport not implemented")
}
func (UnimplementedYakServer) DeleteReport(context.Context, *DeleteReportRequest) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteReport not implemented")
}
func (UnimplementedYakServer) QueryAvailableReportFrom(context.Context, *Empty) (*Fields, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QueryAvailableReportFrom not implemented")
}
func (UnimplementedYakServer) DownloadReport(context.Context, *DownloadReportRequest) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DownloadReport not implemented")
}
func (UnimplementedYakServer) GetAllYsoGadgetOptions(context.Context, *Empty) (*YsoOptionsWithVerbose, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetAllYsoGadgetOptions not implemented")
}
func (UnimplementedYakServer) GetAllYsoClassOptions(context.Context, *YsoOptionsRequerstWithVerbose) (*YsoOptionsWithVerbose, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetAllYsoClassOptions not implemented")
}
func (UnimplementedYakServer) GetAllYsoClassGeneraterOptions(context.Context, *YsoOptionsRequerstWithVerbose) (*YsoClassOptionsResponseWithVerbose, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetAllYsoClassGeneraterOptions not implemented")
}
func (UnimplementedYakServer) GenerateYsoCode(context.Context, *YsoOptionsRequerstWithVerbose) (*YsoCodeResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GenerateYsoCode not implemented")
}
func (UnimplementedYakServer) GenerateYsoBytes(context.Context, *YsoOptionsRequerstWithVerbose) (*YsoBytesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GenerateYsoBytes not implemented")
}
func (UnimplementedYakServer) YsoDump(context.Context, *YsoBytesObject) (*YsoDumpResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method YsoDump not implemented")
}
func (UnimplementedYakServer) SetYakBridgeLogServer(context.Context, *YakDNSLogBridgeAddr) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetYakBridgeLogServer not implemented")
}
func (UnimplementedYakServer) GetCurrentYakBridgeLogServer(context.Context, *Empty) (*YakDNSLogBridgeAddr, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetCurrentYakBridgeLogServer not implemented")
}
func (UnimplementedYakServer) RequireDNSLogDomain(context.Context, *YakDNSLogBridgeAddr) (*DNSLogRootDomain, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RequireDNSLogDomain not implemented")
}
func (UnimplementedYakServer) QueryDNSLogByToken(context.Context, *QueryDNSLogByTokenRequest) (*QueryDNSLogByTokenResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QueryDNSLogByToken not implemented")
}
func (UnimplementedYakServer) RequireICMPRandomLength(context.Context, *Empty) (*RequireICMPRandomLengthResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RequireICMPRandomLength not implemented")
}
func (UnimplementedYakServer) QueryICMPTrigger(context.Context, *QueryICMPTriggerRequest) (*QueryICMPTriggerResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QueryICMPTrigger not implemented")
}
func (UnimplementedYakServer) RequireRandomPortToken(context.Context, *Empty) (*RandomPortInfo, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RequireRandomPortToken not implemented")
}
func (UnimplementedYakServer) QueryRandomPortTrigger(context.Context, *QueryRandomPortTriggerRequest) (*RandomPortTriggerNotification, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QueryRandomPortTrigger not implemented")
}
func (UnimplementedYakServer) GetAvailableYakScriptTags(context.Context, *Empty) (*Fields, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetAvailableYakScriptTags not implemented")
}
func (UnimplementedYakServer) ForceUpdateAvailableYakScriptTags(context.Context, *Empty) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ForceUpdateAvailableYakScriptTags not implemented")
}
func (UnimplementedYakServer) ExecYakitPluginsByYakScriptFilter(*ExecYakitPluginsByYakScriptFilterRequest, Yak_ExecYakitPluginsByYakScriptFilterServer) error {
	return status.Errorf(codes.Unimplemented, "method ExecYakitPluginsByYakScriptFilter not implemented")
}
func (UnimplementedYakServer) GenerateYakCodeByPacket(context.Context, *GenerateYakCodeByPacketRequest) (*GenerateYakCodeByPacketResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GenerateYakCodeByPacket not implemented")
}
func (UnimplementedYakServer) GenerateCSRFPocByPacket(context.Context, *GenerateCSRFPocByPacketRequest) (*GenerateCSRFPocByPacketResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GenerateCSRFPocByPacket not implemented")
}
func (UnimplementedYakServer) ExportMITMReplacerRules(context.Context, *Empty) (*ExportMITMReplacerRulesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ExportMITMReplacerRules not implemented")
}
func (UnimplementedYakServer) ImportMITMReplacerRules(context.Context, *ImportMITMReplacerRulesRequest) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ImportMITMReplacerRules not implemented")
}
func (UnimplementedYakServer) GetCurrentRules(context.Context, *Empty) (*MITMContentReplacers, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetCurrentRules not implemented")
}
func (UnimplementedYakServer) SetCurrentRules(context.Context, *MITMContentReplacers) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetCurrentRules not implemented")
}
func (UnimplementedYakServer) ExtractDataToFile(Yak_ExtractDataToFileServer) error {
	return status.Errorf(codes.Unimplemented, "method ExtractDataToFile not implemented")
}
func (UnimplementedYakServer) AutoDecode(context.Context, *AutoDecodeRequest) (*AutoDecodeResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AutoDecode not implemented")
}
func (UnimplementedYakServer) GetSystemProxy(context.Context, *Empty) (*GetSystemProxyResult, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetSystemProxy not implemented")
}
func (UnimplementedYakServer) SetSystemProxy(context.Context, *SetSystemProxyRequest) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetSystemProxy not implemented")
}
func (UnimplementedYakServer) GetKey(context.Context, *GetKeyRequest) (*GetKeyResult, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetKey not implemented")
}
func (UnimplementedYakServer) SetKey(context.Context, *SetKeyRequest) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetKey not implemented")
}
func (UnimplementedYakServer) DelKey(context.Context, *GetKeyRequest) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DelKey not implemented")
}
func (UnimplementedYakServer) GetAllProcessEnvKey(context.Context, *Empty) (*GetProcessEnvKeyResult, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetAllProcessEnvKey not implemented")
}
func (UnimplementedYakServer) SetProcessEnvKey(context.Context, *SetKeyRequest) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetProcessEnvKey not implemented")
}
func (UnimplementedYakServer) GetProjectKey(context.Context, *GetKeyRequest) (*GetKeyResult, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetProjectKey not implemented")
}
func (UnimplementedYakServer) SetProjectKey(context.Context, *SetKeyRequest) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetProjectKey not implemented")
}
func (UnimplementedYakServer) GetOnlineProfile(context.Context, *Empty) (*OnlineProfile, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetOnlineProfile not implemented")
}
func (UnimplementedYakServer) SetOnlineProfile(context.Context, *OnlineProfile) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetOnlineProfile not implemented")
}
func (UnimplementedYakServer) DownloadOnlinePluginById(context.Context, *DownloadOnlinePluginByIdRequest) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DownloadOnlinePluginById not implemented")
}
func (UnimplementedYakServer) DownloadOnlinePluginByIds(context.Context, *DownloadOnlinePluginByIdsRequest) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DownloadOnlinePluginByIds not implemented")
}
func (UnimplementedYakServer) DownloadOnlinePluginAll(*DownloadOnlinePluginByTokenRequest, Yak_DownloadOnlinePluginAllServer) error {
	return status.Errorf(codes.Unimplemented, "method DownloadOnlinePluginAll not implemented")
}
func (UnimplementedYakServer) DeletePluginByUserID(context.Context, *DeletePluginByUserIDRequest) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeletePluginByUserID not implemented")
}
func (UnimplementedYakServer) DeleteAllLocalPlugins(context.Context, *Empty) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteAllLocalPlugins not implemented")
}
func (UnimplementedYakServer) GetYakScriptTagsAndType(context.Context, *Empty) (*GetYakScriptTagsAndTypeResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetYakScriptTagsAndType not implemented")
}
func (UnimplementedYakServer) DeleteLocalPluginsByWhere(context.Context, *DeleteLocalPluginsByWhereRequest) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteLocalPluginsByWhere not implemented")
}
func (UnimplementedYakServer) DownloadOnlinePluginByScriptNames(context.Context, *DownloadOnlinePluginByScriptNamesRequest) (*DownloadOnlinePluginByScriptNamesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DownloadOnlinePluginByScriptNames not implemented")
}
func (UnimplementedYakServer) ExecPacketScan(*ExecPacketScanRequest, Yak_ExecPacketScanServer) error {
	return status.Errorf(codes.Unimplemented, "method ExecPacketScan not implemented")
}
func (UnimplementedYakServer) GetEngineDefaultProxy(context.Context, *Empty) (*DefaultProxyResult, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetEngineDefaultProxy not implemented")
}
func (UnimplementedYakServer) SetEngineDefaultProxy(context.Context, *DefaultProxyResult) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetEngineDefaultProxy not implemented")
}
func (UnimplementedYakServer) GetMachineID(context.Context, *Empty) (*GetMachineIDResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetMachineID not implemented")
}
func (UnimplementedYakServer) GetLicense(context.Context, *Empty) (*GetLicenseResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetLicense not implemented")
}
func (UnimplementedYakServer) CheckLicense(context.Context, *CheckLicenseRequest) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CheckLicense not implemented")
}
func (UnimplementedYakServer) GetRequestBodyByHTTPFlowID(context.Context, *DownloadBodyByHTTPFlowIDRequest) (*Bytes, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetRequestBodyByHTTPFlowID not implemented")
}
func (UnimplementedYakServer) GetResponseBodyByHTTPFlowID(context.Context, *DownloadBodyByHTTPFlowIDRequest) (*Bytes, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetResponseBodyByHTTPFlowID not implemented")
}
func (UnimplementedYakServer) GetHTTPPacketBody(context.Context, *GetHTTPPacketBodyRequest) (*Bytes, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetHTTPPacketBody not implemented")
}
func (UnimplementedYakServer) RegisterFacadesHTTP(context.Context, *RegisterFacadesHTTPRequest) (*RegisterFacadesHTTPResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RegisterFacadesHTTP not implemented")
}
func (UnimplementedYakServer) ResetAndInvalidUserData(context.Context, *ResetAndInvalidUserDataRequest) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ResetAndInvalidUserData not implemented")
}
func (UnimplementedYakServer) CreateYaklangShell(Yak_CreateYaklangShellServer) error {
	return status.Errorf(codes.Unimplemented, "method CreateYaklangShell not implemented")
}
func (UnimplementedYakServer) AttachCombinedOutput(*AttachCombinedOutputRequest, Yak_AttachCombinedOutputServer) error {
	return status.Errorf(codes.Unimplemented, "method AttachCombinedOutput not implemented")
}
func (UnimplementedYakServer) IsPrivilegedForNetRaw(context.Context, *Empty) (*IsPrivilegedForNetRawResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method IsPrivilegedForNetRaw not implemented")
}
func (UnimplementedYakServer) PromotePermissionForUserPcap(context.Context, *Empty) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PromotePermissionForUserPcap not implemented")
}
func (UnimplementedYakServer) SetCurrentProject(context.Context, *SetCurrentProjectRequest) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetCurrentProject not implemented")
}
func (UnimplementedYakServer) GetCurrentProject(context.Context, *Empty) (*ProjectDescription, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetCurrentProject not implemented")
}
func (UnimplementedYakServer) GetProjects(context.Context, *GetProjectsRequest) (*GetProjectsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetProjects not implemented")
}
func (UnimplementedYakServer) NewProject(context.Context, *NewProjectRequest) (*NewProjectResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method NewProject not implemented")
}
func (UnimplementedYakServer) IsProjectNameValid(context.Context, *IsProjectNameValidRequest) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method IsProjectNameValid not implemented")
}
func (UnimplementedYakServer) RemoveProject(context.Context, *RemoveProjectRequest) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RemoveProject not implemented")
}
func (UnimplementedYakServer) DeleteProject(context.Context, *DeleteProjectRequest) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteProject not implemented")
}
func (UnimplementedYakServer) GetDefaultProject(context.Context, *Empty) (*ProjectDescription, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetDefaultProject not implemented")
}
func (UnimplementedYakServer) QueryProjectDetail(context.Context, *QueryProjectDetailRequest) (*ProjectDescription, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QueryProjectDetail not implemented")
}
func (UnimplementedYakServer) ExportProject(*ExportProjectRequest, Yak_ExportProjectServer) error {
	return status.Errorf(codes.Unimplemented, "method ExportProject not implemented")
}
func (UnimplementedYakServer) ImportProject(*ImportProjectRequest, Yak_ImportProjectServer) error {
	return status.Errorf(codes.Unimplemented, "method ImportProject not implemented")
}
func (UnimplementedYakServer) MigrateLegacyDatabase(context.Context, *Empty) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method MigrateLegacyDatabase not implemented")
}
func (UnimplementedYakServer) QueryMITMRuleExtractedData(context.Context, *QueryMITMRuleExtractedDataRequest) (*QueryMITMRuleExtractedDataResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QueryMITMRuleExtractedData not implemented")
}
func (UnimplementedYakServer) ImportChaosMakerRules(context.Context, *ImportChaosMakerRulesRequest) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ImportChaosMakerRules not implemented")
}
func (UnimplementedYakServer) QueryChaosMakerRule(context.Context, *QueryChaosMakerRuleRequest) (*QueryChaosMakerRuleResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QueryChaosMakerRule not implemented")
}
func (UnimplementedYakServer) DeleteChaosMakerRuleByID(context.Context, *DeleteChaosMakerRuleByIDRequest) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteChaosMakerRuleByID not implemented")
}
func (UnimplementedYakServer) ExecuteChaosMakerRule(*ExecuteChaosMakerRuleRequest, Yak_ExecuteChaosMakerRuleServer) error {
	return status.Errorf(codes.Unimplemented, "method ExecuteChaosMakerRule not implemented")
}
func (UnimplementedYakServer) IsRemoteAddrAvailable(context.Context, *IsRemoteAddrAvailableRequest) (*IsRemoteAddrAvailableResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method IsRemoteAddrAvailable not implemented")
}
func (UnimplementedYakServer) ConnectVulinboxAgent(context.Context, *IsRemoteAddrAvailableRequest) (*IsRemoteAddrAvailableResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ConnectVulinboxAgent not implemented")
}
func (UnimplementedYakServer) GetRegisteredVulinboxAgent(context.Context, *GetRegisteredAgentRequest) (*GetRegisteredAgentResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetRegisteredVulinboxAgent not implemented")
}
func (UnimplementedYakServer) DisconnectVulinboxAgent(context.Context, *DisconnectVulinboxAgentRequest) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DisconnectVulinboxAgent not implemented")
}
func (UnimplementedYakServer) IsCVEDatabaseReady(context.Context, *IsCVEDatabaseReadyRequest) (*IsCVEDatabaseReadyResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method IsCVEDatabaseReady not implemented")
}
func (UnimplementedYakServer) UpdateCVEDatabase(*UpdateCVEDatabaseRequest, Yak_UpdateCVEDatabaseServer) error {
	return status.Errorf(codes.Unimplemented, "method UpdateCVEDatabase not implemented")
}
func (UnimplementedYakServer) ExportsProfileDatabase(*ExportsProfileDatabaseRequest, Yak_ExportsProfileDatabaseServer) error {
	return status.Errorf(codes.Unimplemented, "method ExportsProfileDatabase not implemented")
}
func (UnimplementedYakServer) ImportsProfileDatabase(*ImportsProfileDatabaseRequest, Yak_ImportsProfileDatabaseServer) error {
	return status.Errorf(codes.Unimplemented, "method ImportsProfileDatabase not implemented")
}
func (UnimplementedYakServer) QueryCVE(context.Context, *QueryCVERequest) (*QueryCVEResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QueryCVE not implemented")
}
func (UnimplementedYakServer) GetCVE(context.Context, *GetCVERequest) (*CVEDetailEx, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetCVE not implemented")
}
func (UnimplementedYakServer) SaveTextToTemporalFile(context.Context, *SaveTextToTemporalFileRequest) (*SaveTextToTemporalFileResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SaveTextToTemporalFile not implemented")
}
func (UnimplementedYakServer) IsScrecorderReady(context.Context, *IsScrecorderReadyRequest) (*IsScrecorderReadyResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method IsScrecorderReady not implemented")
}
func (UnimplementedYakServer) InstallScrecorder(*InstallScrecorderRequest, Yak_InstallScrecorderServer) error {
	return status.Errorf(codes.Unimplemented, "method InstallScrecorder not implemented")
}
func (UnimplementedYakServer) StartScrecorder(*StartScrecorderRequest, Yak_StartScrecorderServer) error {
	return status.Errorf(codes.Unimplemented, "method StartScrecorder not implemented")
}
func (UnimplementedYakServer) QueryScreenRecorders(context.Context, *QueryScreenRecorderRequest) (*QueryScreenRecorderResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QueryScreenRecorders not implemented")
}
func (UnimplementedYakServer) DeleteScreenRecorders(context.Context, *QueryScreenRecorderRequest) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteScreenRecorders not implemented")
}
func (UnimplementedYakServer) UploadScreenRecorders(context.Context, *UploadScreenRecorderRequest) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UploadScreenRecorders not implemented")
}
func (UnimplementedYakServer) GetOneScreenRecorders(context.Context, *GetOneScreenRecorderRequest) (*ScreenRecorder, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetOneScreenRecorders not implemented")
}
func (UnimplementedYakServer) UpdateScreenRecorders(context.Context, *UpdateScreenRecorderRequest) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateScreenRecorders not implemented")
}
func (UnimplementedYakServer) IsVulinboxReady(context.Context, *IsVulinboxReadyRequest) (*IsVulinboxReadyResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method IsVulinboxReady not implemented")
}
func (UnimplementedYakServer) InstallVulinbox(*InstallVulinboxRequest, Yak_InstallVulinboxServer) error {
	return status.Errorf(codes.Unimplemented, "method InstallVulinbox not implemented")
}
func (UnimplementedYakServer) StartVulinbox(*StartVulinboxRequest, Yak_StartVulinboxServer) error {
	return status.Errorf(codes.Unimplemented, "method StartVulinbox not implemented")
}
func (UnimplementedYakServer) HTTPRequestBuilder(context.Context, *HTTPRequestBuilderParams) (*HTTPRequestBuilderResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method HTTPRequestBuilder not implemented")
}
func (UnimplementedYakServer) DebugPlugin(*DebugPluginRequest, Yak_DebugPluginServer) error {
	return status.Errorf(codes.Unimplemented, "method DebugPlugin not implemented")
}
func (UnimplementedYakServer) SmokingEvaluatePlugin(context.Context, *SmokingEvaluatePluginRequest) (*SmokingEvaluatePluginResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SmokingEvaluatePlugin not implemented")
}
func (UnimplementedYakServer) GetSystemDefaultDnsServers(context.Context, *Empty) (*DefaultDnsServerResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetSystemDefaultDnsServers not implemented")
}
func (UnimplementedYakServer) mustEmbedUnimplementedYakServer() {}

// UnsafeYakServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to YakServer will
// result in compilation errors.
type UnsafeYakServer interface {
	mustEmbedUnimplementedYakServer()
}

func RegisterYakServer(s grpc.ServiceRegistrar, srv YakServer) {
	s.RegisterService(&Yak_ServiceDesc, srv)
}

func _Yak_Version_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).Version(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_Version_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).Version(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_Echo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EchoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).Echo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_Echo_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).Echo(ctx, req.(*EchoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_MITM_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(YakServer).MITM(&yakMITMServer{stream})
}

type Yak_MITMServer interface {
	Send(*MITMResponse) error
	Recv() (*MITMRequest, error)
	grpc.ServerStream
}

type yakMITMServer struct {
	grpc.ServerStream
}

func (x *yakMITMServer) Send(m *MITMResponse) error {
	return x.ServerStream.SendMsg(m)
}

func (x *yakMITMServer) Recv() (*MITMRequest, error) {
	m := new(MITMRequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _Yak_SetMITMFilter_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetMITMFilterRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).SetMITMFilter(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_SetMITMFilter_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).SetMITMFilter(ctx, req.(*SetMITMFilterRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_GetMITMFilter_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).GetMITMFilter(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_GetMITMFilter_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).GetMITMFilter(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_DownloadMITMCert_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).DownloadMITMCert(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_DownloadMITMCert_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).DownloadMITMCert(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_OpenPort_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(YakServer).OpenPort(&yakOpenPortServer{stream})
}

type Yak_OpenPortServer interface {
	Send(*Output) error
	Recv() (*Input, error)
	grpc.ServerStream
}

type yakOpenPortServer struct {
	grpc.ServerStream
}

func (x *yakOpenPortServer) Send(m *Output) error {
	return x.ServerStream.SendMsg(m)
}

func (x *yakOpenPortServer) Recv() (*Input, error) {
	m := new(Input)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _Yak_Exec_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(ExecRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(YakServer).Exec(m, &yakExecServer{stream})
}

type Yak_ExecServer interface {
	Send(*ExecResult) error
	grpc.ServerStream
}

type yakExecServer struct {
	grpc.ServerStream
}

func (x *yakExecServer) Send(m *ExecResult) error {
	return x.ServerStream.SendMsg(m)
}

func _Yak_QueryExecHistory_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ExecHistoryRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).QueryExecHistory(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_QueryExecHistory_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).QueryExecHistory(ctx, req.(*ExecHistoryRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_RemoveExecHistory_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).RemoveExecHistory(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_RemoveExecHistory_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).RemoveExecHistory(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_LoadNucleiTemplates_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).LoadNucleiTemplates(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_LoadNucleiTemplates_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).LoadNucleiTemplates(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_AutoUpdateYakModule_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(Empty)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(YakServer).AutoUpdateYakModule(m, &yakAutoUpdateYakModuleServer{stream})
}

type Yak_AutoUpdateYakModuleServer interface {
	Send(*ExecResult) error
	grpc.ServerStream
}

type yakAutoUpdateYakModuleServer struct {
	grpc.ServerStream
}

func (x *yakAutoUpdateYakModuleServer) Send(m *ExecResult) error {
	return x.ServerStream.SendMsg(m)
}

func _Yak_ExecYakScript_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(ExecRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(YakServer).ExecYakScript(m, &yakExecYakScriptServer{stream})
}

type Yak_ExecYakScriptServer interface {
	Send(*ExecResult) error
	grpc.ServerStream
}

type yakExecYakScriptServer struct {
	grpc.ServerStream
}

func (x *yakExecYakScriptServer) Send(m *ExecResult) error {
	return x.ServerStream.SendMsg(m)
}

func _Yak_ExecBatchYakScript_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(ExecBatchYakScriptRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(YakServer).ExecBatchYakScript(m, &yakExecBatchYakScriptServer{stream})
}

type Yak_ExecBatchYakScriptServer interface {
	Send(*ExecBatchYakScriptResult) error
	grpc.ServerStream
}

type yakExecBatchYakScriptServer struct {
	grpc.ServerStream
}

func (x *yakExecBatchYakScriptServer) Send(m *ExecBatchYakScriptResult) error {
	return x.ServerStream.SendMsg(m)
}

func _Yak_GetExecBatchYakScriptUnfinishedTask_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).GetExecBatchYakScriptUnfinishedTask(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_GetExecBatchYakScriptUnfinishedTask_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).GetExecBatchYakScriptUnfinishedTask(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_GetExecBatchYakScriptUnfinishedTaskByUid_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetExecBatchYakScriptUnfinishedTaskByUidRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).GetExecBatchYakScriptUnfinishedTaskByUid(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_GetExecBatchYakScriptUnfinishedTaskByUid_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).GetExecBatchYakScriptUnfinishedTaskByUid(ctx, req.(*GetExecBatchYakScriptUnfinishedTaskByUidRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_PopExecBatchYakScriptUnfinishedTaskByUid_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetExecBatchYakScriptUnfinishedTaskByUidRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).PopExecBatchYakScriptUnfinishedTaskByUid(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_PopExecBatchYakScriptUnfinishedTaskByUid_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).PopExecBatchYakScriptUnfinishedTaskByUid(ctx, req.(*GetExecBatchYakScriptUnfinishedTaskByUidRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_RecoverExecBatchYakScriptUnfinishedTask_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(RecoverExecBatchYakScriptUnfinishedTaskRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(YakServer).RecoverExecBatchYakScriptUnfinishedTask(m, &yakRecoverExecBatchYakScriptUnfinishedTaskServer{stream})
}

type Yak_RecoverExecBatchYakScriptUnfinishedTaskServer interface {
	Send(*ExecBatchYakScriptResult) error
	grpc.ServerStream
}

type yakRecoverExecBatchYakScriptUnfinishedTaskServer struct {
	grpc.ServerStream
}

func (x *yakRecoverExecBatchYakScriptUnfinishedTaskServer) Send(m *ExecBatchYakScriptResult) error {
	return x.ServerStream.SendMsg(m)
}

func _Yak_QueryYakScript_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryYakScriptRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).QueryYakScript(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_QueryYakScript_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).QueryYakScript(ctx, req.(*QueryYakScriptRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_QueryYakScriptByYakScriptName_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(QueryYakScriptRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(YakServer).QueryYakScriptByYakScriptName(m, &yakQueryYakScriptByYakScriptNameServer{stream})
}

type Yak_QueryYakScriptByYakScriptNameServer interface {
	Send(*YakScript) error
	grpc.ServerStream
}

type yakQueryYakScriptByYakScriptNameServer struct {
	grpc.ServerStream
}

func (x *yakQueryYakScriptByYakScriptNameServer) Send(m *YakScript) error {
	return x.ServerStream.SendMsg(m)
}

func _Yak_SaveYakScript_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(YakScript)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).SaveYakScript(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_SaveYakScript_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).SaveYakScript(ctx, req.(*YakScript))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_DeleteYakScript_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteYakScriptRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).DeleteYakScript(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_DeleteYakScript_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).DeleteYakScript(ctx, req.(*DeleteYakScriptRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_GetYakScriptById_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetYakScriptByIdRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).GetYakScriptById(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_GetYakScriptById_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).GetYakScriptById(ctx, req.(*GetYakScriptByIdRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_GetYakScriptByName_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetYakScriptByNameRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).GetYakScriptByName(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_GetYakScriptByName_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).GetYakScriptByName(ctx, req.(*GetYakScriptByNameRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_GetYakScriptByOnlineID_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetYakScriptByOnlineIDRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).GetYakScriptByOnlineID(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_GetYakScriptByOnlineID_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).GetYakScriptByOnlineID(ctx, req.(*GetYakScriptByOnlineIDRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_IgnoreYakScript_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteYakScriptRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).IgnoreYakScript(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_IgnoreYakScript_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).IgnoreYakScript(ctx, req.(*DeleteYakScriptRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_UnIgnoreYakScript_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteYakScriptRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).UnIgnoreYakScript(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_UnIgnoreYakScript_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).UnIgnoreYakScript(ctx, req.(*DeleteYakScriptRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_ExportYakScript_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ExportYakScriptRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).ExportYakScript(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_ExportYakScript_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).ExportYakScript(ctx, req.(*ExportYakScriptRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_ExecutePacketYakScript_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(ExecutePacketYakScriptParams)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(YakServer).ExecutePacketYakScript(m, &yakExecutePacketYakScriptServer{stream})
}

type Yak_ExecutePacketYakScriptServer interface {
	Send(*ExecResult) error
	grpc.ServerStream
}

type yakExecutePacketYakScriptServer struct {
	grpc.ServerStream
}

func (x *yakExecutePacketYakScriptServer) Send(m *ExecResult) error {
	return x.ServerStream.SendMsg(m)
}

func _Yak_ExecuteBatchPacketYakScript_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(ExecuteBatchPacketYakScriptParams)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(YakServer).ExecuteBatchPacketYakScript(m, &yakExecuteBatchPacketYakScriptServer{stream})
}

type Yak_ExecuteBatchPacketYakScriptServer interface {
	Send(*ExecBatchYakScriptResult) error
	grpc.ServerStream
}

type yakExecuteBatchPacketYakScriptServer struct {
	grpc.ServerStream
}

func (x *yakExecuteBatchPacketYakScriptServer) Send(m *ExecBatchYakScriptResult) error {
	return x.ServerStream.SendMsg(m)
}

func _Yak_GetYakScriptTags_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).GetYakScriptTags(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_GetYakScriptTags_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).GetYakScriptTags(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_QueryYakScriptLocalAndUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryYakScriptLocalAndUserRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).QueryYakScriptLocalAndUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_QueryYakScriptLocalAndUser_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).QueryYakScriptLocalAndUser(ctx, req.(*QueryYakScriptLocalAndUserRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_QueryYakScriptByOnlineGroup_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryYakScriptByOnlineGroupRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).QueryYakScriptByOnlineGroup(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_QueryYakScriptByOnlineGroup_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).QueryYakScriptByOnlineGroup(ctx, req.(*QueryYakScriptByOnlineGroupRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_QueryYakScriptLocalAll_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).QueryYakScriptLocalAll(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_QueryYakScriptLocalAll_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).QueryYakScriptLocalAll(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_QueryYakScriptByNames_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryYakScriptByNamesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).QueryYakScriptByNames(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_QueryYakScriptByNames_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).QueryYakScriptByNames(ctx, req.(*QueryYakScriptByNamesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_GetHTTPFlowByHash_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetHTTPFlowByHashRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).GetHTTPFlowByHash(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_GetHTTPFlowByHash_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).GetHTTPFlowByHash(ctx, req.(*GetHTTPFlowByHashRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_GetHTTPFlowById_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetHTTPFlowByIdRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).GetHTTPFlowById(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_GetHTTPFlowById_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).GetHTTPFlowById(ctx, req.(*GetHTTPFlowByIdRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_GetHTTPFlowByIds_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetHTTPFlowByIdsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).GetHTTPFlowByIds(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_GetHTTPFlowByIds_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).GetHTTPFlowByIds(ctx, req.(*GetHTTPFlowByIdsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_QueryHTTPFlows_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryHTTPFlowRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).QueryHTTPFlows(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_QueryHTTPFlows_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).QueryHTTPFlows(ctx, req.(*QueryHTTPFlowRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_DeleteHTTPFlows_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteHTTPFlowRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).DeleteHTTPFlows(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_DeleteHTTPFlows_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).DeleteHTTPFlows(ctx, req.(*DeleteHTTPFlowRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_SetTagForHTTPFlow_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetTagForHTTPFlowRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).SetTagForHTTPFlow(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_SetTagForHTTPFlow_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).SetTagForHTTPFlow(ctx, req.(*SetTagForHTTPFlowRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_QueryHTTPFlowsIds_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryHTTPFlowsIdsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).QueryHTTPFlowsIds(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_QueryHTTPFlowsIds_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).QueryHTTPFlowsIds(ctx, req.(*QueryHTTPFlowsIdsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_HTTPFlowsFieldGroup_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(HTTPFlowsFieldGroupRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).HTTPFlowsFieldGroup(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_HTTPFlowsFieldGroup_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).HTTPFlowsFieldGroup(ctx, req.(*HTTPFlowsFieldGroupRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_HTTPFlowsShare_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(HTTPFlowsShareRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).HTTPFlowsShare(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_HTTPFlowsShare_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).HTTPFlowsShare(ctx, req.(*HTTPFlowsShareRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_HTTPFlowsExtract_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(HTTPFlowsExtractRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).HTTPFlowsExtract(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_HTTPFlowsExtract_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).HTTPFlowsExtract(ctx, req.(*HTTPFlowsExtractRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_ExtractUrl_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FuzzerRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).ExtractUrl(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_ExtractUrl_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).ExtractUrl(ctx, req.(*FuzzerRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_GetHistoryHTTPFuzzerTask_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetHistoryHTTPFuzzerTaskRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).GetHistoryHTTPFuzzerTask(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_GetHistoryHTTPFuzzerTask_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).GetHistoryHTTPFuzzerTask(ctx, req.(*GetHistoryHTTPFuzzerTaskRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_QueryHistoryHTTPFuzzerTask_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).QueryHistoryHTTPFuzzerTask(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_QueryHistoryHTTPFuzzerTask_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).QueryHistoryHTTPFuzzerTask(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_QueryHistoryHTTPFuzzerTaskEx_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryHistoryHTTPFuzzerTaskExParams)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).QueryHistoryHTTPFuzzerTaskEx(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_QueryHistoryHTTPFuzzerTaskEx_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).QueryHistoryHTTPFuzzerTaskEx(ctx, req.(*QueryHistoryHTTPFuzzerTaskExParams))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_DeleteHistoryHTTPFuzzerTask_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteHistoryHTTPFuzzerTaskRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).DeleteHistoryHTTPFuzzerTask(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_DeleteHistoryHTTPFuzzerTask_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).DeleteHistoryHTTPFuzzerTask(ctx, req.(*DeleteHistoryHTTPFuzzerTaskRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_HTTPFuzzer_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(FuzzerRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(YakServer).HTTPFuzzer(m, &yakHTTPFuzzerServer{stream})
}

type Yak_HTTPFuzzerServer interface {
	Send(*FuzzerResponse) error
	grpc.ServerStream
}

type yakHTTPFuzzerServer struct {
	grpc.ServerStream
}

func (x *yakHTTPFuzzerServer) Send(m *FuzzerResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _Yak_PreloadHTTPFuzzerParams_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PreloadHTTPFuzzerParamsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).PreloadHTTPFuzzerParams(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_PreloadHTTPFuzzerParams_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).PreloadHTTPFuzzerParams(ctx, req.(*PreloadHTTPFuzzerParamsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_RenderVariables_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RenderVariablesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).RenderVariables(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_RenderVariables_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).RenderVariables(ctx, req.(*RenderVariablesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_MatchHTTPResponse_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MatchHTTPResponseParams)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).MatchHTTPResponse(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_MatchHTTPResponse_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).MatchHTTPResponse(ctx, req.(*MatchHTTPResponseParams))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_ExtractHTTPResponse_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ExtractHTTPResponseParams)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).ExtractHTTPResponse(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_ExtractHTTPResponse_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).ExtractHTTPResponse(ctx, req.(*ExtractHTTPResponseParams))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_RedirectRequest_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RedirectRequestParams)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).RedirectRequest(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_RedirectRequest_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).RedirectRequest(ctx, req.(*RedirectRequestParams))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_HTTPRequestMutate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(HTTPRequestMutateParams)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).HTTPRequestMutate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_HTTPRequestMutate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).HTTPRequestMutate(ctx, req.(*HTTPRequestMutateParams))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_HTTPResponseMutate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(HTTPResponseMutateParams)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).HTTPResponseMutate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_HTTPResponseMutate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).HTTPResponseMutate(ctx, req.(*HTTPResponseMutateParams))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_FixUploadPacket_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FixUploadPacketRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).FixUploadPacket(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_FixUploadPacket_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).FixUploadPacket(ctx, req.(*FixUploadPacketRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_IsMultipartFormDataRequest_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FixUploadPacketRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).IsMultipartFormDataRequest(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_IsMultipartFormDataRequest_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).IsMultipartFormDataRequest(ctx, req.(*FixUploadPacketRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_GenerateExtractRule_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GenerateExtractRuleRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).GenerateExtractRule(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_GenerateExtractRule_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).GenerateExtractRule(ctx, req.(*GenerateExtractRuleRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_ExtractData_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(YakServer).ExtractData(&yakExtractDataServer{stream})
}

type Yak_ExtractDataServer interface {
	Send(*ExtractDataResponse) error
	Recv() (*ExtractDataRequest, error)
	grpc.ServerStream
}

type yakExtractDataServer struct {
	grpc.ServerStream
}

func (x *yakExtractDataServer) Send(m *ExtractDataResponse) error {
	return x.ServerStream.SendMsg(m)
}

func (x *yakExtractDataServer) Recv() (*ExtractDataRequest, error) {
	m := new(ExtractDataRequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _Yak_SaveFuzzerLabel_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SaveFuzzerLabelRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).SaveFuzzerLabel(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_SaveFuzzerLabel_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).SaveFuzzerLabel(ctx, req.(*SaveFuzzerLabelRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_QueryFuzzerLabel_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).QueryFuzzerLabel(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_QueryFuzzerLabel_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).QueryFuzzerLabel(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_DeleteFuzzerLabel_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteFuzzerLabelRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).DeleteFuzzerLabel(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_DeleteFuzzerLabel_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).DeleteFuzzerLabel(ctx, req.(*DeleteFuzzerLabelRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_QueryHTTPFuzzerResponseByTaskId_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryHTTPFuzzerResponseByTaskIdRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).QueryHTTPFuzzerResponseByTaskId(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_QueryHTTPFuzzerResponseByTaskId_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).QueryHTTPFuzzerResponseByTaskId(ctx, req.(*QueryHTTPFuzzerResponseByTaskIdRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_CreateWebsocketFuzzer_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(YakServer).CreateWebsocketFuzzer(&yakCreateWebsocketFuzzerServer{stream})
}

type Yak_CreateWebsocketFuzzerServer interface {
	Send(*ClientWebsocketResponse) error
	Recv() (*ClientWebsocketRequest, error)
	grpc.ServerStream
}

type yakCreateWebsocketFuzzerServer struct {
	grpc.ServerStream
}

func (x *yakCreateWebsocketFuzzerServer) Send(m *ClientWebsocketResponse) error {
	return x.ServerStream.SendMsg(m)
}

func (x *yakCreateWebsocketFuzzerServer) Recv() (*ClientWebsocketRequest, error) {
	m := new(ClientWebsocketRequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _Yak_QueryWebsocketFlowByHTTPFlowWebsocketHash_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryWebsocketFlowByHTTPFlowWebsocketHashRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).QueryWebsocketFlowByHTTPFlowWebsocketHash(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_QueryWebsocketFlowByHTTPFlowWebsocketHash_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).QueryWebsocketFlowByHTTPFlowWebsocketHash(ctx, req.(*QueryWebsocketFlowByHTTPFlowWebsocketHashRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_DeleteWebsocketFlowByHTTPFlowWebsocketHash_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteWebsocketFlowByHTTPFlowWebsocketHashRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).DeleteWebsocketFlowByHTTPFlowWebsocketHash(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_DeleteWebsocketFlowByHTTPFlowWebsocketHash_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).DeleteWebsocketFlowByHTTPFlowWebsocketHash(ctx, req.(*DeleteWebsocketFlowByHTTPFlowWebsocketHashRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_DeleteWebsocketFlowAll_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).DeleteWebsocketFlowAll(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_DeleteWebsocketFlowAll_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).DeleteWebsocketFlowAll(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_ConvertFuzzerResponseToHTTPFlow_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FuzzerResponse)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).ConvertFuzzerResponseToHTTPFlow(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_ConvertFuzzerResponseToHTTPFlow_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).ConvertFuzzerResponseToHTTPFlow(ctx, req.(*FuzzerResponse))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_StringFuzzer_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StringFuzzerRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).StringFuzzer(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_StringFuzzer_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).StringFuzzer(ctx, req.(*StringFuzzerRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_HTTPRequestAnalyzer_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(HTTPRequestAnalysisMaterial)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).HTTPRequestAnalyzer(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_HTTPRequestAnalyzer_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).HTTPRequestAnalyzer(ctx, req.(*HTTPRequestAnalysisMaterial))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_Codec_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CodecRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).Codec(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_Codec_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).Codec(ctx, req.(*CodecRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_QueryPayload_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryPayloadRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).QueryPayload(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_QueryPayload_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).QueryPayload(ctx, req.(*QueryPayloadRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_DeletePayloadByGroup_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeletePayloadByGroupRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).DeletePayloadByGroup(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_DeletePayloadByGroup_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).DeletePayloadByGroup(ctx, req.(*DeletePayloadByGroupRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_DeletePayload_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeletePayloadRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).DeletePayload(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_DeletePayload_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).DeletePayload(ctx, req.(*DeletePayloadRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_SavePayload_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SavePayloadRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).SavePayload(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_SavePayload_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).SavePayload(ctx, req.(*SavePayloadRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_SavePayloadStream_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(SavePayloadRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(YakServer).SavePayloadStream(m, &yakSavePayloadStreamServer{stream})
}

type Yak_SavePayloadStreamServer interface {
	Send(*SavePayloadProgress) error
	grpc.ServerStream
}

type yakSavePayloadStreamServer struct {
	grpc.ServerStream
}

func (x *yakSavePayloadStreamServer) Send(m *SavePayloadProgress) error {
	return x.ServerStream.SendMsg(m)
}

func _Yak_GetAllPayloadGroup_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).GetAllPayloadGroup(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_GetAllPayloadGroup_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).GetAllPayloadGroup(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_UpdatePayload_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdatePayloadRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).UpdatePayload(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_UpdatePayload_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).UpdatePayload(ctx, req.(*UpdatePayloadRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_GetAllPayload_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetAllPayloadRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).GetAllPayload(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_GetAllPayload_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).GetAllPayload(ctx, req.(*GetAllPayloadRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_GetYakitCompletionRaw_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).GetYakitCompletionRaw(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_GetYakitCompletionRaw_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).GetYakitCompletionRaw(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_GetYakVMBuildInMethodCompletion_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetYakVMBuildInMethodCompletionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).GetYakVMBuildInMethodCompletion(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_GetYakVMBuildInMethodCompletion_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).GetYakVMBuildInMethodCompletion(ctx, req.(*GetYakVMBuildInMethodCompletionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_StaticAnalyzeError_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StaticAnalyzeErrorRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).StaticAnalyzeError(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_StaticAnalyzeError_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).StaticAnalyzeError(ctx, req.(*StaticAnalyzeErrorRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_YaklangCompileAndFormat_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(YaklangCompileAndFormatRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).YaklangCompileAndFormat(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_YaklangCompileAndFormat_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).YaklangCompileAndFormat(ctx, req.(*YaklangCompileAndFormatRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_PortScan_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(PortScanRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(YakServer).PortScan(m, &yakPortScanServer{stream})
}

type Yak_PortScanServer interface {
	Send(*ExecResult) error
	grpc.ServerStream
}

type yakPortScanServer struct {
	grpc.ServerStream
}

func (x *yakPortScanServer) Send(m *ExecResult) error {
	return x.ServerStream.SendMsg(m)
}

func _Yak_ViewPortScanCode_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).ViewPortScanCode(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_ViewPortScanCode_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).ViewPortScanCode(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_SimpleDetect_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(RecordPortScanRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(YakServer).SimpleDetect(m, &yakSimpleDetectServer{stream})
}

type Yak_SimpleDetectServer interface {
	Send(*ExecResult) error
	grpc.ServerStream
}

type yakSimpleDetectServer struct {
	grpc.ServerStream
}

func (x *yakSimpleDetectServer) Send(m *ExecResult) error {
	return x.ServerStream.SendMsg(m)
}

func _Yak_SaveCancelSimpleDetect_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RecordPortScanRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).SaveCancelSimpleDetect(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_SaveCancelSimpleDetect_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).SaveCancelSimpleDetect(ctx, req.(*RecordPortScanRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_GetSimpleDetectUnfinishedTask_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).GetSimpleDetectUnfinishedTask(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_GetSimpleDetectUnfinishedTask_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).GetSimpleDetectUnfinishedTask(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_GetSimpleDetectUnfinishedTaskByUid_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetExecBatchYakScriptUnfinishedTaskByUidRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).GetSimpleDetectUnfinishedTaskByUid(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_GetSimpleDetectUnfinishedTaskByUid_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).GetSimpleDetectUnfinishedTaskByUid(ctx, req.(*GetExecBatchYakScriptUnfinishedTaskByUidRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_PopSimpleDetectUnfinishedTaskByUid_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetExecBatchYakScriptUnfinishedTaskByUidRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).PopSimpleDetectUnfinishedTaskByUid(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_PopSimpleDetectUnfinishedTaskByUid_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).PopSimpleDetectUnfinishedTaskByUid(ctx, req.(*GetExecBatchYakScriptUnfinishedTaskByUidRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_RecoverSimpleDetectUnfinishedTask_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(RecoverExecBatchYakScriptUnfinishedTaskRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(YakServer).RecoverSimpleDetectUnfinishedTask(m, &yakRecoverSimpleDetectUnfinishedTaskServer{stream})
}

type Yak_RecoverSimpleDetectUnfinishedTaskServer interface {
	Send(*ExecResult) error
	grpc.ServerStream
}

type yakRecoverSimpleDetectUnfinishedTaskServer struct {
	grpc.ServerStream
}

func (x *yakRecoverSimpleDetectUnfinishedTaskServer) Send(m *ExecResult) error {
	return x.ServerStream.SendMsg(m)
}

func _Yak_QueryPorts_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryPortsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).QueryPorts(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_QueryPorts_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).QueryPorts(ctx, req.(*QueryPortsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_DeletePorts_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeletePortsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).DeletePorts(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_DeletePorts_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).DeletePorts(ctx, req.(*DeletePortsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_QueryHosts_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryHostsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).QueryHosts(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_QueryHosts_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).QueryHosts(ctx, req.(*QueryHostsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_DeleteHosts_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteHostsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).DeleteHosts(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_DeleteHosts_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).DeleteHosts(ctx, req.(*DeleteHostsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_QueryDomains_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryDomainsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).QueryDomains(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_QueryDomains_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).QueryDomains(ctx, req.(*QueryDomainsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_DeleteDomains_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteDomainsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).DeleteDomains(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_DeleteDomains_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).DeleteDomains(ctx, req.(*DeleteDomainsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_QueryPortsGroup_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).QueryPortsGroup(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_QueryPortsGroup_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).QueryPortsGroup(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_UpdateFromYakitResource_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateFromYakitResourceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).UpdateFromYakitResource(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_UpdateFromYakitResource_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).UpdateFromYakitResource(ctx, req.(*UpdateFromYakitResourceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_UpdateFromGithub_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateFromGithubRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).UpdateFromGithub(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_UpdateFromGithub_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).UpdateFromGithub(ctx, req.(*UpdateFromGithubRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_AddToMenu_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddToMenuRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).AddToMenu(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_AddToMenu_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).AddToMenu(ctx, req.(*AddToMenuRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_RemoveFromMenu_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RemoveFromMenuRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).RemoveFromMenu(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_RemoveFromMenu_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).RemoveFromMenu(ctx, req.(*RemoveFromMenuRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_YakScriptIsInMenu_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(YakScriptIsInMenuRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).YakScriptIsInMenu(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_YakScriptIsInMenu_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).YakScriptIsInMenu(ctx, req.(*YakScriptIsInMenuRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_GetAllMenuItem_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).GetAllMenuItem(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_GetAllMenuItem_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).GetAllMenuItem(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_DeleteAllMenuItem_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).DeleteAllMenuItem(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_DeleteAllMenuItem_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).DeleteAllMenuItem(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_ImportMenuItem_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ImportMenuItemRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).ImportMenuItem(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_ImportMenuItem_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).ImportMenuItem(ctx, req.(*ImportMenuItemRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_ExportMenuItem_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).ExportMenuItem(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_ExportMenuItem_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).ExportMenuItem(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_GetMenuItemById_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetMenuItemByIdRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).GetMenuItemById(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_GetMenuItemById_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).GetMenuItemById(ctx, req.(*GetMenuItemByIdRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_QueryGroupsByYakScriptId_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryGroupsByYakScriptIdRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).QueryGroupsByYakScriptId(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_QueryGroupsByYakScriptId_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).QueryGroupsByYakScriptId(ctx, req.(*QueryGroupsByYakScriptIdRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_AddMenus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddMenuRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).AddMenus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_AddMenus_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).AddMenus(ctx, req.(*AddMenuRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_QueryAllMenuItem_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryAllMenuItemRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).QueryAllMenuItem(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_QueryAllMenuItem_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).QueryAllMenuItem(ctx, req.(*QueryAllMenuItemRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_DeleteAllMenu_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryAllMenuItemRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).DeleteAllMenu(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_DeleteAllMenu_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).DeleteAllMenu(ctx, req.(*QueryAllMenuItemRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_AddToNavigation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddToNavigationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).AddToNavigation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_AddToNavigation_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).AddToNavigation(ctx, req.(*AddToNavigationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_GetAllNavigationItem_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetAllNavigationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).GetAllNavigationItem(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_GetAllNavigationItem_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).GetAllNavigationItem(ctx, req.(*GetAllNavigationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_DeleteAllNavigation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetAllNavigationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).DeleteAllNavigation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_DeleteAllNavigation_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).DeleteAllNavigation(ctx, req.(*GetAllNavigationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_AddOneNavigation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddOneNavigationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).AddOneNavigation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_AddOneNavigation_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).AddOneNavigation(ctx, req.(*AddOneNavigationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_QueryNavigationGroups_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryNavigationGroupsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).QueryNavigationGroups(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_QueryNavigationGroups_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).QueryNavigationGroups(ctx, req.(*QueryNavigationGroupsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_SaveMarkdownDocument_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SaveMarkdownDocumentRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).SaveMarkdownDocument(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_SaveMarkdownDocument_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).SaveMarkdownDocument(ctx, req.(*SaveMarkdownDocumentRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_GetMarkdownDocument_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetMarkdownDocumentRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).GetMarkdownDocument(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_GetMarkdownDocument_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).GetMarkdownDocument(ctx, req.(*GetMarkdownDocumentRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_DeleteMarkdownDocument_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetMarkdownDocumentRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).DeleteMarkdownDocument(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_DeleteMarkdownDocument_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).DeleteMarkdownDocument(ctx, req.(*GetMarkdownDocumentRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_StartBasicCrawler_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StartBasicCrawlerRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).StartBasicCrawler(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_StartBasicCrawler_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).StartBasicCrawler(ctx, req.(*StartBasicCrawlerRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_ViewBasicCrawlerCode_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).ViewBasicCrawlerCode(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_ViewBasicCrawlerCode_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).ViewBasicCrawlerCode(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_GenerateWebsiteTree_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GenerateWebsiteTreeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).GenerateWebsiteTree(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_GenerateWebsiteTree_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).GenerateWebsiteTree(ctx, req.(*GenerateWebsiteTreeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_QueryYakScriptExecResult_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryYakScriptExecResultRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).QueryYakScriptExecResult(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_QueryYakScriptExecResult_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).QueryYakScriptExecResult(ctx, req.(*QueryYakScriptExecResultRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_QueryYakScriptNameInExecResult_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).QueryYakScriptNameInExecResult(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_QueryYakScriptNameInExecResult_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).QueryYakScriptNameInExecResult(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_DeleteYakScriptExecResult_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteYakScriptExecResultRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).DeleteYakScriptExecResult(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_DeleteYakScriptExecResult_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).DeleteYakScriptExecResult(ctx, req.(*DeleteYakScriptExecResultRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_DeleteYakScriptExec_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).DeleteYakScriptExec(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_DeleteYakScriptExec_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).DeleteYakScriptExec(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_StartBrute_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(StartBruteParams)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(YakServer).StartBrute(m, &yakStartBruteServer{stream})
}

type Yak_StartBruteServer interface {
	Send(*ExecResult) error
	grpc.ServerStream
}

type yakStartBruteServer struct {
	grpc.ServerStream
}

func (x *yakStartBruteServer) Send(m *ExecResult) error {
	return x.ServerStream.SendMsg(m)
}

func _Yak_GetAvailableBruteTypes_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).GetAvailableBruteTypes(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_GetAvailableBruteTypes_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).GetAvailableBruteTypes(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_GetTunnelServerExternalIP_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetTunnelServerExternalIPParams)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).GetTunnelServerExternalIP(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_GetTunnelServerExternalIP_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).GetTunnelServerExternalIP(ctx, req.(*GetTunnelServerExternalIPParams))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_VerifyTunnelServerDomain_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(VerifyTunnelServerDomainParams)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).VerifyTunnelServerDomain(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_VerifyTunnelServerDomain_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).VerifyTunnelServerDomain(ctx, req.(*VerifyTunnelServerDomainParams))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_StartFacades_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(StartFacadesParams)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(YakServer).StartFacades(m, &yakStartFacadesServer{stream})
}

type Yak_StartFacadesServer interface {
	Send(*ExecResult) error
	grpc.ServerStream
}

type yakStartFacadesServer struct {
	grpc.ServerStream
}

func (x *yakStartFacadesServer) Send(m *ExecResult) error {
	return x.ServerStream.SendMsg(m)
}

func _Yak_StartFacadesWithYsoObject_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(StartFacadesWithYsoParams)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(YakServer).StartFacadesWithYsoObject(m, &yakStartFacadesWithYsoObjectServer{stream})
}

type Yak_StartFacadesWithYsoObjectServer interface {
	Send(*ExecResult) error
	grpc.ServerStream
}

type yakStartFacadesWithYsoObjectServer struct {
	grpc.ServerStream
}

func (x *yakStartFacadesWithYsoObjectServer) Send(m *ExecResult) error {
	return x.ServerStream.SendMsg(m)
}

func _Yak_ApplyClassToFacades_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ApplyClassToFacadesParamsWithVerbose)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).ApplyClassToFacades(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_ApplyClassToFacades_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).ApplyClassToFacades(ctx, req.(*ApplyClassToFacadesParamsWithVerbose))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_BytesToBase64_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BytesToBase64Request)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).BytesToBase64(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_BytesToBase64_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).BytesToBase64(ctx, req.(*BytesToBase64Request))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_ConfigGlobalReverse_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(ConfigGlobalReverseParams)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(YakServer).ConfigGlobalReverse(m, &yakConfigGlobalReverseServer{stream})
}

type Yak_ConfigGlobalReverseServer interface {
	Send(*Empty) error
	grpc.ServerStream
}

type yakConfigGlobalReverseServer struct {
	grpc.ServerStream
}

func (x *yakConfigGlobalReverseServer) Send(m *Empty) error {
	return x.ServerStream.SendMsg(m)
}

func _Yak_AvailableLocalAddr_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).AvailableLocalAddr(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_AvailableLocalAddr_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).AvailableLocalAddr(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_GetGlobalReverseServer_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).GetGlobalReverseServer(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_GetGlobalReverseServer_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).GetGlobalReverseServer(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_QueryRisks_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryRisksRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).QueryRisks(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_QueryRisks_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).QueryRisks(ctx, req.(*QueryRisksRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_QueryRisk_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryRiskRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).QueryRisk(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_QueryRisk_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).QueryRisk(ctx, req.(*QueryRiskRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_DeleteRisk_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteRiskRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).DeleteRisk(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_DeleteRisk_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).DeleteRisk(ctx, req.(*DeleteRiskRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_QueryAvailableRiskType_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).QueryAvailableRiskType(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_QueryAvailableRiskType_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).QueryAvailableRiskType(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_QueryAvailableRiskLevel_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).QueryAvailableRiskLevel(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_QueryAvailableRiskLevel_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).QueryAvailableRiskLevel(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_QueryRiskTableStats_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).QueryRiskTableStats(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_QueryRiskTableStats_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).QueryRiskTableStats(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_ResetRiskTableStats_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).ResetRiskTableStats(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_ResetRiskTableStats_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).ResetRiskTableStats(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_QueryAvailableTarget_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).QueryAvailableTarget(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_QueryAvailableTarget_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).QueryAvailableTarget(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_QueryNewRisk_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryNewRiskRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).QueryNewRisk(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_QueryNewRisk_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).QueryNewRisk(ctx, req.(*QueryNewRiskRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_NewRiskRead_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NewRiskReadRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).NewRiskRead(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_NewRiskRead_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).NewRiskRead(ctx, req.(*NewRiskReadRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_UploadRiskToOnline_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UploadRiskToOnlineRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).UploadRiskToOnline(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_UploadRiskToOnline_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).UploadRiskToOnline(ctx, req.(*UploadRiskToOnlineRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_QueryReports_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryReportsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).QueryReports(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_QueryReports_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).QueryReports(ctx, req.(*QueryReportsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_QueryReport_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryReportRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).QueryReport(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_QueryReport_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).QueryReport(ctx, req.(*QueryReportRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_DeleteReport_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteReportRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).DeleteReport(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_DeleteReport_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).DeleteReport(ctx, req.(*DeleteReportRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_QueryAvailableReportFrom_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).QueryAvailableReportFrom(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_QueryAvailableReportFrom_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).QueryAvailableReportFrom(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_DownloadReport_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DownloadReportRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).DownloadReport(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_DownloadReport_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).DownloadReport(ctx, req.(*DownloadReportRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_GetAllYsoGadgetOptions_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).GetAllYsoGadgetOptions(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_GetAllYsoGadgetOptions_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).GetAllYsoGadgetOptions(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_GetAllYsoClassOptions_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(YsoOptionsRequerstWithVerbose)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).GetAllYsoClassOptions(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_GetAllYsoClassOptions_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).GetAllYsoClassOptions(ctx, req.(*YsoOptionsRequerstWithVerbose))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_GetAllYsoClassGeneraterOptions_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(YsoOptionsRequerstWithVerbose)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).GetAllYsoClassGeneraterOptions(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_GetAllYsoClassGeneraterOptions_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).GetAllYsoClassGeneraterOptions(ctx, req.(*YsoOptionsRequerstWithVerbose))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_GenerateYsoCode_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(YsoOptionsRequerstWithVerbose)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).GenerateYsoCode(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_GenerateYsoCode_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).GenerateYsoCode(ctx, req.(*YsoOptionsRequerstWithVerbose))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_GenerateYsoBytes_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(YsoOptionsRequerstWithVerbose)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).GenerateYsoBytes(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_GenerateYsoBytes_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).GenerateYsoBytes(ctx, req.(*YsoOptionsRequerstWithVerbose))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_YsoDump_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(YsoBytesObject)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).YsoDump(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_YsoDump_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).YsoDump(ctx, req.(*YsoBytesObject))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_SetYakBridgeLogServer_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(YakDNSLogBridgeAddr)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).SetYakBridgeLogServer(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_SetYakBridgeLogServer_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).SetYakBridgeLogServer(ctx, req.(*YakDNSLogBridgeAddr))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_GetCurrentYakBridgeLogServer_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).GetCurrentYakBridgeLogServer(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_GetCurrentYakBridgeLogServer_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).GetCurrentYakBridgeLogServer(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_RequireDNSLogDomain_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(YakDNSLogBridgeAddr)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).RequireDNSLogDomain(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_RequireDNSLogDomain_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).RequireDNSLogDomain(ctx, req.(*YakDNSLogBridgeAddr))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_QueryDNSLogByToken_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryDNSLogByTokenRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).QueryDNSLogByToken(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_QueryDNSLogByToken_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).QueryDNSLogByToken(ctx, req.(*QueryDNSLogByTokenRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_RequireICMPRandomLength_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).RequireICMPRandomLength(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_RequireICMPRandomLength_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).RequireICMPRandomLength(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_QueryICMPTrigger_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryICMPTriggerRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).QueryICMPTrigger(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_QueryICMPTrigger_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).QueryICMPTrigger(ctx, req.(*QueryICMPTriggerRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_RequireRandomPortToken_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).RequireRandomPortToken(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_RequireRandomPortToken_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).RequireRandomPortToken(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_QueryRandomPortTrigger_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryRandomPortTriggerRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).QueryRandomPortTrigger(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_QueryRandomPortTrigger_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).QueryRandomPortTrigger(ctx, req.(*QueryRandomPortTriggerRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_GetAvailableYakScriptTags_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).GetAvailableYakScriptTags(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_GetAvailableYakScriptTags_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).GetAvailableYakScriptTags(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_ForceUpdateAvailableYakScriptTags_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).ForceUpdateAvailableYakScriptTags(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_ForceUpdateAvailableYakScriptTags_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).ForceUpdateAvailableYakScriptTags(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_ExecYakitPluginsByYakScriptFilter_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(ExecYakitPluginsByYakScriptFilterRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(YakServer).ExecYakitPluginsByYakScriptFilter(m, &yakExecYakitPluginsByYakScriptFilterServer{stream})
}

type Yak_ExecYakitPluginsByYakScriptFilterServer interface {
	Send(*ExecResult) error
	grpc.ServerStream
}

type yakExecYakitPluginsByYakScriptFilterServer struct {
	grpc.ServerStream
}

func (x *yakExecYakitPluginsByYakScriptFilterServer) Send(m *ExecResult) error {
	return x.ServerStream.SendMsg(m)
}

func _Yak_GenerateYakCodeByPacket_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GenerateYakCodeByPacketRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).GenerateYakCodeByPacket(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_GenerateYakCodeByPacket_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).GenerateYakCodeByPacket(ctx, req.(*GenerateYakCodeByPacketRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_GenerateCSRFPocByPacket_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GenerateCSRFPocByPacketRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).GenerateCSRFPocByPacket(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_GenerateCSRFPocByPacket_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).GenerateCSRFPocByPacket(ctx, req.(*GenerateCSRFPocByPacketRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_ExportMITMReplacerRules_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).ExportMITMReplacerRules(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_ExportMITMReplacerRules_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).ExportMITMReplacerRules(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_ImportMITMReplacerRules_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ImportMITMReplacerRulesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).ImportMITMReplacerRules(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_ImportMITMReplacerRules_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).ImportMITMReplacerRules(ctx, req.(*ImportMITMReplacerRulesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_GetCurrentRules_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).GetCurrentRules(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_GetCurrentRules_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).GetCurrentRules(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_SetCurrentRules_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MITMContentReplacers)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).SetCurrentRules(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_SetCurrentRules_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).SetCurrentRules(ctx, req.(*MITMContentReplacers))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_ExtractDataToFile_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(YakServer).ExtractDataToFile(&yakExtractDataToFileServer{stream})
}

type Yak_ExtractDataToFileServer interface {
	Send(*ExtractDataToFileResult) error
	Recv() (*ExtractDataToFileRequest, error)
	grpc.ServerStream
}

type yakExtractDataToFileServer struct {
	grpc.ServerStream
}

func (x *yakExtractDataToFileServer) Send(m *ExtractDataToFileResult) error {
	return x.ServerStream.SendMsg(m)
}

func (x *yakExtractDataToFileServer) Recv() (*ExtractDataToFileRequest, error) {
	m := new(ExtractDataToFileRequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _Yak_AutoDecode_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AutoDecodeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).AutoDecode(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_AutoDecode_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).AutoDecode(ctx, req.(*AutoDecodeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_GetSystemProxy_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).GetSystemProxy(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_GetSystemProxy_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).GetSystemProxy(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_SetSystemProxy_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetSystemProxyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).SetSystemProxy(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_SetSystemProxy_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).SetSystemProxy(ctx, req.(*SetSystemProxyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_GetKey_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetKeyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).GetKey(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_GetKey_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).GetKey(ctx, req.(*GetKeyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_SetKey_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetKeyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).SetKey(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_SetKey_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).SetKey(ctx, req.(*SetKeyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_DelKey_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetKeyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).DelKey(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_DelKey_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).DelKey(ctx, req.(*GetKeyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_GetAllProcessEnvKey_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).GetAllProcessEnvKey(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_GetAllProcessEnvKey_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).GetAllProcessEnvKey(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_SetProcessEnvKey_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetKeyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).SetProcessEnvKey(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_SetProcessEnvKey_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).SetProcessEnvKey(ctx, req.(*SetKeyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_GetProjectKey_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetKeyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).GetProjectKey(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_GetProjectKey_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).GetProjectKey(ctx, req.(*GetKeyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_SetProjectKey_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetKeyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).SetProjectKey(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_SetProjectKey_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).SetProjectKey(ctx, req.(*SetKeyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_GetOnlineProfile_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).GetOnlineProfile(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_GetOnlineProfile_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).GetOnlineProfile(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_SetOnlineProfile_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(OnlineProfile)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).SetOnlineProfile(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_SetOnlineProfile_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).SetOnlineProfile(ctx, req.(*OnlineProfile))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_DownloadOnlinePluginById_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DownloadOnlinePluginByIdRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).DownloadOnlinePluginById(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_DownloadOnlinePluginById_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).DownloadOnlinePluginById(ctx, req.(*DownloadOnlinePluginByIdRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_DownloadOnlinePluginByIds_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DownloadOnlinePluginByIdsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).DownloadOnlinePluginByIds(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_DownloadOnlinePluginByIds_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).DownloadOnlinePluginByIds(ctx, req.(*DownloadOnlinePluginByIdsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_DownloadOnlinePluginAll_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(DownloadOnlinePluginByTokenRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(YakServer).DownloadOnlinePluginAll(m, &yakDownloadOnlinePluginAllServer{stream})
}

type Yak_DownloadOnlinePluginAllServer interface {
	Send(*DownloadOnlinePluginProgress) error
	grpc.ServerStream
}

type yakDownloadOnlinePluginAllServer struct {
	grpc.ServerStream
}

func (x *yakDownloadOnlinePluginAllServer) Send(m *DownloadOnlinePluginProgress) error {
	return x.ServerStream.SendMsg(m)
}

func _Yak_DeletePluginByUserID_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeletePluginByUserIDRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).DeletePluginByUserID(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_DeletePluginByUserID_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).DeletePluginByUserID(ctx, req.(*DeletePluginByUserIDRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_DeleteAllLocalPlugins_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).DeleteAllLocalPlugins(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_DeleteAllLocalPlugins_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).DeleteAllLocalPlugins(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_GetYakScriptTagsAndType_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).GetYakScriptTagsAndType(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_GetYakScriptTagsAndType_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).GetYakScriptTagsAndType(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_DeleteLocalPluginsByWhere_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteLocalPluginsByWhereRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).DeleteLocalPluginsByWhere(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_DeleteLocalPluginsByWhere_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).DeleteLocalPluginsByWhere(ctx, req.(*DeleteLocalPluginsByWhereRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_DownloadOnlinePluginByScriptNames_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DownloadOnlinePluginByScriptNamesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).DownloadOnlinePluginByScriptNames(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_DownloadOnlinePluginByScriptNames_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).DownloadOnlinePluginByScriptNames(ctx, req.(*DownloadOnlinePluginByScriptNamesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_ExecPacketScan_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(ExecPacketScanRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(YakServer).ExecPacketScan(m, &yakExecPacketScanServer{stream})
}

type Yak_ExecPacketScanServer interface {
	Send(*ExecResult) error
	grpc.ServerStream
}

type yakExecPacketScanServer struct {
	grpc.ServerStream
}

func (x *yakExecPacketScanServer) Send(m *ExecResult) error {
	return x.ServerStream.SendMsg(m)
}

func _Yak_GetEngineDefaultProxy_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).GetEngineDefaultProxy(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_GetEngineDefaultProxy_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).GetEngineDefaultProxy(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_SetEngineDefaultProxy_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DefaultProxyResult)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).SetEngineDefaultProxy(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_SetEngineDefaultProxy_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).SetEngineDefaultProxy(ctx, req.(*DefaultProxyResult))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_GetMachineID_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).GetMachineID(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_GetMachineID_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).GetMachineID(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_GetLicense_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).GetLicense(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_GetLicense_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).GetLicense(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_CheckLicense_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CheckLicenseRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).CheckLicense(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_CheckLicense_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).CheckLicense(ctx, req.(*CheckLicenseRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_GetRequestBodyByHTTPFlowID_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DownloadBodyByHTTPFlowIDRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).GetRequestBodyByHTTPFlowID(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_GetRequestBodyByHTTPFlowID_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).GetRequestBodyByHTTPFlowID(ctx, req.(*DownloadBodyByHTTPFlowIDRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_GetResponseBodyByHTTPFlowID_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DownloadBodyByHTTPFlowIDRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).GetResponseBodyByHTTPFlowID(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_GetResponseBodyByHTTPFlowID_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).GetResponseBodyByHTTPFlowID(ctx, req.(*DownloadBodyByHTTPFlowIDRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_GetHTTPPacketBody_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetHTTPPacketBodyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).GetHTTPPacketBody(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_GetHTTPPacketBody_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).GetHTTPPacketBody(ctx, req.(*GetHTTPPacketBodyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_RegisterFacadesHTTP_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RegisterFacadesHTTPRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).RegisterFacadesHTTP(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_RegisterFacadesHTTP_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).RegisterFacadesHTTP(ctx, req.(*RegisterFacadesHTTPRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_ResetAndInvalidUserData_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ResetAndInvalidUserDataRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).ResetAndInvalidUserData(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_ResetAndInvalidUserData_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).ResetAndInvalidUserData(ctx, req.(*ResetAndInvalidUserDataRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_CreateYaklangShell_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(YakServer).CreateYaklangShell(&yakCreateYaklangShellServer{stream})
}

type Yak_CreateYaklangShellServer interface {
	Send(*YaklangShellResponse) error
	Recv() (*YaklangShellRequest, error)
	grpc.ServerStream
}

type yakCreateYaklangShellServer struct {
	grpc.ServerStream
}

func (x *yakCreateYaklangShellServer) Send(m *YaklangShellResponse) error {
	return x.ServerStream.SendMsg(m)
}

func (x *yakCreateYaklangShellServer) Recv() (*YaklangShellRequest, error) {
	m := new(YaklangShellRequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _Yak_AttachCombinedOutput_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(AttachCombinedOutputRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(YakServer).AttachCombinedOutput(m, &yakAttachCombinedOutputServer{stream})
}

type Yak_AttachCombinedOutputServer interface {
	Send(*ExecResult) error
	grpc.ServerStream
}

type yakAttachCombinedOutputServer struct {
	grpc.ServerStream
}

func (x *yakAttachCombinedOutputServer) Send(m *ExecResult) error {
	return x.ServerStream.SendMsg(m)
}

func _Yak_IsPrivilegedForNetRaw_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).IsPrivilegedForNetRaw(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_IsPrivilegedForNetRaw_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).IsPrivilegedForNetRaw(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_PromotePermissionForUserPcap_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).PromotePermissionForUserPcap(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_PromotePermissionForUserPcap_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).PromotePermissionForUserPcap(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_SetCurrentProject_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetCurrentProjectRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).SetCurrentProject(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_SetCurrentProject_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).SetCurrentProject(ctx, req.(*SetCurrentProjectRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_GetCurrentProject_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).GetCurrentProject(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_GetCurrentProject_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).GetCurrentProject(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_GetProjects_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetProjectsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).GetProjects(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_GetProjects_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).GetProjects(ctx, req.(*GetProjectsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_NewProject_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NewProjectRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).NewProject(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_NewProject_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).NewProject(ctx, req.(*NewProjectRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_IsProjectNameValid_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IsProjectNameValidRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).IsProjectNameValid(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_IsProjectNameValid_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).IsProjectNameValid(ctx, req.(*IsProjectNameValidRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_RemoveProject_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RemoveProjectRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).RemoveProject(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_RemoveProject_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).RemoveProject(ctx, req.(*RemoveProjectRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_DeleteProject_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteProjectRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).DeleteProject(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_DeleteProject_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).DeleteProject(ctx, req.(*DeleteProjectRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_GetDefaultProject_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).GetDefaultProject(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_GetDefaultProject_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).GetDefaultProject(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_QueryProjectDetail_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryProjectDetailRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).QueryProjectDetail(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_QueryProjectDetail_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).QueryProjectDetail(ctx, req.(*QueryProjectDetailRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_ExportProject_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(ExportProjectRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(YakServer).ExportProject(m, &yakExportProjectServer{stream})
}

type Yak_ExportProjectServer interface {
	Send(*ProjectIOProgress) error
	grpc.ServerStream
}

type yakExportProjectServer struct {
	grpc.ServerStream
}

func (x *yakExportProjectServer) Send(m *ProjectIOProgress) error {
	return x.ServerStream.SendMsg(m)
}

func _Yak_ImportProject_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(ImportProjectRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(YakServer).ImportProject(m, &yakImportProjectServer{stream})
}

type Yak_ImportProjectServer interface {
	Send(*ProjectIOProgress) error
	grpc.ServerStream
}

type yakImportProjectServer struct {
	grpc.ServerStream
}

func (x *yakImportProjectServer) Send(m *ProjectIOProgress) error {
	return x.ServerStream.SendMsg(m)
}

func _Yak_MigrateLegacyDatabase_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).MigrateLegacyDatabase(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_MigrateLegacyDatabase_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).MigrateLegacyDatabase(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_QueryMITMRuleExtractedData_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryMITMRuleExtractedDataRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).QueryMITMRuleExtractedData(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_QueryMITMRuleExtractedData_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).QueryMITMRuleExtractedData(ctx, req.(*QueryMITMRuleExtractedDataRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_ImportChaosMakerRules_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ImportChaosMakerRulesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).ImportChaosMakerRules(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_ImportChaosMakerRules_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).ImportChaosMakerRules(ctx, req.(*ImportChaosMakerRulesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_QueryChaosMakerRule_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryChaosMakerRuleRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).QueryChaosMakerRule(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_QueryChaosMakerRule_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).QueryChaosMakerRule(ctx, req.(*QueryChaosMakerRuleRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_DeleteChaosMakerRuleByID_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteChaosMakerRuleByIDRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).DeleteChaosMakerRuleByID(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_DeleteChaosMakerRuleByID_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).DeleteChaosMakerRuleByID(ctx, req.(*DeleteChaosMakerRuleByIDRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_ExecuteChaosMakerRule_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(ExecuteChaosMakerRuleRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(YakServer).ExecuteChaosMakerRule(m, &yakExecuteChaosMakerRuleServer{stream})
}

type Yak_ExecuteChaosMakerRuleServer interface {
	Send(*ExecResult) error
	grpc.ServerStream
}

type yakExecuteChaosMakerRuleServer struct {
	grpc.ServerStream
}

func (x *yakExecuteChaosMakerRuleServer) Send(m *ExecResult) error {
	return x.ServerStream.SendMsg(m)
}

func _Yak_IsRemoteAddrAvailable_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IsRemoteAddrAvailableRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).IsRemoteAddrAvailable(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_IsRemoteAddrAvailable_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).IsRemoteAddrAvailable(ctx, req.(*IsRemoteAddrAvailableRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_ConnectVulinboxAgent_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IsRemoteAddrAvailableRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).ConnectVulinboxAgent(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_ConnectVulinboxAgent_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).ConnectVulinboxAgent(ctx, req.(*IsRemoteAddrAvailableRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_GetRegisteredVulinboxAgent_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetRegisteredAgentRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).GetRegisteredVulinboxAgent(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_GetRegisteredVulinboxAgent_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).GetRegisteredVulinboxAgent(ctx, req.(*GetRegisteredAgentRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_DisconnectVulinboxAgent_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DisconnectVulinboxAgentRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).DisconnectVulinboxAgent(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_DisconnectVulinboxAgent_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).DisconnectVulinboxAgent(ctx, req.(*DisconnectVulinboxAgentRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_IsCVEDatabaseReady_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IsCVEDatabaseReadyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).IsCVEDatabaseReady(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_IsCVEDatabaseReady_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).IsCVEDatabaseReady(ctx, req.(*IsCVEDatabaseReadyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_UpdateCVEDatabase_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(UpdateCVEDatabaseRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(YakServer).UpdateCVEDatabase(m, &yakUpdateCVEDatabaseServer{stream})
}

type Yak_UpdateCVEDatabaseServer interface {
	Send(*ExecResult) error
	grpc.ServerStream
}

type yakUpdateCVEDatabaseServer struct {
	grpc.ServerStream
}

func (x *yakUpdateCVEDatabaseServer) Send(m *ExecResult) error {
	return x.ServerStream.SendMsg(m)
}

func _Yak_ExportsProfileDatabase_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(ExportsProfileDatabaseRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(YakServer).ExportsProfileDatabase(m, &yakExportsProfileDatabaseServer{stream})
}

type Yak_ExportsProfileDatabaseServer interface {
	Send(*ExecResult) error
	grpc.ServerStream
}

type yakExportsProfileDatabaseServer struct {
	grpc.ServerStream
}

func (x *yakExportsProfileDatabaseServer) Send(m *ExecResult) error {
	return x.ServerStream.SendMsg(m)
}

func _Yak_ImportsProfileDatabase_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(ImportsProfileDatabaseRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(YakServer).ImportsProfileDatabase(m, &yakImportsProfileDatabaseServer{stream})
}

type Yak_ImportsProfileDatabaseServer interface {
	Send(*ExecResult) error
	grpc.ServerStream
}

type yakImportsProfileDatabaseServer struct {
	grpc.ServerStream
}

func (x *yakImportsProfileDatabaseServer) Send(m *ExecResult) error {
	return x.ServerStream.SendMsg(m)
}

func _Yak_QueryCVE_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryCVERequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).QueryCVE(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_QueryCVE_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).QueryCVE(ctx, req.(*QueryCVERequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_GetCVE_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetCVERequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).GetCVE(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_GetCVE_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).GetCVE(ctx, req.(*GetCVERequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_SaveTextToTemporalFile_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SaveTextToTemporalFileRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).SaveTextToTemporalFile(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_SaveTextToTemporalFile_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).SaveTextToTemporalFile(ctx, req.(*SaveTextToTemporalFileRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_IsScrecorderReady_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IsScrecorderReadyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).IsScrecorderReady(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_IsScrecorderReady_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).IsScrecorderReady(ctx, req.(*IsScrecorderReadyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_InstallScrecorder_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(InstallScrecorderRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(YakServer).InstallScrecorder(m, &yakInstallScrecorderServer{stream})
}

type Yak_InstallScrecorderServer interface {
	Send(*ExecResult) error
	grpc.ServerStream
}

type yakInstallScrecorderServer struct {
	grpc.ServerStream
}

func (x *yakInstallScrecorderServer) Send(m *ExecResult) error {
	return x.ServerStream.SendMsg(m)
}

func _Yak_StartScrecorder_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(StartScrecorderRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(YakServer).StartScrecorder(m, &yakStartScrecorderServer{stream})
}

type Yak_StartScrecorderServer interface {
	Send(*ExecResult) error
	grpc.ServerStream
}

type yakStartScrecorderServer struct {
	grpc.ServerStream
}

func (x *yakStartScrecorderServer) Send(m *ExecResult) error {
	return x.ServerStream.SendMsg(m)
}

func _Yak_QueryScreenRecorders_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryScreenRecorderRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).QueryScreenRecorders(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_QueryScreenRecorders_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).QueryScreenRecorders(ctx, req.(*QueryScreenRecorderRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_DeleteScreenRecorders_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryScreenRecorderRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).DeleteScreenRecorders(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_DeleteScreenRecorders_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).DeleteScreenRecorders(ctx, req.(*QueryScreenRecorderRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_UploadScreenRecorders_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UploadScreenRecorderRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).UploadScreenRecorders(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_UploadScreenRecorders_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).UploadScreenRecorders(ctx, req.(*UploadScreenRecorderRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_GetOneScreenRecorders_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetOneScreenRecorderRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).GetOneScreenRecorders(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_GetOneScreenRecorders_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).GetOneScreenRecorders(ctx, req.(*GetOneScreenRecorderRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_UpdateScreenRecorders_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateScreenRecorderRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).UpdateScreenRecorders(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_UpdateScreenRecorders_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).UpdateScreenRecorders(ctx, req.(*UpdateScreenRecorderRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_IsVulinboxReady_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IsVulinboxReadyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).IsVulinboxReady(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_IsVulinboxReady_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).IsVulinboxReady(ctx, req.(*IsVulinboxReadyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_InstallVulinbox_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(InstallVulinboxRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(YakServer).InstallVulinbox(m, &yakInstallVulinboxServer{stream})
}

type Yak_InstallVulinboxServer interface {
	Send(*ExecResult) error
	grpc.ServerStream
}

type yakInstallVulinboxServer struct {
	grpc.ServerStream
}

func (x *yakInstallVulinboxServer) Send(m *ExecResult) error {
	return x.ServerStream.SendMsg(m)
}

func _Yak_StartVulinbox_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(StartVulinboxRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(YakServer).StartVulinbox(m, &yakStartVulinboxServer{stream})
}

type Yak_StartVulinboxServer interface {
	Send(*ExecResult) error
	grpc.ServerStream
}

type yakStartVulinboxServer struct {
	grpc.ServerStream
}

func (x *yakStartVulinboxServer) Send(m *ExecResult) error {
	return x.ServerStream.SendMsg(m)
}

func _Yak_HTTPRequestBuilder_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(HTTPRequestBuilderParams)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).HTTPRequestBuilder(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_HTTPRequestBuilder_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).HTTPRequestBuilder(ctx, req.(*HTTPRequestBuilderParams))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_DebugPlugin_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(DebugPluginRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(YakServer).DebugPlugin(m, &yakDebugPluginServer{stream})
}

type Yak_DebugPluginServer interface {
	Send(*ExecResult) error
	grpc.ServerStream
}

type yakDebugPluginServer struct {
	grpc.ServerStream
}

func (x *yakDebugPluginServer) Send(m *ExecResult) error {
	return x.ServerStream.SendMsg(m)
}

func _Yak_SmokingEvaluatePlugin_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SmokingEvaluatePluginRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).SmokingEvaluatePlugin(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_SmokingEvaluatePlugin_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).SmokingEvaluatePlugin(ctx, req.(*SmokingEvaluatePluginRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Yak_GetSystemDefaultDnsServers_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YakServer).GetSystemDefaultDnsServers(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Yak_GetSystemDefaultDnsServers_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YakServer).GetSystemDefaultDnsServers(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

// Yak_ServiceDesc is the grpc.ServiceDesc for Yak service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Yak_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "ypb.Yak",
	HandlerType: (*YakServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Version",
			Handler:    _Yak_Version_Handler,
		},
		{
			MethodName: "Echo",
			Handler:    _Yak_Echo_Handler,
		},
		{
			MethodName: "SetMITMFilter",
			Handler:    _Yak_SetMITMFilter_Handler,
		},
		{
			MethodName: "GetMITMFilter",
			Handler:    _Yak_GetMITMFilter_Handler,
		},
		{
			MethodName: "DownloadMITMCert",
			Handler:    _Yak_DownloadMITMCert_Handler,
		},
		{
			MethodName: "QueryExecHistory",
			Handler:    _Yak_QueryExecHistory_Handler,
		},
		{
			MethodName: "RemoveExecHistory",
			Handler:    _Yak_RemoveExecHistory_Handler,
		},
		{
			MethodName: "LoadNucleiTemplates",
			Handler:    _Yak_LoadNucleiTemplates_Handler,
		},
		{
			MethodName: "GetExecBatchYakScriptUnfinishedTask",
			Handler:    _Yak_GetExecBatchYakScriptUnfinishedTask_Handler,
		},
		{
			MethodName: "GetExecBatchYakScriptUnfinishedTaskByUid",
			Handler:    _Yak_GetExecBatchYakScriptUnfinishedTaskByUid_Handler,
		},
		{
			MethodName: "PopExecBatchYakScriptUnfinishedTaskByUid",
			Handler:    _Yak_PopExecBatchYakScriptUnfinishedTaskByUid_Handler,
		},
		{
			MethodName: "QueryYakScript",
			Handler:    _Yak_QueryYakScript_Handler,
		},
		{
			MethodName: "SaveYakScript",
			Handler:    _Yak_SaveYakScript_Handler,
		},
		{
			MethodName: "DeleteYakScript",
			Handler:    _Yak_DeleteYakScript_Handler,
		},
		{
			MethodName: "GetYakScriptById",
			Handler:    _Yak_GetYakScriptById_Handler,
		},
		{
			MethodName: "GetYakScriptByName",
			Handler:    _Yak_GetYakScriptByName_Handler,
		},
		{
			MethodName: "GetYakScriptByOnlineID",
			Handler:    _Yak_GetYakScriptByOnlineID_Handler,
		},
		{
			MethodName: "IgnoreYakScript",
			Handler:    _Yak_IgnoreYakScript_Handler,
		},
		{
			MethodName: "UnIgnoreYakScript",
			Handler:    _Yak_UnIgnoreYakScript_Handler,
		},
		{
			MethodName: "ExportYakScript",
			Handler:    _Yak_ExportYakScript_Handler,
		},
		{
			MethodName: "GetYakScriptTags",
			Handler:    _Yak_GetYakScriptTags_Handler,
		},
		{
			MethodName: "QueryYakScriptLocalAndUser",
			Handler:    _Yak_QueryYakScriptLocalAndUser_Handler,
		},
		{
			MethodName: "QueryYakScriptByOnlineGroup",
			Handler:    _Yak_QueryYakScriptByOnlineGroup_Handler,
		},
		{
			MethodName: "QueryYakScriptLocalAll",
			Handler:    _Yak_QueryYakScriptLocalAll_Handler,
		},
		{
			MethodName: "QueryYakScriptByNames",
			Handler:    _Yak_QueryYakScriptByNames_Handler,
		},
		{
			MethodName: "GetHTTPFlowByHash",
			Handler:    _Yak_GetHTTPFlowByHash_Handler,
		},
		{
			MethodName: "GetHTTPFlowById",
			Handler:    _Yak_GetHTTPFlowById_Handler,
		},
		{
			MethodName: "GetHTTPFlowByIds",
			Handler:    _Yak_GetHTTPFlowByIds_Handler,
		},
		{
			MethodName: "QueryHTTPFlows",
			Handler:    _Yak_QueryHTTPFlows_Handler,
		},
		{
			MethodName: "DeleteHTTPFlows",
			Handler:    _Yak_DeleteHTTPFlows_Handler,
		},
		{
			MethodName: "SetTagForHTTPFlow",
			Handler:    _Yak_SetTagForHTTPFlow_Handler,
		},
		{
			MethodName: "QueryHTTPFlowsIds",
			Handler:    _Yak_QueryHTTPFlowsIds_Handler,
		},
		{
			MethodName: "HTTPFlowsFieldGroup",
			Handler:    _Yak_HTTPFlowsFieldGroup_Handler,
		},
		{
			MethodName: "HTTPFlowsShare",
			Handler:    _Yak_HTTPFlowsShare_Handler,
		},
		{
			MethodName: "HTTPFlowsExtract",
			Handler:    _Yak_HTTPFlowsExtract_Handler,
		},
		{
			MethodName: "ExtractUrl",
			Handler:    _Yak_ExtractUrl_Handler,
		},
		{
			MethodName: "GetHistoryHTTPFuzzerTask",
			Handler:    _Yak_GetHistoryHTTPFuzzerTask_Handler,
		},
		{
			MethodName: "QueryHistoryHTTPFuzzerTask",
			Handler:    _Yak_QueryHistoryHTTPFuzzerTask_Handler,
		},
		{
			MethodName: "QueryHistoryHTTPFuzzerTaskEx",
			Handler:    _Yak_QueryHistoryHTTPFuzzerTaskEx_Handler,
		},
		{
			MethodName: "DeleteHistoryHTTPFuzzerTask",
			Handler:    _Yak_DeleteHistoryHTTPFuzzerTask_Handler,
		},
		{
			MethodName: "PreloadHTTPFuzzerParams",
			Handler:    _Yak_PreloadHTTPFuzzerParams_Handler,
		},
		{
			MethodName: "RenderVariables",
			Handler:    _Yak_RenderVariables_Handler,
		},
		{
			MethodName: "MatchHTTPResponse",
			Handler:    _Yak_MatchHTTPResponse_Handler,
		},
		{
			MethodName: "ExtractHTTPResponse",
			Handler:    _Yak_ExtractHTTPResponse_Handler,
		},
		{
			MethodName: "RedirectRequest",
			Handler:    _Yak_RedirectRequest_Handler,
		},
		{
			MethodName: "HTTPRequestMutate",
			Handler:    _Yak_HTTPRequestMutate_Handler,
		},
		{
			MethodName: "HTTPResponseMutate",
			Handler:    _Yak_HTTPResponseMutate_Handler,
		},
		{
			MethodName: "FixUploadPacket",
			Handler:    _Yak_FixUploadPacket_Handler,
		},
		{
			MethodName: "IsMultipartFormDataRequest",
			Handler:    _Yak_IsMultipartFormDataRequest_Handler,
		},
		{
			MethodName: "GenerateExtractRule",
			Handler:    _Yak_GenerateExtractRule_Handler,
		},
		{
			MethodName: "SaveFuzzerLabel",
			Handler:    _Yak_SaveFuzzerLabel_Handler,
		},
		{
			MethodName: "QueryFuzzerLabel",
			Handler:    _Yak_QueryFuzzerLabel_Handler,
		},
		{
			MethodName: "DeleteFuzzerLabel",
			Handler:    _Yak_DeleteFuzzerLabel_Handler,
		},
		{
			MethodName: "QueryHTTPFuzzerResponseByTaskId",
			Handler:    _Yak_QueryHTTPFuzzerResponseByTaskId_Handler,
		},
		{
			MethodName: "QueryWebsocketFlowByHTTPFlowWebsocketHash",
			Handler:    _Yak_QueryWebsocketFlowByHTTPFlowWebsocketHash_Handler,
		},
		{
			MethodName: "DeleteWebsocketFlowByHTTPFlowWebsocketHash",
			Handler:    _Yak_DeleteWebsocketFlowByHTTPFlowWebsocketHash_Handler,
		},
		{
			MethodName: "DeleteWebsocketFlowAll",
			Handler:    _Yak_DeleteWebsocketFlowAll_Handler,
		},
		{
			MethodName: "ConvertFuzzerResponseToHTTPFlow",
			Handler:    _Yak_ConvertFuzzerResponseToHTTPFlow_Handler,
		},
		{
			MethodName: "StringFuzzer",
			Handler:    _Yak_StringFuzzer_Handler,
		},
		{
			MethodName: "HTTPRequestAnalyzer",
			Handler:    _Yak_HTTPRequestAnalyzer_Handler,
		},
		{
			MethodName: "Codec",
			Handler:    _Yak_Codec_Handler,
		},
		{
			MethodName: "QueryPayload",
			Handler:    _Yak_QueryPayload_Handler,
		},
		{
			MethodName: "DeletePayloadByGroup",
			Handler:    _Yak_DeletePayloadByGroup_Handler,
		},
		{
			MethodName: "DeletePayload",
			Handler:    _Yak_DeletePayload_Handler,
		},
		{
			MethodName: "SavePayload",
			Handler:    _Yak_SavePayload_Handler,
		},
		{
			MethodName: "GetAllPayloadGroup",
			Handler:    _Yak_GetAllPayloadGroup_Handler,
		},
		{
			MethodName: "UpdatePayload",
			Handler:    _Yak_UpdatePayload_Handler,
		},
		{
			MethodName: "GetAllPayload",
			Handler:    _Yak_GetAllPayload_Handler,
		},
		{
			MethodName: "GetYakitCompletionRaw",
			Handler:    _Yak_GetYakitCompletionRaw_Handler,
		},
		{
			MethodName: "GetYakVMBuildInMethodCompletion",
			Handler:    _Yak_GetYakVMBuildInMethodCompletion_Handler,
		},
		{
			MethodName: "StaticAnalyzeError",
			Handler:    _Yak_StaticAnalyzeError_Handler,
		},
		{
			MethodName: "YaklangCompileAndFormat",
			Handler:    _Yak_YaklangCompileAndFormat_Handler,
		},
		{
			MethodName: "ViewPortScanCode",
			Handler:    _Yak_ViewPortScanCode_Handler,
		},
		{
			MethodName: "SaveCancelSimpleDetect",
			Handler:    _Yak_SaveCancelSimpleDetect_Handler,
		},
		{
			MethodName: "GetSimpleDetectUnfinishedTask",
			Handler:    _Yak_GetSimpleDetectUnfinishedTask_Handler,
		},
		{
			MethodName: "GetSimpleDetectUnfinishedTaskByUid",
			Handler:    _Yak_GetSimpleDetectUnfinishedTaskByUid_Handler,
		},
		{
			MethodName: "PopSimpleDetectUnfinishedTaskByUid",
			Handler:    _Yak_PopSimpleDetectUnfinishedTaskByUid_Handler,
		},
		{
			MethodName: "QueryPorts",
			Handler:    _Yak_QueryPorts_Handler,
		},
		{
			MethodName: "DeletePorts",
			Handler:    _Yak_DeletePorts_Handler,
		},
		{
			MethodName: "QueryHosts",
			Handler:    _Yak_QueryHosts_Handler,
		},
		{
			MethodName: "DeleteHosts",
			Handler:    _Yak_DeleteHosts_Handler,
		},
		{
			MethodName: "QueryDomains",
			Handler:    _Yak_QueryDomains_Handler,
		},
		{
			MethodName: "DeleteDomains",
			Handler:    _Yak_DeleteDomains_Handler,
		},
		{
			MethodName: "QueryPortsGroup",
			Handler:    _Yak_QueryPortsGroup_Handler,
		},
		{
			MethodName: "UpdateFromYakitResource",
			Handler:    _Yak_UpdateFromYakitResource_Handler,
		},
		{
			MethodName: "UpdateFromGithub",
			Handler:    _Yak_UpdateFromGithub_Handler,
		},
		{
			MethodName: "AddToMenu",
			Handler:    _Yak_AddToMenu_Handler,
		},
		{
			MethodName: "RemoveFromMenu",
			Handler:    _Yak_RemoveFromMenu_Handler,
		},
		{
			MethodName: "YakScriptIsInMenu",
			Handler:    _Yak_YakScriptIsInMenu_Handler,
		},
		{
			MethodName: "GetAllMenuItem",
			Handler:    _Yak_GetAllMenuItem_Handler,
		},
		{
			MethodName: "DeleteAllMenuItem",
			Handler:    _Yak_DeleteAllMenuItem_Handler,
		},
		{
			MethodName: "ImportMenuItem",
			Handler:    _Yak_ImportMenuItem_Handler,
		},
		{
			MethodName: "ExportMenuItem",
			Handler:    _Yak_ExportMenuItem_Handler,
		},
		{
			MethodName: "GetMenuItemById",
			Handler:    _Yak_GetMenuItemById_Handler,
		},
		{
			MethodName: "QueryGroupsByYakScriptId",
			Handler:    _Yak_QueryGroupsByYakScriptId_Handler,
		},
		{
			MethodName: "AddMenus",
			Handler:    _Yak_AddMenus_Handler,
		},
		{
			MethodName: "QueryAllMenuItem",
			Handler:    _Yak_QueryAllMenuItem_Handler,
		},
		{
			MethodName: "DeleteAllMenu",
			Handler:    _Yak_DeleteAllMenu_Handler,
		},
		{
			MethodName: "AddToNavigation",
			Handler:    _Yak_AddToNavigation_Handler,
		},
		{
			MethodName: "GetAllNavigationItem",
			Handler:    _Yak_GetAllNavigationItem_Handler,
		},
		{
			MethodName: "DeleteAllNavigation",
			Handler:    _Yak_DeleteAllNavigation_Handler,
		},
		{
			MethodName: "AddOneNavigation",
			Handler:    _Yak_AddOneNavigation_Handler,
		},
		{
			MethodName: "QueryNavigationGroups",
			Handler:    _Yak_QueryNavigationGroups_Handler,
		},
		{
			MethodName: "SaveMarkdownDocument",
			Handler:    _Yak_SaveMarkdownDocument_Handler,
		},
		{
			MethodName: "GetMarkdownDocument",
			Handler:    _Yak_GetMarkdownDocument_Handler,
		},
		{
			MethodName: "DeleteMarkdownDocument",
			Handler:    _Yak_DeleteMarkdownDocument_Handler,
		},
		{
			MethodName: "StartBasicCrawler",
			Handler:    _Yak_StartBasicCrawler_Handler,
		},
		{
			MethodName: "ViewBasicCrawlerCode",
			Handler:    _Yak_ViewBasicCrawlerCode_Handler,
		},
		{
			MethodName: "GenerateWebsiteTree",
			Handler:    _Yak_GenerateWebsiteTree_Handler,
		},
		{
			MethodName: "QueryYakScriptExecResult",
			Handler:    _Yak_QueryYakScriptExecResult_Handler,
		},
		{
			MethodName: "QueryYakScriptNameInExecResult",
			Handler:    _Yak_QueryYakScriptNameInExecResult_Handler,
		},
		{
			MethodName: "DeleteYakScriptExecResult",
			Handler:    _Yak_DeleteYakScriptExecResult_Handler,
		},
		{
			MethodName: "DeleteYakScriptExec",
			Handler:    _Yak_DeleteYakScriptExec_Handler,
		},
		{
			MethodName: "GetAvailableBruteTypes",
			Handler:    _Yak_GetAvailableBruteTypes_Handler,
		},
		{
			MethodName: "GetTunnelServerExternalIP",
			Handler:    _Yak_GetTunnelServerExternalIP_Handler,
		},
		{
			MethodName: "VerifyTunnelServerDomain",
			Handler:    _Yak_VerifyTunnelServerDomain_Handler,
		},
		{
			MethodName: "ApplyClassToFacades",
			Handler:    _Yak_ApplyClassToFacades_Handler,
		},
		{
			MethodName: "BytesToBase64",
			Handler:    _Yak_BytesToBase64_Handler,
		},
		{
			MethodName: "AvailableLocalAddr",
			Handler:    _Yak_AvailableLocalAddr_Handler,
		},
		{
			MethodName: "GetGlobalReverseServer",
			Handler:    _Yak_GetGlobalReverseServer_Handler,
		},
		{
			MethodName: "QueryRisks",
			Handler:    _Yak_QueryRisks_Handler,
		},
		{
			MethodName: "QueryRisk",
			Handler:    _Yak_QueryRisk_Handler,
		},
		{
			MethodName: "DeleteRisk",
			Handler:    _Yak_DeleteRisk_Handler,
		},
		{
			MethodName: "QueryAvailableRiskType",
			Handler:    _Yak_QueryAvailableRiskType_Handler,
		},
		{
			MethodName: "QueryAvailableRiskLevel",
			Handler:    _Yak_QueryAvailableRiskLevel_Handler,
		},
		{
			MethodName: "QueryRiskTableStats",
			Handler:    _Yak_QueryRiskTableStats_Handler,
		},
		{
			MethodName: "ResetRiskTableStats",
			Handler:    _Yak_ResetRiskTableStats_Handler,
		},
		{
			MethodName: "QueryAvailableTarget",
			Handler:    _Yak_QueryAvailableTarget_Handler,
		},
		{
			MethodName: "QueryNewRisk",
			Handler:    _Yak_QueryNewRisk_Handler,
		},
		{
			MethodName: "NewRiskRead",
			Handler:    _Yak_NewRiskRead_Handler,
		},
		{
			MethodName: "UploadRiskToOnline",
			Handler:    _Yak_UploadRiskToOnline_Handler,
		},
		{
			MethodName: "QueryReports",
			Handler:    _Yak_QueryReports_Handler,
		},
		{
			MethodName: "QueryReport",
			Handler:    _Yak_QueryReport_Handler,
		},
		{
			MethodName: "DeleteReport",
			Handler:    _Yak_DeleteReport_Handler,
		},
		{
			MethodName: "QueryAvailableReportFrom",
			Handler:    _Yak_QueryAvailableReportFrom_Handler,
		},
		{
			MethodName: "DownloadReport",
			Handler:    _Yak_DownloadReport_Handler,
		},
		{
			MethodName: "GetAllYsoGadgetOptions",
			Handler:    _Yak_GetAllYsoGadgetOptions_Handler,
		},
		{
			MethodName: "GetAllYsoClassOptions",
			Handler:    _Yak_GetAllYsoClassOptions_Handler,
		},
		{
			MethodName: "GetAllYsoClassGeneraterOptions",
			Handler:    _Yak_GetAllYsoClassGeneraterOptions_Handler,
		},
		{
			MethodName: "GenerateYsoCode",
			Handler:    _Yak_GenerateYsoCode_Handler,
		},
		{
			MethodName: "GenerateYsoBytes",
			Handler:    _Yak_GenerateYsoBytes_Handler,
		},
		{
			MethodName: "YsoDump",
			Handler:    _Yak_YsoDump_Handler,
		},
		{
			MethodName: "SetYakBridgeLogServer",
			Handler:    _Yak_SetYakBridgeLogServer_Handler,
		},
		{
			MethodName: "GetCurrentYakBridgeLogServer",
			Handler:    _Yak_GetCurrentYakBridgeLogServer_Handler,
		},
		{
			MethodName: "RequireDNSLogDomain",
			Handler:    _Yak_RequireDNSLogDomain_Handler,
		},
		{
			MethodName: "QueryDNSLogByToken",
			Handler:    _Yak_QueryDNSLogByToken_Handler,
		},
		{
			MethodName: "RequireICMPRandomLength",
			Handler:    _Yak_RequireICMPRandomLength_Handler,
		},
		{
			MethodName: "QueryICMPTrigger",
			Handler:    _Yak_QueryICMPTrigger_Handler,
		},
		{
			MethodName: "RequireRandomPortToken",
			Handler:    _Yak_RequireRandomPortToken_Handler,
		},
		{
			MethodName: "QueryRandomPortTrigger",
			Handler:    _Yak_QueryRandomPortTrigger_Handler,
		},
		{
			MethodName: "GetAvailableYakScriptTags",
			Handler:    _Yak_GetAvailableYakScriptTags_Handler,
		},
		{
			MethodName: "ForceUpdateAvailableYakScriptTags",
			Handler:    _Yak_ForceUpdateAvailableYakScriptTags_Handler,
		},
		{
			MethodName: "GenerateYakCodeByPacket",
			Handler:    _Yak_GenerateYakCodeByPacket_Handler,
		},
		{
			MethodName: "GenerateCSRFPocByPacket",
			Handler:    _Yak_GenerateCSRFPocByPacket_Handler,
		},
		{
			MethodName: "ExportMITMReplacerRules",
			Handler:    _Yak_ExportMITMReplacerRules_Handler,
		},
		{
			MethodName: "ImportMITMReplacerRules",
			Handler:    _Yak_ImportMITMReplacerRules_Handler,
		},
		{
			MethodName: "GetCurrentRules",
			Handler:    _Yak_GetCurrentRules_Handler,
		},
		{
			MethodName: "SetCurrentRules",
			Handler:    _Yak_SetCurrentRules_Handler,
		},
		{
			MethodName: "AutoDecode",
			Handler:    _Yak_AutoDecode_Handler,
		},
		{
			MethodName: "GetSystemProxy",
			Handler:    _Yak_GetSystemProxy_Handler,
		},
		{
			MethodName: "SetSystemProxy",
			Handler:    _Yak_SetSystemProxy_Handler,
		},
		{
			MethodName: "GetKey",
			Handler:    _Yak_GetKey_Handler,
		},
		{
			MethodName: "SetKey",
			Handler:    _Yak_SetKey_Handler,
		},
		{
			MethodName: "DelKey",
			Handler:    _Yak_DelKey_Handler,
		},
		{
			MethodName: "GetAllProcessEnvKey",
			Handler:    _Yak_GetAllProcessEnvKey_Handler,
		},
		{
			MethodName: "SetProcessEnvKey",
			Handler:    _Yak_SetProcessEnvKey_Handler,
		},
		{
			MethodName: "GetProjectKey",
			Handler:    _Yak_GetProjectKey_Handler,
		},
		{
			MethodName: "SetProjectKey",
			Handler:    _Yak_SetProjectKey_Handler,
		},
		{
			MethodName: "GetOnlineProfile",
			Handler:    _Yak_GetOnlineProfile_Handler,
		},
		{
			MethodName: "SetOnlineProfile",
			Handler:    _Yak_SetOnlineProfile_Handler,
		},
		{
			MethodName: "DownloadOnlinePluginById",
			Handler:    _Yak_DownloadOnlinePluginById_Handler,
		},
		{
			MethodName: "DownloadOnlinePluginByIds",
			Handler:    _Yak_DownloadOnlinePluginByIds_Handler,
		},
		{
			MethodName: "DeletePluginByUserID",
			Handler:    _Yak_DeletePluginByUserID_Handler,
		},
		{
			MethodName: "DeleteAllLocalPlugins",
			Handler:    _Yak_DeleteAllLocalPlugins_Handler,
		},
		{
			MethodName: "GetYakScriptTagsAndType",
			Handler:    _Yak_GetYakScriptTagsAndType_Handler,
		},
		{
			MethodName: "DeleteLocalPluginsByWhere",
			Handler:    _Yak_DeleteLocalPluginsByWhere_Handler,
		},
		{
			MethodName: "DownloadOnlinePluginByScriptNames",
			Handler:    _Yak_DownloadOnlinePluginByScriptNames_Handler,
		},
		{
			MethodName: "GetEngineDefaultProxy",
			Handler:    _Yak_GetEngineDefaultProxy_Handler,
		},
		{
			MethodName: "SetEngineDefaultProxy",
			Handler:    _Yak_SetEngineDefaultProxy_Handler,
		},
		{
			MethodName: "GetMachineID",
			Handler:    _Yak_GetMachineID_Handler,
		},
		{
			MethodName: "GetLicense",
			Handler:    _Yak_GetLicense_Handler,
		},
		{
			MethodName: "CheckLicense",
			Handler:    _Yak_CheckLicense_Handler,
		},
		{
			MethodName: "GetRequestBodyByHTTPFlowID",
			Handler:    _Yak_GetRequestBodyByHTTPFlowID_Handler,
		},
		{
			MethodName: "GetResponseBodyByHTTPFlowID",
			Handler:    _Yak_GetResponseBodyByHTTPFlowID_Handler,
		},
		{
			MethodName: "GetHTTPPacketBody",
			Handler:    _Yak_GetHTTPPacketBody_Handler,
		},
		{
			MethodName: "RegisterFacadesHTTP",
			Handler:    _Yak_RegisterFacadesHTTP_Handler,
		},
		{
			MethodName: "ResetAndInvalidUserData",
			Handler:    _Yak_ResetAndInvalidUserData_Handler,
		},
		{
			MethodName: "IsPrivilegedForNetRaw",
			Handler:    _Yak_IsPrivilegedForNetRaw_Handler,
		},
		{
			MethodName: "PromotePermissionForUserPcap",
			Handler:    _Yak_PromotePermissionForUserPcap_Handler,
		},
		{
			MethodName: "SetCurrentProject",
			Handler:    _Yak_SetCurrentProject_Handler,
		},
		{
			MethodName: "GetCurrentProject",
			Handler:    _Yak_GetCurrentProject_Handler,
		},
		{
			MethodName: "GetProjects",
			Handler:    _Yak_GetProjects_Handler,
		},
		{
			MethodName: "NewProject",
			Handler:    _Yak_NewProject_Handler,
		},
		{
			MethodName: "IsProjectNameValid",
			Handler:    _Yak_IsProjectNameValid_Handler,
		},
		{
			MethodName: "RemoveProject",
			Handler:    _Yak_RemoveProject_Handler,
		},
		{
			MethodName: "DeleteProject",
			Handler:    _Yak_DeleteProject_Handler,
		},
		{
			MethodName: "GetDefaultProject",
			Handler:    _Yak_GetDefaultProject_Handler,
		},
		{
			MethodName: "QueryProjectDetail",
			Handler:    _Yak_QueryProjectDetail_Handler,
		},
		{
			MethodName: "MigrateLegacyDatabase",
			Handler:    _Yak_MigrateLegacyDatabase_Handler,
		},
		{
			MethodName: "QueryMITMRuleExtractedData",
			Handler:    _Yak_QueryMITMRuleExtractedData_Handler,
		},
		{
			MethodName: "ImportChaosMakerRules",
			Handler:    _Yak_ImportChaosMakerRules_Handler,
		},
		{
			MethodName: "QueryChaosMakerRule",
			Handler:    _Yak_QueryChaosMakerRule_Handler,
		},
		{
			MethodName: "DeleteChaosMakerRuleByID",
			Handler:    _Yak_DeleteChaosMakerRuleByID_Handler,
		},
		{
			MethodName: "IsRemoteAddrAvailable",
			Handler:    _Yak_IsRemoteAddrAvailable_Handler,
		},
		{
			MethodName: "ConnectVulinboxAgent",
			Handler:    _Yak_ConnectVulinboxAgent_Handler,
		},
		{
			MethodName: "GetRegisteredVulinboxAgent",
			Handler:    _Yak_GetRegisteredVulinboxAgent_Handler,
		},
		{
			MethodName: "DisconnectVulinboxAgent",
			Handler:    _Yak_DisconnectVulinboxAgent_Handler,
		},
		{
			MethodName: "IsCVEDatabaseReady",
			Handler:    _Yak_IsCVEDatabaseReady_Handler,
		},
		{
			MethodName: "QueryCVE",
			Handler:    _Yak_QueryCVE_Handler,
		},
		{
			MethodName: "GetCVE",
			Handler:    _Yak_GetCVE_Handler,
		},
		{
			MethodName: "SaveTextToTemporalFile",
			Handler:    _Yak_SaveTextToTemporalFile_Handler,
		},
		{
			MethodName: "IsScrecorderReady",
			Handler:    _Yak_IsScrecorderReady_Handler,
		},
		{
			MethodName: "QueryScreenRecorders",
			Handler:    _Yak_QueryScreenRecorders_Handler,
		},
		{
			MethodName: "DeleteScreenRecorders",
			Handler:    _Yak_DeleteScreenRecorders_Handler,
		},
		{
			MethodName: "UploadScreenRecorders",
			Handler:    _Yak_UploadScreenRecorders_Handler,
		},
		{
			MethodName: "GetOneScreenRecorders",
			Handler:    _Yak_GetOneScreenRecorders_Handler,
		},
		{
			MethodName: "UpdateScreenRecorders",
			Handler:    _Yak_UpdateScreenRecorders_Handler,
		},
		{
			MethodName: "IsVulinboxReady",
			Handler:    _Yak_IsVulinboxReady_Handler,
		},
		{
			MethodName: "HTTPRequestBuilder",
			Handler:    _Yak_HTTPRequestBuilder_Handler,
		},
		{
			MethodName: "SmokingEvaluatePlugin",
			Handler:    _Yak_SmokingEvaluatePlugin_Handler,
		},
		{
			MethodName: "GetSystemDefaultDnsServers",
			Handler:    _Yak_GetSystemDefaultDnsServers_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "MITM",
			Handler:       _Yak_MITM_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
		{
			StreamName:    "OpenPort",
			Handler:       _Yak_OpenPort_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
		{
			StreamName:    "Exec",
			Handler:       _Yak_Exec_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "AutoUpdateYakModule",
			Handler:       _Yak_AutoUpdateYakModule_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "ExecYakScript",
			Handler:       _Yak_ExecYakScript_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "ExecBatchYakScript",
			Handler:       _Yak_ExecBatchYakScript_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "RecoverExecBatchYakScriptUnfinishedTask",
			Handler:       _Yak_RecoverExecBatchYakScriptUnfinishedTask_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "QueryYakScriptByYakScriptName",
			Handler:       _Yak_QueryYakScriptByYakScriptName_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "ExecutePacketYakScript",
			Handler:       _Yak_ExecutePacketYakScript_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "ExecuteBatchPacketYakScript",
			Handler:       _Yak_ExecuteBatchPacketYakScript_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "HTTPFuzzer",
			Handler:       _Yak_HTTPFuzzer_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "ExtractData",
			Handler:       _Yak_ExtractData_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
		{
			StreamName:    "CreateWebsocketFuzzer",
			Handler:       _Yak_CreateWebsocketFuzzer_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
		{
			StreamName:    "SavePayloadStream",
			Handler:       _Yak_SavePayloadStream_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "PortScan",
			Handler:       _Yak_PortScan_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "SimpleDetect",
			Handler:       _Yak_SimpleDetect_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "RecoverSimpleDetectUnfinishedTask",
			Handler:       _Yak_RecoverSimpleDetectUnfinishedTask_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "StartBrute",
			Handler:       _Yak_StartBrute_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "StartFacades",
			Handler:       _Yak_StartFacades_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "StartFacadesWithYsoObject",
			Handler:       _Yak_StartFacadesWithYsoObject_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "ConfigGlobalReverse",
			Handler:       _Yak_ConfigGlobalReverse_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "ExecYakitPluginsByYakScriptFilter",
			Handler:       _Yak_ExecYakitPluginsByYakScriptFilter_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "ExtractDataToFile",
			Handler:       _Yak_ExtractDataToFile_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
		{
			StreamName:    "DownloadOnlinePluginAll",
			Handler:       _Yak_DownloadOnlinePluginAll_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "ExecPacketScan",
			Handler:       _Yak_ExecPacketScan_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "CreateYaklangShell",
			Handler:       _Yak_CreateYaklangShell_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
		{
			StreamName:    "AttachCombinedOutput",
			Handler:       _Yak_AttachCombinedOutput_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "ExportProject",
			Handler:       _Yak_ExportProject_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "ImportProject",
			Handler:       _Yak_ImportProject_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "ExecuteChaosMakerRule",
			Handler:       _Yak_ExecuteChaosMakerRule_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "UpdateCVEDatabase",
			Handler:       _Yak_UpdateCVEDatabase_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "ExportsProfileDatabase",
			Handler:       _Yak_ExportsProfileDatabase_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "ImportsProfileDatabase",
			Handler:       _Yak_ImportsProfileDatabase_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "InstallScrecorder",
			Handler:       _Yak_InstallScrecorder_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "StartScrecorder",
			Handler:       _Yak_StartScrecorder_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "InstallVulinbox",
			Handler:       _Yak_InstallVulinbox_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "StartVulinbox",
			Handler:       _Yak_StartVulinbox_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "DebugPlugin",
			Handler:       _Yak_DebugPlugin_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "yakgrpc.proto",
}
