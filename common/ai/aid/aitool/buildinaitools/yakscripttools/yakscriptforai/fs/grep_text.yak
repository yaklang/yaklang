__DESC__ = "一个文本查找工具，用于在指定文件中搜索目标文本，并输出每次匹配到的文本在文件中的起始和结束位置（索引）。支持指定文件路径或目录进行递归搜索。"

__KEYWORDS__ = "file path,文本处理,命令行工具,文件内容搜索,text finder,grep,file searching,文件搜索,文件路径,search tool,string matching,command line,utility,文本查找,位置查找,text search,position,字符串匹配"

yakit.AutoInitYakit()

pathName := cli.String("path", cli.setHelp("the filepath you want to check"), cli.setRequired(true))
target := cli.String("text", cli.setHelp("target text you want to grep"), cli.setRequired(true))
maxResult := cli.Int("limit", cli.setHelp("max times (limit) grep for results"),  cli.setDefault(10))
offset := cli.Int("offset", cli.setHelp("skip how many first match"), cli.setDefault(0))

cli.check()

if !file.IsExisted(pathName) {
    yakit.Info("no such path: %v" % pathName)
    return
}
if target == "" {
    yakit.Info("grep target not right")
    return
}

count := 0
m := sync.NewMutex()

defer func{
    if count<= 0 { yakit.Info(f"not `${target}` find") }
}

output = (targetFile, offset, offsetEnd) => {
    m.Lock()
    defer m.Unlock()
    count++
    yakit.Info("find in %v index:%v-%v" % [targetFile, offset, offsetEnd])
}

handle = (targetFile, content) => {
    offset := str.Index(content, target)
    if offset < 0 {
        return
    }

    output(targetFile, offset, offset+len(target))
    for {
        newOffset := str.Index(content[offset+1:], target)
        if newOffset < 0 { return }
        newOffset += 1 + offset
        output(targetFile, newOffset, newOffset + len(target))
        offset = newOffset
    }
}

if file.IsDir(pathName) {
    filesys.Recursive(pathName, filesys.onFileStat((fileToCheck, info) => {
        defer recover()
        handle(fileToCheck, string(file.ReadFile(fileToCheck)~))
    }))
} else {
    result = file.ReadFile(pathName)~
    handle(pathName, string(result))
}