__DESC__ = "一个用于查看目录树形结构的工具，支持显示目录下的文件和子目录层级关系，默认排除 .git/node_modules 等噪声目录。支持名称黑白名单和扩展名黑白名单过滤。适用于目录结构分析、项目概览等场景。"
__VERBOSE_NAME__ = "目录树形结构查看工具"
__KEYWORDS__ = "directory tree,目录结构,树形结构,文件系统浏览,directory listing,文件夹结构,文件树,file hierarchy,目录浏览,directory navigation,exclude,include,extension filter"

__USAGE__ = <<<USAGE_BLOCK
Directory Tree Viewing Tool - Parameter Description for JSON Tool Calls

Required Parameters:
  path            (string)  The absolute or relative directory path to display as a tree.
                            Must point to an existing directory.

Optional Parameters:
  exclude         (string)  Comma-separated list of directory/file names to exclude.
                            Each name is matched against EVERY path component individually.
                            For example, "node_modules,.git" will skip any entry whose path
                            contains a component exactly named "node_modules" or ".git".
                            This means subdirectories inside excluded directories are also skipped.
                            Default: ".git,.svn,.hg,node_modules,__pycache__,.DS_Store,.idea,.vscode,.next,.nuxt,.cache"
                            Set to "" (empty string) to disable all name exclusions.
  include         (string)  Comma-separated list of name substrings for whitelist filtering.
                            When set (non-empty), only FILES whose filename contains at least one
                            of these substrings will appear in the tree output.
                            IMPORTANT: Directories always pass this filter so their children
                            can still be explored. Only leaf file names are filtered.
                            Default: "" (disabled, all filenames pass).
  exclude-ext     (string)  Comma-separated list of file extensions to exclude (blacklist).
                            Each extension is matched case-insensitively against file extensions.
                            The dot prefix is optional: both "pyc" and ".pyc" are accepted.
                            Directories are NEVER affected by extension filters.
                            Default: "" (disabled).
  include-ext     (string)  Comma-separated list of file extensions to include (whitelist).
                            When set, only files whose extension matches one of these values are shown.
                            The dot prefix is optional: both "go" and ".go" are accepted.
                            Directories always pass this filter.
                            Default: "" (disabled, all extensions pass).
  max-depth       (int)     Maximum directory depth to recurse into. Entries deeper than this
                            level are not shown. Default: 6.
  max-lines       (int)     Maximum total lines in the output. Once reached, remaining entries
                            are truncated with a notice. Default: 200.

Filter Evaluation Order:
  1. exclude name blacklist (path component exact match)
  2. include name whitelist (filename substring match, directories pass)
  3. exclude-ext extension blacklist (file extension match, directories pass)
  4. include-ext extension whitelist (file extension match, directories pass)
  5. max-depth check
USAGE_BLOCK

yakit.AutoInitYakit()

// Parse CLI arguments
path := cli.String("path", cli.setRequired(true), cli.setHelp("directory path to display tree structure"))
excludeRaw := cli.String("exclude", cli.setHelp("comma-separated list of directory/file names to exclude from tree view"), cli.setDefault(".git,.svn,.hg,node_modules,__pycache__,.DS_Store,.idea,.vscode,.next,.nuxt,.cache"))
includeRaw := cli.String("include", cli.setHelp("comma-separated list of name substrings to include (whitelist, only matching entries shown)"), cli.setDefault(""))
excludeExtRaw := cli.String("exclude-ext", cli.setHelp("comma-separated list of file extensions to exclude (e.g. '.pyc,.o,.so')"), cli.setDefault(""))
includeExtRaw := cli.String("include-ext", cli.setHelp("comma-separated list of file extensions to include (whitelist, e.g. '.go,.js,.py')"), cli.setDefault(""))
maxDepth := cli.Int("max-depth", cli.setHelp("maximum directory depth to display"), cli.setDefault(6))
maxLines := cli.Int("max-lines", cli.setHelp("maximum number of lines to display"), cli.setDefault(200))

cli.check()

yakit.Info("Viewing directory tree structure: %v", path)

// Check path existence
if !file.IsExisted(path) {
    errMsg = sprintf("Path does not exist: %v", path)
    yakit.Error(errMsg)
    println(errMsg)
    return
}

// Check is directory
if !file.IsDir(path) {
    errMsg = sprintf("Path is not a directory: %v", path)
    yakit.Error(errMsg)
    println(errMsg)
    return
}

// Parse exclude name list
excludeNames = {}
for item in str.Split(excludeRaw, ",") {
    item = str.TrimSpace(item)
    if item != "" {
        excludeNames[item] = true
    }
}

// Parse include name list (whitelist)
includeNames = {}
for item in str.Split(includeRaw, ",") {
    item = str.TrimSpace(item)
    if item != "" {
        includeNames[item] = true
    }
}
hasIncludeFilter = len(includeNames) > 0

// Parse exclude-ext list
excludeExts = {}
for item in str.Split(excludeExtRaw, ",") {
    item = str.TrimSpace(item)
    if item != "" {
        if !str.HasPrefix(item, ".") { item = "." + item }
        excludeExts[str.ToLower(item)] = true
    }
}

// Parse include-ext list (whitelist)
includeExts = {}
for item in str.Split(includeExtRaw, ",") {
    item = str.TrimSpace(item)
    if item != "" {
        if !str.HasPrefix(item, ".") { item = "." + item }
        includeExts[str.ToLower(item)] = true
    }
}
hasIncludeExtFilter = len(includeExts) > 0

if len(excludeNames) > 0 {
    yakit.Info("exclude: %v", excludeRaw)
}
if hasIncludeFilter {
    yakit.Info("include: %v", includeRaw)
}
if len(excludeExts) > 0 {
    yakit.Info("exclude-ext: %v", excludeExtRaw)
}
if hasIncludeExtFilter {
    yakit.Info("include-ext: %v", includeExtRaw)
}

// shouldFilterPath checks whether a path should be filtered out.
// Returns true if the entry should be EXCLUDED (not shown).
// isDir: whether this entry is a directory
// relPath: relative path from root (normalized with /)
shouldFilterPath = (relPath, entryName, isDir) => {
    // 1. Check exclude name blacklist (applies to any path component)
    normalized = str.ReplaceAll(relPath, "\\", "/")
    parts = str.Split(normalized, "/")
    for part in parts {
        if excludeNames[part] {
            return true
        }
    }

    // 2. Check include name whitelist (if set, entry name must contain one of the substrings)
    //    For directories: always pass include filter so their children can be explored
    if hasIncludeFilter && !isDir {
        matched = false
        for incName in includeNames {
            if str.Contains(entryName, incName) {
                matched = true
                break
            }
        }
        if !matched { return true }
    }

    // 3. Extension filters only apply to files, not directories
    if !isDir {
        ext = str.ToLower(file.GetExt(entryName))
        // 3a. Check exclude-ext blacklist
        if ext != "" && excludeExts[ext] {
            return true
        }
        // 3b. Check include-ext whitelist
        if hasIncludeExtFilter {
            if ext == "" || !includeExts[ext] {
                return true
            }
        }
    }

    return false
}

// Collect all tree lines into a buffer for single output
buf = bufio.NewBuffer()
lineCount = 0
dirCount = 0
fileCount = 0
truncated = false

filesys.Recursive(path, filesys.onStat((isDir, pathname, info) => {
    defer func { recover() }

    if truncated { return }
    if lineCount >= maxLines {
        truncated = true
        return
    }

    // Get relative path
    relPath = str.TrimPrefix(pathname, path)
    relPath = str.TrimLeft(relPath, "/\\")
    if relPath == "" { return } // skip root itself

    // Normalize path separators
    relPath = str.ReplaceAll(relPath, "\\", "/")

    // Get entry name (last component)
    parts = str.Split(relPath, "/")
    entryName = parts[len(parts) - 1]

    // Apply unified filter
    if shouldFilterPath(relPath, entryName, isDir) { return }

    // Check depth
    if len(parts) > maxDepth { return }

    lineCount++
    if isDir {
        dirCount++
    } else {
        fileCount++
    }

    // Build indented tree line
    depth = len(parts) - 1
    indent = str.Repeat("  ", depth)
    name = entryName
    if isDir {
        name = name + "/"
    }
    buf.WriteString(indent + name + "\n")
}))

// Build the complete result string
result = bufio.NewBuffer()
result.WriteString(sprintf("Directory: %v\n", path))
result.WriteString("========================\n")
result.WriteString(buf.String())
result.WriteString("========================\n")
result.WriteString(sprintf("%v directories, %v files\n", dirCount, fileCount))
if truncated {
    result.WriteString(sprintf("(output truncated at %v lines, use --max-lines to increase)\n", maxLines))
}

// Output to stdout (captured by AI tool framework as tool result)
println(result.String())

// Also log for visibility
yakit.Info("Directory tree: %v (%v dirs, %v files)", path, dirCount, fileCount)
