__DESC__ = "一个用于查看目录树形结构的工具，支持显示目录下的文件和子目录层级关系，默认排除 .git/node_modules 等噪声目录。适用于目录结构分析、项目概览等场景。"
__VERBOSE_NAME__ = "目录树形结构查看工具"
__KEYWORDS__ = "directory tree,目录结构,树形结构,文件系统浏览,directory listing,文件夹结构,文件树,file hierarchy,目录浏览,directory navigation,exclude"

/*
目录树形结构查看工具

功能特点：
1. 查看目录的树形结构
   - 显示目录下的文件和子目录
   - 层级关系清晰展示
   - 包含文件和目录的统计信息

2. 参数说明：
   --path: 要查看的目录路径 (必需)
   --exclude: 排除的目录/文件名 (逗号分隔，默认排除 .git,node_modules 等)
   --max-depth: 最大递归深度 (默认 6)
   --max-lines: 最大输出行数 (默认 200)

使用示例：
1. 查看当前目录结构：
   yak tree.yak --path .

2. 查看指定目录结构(带自定义排除)：
   yak tree.yak --path /tmp --exclude ".git,node_modules,vendor"

3. 不排除任何目录：
   yak tree.yak --path /path/to/project --exclude ""

注意事项：
- 支持绝对路径和相对路径
- 自动限制深度和输出行数以提高性能
- 显示文件数量和目录数量统计
- 如果目录不存在会报错
- 默认排除 .git, node_modules 等噪声目录以减少输出干扰
*/

yakit.AutoInitYakit()

// 解析命令行参数
path := cli.String("path", cli.setRequired(true), cli.setHelp("directory path to display tree structure"))
excludeRaw := cli.String("exclude", cli.setHelp("comma-separated list of directory/file names to exclude from tree view"), cli.setDefault(".git,.svn,.hg,node_modules,__pycache__,.DS_Store,.idea,.vscode,.next,.nuxt,.cache"))
maxDepth := cli.Int("max-depth", cli.setHelp("maximum directory depth to display"), cli.setDefault(6))
maxLines := cli.Int("max-lines", cli.setHelp("maximum number of lines to display"), cli.setDefault(200))

cli.check()

yakit.Info("Viewing directory tree structure: %v", path)

// 检查路径是否存在
if !file.IsExisted(path) {
    errMsg = sprintf("Path does not exist: %v", path)
    yakit.Error(errMsg)
    println(errMsg)
    return
}

// 检查是否是目录
if !file.IsDir(path) {
    errMsg = sprintf("Path is not a directory: %v", path)
    yakit.Error(errMsg)
    println(errMsg)
    return
}

// 解析 exclude 列表
excludeNames = {}
for item in str.Split(excludeRaw, ",") {
    item = str.TrimSpace(item)
    if item != "" {
        excludeNames[item] = true
    }
}

if len(excludeNames) > 0 {
    yakit.Info("exclude: %v", excludeRaw)
}

// shouldExcludePath checks if any path component matches the exclude list
shouldExcludePath = (filePath) => {
    normalized = str.ReplaceAll(filePath, "\\", "/")
    parts = str.Split(normalized, "/")
    for part in parts {
        if excludeNames[part] {
            return true
        }
    }
    return false
}

// Collect all tree lines into a buffer for single output
buf = bufio.NewBuffer()
lineCount = 0
dirCount = 0
fileCount = 0
truncated = false

filesys.Recursive(path, filesys.onStat((isDir, pathname, info) => {
    defer func { recover() }

    if truncated { return }
    if lineCount >= maxLines {
        truncated = true
        return
    }

    // Get relative path
    relPath = str.TrimPrefix(pathname, path)
    relPath = str.TrimLeft(relPath, "/\\")
    if relPath == "" { return } // skip root itself

    // Normalize path separators
    relPath = str.ReplaceAll(relPath, "\\", "/")

    // Check exclude
    if shouldExcludePath(relPath) { return }

    // Check depth
    parts = str.Split(relPath, "/")
    if len(parts) > maxDepth { return }

    lineCount++
    if isDir {
        dirCount++
    } else {
        fileCount++
    }

    // Build indented tree line
    depth = len(parts) - 1
    indent = str.Repeat("  ", depth)
    name = parts[len(parts) - 1]
    if isDir {
        name = name + "/"
    }
    buf.WriteString(indent + name + "\n")
}))

// Build the complete result string
result = bufio.NewBuffer()
result.WriteString(sprintf("Directory: %v\n", path))
result.WriteString("========================\n")
result.WriteString(buf.String())
result.WriteString("========================\n")
result.WriteString(sprintf("%v directories, %v files\n", dirCount, fileCount))
if truncated {
    result.WriteString(sprintf("(output truncated at %v lines, use --max-lines to increase)\n", maxLines))
}

// Output to stdout (captured by AI tool framework as tool result)
println(result.String())

// Also log for visibility
yakit.Info("Directory tree: %v (%v dirs, %v files)", path, dirCount, fileCount)
