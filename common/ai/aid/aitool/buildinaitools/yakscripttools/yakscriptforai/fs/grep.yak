__DESC__ = "一个文本查找工具，用于在指定文件或目录下查找匹配特定模式的文本。支持子串（区分大小写和不区分大小写）和正则表达式模式。可指定查找的路径、模式、最大结果数量、跳过的匹配次数以及显示匹配文本周围的上下文。"
__VERBOSE_NAME__ = "文本查找工具"
__KEYWORDS__ = "pattern matching,regexp,file path,模式匹配,查找替换,文件路径,context text,文本查找,文本工具,directory search,text tool,文件搜索,正则表达式,目录搜索,grep,text finder,file search"

yakit.AutoInitYakit()

pathName := cli.String("path", cli.setHelp("the filepath(s) you want to check, use comma ',' to separate multiple paths"), cli.setRequired(true))
pattern := cli.String("pattern", cli.setHelp("target text you want to grep, use comma ',' as split"), cli.setRequired(true))
matchMode = cli.String("pattern-mode", cli.setHelp("one of [substr/regexp/isubstr] set match mode: 1. substr for CaseSensitive-SubString; 2. isubstr for CaseInsensitive-SubString; 3. regexp for Regexp match in Golang Style"))
maxResult := cli.Int("limit", cli.setHelp("max times (limit) grep for results"),  cli.setDefault(10))
offsetResultCount := cli.Int("offset", cli.setHelp("skip how many first match"), cli.setDefault(0))
fileSizeLimit = cli.Int("file-size-max", cli.setHelp("limit for file size, if the file is too large, stop it auto"), cli.setDefault(1000 * 1000 * 1000 * 2)) // 2G
contextBuffer := cli.Int("context-buffer", cli.setHelp("Show (or display) a certain number of bytes of context around the matching text, default 0 is for not show"), cli.setDefault(0))
cli.check()

// 解析多个路径（以逗号分隔）
pathList := str.Split(pathName, ",")
validPaths := []
for p in pathList {
    p = str.TrimSpace(p)
    if p == "" {
        continue
    }
    if !file.IsExisted(p) {
        yakit.Info("no such file or directory: %v" % p)
        continue
    }
    validPaths = append(validPaths, p)
}

if len(validPaths) == 0 {
    yakit.Info("no valid file or directory found")
    return
}

multipleFiles := len(validPaths) > 1

if pattern == "" {
    yakit.Info("grep target not right")
    return
}

// Print start info
yakit.Info("=== Start Grep ===")
yakit.Info("target path(s): %v", pathName)
yakit.Info("pattern: %v", pattern)
yakit.Info("pattern-mode: %v", matchMode)
yakit.Info("limit: %v, offset: %v, context-buffer: %v", maxResult, offsetResultCount, contextBuffer)

count := 0
m := sync.NewMutex()

findRes := []


defer func{
    yakit.Info("=== Grep Finished ===")
    if count <= 0 {
        yakit.Info("pattern [%v] matched 0 results", pattern)
    } else {
        yakit.Info("pattern [%v] matched %v results (showed %v)", pattern, count, min(count - offsetResultCount, maxResult))
    }
}

end = false
output = (targetFile, offset, offsetEnd) => {
    m.Lock()
    defer m.Unlock()
    count++

    if count <= offsetResultCount {
        return
    }

    if count > (maxResult + offsetResultCount) {
        end = true
        return
    }
    
    // 当有多个文件时，显示文件来源
    var msg
    if multipleFiles {
        msg = "[file: %v] matched at index:%v-%v" % [targetFile, offset, offsetEnd]
    } else {
        msg = "matched in %v at index:%v-%v" % [targetFile, offset, offsetEnd]
    }
    yakit.Info(msg)
    if contextBuffer > 0 {
        seekStart = offset - contextBuffer
        if seekStart <= 0 {
            seekStart = 0
        }
        seekLen := offsetEnd - offset
        if seekLen <= 0 {
            return
        }
        seekLen += 2 * contextBuffer
        fp, err := file.OpenFile(targetFile, file.O_RDONLY, 0644)
        if err != nil { return }
        defer fp.Close()

        n, err = fp.Seek(seekStart, 0)
        if err != nil {
            return
        }
        raw, err := io.ReadAll(io.LimitReader(fp, seekLen))
        if err != nil {
            return
        }
        yakit.File(targetFile, yakit.fileReadAction(offset, seekLen, "byte", raw))
        if len(raw) > 0 {
            // format and print the context content
            contentStr := string(raw)
            yakit.Info("  context: %#v", contentStr)
            findRes = append(findRes, contentStr)
        }
    }
}

isRegexp = str.ToLower(matchMode) in ["regexp", "re", "regex"]

handleRegexp = (subpattern, targetFile, content) => {
    defer recover()
    subpatternRe := re.Compile(subpattern)~
    loc := subpatternRe.FindStringIndex(string(content))
    if len(loc) < 2 {
        return
    }
    start, endPos = loc[0], loc[1]
    output(targetFile, start, endPos)
    for {
        if end { return } // check global end flag
        base := start + 1
        newLoc := subpatternRe.FindStringIndex(string(content[base:]))
        if len(newLoc) < 2 {
            return
        }
        // add base offset to get absolute position in original content
        start, endPos = base + newLoc[0], base + newLoc[1]
        output(targetFile, start, endPos)
    }
}

handle = (patternSubstr, targetFile, content) => {
    switch str.ToLower(matchMode){
    case "isubstr", "isubstring":
        content = str.ToLower(string(content))
        patternSubstr = str.ToLower(patternSubstr)
    }

    offset := str.Index(content, patternSubstr)
    if offset < 0 {
        return
    }

    output(targetFile, offset, offset+len(patternSubstr))
    for {
        newOffset := str.Index(content[offset+1:], patternSubstr)
        if newOffset < 0 { return }
        newOffset += 1 + offset
        output(targetFile, newOffset, newOffset + len(patternSubstr))
        offset = newOffset
    }
}


// 处理单个路径的函数
processPath = (singlePath) => {
    if file.IsDir(singlePath) {
        filesys.Recursive(singlePath, filesys.onFileStat((fileToCheck, info) => {
            yakit.File(fileToCheck, yakit.fileStatusAction(info))
            defer recover()
            if end { return }

            if fileSizeLimit > 0 && info.Size() > fileSizeLimit {
                // overlarge
                return
            }

            allpattern := str.Split(pattern, ",")
            for subPatternItem in allpattern {
                fileContent := file.ReadFile(fileToCheck)~
                yakit.File(fileToCheck, yakit.fileReadAction(0, len(fileContent), "byte", fileContent))
                if isRegexp {
                    handleRegexp(subPatternItem, fileToCheck, string(fileContent))
                } else {
                    handle(subPatternItem, fileToCheck, string(fileContent))
                }
            }
        }))
    } else {
        allpattern := str.Split(pattern, ",")
        for subPatternItem in allpattern {
            fileContent := file.ReadFile(singlePath)~
            yakit.File(singlePath, yakit.fileReadAction(0, len(fileContent), "byte", fileContent))
            if isRegexp {
                handleRegexp(subPatternItem, singlePath, string(fileContent))
            } else {
                handle(subPatternItem, singlePath, string(fileContent))
            }
        }
    }
}

// 遍历所有有效路径
for currentPath in validPaths {
    if end { break }
    if multipleFiles {
        yakit.Info("processing path: %v", currentPath)
    }
    processPath(currentPath)
}

// print findRes to stdout for AI to consume
if len(findRes) > 0 {
    yakit.Info("=== Grep Results Summary ===")
    for i := 0; i < len(findRes); i++ {
        res := findRes[i]
        yakit.Info("[match %d] %s", i+1, res)
    }
    yakit.Info("=== End of Grep Results ===")
}

yakit.File(pathName, yakit.fileFindAction("content", sprintf("patternMode:[%s] | pattern:[%s]",matchMode,pattern), findRes...))