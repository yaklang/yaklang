__DESC__ = "一个文本查找工具，用于在指定文件或目录下查找匹配特定模式的文本。支持子串（区分大小写和不区分大小写）和正则表达式模式。支持名称和扩展名黑白名单过滤。可指定查找的路径、模式、最大结果数量、跳过的匹配次数以及显示匹配文本周围的上下文。"
__VERBOSE_NAME__ = "文本查找工具"
__KEYWORDS__ = "pattern matching,regexp,file path,模式匹配,查找替换,文件路径,context text,文本查找,文本工具,directory search,text tool,文件搜索,正则表达式,目录搜索,grep,text finder,file search,include,exclude,extension filter"

__USAGE__ = <<<USAGE_BLOCK
Text Grep Tool - Parameter Description for JSON Tool Calls

Required Parameters:
  path            (string)  The file or directory path(s) to search. Multiple paths can be specified
                            separated by comma ",". Each path is validated before scanning.
                            If a path is a directory, all files within it are searched recursively.
                            If a path is a file, only that file is searched.
  pattern         (string)  The text pattern(s) to search for. Multiple patterns can be specified
                            separated by comma ",". Each pattern is searched independently.
                            How patterns are matched depends on the "pattern-mode" parameter.

Optional Parameters:
  pattern-mode    (string)  Controls how the pattern string is interpreted. Accepted values:
                            - "" or "substr" (default): case-sensitive substring matching.
                              The pattern is treated as a literal string.
                            - "isubstr" or "isubstring": case-insensitive substring matching.
                              Both the file content and the pattern are lowercased before comparison.
                            - "regexp" / "re" / "regex": Golang-style regular expression.
                              The pattern is compiled as a regex and matched against file content.
  limit           (int)     Maximum number of matched results to return. Default: 10.
                            The search stops early once this many results (after offset) are collected.
  offset          (int)     Skip the first N matches before collecting results. Default: 0.
                            Useful for paginating through large result sets.
  file-size-max   (int)     Maximum file size in bytes. Files larger than this are skipped entirely.
                            Default: 2000000000 (2GB). Set to a smaller value for faster scans.
  context-buffer  (int)     Number of bytes of surrounding context to show around each match.
                            Default: 0 (only match position is reported, no surrounding text).
                            When > 0, the tool extracts [match_start - context_buffer, match_end + context_buffer]
                            bytes from the file content and includes it in the result.
  exclude         (string)  Comma-separated list of directory/file names to exclude.
                            Each name is checked against EVERY component of the file path.
                            For example, "node_modules,.git" will skip any file whose path contains
                            a directory or file named exactly "node_modules" or ".git".
                            Default: ".git,.svn,.hg,node_modules,__pycache__,.DS_Store,.idea,.vscode,.next,.nuxt,.cache"
                            Set to "" to disable all name exclusions.
  include         (string)  Comma-separated list of filename substrings for whitelist filtering.
                            When set (non-empty), only files whose filename (last path component)
                            contains at least one of these substrings are searched.
                            Default: "" (disabled, all files are searched).
  exclude-ext     (string)  Comma-separated list of file extensions to exclude (blacklist).
                            The dot prefix is optional: both "pyc" and ".pyc" are accepted.
                            Matching is case-insensitive.
                            Default: "" (disabled).
  include-ext     (string)  Comma-separated list of file extensions to include (whitelist).
                            When set, only files whose extension matches one of these values are searched.
                            The dot prefix is optional: both "go" and ".go" are accepted.
                            Default: "" (disabled, all extensions pass).

Filter Evaluation Order (for each file during recursive scan):
  1. exclude name blacklist (path component exact match)
  2. include name whitelist (filename substring match)
  3. exclude-ext extension blacklist (file extension match)
  4. include-ext extension whitelist (file extension match)
  5. file-size-max check
  6. pattern matching (substr/isubstr/regexp)
USAGE_BLOCK

yakit.AutoInitYakit()

pathName := cli.String("path", cli.setHelp("the filepath(s) you want to check, use comma ',' to separate multiple paths"), cli.setRequired(true))
pattern := cli.String("pattern", cli.setHelp("target text you want to grep, use comma ',' as split"), cli.setRequired(true))
matchMode = cli.String("pattern-mode", cli.setHelp("one of [substr/regexp/isubstr] set match mode: 1. substr for CaseSensitive-SubString; 2. isubstr for CaseInsensitive-SubString; 3. regexp for Regexp match in Golang Style"))
maxResult := cli.Int("limit", cli.setHelp("max times (limit) grep for results"),  cli.setDefault(10))
offsetResultCount := cli.Int("offset", cli.setHelp("skip how many first match"), cli.setDefault(0))
fileSizeLimit = cli.Int("file-size-max", cli.setHelp("limit for file size, if the file is too large, stop it auto"), cli.setDefault(1000 * 1000 * 1000 * 2)) // 2G
contextBuffer := cli.Int("context-buffer", cli.setHelp("Show (or display) a certain number of bytes of context around the matching text, default 0 is for not show"), cli.setDefault(0))
excludeRaw := cli.String("exclude", cli.setHelp("comma-separated list of directory/file names to exclude from scanning"), cli.setDefault(".git,.svn,.hg,node_modules,__pycache__,.DS_Store,.idea,.vscode,.next,.nuxt,.cache"))
includeRaw := cli.String("include", cli.setHelp("comma-separated list of file name substrings to include (whitelist)"), cli.setDefault(""))
excludeExtRaw := cli.String("exclude-ext", cli.setHelp("comma-separated list of file extensions to exclude (e.g. '.pyc,.o,.so')"), cli.setDefault(""))
includeExtRaw := cli.String("include-ext", cli.setHelp("comma-separated list of file extensions to include (whitelist, e.g. '.go,.js,.py')"), cli.setDefault(""))
cli.check()

// Fallback: if fileSizeLimit is 0 or negative (e.g., due to scientific notation parsing issue), set to 2GB
if fileSizeLimit <= 0 {
    fileSizeLimit = 1000 * 1000 * 1000 * 2 // 2GB
    yakit.Info("file-size-max was invalid (%v), reset to default 2GB", fileSizeLimit)
}

// Parse exclude name list
excludeNames = {}
for item in str.Split(excludeRaw, ",") {
    item = str.TrimSpace(item)
    if item != "" {
        excludeNames[item] = true
    }
}

// Parse include name list (whitelist)
includeNames = {}
for item in str.Split(includeRaw, ",") {
    item = str.TrimSpace(item)
    if item != "" {
        includeNames[item] = true
    }
}
hasIncludeFilter = len(includeNames) > 0

// Parse exclude-ext list
excludeExts = {}
for item in str.Split(excludeExtRaw, ",") {
    item = str.TrimSpace(item)
    if item != "" {
        if !str.HasPrefix(item, ".") { item = "." + item }
        excludeExts[str.ToLower(item)] = true
    }
}

// Parse include-ext list (whitelist)
includeExts = {}
for item in str.Split(includeExtRaw, ",") {
    item = str.TrimSpace(item)
    if item != "" {
        if !str.HasPrefix(item, ".") { item = "." + item }
        includeExts[str.ToLower(item)] = true
    }
}
hasIncludeExtFilter = len(includeExts) > 0

// shouldFilterPath returns true if the file should be EXCLUDED from searching.
shouldFilterPath = (filePath) => {
    normalized = str.ReplaceAll(filePath, "\\", "/")
    parts = str.Split(normalized, "/")

    // 1. Check exclude name blacklist (any path component)
    for part in parts {
        if excludeNames[part] {
            return true
        }
    }

    // 2. Check include name whitelist (file name must contain a substring)
    if hasIncludeFilter {
        fileName = parts[len(parts) - 1]
        matched = false
        for incName in includeNames {
            if str.Contains(fileName, incName) {
                matched = true
                break
            }
        }
        if !matched { return true }
    }

    // 3. Check extension filters
    fileName = parts[len(parts) - 1]
    ext = str.ToLower(file.GetExt(fileName))
    // 3a. exclude-ext blacklist
    if ext != "" && excludeExts[ext] {
        return true
    }
    // 3b. include-ext whitelist
    if hasIncludeExtFilter {
        if ext == "" || !includeExts[ext] {
            return true
        }
    }

    return false
}

// 解析多个路径（以逗号分隔）
pathList := str.Split(pathName, ",")
validPaths := []
for p in pathList {
    p = str.TrimSpace(p)
    if p == "" {
        continue
    }
    if !file.IsExisted(p) {
        yakit.Info("no such file or directory: %v" % p)
        continue
    }
    validPaths = append(validPaths, p)
}

if len(validPaths) == 0 {
    yakit.Info("no valid file or directory found")
    return
}

multipleFiles := len(validPaths) > 1

if pattern == "" {
    yakit.Info("grep target not right")
    return
}

// Print start info
yakit.Info("=== Start Grep ===")
yakit.Info("target path(s): %v", pathName)
yakit.Info("pattern: %v", pattern)
yakit.Info("pattern-mode: %v", matchMode)
yakit.Info("limit: %v, offset: %v, context-buffer: %v", maxResult, offsetResultCount, contextBuffer)
if len(excludeNames) > 0 {
    yakit.Info("exclude: %v", excludeRaw)
}
if hasIncludeFilter {
    yakit.Info("include: %v", includeRaw)
}
if len(excludeExts) > 0 {
    yakit.Info("exclude-ext: %v", excludeExtRaw)
}
if hasIncludeExtFilter {
    yakit.Info("include-ext: %v", includeExtRaw)
}

count := 0
m := sync.NewMutex()

findRes := []


defer func{
    yakit.Info("=== Grep Finished ===")
    if count <= 0 {
        yakit.Info("pattern [%v] matched 0 results", pattern)
    } else {
        yakit.Info("pattern [%v] matched %v results (showed %v)", pattern, count, min(count - offsetResultCount, maxResult))
    }
}

end = false
// Maximum number of matches to log individually via yakit.Info IPC
// to avoid flooding the IPC channel (each yakit.Info is a network round-trip).
maxIPCLogCount = 20

// output uses in-memory rawContent ([]byte) to extract context,
// avoiding per-match file I/O and excessive yakit.File IPC calls.
output = (targetFile, offset, offsetEnd, rawContent) => {
    m.Lock()
    defer m.Unlock()
    count++

    if count <= offsetResultCount {
        return
    }

    if count > (maxResult + offsetResultCount) {
        end = true
        return
    }

    displayCount = count - offsetResultCount

    // Build match info string
    var msg
    if multipleFiles {
        msg = "[file: %v] matched at index:%v-%v" % [targetFile, offset, offsetEnd]
    } else {
        msg = "matched in %v at index:%v-%v" % [targetFile, offset, offsetEnd]
    }

    // Only log first N matches via yakit.Info to avoid IPC flood
    // (each call is a JSON serialize + network send)
    if displayCount <= maxIPCLogCount {
        yakit.Info(msg)
    } else if displayCount == maxIPCLogCount + 1 {
        yakit.Info("... (suppressing per-match IPC logs for remaining matches, results still collected)")
    }

    if contextBuffer > 0 && rawContent != nil {
        seekStart = offset - contextBuffer
        if seekStart < 0 {
            seekStart = 0
        }
        seekEnd = offsetEnd + contextBuffer
        if seekEnd > len(rawContent) {
            seekEnd = len(rawContent)
        }
        if seekEnd <= seekStart {
            return
        }
        raw = rawContent[seekStart:seekEnd]
        if len(raw) > 0 {
            contentStr := string(raw)
            if displayCount <= maxIPCLogCount {
                yakit.Info("  context: %#v", contentStr)
            }
            findRes = append(findRes, contentStr)
        }
    }
}

isRegexp = str.ToLower(matchMode) in ["regexp", "re", "regex"]

// Use FindAllStringIndex to avoid slow string slicing ([]rune conversion)
handleRegexp = (subpattern, targetFile, content, rawContent) => {
    defer recover()
    subpatternRe := re.Compile(subpattern)~
    allMatches := subpatternRe.FindAllStringIndex(string(content), maxResult + offsetResultCount + 1)
    for _, match = range allMatches {
        if end { return }
        output(targetFile, match[0], match[1], rawContent)
    }
}

handle = (patternSubstr, targetFile, content, rawContent) => {
    switch str.ToLower(matchMode){
    case "isubstr", "isubstring":
        content = str.ToLower(string(content))
        patternSubstr = str.ToLower(patternSubstr)
    }

    // Use regex FindAllStringIndex for much better performance
    // (str.Index + substring triggers slow []rune conversion in yak VM)
    defer recover()
    patternRe := re.Compile(re.QuoteMeta(patternSubstr))~
    allMatches := patternRe.FindAllStringIndex(string(content), maxResult + offsetResultCount + 1)
    for _, match = range allMatches {
        if end { return }
        output(targetFile, match[0], match[1], rawContent)
    }
}


// 处理单个路径的函数
processPath = (singlePath) => {
    if file.IsDir(singlePath) {
        filesys.Recursive(singlePath, filesys.onFileStat((fileToCheck, info) => {
            // yakit.File(fileToCheck, yakit.fileStatusAction(info))
            defer recover()
            if end { return }

            // Skip filtered paths (exclude/include name + extension filters)
            if shouldFilterPath(fileToCheck) { return }

            if fileSizeLimit > 0 && info.Size() > fileSizeLimit {
                // overlarge
                return
            }

            // Read file once and cache the content (no longer send full content via IPC)
            fileContent := file.ReadFile(fileToCheck)~
            fileContentStr := string(fileContent)

            allpattern := str.Split(pattern, ",")
            for subPatternItem in allpattern {
                if end { return } // Check end before each pattern
                if isRegexp {
                    handleRegexp(subPatternItem, fileToCheck, fileContentStr, fileContent)
                } else {
                    handle(subPatternItem, fileToCheck, fileContentStr, fileContent)
                }
            }
        }))
    } else {
        // Read file once and cache the content (no longer send full content via IPC)
        fileContent := file.ReadFile(singlePath)~
        fileContentStr := string(fileContent)

        allpattern := str.Split(pattern, ",")
        for subPatternItem in allpattern {
            if end { return } // Check end before each pattern
            if isRegexp {
                handleRegexp(subPatternItem, singlePath, fileContentStr, fileContent)
            } else {
                handle(subPatternItem, singlePath, fileContentStr, fileContent)
            }
        }
    }
}

// 遍历所有有效路径
for currentPath in validPaths {
    if end { break }
    if multipleFiles {
        yakit.Info("processing path: %v", currentPath)
    }
    processPath(currentPath)
}

// Maximum results to output via stdout and yakit.Info summary
// AI tool framework captures stdout as the tool result; keep it reasonable.
maxStdoutResults = 100

// print findRes summary to yakit.Info (batched, not per-match)
if len(findRes) > 0 {
    yakit.Info("=== Grep Results Summary: %d matches ===", len(findRes))
    showCount = min(len(findRes), maxStdoutResults)
    for i := 0; i < showCount; i++ {
        yakit.Info("[match %d] %s", i+1, findRes[i])
    }
    if len(findRes) > maxStdoutResults {
        yakit.Info("... (%d more matches not shown)", len(findRes) - maxStdoutResults)
    }
    yakit.Info("=== End of Grep Results ===")

    // Write results to stdout (captured by AI tool framework)
    // Cap output to maxStdoutResults to keep tool result size manageable
    println(sprintf("=== Grep Results: %d matches (pattern: %s) ===", len(findRes), pattern))
    for i := 0; i < showCount; i++ {
        println(sprintf("[match %d] %s", i+1, findRes[i]))
    }
    if len(findRes) > maxStdoutResults {
        println(sprintf("... (%d more matches not shown, use offset to paginate)", len(findRes) - maxStdoutResults))
    }
    println("=== End of Grep Results ===")
} else {
    println(sprintf("No matches found for pattern: %s", pattern))
}

// Send structured results to yakit UI via IPC.
// IMPORTANT: Cap results to prevent IPC hang from oversized payload.
maxFileResults = 50
if len(findRes) <= maxFileResults {
    yakit.File(pathName, yakit.fileFindAction("content", sprintf("patternMode:[%s] | pattern:[%s]",matchMode,pattern), findRes...))
} else {
    truncatedRes = findRes[:maxFileResults]
    yakit.File(pathName, yakit.fileFindAction("content", sprintf("patternMode:[%s] | pattern:[%s] (showing %d of %d)",matchMode,pattern, maxFileResults, len(findRes)), truncatedRes...))
}