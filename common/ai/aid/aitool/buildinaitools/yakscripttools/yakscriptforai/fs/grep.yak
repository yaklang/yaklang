__DESC__ = "一个文本查找工具，用于在指定文件或目录下查找匹配特定模式的文本。支持子串（区分大小写和不区分大小写）和正则表达式模式。可指定查找的路径、模式、最大结果数量、跳过的匹配次数以及显示匹配文本周围的上下文。"
__VERBOSE_NAME__ = "文本查找工具"
__KEYWORDS__ = "pattern matching,regexp,file path,模式匹配,查找替换,文件路径,context text,文本查找,文本工具,directory search,text tool,文件搜索,正则表达式,目录搜索,grep,text finder,file search"

yakit.AutoInitYakit()

pathName := cli.String("path", cli.setHelp("the filepath(s) you want to check, use comma ',' to separate multiple paths"), cli.setRequired(true))
pattern := cli.String("pattern", cli.setHelp("target text you want to grep, use comma ',' as split"), cli.setRequired(true))
matchMode = cli.String("pattern-mode", cli.setHelp("one of [substr/regexp/isubstr] set match mode: 1. substr for CaseSensitive-SubString; 2. isubstr for CaseInsensitive-SubString; 3. regexp for Regexp match in Golang Style"))
maxResult := cli.Int("limit", cli.setHelp("max times (limit) grep for results"),  cli.setDefault(10))
offsetResultCount := cli.Int("offset", cli.setHelp("skip how many first match"), cli.setDefault(0))
fileSizeLimit = cli.Int("file-size-max", cli.setHelp("limit for file size, if the file is too large, stop it auto"), cli.setDefault(1000 * 1000 * 1000 * 2)) // 2G
contextBuffer := cli.Int("context-buffer", cli.setHelp("Show (or display) a certain number of bytes of context around the matching text, default 0 is for not show"), cli.setDefault(0))
excludeRaw := cli.String("exclude", cli.setHelp("comma-separated list of directory/file names to exclude from scanning"), cli.setDefault(".git,.svn,.hg,node_modules,__pycache__,.DS_Store,.idea,.vscode,.next,.nuxt,.cache"))
cli.check()

// Fallback: if fileSizeLimit is 0 or negative (e.g., due to scientific notation parsing issue), set to 2GB
if fileSizeLimit <= 0 {
    fileSizeLimit = 1000 * 1000 * 1000 * 2 // 2GB
    yakit.Info("file-size-max was invalid (%v), reset to default 2GB", fileSizeLimit)
}

// 解析 exclude 列表
excludeNames = {}
for item in str.Split(excludeRaw, ",") {
    item = str.TrimSpace(item)
    if item != "" {
        excludeNames[item] = true
    }
}

// shouldExcludePath checks if any path component matches the exclude list
shouldExcludePath = (filePath) => {
    normalized = str.ReplaceAll(filePath, "\\", "/")
    parts = str.Split(normalized, "/")
    for part in parts {
        if excludeNames[part] {
            return true
        }
    }
    return false
}

// 解析多个路径（以逗号分隔）
pathList := str.Split(pathName, ",")
validPaths := []
for p in pathList {
    p = str.TrimSpace(p)
    if p == "" {
        continue
    }
    if !file.IsExisted(p) {
        yakit.Info("no such file or directory: %v" % p)
        continue
    }
    validPaths = append(validPaths, p)
}

if len(validPaths) == 0 {
    yakit.Info("no valid file or directory found")
    return
}

multipleFiles := len(validPaths) > 1

if pattern == "" {
    yakit.Info("grep target not right")
    return
}

// Print start info
yakit.Info("=== Start Grep ===")
yakit.Info("target path(s): %v", pathName)
yakit.Info("pattern: %v", pattern)
yakit.Info("pattern-mode: %v", matchMode)
yakit.Info("limit: %v, offset: %v, context-buffer: %v", maxResult, offsetResultCount, contextBuffer)
if len(excludeNames) > 0 {
    yakit.Info("exclude: %v", excludeRaw)
}

count := 0
m := sync.NewMutex()

findRes := []


defer func{
    yakit.Info("=== Grep Finished ===")
    if count <= 0 {
        yakit.Info("pattern [%v] matched 0 results", pattern)
    } else {
        yakit.Info("pattern [%v] matched %v results (showed %v)", pattern, count, min(count - offsetResultCount, maxResult))
    }
}

end = false
// Maximum number of matches to log individually via yakit.Info IPC
// to avoid flooding the IPC channel (each yakit.Info is a network round-trip).
maxIPCLogCount = 20

// output uses in-memory rawContent ([]byte) to extract context,
// avoiding per-match file I/O and excessive yakit.File IPC calls.
output = (targetFile, offset, offsetEnd, rawContent) => {
    m.Lock()
    defer m.Unlock()
    count++

    if count <= offsetResultCount {
        return
    }

    if count > (maxResult + offsetResultCount) {
        end = true
        return
    }

    displayCount = count - offsetResultCount

    // Build match info string
    var msg
    if multipleFiles {
        msg = "[file: %v] matched at index:%v-%v" % [targetFile, offset, offsetEnd]
    } else {
        msg = "matched in %v at index:%v-%v" % [targetFile, offset, offsetEnd]
    }

    // Only log first N matches via yakit.Info to avoid IPC flood
    // (each call is a JSON serialize + network send)
    if displayCount <= maxIPCLogCount {
        yakit.Info(msg)
    } else if displayCount == maxIPCLogCount + 1 {
        yakit.Info("... (suppressing per-match IPC logs for remaining matches, results still collected)")
    }

    if contextBuffer > 0 && rawContent != nil {
        seekStart = offset - contextBuffer
        if seekStart < 0 {
            seekStart = 0
        }
        seekEnd = offsetEnd + contextBuffer
        if seekEnd > len(rawContent) {
            seekEnd = len(rawContent)
        }
        if seekEnd <= seekStart {
            return
        }
        raw = rawContent[seekStart:seekEnd]
        if len(raw) > 0 {
            contentStr := string(raw)
            if displayCount <= maxIPCLogCount {
                yakit.Info("  context: %#v", contentStr)
            }
            findRes = append(findRes, contentStr)
        }
    }
}

isRegexp = str.ToLower(matchMode) in ["regexp", "re", "regex"]

// Use FindAllStringIndex to avoid slow string slicing ([]rune conversion)
handleRegexp = (subpattern, targetFile, content, rawContent) => {
    defer recover()
    subpatternRe := re.Compile(subpattern)~
    allMatches := subpatternRe.FindAllStringIndex(string(content), maxResult + offsetResultCount + 1)
    for _, match = range allMatches {
        if end { return }
        output(targetFile, match[0], match[1], rawContent)
    }
}

handle = (patternSubstr, targetFile, content, rawContent) => {
    switch str.ToLower(matchMode){
    case "isubstr", "isubstring":
        content = str.ToLower(string(content))
        patternSubstr = str.ToLower(patternSubstr)
    }

    // Use regex FindAllStringIndex for much better performance
    // (str.Index + substring triggers slow []rune conversion in yak VM)
    defer recover()
    patternRe := re.Compile(re.QuoteMeta(patternSubstr))~
    allMatches := patternRe.FindAllStringIndex(string(content), maxResult + offsetResultCount + 1)
    for _, match = range allMatches {
        if end { return }
        output(targetFile, match[0], match[1], rawContent)
    }
}


// 处理单个路径的函数
processPath = (singlePath) => {
    if file.IsDir(singlePath) {
        filesys.Recursive(singlePath, filesys.onFileStat((fileToCheck, info) => {
            // yakit.File(fileToCheck, yakit.fileStatusAction(info))
            defer recover()
            if end { return }

            // Skip excluded paths (e.g. .git, node_modules)
            if shouldExcludePath(fileToCheck) { return }

            if fileSizeLimit > 0 && info.Size() > fileSizeLimit {
                // overlarge
                return
            }

            // Read file once and cache the content (no longer send full content via IPC)
            fileContent := file.ReadFile(fileToCheck)~
            fileContentStr := string(fileContent)

            allpattern := str.Split(pattern, ",")
            for subPatternItem in allpattern {
                if end { return } // Check end before each pattern
                if isRegexp {
                    handleRegexp(subPatternItem, fileToCheck, fileContentStr, fileContent)
                } else {
                    handle(subPatternItem, fileToCheck, fileContentStr, fileContent)
                }
            }
        }))
    } else {
        // Read file once and cache the content (no longer send full content via IPC)
        fileContent := file.ReadFile(singlePath)~
        fileContentStr := string(fileContent)

        allpattern := str.Split(pattern, ",")
        for subPatternItem in allpattern {
            if end { return } // Check end before each pattern
            if isRegexp {
                handleRegexp(subPatternItem, singlePath, fileContentStr, fileContent)
            } else {
                handle(subPatternItem, singlePath, fileContentStr, fileContent)
            }
        }
    }
}

// 遍历所有有效路径
for currentPath in validPaths {
    if end { break }
    if multipleFiles {
        yakit.Info("processing path: %v", currentPath)
    }
    processPath(currentPath)
}

// Maximum results to output via stdout and yakit.Info summary
// AI tool framework captures stdout as the tool result; keep it reasonable.
maxStdoutResults = 100

// print findRes summary to yakit.Info (batched, not per-match)
if len(findRes) > 0 {
    yakit.Info("=== Grep Results Summary: %d matches ===", len(findRes))
    showCount = min(len(findRes), maxStdoutResults)
    for i := 0; i < showCount; i++ {
        yakit.Info("[match %d] %s", i+1, findRes[i])
    }
    if len(findRes) > maxStdoutResults {
        yakit.Info("... (%d more matches not shown)", len(findRes) - maxStdoutResults)
    }
    yakit.Info("=== End of Grep Results ===")

    // Write results to stdout (captured by AI tool framework)
    // Cap output to maxStdoutResults to keep tool result size manageable
    println(sprintf("=== Grep Results: %d matches (pattern: %s) ===", len(findRes), pattern))
    for i := 0; i < showCount; i++ {
        println(sprintf("[match %d] %s", i+1, findRes[i]))
    }
    if len(findRes) > maxStdoutResults {
        println(sprintf("... (%d more matches not shown, use offset to paginate)", len(findRes) - maxStdoutResults))
    }
    println("=== End of Grep Results ===")
} else {
    println(sprintf("No matches found for pattern: %s", pattern))
}

// Send structured results to yakit UI via IPC.
// IMPORTANT: Cap results to prevent IPC hang from oversized payload.
maxFileResults = 50
if len(findRes) <= maxFileResults {
    yakit.File(pathName, yakit.fileFindAction("content", sprintf("patternMode:[%s] | pattern:[%s]",matchMode,pattern), findRes...))
} else {
    truncatedRes = findRes[:maxFileResults]
    yakit.File(pathName, yakit.fileFindAction("content", sprintf("patternMode:[%s] | pattern:[%s] (showing %d of %d)",matchMode,pattern, maxFileResults, len(findRes)), truncatedRes...))
}