__KEYWORDS__ = "port scan,syn scan,tcp scan,service scan,fingerprint,network scan,security,pentest,host discovery,port discovery,service identification,network security"
__VERBOSE_NAME__ = "Unified Port Scanner (SYN+TCP)"
__DESC__ = "A unified port scanning tool that combines SYN scan and TCP connect scan. Supports three modes: auto (tries SYN first, falls back to TCP if SYN fails), syn (SYN + TCP fingerprinting), and tcp (pure TCP connect scan). Auto mode is recommended for most scenarios."

__USAGE__ = <<<USAGE_BLOCK
Unified Port Scanner - Parameter Description for JSON Tool Calls

This tool combines SYN scanning (fast port discovery) and TCP connect scanning
(reliable service fingerprinting) into a single unified interface. The "auto" mode
is recommended: it tries SYN first for speed, and automatically falls back to TCP
if SYN scanning is unavailable (e.g., insufficient privileges).

Required Parameters:
  hosts           (string)  The target hosts to scan. Supports one or more targets
                            separated by comma ",". Accepts domain names, IPs, and
                            CIDR notation. Example: "www.example.com,192.168.1.1".

Optional Parameters:
  ports           (string)  The ports to scan. Supports individual ports, ranges, and
                            comma-separated combinations.
                            Default: "22,80,443,445,3306,3389,5432,8000-8004,8080-8084,7000-7005".
  mode            (string)  Scan mode: "auto", "syn", or "tcp".
                            - "auto": Try SYN scan first, fall back to TCP on failure (recommended).
                            - "syn":  Force SYN + TCP fingerprint scan (requires privileges).
                            - "tcp":  Pure TCP connect scan (always works, slower).
                            Default: "auto".
  concurrent      (int)     Concurrency for the primary scan phase.
                            For SYN mode: SYN packet sending concurrency. Default: 2000.
                            For TCP mode: TCP connect concurrency. Default: 100.
  fp-concurrent   (int)     Concurrency for service fingerprinting (SYN mode second phase).
                            Only effective in syn/auto mode. Default: 50.
  web             (bool)    Enable web service scanning. Set to true if you suspect
                            the target is running a web service. Default: false.
  active          (bool)    Enable active probing mode. When true, the scanner will
                            actively send packets to detect service fingerprints.
                            Default: false.
USAGE_BLOCK

yakit.AutoInitYakit()

// ==================== 参数解析 ====================
target = cli.String("hosts", cli.setHelp("the targets to scan, comma-separated, supports IP/domain/CIDR"), cli.setRequired(true))
ports = cli.String("ports", cli.setHelp("the ports to scan, supports individual ports, ranges, comma-separated"), cli.setDefault("22,80,443,445,3306,3389,5432,8000-8004,8080-8084,7000-7005"))
mode = cli.String("mode", cli.setHelp("scan mode: auto, syn, or tcp"), cli.setDefault("auto"))
concurrent = cli.Int("concurrent", cli.setHelp("concurrency for primary scan phase"), cli.setDefault(0))
fpConcurrent = cli.Int("fp-concurrent", cli.setHelp("concurrency for fingerprint scan in SYN mode"), cli.setDefault(50))
webservice = cli.Bool("web", cli.setHelp("enable web service scanning"))
active = cli.Bool("active", cli.setHelp("enable active probing for service fingerprints"))
cli.check()

// ==================== 参数校验 ====================
mode = str.ToLower(mode)
if mode != "auto" && mode != "syn" && mode != "tcp" {
    yakit.Error("invalid mode '%v', must be one of: auto, syn, tcp", mode)
    return
}

// ==================== 工具函数 ====================

// 构建 servicescan 的选项列表
buildServiceScanOpts = func(tcpConcurrency) {
    opts = []
    opts.Push(servicescan.concurrent(tcpConcurrency))
    if webservice {
        opts.Push(servicescan.web())
    }
    opts.Push(servicescan.onOpen(i => {
        yakit.Info("%v is open", i.String())
    }))
    opts.Push(servicescan.probeTimeout(5))
    if active {
        opts.Push(servicescan.active(true))
    }
    return opts
}

// 从 target 字符串中提取一个单独的 IP 用于探测
// 处理逗号分隔和 CIDR 格式
extractProbeTarget = func(rawTarget) {
    parts = str.Split(rawTarget, ",")
    first = str.TrimSpace(parts[0])
    // 如果是 CIDR 格式 (如 192.168.1.0/24)，提取基础 IP
    if str.Contains(first, "/") {
        first = str.Split(first, "/")[0]
    }
    return first
}

// ==================== SYN 可用性探测 ====================

// probeSynAvailable - 通过快速探测检测 SYN 扫描 (pcap/raw socket) 是否可用
//
// 原理：对单个目标的 80 端口执行一次小规模 SYN 扫描
//   - 如果 pcap 正常工作：扫描完成后结果通道会正常关闭（约 6-10 秒）
//   - 如果 pcap 不可用（权限不足）：initHandlerStart 阻塞在 captureReady 通道上，
//     结果通道永远不会关闭，导致读取方永远阻塞
//   通过超时轮询检测通道是否关闭来判断 pcap 是否工作
//
// 返回值: (bool, string) - (是否可用, 失败原因描述)
probeSynAvailable = func(probeTarget) {
    yakit.Info("probing SYN scan availability on %v ...", probeTarget)

    // 对目标的 80 端口做一次快速 SYN 探测
    // synscan.wait(3): 发送完 SYN 包后只等待 3 秒收响应
    // synscan.concurrent(100): 低并发，仅用于检测
    probeChan, err = synscan.Scan(probeTarget, "80", synscan.concurrent(100), synscan.wait(3))
    if err != nil {
        // 同步错误: 路由/接口/网关/DNS 解析等问题
        return false, sprintf("SYN scan init error: %v", err)
    }

    // 启动协程消费探测通道
    probeCompleted = false
    go fn{
        for _ in probeChan {
            // 消费所有结果，不关心具体内容
        }
        // 通道关闭意味着 pcap 正常工作，扫描已完成
        probeCompleted = true
    }

    // 轮询检查: 每 0.5 秒检查一次, 最多等待 15 秒
    // 正常 SYN 探测耗时: route(2s) + pcap_init(1-3s) + arp(1s) + send(0s) + wait(3s) ≈ 7-9s
    // 15 秒超时留有足够余量
    for i = 0; i < 30; i++ {
        if probeCompleted {
            yakit.Info("SYN scan probe succeeded - pcap/raw socket is working")
            return true, ""
        }
        sleep(0.5)
    }

    // 超时: pcap 很可能不可用
    return false, "SYN scan probe timed out after 15s - pcap/raw socket is likely unavailable"
}

// tryFixSynPermission - 尝试修复 SYN 扫描权限
// 在 macOS 上会修复 BPF 设备权限，在 Linux 上设置 cap_net_raw
// 注意: macOS 上修复后可能需要重新登录才能生效
tryFixSynPermission = func() {
    yakit.Info("attempting to fix SYN scan permissions via synscan.FixPermission()...")
    try {
        err = synscan.FixPermission()
        if err != nil {
            yakit.Info("WARNING: synscan.FixPermission() returned error: %v", err)
            yakit.Info("SYN scan may require manual privilege elevation (e.g. sudo)")
        } else {
            yakit.Info("synscan.FixPermission() completed successfully")
        }
    } catch err {
        yakit.Info("WARNING: synscan.FixPermission() failed: %v", err)
    }
}

// ==================== 扫描执行函数 ====================

// doSynScan - 执行 SYN + 服务指纹扫描
// SYN 扫描速度快（仅发送 SYN 包），发现开放端口后再通过 TCP 连接做指纹识别
doSynScan = func() {
    synConcurrency = concurrent
    if synConcurrency <= 0 {
        synConcurrency = 2000
    }
    yakit.Info("starting SYN scan: target=%v ports=%v syn-concurrent=%v fp-concurrent=%v", target, ports, synConcurrency, fpConcurrent)

    synChan, err = synscan.Scan(target, ports, synscan.concurrent(synConcurrency), synscan.callback(result => {
        yakit.Info("synscan found open port: %v", result.String())
    }))
    if err != nil {
        return nil, err
    }

    opts = buildServiceScanOpts(fpConcurrent)
    results, err = servicescan.ScanFromSynResult(synChan, opts...)
    if err != nil {
        return nil, err
    }
    return results, nil
}

// doTcpScan - 执行 TCP 连接扫描
// 完全使用 TCP 三次握手，不需要 raw socket 权限，始终可用
doTcpScan = func() {
    tcpConcurrency = concurrent
    if tcpConcurrency <= 0 {
        tcpConcurrency = 100
    }
    yakit.Info("starting TCP connect scan: target=%v ports=%v concurrent=%v", target, ports, tcpConcurrency)

    opts = buildServiceScanOpts(tcpConcurrency)
    results, err = servicescan.Scan(target, ports, opts...)
    if err != nil {
        return nil, err
    }
    return results, nil
}

// ==================== 结果报告 ====================

reportResults = func(results) {
    openPorts = []
    closedPorts = []
    for result in results {
        if !result.IsOpen() {
            closedPorts.Push(str.HostPort(result.Target, result.Port))
            continue
        }
        openPorts.Push(str.HostPort(result.Target, result.Port))
        glance = result.String()
        banner = result.GetBanner()
        yakit.Info("open: %v banner: %v", glance, banner)
    }
    if closedPorts.Len() > 0 {
        yakit.Info("closed ports count: %v", closedPorts.Len())
    }
    yakit.Info("scan completed: open=%v closed=%v total=%v", openPorts.Len(), closedPorts.Len(), openPorts.Len()+closedPorts.Len())
}

// ==================== 主执行逻辑 ====================

start = time.Now()
defer fn{
    yakit.Info("total cost: %v", time.Now().Sub(start).String())
}

results = undefined
scanErr = undefined

if mode == "auto" {
    // auto 模式：尝试 SYN -> 失败则降级到 TCP
    //
    // 优化流程 (先探测, 失败才修复权限, 避免不必要的 FixPermission 开销):
    // 1. 先快速探测 SYN 是否可用
    // 2. 如果可用, 直接执行 SYN + 指纹扫描
    // 3. 如果不可用, 尝试修复权限 -> 重新探测
    // 4. 如果仍不可用, 降级到 TCP 连接扫描
    probeTarget = extractProbeTarget(target)
    synAvailable, probeMsg = probeSynAvailable(probeTarget)

    if !synAvailable {
        // 第一次探测失败, 尝试修复权限后重试
        yakit.Info("SYN scan not available on first probe: %v", probeMsg)
        yakit.Info("attempting to fix pcap permissions and retry...")
        tryFixSynPermission()
        synAvailable, probeMsg = probeSynAvailable(probeTarget)
    }

    if synAvailable {
        yakit.Info("SYN scan is available, proceeding with SYN + fingerprint mode")
        results, scanErr = doSynScan()
        if scanErr != nil {
            yakit.Info("WARNING: SYN scan failed during execution: %v", scanErr)
            yakit.Info("falling back to TCP connect scan...")
            results, scanErr = doTcpScan()
            if scanErr != nil {
                yakit.Error("TCP connect scan also failed: %v", scanErr)
                return
            }
        }
    } else {
        yakit.Info("WARNING: SYN scan is NOT available after permission fix attempt: %v", probeMsg)
        yakit.Info("HINT: on macOS, you may need to log out and back in after fixing permissions")
        yakit.Info("HINT: on Linux, try running with sudo for SYN scan support")
        yakit.Info("falling back to TCP connect scan automatically...")
        results, scanErr = doTcpScan()
        if scanErr != nil {
            yakit.Error("TCP connect scan failed: %v", scanErr)
            return
        }
    }

} elif mode == "syn" {
    // syn 模式：强制使用 SYN 扫描, 不可用则尝试修复, 仍不可用则报错退出
    probeTarget = extractProbeTarget(target)
    synAvailable, probeMsg = probeSynAvailable(probeTarget)

    if !synAvailable {
        yakit.Info("SYN scan not available: %v", probeMsg)
        yakit.Info("attempting to fix pcap permissions...")
        tryFixSynPermission()
        synAvailable, probeMsg = probeSynAvailable(probeTarget)
    }

    if !synAvailable {
        yakit.Error("SYN scan is NOT available even after permission fix: %v", probeMsg)
        yakit.Error("HINT: SYN scan requires pcap/raw socket privileges.")
        yakit.Error("  - macOS/Linux: run with sudo, or ensure BPF permissions are set")
        yakit.Error("  - macOS: you may need to log out and back in after fixing BPF permissions")
        yakit.Error("  - Windows: run as Administrator")
        yakit.Error("  - Or use mode=tcp for TCP connect scan (no special privileges needed)")
        return
    }

    results, scanErr = doSynScan()
    if scanErr != nil {
        yakit.Error("SYN scan failed: %v", scanErr)
        return
    }

} elif mode == "tcp" {
    // tcp 模式：纯 TCP 连接扫描, 不需要特殊权限
    results, scanErr = doTcpScan()
    if scanErr != nil {
        yakit.Error("TCP connect scan failed: %v", scanErr)
        return
    }
}

if results != nil {
    reportResults(results)
} else {
    yakit.Error("no scan results available")
}
