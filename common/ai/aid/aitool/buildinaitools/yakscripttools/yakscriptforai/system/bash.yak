__DESC__ = "ä¸€ä¸ªè·¨å¹³å°çš„Shellå‘½ä»¤æ‰§è¡Œå·¥å…·ï¼Œæ”¯æŒbashã€cmdã€powershellç­‰å¤šç§shellç±»å‹ï¼Œå…è®¸ç”¨æˆ·åœ¨å—æ§ç¯å¢ƒä¸­æ‰§è¡Œä»»æ„shellå‘½ä»¤ï¼Œæ”¯æŒè¶…æ—¶æ§åˆ¶å’Œè¾“å‡ºæ•è·ï¼Œé€‚ç”¨äºç³»ç»Ÿç®¡ç†ã€è‡ªåŠ¨åŒ–è„šæœ¬æ‰§è¡Œå’Œè¿ç»´æ“ä½œã€‚æ³¨æ„ï¼šå½“ä½¿ç”¨cmdç±»å‹æ—¶ï¼Œè·¯å¾„ä¸­çš„åæ–œæ (\\)éœ€è¦è½¬ä¹‰ï¼Œä¾‹å¦‚åº”ä½¿ç”¨ C:\\\\Users è€Œä¸æ˜¯ C:\\Usersã€‚ã€é‡è¦æç¤ºã€‘ä¸ºé¿å…å‘½ä»¤å¡ä½ï¼Œè¯·ç¡®ä¿ç”Ÿæˆçš„å‘½ä»¤èƒ½åœ¨åˆç†æ—¶é—´å†…å®Œæˆï¼Œå¯¹äºå¯èƒ½é•¿æ—¶é—´è¿è¡Œçš„å‘½ä»¤ï¼ˆå¦‚ tail -fã€watchã€ping æ— é™å¾ªç¯ç­‰ï¼‰ï¼Œè¯·ä½¿ç”¨ timeout å‘½ä»¤åŒ…è£…æˆ–æ·»åŠ é€‚å½“çš„é™åˆ¶å‚æ•°ï¼ˆå¦‚ ping -c 5ï¼‰ã€‚é»˜è®¤è¶…æ—¶æ—¶é—´ä¸º60ç§’ã€‚"
__VERBOSE_NAME__ = "è·¨å¹³å°Shellå‘½ä»¤æ‰§è¡Œå·¥å…·"
__KEYWORDS__ = "shell command,bash,cmd,powershell,å‘½ä»¤è¡Œå·¥å…·,ç³»ç»Ÿç®¡ç†,è‡ªåŠ¨åŒ–è„šæœ¬,è¿ç»´å·¥å…·,shell script,command execution,ç³»ç»Ÿæ“ä½œ,ç»ˆç«¯å‘½ä»¤,system administration,automation tools,æ“ä½œç³»ç»Ÿ,è·¨å¹³å°å‘½ä»¤,timeout,è¶…æ—¶æ§åˆ¶"

yakit.AutoInitYakit()

// è§£æå‘½ä»¤è¡Œå‚æ•°ï¼šè¶…æ—¶æ—¶é—´ã€shellç±»å‹å’Œè¦æ‰§è¡Œçš„å‘½ä»¤
timeoutSeconds := cli.Int("timeout", cli.setRequired(false), cli.setHelp("the timeout seconds for the shell command, default 60. Commands exceeding this timeout will be killed. Set a reasonable value to avoid hanging. IMPORTANT: Avoid indefinite commands like 'tail -f', 'ping' without -c, 'watch', etc."), cli.setDefault(60))
shellType := cli.String("shell", cli.setRequired(false), cli.setHelp("shell type: bash, cmd, powershell. Auto-detect if not specified (linux/mac: bash, windows: cmd)"), cli.setDefault(""))
command := cli.String("command", cli.setRequired(true), cli.setHelp("the shell command you want to execute. IMPORTANT: Avoid commands that run indefinitely (e.g., tail -f, ping without -c, watch). For potentially long-running commands, use timeout wrapper or add limits."))

cli.check()

// è·å–æ“ä½œç³»ç»Ÿç±»å‹
osType = os.OS

// æ ¹æ®ç³»ç»Ÿç±»å‹å’Œç”¨æˆ·è®¾ç½®ç¡®å®šshellç±»å‹
if shellType == "" {
    switch osType {
    case "windows":
        shellType = "cmd"
        yakit.Info("Auto-detected Windows, using cmd shell")
    case "linux", "darwin":
        shellType = "bash"
        yakit.Info("Auto-detected %v, using bash shell", osType)
    default:
        shellType = "bash"
        yakit.Info("Unknown OS %v, defaulting to bash shell", osType)
    }
} else {
    yakit.Info("Using specified shell: %v", shellType)
}

yakit.Info("Executing %v command with %d seconds timeout: %#v", shellType, timeoutSeconds, command)

// éªŒè¯è¶…æ—¶å‚æ•°ï¼Œç¡®ä¿ä¸ä¸ºé›¶æˆ–è´Ÿæ•°
if timeoutSeconds <= 0 {
    timeoutSeconds = 60
    yakit.Info("Invalid timeout value, using default 60 seconds")
}

// åˆ›å»ºå¸¦è¶…æ—¶çš„ä¸Šä¸‹æ–‡ï¼Œä¿æŠ¤ç³»ç»Ÿèµ„æº
ctx, cancel = context.WithTimeout(context.Background(), time.ParseDuration(sprint(timeoutSeconds) + "s")~)
defer cancel()

// æ ¹æ®shellç±»å‹æ„å»ºç›¸åº”çš„å‘½ä»¤æ‰§è¡Œå™¨
var cmd
var err
switch shellType {
case "bash":
    cmd, err = exec.CommandContext(ctx, "bash -c %#v" % command)
case "cmd":
    cmd, err = exec.CommandContext(ctx, "cmd /c %v" % command)
case "powershell":
    cmd, err = exec.CommandContext(ctx, "powershell.exe -NoProfile -ExecutionPolicy Bypass -Command %s" % command)
default:
    yakit.Error("Unsupported shell type: %v. Supported types: bash, cmd, powershell", shellType)
    return
}

if err != nil {
    yakit.Error("Failed to create %v command: %v", shellType, err)
    return
}

// åˆ›å»ºè¾“å‡ºç¼“å†²åŒºä»¥æ•è·å‘½ä»¤ç»“æœ
stdoutbuf = bufio.NewBuffer()
stderrbuf = bufio.NewBuffer()
cmd.Stdout = stdoutbuf
cmd.Stderr = stderrbuf

// æ‰§è¡Œå‘½ä»¤å¹¶å¤„ç†ç»“æœ
err = cmd.Run()
isTimeout = false
if err != nil {
    errStr = sprint(err)
    // æ£€æŸ¥æ˜¯å¦æ˜¯è¶…æ—¶å¯¼è‡´çš„é”™è¯¯ï¼ˆé€šè¿‡é”™è¯¯ä¿¡æ¯åˆ¤æ–­ï¼‰
    if str.Contains(errStr, "killed") || str.Contains(errStr, "signal: killed") || str.Contains(errStr, "context deadline exceeded") {
        isTimeout = true
        yakit.Info("âš ï¸ COMMAND TIMEOUT: The command was killed after %d seconds timeout. The command may be running too long or hanging indefinitely.", timeoutSeconds)
        yakit.Info("ğŸ’¡ SUGGESTION: For long-running commands, consider using 'timeout' command wrapper (e.g., 'timeout 30 your_command'), or add limits to your command (e.g., 'ping -c 5' instead of 'ping').")
    } else {
        yakit.Error("%v command execution failed: %v", shellType, err)
    }
}

toUtf8 = (s)=>{
    res,err = codec.GBKSafe(s)
    if err {
        return s
    }
    return res
}

// è¾“å‡ºæ‰§è¡Œç»“æœ
count := 0
if stdoutbuf.Len() > 0 {
    count++
    yakit.Info("Stdout:\n%v", toUtf8(stdoutbuf.String()))
}
if stderrbuf.Len() > 0 {
    count++
    yakit.Info("Stderr:\n%v", toUtf8(stderrbuf.String()))
}
if count <= 0 {
    if isTimeout {
        yakit.Info("No output captured before timeout")
    } else {
        yakit.Info("No output found, %v command execution failed or output is empty", shellType)
    }
}
