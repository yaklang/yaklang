__DESC__ = `ä¸€ä¸ªè·¨å¹³å°çš„Shellå‘½ä»¤æ‰§è¡Œå·¥å…·ï¼Œæ”¯æŒbashã€cmdã€powershellç­‰å¤šç§shellç±»å‹ï¼Œå…è®¸ç”¨æˆ·åœ¨å—æ§ç¯å¢ƒä¸­æ‰§è¡Œä»»æ„shellå‘½ä»¤ï¼Œæ”¯æŒè¶…æ—¶æ§åˆ¶å’Œè¾“å‡ºæ•è·ï¼Œé€‚ç”¨äºç³»ç»Ÿç®¡ç†ã€è‡ªåŠ¨åŒ–è„šæœ¬æ‰§è¡Œå’Œè¿ç»´æ“ä½œã€‚

ã€è¶…æ—¶æ§åˆ¶ã€‘ä¸ºé¿å…å‘½ä»¤å¡ä½ï¼Œè¯·ç¡®ä¿ç”Ÿæˆçš„å‘½ä»¤èƒ½åœ¨åˆç†æ—¶é—´å†…å®Œæˆã€‚å¯¹äºå¯èƒ½é•¿æ—¶é—´è¿è¡Œçš„å‘½ä»¤ï¼ˆå¦‚ tail -fã€watchã€ping æ— é™å¾ªç¯ç­‰ï¼‰ï¼Œè¯·ä½¿ç”¨ timeout ä¸Šä¸‹æ–‡æ§åˆ¶æˆ–æ·»åŠ é€‚å½“çš„é™åˆ¶å‚æ•°ï¼ˆå¦‚ ping -c 5ï¼‰ã€‚é»˜è®¤è¶…æ—¶æ—¶é—´ä¸º60ç§’ã€‚

ã€æƒé™ä¸å®‰å…¨è­¦å‘Š - éå¸¸é‡è¦ã€‘
1. ã€é¿å…æ•æ„Ÿç›®å½•æ‰«æã€‘ä¸è¦å¯¹æ ¹ç›®å½• / æˆ–ç³»ç»Ÿç›®å½•æ‰§è¡Œé€’å½’æ“ä½œï¼ˆå¦‚ find / -xxxã€ls -R /ï¼‰ã€‚è¿™ä¼šè§¦å‘æ“ä½œç³»ç»Ÿå®‰å…¨è­¦å‘Šï¼Œä¸”åœ¨érootæƒé™ä¸‹å¤§é‡æŠ¥é”™ã€‚
2. ã€ç¦æ­¢è®¿é—®æ•æ„Ÿæ–‡ä»¶ã€‘érootç”¨æˆ·ç¦æ­¢å°è¯•è®¿é—®ï¼š/etc/shadowã€/root/.ssh/*ã€/etc/sudoers ç­‰æ•æ„Ÿé…ç½®æ–‡ä»¶ã€‚
3. ã€é™åˆ¶æœç´¢èŒƒå›´ã€‘ä½¿ç”¨ find å‘½ä»¤æ—¶ï¼Œå¿…é¡»æŒ‡å®šå…·ä½“ç›®å½•ï¼ˆå¦‚ find /home/user -name xxxï¼‰ï¼Œç¦æ­¢ä½¿ç”¨ find / å…¨ç›˜æœç´¢ã€‚å¯æ·»åŠ  -maxdepth é™åˆ¶æ·±åº¦ã€‚
4. ã€é¿å…æƒé™å‡çº§å°è¯•ã€‘ä¸è¦æ‰§è¡Œ sudoã€suã€chmod 777 ç­‰å¯èƒ½è¢«è§†ä¸ºæ¶æ„çš„æ“ä½œã€‚
5. ã€å®‰å…¨çš„æ›¿ä»£æ–¹æ¡ˆã€‘
   - æŸ¥çœ‹ç³»ç»Ÿä¿¡æ¯: uname -a, hostnamectl, cat /etc/os-release
   - æ£€æŸ¥ç£ç›˜: df -hï¼ˆå½“å‰ç”¨æˆ·å¯è¯»çš„åˆ†åŒºï¼‰
   - æ£€æŸ¥è¿›ç¨‹: ps aux, top -l 1ï¼ˆmacOSï¼‰, top -bn1ï¼ˆLinuxï¼‰
   - æ£€æŸ¥ç½‘ç»œ: netstat -tuln, ss -tuln, lsof -iï¼ˆé™åˆ¶ç«¯å£ï¼‰
   - æ£€æŸ¥ç«¯å£: lsof -i:ç«¯å£å·

ã€Windowsæ³¨æ„ã€‘å½“ä½¿ç”¨cmdç±»å‹æ—¶ï¼Œè·¯å¾„ä¸­çš„åæ–œæ (\)éœ€è¦è½¬ä¹‰ï¼Œä¾‹å¦‚åº”ä½¿ç”¨ C:\\Users è€Œä¸æ˜¯ C:\Usersã€‚

ã€Bashæ‰§è¡Œç‰¹æ€§ã€‘
- è„šæœ¬ä»¥ set -e æ¨¡å¼æ‰§è¡Œï¼Œé‡åˆ°é”™è¯¯ç«‹å³é€€å‡ºï¼Œé¿å…ç¾éš¾æ€§åæœ
- è„šæœ¬ä»¥ set -x æ¨¡å¼æ‰§è¡Œï¼ˆtraceï¼‰ï¼Œè¾“å‡ºæ¯æ¡æ‰§è¡Œçš„å‘½ä»¤ï¼Œä¾¿äºè°ƒè¯•å’Œé”™è¯¯å®šä½
- é”™è¯¯è¾“å‡ºåŒ…å«è¡Œå·ä¿¡æ¯ï¼Œä¾¿äºè¯†åˆ«é—®é¢˜ä½ç½®`
__VERBOSE_NAME__ = "è·¨å¹³å°Shellå‘½ä»¤æ‰§è¡Œå·¥å…·"
__KEYWORDS__ = "shell command,bash,cmd,powershell,å‘½ä»¤è¡Œå·¥å…·,ç³»ç»Ÿç®¡ç†,è‡ªåŠ¨åŒ–è„šæœ¬,è¿ç»´å·¥å…·,shell script,command execution,ç³»ç»Ÿæ“ä½œ,ç»ˆç«¯å‘½ä»¤,system administration,automation tools,æ“ä½œç³»ç»Ÿ,è·¨å¹³å°å‘½ä»¤,timeout,è¶…æ—¶æ§åˆ¶"

yakit.AutoInitYakit()

// è§£æå‘½ä»¤è¡Œå‚æ•°ï¼šè¶…æ—¶æ—¶é—´ã€shellç±»å‹å’Œè¦æ‰§è¡Œçš„å‘½ä»¤
timeoutSeconds := cli.Int("timeout", cli.setRequired(false), cli.setHelp("the timeout seconds for the shell command, default 60. Commands exceeding this timeout will be killed. Set a reasonable value to avoid hanging. IMPORTANT: Avoid indefinite commands like 'tail -f', 'ping' without -c, 'watch', etc."), cli.setDefault(60))
shellType := cli.String("shell", cli.setRequired(false), cli.setHelp("shell type: bash, cmd, powershell. Auto-detect if not specified (linux/mac: bash, windows: cmd)"), cli.setDefault(""))
command := cli.String("command", cli.setRequired(true), cli.setHelp("the shell command you want to execute. IMPORTANT: Avoid commands that run indefinitely (e.g., tail -f, ping without -c, watch). For potentially long-running commands, use timeout wrapper or add limits."))

cli.check()

// è·å–æ“ä½œç³»ç»Ÿç±»å‹
osType = os.OS

// æ ¹æ®ç³»ç»Ÿç±»å‹å’Œç”¨æˆ·è®¾ç½®ç¡®å®šshellç±»å‹
if shellType == "" {
    switch osType {
    case "windows":
        shellType = "cmd"
        yakit.Info("Auto-detected Windows, using cmd shell")
    case "linux", "darwin":
        shellType = "bash"
        yakit.Info("Auto-detected %v, using bash shell", osType)
    default:
        shellType = "bash"
        yakit.Info("Unknown OS %v, defaulting to bash shell", osType)
    }
} else {
    yakit.Info("Using specified shell: %v", shellType)
}

// éªŒè¯è¶…æ—¶å‚æ•°ï¼Œç¡®ä¿ä¸ä¸ºé›¶æˆ–è´Ÿæ•°
if timeoutSeconds <= 0 {
    timeoutSeconds = 60
    yakit.Info("Invalid timeout value, using default 60 seconds")
}

// åˆ›å»ºå¸¦è¶…æ—¶çš„ä¸Šä¸‹æ–‡ï¼Œä¿æŠ¤ç³»ç»Ÿèµ„æº
ctx, cancel = context.WithTimeout(context.Background(), time.ParseDuration(sprint(timeoutSeconds) + "s")~)
defer cancel()

// æ ¹æ®shellç±»å‹æ„å»ºç›¸åº”çš„å‘½ä»¤æ‰§è¡Œå™¨
var cmd
var err
var scriptFile = ""

switch shellType {
case "bash":
    // Generate a temporary script file with proper bash settings
    // - set -e: Exit immediately if a command exits with a non-zero status
    // - set -x: Print commands and their arguments as they are executed (trace mode)
    // This approach avoids all quoting/escaping issues and provides better debugging
    
    scriptContent := `#!/bin/bash
# Auto-generated script by AI tool
# Exit on error (prevents catastrophic cascading failures)
set -e
# Trace mode (shows each command with line numbers for debugging)
set -x

# User command starts here (line 8)
` + command + `
`
    
    // Create temporary script file
    scriptFile, err = file.TempFileName("ai_bash_script_*.sh")
    if err != nil {
        yakit.Error("Failed to create temporary script file: %v", err)
        return
    }
    
    // Ensure cleanup of temporary file
    defer func() {
        if scriptFile != "" {
            removeErr := file.Remove(scriptFile)
            if removeErr != nil {
                yakit.Info("Note: Failed to remove temporary script file %v: %v", scriptFile, removeErr)
            }
        }
    }()
    
    // Write script content to file
    err = file.Save(scriptFile, scriptContent)
    if err != nil {
        yakit.Error("Failed to write script content to file: %v", err)
        return
    }
    
    // Make script executable (optional, since we run via 'bash scriptfile')
    chmodErr := os.Chmod(scriptFile, 0755)
    if chmodErr != nil {
        yakit.Info("Note: Failed to chmod script file: %v (continuing anyway)", chmodErr)
    }
    
    yakit.Info("Executing bash script with %d seconds timeout", timeoutSeconds)
    yakit.Info("Script file: %v", scriptFile)
    yakit.Info("Script content preview:\n---\n%v\n---", scriptContent)
    
    // Execute the script using bash
    cmd, err = exec.CommandContext(ctx, "bash " + scriptFile)
    
case "cmd":
    // For Windows cmd, use direct command execution
    yakit.Info("Executing cmd command with %d seconds timeout: %v", timeoutSeconds, command)
    cmd, err = exec.CommandContext(ctx, "cmd /c " + command)
    
case "powershell":
    // For PowerShell, create a temporary script file as well
    scriptContent := `# Auto-generated PowerShell script by AI tool
# Stop on first error
$ErrorActionPreference = "Stop"
# Enable verbose output for debugging
Set-PSDebug -Trace 1

# User command starts here
` + command + `
`
    
    scriptFile, err = file.TempFileName("ai_powershell_script_*.ps1")
    if err != nil {
        yakit.Error("Failed to create temporary PowerShell script file: %v", err)
        return
    }
    
    defer func() {
        if scriptFile != "" {
            removeErr := file.Remove(scriptFile)
            if removeErr != nil {
                yakit.Info("Note: Failed to remove temporary script file %v: %v", scriptFile, removeErr)
            }
        }
    }()
    
    err = file.Save(scriptFile, scriptContent)
    if err != nil {
        yakit.Error("Failed to write PowerShell script content to file: %v", err)
        return
    }
    
    yakit.Info("Executing PowerShell script with %d seconds timeout", timeoutSeconds)
    yakit.Info("Script file: %v", scriptFile)
    
    cmd, err = exec.CommandContext(ctx, "powershell.exe -NoProfile -ExecutionPolicy Bypass -File " + scriptFile)
    
default:
    yakit.Error("Unsupported shell type: %v. Supported types: bash, cmd, powershell", shellType)
    return
}

if err != nil {
    yakit.Error("Failed to create %v command: %v", shellType, err)
    return
}

// åˆ›å»ºè¾“å‡ºç¼“å†²åŒºä»¥æ•è·å‘½ä»¤ç»“æœ
stdoutbuf = bufio.NewBuffer()
stderrbuf = bufio.NewBuffer()
cmd.Stdout = stdoutbuf
cmd.Stderr = stderrbuf

// æ‰§è¡Œå‘½ä»¤å¹¶å¤„ç†ç»“æœ
err = cmd.Run()
isTimeout = false
exitCode = 0

if err != nil {
    errStr = sprint(err)
    // æ£€æŸ¥æ˜¯å¦æ˜¯è¶…æ—¶å¯¼è‡´çš„é”™è¯¯ï¼ˆé€šè¿‡é”™è¯¯ä¿¡æ¯åˆ¤æ–­ï¼‰
    if str.Contains(errStr, "killed") || str.Contains(errStr, "signal: killed") || str.Contains(errStr, "context deadline exceeded") {
        isTimeout = true
        yakit.Info("âš ï¸ COMMAND TIMEOUT: The command was killed after %d seconds timeout. The command may be running too long or hanging indefinitely.", timeoutSeconds)
        yakit.Info("ğŸ’¡ SUGGESTION: For long-running commands, consider using 'timeout' command wrapper (e.g., 'timeout 30 your_command'), or add limits to your command (e.g., 'ping -c 5' instead of 'ping').")
    } else {
        // Extract exit code if available
        if str.Contains(errStr, "exit status") {
            // Parse exit code from error message like "exit status 1"
            parts = str.Split(errStr, " ")
            if len(parts) >= 3 {
                exitCode = parseInt(parts[len(parts)-1])
            }
        }
        yakit.Error("%v command execution failed (exit code %d): %v", shellType, exitCode, err)
        if shellType == "bash" {
            yakit.Info("ğŸ’¡ TIP: With 'set -e' enabled, the script exits on the first error. Check the trace output (lines starting with '+') to identify which command failed.")
            yakit.Info("ğŸ’¡ TIP: Line numbers in error messages are offset by 7 from the original command (due to script header). Subtract 7 to get the actual line in your command.")
        }
    }
}

toUtf8 = (s)=>{
    res,err = codec.GBKSafe(s)
    if err {
        return s
    }
    return res
}

// è¾“å‡ºæ‰§è¡Œç»“æœ
count := 0
if stdoutbuf.Len() > 0 {
    count++
    yakit.Info("Stdout:\n%v", toUtf8(stdoutbuf.String()))
}
if stderrbuf.Len() > 0 {
    count++
    // For bash with set -x, stderr contains trace output which is useful for debugging
    if shellType == "bash" {
        yakit.Info("Stderr (includes trace output from 'set -x', lines starting with '+' show executed commands):\n%v", toUtf8(stderrbuf.String()))
    } else {
        yakit.Info("Stderr:\n%v", toUtf8(stderrbuf.String()))
    }
}
if count <= 0 {
    if isTimeout {
        yakit.Info("No output captured before timeout")
    } else {
        yakit.Info("No output found, %v command execution completed (possibly with empty output)", shellType)
    }
}
