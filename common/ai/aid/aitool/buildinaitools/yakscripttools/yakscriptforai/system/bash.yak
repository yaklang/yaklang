__DESC__ = "è·¨å¹³å°Shellå‘½ä»¤æ‰§è¡Œå·¥å…·ï¼Œæ”¯æŒbash/cmd/powershellï¼Œå…·å¤‡è¶…æ—¶æ§åˆ¶å’Œè¾“å‡ºæ•è·ã€‚bashè„šæœ¬ä»¥set -eï¼ˆé‡é”™é€€å‡ºï¼‰å’Œset -xï¼ˆå‘½ä»¤è¿½è¸ªï¼‰æ¨¡å¼æ‰§è¡Œï¼Œé€‚ç”¨äºç³»ç»Ÿç®¡ç†ã€è‡ªåŠ¨åŒ–è„šæœ¬å’Œè¿ç»´æ“ä½œã€‚"
__VERBOSE_NAME__ = "è·¨å¹³å°Shellå‘½ä»¤æ‰§è¡Œå·¥å…·"
__KEYWORDS__ = "shell command,bash,cmd,powershell,å‘½ä»¤è¡Œå·¥å…·,ç³»ç»Ÿç®¡ç†,è‡ªåŠ¨åŒ–è„šæœ¬,è¿ç»´å·¥å…·,shell script,command execution,ç³»ç»Ÿæ“ä½œ,ç»ˆç«¯å‘½ä»¤,system administration,automation tools,æ“ä½œç³»ç»Ÿ,è·¨å¹³å°å‘½ä»¤,timeout,è¶…æ—¶æ§åˆ¶"

__USAGE__ = <<<USAGE_BLOCK
Cross-Platform Shell Command Execution Tool - Usage Guide for AI Parameter Generation

## Parameters

Required:
  command   (string)  The shell command or script to execute.
                      Single-line commands: put directly in JSON params.command
                      Multi-line scripts: MUST use AITAG format for the command parameter

Optional:
  timeout   (int)     *** CRITICAL: YOU MUST ALWAYS SET THIS PARAMETER ***
                      Max execution time in seconds. Process is KILLED when timeout is reached.
                      Default: 60 (but DO NOT rely on the default -- always set explicitly!)
                      If the command hangs or runs forever, the entire tool call blocks.
                      Recommended values:
                        - Quick queries (ls, cat, echo, uname, whoami): 10-15
                        - File operations (find, grep, du): 15-30
                        - Network commands (curl, wget, ping -c N): 30-60
                        - Build/compile/install (make, go build, pip install): 120-300
  shell     (string)  Shell type: "bash" | "cmd" | "powershell"
                      Default: auto-detect (linux/mac -> bash, windows -> cmd)

## Execution Characteristics

bash:  set -e (exit on error) + set -x (trace mode, shows each command with '+' prefix)
cmd:   executes via "cmd /c", backslashes MUST be escaped: "C:\\Users"
powershell: $ErrorActionPreference="Stop" + Set-PSDebug -Trace 1

## Safety Rules

FORBIDDEN: find / , ls -R / , sudo, su, chmod 777, rm -rf /, access to /etc/shadow
MUST have limits: ping -c N, find ... -maxdepth N, tail -n N (never -f), pipe | head -N

## Few-Shot Examples

Replace {NONCE} with the actual nonce from the response format section.

### Example 1: Simple one-line command (JSON params, explicit timeout)

User intent: "Check disk space"

```json
{
  "@action": "call-tool",
  "tool": "bash",
  "identifier": "check_disk_space",
  "params": {
    "command": "df -h",
    "timeout": 10
  }
}
```

### Example 2: Multi-line diagnostic script (AITAG for command)

User intent: "Show system status: OS, memory, and top processes"

```json
{
  "@action": "call-tool",
  "tool": "bash",
  "identifier": "system_status_check",
  "params": {
    "timeout": 20
  }
}
```

<|TOOL_PARAM_command_{NONCE}|>
echo "=== OS Info ==="
uname -a
echo ""
echo "=== Memory ==="
free -h 2>/dev/null || vm_stat 2>/dev/null || echo "Memory info not available"
echo ""
echo "=== Top 5 CPU Processes ==="
ps aux --sort=-%cpu 2>/dev/null | head -6 || ps aux | head -6
<|TOOL_PARAM_command_END_{NONCE}|>

### Example 3: File search with safety limits (AITAG for command)

User intent: "Find large log files in /var/log"

```json
{
  "@action": "call-tool",
  "tool": "bash",
  "identifier": "find_large_logs",
  "params": {
    "timeout": 20
  }
}
```

<|TOOL_PARAM_command_{NONCE}|>
echo "Searching for .log files > 10MB (max depth 3)..."
find /var/log -name "*.log" -size +10M -maxdepth 3 -type f -exec ls -lh {} \; 2>/dev/null | head -20
echo ""
du -sh /var/log 2>/dev/null || echo "Cannot access /var/log"
<|TOOL_PARAM_command_END_{NONCE}|>

### Example 4: Complex script with conditional logic (AITAG for command)

User intent: "Check if Python3 is installed, show version and packages"

```json
{
  "@action": "call-tool",
  "tool": "bash",
  "identifier": "check_python_env",
  "params": {
    "timeout": 25
  }
}
```

<|TOOL_PARAM_command_{NONCE}|>
if command -v python3 &> /dev/null; then
    echo "Python3 found: $(python3 --version)"
    echo "Path: $(which python3)"
    echo ""
    echo "Installed packages (first 20):"
    python3 -m pip list 2>/dev/null | head -20 || echo "pip not available"
else
    echo "Python3 not found"
    which python 2>/dev/null && python --version 2>/dev/null || echo "No python found"
fi
<|TOOL_PARAM_command_END_{NONCE}|>

## Key Rules

1. ** TIMEOUT IS MANDATORY ** -- Always set timeout explicitly. Do NOT rely on the default 60s.
   Estimate how long the command should take, and set timeout to ~1.5x that estimate.
   A command that hangs without timeout will block the entire agent workflow.
2. Multi-line commands -> ALWAYS use AITAG for the command parameter
3. Single-line commands -> Use JSON params.command directly
4. Limit output: pipe through | head -N; limit search: add -maxdepth to find
5. Use fallback chains for cross-platform: cmd1 2>/dev/null || cmd2 || echo "not available"
6. NEVER generate indefinite commands (no tail -f, no watch, no ping without -c)
USAGE_BLOCK

yakit.AutoInitYakit()

// è§£æå‘½ä»¤è¡Œå‚æ•°ï¼šè¶…æ—¶æ—¶é—´ã€shellç±»å‹å’Œè¦æ‰§è¡Œçš„å‘½ä»¤
timeoutSeconds := cli.Int("timeout", cli.setRequired(false), cli.setHelp("the timeout seconds for the shell command, default 60. Commands exceeding this timeout will be killed. Set a reasonable value to avoid hanging. IMPORTANT: Avoid indefinite commands like 'tail -f', 'ping' without -c, 'watch', etc."), cli.setDefault(60))
shellType := cli.String("shell", cli.setRequired(false), cli.setHelp("shell type: bash, cmd, powershell. Auto-detect if not specified (linux/mac: bash, windows: cmd)"), cli.setDefault(""))
command := cli.String("command", cli.setRequired(true), cli.setHelp("the shell command you want to execute. IMPORTANT: Avoid commands that run indefinitely (e.g., tail -f, ping without -c, watch). For potentially long-running commands, use timeout wrapper or add limits."))

cli.check()

// è·å–æ“ä½œç³»ç»Ÿç±»å‹
osType = os.OS

// æ ¹æ®ç³»ç»Ÿç±»å‹å’Œç”¨æˆ·è®¾ç½®ç¡®å®šshellç±»å‹
if shellType == "" {
    switch osType {
    case "windows":
        shellType = "cmd"
        yakit.Info("Auto-detected Windows, using cmd shell")
    case "linux", "darwin":
        shellType = "bash"
        yakit.Info("Auto-detected %v, using bash shell", osType)
    default:
        shellType = "bash"
        yakit.Info("Unknown OS %v, defaulting to bash shell", osType)
    }
} else {
    yakit.Info("Using specified shell: %v", shellType)
}

// éªŒè¯è¶…æ—¶å‚æ•°ï¼Œç¡®ä¿ä¸ä¸ºé›¶æˆ–è´Ÿæ•°
if timeoutSeconds <= 0 {
    timeoutSeconds = 60
    yakit.Info("Invalid timeout value, using default 60 seconds")
}

// åˆ›å»ºå¸¦è¶…æ—¶çš„ä¸Šä¸‹æ–‡ï¼Œä¿æŠ¤ç³»ç»Ÿèµ„æº
ctx, cancel = context.WithTimeout(context.Background(), time.ParseDuration(sprint(timeoutSeconds) + "s")~)
defer cancel()

// æ ¹æ®shellç±»å‹æ„å»ºç›¸åº”çš„å‘½ä»¤æ‰§è¡Œå™¨
var cmd
var err
var scriptFile = ""

switch shellType {
case "bash":
    // Generate a temporary script file with proper bash settings
    // - set -e: Exit immediately if a command exits with a non-zero status
    // - set -x: Print commands and their arguments as they are executed (trace mode)
    // This approach avoids all quoting/escaping issues and provides better debugging
    
    scriptContent := `#!/bin/bash
# Auto-generated script by AI tool
# Exit on error (prevents catastrophic cascading failures)
set -e
# Trace mode (shows each command with line numbers for debugging)
set -x

# User command starts here (line 8)
` + command + `
`
    
    // Create temporary script file
    scriptFile, err = file.TempFileName("ai_bash_script_*.sh")
    if err != nil {
        yakit.Error("Failed to create temporary script file: %v", err)
        return
    }
    
    // Ensure cleanup of temporary file
    defer func() {
        if scriptFile != "" {
            removeErr := file.Remove(scriptFile)
            if removeErr != nil {
                yakit.Info("Note: Failed to remove temporary script file %v: %v", scriptFile, removeErr)
            }
        }
    }()
    
    // Write script content to file
    err = file.Save(scriptFile, scriptContent)
    if err != nil {
        yakit.Error("Failed to write script content to file: %v", err)
        return
    }
    
    // Make script executable (optional, since we run via 'bash scriptfile')
    chmodErr := os.Chmod(scriptFile, 0755)
    if chmodErr != nil {
        yakit.Info("Note: Failed to chmod script file: %v (continuing anyway)", chmodErr)
    }
    
    yakit.Info("Executing bash script with %d seconds timeout", timeoutSeconds)
    yakit.Info("Script file: %v", scriptFile)
    yakit.Info("Script content preview:\n---\n%v\n---", scriptContent)
    
    // Execute the script using bash
    cmd, err = exec.CommandContext(ctx, "bash " + scriptFile)
    
case "cmd":
    // For Windows cmd, use direct command execution
    yakit.Info("Executing cmd command with %d seconds timeout: %v", timeoutSeconds, command)
    cmd, err = exec.CommandContext(ctx, "cmd /c " + command)
    
case "powershell":
    // For PowerShell, create a temporary script file as well
    scriptContent := `# Auto-generated PowerShell script by AI tool
# Stop on first error
$ErrorActionPreference = "Stop"
# Enable verbose output for debugging
Set-PSDebug -Trace 1

# User command starts here
` + command + `
`
    
    scriptFile, err = file.TempFileName("ai_powershell_script_*.ps1")
    if err != nil {
        yakit.Error("Failed to create temporary PowerShell script file: %v", err)
        return
    }
    
    defer func() {
        if scriptFile != "" {
            removeErr := file.Remove(scriptFile)
            if removeErr != nil {
                yakit.Info("Note: Failed to remove temporary script file %v: %v", scriptFile, removeErr)
            }
        }
    }()
    
    err = file.Save(scriptFile, scriptContent)
    if err != nil {
        yakit.Error("Failed to write PowerShell script content to file: %v", err)
        return
    }
    
    yakit.Info("Executing PowerShell script with %d seconds timeout", timeoutSeconds)
    yakit.Info("Script file: %v", scriptFile)
    
    cmd, err = exec.CommandContext(ctx, "powershell.exe -NoProfile -ExecutionPolicy Bypass -File " + scriptFile)
    
default:
    yakit.Error("Unsupported shell type: %v. Supported types: bash, cmd, powershell", shellType)
    return
}

if err != nil {
    yakit.Error("Failed to create %v command: %v", shellType, err)
    return
}

// åˆ›å»ºè¾“å‡ºç¼“å†²åŒºä»¥æ•è·å‘½ä»¤ç»“æœ
stdoutbuf = bufio.NewBuffer()
stderrbuf = bufio.NewBuffer()
cmd.Stdout = stdoutbuf
cmd.Stderr = stderrbuf

// æ‰§è¡Œå‘½ä»¤å¹¶å¤„ç†ç»“æœ
err = cmd.Run()
isTimeout = false
exitCode = 0

if err != nil {
    errStr = sprint(err)
    // æ£€æŸ¥æ˜¯å¦æ˜¯è¶…æ—¶å¯¼è‡´çš„é”™è¯¯ï¼ˆé€šè¿‡é”™è¯¯ä¿¡æ¯åˆ¤æ–­ï¼‰
    if str.Contains(errStr, "killed") || str.Contains(errStr, "signal: killed") || str.Contains(errStr, "context deadline exceeded") {
        isTimeout = true
        yakit.Info("âš ï¸ COMMAND TIMEOUT: The command was killed after %d seconds timeout. The command may be running too long or hanging indefinitely.", timeoutSeconds)
        yakit.Info("ğŸ’¡ SUGGESTION: For long-running commands, consider using 'timeout' command wrapper (e.g., 'timeout 30 your_command'), or add limits to your command (e.g., 'ping -c 5' instead of 'ping').")
    } else {
        // Extract exit code if available
        if str.Contains(errStr, "exit status") {
            // Parse exit code from error message like "exit status 1"
            parts = str.Split(errStr, " ")
            if len(parts) >= 3 {
                exitCode = parseInt(parts[len(parts)-1])
            }
        }
        yakit.Error("%v command execution failed (exit code %d): %v", shellType, exitCode, err)
        if shellType == "bash" {
            yakit.Info("ğŸ’¡ TIP: With 'set -e' enabled, the script exits on the first error. Check the trace output (lines starting with '+') to identify which command failed.")
            yakit.Info("ğŸ’¡ TIP: Line numbers in error messages are offset by 7 from the original command (due to script header). Subtract 7 to get the actual line in your command.")
        }
    }
}

// Platform-aware output encoding conversion:
// - Windows: cmd.exe/powershell may output GBK-encoded text, use codec.GBKSafe to convert
// - macOS/Linux: bash outputs UTF-8 natively, use codec.FixUTF8 to preserve valid UTF-8
//   and only escape truly invalid bytes (e.g. binary data mixed into output)
//
// Why not use codec.GBKSafe on macOS/Linux?
//   GBKSafe checks utf8.Valid() on the ENTIRE buffer. If even one invalid byte exists
//   (e.g. from httpd -V or other commands mixing binary into stderr), it converts the
//   ENTIRE buffer from GBK to UTF-8, which corrupts all Chinese UTF-8 characters
//   (e.g. "æœåŠ¡é…ç½®æ£€æŸ¥" becomes "é‘¸å—›å§Šçƒ¯é—ç£…æ›å¤Šâ‚¬é‘º6").
toUtf8 = (s)=>{
    if osType == "windows" {
        res, err = codec.GBKSafe(s)
        if err {
            // GBK conversion failed, fall back to fixing invalid bytes
            return codec.FixUTF8(s)
        }
        return res
    }
    // macOS/Linux: output is UTF-8, preserve valid characters and escape bad bytes
    return codec.FixUTF8(s)
}

// è¾“å‡ºæ‰§è¡Œç»“æœ
count := 0
if stdoutbuf.Len() > 0 {
    count++
    yakit.Info("Stdout:\n%v", toUtf8(stdoutbuf.String()))
}
if stderrbuf.Len() > 0 {
    count++
    // For bash with set -x, stderr contains trace output which is useful for debugging
    if shellType == "bash" {
        yakit.Info("Stderr (includes trace output from 'set -x', lines starting with '+' show executed commands):\n%v", toUtf8(stderrbuf.String()))
    } else {
        yakit.Info("Stderr:\n%v", toUtf8(stderrbuf.String()))
    }
}
if count <= 0 {
    if isTimeout {
        yakit.Info("No output captured before timeout")
    } else {
        yakit.Info("No output found, %v command execution completed (possibly with empty output)", shellType)
    }
}
