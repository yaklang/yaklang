__DESC__ = "专门用于分析chall.pcapng等网络安全挑战PCAP文件的工具，支持解密隐蔽通信、提取flag、识别网络工具行为。"
__VERBOSE_NAME__ = "挑战PCAP分析工具"
__KEYWORDS__ = "challenge,ctf,网络安全挑战,隐蔽通信,flag提取,网络工具分析,流量解密,恶意行为检测"

/*
挑战PCAP分析工具

功能特点：
1. 专门针对CTF和网络安全挑战的PCAP分析
   - 识别隐蔽通信通道
   - 提取隐藏的flag和敏感信息
   - 分析网络工具的使用痕迹
   - 解密加密通信内容

2. 高级分析功能：
   - DNS隧道检测和解密
   - HTTP头信息分析
   - TCP流重组和payload提取
   - 协议逆向分析
   - 编码内容自动识别和解码

3. flag提取：
   - 自动识别flag格式
   - 提取base64/hex编码的flag
   - 从网络流量中提取隐藏信息
   - 支持多种flag格式识别

4. 参数说明：
   --file: PCAP文件路径 (必需)
   --extract-flags: 自动提取flag (可选，默认true)
   --decode-all: 尝试解码所有可疑内容 (可选，默认true)
   --verbose: 详细输出模式 (可选，默认false)

使用示例：
1. 分析挑战PCAP文件：
   yak analyze_challenge_pcap.yak --file chall.pcapng

2. 详细分析模式：
   yak analyze_challenge_pcap.yak --file chall.pcapng --verbose

3. 禁用自动flag提取：
   yak analyze_challenge_pcap.yak --file chall.pcapng --extract-flags false

注意事项：
- 专门为网络安全挑战和CTF设计
- 支持多种隐蔽通信方式的检测
- 自动保存发现的flag和敏感信息
- 详细分析可能需要较长时间
- 输出包含flag提取结果和通信分析
*/

yakit.AutoInitYakit()

// 解析命令行参数
pcapFile := cli.String("file", cli.setRequired(true), cli.setHelp("challenge PCAP file to analyze"))
extractFlags := cli.Bool("extract-flags", cli.setDefault(true), cli.setHelp("automatically extract flags"))
decodeAll := cli.Bool("decode-all", cli.setDefault(true), cli.setHelp("attempt to decode all suspicious content"))
verbose := cli.Bool("verbose", cli.setHelp("verbose output mode"))

cli.check()

yakit.Info("Starting challenge PCAP analysis for file: %v", pcapFile)

// 检查文件是否存在
if !file.IsExisted(pcapFile) {
    yakit.Error("PCAP file does not exist: %v", pcapFile)
    return
}

// 初始化分析结果
challengeResults := {
    "packets_analyzed": 0,
    "flags_found": [],
    "suspicious_traffic": [],
    "decoded_content": [],
    "network_tools": [],
    "hidden_channels": [],
    "extracted_data": [],
}

// flag模式识别
flagPatterns := [
    "flag\\{[^{}]*\\}",
    "CTF\\{[^{}]*\\}",
    "[Ff][Ll][Aa][Gg]\\{[^{}]*\\}",
    "([a-zA-Z0-9]{8}-[a-zA-Z0-9]{4}-[a-zA-Z0-9]{4}-[a-zA-Z0-9]{4}-[a-zA-Z0-9]{12})", // UUID格式
    "([a-zA-Z0-9+/=]{20,})", // base64-like strings
    "0x[0-9a-fA-F]{8,}", // hex values
]

// 网络工具特征
networkTools := [
    "nmap", "masscan", "zmap", "dirb", "gobuster", "ffuf",
    "sqlmap", "burp", "wireshark", "tcpdump", "ettercap",
    "metasploit", "cobalt", "empire", "covenant", "sliver",
    "nc ", "netcat", "ncat", "socat", "ssh", "scp", "rsync",
    "wget", "curl", "python", "perl", "ruby", "php",
    "bash", "sh", "powershell", "cmd.exe",
]

// 隐蔽通道检测
hiddenChannels := [
    "TXT", "NULL", "CNAME", "MX", "SRV", // DNS隧道
    "CONNECT", "Proxy-Authorization", // HTTP隧道
    "tor", "i2p", "freenet", // 匿名网络
    "VPN", "SSH", "SSL", // 加密隧道
]

// 高级数据包分析函数
analyzeChallengePacket = func(packet) {
    challengeResults["packets_analyzed"]++

    if packet == nil {
        return
    }

    data := packet.Data()
    if data == nil || len(data) == 0 {
        return
    }

    packetStr := string(data)
    packetHex := codec.EncodeToHex(data)

    if verbose {
        yakit.Info("Analyzing packet %v (%v bytes)", challengeResults["packets_analyzed"], len(data))
    }

    suspicious := false

    // 1. flag提取
    if extractFlags {
        for pattern in flagPatterns {
            matches := regexp.FindAllStringSubmatch(packetStr, pattern)
            if matches != nil {
                for match in matches {
                    if len(match) > 1 {
                        flag := match[1]
                        challengeResults["flags_found"] = append(challengeResults["flags_found"], {
                            "flag": flag,
                            "pattern": pattern,
                            "packet": challengeResults["packets_analyzed"],
                            "context": packetStr,
                        })
                        yakit.Info("🚩 FLAG FOUND: %v", flag)
                        suspicious = true
                    }
                }
            }
        }

        // 检测可能的编码flag
        if len(data) > 10 {
            // 尝试base64解码
            decoded, err := codec.DecodeBase64(string(data))
            if err == nil {
                decodedStr := string(decoded)
                for pattern in flagPatterns {
                    matches := regexp.FindAllStringSubmatch(decodedStr, pattern)
                    if matches != nil {
                        for match in matches {
                            if len(match) > 1 {
                                challengeResults["flags_found"] = append(challengeResults["flags_found"], {
                                    "flag": match[1],
                                    "encoding": "base64",
                                    "packet": challengeResults["packets_analyzed"],
                                    "context": decodedStr,
                                })
                                yakit.Info("🚩 FLAG FOUND (base64 decoded): %v", match[1])
                                suspicious = true
                            }
                        }
                    }
                }
            }

            // 尝试hex解码
            hexDecoded, err := codec.DecodeHex(string(data))
            if err == nil {
                hexStr := string(hexDecoded)
                for pattern in flagPatterns {
                    matches := regexp.FindAllStringSubmatch(hexStr, pattern)
                    if matches != nil {
                        for match in matches {
                            if len(match) > 1 {
                                challengeResults["flags_found"] = append(challengeResults["flags_found"], {
                                    "flag": match[1],
                                    "encoding": "hex",
                                    "packet": challengeResults["packets_analyzed"],
                                    "context": hexStr,
                                })
                                yakit.Info("🚩 FLAG FOUND (hex decoded): %v", match[1])
                                suspicious = true
                            }
                        }
                    }
                }
            }
        }
    }

    // 2. 网络工具检测
    for tool in networkTools {
        if packetStr.Contains(tool) {
            challengeResults["network_tools"] = append(challengeResults["network_tools"], {
                "tool": tool,
                "packet": challengeResults["packets_analyzed"],
                "context": packetStr,
            })
            yakit.Info("🔧 Network tool detected: %v", tool)
            suspicious = true
        }
    }

    // 3. 隐蔽通道检测
    for channel in hiddenChannels {
        if packetStr.Contains(channel) {
            challengeResults["hidden_channels"] = append(challengeResults["hidden_channels"], {
                "channel_type": channel,
                "packet": challengeResults["packets_analyzed"],
                "context": packetStr,
            })
            yakit.Info("🚪 Hidden channel detected: %v", channel)
            suspicious = true
        }
    }

    // 4. 通用解码尝试
    if decodeAll && len(data) > 4 {
        // 检测并解码base64内容
        base64Decoded, err := codec.DecodeBase64(string(data))
        if err == nil && len(base64Decoded) > 0 {
            decodedStr := string(base64Decoded)
            if len(decodedStr) != len(string(data)) { // 确保是有效的解码
                challengeResults["decoded_content"] = append(challengeResults["decoded_content"], {
                    "encoding": "base64",
                    "original": string(data),
                    "decoded": decodedStr,
                    "packet": challengeResults["packets_analyzed"],
                })
                if verbose {
                    yakit.Info("📄 Base64 decoded: %v", decodedStr[:min(100, len(decodedStr))])
                }
                suspicious = true
            }
        }

        // 检测高熵数据（可能是加密的）
        entropy := calculateEntropy(data)
        if entropy > 7.8 {
            challengeResults["suspicious_traffic"] = append(challengeResults["suspicious_traffic"], {
                "type": "high_entropy",
                "entropy": entropy,
                "packet": challengeResults["packets_analyzed"],
                "size": len(data),
            })
            yakit.Info("🔐 High entropy traffic detected (entropy: %.2f)", entropy)
            suspicious = true
        }
    }

    // 5. 提取可疑数据
    if suspicious {
        challengeResults["extracted_data"] = append(challengeResults["extracted_data"], {
            "packet": challengeResults["packets_analyzed"],
            "data": data,
            "hex": packetHex,
            "text": packetStr,
        })
    }
}

// 熵计算函数
calculateEntropy = func(data) {
    if len(data) == 0 {
        return 0.0
    }

    freq := {}
    for i in data {
        freq[i] = (freq[i] || 0) + 1
    }

    entropy := 0.0
    dataLen := float64(len(data))

    for _, count in freq {
        p := float64(count) / dataLen
        if p > 0 {
            entropy -= p * log2(p)
        }
    }

    return entropy
}

log2 = func(x) {
    return log(x) / log(2.0)
}

// 设置PCAP分析选项
options := []

// 添加数据包处理函数
options = append(options, pcapx.pcap_everyPacket(analyzeChallengePacket))

// 执行PCAP文件分析
yakit.Info("Opening challenge PCAP file and starting analysis...")
err := pcapx.OpenPcapFile(pcapFile, options...)
if err != nil {
    yakit.Error("Failed to analyze PCAP file: %v", err)
    return
}

// 输出分析结果
yakit.Info("=== Challenge PCAP Analysis Results ===")
yakit.Info("Packets analyzed: %v", challengeResults["packets_analyzed"])
yakit.Info("Flags found: %v", len(challengeResults["flags_found"]))
yakit.Info("Network tools detected: %v", len(challengeResults["network_tools"]))
yakit.Info("Hidden channels found: %v", len(challengeResults["hidden_channels"]))
yakit.Info("Decoded content: %v", len(challengeResults["decoded_content"]))
yakit.Info("Suspicious traffic: %v", len(challengeResults["suspicious_traffic"]))
yakit.Info("Extracted data packets: %v", len(challengeResults["extracted_data"]))

// 详细输出flag
if len(challengeResults["flags_found"]) > 0 {
    yakit.Info("=== FLAGS FOUND ===")
    for flag in challengeResults["flags_found"] {
        yakit.Info("🚩 %v (packet %v)", flag["flag"], flag["packet"])
        if flag["encoding"] != nil {
            yakit.Info("   Encoding: %v", flag["encoding"])
        }
    }
}

// 总结
if len(challengeResults["flags_found"]) > 0 {
    yakit.Info("🎉 Analysis completed! Found %v potential flags.", len(challengeResults["flags_found"]))
} else {
    yakit.Info("🤔 Analysis completed. No obvious flags found, but check the extracted data for hidden information.")
}

yakit.Info("Challenge PCAP analysis completed successfully!")
