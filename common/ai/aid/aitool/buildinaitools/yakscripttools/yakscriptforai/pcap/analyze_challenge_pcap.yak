__DESC__ = "ä¸“é—¨ç”¨äºŽåˆ†æžchall.pcapngç­‰ç½‘ç»œå®‰å…¨æŒ‘æˆ˜PCAPæ–‡ä»¶çš„å·¥å…·ï¼Œæ”¯æŒè§£å¯†éšè”½é€šä¿¡ã€æå–flagã€è¯†åˆ«ç½‘ç»œå·¥å…·è¡Œä¸ºã€‚"
__VERBOSE_NAME__ = "æŒ‘æˆ˜PCAPåˆ†æžå·¥å…·"
__KEYWORDS__ = "challenge,ctf,ç½‘ç»œå®‰å…¨æŒ‘æˆ˜,éšè”½é€šä¿¡,flagæå–,ç½‘ç»œå·¥å…·åˆ†æž,æµé‡è§£å¯†,æ¶æ„è¡Œä¸ºæ£€æµ‹"

/*
æŒ‘æˆ˜PCAPåˆ†æžå·¥å…·

åŠŸèƒ½ç‰¹ç‚¹ï¼š
1. ä¸“é—¨é’ˆå¯¹CTFå’Œç½‘ç»œå®‰å…¨æŒ‘æˆ˜çš„PCAPåˆ†æž
   - è¯†åˆ«éšè”½é€šä¿¡é€šé“
   - æå–éšè—çš„flagå’Œæ•æ„Ÿä¿¡æ¯
   - åˆ†æžç½‘ç»œå·¥å…·çš„ä½¿ç”¨ç—•è¿¹
   - è§£å¯†åŠ å¯†é€šä¿¡å†…å®¹

2. é«˜çº§åˆ†æžåŠŸèƒ½ï¼š
   - DNSéš§é“æ£€æµ‹å’Œè§£å¯†
   - HTTPå¤´ä¿¡æ¯åˆ†æž
   - TCPæµé‡ç»„å’Œpayloadæå–
   - åè®®é€†å‘åˆ†æž
   - ç¼–ç å†…å®¹è‡ªåŠ¨è¯†åˆ«å’Œè§£ç 

3. flagæå–ï¼š
   - è‡ªåŠ¨è¯†åˆ«flagæ ¼å¼
   - æå–base64/hexç¼–ç çš„flag
   - ä»Žç½‘ç»œæµé‡ä¸­æå–éšè—ä¿¡æ¯
   - æ”¯æŒå¤šç§flagæ ¼å¼è¯†åˆ«

4. å‚æ•°è¯´æ˜Žï¼š
   --file: PCAPæ–‡ä»¶è·¯å¾„ (å¿…éœ€)
   --extract-flags: è‡ªåŠ¨æå–flag (å¯é€‰ï¼Œé»˜è®¤true)
   --decode-all: å°è¯•è§£ç æ‰€æœ‰å¯ç–‘å†…å®¹ (å¯é€‰ï¼Œé»˜è®¤true)
   --verbose: è¯¦ç»†è¾“å‡ºæ¨¡å¼ (å¯é€‰ï¼Œé»˜è®¤false)

ä½¿ç”¨ç¤ºä¾‹ï¼š
1. åˆ†æžæŒ‘æˆ˜PCAPæ–‡ä»¶ï¼š
   yak analyze_challenge_pcap.yak --file chall.pcapng

2. è¯¦ç»†åˆ†æžæ¨¡å¼ï¼š
   yak analyze_challenge_pcap.yak --file chall.pcapng --verbose

3. ç¦ç”¨è‡ªåŠ¨flagæå–ï¼š
   yak analyze_challenge_pcap.yak --file chall.pcapng --extract-flags false

æ³¨æ„äº‹é¡¹ï¼š
- ä¸“é—¨ä¸ºç½‘ç»œå®‰å…¨æŒ‘æˆ˜å’ŒCTFè®¾è®¡
- æ”¯æŒå¤šç§éšè”½é€šä¿¡æ–¹å¼çš„æ£€æµ‹
- è‡ªåŠ¨ä¿å­˜å‘çŽ°çš„flagå’Œæ•æ„Ÿä¿¡æ¯
- è¯¦ç»†åˆ†æžå¯èƒ½éœ€è¦è¾ƒé•¿æ—¶é—´
- è¾“å‡ºåŒ…å«flagæå–ç»“æžœå’Œé€šä¿¡åˆ†æž
*/

yakit.AutoInitYakit()

// è§£æžå‘½ä»¤è¡Œå‚æ•°
pcapFile := cli.String("file", cli.setRequired(true), cli.setHelp("challenge PCAP file to analyze"))
extractFlags := cli.Bool("extract-flags", cli.setDefault(true), cli.setHelp("automatically extract flags"))
decodeAll := cli.Bool("decode-all", cli.setDefault(true), cli.setHelp("attempt to decode all suspicious content"))
verbose := cli.Bool("verbose", cli.setHelp("verbose output mode"))

cli.check()

yakit.Info("Starting challenge PCAP analysis for file: %v", pcapFile)

// æ£€æŸ¥æ–‡ä»¶æ˜¯å¦å­˜åœ¨
if !file.IsExisted(pcapFile) {
    yakit.Error("PCAP file does not exist: %v", pcapFile)
    return
}

// åˆå§‹åŒ–åˆ†æžç»“æžœ
challengeResults := {
    "packets_analyzed": 0,
    "flags_found": [],
    "suspicious_traffic": [],
    "decoded_content": [],
    "network_tools": [],
    "hidden_channels": [],
    "extracted_data": [],
}

// flagæ¨¡å¼è¯†åˆ«
flagPatterns := [
    "flag\\{[^{}]*\\}",
    "CTF\\{[^{}]*\\}",
    "[Ff][Ll][Aa][Gg]\\{[^{}]*\\}",
    "([a-zA-Z0-9]{8}-[a-zA-Z0-9]{4}-[a-zA-Z0-9]{4}-[a-zA-Z0-9]{4}-[a-zA-Z0-9]{12})", // UUIDæ ¼å¼
    "([a-zA-Z0-9+/=]{20,})", // base64-like strings
    "0x[0-9a-fA-F]{8,}", // hex values
]

// ç½‘ç»œå·¥å…·ç‰¹å¾
networkTools := [
    "nmap", "masscan", "zmap", "dirb", "gobuster", "ffuf",
    "sqlmap", "burp", "wireshark", "tcpdump", "ettercap",
    "metasploit", "cobalt", "empire", "covenant", "sliver",
    "nc ", "netcat", "ncat", "socat", "ssh", "scp", "rsync",
    "wget", "curl", "python", "perl", "ruby", "php",
    "bash", "sh", "powershell", "cmd.exe",
]

// éšè”½é€šé“æ£€æµ‹
hiddenChannels := [
    "TXT", "NULL", "CNAME", "MX", "SRV", // DNSéš§é“
    "CONNECT", "Proxy-Authorization", // HTTPéš§é“
    "tor", "i2p", "freenet", // åŒ¿åç½‘ç»œ
    "VPN", "SSH", "SSL", // åŠ å¯†éš§é“
]

// é«˜çº§æ•°æ®åŒ…åˆ†æžå‡½æ•°
analyzeChallengePacket = func(packet) {
    challengeResults["packets_analyzed"]++

    if packet == nil {
        return
    }

    data := packet.Data()
    if data == nil || len(data) == 0 {
        return
    }

    packetStr := string(data)
    packetHex := codec.EncodeToHex(data)

    if verbose {
        yakit.Info("Analyzing packet %v (%v bytes)", challengeResults["packets_analyzed"], len(data))
    }

    suspicious := false

    // 1. flagæå–
    if extractFlags {
        for pattern in flagPatterns {
            matches := regexp.FindAllStringSubmatch(packetStr, pattern)
            if matches != nil {
                for match in matches {
                    if len(match) > 1 {
                        flag := match[1]
                        challengeResults["flags_found"] = append(challengeResults["flags_found"], {
                            "flag": flag,
                            "pattern": pattern,
                            "packet": challengeResults["packets_analyzed"],
                            "context": packetStr,
                        })
                        yakit.Info("ðŸš© FLAG FOUND: %v", flag)
                        suspicious = true
                    }
                }
            }
        }

        // æ£€æµ‹å¯èƒ½çš„ç¼–ç flag
        if len(data) > 10 {
            // å°è¯•base64è§£ç 
            decoded, err := codec.DecodeBase64(string(data))
            if err == nil {
                decodedStr := string(decoded)
                for pattern in flagPatterns {
                    matches := regexp.FindAllStringSubmatch(decodedStr, pattern)
                    if matches != nil {
                        for match in matches {
                            if len(match) > 1 {
                                challengeResults["flags_found"] = append(challengeResults["flags_found"], {
                                    "flag": match[1],
                                    "encoding": "base64",
                                    "packet": challengeResults["packets_analyzed"],
                                    "context": decodedStr,
                                })
                                yakit.Info("ðŸš© FLAG FOUND (base64 decoded): %v", match[1])
                                suspicious = true
                            }
                        }
                    }
                }
            }

            // å°è¯•hexè§£ç 
            hexDecoded, err := codec.DecodeHex(string(data))
            if err == nil {
                hexStr := string(hexDecoded)
                for pattern in flagPatterns {
                    matches := regexp.FindAllStringSubmatch(hexStr, pattern)
                    if matches != nil {
                        for match in matches {
                            if len(match) > 1 {
                                challengeResults["flags_found"] = append(challengeResults["flags_found"], {
                                    "flag": match[1],
                                    "encoding": "hex",
                                    "packet": challengeResults["packets_analyzed"],
                                    "context": hexStr,
                                })
                                yakit.Info("ðŸš© FLAG FOUND (hex decoded): %v", match[1])
                                suspicious = true
                            }
                        }
                    }
                }
            }
        }
    }

    // 2. ç½‘ç»œå·¥å…·æ£€æµ‹
    for tool in networkTools {
        if packetStr.Contains(tool) {
            challengeResults["network_tools"] = append(challengeResults["network_tools"], {
                "tool": tool,
                "packet": challengeResults["packets_analyzed"],
                "context": packetStr,
            })
            yakit.Info("ðŸ”§ Network tool detected: %v", tool)
            suspicious = true
        }
    }

    // 3. éšè”½é€šé“æ£€æµ‹
    for channel in hiddenChannels {
        if packetStr.Contains(channel) {
            challengeResults["hidden_channels"] = append(challengeResults["hidden_channels"], {
                "channel_type": channel,
                "packet": challengeResults["packets_analyzed"],
                "context": packetStr,
            })
            yakit.Info("ðŸšª Hidden channel detected: %v", channel)
            suspicious = true
        }
    }

    // 4. é€šç”¨è§£ç å°è¯•
    if decodeAll && len(data) > 4 {
        // æ£€æµ‹å¹¶è§£ç base64å†…å®¹
        base64Decoded, err := codec.DecodeBase64(string(data))
        if err == nil && len(base64Decoded) > 0 {
            decodedStr := string(base64Decoded)
            if len(decodedStr) != len(string(data)) { // ç¡®ä¿æ˜¯æœ‰æ•ˆçš„è§£ç 
                challengeResults["decoded_content"] = append(challengeResults["decoded_content"], {
                    "encoding": "base64",
                    "original": string(data),
                    "decoded": decodedStr,
                    "packet": challengeResults["packets_analyzed"],
                })
                if verbose {
                    yakit.Info("ðŸ“„ Base64 decoded: %v", decodedStr[:min(100, len(decodedStr))])
                }
                suspicious = true
            }
        }

        // æ£€æµ‹é«˜ç†µæ•°æ®ï¼ˆå¯èƒ½æ˜¯åŠ å¯†çš„ï¼‰
        entropy := calculateEntropy(data)
        if entropy > 7.8 {
            challengeResults["suspicious_traffic"] = append(challengeResults["suspicious_traffic"], {
                "type": "high_entropy",
                "entropy": entropy,
                "packet": challengeResults["packets_analyzed"],
                "size": len(data),
            })
            yakit.Info("ðŸ” High entropy traffic detected (entropy: %.2f)", entropy)
            suspicious = true
        }
    }

    // 5. æå–å¯ç–‘æ•°æ®
    if suspicious {
        challengeResults["extracted_data"] = append(challengeResults["extracted_data"], {
            "packet": challengeResults["packets_analyzed"],
            "data": data,
            "hex": packetHex,
            "text": packetStr,
        })
    }
}

// ç†µè®¡ç®—å‡½æ•°
calculateEntropy = func(data) {
    if len(data) == 0 {
        return 0.0
    }

    freq := {}
    for i in data {
        freq[i] = (freq[i] || 0) + 1
    }

    entropy := 0.0
    dataLen := float64(len(data))

    for _, count in freq {
        p := float64(count) / dataLen
        if p > 0 {
            entropy -= p * log2(p)
        }
    }

    return entropy
}

log2 = func(x) {
    return log(x) / log(2.0)
}

// è®¾ç½®PCAPåˆ†æžé€‰é¡¹
options := []

// æ·»åŠ æ•°æ®åŒ…å¤„ç†å‡½æ•°
options = append(options, pcapx.pcap_everyPacket(analyzeChallengePacket))

// æ‰§è¡ŒPCAPæ–‡ä»¶åˆ†æž
yakit.Info("Opening challenge PCAP file and starting analysis...")
err := pcapx.OpenPcapFile(pcapFile, options...)
if err != nil {
    yakit.Error("Failed to analyze PCAP file: %v", err)
    return
}

// è¾“å‡ºåˆ†æžç»“æžœ
yakit.Info("=== Challenge PCAP Analysis Results ===")
yakit.Info("Packets analyzed: %v", challengeResults["packets_analyzed"])
yakit.Info("Flags found: %v", len(challengeResults["flags_found"]))
yakit.Info("Network tools detected: %v", len(challengeResults["network_tools"]))
yakit.Info("Hidden channels found: %v", len(challengeResults["hidden_channels"]))
yakit.Info("Decoded content: %v", len(challengeResults["decoded_content"]))
yakit.Info("Suspicious traffic: %v", len(challengeResults["suspicious_traffic"]))
yakit.Info("Extracted data packets: %v", len(challengeResults["extracted_data"]))

// è¯¦ç»†è¾“å‡ºflag
if len(challengeResults["flags_found"]) > 0 {
    yakit.Info("=== FLAGS FOUND ===")
    for flag in challengeResults["flags_found"] {
        yakit.Info("ðŸš© %v (packet %v)", flag["flag"], flag["packet"])
        if flag["encoding"] != nil {
            yakit.Info("   Encoding: %v", flag["encoding"])
        }
    }
}

// æ€»ç»“
if len(challengeResults["flags_found"]) > 0 {
    yakit.Info("ðŸŽ‰ Analysis completed! Found %v potential flags.", len(challengeResults["flags_found"]))
} else {
    yakit.Info("ðŸ¤” Analysis completed. No obvious flags found, but check the extracted data for hidden information.")
}

yakit.Info("Challenge PCAP analysis completed successfully!")
