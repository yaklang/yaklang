__DESC__ = "ä¸“é—¨ç”¨äºŽåˆ†æžchall.pcapngç­‰ç½‘ç»œå®‰å…¨æŒ‘æˆ˜PCAPæ–‡ä»¶çš„å·¥å…·ï¼Œæ”¯æŒè§£å¯†éšè”½é€šä¿¡ã€æå–flagã€è¯†åˆ«ç½‘ç»œå·¥å…·è¡Œä¸ºã€‚"
__VERBOSE_NAME__ = "æŒ‘æˆ˜PCAPåˆ†æžå·¥å…·"
__KEYWORDS__ = "challenge,ctf,ç½‘ç»œå®‰å…¨æŒ‘æˆ˜,éšè”½é€šä¿¡,flagæå–,ç½‘ç»œå·¥å…·åˆ†æž,æµé‡è§£å¯†,æ¶æ„è¡Œä¸ºæ£€æµ‹"

/*
æŒ‘æˆ˜PCAPåˆ†æžå·¥å…·

åŠŸèƒ½ç‰¹ç‚¹ï¼š
1. ä¸“é—¨é’ˆå¯¹CTFå’Œç½‘ç»œå®‰å…¨æŒ‘æˆ˜çš„PCAPåˆ†æž
   - è¯†åˆ«éšè”½é€šä¿¡é€šé“
   - æå–éšè—çš„flagå’Œæ•æ„Ÿä¿¡æ¯
   - åˆ†æžç½‘ç»œå·¥å…·çš„ä½¿ç”¨ç—•è¿¹
   - è§£å¯†åŠ å¯†é€šä¿¡å†…å®¹

2. é«˜çº§åˆ†æžåŠŸèƒ½ï¼š
   - DNSéš§é“æ£€æµ‹å’Œè§£å¯†
   - HTTPå¤´ä¿¡æ¯åˆ†æž
   - TCPæµé‡ç»„å’Œpayloadæå–
   - åè®®é€†å‘åˆ†æž
   - ç¼–ç å†…å®¹è‡ªåŠ¨è¯†åˆ«å’Œè§£ç 

3. flagæå–ï¼š
   - è‡ªåŠ¨è¯†åˆ«flagæ ¼å¼
   - æå–base64/hexç¼–ç çš„flag
   - ä»Žç½‘ç»œæµé‡ä¸­æå–éšè—ä¿¡æ¯
   - æ”¯æŒå¤šç§flagæ ¼å¼è¯†åˆ«

4. å‚æ•°è¯´æ˜Žï¼š
   --file: PCAPæ–‡ä»¶è·¯å¾„ (å¿…éœ€)
   --extract-flags: è‡ªåŠ¨æå–flag (å¯é€‰ï¼Œé»˜è®¤trueï¼Œå¯é€‰å€¼: true/false)
   --decode-all: å°è¯•è§£ç æ‰€æœ‰å¯ç–‘å†…å®¹ (å¯é€‰ï¼Œé»˜è®¤trueï¼Œå¯é€‰å€¼: true/false)
   --verbose: è¯¦ç»†è¾“å‡ºæ¨¡å¼ (å¯é€‰ï¼Œé»˜è®¤falseï¼Œå¯é€‰å€¼: true/false)
   --enable-reassembly: å¯ç”¨TCPæ•°æ®æµé‡ç»„ (å¯é€‰ï¼Œé»˜è®¤trueï¼Œå¯é€‰å€¼: true/false)
   --max-packets: æœ€å¤§å¤„ç†æ•°æ®åŒ…æ•°é‡ï¼Œé»˜è®¤100000 (å¯é€‰)

ä½¿ç”¨ç¤ºä¾‹ï¼š
1. åˆ†æžæŒ‘æˆ˜PCAPæ–‡ä»¶ï¼š
   yak analyze_challenge_pcap.yak --file chall.pcapng

2. è¯¦ç»†åˆ†æžæ¨¡å¼ï¼š
   yak analyze_challenge_pcap.yak --file chall.pcapng --verbose

3. ç¦ç”¨è‡ªåŠ¨flagæå–ï¼š
   yak analyze_challenge_pcap.yak --file chall.pcapng --extract-flags false

æ³¨æ„äº‹é¡¹ï¼š
- ä¸“é—¨ä¸ºç½‘ç»œå®‰å…¨æŒ‘æˆ˜å’ŒCTFè®¾è®¡
- æ”¯æŒå¤šç§éšè”½é€šä¿¡æ–¹å¼çš„æ£€æµ‹
- è‡ªåŠ¨ä¿å­˜å‘çŽ°çš„flagå’Œæ•æ„Ÿä¿¡æ¯
- è¯¦ç»†åˆ†æžå¯èƒ½éœ€è¦è¾ƒé•¿æ—¶é—´
- è¾“å‡ºåŒ…å«flagæå–ç»“æžœå’Œé€šä¿¡åˆ†æž
*/

yakit.AutoInitYakit()

// è§£æžå‘½ä»¤è¡Œå‚æ•°
pcapFile := cli.String("file", cli.setRequired(true), cli.setHelp("challenge PCAP file to analyze"))
extractFlagsStr := cli.String("extract-flags", cli.setDefault("true"), cli.setHelp("automatically extract flags (default: true)"))
decodeAllStr := cli.String("decode-all", cli.setDefault("true"), cli.setHelp("attempt to decode all suspicious content (default: true)"))
verboseStr := cli.String("verbose", cli.setDefault("false"), cli.setHelp("verbose output mode (default: false)"))
enableReassemblyStr := cli.String("enable-reassembly", cli.setDefault("true"), cli.setHelp("enable TCP stream reassembly (default: true)"))
maxPackets := cli.Int("max-packets", cli.setDefault(100000), cli.setHelp("maximum packets to analyze (default: 100000)"))

cli.check()

// è§£æžå¸ƒå°”å€¼å‚æ•°
extractFlags := parseBool(extractFlagsStr)
decodeAll := parseBool(decodeAllStr)
verbose := parseBool(verboseStr)
enableReassembly := parseBool(enableReassemblyStr)

yakit.Info("Starting challenge PCAP analysis for file: %v", pcapFile)
yakit.Info("Configuration: extract-flags=%v, decode-all=%v, verbose=%v, reassembly=%v", extractFlags, decodeAll, verbose, enableReassembly)

// æ£€æŸ¥æ–‡ä»¶æ˜¯å¦å­˜åœ¨
if !file.IsExisted(pcapFile) {
    yakit.Error("PCAP file does not exist: %v", pcapFile)
    return
}

// åˆ›å»ºä¸´æ—¶è¾“å‡ºæ–‡ä»¶
tempFile := sprintf("/tmp/challenge_pcap_analysis_%v.txt", time.Now().Unix())
detailedOutputParts := []

// åˆå§‹åŒ–åˆ†æžç»“æžœ
challengeResults := {
    "packets_analyzed": 0,
    "flags_found": [],
    "suspicious_traffic": [],
    "decoded_content": [],
    "network_tools": [],
    "hidden_channels": [],
    "extracted_data": [],
}

// è¿›åº¦æ‰“å°æŽ§åˆ¶å˜é‡
lastProgressTime := time.Now()
progressInterval := 5.0 // æ¯5ç§’æ‰“å°ä¸€æ¬¡è¿›åº¦
processingStopped := false

// flagæ¨¡å¼è¯†åˆ«
flagPatterns := [
    "flag\\{[^{}]*\\}",
    "CTF\\{[^{}]*\\}",
    "[Ff][Ll][Aa][Gg]\\{[^{}]*\\}",
    "([a-zA-Z0-9]{8}-[a-zA-Z0-9]{4}-[a-zA-Z0-9]{4}-[a-zA-Z0-9]{4}-[a-zA-Z0-9]{12})", // UUIDæ ¼å¼
    "([a-zA-Z0-9+/=]{20,})", // base64-like strings
    "0x[0-9a-fA-F]{8,}", // hex values
]

// ç½‘ç»œå·¥å…·ç‰¹å¾
networkTools := [
    "nmap", "masscan", "zmap", "dirb", "gobuster", "ffuf",
    "sqlmap", "burp", "wireshark", "tcpdump", "ettercap",
    "metasploit", "cobalt", "empire", "covenant", "sliver",
    "nc ", "netcat", "ncat", "socat", "ssh", "scp", "rsync",
    "wget", "curl", "python", "perl", "ruby", "php",
    "bash", "sh", "powershell", "cmd.exe",
]

// éšè”½é€šé“æ£€æµ‹
hiddenChannels := [
    "TXT", "NULL", "CNAME", "MX", "SRV", // DNSéš§é“
    "CONNECT", "Proxy-Authorization", // HTTPéš§é“
    "tor", "i2p", "freenet", // åŒ¿åç½‘ç»œ
    "VPN", "SSH", "SSL", // åŠ å¯†éš§é“
]

// é«˜çº§æ•°æ®åŒ…åˆ†æžå‡½æ•°
analyzeChallengePacket = func(packet) {
    if processingStopped {
        return
    }

    challengeResults["packets_analyzed"]++

    if challengeResults["packets_analyzed"] > maxPackets {
        yakit.Warn("Reached maximum packet limit (%v), stopping analysis. Total packets processed: %v", maxPackets, challengeResults["packets_analyzed"])
        detailedOutputParts = append(detailedOutputParts, sprintf("Reached maximum packet limit (%v), stopping analysis\n", maxPackets))
        processingStopped = true
        return
    }

    // å®šæœŸæ‰“å°è¿›åº¦ï¼ˆæ¯5ç§’ä¸€æ¬¡ï¼‰
    elapsed := time.Since(lastProgressTime).Seconds()
    if elapsed >= progressInterval {
        yakit.Info("Progress: %v packets processed, %v flags found", challengeResults["packets_analyzed"], len(challengeResults["flags_found"]))
        lastProgressTime = time.Now()
    }

    if packet == nil {
        return
    }

    data := packet.Data()
    if data == nil || len(data) == 0 {
        return
    }

    packetStr := string(data)
    packetHex := codec.EncodeToHex(data)

    // è®°å½•è¯¦ç»†çš„æ•°æ®åŒ…ä¿¡æ¯
    detailedOutputParts = append(detailedOutputParts, sprintf("=== Packet %v ===\n", challengeResults["packets_analyzed"]))
    detailedOutputParts = append(detailedOutputParts, sprintf("Data size: %v bytes\n", len(data)))

    if packet != nil {
        packetInfo := packet.String()
        detailedOutputParts = append(detailedOutputParts, sprintf("Packet info: %v\n", packetInfo))
    }

    if verbose {
        yakit.Info("Analyzing packet %v (%v bytes)", challengeResults["packets_analyzed"], len(data))
    }

    suspicious := false

    // 1. flagæå–ï¼ˆç®€åŒ–çš„å­—ç¬¦ä¸²åŒ¹é…ï¼‰
    if extractFlags {
        // ç›´æŽ¥æ£€æµ‹å¸¸è§çš„flagæ ¼å¼
        flagPrefixes := ["flag{", "CTF{", "FLAG{", "Flag{"]
        for prefix in flagPrefixes {
            if packetStr.Contains(prefix) {
                // æ‰¾åˆ°flagå¼€å§‹ä½ç½®
                startIdx := packetStr.Index(prefix)
                if startIdx >= 0 {
                    // æŸ¥æ‰¾å¯¹åº”çš„ç»“æŸæ‹¬å·
                    remaining := packetStr[startIdx:]
                    endIdx := remaining.Index("}")
                    if endIdx > 0 {
                        flag := remaining[:endIdx+1]
                        challengeResults["flags_found"] = append(challengeResults["flags_found"], {
                            "flag": flag,
                            "pattern": "string_match",
                            "packet": challengeResults["packets_analyzed"],
                            "context": packetStr,
                        })
                        yakit.Info("ðŸš© FLAG FOUND: %v", flag)
                        suspicious = true
                    }
                }
            }
        }

        // æ£€æµ‹å¯èƒ½çš„ç¼–ç flag
        if len(data) > 10 {
            // å°è¯•base64è§£ç 
            decoded, err := codec.DecodeBase64(string(data))
            if err == nil {
                decodedStr := string(decoded)
                for prefix in flagPrefixes {
                    if decodedStr.Contains(prefix) {
                        startIdx := decodedStr.Index(prefix)
                        if startIdx >= 0 {
                            remaining := decodedStr[startIdx:]
                            endIdx := remaining.Index("}")
                            if endIdx > 0 {
                                flag := remaining[:endIdx+1]
                                challengeResults["flags_found"] = append(challengeResults["flags_found"], {
                                    "flag": flag,
                                    "encoding": "base64",
                                    "packet": challengeResults["packets_analyzed"],
                                    "context": decodedStr,
                                })
                                yakit.Info("ðŸš© FLAG FOUND (base64 decoded): %v", flag)
                                suspicious = true
                            }
                        }
                    }
                }
            }

            // å°è¯•hexè§£ç ï¼ˆç®€åŒ–ç‰ˆï¼Œé¿å…ç±»åž‹è½¬æ¢é”™è¯¯ï¼‰
            // hexDecoded, err := codec.DecodeHex(string(data))
            // if err == nil {
            //     hexStr := string(hexDecoded)
            //     for prefix in flagPrefixes {
            //         if hexStr.Contains(prefix) {
            //             startIdx := hexStr.Index(prefix)
            //             if startIdx >= 0 {
            //                 remaining := hexStr[startIdx:]
            //                 endIdx := remaining.Index("}")
            //                 if endIdx > 0 {
            //                     flag := remaining[:endIdx+1]
            //                     challengeResults["flags_found"] = append(challengeResults["flags_found"], {
            //                         "flag": flag,
            //                         "encoding": "hex",
            //                         "packet": challengeResults["packets_analyzed"],
            //                         "context": hexStr,
            //                     })
            //                     yakit.Info("ðŸš© FLAG FOUND (hex decoded): %v", flag)
            //                     suspicious = true
            //                 }
            //             }
            //         }
            //     }
            // }
        }
    }

    // 2. ç½‘ç»œå·¥å…·æ£€æµ‹
    for tool in networkTools {
        if packetStr.Contains(tool) {
            challengeResults["network_tools"] = append(challengeResults["network_tools"], {
                "tool": tool,
                "packet": challengeResults["packets_analyzed"],
                "context": packetStr,
            })
            suspicious = true
        }
    }

    // 3. éšè”½é€šé“æ£€æµ‹
    for channel in hiddenChannels {
        if packetStr.Contains(channel) {
            challengeResults["hidden_channels"] = append(challengeResults["hidden_channels"], {
                "channel_type": channel,
                "packet": challengeResults["packets_analyzed"],
                "context": packetStr,
            })
            suspicious = true
        }
    }

    // 4. é€šç”¨è§£ç å°è¯•
    if decodeAll && len(data) > 4 {
        // æ£€æµ‹å¹¶è§£ç base64å†…å®¹
        base64Decoded, err := codec.DecodeBase64(string(data))
        if err == nil && len(base64Decoded) > 0 {
            decodedStr := string(base64Decoded)
            if len(decodedStr) != len(string(data)) { // ç¡®ä¿æ˜¯æœ‰æ•ˆçš„è§£ç 
                challengeResults["decoded_content"] = append(challengeResults["decoded_content"], {
                    "encoding": "base64",
                    "original": string(data),
                    "decoded": decodedStr,
                    "packet": challengeResults["packets_analyzed"],
                })
                suspicious = true
            }
        }

        // æ£€æµ‹é«˜ç†µæ•°æ®ï¼ˆæš‚æ—¶ç¦ç”¨ï¼‰
        // entropy := calculateEntropy(data)
        // if entropy > 7.8 {
        //     challengeResults["suspicious_traffic"] = append(challengeResults["suspicious_traffic"], {
        //         "type": "high_entropy",
        //         "entropy": entropy,
        //         "packet": challengeResults["packets_analyzed"],
        //         "size": len(data),
        //     })
        //     yakit.Info("ðŸ” High entropy traffic detected (entropy: %.2f)", entropy)
        //     suspicious = true
        // }
    }

    // 5. æå–å¯ç–‘æ•°æ®
    if suspicious {
        challengeResults["extracted_data"] = append(challengeResults["extracted_data"], {
            "packet": challengeResults["packets_analyzed"],
            "data": data,
            "hex": packetHex,
            "text": packetStr,
        })
    }

    // æ€»æ˜¯æ·»åŠ æ•°æ®é¢„è§ˆï¼ˆä¸ç®¡æ˜¯å¦å¯ç–‘ï¼‰
    if len(packetStr) > 0 {
        if len(packetStr) <= 200 {
            detailedOutputParts = append(detailedOutputParts, sprintf("Text preview: %v\n", sdump(packetStr)))
        } else {
            detailedOutputParts = append(detailedOutputParts, sprintf("Data size: %v bytes, preview: %v...\n", len(packetStr), sdump(packetStr[:100])))
        }
    }
    detailedOutputParts = append(detailedOutputParts, sprintf("---\n\n"))
}

// ç®€åŒ–çš„ç†µè®¡ç®—å‡½æ•°ï¼ˆä½¿ç”¨å­—èŠ‚åˆ†å¸ƒï¼‰- ç®€åŒ–ç‰ˆé¿å…ç±»åž‹é—®é¢˜
calculateEntropy = func(data) {
    if len(data) < 10 {
        return 0.0
    }

    // ç®€å•çš„ç†µä¼°è®¡ï¼šè®¡ç®—å”¯ä¸€å­—èŠ‚æ•°ä¸Žæ€»å­—èŠ‚æ•°çš„æ¯”ä¾‹
    uniqueCount := 0
    seen := {}

    for i := 0; i < len(data); i++ {
        if seen[data[i]] == nil {
            seen[data[i]] = true
            uniqueCount++
        }
    }

    return float64(uniqueCount) / float64(len(data))
}

// TCPæ•°æ®é‡ç»„å›žè°ƒå‡½æ•°
onChallengeFlowDataFrameReassembled = func(flow, conn, frame) {
    if processingStopped {
        return
    }

    challengeResults["packets_analyzed"]++

    if frame == nil || frame.Payload == nil || len(frame.Payload) == 0 {
        return
    }

    frameData := frame.Payload
    frameStr := string(frameData)
    frameHex := codec.EncodeToHex(frameData)

    // è®°å½•è¯¦ç»†çš„TCPé‡ç»„ä¿¡æ¯
    detailedOutputParts = append(detailedOutputParts, sprintf("=== TCP Reassembled Frame ===\n"))
    detailedOutputParts = append(detailedOutputParts, sprintf("Flow: %v -> %v\n", flow.ClientConn, flow.ServerConn))
    detailedOutputParts = append(detailedOutputParts, sprintf("Frame size: %v bytes\n", len(frameData)))
    detailedOutputParts = append(detailedOutputParts, sprintf("Connection hash: %v\n", frame.ConnHash))

    // åˆ†æžé‡ç»„åŽçš„æ•°æ®å†…å®¹
    suspiciousContent := false
    suspiciousFindings := []

    // æ£€æŸ¥å‘½ä»¤æ³¨å…¥å’Œç½‘ç»œå·¥å…·ç‰¹å¾
    suspiciousPatterns := [
        "cmd.exe", "/bin/bash", "powershell", "wget", "curl",
        "nc ", "netcat", "ncat", "socat", "ssh ", "scp ",
        "system(", "exec(", "eval(", "popen(",
        "whoami", "hostname", "ipconfig", "ifconfig",
        "cat ", "ls ", "dir ", "type ", "copy ",
    ]

    for pattern in suspiciousPatterns {
        if frameStr.Contains(pattern) {
            suspiciousFindings = append(suspiciousFindings, sprintf("Suspicious pattern: %v", pattern))
            suspiciousContent = true
        }
    }

    // æ£€æŸ¥HTTPæµé‡
    if frameStr.Contains("HTTP/") || frameStr.Contains("GET ") || frameStr.Contains("POST ") {
        suspiciousFindings = append(suspiciousFindings, "HTTP traffic detected")
        suspiciousContent = true
    }

    // å°è¯•base64è§£ç 
    if decodeAll && len(frameData) > 10 {
        decoded, err := codec.DecodeBase64(string(frameData))
        if err == nil && len(decoded) > 0 {
            suspiciousFindings = append(suspiciousFindings, sprintf("Base64 decoded content: %v", string(decoded)))
            suspiciousContent = true
            challengeResults["decoded_content"] = append(challengeResults["decoded_content"], {
                "encoding": "base64",
                "original": string(frameData),
                "decoded": string(decoded),
                "packet": challengeResults["packets_analyzed"],
            })
        }
    }

    if suspiciousContent {
        detailedOutputParts = append(detailedOutputParts, "Suspicious content detected in reassembled frame:\n")

        for finding in suspiciousFindings {
            detailedOutputParts = append(detailedOutputParts, sprintf("  - %v\n", finding))
        }
    }

    // æ•°æ®é¢„è§ˆ
    if len(frameStr) > 0 {
        if len(frameStr) <= 200 {
            detailedOutputParts = append(detailedOutputParts, sprintf("Frame data: %v\n", sdump(frameStr)))
        } else {
            detailedOutputParts = append(detailedOutputParts, sprintf("Frame data preview: %v...\n", sdump(frameStr[:100])))
        }
    }

    detailedOutputParts = append(detailedOutputParts, sprintf("Frame hex: %v\n", frameHex[:min(200, len(frameHex))]))
    detailedOutputParts = append(detailedOutputParts, "\n")
}

// è®¾ç½®PCAPåˆ†æžé€‰é¡¹
options := []

// æ ¹æ®å‚æ•°å†³å®šæ˜¯å¦å¯ç”¨æ•°æ®é‡ç»„
if enableReassembly {
    options = append(options, pcapx.pcap_onFlowDataFrame(onChallengeFlowDataFrameReassembled))
}

// æ·»åŠ æ•°æ®åŒ…å¤„ç†å‡½æ•°
options = append(options, pcapx.pcap_everyPacket(analyzeChallengePacket))

// æ‰§è¡ŒPCAPæ–‡ä»¶åˆ†æž
err := pcapx.OpenPcapFile(pcapFile, options...)
if err != nil {
    yakit.Error("Failed to analyze PCAP file: %v", err)
    return
}

// ä¿å­˜è¯¦ç»†ç»“æžœåˆ°æ–‡ä»¶
if len(detailedOutputParts) > 0 {
    outputContent := str.Join(detailedOutputParts, "")
    err := file.Save(tempFile, outputContent)
    if err != nil {
        yakit.Warn("Failed to save detailed results to file: %v", err)
    } else {
        yakit.Info("Detailed challenge analysis saved to: %v", tempFile)
    }
}

// è¾“å‡ºåˆ†æžç»“æžœ
yakit.Info("=== Challenge PCAP Analysis Results ===")
yakit.Info("Packets analyzed: %v", challengeResults["packets_analyzed"])
yakit.Info("Flags found: %v", len(challengeResults["flags_found"]))
yakit.Info("Network tools detected: %v", len(challengeResults["network_tools"]))
yakit.Info("Hidden channels found: %v", len(challengeResults["hidden_channels"]))
yakit.Info("Decoded content: %v", len(challengeResults["decoded_content"]))
yakit.Info("Suspicious traffic: %v", len(challengeResults["suspicious_traffic"]))
yakit.Info("Extracted data packets: %v", len(challengeResults["extracted_data"]))

// è¯¦ç»†è¾“å‡ºflag
if len(challengeResults["flags_found"]) > 0 {
    yakit.Info("=== FLAGS FOUND ===")
    for flag in challengeResults["flags_found"] {
        yakit.Info("ðŸš© %v (packet %v)", flag["flag"], flag["packet"])
        if flag["encoding"] != nil {
            yakit.Info("   Encoding: %v", flag["encoding"])
        }
    }
}

// æ€»ç»“
if len(challengeResults["flags_found"]) > 0 {
    yakit.Info("ðŸŽ‰ Analysis completed! Found %v potential flags.", len(challengeResults["flags_found"]))
} else {
    yakit.Info("ðŸ¤” Analysis completed. No obvious flags found, but check the extracted data for hidden information.")
}

yakit.Info("Challenge PCAP analysis completed successfully!")
