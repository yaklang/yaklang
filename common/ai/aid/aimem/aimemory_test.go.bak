package aimem

import (
	"context"
	"fmt"
	"testing"

	"github.com/stretchr/testify/assert"
	"github.com/yaklang/yaklang/common/ai/aid/aicommon"
	"github.com/yaklang/yaklang/common/ai/aid/aitool"
	"github.com/yaklang/yaklang/common/consts"
	"github.com/yaklang/yaklang/common/log"
	"github.com/yaklang/yaklang/common/schema"
	"github.com/yaklang/yaklang/common/utils"
)

// MockInvoker 实现 AIInvokeRuntime 接口用于测试
type MockInvoker struct {
	ctx context.Context
}

func NewMockInvoker(ctx context.Context) *MockInvoker {
	return &MockInvoker{ctx: ctx}
}

func (m *MockInvoker) GetBasicPromptInfo(tools []*aitool.Tool) (string, map[string]any, error) {
	return "Mock Basic Prompt Template: {{ .Query }}", map[string]any{
		"Query": "test query",
	}, nil
}

func (m *MockInvoker) InvokeLiteForge(ctx context.Context, actionName string, prompt string, outputs []aitool.ToolOption) (*aicommon.Action, error) {
	log.Infof("mock InvokeLiteForge called with action: %s", actionName)

	if actionName == "memory-triage" {
		// 构造mock的返回数据
		mockResponseJSON := `{
			"@action": "memory-triage",
			"memory_entities": [
				{
					"content": "用户在实现一个复杂的AI记忆系统，使用C.O.R.E. P.A.C.T.框架进行记忆评分",
					"tags": ["AI开发", "记忆系统", "C.O.R.E. P.A.C.T."],
					"potential_questions": [
						"如何实现AI记忆系统？",
						"什么是C.O.R.E. P.A.C.T.框架？",
						"如何评估记忆的重要性？"
					],
					"t": 0.8,
					"a": 0.7,
					"p": 0.9,
					"o": 0.85,
					"e": 0.6,
					"r": 0.75,
					"c": 0.65
				},
				{
					"content": "系统需要支持语义搜索、按分数搜索和按标签搜索功能",
					"tags": ["搜索功能", "AI开发"],
					"potential_questions": [
						"如何实现语义搜索？",
						"什么是按分数搜索？",
						"如何按标签过滤记忆？"
					],
					"t": 0.7,
					"a": 0.8,
					"p": 0.6,
					"o": 0.9,
					"e": 0.5,
					"r": 0.8,
					"c": 0.7
				}
			]
		}`

		// 使用ExtractAction从JSON字符串创建Action
		action, err := aicommon.ExtractAction(mockResponseJSON, "memory-triage")
		if err != nil {
			return nil, utils.Errorf("failed to extract action: %v", err)
		}
		return action, nil
	}

	return nil, utils.Errorf("unexpected action: %s", actionName)
}

func (m *MockInvoker) ExecuteToolRequiredAndCall(name string) (*aitool.ToolResult, bool, error) {
	return nil, false, nil
}

func (m *MockInvoker) AskForClarification(question string, payloads []string) string {
	return ""
}

func (m *MockInvoker) DirectlyAnswer(query string, tools []*aitool.Tool) (string, error) {
	return "", nil
}

func (m *MockInvoker) EnhanceKnowledgeAnswer(ctx context.Context, s string) (string, error) {
	return "", nil
}

func (m *MockInvoker) VerifyUserSatisfaction(query string, isToolCall bool, payload string) (bool, error) {
	return true, nil
}

func (m *MockInvoker) RequireAIForgeAndAsyncExecute(ctx context.Context, forgeName string, onFinish func(error)) {
}

func (m *MockInvoker) AsyncPlanAndExecute(ctx context.Context, planPayload string, onFinish func(error)) {
}

func (m *MockInvoker) AddToTimeline(entry, content string) {
}

func (m *MockInvoker) GetConfig() aicommon.AICallerConfigIf {
	return nil
}

func (m *MockInvoker) EmitFileArtifactWithExt(name, ext string, data any) string {
	return ""
}

func (m *MockInvoker) EmitResultAfterStream(any) {
}

func (m *MockInvoker) EmitResult(any) {
}

func init() {
	// 启用mock模式
	IsMockMode = true
}

// 测试创建AIMemory
func TestNewAIMemory(t *testing.T) {
	ctx := context.Background()
	sessionID := "test-session-001"

	// 先清理可能存在的旧数据
	cleanupTestData(t, sessionID)

	mem, err := NewAIMemory(sessionID,
		WithInvoker(NewMockInvoker(ctx)),
		WithContextProvider(func() (string, error) {
			return "测试背景：用户正在开发AI记忆系统", nil
		}),
	)

	// 确保最后清理
	defer cleanupTestData(t, sessionID)

	assert.NoError(t, err)
	assert.NotNil(t, mem)
	if mem != nil {
		defer mem.Close()
	}

	log.Infof("successfully created AI memory for session: %s", sessionID)
}

// 测试添加原始文本并生成记忆条目
func TestAddRawText(t *testing.T) {
	ctx := context.Background()
	sessionID := "test-session-002"

	// 先清理可能存在的旧数据
	cleanupTestData(t, sessionID)
	defer cleanupTestData(t, sessionID)

	mem, err := NewAIMemory(sessionID,
		WithInvoker(NewMockInvoker(ctx)),
		WithContextProvider(func() (string, error) {
			return "已有标签：AI开发、记忆系统、搜索功能", nil
		}),
	)
	assert.NoError(t, err)
	assert.NotNil(t, mem)
	defer mem.Close()

	// 添加原始文本
	rawText := "用户正在实现一个AI记忆系统，需要支持C.O.R.E. P.A.C.T.框架的七个维度评分，并且要实现语义搜索功能。"
	entities, err := mem.AddRawText(rawText)

	assert.NoError(t, err)
	assert.NotEmpty(t, entities)

	log.Infof("generated %d memory entities", len(entities))
	for i, entity := range entities {
		log.Infof("entity %d: %s", i, entity.Content)
		log.Infof("  tags: %v", entity.Tags)
		log.Infof("  scores: C=%.2f, O=%.2f, R=%.2f, E=%.2f, P=%.2f, A=%.2f, T=%.2f",
			entity.C_Score, entity.O_Score, entity.R_Score, entity.E_Score,
			entity.P_Score, entity.A_Score, entity.T_Score)

		assert.NotEmpty(t, entity.Id)
		assert.NotEmpty(t, entity.Content)
		assert.NotEmpty(t, entity.Tags)
		assert.NotEmpty(t, entity.PotentialQuestions)
		assert.Len(t, entity.CorePactVector, 7)
	}
}

// 测试保存记忆条目并验证数据库
func TestSaveMemoryEntitiesAndVerifyDB(t *testing.T) {
	ctx := context.Background()
	sessionID := "test-session-003"

	// 清理测试数据
	defer cleanupTestData(t, sessionID)

	mem, err := NewAIMemory(sessionID,
		WithInvoker(NewMockInvoker(ctx)),
	)
	assert.NoError(t, err)
	assert.NotNil(t, mem)
	defer mem.Close()

	// 添加并保存记忆条目
	rawText := "测试保存功能：用户需要实现语义搜索和按标签搜索"
	entities, err := mem.AddRawText(rawText)
	assert.NoError(t, err)
	assert.NotEmpty(t, entities)

	// 保存到数据库
	err = mem.SaveMemoryEntities(sessionID, entities...)
	assert.NoError(t, err)

	log.Infof("successfully saved %d memory entities", len(entities))

	// 验证数据库中的数据
	db := consts.GetGormProjectDatabase()
	var count int64
	err = db.Model(&schema.AIMemoryEntity{}).Where("session_id = ?", sessionID).Count(&count).Error
	assert.NoError(t, err)
	assert.Equal(t, int64(len(entities)), count)

	// 验证每个条目的详细数据
	var dbEntities []schema.AIMemoryEntity
	err = db.Where("session_id = ?", sessionID).Find(&dbEntities).Error
	assert.NoError(t, err)
	assert.Len(t, dbEntities, len(entities))

	for i, dbEntity := range dbEntities {
		log.Infof("verified entity %d in database: %s", i, dbEntity.MemoryID)
		assert.NotEmpty(t, dbEntity.Content)
		assert.NotEmpty(t, dbEntity.Tags)
		assert.NotEmpty(t, dbEntity.PotentialQuestions)
		assert.Len(t, dbEntity.CorePactVector, 7)
	}

	log.Infof("verified %d entities in database with complete data", count)
}

// 测试RAG索引验证
func TestRAGIndexingVerification(t *testing.T) {
	ctx := context.Background()
	sessionID := "test-session-004-rag"

	// 清理测试数据
	defer cleanupTestData(t, sessionID)

	mem, err := NewAIMemory(sessionID,
		WithInvoker(NewMockInvoker(ctx)),
	)
	assert.NoError(t, err)
	assert.NotNil(t, mem)
	defer mem.Close()

	// 添加并保存记忆条目
	rawText := "用户正在开发AI记忆系统，使用RAG技术实现语义搜索功能"
	entities, err := mem.AddRawText(rawText)
	assert.NoError(t, err)

	err = mem.SaveMemoryEntities(sessionID, entities...)
	assert.NoError(t, err)

	// 验证RAG文档数量
	docCount, err := mem.rag.CountDocuments()
	assert.NoError(t, err)

	totalQuestions := 0
	for _, entity := range entities {
		totalQuestions += len(entity.PotentialQuestions)
	}

	log.Infof("RAG document count: %d, expected questions: %d", docCount, totalQuestions)
	assert.Equal(t, totalQuestions, docCount, "RAG文档数量应该等于所有潜在问题的数量")

	// 验证可以通过RAG检索到文档
	docs, err := mem.rag.ListDocuments()
	assert.NoError(t, err)
	assert.Len(t, docs, totalQuestions)

	for i, doc := range docs {
		log.Infof("RAG document %d: ID=%s, content=%s", i, doc.ID, utils.ShrinkString(doc.Content, 50))
		assert.NotEmpty(t, doc.ID)
		assert.NotEmpty(t, doc.Content)
		assert.NotEmpty(t, doc.Metadata["memory_id"])
		assert.NotEmpty(t, doc.Metadata["question"])
		assert.Equal(t, sessionID, doc.Metadata["session_id"])
	}
}

// 测试语义搜索
func TestSearchBySemantics(t *testing.T) {
	ctx := context.Background()
	sessionID := "test-session-005"

	// 清理测试数据
	defer cleanupTestData(t, sessionID)

	mem, err := NewAIMemory(sessionID,
		WithInvoker(NewMockInvoker(ctx)),
	)
	assert.NoError(t, err)
	assert.NotNil(t, mem)
	defer mem.Close()

	// 添加并保存记忆条目
	rawText := "用户正在开发AI记忆系统，使用RAG技术实现语义搜索功能"
	entities, err := mem.AddRawText(rawText)
	assert.NoError(t, err)

	err = mem.SaveMemoryEntities(sessionID, entities...)
	assert.NoError(t, err)

	// 执行语义搜索
	results, err := mem.SearchBySemantics(sessionID, "如何实现语义搜索？", 10)
	assert.NoError(t, err)

	log.Infof("semantic search returned %d results", len(results))
	for i, result := range results {
		log.Infof("result %d (score: %.4f): %s", i, result.Score, utils.ShrinkString(result.Entity.Content, 50))
		assert.NotNil(t, result.Entity)
		assert.GreaterOrEqual(t, result.Score, 0.0)
	}
}

// 测试按分数向量搜索
func TestSearchByScoreVector(t *testing.T) {
	ctx := context.Background()
	sessionID := "test-session-006-vector"

	// 清理测试数据
	defer cleanupTestData(t, sessionID)

	mem, err := NewAIMemory(sessionID,
		WithInvoker(NewMockInvoker(ctx)),
	)
	assert.NoError(t, err)
	assert.NotNil(t, mem)
	defer mem.Close()

	// 添加并保存多个记忆条目
	rawText := "用户正在开发AI记忆系统"
	entities, err := mem.AddRawText(rawText)
	assert.NoError(t, err)

	err = mem.SaveMemoryEntities(sessionID, entities...)
	assert.NoError(t, err)

	// 构建目标分数向量（寻找相似评分的记忆）
	targetScores := &MemoryEntity{
		C_Score: 0.7,
		O_Score: 0.85,
		R_Score: 0.75,
		E_Score: 0.6,
		P_Score: 0.9,
		A_Score: 0.75,
		T_Score: 0.8,
	}

	// 执行向量相似度搜索
	results, err := mem.SearchByScoreVector(sessionID, targetScores, 10)
	assert.NoError(t, err)

	log.Infof("score vector search returned %d results", len(results))
	for i, result := range results {
		log.Infof("result %d (similarity: %.4f):", i, result.Score)
		log.Infof("  content: %s", utils.ShrinkString(result.Entity.Content, 50))
		log.Infof("  scores: C=%.2f, O=%.2f, R=%.2f, E=%.2f, P=%.2f, A=%.2f, T=%.2f",
			result.Entity.C_Score, result.Entity.O_Score, result.Entity.R_Score,
			result.Entity.E_Score, result.Entity.P_Score, result.Entity.A_Score,
			result.Entity.T_Score)
		assert.GreaterOrEqual(t, result.Score, 0.0)
		assert.LessOrEqual(t, result.Score, 1.0)
	}
}

// 测试按分数范围搜索
func TestSearchByScores(t *testing.T) {
	ctx := context.Background()
	sessionID := "test-session-007"

	// 清理测试数据
	defer cleanupTestData(t, sessionID)

	mem, err := NewAIMemory(sessionID,
		WithInvoker(NewMockInvoker(ctx)),
	)
	assert.NoError(t, err)
	assert.NotNil(t, mem)
	defer mem.Close()

	// 添加并保存记忆条目
	rawText := "测试分数搜索：实现高相关性和高可操作性的记忆条目"
	entities, err := mem.AddRawText(rawText)
	assert.NoError(t, err)

	err = mem.SaveMemoryEntities(sessionID, entities...)
	assert.NoError(t, err)

	// 搜索高相关性的记忆
	filter := &ScoreFilter{
		R_Min: 0.7,
		R_Max: 1.0,
	}
	results, err := mem.SearchByScores(sessionID, filter, 10)
	assert.NoError(t, err)

	log.Infof("score search returned %d results", len(results))
	for i, result := range results {
		log.Infof("result %d: R=%.2f, content: %s", i, result.R_Score, utils.ShrinkString(result.Content, 50))
		assert.GreaterOrEqual(t, result.R_Score, 0.7)
	}
}

// 测试按标签搜索
func TestSearchByTags(t *testing.T) {
	ctx := context.Background()
	sessionID := "test-session-008"

	// 清理测试数据
	defer cleanupTestData(t, sessionID)

	mem, err := NewAIMemory(sessionID,
		WithInvoker(NewMockInvoker(ctx)),
	)
	assert.NoError(t, err)
	assert.NotNil(t, mem)
	defer mem.Close()

	// 添加并保存记忆条目
	rawText := "用户在开发AI系统，需要实现记忆管理和搜索功能"
	entities, err := mem.AddRawText(rawText)
	assert.NoError(t, err)

	err = mem.SaveMemoryEntities(sessionID, entities...)
	assert.NoError(t, err)

	// 按标签搜索
	results, err := mem.SearchByTags(sessionID, []string{"AI开发"}, false, 10)
	assert.NoError(t, err)

	log.Infof("tag search returned %d results", len(results))
	for i, result := range results {
		log.Infof("result %d: tags=%v, content: %s", i, result.Tags, utils.ShrinkString(result.Content, 50))
		// 验证至少包含一个搜索的标签
		hasTag := false
		for _, tag := range result.Tags {
			if tag == "AI开发" {
				hasTag = true
				break
			}
		}
		assert.True(t, hasTag, "结果应该包含搜索的标签")
	}
}

// 测试获取所有标签
func TestGetAllTags(t *testing.T) {
	ctx := context.Background()
	sessionID := "test-session-009"

	// 清理测试数据
	defer cleanupTestData(t, sessionID)

	mem, err := NewAIMemory(sessionID,
		WithInvoker(NewMockInvoker(ctx)),
	)
	assert.NoError(t, err)
	assert.NotNil(t, mem)
	defer mem.Close()

	// 添加并保存记忆条目
	rawText := "测试标签功能：AI开发、记忆系统、搜索功能"
	entities, err := mem.AddRawText(rawText)
	assert.NoError(t, err)

	err = mem.SaveMemoryEntities(sessionID, entities...)
	assert.NoError(t, err)

	// 获取所有标签
	tags, err := mem.GetAllTags(sessionID)
	assert.NoError(t, err)
	assert.NotEmpty(t, tags)

	log.Infof("found %d unique tags: %v", len(tags), tags)
}

// 测试获取动态上下文
func TestGetDynamicContextWithTags(t *testing.T) {
	ctx := context.Background()
	sessionID := "test-session-010"

	// 清理测试数据
	defer cleanupTestData(t, sessionID)

	mem, err := NewAIMemory(sessionID,
		WithInvoker(NewMockInvoker(ctx)),
	)
	assert.NoError(t, err)
	assert.NotNil(t, mem)
	defer mem.Close()

	// 添加并保存记忆条目
	rawText := "用户正在开发AI记忆系统"
	entities, err := mem.AddRawText(rawText)
	assert.NoError(t, err)

	err = mem.SaveMemoryEntities(sessionID, entities...)
	assert.NoError(t, err)

	// 获取动态上下文
	context, err := mem.GetDynamicContextWithTags(sessionID)
	assert.NoError(t, err)
	assert.NotEmpty(t, context)

	log.Infof("dynamic context:\n%s", context)
	assert.Contains(t, context, "已存储的记忆领域标签")
}

// 清理测试数据
func cleanupTestData(t *testing.T, sessionID string) {
	db := consts.GetGormProjectDatabase()
	if db == nil {
		return
	}

	// 删除测试数据
	err := db.Where("session_id = ?", sessionID).Delete(&schema.AIMemoryEntity{}).Error
	if err != nil {
		log.Warnf("cleanup test data failed: %v", err)
	}

	// 清理RAG collection和相关文档
	collectionName := fmt.Sprintf("ai-memory-%s", sessionID)

	// 删除collection关联的documents
	var collection schema.VectorStoreCollection
	if err := db.Where("name = ?", collectionName).First(&collection).Error; err == nil {
		db.Where("collection_id = ?", collection.ID).Delete(&schema.VectorStoreDocument{})
		db.Delete(&collection)
	}

	log.Infof("cleaned up test data for session: %s", sessionID)
}
