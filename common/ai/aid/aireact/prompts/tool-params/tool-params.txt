# Tool Parameter Generation
{{ if .DynamicContext }}{{ .DynamicContext }} {{end}}
You need to generate parameters for the tool '{{ .ToolName }}'.

Tool Description: {{ .ToolDescription }}
{{ if .ToolUsage }}
## Tool Usage Guide
{{ .ToolUsage }}
{{ end }}
{{ if .ToolSchema }}Tool Schema:
```json
{{ .ToolSchema }}
```
{{ end }}

{{ if .OriginalQuery }}# Original User Query
User's original request: {{ .OriginalQuery }}
{{ end }}

{{ if .CumulativeSummary }}# Task Context & Memory
Overall task context: {{ .CumulativeSummary }}
{{ end }}

# Task Progress
Current iteration: {{ .CurrentIteration }}/{{ .MaxIterations }}
This tool call is part of a multi-step ReAct process. Consider how this tool execution contributes to completing the overall user task.

{{ if .Timeline }}# Recent Timeline
{{ .Timeline }}
{{ end }}

# Instructions
Generate appropriate parameters for this tool call based on the context above.

IMPORTANT CONSIDERATIONS:
- Consider the original user query and overall task context when generating parameters
- This tool execution should contribute to completing the user's original request
- The cumulative summary contains the evolving context - use this to understand what has been accomplished so far
- After this tool execution, the ReAct loop will determine if the task is complete or if further actions are needed
- Generate parameters that will produce meaningful results toward task completion

## ⚠️ SHELL COMMAND SECURITY RULES (bash/cmd/powershell)
If generating parameters for shell execution tools (bash, cmd, powershell), you MUST follow these rules:

**FORBIDDEN OPERATIONS:**
- ❌ `find /` or `find / -xxx` - Never scan from root directory
- ❌ `ls -R /` - Never recursive list from root
- ❌ Accessing `/etc/shadow`, `/etc/sudoers`, `/root/.ssh/*`
- ❌ `sudo xxx`, `su xxx` - No privilege escalation attempts
- ❌ `chmod 777`, `chown root` - No dangerous permission changes
- ❌ `rm -rf /`, `dd if=/dev/zero` - No destructive operations

**SAFE ALTERNATIVES:**
- ✅ System info: `uname -a`, `hostnamectl`, `cat /etc/os-release`
- ✅ Disk space: `df -h` (user-readable partitions only)
- ✅ Processes: `ps aux`, `top -l 1` (macOS), `top -bn1` (Linux)
- ✅ Network: `netstat -tuln`, `lsof -i:PORT` (specific port)
- ✅ File search: `find /home/user -name xxx -maxdepth 3` (specific dir + depth limit)
- ✅ OS type: `uname -s`, `cat /etc/os-release`, or use the `ostype` tool

**COMMAND GENERATION PRINCIPLES:**
1. Always specify exact directories instead of `/`
2. Add `-maxdepth` when using `find`
3. Avoid commands that require root permission
4. Consider the current user's permission level
5. Use specific, targeted commands rather than broad scans

## RESPONSE FORMAT

You can generate parameters in TWO ways:

### Method 1: Standard JSON Format (for simple parameters)
For simple string/number/boolean parameters that don't contain special characters or multi-line content:

RESPONSE FORMAT: Respond with a JSON object following the @action pattern(Example):

```json
{
  "@action": "call-tool",
  "tool": "toolname_yet",
  "identifier": "short_intent_description",
  "params": {
    "param1": "value1",
    "param2": "value2"
  }
}
```

**IMPORTANT: The `identifier` field is REQUIRED**
- The `identifier` should be a short, lowercase, underscore-separated string that describes the PURPOSE/INTENT of this tool call
- Examples: `query_large_file`, `find_process`, `list_directory`, `search_log_error`, `check_disk_usage`
- Format: use lowercase letters and underscores only (snake_case), keep it under 30 characters
- This identifier will be used in file paths to help users quickly understand what this tool call is doing

For your current tool '{{ .ToolName }}':

```json
{
  "@action": "call-tool",
  "tool": "{{ .ToolName }}",
  "identifier": "your_intent_here",
  "params": {
    "param1": "simple_value",
    "param2": 123
  }
}
```

### Method 2: AITAG Format (for complex parameters with multi-line content or special characters)
For parameters that contain:
- Multi-line text (code, scripts, long content)
- Special characters that need escaping in JSON (\n, \t, ", \, etc.)
- Large text blocks

Use AITAG format to wrap the content safely:

```json
{
  "@action": "call-tool",
  "tool": "{{ .ToolName }}",
  "identifier": "your_intent_here",
  "params": {
    "simple_param": "value"
  }
}
```

<|TOOL_PARAM_complex_param_{{ .Nonce }}|>
Your multi-line content here.
Can include special characters: "quotes", \backslashes\, 
newlines, tabs, and any other content without escaping.
<|TOOL_PARAM_complex_param_END_{{ .Nonce }}|>

### Hybrid Mode (Recommended for mixed parameters)
You can combine both methods - use JSON for simple parameters and AITAG for complex ones:

```json
{
  "@action": "call-tool",
  "tool": "{{ .ToolName }}",
  "identifier": "run_bash_script",
  "params": {
    "timeout": 30,
    "verbose": true
  }
}
```

<|TOOL_PARAM_script_{{ .Nonce }}|>
#!/bin/bash
echo "Hello World"
for i in {1..10}; do
    echo "Line $i"
done
<|TOOL_PARAM_script_END_{{ .Nonce }}|>

<|TOOL_PARAM_config_{{ .Nonce }}|>
{
  "nested": "json",
  "with": ["arrays", "and", "special chars: \"quotes\""]
}
<|TOOL_PARAM_config_END_{{ .Nonce }}|>

### AITAG Format Rules:
- Start tag: `<|TOOL_PARAM_{param_name}_{{ .Nonce }}|>`
- End tag: `<|TOOL_PARAM_{param_name}_END_{{ .Nonce }}|>`
- Replace `{param_name}` with the actual parameter name
- Content between tags is used as-is without any escaping
- AITAG parameters will override any same-named parameters in the JSON `params` object
{{ if .ParamNames }}
### Available Parameters for this tool:
{{- range .ParamNames }}
- {{ . }}: Use `<|TOOL_PARAM_{{ . }}_{{ $.Nonce }}|>...<|TOOL_PARAM_{{ . }}_END_{{ $.Nonce }}|>` for complex content
{{- end }}
{{ end }}
