// 仅支持插件仓库子页面下调用
// mitm劫持下验证码可能会被后端刷新，动态爬虫无法输入符合格式的验证码，且可能爬虫会刷新验证码

// verification_code_list=cli.LineDict("verification_code_list", cli.setDefault(""),cli.setRequired(true),cli.setVerboseName("验证码参数"),cli.setHelp("会检测请求报文中是否含有验证码参数，字符串包含匹配"))
verification_code=cli.String("verification_code", cli.setDefault("code"),cli.setRequired(true),cli.setVerboseName("验证码参数"),cli.setHelp("会检测请求包中是否含有验证码参数，严格匹配"))
brute_mode=cli.StringSlice("brute_mode", cli.setMultipleSelect(false),cli.setSelectOption("四位数爆破", "1"),cli.setSelectOption("六位数万能验证码", "2" /*type: string*/),cli.setSelectOption("六位数爆破", "3" /*type: string*/),cli.setDefault("1"),cli.setVerboseName("爆破模式"),cli.setRequired(true))
// thread_number=cli.Int("thread_number", cli.setDefault(10),cli.setVerboseName("爆破线程数"),cli.setCliGroup("插件额外参数"))
// fuzz_tag 自动多线程

success_list=cli.LineDict("success_list",cli.setDefault("phone\naccount\nsuccess\n成功\ntoken\ney\ntrue"),cli.setCliGroup("插件额外参数"),cli.setVerboseName("成功标识字典") )

//开始替换内容标志recognition_patten
//待替换内容，勿动！
recognition_patten=cli.StringSlice("recognition_patten", cli.setVerboseName("识别模式"),cli.setMultipleSelect(false),cli.setSelectOption("字典模式", "1"),cli.setSelectOption("机器学习模式", "2"),cli.setSelectOption("字典模式优先-机器学习辅助", "3"),cli.setSelectOption("字典模式-机器学习并行", "4"),cli.setSelectOption("机器学习优先-字典模式辅助", "5"),cli.setDefault("1"),cli.setHelp("检测识别模式"),cli.setCliGroup("插件额外参数"))
//结束替换内容标志recognition_patten

//开始替换内容标志task_type
//待替换内容，勿动！
task_type=cli.StringSlice("task_type", cli.setVerboseName("任务类型"),cli.setMultipleSelect(false),cli.setSelectOption("即时", "即时"),cli.setDefault("即时"),cli.setHelp("任务类型，mitm都为即时任务"),cli.setCliGroup("插件额外参数"))
//结束替换内容标志task_type


// 定义全局变量
recognition_patten_dic={
    "1":"字典模式",
    "2":"机器学习模式",
    "3":"字典模式优先-机器学习辅助",
    "4":"字典模式-机器学习并行",
    "5":"机器学习优先-字典模式辅助",
}
cli.check()


// 验证码不正确的正则
verification_code_fail_list=[
    `(验证码(.*?)(错误|有误|失效|无效|不正确))|((错误|有误|失效|无效|不正确)的验证码)`,
    `(?i)(captcha (incorrect|error|invalid))|((incorrect|error|invalid) captcha)`
]
detect_output_dic={}
risk_output_dic={}
flow_total=-1
bad_end_str_list=[
".jpg", ".png", ".gif", ".css", ".js", ".pdf", ".mp3", ".mp4", ".avi", ".map", ".svg", ".ico", ".woff", ".woff2", ".ttf"
]
brute_mode_and_code_len_dic={
    "1":[4,"四位数爆破"],
    "2":[6,"六位数万能验证码"],
    "3":[6,"六位数爆破"]
}

four_digit_number_fuzz_tag="{{int(0000-9999)}}"
//test_tag four_digit_number_fuzz_tag="{{int(1050-1100)}}"
six_digit_number_fuzz_tag1="{{int(0,00000,000000,111111,222222,333333,444444,555555,666666,777777,888888,999999,123456,123123,666888)}}"
six_digit_number_fuzz_tag2="{{int(000000-999999)}}"
solution="验证码爆破漏洞是指恶意用户或攻击者利用自动化工具尝试大量猜测或暴力破解验证码，以绕过身份验证机制并获取未经授权的访问或权限。攻击者通常会使用大量可能的验证码组合，不断尝试直到找到有效的验证码，从而成功绕过验证码验证步骤。"
description="以下是一些防止验证码爆破漏洞的常见解决方案：\n1.验证码有效性限制：限制验证码的有效性时间和尝试次数，确保验证码在一定时间内只能尝试一定次数，超过次数或时间后验证码失效。\n2.增加复杂度：使用更复杂的验证码，如多位数字和字母的组合，增加破解难度。可以考虑使用动态变化的验证码，提高安全性。\n3.实施验证码延迟：在每次尝试后增加验证码验证的延迟时间，防止攻击者快速尝试大量验证码。\n4.监控异常行为：实时监控验证码验证请求，检测异常行为，如频繁尝试不同验证码、来自同一 IP 的大量请求等，及时采取防御措施。\n5.多因素身份验证：结合其他安全措施，如短信验证码和密码双重验证，提高身份验证的安全性，减少验证码爆破的风险。"


brute_mode=brute_mode[0]
wg=sync.NewSizedWaitGroup(10)




// 定义用于打印的 base_info 变量
base_info_script_name="验证码爆破"
base_info_task_creater=""
base_info_task_type=task_type[0]
base_info_detect_mode="mitm"
base_info_task_mode=recognition_patten_dic[recognition_patten[0]]
base_info_login=""
base_info_crediential=""
base_info_user_define_header=""
base_info_start_time=time.Now().String()
base_info_end_time=""


// 定义打印函数
base_info_output=func(){
    yakit_output(f"加载插件结束。配置的基本信息如下：任务名称为'${base_info_script_name}'、任务创建人为'${base_info_task_creater}'、任务类型为'${base_info_task_type}任务'、检测模式为'${base_info_detect_mode}模式'、任务模式为'${base_info_task_mode}'、登录入口信息为'${base_info_login}'、凭证信息为'${base_info_crediential}'、自定义请求头信息为'${base_info_user_define_header}'、任务开始时间为 ${base_info_start_time}、结束时间为${base_info_end_time}。")
}
base_info_output()



mitm_risk_output=func(url,req,rsp,vul_type,vul_name,vul_severity,param,payload,payload_success_flag,pocname){

    if task_type[0]=="即时" || task_type[0]=="定时" {
        // 验证码爆破，只需对url进行去重
        header_md5_check,body_md5_check=poc.Split(req)
        body_md5_check=""
        url_body_hash=codec.Md5(url+string(body_md5_check))
        if url_body_hash in risk_output_dic{
            //该条流已经告警输出，不再进行告警
            return
        }else{
            risk_output_dic[url_body_hash]=1
        }

        //记录到检测去重字典中,借助库函数，拼接root_url和path
        detect_root_url=str.ParseStringUrlToWebsiteRootPath(url)
        detect_url_Instance,err=str.ParseStringUrlToUrlInstance(url)
        if err!=nil{
            die(err)
        }
        detect_path=detect_url_Instance.Path
        detect_url_path_hash=codec.Md5(detect_root_url+detect_path)
        if detect_url_path_hash in detect_output_dic{
            //该条流已经检测，后续 mirrorFilteredHTTPFlow 不再进行检测
        }else{
            //记录到检测去重字典中
            detect_output_dic[detect_url_path_hash]=1
        }
    }
    risk.NewRisk(
        url,
        risk.title(f"发现 ${url} 中存在 ${vul_name} 漏洞"),
        risk.type(vul_type),
        risk.severity(vul_severity),
        risk.request(string(req)),
        risk.response(string(rsp)),
        risk.parameter(param),
        risk.payload(payload),
        risk.description(description),
        risk.solution(solution),
        risk.details({
            "location":url,
            "pocname":pocname,
            "payload_success_flag":payload_success_flag,
            "recognition_patten":recognition_patten_dic[recognition_patten[0]]
        })
        )
}




result_check=func(result,param){
    wg.Add()
    go fn{
        defer wg.Done()
        if !str.MatchAnyOfSubString(result.ResponseRaw,verification_code_fail_list...) && str.MatchAnyOfSubString(result.ResponseRaw,success_list...) {
            mitm_risk_output(result.Url,result.RequestRaw,result.ResponseRaw,"逻辑漏洞","验证码爆破","middle",param,"","","mitm_verification_code_brute_check")
        }
    }
}






pre_check=func(req,rsp){
    http_req = poc.ParseBytesToHTTPRequest(req)~

    if http_req.Method!="GET" && http_req.Method!="POST" {
        return false
    }

    if str.MatchAnyOfSubString(http_req.URL.Path, bad_end_str_list...) {
        return false
    }

    http_rsp=poc.ParseBytesToHTTPResponse(rsp)~

    if str.MatchAnyOfRegexp(http_rsp.StatusCode, ["40\\d","50\\d"]...){
        return false
    }

    // http_rsp_header,http_rsp_body=poc.Split(rsp)
    // // 启用非json形式的检查
    // if not_json_check{
    //     return true
    // }

    // http_rsp_json_body=json.loads(string(http_rsp_body))
    // if http_rsp_json_body == {} {
    //     return false
    // }

    return true
}



mirrorFilteredHTTPFlow = func(isHttps /*bool*/, url /*string*/, req /*[]byte*/, rsp /*[]byte*/, body /*[]byte*/) {

    // 手动对爬虫预检测流量进行过滤，yakit加载mitm插件时，建议注释，动态爬虫形式调用无需注释（当爬虫启用crawlerx.check()需要注释）
    // if flow_total==-1{
    //     flow_total=flow_total+1
    //     return
    // }

    detect_root_url=str.ParseStringUrlToWebsiteRootPath(url)
    detect_url_Instance,err=str.ParseStringUrlToUrlInstance(url)
    if err!=nil{
        yakit_output("url 解析错误，脚本即将退出")
        die(err)
    }
    detect_path=detect_url_Instance.Path
    detect_url_path_hash=codec.Md5(detect_root_url+detect_path)
    if task_type[0]=="即时" || task_type[0]=="定时"{
        if detect_url_path_hash in detect_output_dic{
            //该条流已经检测并告警，不再进行检测
            yakit_output("detect_output_dic 去重")
            return
        }
        // 计算url和string后的body md5进行去重
        // 验证码爆破 只用url去重
        header_md5_check,body_md5_check=poc.Split(req)
        body_md5_check=""
        url_body_hash=codec.Md5(url+string(body_md5_check))
        if url_body_hash in risk_output_dic{
            //该条流已经告警输出，不再进行检测
            yakit_output("risk_output_dic 去重")
            return
        }
    }

    if !pre_check(req, rsp){
        return
    }

    // 取得验证码参数 ，分析位数，进行爆破
    // 当启用6位数全部爆破时候，爆破00000-999999
    // 根据检测成功标识字典进行告警

    freq=fuzz.HTTPRequest(req, fuzz.https(isHttps))~
    // 判断是否为输入含有验证码的报文
    params,verification_code_param,result=freq.GetCommonParams(),nil,nil
    for param in params{
        // get/post 参数中含有纯数字验证码，且位数符合输入的爆破模式
        if !param.Position().StartsWith("cookie") && param.Name()==verification_code && len(param.GetFirstValue())==brute_mode_and_code_len_dic[brute_mode][0]  && param.GetFirstValue().IsDigit(){
            verification_code_param=param
            break
        }
    }

    if verification_code_param==nil{
        yakit_output(f"在 ${url} 中未检测到合法验证码参数 ,插件即将退出")
        return
    }

    // 根据不同爆破模式 进行爆破
    switch brute_mode {
        case "1":
            yakit_output(f"开始 ${brute_mode_and_code_len_dic[brute_mode][1]} 爆破")
            result=verification_code_param.fuzz(four_digit_number_fuzz_tag).Exec()~
        case "2":
            yakit_output(f"开始 ${brute_mode_and_code_len_dic[brute_mode][1]} 爆破")
            result=verification_code_param.fuzz(six_digit_number_fuzz_tag1).Exec()~
        case "3":
            yakit_output(f"开始 ${brute_mode_and_code_len_dic[brute_mode][1]} 爆破")
            result=verification_code_param.fuzz(six_digit_number_fuzz_tag2).Exec()~
        default:
            yakit_output("爆破失败")
            return
    }
    for sub_res in result{
        result_check(sub_res,verification_code_param.Name())
    }

    wg.Wait()
    yakit_output(f"完成对 ${url} 的验证码爆破")

}