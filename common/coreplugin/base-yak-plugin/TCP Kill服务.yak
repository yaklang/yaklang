yakit.AutoInitYakit()

target := cli.String("target", cli.setRequired(true),cli.setVerboseName("Kill目标"),cli.setHelp("需要kill的tcp连接的目标的IP或者域名,支持逗号分隔与CIDR"))
killDurationSecond := cli.Int("duration", cli.setVerboseName("持续时间"),cli.setHelp("Kill TCP 服务的监控持续时间(单位 秒)"),cli.setDefault(3))

cli.check()
t := time.ParseDuration(sprintf("%ds", killDurationSecond))~
parseTarget := func(t) {
    allTarget := str.ParseStringToHosts(t)
    ipV4Ip := []
    otherTarget := []

    yakit.StatusCard("执行状态", "解析目标列表")
    for i in allTarget {
        if str.IsIPv4(i) {
            ipV4Ip = append(ipV4Ip, i)
        }else {
            otherTarget = append(otherTarget, i)
        }
    }

    lock := sync.NewLock()
    addIp := func(i) {
        lock.Lock()
        defer lock.Unlock()
        ipV4Ip = append(ipV4Ip, i)
    }

    yakit.StatusCard("执行状态", sprintf("解析域名[%d]个", len(otherTarget)))
    wg := sync.NewSizedWaitGroup(20)
    for i in otherTarget {
        wg.Add(1)
        go func(t) {
            defer wg.Done()
            lookipList :=os.LookupIP(i)
            for ip in lookipList {
                if str.IsIPv4(ip) {
                    addIp(ip)
                }
            }
        }(i)
    }
    wg.Wait()

    return ipV4Ip
}

ipArray := parseTarget(target)
yakit.Info("start kill tcp: duration [%s] | ip %v", t.String(),ipArray)
netstack.FastKillTCP(t, ipArray...)