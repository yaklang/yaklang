desc(
	title: "Audit C Format String Vulnerability"
	title_zh: "审计C语言中的格式化字符串漏洞"
	type: audit
	severity: high
	risk: ""
	desc: <<<DESC
### 漏洞描述

1. **漏洞原理**
   格式化字符串漏洞是由于程序在调用格式化输出函数（如`printf`、`fprintf`等）时，未正确指定格式化字符串而导致的安全问题。攻击者可以通过控制格式化字符串参数，读取栈内存内容或引发拒绝服务。
   - 攻击者能够利用格式化字符串中的特殊占位符（例如`%x`、`%s`、`%n`），获取敏感信息或篡改程序运行状态。
   - 使用`%n`会导致写入任意内存地址，可能被用来执行任意代码。

2. **触发场景**
   下面是一个存在漏洞的示例代码：
   ```c
   #include <stdio.h>
   #include <string.h>

   void vulnerable_function(char* user_input) {
       printf(user_input); // 直接将用户输入作为格式化字符串
       printf("\n");
   }

   int main(int argc, char** argv) {
       char buffer[1024];
       read(STDIN_FILENO, buffer, 0x400);
       vulnerable_function(buffer);
       return 0;
   }
   ```
   如果用户输入类似`%x%x%x`，则会泄露栈上的数据；如果输入包含`%n`，则可能导致非法内存写入。

3. **潜在影响**
   - 攻击者可以利用此漏洞读取敏感内存数据，包括但不限于密码、密钥或其他重要信息。
   - 在某些情况下，攻击者可以利用`%n`操作符覆盖关键内存区域，从而实现远程代码执行。
   - 对于嵌入式系统或关键基础设施，此类漏洞可能会造成灾难性后果。

DESC
	rule_id: "c79f91bf-773d-493a-ad14-e7d815e1bd32"
	solution: <<<SOLUTION
### 修复建议

#### 1. 明确指定格式化字符串
   开发者应始终为格式化输出函数提供固定的格式化字符串，避免直接使用用户输入作为格式化参数。
   ```c
   #include <stdio.h>
   #include <string.h>

   void safe_function(char* user_input) {
       printf("%s", user_input); // 使用固定格式化字符串
       printf("\n");
   }

   int main(int argc, char** argv) {
       char buffer[1024];
       read(STDIN_FILENO, buffer, 0x400);
       safe_function(buffer);
       return 0;
   }
   ```

#### 2. 输入验证与清理
   对用户输入进行严格检查和转义，确保其不包含任何格式化占位符。
   ```c
   int is_safe_input(const char* input) {
       while (*input) {
           if (*input == '%') return 0; // 检测是否含有'%'字符
           input++;
       }
       return 1;
   }

   void safer_function(char* user_input) {
       if (!is_safe_input(user_input)) {
           fprintf(stderr, "Invalid input detected!\n");
           return;
       }
       printf("%s", user_input);
       printf("\n");
   }
   ```

#### 3. 启用编译器防护选项
   现代编译器（如GCC、Clang）通常提供针对格式化字符串漏洞的警告和保护机制。启用这些选项有助于发现潜在问题。
   ```bash
   gcc -Wformat-security -Werror=format-security your_program.c -o your_program
   ```

SOLUTION
	reference: <<<REFERENCE
[CWE-134: Use of Externally-Controlled Format String](https://cwe.mitre.org/data/definitions/134.html)
[Format String Attack](https://owasp.org/www-community/attacks/Format_string_attack)
REFERENCE
)

printf(*<slice(index=0)> #-> as $sink);
fprintf(*<slice(index=0)> #-> as $sink);
sprintf(*<slice(index=0)> #-> as $sink);
snprintf(*<slice(index=0)> #-> as $sink);
syslog(*<slice(index=0)> #-> as $sink);
$sink?{!opcode:const} as $high

alert $high for {
	level: "high",
	type: "vuln",
	title: "C Format String Vulnerability Was Detected",
	title_zh: "检测到C语言格式化字符串漏洞",
	solution: <<<SOLUTION
### 修复建议
#### 1. 使用安全的格式化输出函数
通过指定格式化字符串常量避免直接传入用户输入。
```c
#include <stdio.h>
void safe_function(char* user_input) {
    printf("%s", user_input); // 使用固定格式化字符串
}
```
#### 2. 输入合法性校验
对用户输入实施严格校验，确保其不包含非法字符。
```c
#include <stdio.h>
#include <string.h>
void safe_function(char* user_input) {
    if (strchr(user_input, '%') != NULL) {
        fprintf(stderr, "非法输入: 包含格式化字符\n");
        return;
    }
    printf("%s", user_input);
}
```
#### 3. 使用更安全的语言/库
推荐使用具备更高安全性的语言（如Rust）或库，以规避此类问题。

SOLUTION
	risk: "格式化字符串漏洞",
	desc: <<<DESC
### 漏洞描述
1. **漏洞原理**
   格式化字符串漏洞是由于程序使用用户输入作为格式化字符串参数，而未对其进行验证或过滤。攻击者可以利用此漏洞读取内存、修改内存内容，甚至执行任意代码。
2. **触发场景**
   ```c
   #include <stdio.h>
   void vulnerable_function(char* user_input) {
       printf(user_input); // 直接将用户输入作为格式化字符串
   }
   int main(int argc, char** argv) {
       char buffer[1024];
       read(STDIN_FILENO, buffer, 0x400);
       vulnerable_function(buffer);
       return 0;
   }
   ```
   攻击者输入 `%x%x%x` 可能泄露栈中敏感信息；输入 `%n` 可能导致写入任意地址，从而劫持控制流。
3. **潜在影响**
   - 泄露敏感内存数据（如栈内容、返回地址等）。
   - 修改内存中的关键数据（如返回地址、函数指针等）。
   - 执行任意代码，进一步控制系统。

DESC
	name: "high",
	message: "检测到C语言格式化字符串漏洞，并且从数据源（source）到污染汇聚点（sink）间，没有发现任何过滤函数信息。",
}

desc(
	lang: c
	alert_high: 1
	'file://unsafe.c': <<<UNSAFE
#include <stdio.h>
#include <string.h>

void vulnerable_function(char* user_input) {
    printf(user_input);
    printf("\n");
}

int main(int argc, char** argv) {
	char buffer[1024];
    
   	read(STDIN_FILENO, buffer, 0x400);
    vulnerable_function(buffer);
    return 0;
}
UNSAFE
	'safefile://safe.c': <<<SAFE
#include <stdio.h>
#include <string.h>

void vulnerable_function(char* user_input) {
    printf("%s", user_input);
    printf("\n");
}

int main(int argc, char** argv) {
	char buffer[1024];
    
   	read(STDIN_FILENO, buffer, 0x400);
    vulnerable_function(buffer);
    return 0;
}
SAFE
)

