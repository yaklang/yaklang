desc(
	title: "Audit C Format String Vulnerability"
	title_zh: "审计C语言中的格式化字符串漏洞"
	type: audit
	severity: high
	rule_id: "254bbfe6-c356-421e-a3e1-a6662e0abb7e"
	desc: <<<DESC
### 漏洞描述

1. **漏洞原理**
   格式化字符串漏洞是由于程序直接将用户输入作为格式化字符串参数传递给格式化输出函数（如`printf`、`sprintf`等）造成的。攻击者可以通过精心构造的输入控制格式化字符串内容，从而操纵输出函数的行为，导致内存泄漏、任意内存读写或代码执行。

2. **触发场景**
   ```c
   #include <stdio.h>
   #include <string.h>
   void vulnerable_function(char* user_input) {
       printf(user_input); // 直接使用用户输入作为格式化字符串
       printf("\n");
   }
   int main(int argc, char** argv) {
       char buffer[1024];
       read(STDIN_FILENO, buffer, 0x400);
       vulnerable_function(buffer);
       return 0;
   }
   ```
   攻击者输入`%x%x%x`可以泄露栈内存内容；输入`%n`可以写入内存，可能导致任意代码执行。

3. **潜在影响**
   - 敏感信息泄露（如栈内存内容）。
   - 任意内存读写，可能导致程序崩溃或代码执行。
   - 通过内存操作绕过安全机制或提权。
DESC
	solution: <<<SOLUTION
### 修复建议

#### 1. 使用静态格式化字符串
始终使用静态定义的格式化字符串，避免用户输入直接作为格式化参数。
```c
// 修复代码示例
void safe_function(char* user_input) {
    printf("%s", user_input); // 使用静态格式化字符串
    printf("\n");
}
```

#### 2. 输入验证
对用户输入进行严格验证，拒绝包含格式化字符（如`%s`, `%n`）的输入。
```c
// 示例：验证输入不包含格式化字符
if (strchr(user_input, '%') != NULL) {
    fprintf(stderr, "Invalid input: contains formatting characters\n");
    return;
}
```

#### 3. 使用安全函数
在可能的情况下，使用更安全的替代函数（如`snprintf`）并确保正确使用。
```c
// 使用snprintf确保缓冲区安全
char output[256];
snprintf(output, sizeof(output), "%s", user_input);
printf("%s\n", output);
```

#### 4. 编译器警告
启用编译器警告（如GCC的`-Wformat-security`）以捕获潜在的格式化字符串漏洞。
SOLUTION
	reference: <<<REFERENCE
[CWE-134](https://cwe.mitre.org/data/definitions/134.html)
[OWASP Format String Vulnerability](https://owasp.org/www-community/attacks/Format_string_attack)
REFERENCE
)

printf(*<slice(index=0)> #-> as $sink);
fprintf(*<slice(index=1)> #-> as $sink);
sprintf(*<slice(index=1)> #-> as $sink);
snprintf(*<slice(index=2)> #-> as $sink);
syslog(*<slice(index=1)> #-> as $sink);
$sink?{!opcode:const} as $high

alert $high for {
	level: "high",
	type: "vuln",
	title: "C Format String Vulnerability Was Detected",
	title_zh: "检测到C语言格式化字符串漏洞",
	solution: <<<SOLUTION
### 修复建议
#### 1. 使用格式字符串
通过使用明确的格式字符串来指定用户输入的格式，避免用户控制格式字符串。

```c
// 修复代码示例
void vulnerable_function(char* user_input) {
  printf("%s", user_input); // 使用格式字符串
  printf("\n");
}
```

#### 2. 输入合法性校验
对用户输入实施类型、格式或范围限制，拒绝非法输入。

```c
// 示例：校验输入长度
void vulnerable_function(char* user_input) {
  if (strlen(user_input) > 1024) {
    printf("Input too long\n");
    return;
  }
  printf("%s", user_input);
  printf("\n");
}
```

#### 3. 使用安全函数
使用更安全的函数替代`printf`等危险函数，如`snprintf`。

```c
// 示例：使用snprintf
void vulnerable_function(char* user_input) {
  char buffer[1024];
  snprintf(buffer, sizeof(buffer), "%s", user_input); // 安全的格式化输出
  printf("%s\n", buffer);
}
```
SOLUTION
	risk: "格式化字符串漏洞",
	desc: <<<DESC
### 漏洞描述
1. **漏洞原理**
   格式化字符串漏洞是由于应用程序直接将用户输入作为格式化字符串传递给`printf`、`fprintf`等函数，攻击者可以通过构造特殊输入控制格式化字符串的行为。这可能导致内存泄漏、程序崩溃或任意代码执行。

2. **触发场景**
   // 存在漏洞的代码示例
   ```c
   void vulnerable_function(char* user_input) {
     printf(user_input); // 用户控制格式化字符串
     printf("\n");
   }
   ```
   攻击者输入`%x%x%x`可以泄漏栈内存；输入`%n`可能覆盖内存地址，导致任意代码执行。

3. **潜在影响**
   - 敏感信息（如内存内容）被泄漏。
   - 程序崩溃或被利用执行任意代码。
   - 可能绕过安全机制，进一步渗透系统。
DESC
	name: "high",
	message: "检测到C语言格式化字符串漏洞，并且从数据源（source）到污染汇聚点（sink）间，没有发现任何过滤函数信息。",
}

desc(
	lang: c
	alert_high: 1
	'file://unsafe.c': <<<UNSAFE
#include <stdio.h>
#include <string.h>

void vulnerable_function(char* user_input) {
    printf(user_input);
    printf("\n");
}

int main(int argc, char** argv) {
	char buffer[1024];
    
   	read(STDIN_FILENO, buffer, 0x400);
    vulnerable_function(buffer);
    return 0;
}
UNSAFE
	'safefile://safe.c': <<<SAFE
#include <stdio.h>
#include <string.h>

void vulnerable_function(char* user_input) {
    printf("%s", user_input);
    printf("\n");
}

int main(int argc, char** argv) {
	char buffer[1024];
    
   	read(STDIN_FILENO, buffer, 0x400);
    vulnerable_function(buffer);
    return 0;
}
SAFE
)

