desc(
	title: "Check C SSRF Vulnerability"
	type: audit
	severity: high
	desc: <<<DESC
### 漏洞描述

1. **漏洞原理**
   服务器端请求伪造（SSRF）漏洞发生在C语言应用程序接受用户输入的URL或网络地址，并使用该输入发起网络请求时，未对目标地址进行适当验证。攻击者可以利用此漏洞让服务器向内网地址、本地服务或其他不应访问的目标发起请求，从而绕过网络边界限制，访问内部资源，或对第三方服务发起攻击。在C语言中，这通常涉及使用libcurl、socket编程或其他网络库进行HTTP请求。

2. **触发场景**
   ```c
   #include <stdio.h>
   #include <stdlib.h>
   #include <string.h>
   #include <curl/curl.h>
   #include <sys/socket.h>
   #include <netinet/in.h>
   #include <arpa/inet.h>
   
   // 使用libcurl的SSRF漏洞示例
   void vulnerable_http_request(const char *user_url) {
       CURL *curl;
       CURLcode res;
       
       curl = curl_easy_init();
       if (curl) {
           // 直接使用用户输入的URL，未进行验证
           curl_easy_setopt(curl, CURLOPT_URL, user_url);
           curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, write_callback);
           
           res = curl_easy_perform(curl);
           if (res != CURLE_OK) {
               fprintf(stderr, "curl_easy_perform() failed: %s\n",
                       curl_easy_strerror(res));
           }
           curl_easy_cleanup(curl);
       }
   }
   
   // 使用socket的SSRF漏洞示例
   void vulnerable_socket_request(const char *host, int port) {
       int sockfd;
       struct sockaddr_in server_addr;
       
       sockfd = socket(AF_INET, SOCK_STREAM, 0);
       if (sockfd < 0) {
           perror("socket");
           return;
       }
       
       server_addr.sin_family = AF_INET;
       server_addr.sin_port = htons(port);
       // 直接使用用户输入的主机地址
       server_addr.sin_addr.s_addr = inet_addr(host);
       
       if (connect(sockfd, (struct sockaddr*)&server_addr, sizeof(server_addr)) < 0) {
           perror("connect");
           close(sockfd);
           return;
       }
       
       // 发送HTTP请求...
       close(sockfd);
   }
   ```
   攻击者可以输入内网地址如`http://192.168.1.1/admin`或`http://localhost:22`来访问内部服务。

3. **潜在影响**
   - **内网扫描**: 攻击者可以扫描内网服务和端口。
   - **内部服务访问**: 绕过防火墙访问内部API、管理界面等。
   - **敏感信息泄露**: 获取内部服务的响应内容。
   - **拒绝服务攻击**: 对内部或第三方服务发起DoS攻击。
   - **云服务元数据访问**: 在云环境中访问实例元数据服务。
DESC
	rule_id: "b9f7e3a1-2c8d-4e6f-9b1a-7d5c8e2f4a9b"
	title_zh: "检测C语言SSRF漏洞"
	solution: <<<SOLUTION
### 修复建议

#### 1. URL白名单验证
建立允许访问的域名和IP地址白名单。
```c
#include <stdio.h>
#include <string.h>
#include <curl/curl.h>

// 允许的域名白名单
const char *allowed_domains[] = {
    "api.example.com",
    "public-service.com",
    NULL
};

// 验证URL是否在白名单中
int is_allowed_url(const char *url) {
    if (!url) return 0;
    
    // 检查协议
    if (strncmp(url, "http://", 7) != 0 && strncmp(url, "https://", 8) != 0) {
        return 0;
    }
    
    // 提取域名
    const char *domain_start = strstr(url, "://");
    if (!domain_start) return 0;
    domain_start += 3;
    
    char domain[256];
    const char *path_start = strchr(domain_start, '/');
    size_t domain_len = path_start ? (path_start - domain_start) : strlen(domain_start);
    
    if (domain_len >= sizeof(domain)) return 0;
    strncpy(domain, domain_start, domain_len);
    domain[domain_len] = '\0';
    
    // 检查是否在白名单中
    for (int i = 0; allowed_domains[i]; i++) {
        if (strcmp(domain, allowed_domains[i]) == 0) {
            return 1;
        }
    }
    
    return 0;
}

void safe_http_request(const char *user_url) {
    if (!is_allowed_url(user_url)) {
        fprintf(stderr, "URL not allowed: %s\n", user_url);
        return;
    }
    
    CURL *curl = curl_easy_init();
    if (curl) {
        curl_easy_setopt(curl, CURLOPT_URL, user_url);
        curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, write_callback);
        
        // 设置安全选项
        curl_easy_setopt(curl, CURLOPT_FOLLOWLOCATION, 0L); // 禁用重定向
        curl_easy_setopt(curl, CURLOPT_TIMEOUT, 10L); // 设置超时
        curl_easy_setopt(curl, CURLOPT_CONNECTTIMEOUT, 5L);
        
        CURLcode res = curl_easy_perform(curl);
        if (res != CURLE_OK) {
            fprintf(stderr, "Request failed: %s\n", curl_easy_strerror(res));
        }
        curl_easy_cleanup(curl);
    }
}
```

#### 2. IP地址黑名单验证
阻止访问内网和本地地址。
```c
#include <arpa/inet.h>
#include <netinet/in.h>

int is_private_ip(const char *ip) {
    struct in_addr addr;
    if (inet_aton(ip, &addr) == 0) return 1; // 无效IP，拒绝
    
    uint32_t ip_num = ntohl(addr.s_addr);
    
    // 检查私有IP地址段
    // 10.0.0.0/8
    if ((ip_num >= 0x0A000000) && (ip_num <= 0x0AFFFFFF)) return 1;
    
    // 172.16.0.0/12
    if ((ip_num >= 0xAC100000) && (ip_num <= 0xAC1FFFFF)) return 1;
    
    // 192.168.0.0/16
    if ((ip_num >= 0xC0A80000) && (ip_num <= 0xC0A8FFFF)) return 1;
    
    // 127.0.0.0/8 (localhost)
    if ((ip_num >= 0x7F000000) && (ip_num <= 0x7FFFFFFF)) return 1;
    
    // 169.254.0.0/16 (link-local)
    if ((ip_num >= 0xA9FE0000) && (ip_num <= 0xA9FEFFFF)) return 1;
    
    return 0;
}

void safe_socket_request(const char *host, int port) {
    // 验证端口范围
    if (port < 80 || port > 8080) {
        fprintf(stderr, "Port %d not allowed\n", port);
        return;
    }
    
    // 验证IP地址
    if (is_private_ip(host)) {
        fprintf(stderr, "Private IP address not allowed: %s\n", host);
        return;
    }
    
    int sockfd = socket(AF_INET, SOCK_STREAM, 0);
    if (sockfd < 0) {
        perror("socket");
        return;
    }
    
    // 设置超时
    struct timeval timeout;
    timeout.tv_sec = 5;
    timeout.tv_usec = 0;
    setsockopt(sockfd, SOL_SOCKET, SO_RCVTIMEO, &timeout, sizeof(timeout));
    setsockopt(sockfd, SOL_SOCKET, SO_SNDTIMEO, &timeout, sizeof(timeout));
    
    struct sockaddr_in server_addr;
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(port);
    server_addr.sin_addr.s_addr = inet_addr(host);
    
    if (connect(sockfd, (struct sockaddr*)&server_addr, sizeof(server_addr)) < 0) {
        perror("connect");
        close(sockfd);
        return;
    }
    
    // 安全的网络操作...
    close(sockfd);
}
```

#### 3. 使用代理和沙箱
通过代理服务器过滤请求，或在沙箱环境中执行网络请求。
```c
void proxy_http_request(const char *user_url) {
    CURL *curl = curl_easy_init();
    if (curl) {
        // 通过安全代理发送请求
        curl_easy_setopt(curl, CURLOPT_URL, user_url);
        curl_easy_setopt(curl, CURLOPT_PROXY, "http://secure-proxy:8080");
        curl_easy_setopt(curl, CURLOPT_TIMEOUT, 10L);
        
        CURLcode res = curl_easy_perform(curl);
        curl_easy_cleanup(curl);
    }
}
```

#### 4. 请求限制和监控
实施请求频率限制和监控。
```c
#include <time.h>

typedef struct {
    time_t last_request;
    int request_count;
} rate_limit_t;

static rate_limit_t rate_limiter = {0, 0};

int check_rate_limit() {
    time_t now = time(NULL);
    
    if (now - rate_limiter.last_request > 60) {
        // 重置计数器（每分钟）
        rate_limiter.request_count = 0;
        rate_limiter.last_request = now;
    }
    
    if (rate_limiter.request_count >= 10) {
        return 0; // 超过限制
    }
    
    rate_limiter.request_count++;
    return 1;
}
```
SOLUTION
	reference: <<<REFERENCE
[CWE-918: Server-Side Request Forgery (SSRF)](https://cwe.mitre.org/data/definitions/918.html)
[OWASP SSRF Prevention](https://cheatsheetseries.owasp.org/cheatsheets/Server_Side_Request_Forgery_Prevention_Cheat_Sheet.html)
REFERENCE
)

<include('c-user-input')> as $user_input;

curl_easy_setopt(*<slice(index=2)> #-> as $curl_url);
curl_easy_perform() as $curl_perform;
socket() as $socket_call;
connect(*<slice(index=1)> #-> as $connect_addr);
inet_addr(* #-> as $inet_addr);
gethostbyname(* #-> as $gethostbyname);

$user_input & $curl_url as $high;
$user_input & $connect_addr as $high;
$user_input & $inet_addr as $high;
$user_input & $gethostbyname as $high;

alert $high for {
	level: "high",
	type: "vuln",
	title: "C SSRF Vulnerability Was Detected",
	title_zh: "检测到C语言SSRF漏洞",
	desc: <<<DESC
### 漏洞描述

1. **漏洞原理**
   服务器端请求伪造（SSRF）漏洞是由于应用程序接受用户输入的URL或网络地址，并使用该输入发起网络请求时，未对目标地址进行适当验证。攻击者可以利用此漏洞让服务器向内网地址或其他不应访问的目标发起请求。

2. **触发场景**
   检测到用户输入被直接用于网络请求函数：
   ```c
   // 危险示例
   curl_easy_setopt(curl, CURLOPT_URL, user_input);
   server_addr.sin_addr.s_addr = inet_addr(user_input);
   struct hostent *host = gethostbyname(user_input);
   ```
   攻击者可以输入内网地址如`192.168.1.1`或`localhost`来访问内部服务。

3. **潜在影响**
   - 内网扫描，攻击者可以扫描内网服务和端口
   - 内部服务访问，绕过防火墙访问内部API、管理界面
   - 敏感信息泄露，获取内部服务的响应内容
   - 对内部或第三方服务发起攻击
   - 在云环境中访问实例元数据服务
DESC
	message: "检测到C语言代码中存在SSRF漏洞，用户输入被直接用于网络请求",
	solution: <<<SOLUTION
### 修复建议

#### 1. 实施URL白名单验证
```c
const char *allowed_domains[] = {"api.example.com", "public-service.com", NULL};

int is_allowed_url(const char *url) {
    if (!url) return 0;
    
    // 检查协议
    if (strncmp(url, "http://", 7) != 0 && strncmp(url, "https://", 8) != 0) {
        return 0;
    }
    
    // 提取并验证域名
    // ... 域名验证逻辑
    
    return 0; // 默认拒绝
}

void safe_request(const char *user_url) {
    if (!is_allowed_url(user_url)) {
        fprintf(stderr, "URL not allowed\n");
        return;
    }
    curl_easy_setopt(curl, CURLOPT_URL, user_url);
}
```

#### 2. IP地址黑名单验证
```c
int is_private_ip(const char *ip) {
    struct in_addr addr;
    if (inet_aton(ip, &addr) == 0) return 1;
    
    uint32_t ip_num = ntohl(addr.s_addr);
    
    // 检查私有IP地址段
    if ((ip_num >= 0x0A000000) && (ip_num <= 0x0AFFFFFF)) return 1; // 10.0.0.0/8
    if ((ip_num >= 0xAC100000) && (ip_num <= 0xAC1FFFFF)) return 1; // 172.16.0.0/12
    if ((ip_num >= 0xC0A80000) && (ip_num <= 0xC0A8FFFF)) return 1; // 192.168.0.0/16
    if ((ip_num >= 0x7F000000) && (ip_num <= 0x7FFFFFFF)) return 1; // 127.0.0.0/8
    
    return 0;
}
```

#### 3. 设置请求限制
```c
// 设置超时和其他安全选项
curl_easy_setopt(curl, CURLOPT_TIMEOUT, 10L);
curl_easy_setopt(curl, CURLOPT_FOLLOWLOCATION, 0L); // 禁用重定向
curl_easy_setopt(curl, CURLOPT_MAXREDIRS, 0L);
```

#### 4. 使用代理服务器
```c
curl_easy_setopt(curl, CURLOPT_PROXY, "http://secure-proxy:8080");
```
SOLUTION
	risk: "SSRF",
	name: "high",
}

desc(
	lang: c
	alert_high: 1
	'file://unsafe_ssrf.c': <<<UNSAFE
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <curl/curl.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <netdb.h>

// 回调函数用于处理响应数据
size_t write_callback(void *contents, size_t size, size_t nmemb, void *userp) {
    printf("%.*s", (int)(size * nmemb), (char*)contents);
    return size * nmemb;
}

// 使用libcurl的SSRF漏洞
void vulnerable_http_request(const char *user_url) {
    CURL *curl;
    CURLcode res;
    
    curl = curl_easy_init();
    if (curl) {
        // 直接使用用户输入的URL，未进行任何验证
        curl_easy_setopt(curl, CURLOPT_URL, user_url);
        curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, write_callback);
        curl_easy_setopt(curl, CURLOPT_FOLLOWLOCATION, 1L); // 允许重定向
        
        printf("Requesting URL: %s\n", user_url);
        res = curl_easy_perform(curl);
        
        if (res != CURLE_OK) {
            fprintf(stderr, "curl_easy_perform() failed: %s\n",
                    curl_easy_strerror(res));
        }
        
        curl_easy_cleanup(curl);
    }
}

// 使用socket的SSRF漏洞
void vulnerable_socket_request(const char *host, int port) {
    int sockfd;
    struct sockaddr_in server_addr;
    char request[1024];
    char response[4096];
    
    printf("Connecting to %s:%d\n", host, port);
    
    sockfd = socket(AF_INET, SOCK_STREAM, 0);
    if (sockfd < 0) {
        perror("socket");
        return;
    }
    
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(port);
    // 直接使用用户输入的主机地址
    server_addr.sin_addr.s_addr = inet_addr(host);
    
    if (connect(sockfd, (struct sockaddr*)&server_addr, sizeof(server_addr)) < 0) {
        perror("connect");
        close(sockfd);
        return;
    }
    
    // 发送HTTP请求
    snprintf(request, sizeof(request), 
             "GET / HTTP/1.1\r\nHost: %s\r\nConnection: close\r\n\r\n", host);
    send(sockfd, request, strlen(request), 0);
    
    // 接收响应
    int bytes = recv(sockfd, response, sizeof(response) - 1, 0);
    if (bytes > 0) {
        response[bytes] = '\0';
        printf("Response:\n%s\n", response);
    }
    
    close(sockfd);
}

// 通过域名解析的SSRF漏洞
void vulnerable_dns_request(const char *hostname) {
    struct hostent *host_entry;
    
    printf("Resolving hostname: %s\n", hostname);
    
    // 直接使用用户输入进行DNS查询
    host_entry = gethostbyname(hostname);
    
    if (host_entry == NULL) {
        printf("DNS resolution failed\n");
        return;
    }
    
    printf("IP Address: %s\n", inet_ntoa(*((struct in_addr*)host_entry->h_addr_list[0])));
    
    // 可能继续使用解析的IP进行连接
    char *ip = inet_ntoa(*((struct in_addr*)host_entry->h_addr_list[0]));
    vulnerable_socket_request(ip, 80);
}

int main(int argc, char **argv) {
    if (argc < 2) {
        printf("Usage: %s <url_or_host>\n", argv[0]);
        return 1;
    }
    
    char *user_input = argv[1];
    
    // 各种SSRF攻击向量
    if (strstr(user_input, "http")) {
        vulnerable_http_request(user_input);
    } else {
        vulnerable_dns_request(user_input);
    }
    
    // 从环境变量获取目标
    char *target_host = getenv("TARGET_HOST");
    if (target_host) {
        vulnerable_socket_request(target_host, 22); // SSH端口
        vulnerable_socket_request(target_host, 3306); // MySQL端口
    }
    
    return 0;
}
UNSAFE
	'safefile://safe_ssrf.c': <<<SAFE
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <curl/curl.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <netdb.h>

// 允许的域名白名单
const char *allowed_domains[] = {
    "api.example.com",
    "public-service.com",
    "httpbin.org",
    NULL
};

// 允许的端口白名单
const int allowed_ports[] = {80, 443, 8080, 8443, 0};

size_t write_callback(void *contents, size_t size, size_t nmemb, void *userp) {
    printf("%.*s", (int)(size * nmemb), (char*)contents);
    return size * nmemb;
}

// 检查IP是否为私有地址
int is_private_ip(const char *ip) {
    struct in_addr addr;
    if (inet_aton(ip, &addr) == 0) return 1; // 无效IP，拒绝
    
    uint32_t ip_num = ntohl(addr.s_addr);
    
    // 私有IP地址段
    if ((ip_num >= 0x0A000000) && (ip_num <= 0x0AFFFFFF)) return 1; // 10.0.0.0/8
    if ((ip_num >= 0xAC100000) && (ip_num <= 0xAC1FFFFF)) return 1; // 172.16.0.0/12
    if ((ip_num >= 0xC0A80000) && (ip_num <= 0xC0A8FFFF)) return 1; // 192.168.0.0/16
    if ((ip_num >= 0x7F000000) && (ip_num <= 0x7FFFFFFF)) return 1; // 127.0.0.0/8
    if ((ip_num >= 0xA9FE0000) && (ip_num <= 0xA9FEFFFF)) return 1; // 169.254.0.0/16
    
    return 0;
}

// 验证URL是否在允许列表中
int is_allowed_url(const char *url) {
    if (!url) return 0;
    
    // 检查协议
    if (strncmp(url, "http://", 7) != 0 && strncmp(url, "https://", 8) != 0) {
        return 0;
    }
    
    // 提取域名
    const char *domain_start = strstr(url, "://");
    if (!domain_start) return 0;
    domain_start += 3;
    
    char domain[256];
    const char *path_start = strchr(domain_start, '/');
    const char *port_start = strchr(domain_start, ':');
    
    size_t domain_len;
    if (port_start && (!path_start || port_start < path_start)) {
        domain_len = port_start - domain_start;
    } else if (path_start) {
        domain_len = path_start - domain_start;
    } else {
        domain_len = strlen(domain_start);
    }
    
    if (domain_len >= sizeof(domain)) return 0;
    strncpy(domain, domain_start, domain_len);
    domain[domain_len] = '\0';
    
    // 检查域名是否在白名单中
    for (int i = 0; allowed_domains[i]; i++) {
        if (strcmp(domain, allowed_domains[i]) == 0) {
            return 1;
        }
    }
    
    return 0;
}

// 验证端口是否允许
int is_allowed_port(int port) {
    for (int i = 0; allowed_ports[i] != 0; i++) {
        if (allowed_ports[i] == port) {
            return 1;
        }
    }
    return 0;
}

// 安全的HTTP请求
void safe_http_request(const char *user_url) {
    if (!is_allowed_url(user_url)) {
        fprintf(stderr, "URL not allowed: %s\n", user_url);
        return;
    }
    
    CURL *curl = curl_easy_init();
    if (curl) {
        curl_easy_setopt(curl, CURLOPT_URL, user_url);
        curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, write_callback);
        
        // 安全设置
        curl_easy_setopt(curl, CURLOPT_FOLLOWLOCATION, 0L); // 禁用重定向
        curl_easy_setopt(curl, CURLOPT_TIMEOUT, 10L); // 10秒超时
        curl_easy_setopt(curl, CURLOPT_CONNECTTIMEOUT, 5L); // 5秒连接超时
        curl_easy_setopt(curl, CURLOPT_MAXREDIRS, 0L); // 禁用重定向
        curl_easy_setopt(curl, CURLOPT_PROTOCOLS, CURLPROTO_HTTP | CURLPROTO_HTTPS);
        
        printf("Making safe request to: %s\n", user_url);
        CURLcode res = curl_easy_perform(curl);
        
        if (res != CURLE_OK) {
            fprintf(stderr, "Request failed: %s\n", curl_easy_strerror(res));
        }
        
        curl_easy_cleanup(curl);
    }
}

// 安全的socket连接
void safe_socket_request(const char *host, int port) {
    // 验证端口
    if (!is_allowed_port(port)) {
        fprintf(stderr, "Port %d not allowed\n", port);
        return;
    }
    
    // 验证IP地址
    if (is_private_ip(host)) {
        fprintf(stderr, "Private IP address not allowed: %s\n", host);
        return;
    }
    
    printf("Making safe connection to %s:%d\n", host, port);
    
    int sockfd = socket(AF_INET, SOCK_STREAM, 0);
    if (sockfd < 0) {
        perror("socket");
        return;
    }
    
    // 设置超时
    struct timeval timeout;
    timeout.tv_sec = 5;
    timeout.tv_usec = 0;
    setsockopt(sockfd, SOL_SOCKET, SO_RCVTIMEO, &timeout, sizeof(timeout));
    setsockopt(sockfd, SOL_SOCKET, SO_SNDTIMEO, &timeout, sizeof(timeout));
    
    struct sockaddr_in server_addr;
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(port);
    server_addr.sin_addr.s_addr = inet_addr(host);
    
    if (connect(sockfd, (struct sockaddr*)&server_addr, sizeof(server_addr)) < 0) {
        perror("connect");
        close(sockfd);
        return;
    }
    
    printf("Connection successful\n");
    close(sockfd);
}

// 安全的DNS查询
void safe_dns_request(const char *hostname) {
    // 验证主机名格式
    if (!hostname || strlen(hostname) > 253) {
        fprintf(stderr, "Invalid hostname\n");
        return;
    }
    
    // 检查是否包含危险字符
    for (int i = 0; hostname[i]; i++) {
        char c = hostname[i];
        if (!((c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') || 
              (c >= '0' && c <= '9') || c == '.' || c == '-')) {
            fprintf(stderr, "Invalid character in hostname\n");
            return;
        }
    }
    
    printf("Resolving hostname: %s\n", hostname);
    
    struct hostent *host_entry = gethostbyname(hostname);
    if (host_entry == NULL) {
        printf("DNS resolution failed\n");
        return;
    }
    
    char *ip = inet_ntoa(*((struct in_addr*)host_entry->h_addr_list[0]));
    printf("Resolved IP: %s\n", ip);
    
    // 检查解析的IP是否为私有地址
    if (is_private_ip(ip)) {
        printf("Resolved to private IP, connection blocked\n");
        return;
    }
}

int main(int argc, char **argv) {
    if (argc < 2) {
        printf("Usage: %s <url_or_host>\n", argv[0]);
        printf("Allowed domains: ");
        for (int i = 0; allowed_domains[i]; i++) {
            printf("%s ", allowed_domains[i]);
        }
        printf("\n");
        return 1;
    }
    
    char *user_input = argv[1];
    
    if (strstr(user_input, "http")) {
        safe_http_request(user_input);
    } else {
        safe_dns_request(user_input);
    }
    
    return 0;
}
SAFE
)
