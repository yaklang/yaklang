desc(
	title: "Audit C Dangerous Input Functions"
	title_zh: "审计C语言中的危险输入函数"
	type: audit
	severity: high
	desc: <<<DESC
### 漏洞描述

1. **漏洞原理**
   在C语言中，许多标准库函数（如`gets()`、`scanf()`等）在处理用户输入时未对输入数据长度进行检查，可能导致缓冲区溢出。攻击者通过提供超出预期大小的输入数据，可以覆盖相邻的内存区域，从而导致程序崩溃或执行任意代码。

2. **触发场景**
   ```c
   #include <stdio.h>
   void vulnerable_function() {
       char buffer[64];
       printf("Enter your input: ");
       scanf("%s", buffer); // 危险函数，未限制输入长度
       printf("Buffer contents: %s\n", buffer);
   }
   int main() {
       vulnerable_function();
       return 0;
   }
   ```
   上述代码中，`scanf()`函数未对输入数据进行长度限制。如果攻击者输入超过64字节的数据，将覆盖堆栈上的其他变量甚至返回地址，可能导致程序崩溃或执行恶意代码。

3. **潜在影响**
   - 攻击者可以通过缓冲区溢出完全控制程序执行流程。
   - 可能导致信息泄露或系统权限提升。
   - 程序崩溃或拒绝服务（DoS），影响业务运行。

### 规则目的
该规则用于审计C语言中可能引发缓冲区溢出的危险输入函数，识别未经验证的输入操作，降低缓冲区溢出的风险。
DESC
	rule_id: "49b36a64-d6d1-4a78-a5a7-c97fbb9c8bfa"
	solution: <<<SOLUTION
### 修复建议

#### 1. 使用更安全的替代函数
避免使用危险的输入函数（如`gets()`、`scanf()`等），改用具有长度限制的安全函数。
```c
#include <stdio.h>
#include <string.h>
void safer_function() {
    char buffer[64];
    printf("Enter your input: ");
    fgets(buffer, sizeof(buffer), stdin); // 安全函数，限制输入长度
    buffer[strcspn(buffer, "\n")] = '\0'; // 移除换行符
    printf("Buffer contents: %s\n", buffer);
}
int main() {
    safer_function();
    return 0;
}
```

#### 2. 输入校验
对所有用户输入实施严格的长度和格式校验，确保输入符合预期。
```c
// 示例：校验输入长度是否合法
if (strlen(userInput) > MAX_LENGTH) {
    fprintf(stderr, "Error: Input too long\n");
    exit(EXIT_FAILURE);
}
```

#### 3. 启用编译器保护机制
现代编译器提供了多种保护机制（如栈保护、地址空间布局随机化等），可以有效缓解缓冲区溢出带来的危害。
- 使用编译选项启用栈保护（如`-fstack-protector`）。
- 配置链接器启用地址空间布局随机化（ASLR）。

#### 4. 使用静态代码分析工具
通过静态代码分析工具扫描源码，提前发现潜在的缓冲区溢出问题，并及时修复。
SOLUTION
	reference: <<<REFERENCE
[CWE-120](https://cwe.mitre.org/data/definitions/120.html)
[Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)
REFERENCE
)

gets()    as $high;
scanf()   as $high;
vscanf()  as $high;
fscanf()  as $high;
vfscanf() as $high;
sscanf()  as $high;
vsscanf() as $high;

alert $high for {
	level: "high",
	type: "vuln",
	title: "C Dangerous Input Function Vulnerability Was Detected",
	title_zh: "检测到C语言中的危险输入函数漏洞",
	desc: <<<DESC
### 漏洞描述
1. **漏洞原理**
   由于使用了危险的输入函数（如`gets()`、`scanf()`等），未对用户输入长度进行检查，可能导致缓冲区溢出。攻击者通过构造超长输入覆盖内存中的关键数据（如返回地址），从而执行任意代码或导致程序崩溃。
2. **触发场景**
   // 存在漏洞的代码示例
   ```c
   #include <stdio.h>
   void vulnerable_function() {
       char buffer[64];
       printf("Enter your input: ");
       scanf("%s", buffer);  // 直接读取用户输入，未限制长度
       printf("Buffer contents: %s\n", buffer);
   }
   int main() {
       vulnerable_function();
       return 0;
   }
   ```
   攻击者输入超过64字节的数据时，可能覆盖堆栈上的其他变量或返回地址。
3. **潜在影响**
   - 执行任意代码，完全控制目标系统。
   - 导致程序崩溃，造成拒绝服务。
   - 泄露内存中的敏感信息。
DESC
	name: "high",
	message: "检测到C语言中使用危险的输入函数（如`gets()`、`scanf()`等）可能导致缓冲区溢出漏洞，并且从数据源（source）到污染汇聚点（sink）间，没有发现任何过滤函数信息。",
	solution: <<<SOLUTION
### 修复建议
#### 1. 使用安全的替代函数
避免使用危险的输入函数（如`gets()`、`scanf()`等），改用安全性更高的函数。
```c
// 修复代码示例
#include <stdio.h>
#include <string.h>
void safer_function() {
    char buffer[64];
    printf("Enter your input: ");
    fgets(buffer, sizeof(buffer), stdin);  // 使用fgets限制输入长度
    buffer[strcspn(buffer, "\n")] = '\0';  // 去除尾部换行符
    printf("Buffer contents: %s\n", buffer);
}
int main() {
    safer_function();
    return 0;
}
```
#### 2. 输入合法性校验
对用户输入实施长度和格式限制，拒绝非法输入。
```c
// 示例：校验输入长度
#include <stdio.h>
#include <string.h>
void validate_input(const char* input) {
    if (strlen(input) >= 64) {
        fprintf(stderr, "Input too long!\n");
        exit(1);
    }
}
```
#### 3. 启用编译器保护机制
现代编译器提供了多种保护机制（如栈保护、地址空间布局随机化等），确保启用了这些选项。
```bash
gcc -o program program.c -fstack-protector-all -Wl,-z,relro,-z,now
```
SOLUTION
	risk: "缓冲区溢出",
}

desc(
	lang: c
	alert_high: 1
	'file://unsafe.c': <<<UNSAFE
#include <stdio.h>

void vulnerable_function() {
    char buffer[64];
    
    printf("Enter your input: ");
    scanf("%s", buffer);
    
    printf("Buffer contents: %s\n", buffer);
}

int main() {
    vulnerable_function();
    return 0;
}
UNSAFE
	'safefile://safe.c': <<<SAFE
#include <stdio.h>
#include <string.h>

void safer_function() {
    char buffer[64];
    
    printf("Enter your input: ");
    fgets(buffer, sizeof(buffer), stdin); 
    
    buffer[strcspn(buffer, "\n")] = '\0';
    printf("Buffer contents: %s\n", buffer);
}

int main() {
    safer_function();
    return 0;
}
SAFE
)

