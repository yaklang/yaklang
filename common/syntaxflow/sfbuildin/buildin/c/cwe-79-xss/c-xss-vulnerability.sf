desc(
	title: "Check C XSS Vulnerability in Web Applications"
	type: audit
	severity: high
	desc: <<<DESC
### 漏洞描述

1. **漏洞原理**
   跨站脚本攻击（XSS）在C语言Web应用程序中发生时，通常是由于应用程序未对用户输入进行适当的HTML转义或过滤，直接将用户输入嵌入到HTML响应中。虽然C语言不像JavaScript那样直接处理Web前端，但在使用C语言开发Web服务器、CGI程序或嵌入式Web应用时，仍可能存在XSS漏洞。攻击者可以通过构造包含恶意脚本的输入，使这些脚本在用户浏览器中执行，从而窃取用户信息、会话劫持或执行其他恶意操作。

2. **触发场景**
   ```c
   #include <stdio.h>
   #include <stdlib.h>
   #include <string.h>
   
   // CGI程序示例 - 存在XSS漏洞
   void vulnerable_cgi_response(const char *user_input) {
       printf("Content-Type: text/html\r\n\r\n");
       printf("<html><head><title>Search Results</title></head><body>\n");
       // 直接输出用户输入到HTML中，未进行转义
       printf("<h1>Search results for: %s</h1>\n", user_input);
       printf("<p>You searched for: %s</p>\n", user_input);
       printf("</body></html>\n");
   }
   
   // Web服务器响应示例 - 存在XSS漏洞
   void vulnerable_http_response(int client_socket, const char *query_param) {
       char response[2048];
       // 直接拼接用户输入到HTML响应中
       sprintf(response, 
           "HTTP/1.1 200 OK\r\n"
           "Content-Type: text/html\r\n\r\n"
           "<html><body>"
           "<h1>Welcome %s!</h1>"
           "<p>Your query: %s</p>"
           "</body></html>", 
           query_param, query_param);
       
       send(client_socket, response, strlen(response), 0);
   }
   ```
   攻击者输入`<script>alert('XSS')</script>`时，脚本会在用户浏览器中执行。

3. **潜在影响**
   - **会话劫持**: 攻击者可以窃取用户的Cookie和会话信息。
   - **身份冒充**: 攻击者可以以受害者身份执行操作。
   - **敏感信息窃取**: 攻击者可以访问用户的敏感信息。
   - **恶意重定向**: 攻击者可以将用户重定向到恶意网站。
DESC
	rule_id: "c8e1f4b2-9d3a-4c7e-8f2b-1a6d9e4c7b8f"
	title_zh: "检测C语言Web应用XSS漏洞"
	solution: <<<SOLUTION
### 修复建议

#### 1. HTML实体转义
对所有用户输入进行HTML实体转义后再输出到HTML中。
```c
#include <stdio.h>
#include <string.h>
#include <stdlib.h>

// HTML转义函数
char* html_escape(const char *input) {
    if (!input) return NULL;
    
    size_t len = strlen(input);
    size_t escaped_len = len * 6 + 1; // 最坏情况下每个字符都需要转义
    char *escaped = malloc(escaped_len);
    if (!escaped) return NULL;
    
    char *out = escaped;
    for (const char *in = input; *in; in++) {
        switch (*in) {
            case '<':
                strcpy(out, "&lt;");
                out += 4;
                break;
            case '>':
                strcpy(out, "&gt;");
                out += 4;
                break;
            case '&':
                strcpy(out, "&amp;");
                out += 5;
                break;
            case '"':
                strcpy(out, "&quot;");
                out += 6;
                break;
            case '\'':
                strcpy(out, "&#x27;");
                out += 6;
                break;
            default:
                *out++ = *in;
                break;
        }
    }
    *out = '\0';
    return escaped;
}

void safe_cgi_response(const char *user_input) {
    char *escaped_input = html_escape(user_input);
    if (!escaped_input) {
        printf("Content-Type: text/html\r\n\r\n");
        printf("<html><body><h1>Error processing input</h1></body></html>\n");
        return;
    }
    
    printf("Content-Type: text/html\r\n\r\n");
    printf("<html><head><title>Search Results</title></head><body>\n");
    printf("<h1>Search results for: %s</h1>\n", escaped_input);
    printf("<p>You searched for: %s</p>\n", escaped_input);
    printf("</body></html>\n");
    
    free(escaped_input);
}
```

#### 2. 输入验证和过滤
对用户输入进行严格的验证和过滤。
```c
int is_safe_html_input(const char *input) {
    if (!input) return 0;
    
    // 检查输入长度
    if (strlen(input) > 1000) return 0;
    
    // 检查是否包含危险字符序列
    const char *dangerous[] = {"<script", "</script", "javascript:", "on", NULL};
    for (int i = 0; dangerous[i]; i++) {
        if (strcasestr(input, dangerous[i])) {
            return 0;
        }
    }
    
    return 1;
}

void validated_cgi_response(const char *user_input) {
    if (!is_safe_html_input(user_input)) {
        printf("Content-Type: text/html\r\n\r\n");
        printf("<html><body><h1>Invalid input detected</h1></body></html>\n");
        return;
    }
    
    char *escaped_input = html_escape(user_input);
    // ... 继续处理
    free(escaped_input);
}
```

#### 3. 使用安全的响应头
设置安全相关的HTTP响应头。
```c
void safe_http_response(int client_socket, const char *query_param) {
    char *escaped_param = html_escape(query_param);
    if (!escaped_param) {
        char error_response[] = "HTTP/1.1 500 Internal Server Error\r\n\r\n";
        send(client_socket, error_response, strlen(error_response), 0);
        return;
    }
    
    char response[4096];
    snprintf(response, sizeof(response),
        "HTTP/1.1 200 OK\r\n"
        "Content-Type: text/html; charset=UTF-8\r\n"
        "X-Content-Type-Options: nosniff\r\n"
        "X-Frame-Options: DENY\r\n"
        "X-XSS-Protection: 1; mode=block\r\n"
        "Content-Security-Policy: default-src 'self'\r\n\r\n"
        "<html><head><meta charset=\"UTF-8\"></head><body>"
        "<h1>Welcome %s!</h1>"
        "<p>Your query: %s</p>"
        "</body></html>",
        escaped_param, escaped_param);
    
    send(client_socket, response, strlen(response), 0);
    free(escaped_param);
}
```

#### 4. 使用模板引擎
考虑使用支持自动转义的模板引擎。
```c
// 使用安全的模板函数
void render_template(const char *template, const char *user_data) {
    char *escaped_data = html_escape(user_data);
    char output[2048];
    
    snprintf(output, sizeof(output), template, escaped_data);
    printf("%s", output);
    
    free(escaped_data);
}
```
SOLUTION
	reference: <<<REFERENCE
[CWE-79: Cross-site Scripting (XSS)](https://cwe.mitre.org/data/definitions/79.html)
[OWASP XSS Prevention](https://cheatsheetseries.owasp.org/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.html)
REFERENCE
)

<include('c-user-input')> as $user_input;

accept -->?{have: 'write'} as $target;
accept -->?{have: 'send'} as $target;
$target<getCallee>(*<slice(index=1)> as $sink);

$sink #{
    until: '* & $user_input'
}-> as $high;

alert $high for {
	level: "high",
	type: "vuln",
	title: "C XSS Vulnerability in Web Application Was Detected",
	title_zh: "检测到C语言Web应用XSS漏洞",
	desc: <<<DESC
### 漏洞描述

1. **漏洞原理**
   跨站脚本攻击（XSS）漏洞是由于应用程序未对用户输入进行适当的HTML转义或过滤，直接将用户输入嵌入到HTML响应中。攻击者可以通过构造包含恶意脚本的输入，使这些脚本在用户浏览器中执行。

2. **触发场景**
   检测到用户输入被直接用于HTML输出函数，可能导致XSS攻击：
   ```c
   // 危险示例
   printf("<h1>Welcome %s!</h1>", user_input);
   sprintf(response, "<p>You entered: %s</p>", user_input);
   send(socket, html_response_with_user_input, length, 0);
   ```
   攻击者输入`<script>alert('XSS')</script>`时，脚本会在浏览器中执行。

3. **潜在影响**
   - 会话劫持，攻击者可以窃取用户Cookie和会话信息
   - 身份冒充，攻击者可以以受害者身份执行操作
   - 敏感信息窃取，攻击者可以访问用户的敏感信息
   - 恶意重定向，将用户重定向到恶意网站
DESC
	message: "检测到C语言Web应用中存在XSS漏洞，用户输入被直接输出到HTML响应中",
	solution: <<<SOLUTION
### 修复建议

#### 1. HTML实体转义
```c
char* html_escape(const char *input) {
    // 实现HTML转义函数
    size_t len = strlen(input);
    char *escaped = malloc(len * 6 + 1);
    char *out = escaped;
    
    for (const char *in = input; *in; in++) {
        switch (*in) {
            case '<': strcpy(out, "&lt;"); out += 4; break;
            case '>': strcpy(out, "&gt;"); out += 4; break;
            case '&': strcpy(out, "&amp;"); out += 5; break;
            case '"': strcpy(out, "&quot;"); out += 6; break;
            case '\'': strcpy(out, "&#x27;"); out += 6; break;
            default: *out++ = *in; break;
        }
    }
    *out = '\0';
    return escaped;
}

// 安全使用
char *escaped_input = html_escape(user_input);
printf("<h1>Welcome %s!</h1>", escaped_input);
free(escaped_input);
```

#### 2. 输入验证
```c
int is_safe_html_input(const char *input) {
    if (!input || strlen(input) > 1000) return 0;
    
    const char *dangerous[] = {"<script", "javascript:", NULL};
    for (int i = 0; dangerous[i]; i++) {
        if (strcasestr(input, dangerous[i])) return 0;
    }
    return 1;
}
```

#### 3. 设置安全HTTP头
```c
printf("Content-Type: text/html; charset=UTF-8\r\n");
printf("X-Content-Type-Options: nosniff\r\n");
printf("X-Frame-Options: DENY\r\n");
printf("X-XSS-Protection: 1; mode=block\r\n");
printf("Content-Security-Policy: default-src 'self'\r\n\r\n");
```
SOLUTION
	risk: "XSS",
	name: "high",
}

desc(
	lang: c
	alert_high: 1
	'file://unsafe_xss.c': <<<UNSAFE
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/socket.h>

// CGI程序 - 存在XSS漏洞
void vulnerable_cgi_search(const char *query) {
    printf("Content-Type: text/html\r\n\r\n");
    printf("<html><head><title>Search Results</title></head><body>\n");
    // 直接输出用户输入，未进行HTML转义
    printf("<h1>Search results for: %s</h1>\n", query);
    printf("<p>You searched for: %s</p>\n", query);
    printf("<div>Query parameter: %s</div>\n", query);
    printf("</body></html>\n");
}

// Web服务器响应 - 存在XSS漏洞
void vulnerable_http_response(int client_socket, const char *user_name) {
    char response[2048];
    
    // 直接拼接用户输入到HTML响应
    sprintf(response, 
        "HTTP/1.1 200 OK\r\n"
        "Content-Type: text/html\r\n\r\n"
        "<html><body>"
        "<h1>Welcome %s!</h1>"
        "<p>Hello %s, nice to see you!</p>"
        "<div>User: %s</div>"
        "</body></html>", 
        user_name, user_name, user_name);
    
    send(client_socket, response, strlen(response), 0);
}

// 表单处理 - 存在XSS漏洞
void vulnerable_form_handler(const char *comment) {
    printf("Content-Type: text/html\r\n\r\n");
    printf("<html><body>\n");
    printf("<h2>Your comment has been posted:</h2>\n");
    // 直接输出用户评论，未转义
    printf("<blockquote>%s</blockquote>\n", comment);
    printf("</body></html>\n");
}

int main() {
    char *query = getenv("QUERY_STRING");
    char *user_name = getenv("USER_NAME");
    char *comment = getenv("COMMENT");
    
    if (query) {
        vulnerable_cgi_search(query);
    }
    
    if (user_name) {
        int socket_fd = accept(); // 假设的socket
        vulnerable_http_response(socket_fd, user_name);
    }
    
    if (comment) {
        vulnerable_form_handler(comment);
    }
    
    return 0;
}
UNSAFE
	'safefile://safe_xss.c': <<<SAFE
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/socket.h>

// HTML转义函数
char* html_escape(const char *input) {
    if (!input) return NULL;
    
    size_t len = strlen(input);
    size_t escaped_len = len * 6 + 1;
    char *escaped = malloc(escaped_len);
    if (!escaped) return NULL;
    
    char *out = escaped;
    for (const char *in = input; *in; in++) {
        switch (*in) {
            case '<':
                strcpy(out, "&lt;");
                out += 4;
                break;
            case '>':
                strcpy(out, "&gt;");
                out += 4;
                break;
            case '&':
                strcpy(out, "&amp;");
                out += 5;
                break;
            case '"':
                strcpy(out, "&quot;");
                out += 6;
                break;
            case '\'':
                strcpy(out, "&#x27;");
                out += 6;
                break;
            default:
                *out++ = *in;
                break;
        }
    }
    *out = '\0';
    return escaped;
}

// 输入验证函数
int is_safe_html_input(const char *input) {
    if (!input || strlen(input) > 1000) return 0;
    
    // 检查危险字符序列
    const char *dangerous[] = {"<script", "</script", "javascript:", "onclick", "onerror", NULL};
    for (int i = 0; dangerous[i]; i++) {
        if (strcasestr(input, dangerous[i])) {
            return 0;
        }
    }
    
    return 1;
}

// 安全的CGI搜索处理
void safe_cgi_search(const char *query) {
    if (!is_safe_html_input(query)) {
        printf("Content-Type: text/html\r\n\r\n");
        printf("<html><body><h1>Invalid input detected</h1></body></html>\n");
        return;
    }
    
    char *escaped_query = html_escape(query);
    if (!escaped_query) {
        printf("Content-Type: text/html\r\n\r\n");
        printf("<html><body><h1>Error processing input</h1></body></html>\n");
        return;
    }
    
    printf("Content-Type: text/html; charset=UTF-8\r\n");
    printf("X-Content-Type-Options: nosniff\r\n");
    printf("X-Frame-Options: DENY\r\n");
    printf("X-XSS-Protection: 1; mode=block\r\n\r\n");
    
    printf("<html><head>");
    printf("<meta charset=\"UTF-8\">");
    printf("<title>Search Results</title>");
    printf("</head><body>\n");
    printf("<h1>Search results for: %s</h1>\n", escaped_query);
    printf("<p>You searched for: %s</p>\n", escaped_query);
    printf("</body></html>\n");
    
    free(escaped_query);
}

// 安全的HTTP响应处理
void safe_http_response(int client_socket, const char *user_name) {
    if (!is_safe_html_input(user_name)) {
        char error_response[] = "HTTP/1.1 400 Bad Request\r\n\r\nInvalid input";
        send(client_socket, error_response, strlen(error_response), 0);
        return;
    }
    
    char *escaped_name = html_escape(user_name);
    if (!escaped_name) {
        char error_response[] = "HTTP/1.1 500 Internal Server Error\r\n\r\n";
        send(client_socket, error_response, strlen(error_response), 0);
        return;
    }
    
    char response[4096];
    snprintf(response, sizeof(response),
        "HTTP/1.1 200 OK\r\n"
        "Content-Type: text/html; charset=UTF-8\r\n"
        "X-Content-Type-Options: nosniff\r\n"
        "X-Frame-Options: DENY\r\n"
        "X-XSS-Protection: 1; mode=block\r\n"
        "Content-Security-Policy: default-src 'self'\r\n\r\n"
        "<html><head><meta charset=\"UTF-8\"></head><body>"
        "<h1>Welcome %s!</h1>"
        "<p>Hello %s, nice to see you!</p>"
        "</body></html>",
        escaped_name, escaped_name);
    
    send(client_socket, response, strlen(response), 0);
    free(escaped_name);
}

int main() {
    char *query = getenv("QUERY_STRING");
    char *user_name = getenv("USER_NAME");
    
    if (query) {
        safe_cgi_search(query);
    }
    
    if (user_name) {
        int socket_fd = accept(); // 假设的socket
        safe_http_response(socket_fd, user_name);
    }
    
    return 0;
}
SAFE
)
