desc(
	title: "Detect C Command Injection Vulnerability"
	type: audit
	severity: high
	desc: <<<DESC
### 漏洞描述

1. **漏洞原理**
   命令注入漏洞发生在应用程序将未经验证的用户输入直接传递给系统命令执行函数时。在C语言中，常见的危险函数包括`system()`、`popen()`以及`exec`和`spawn`系列函数。攻击者可以通过构造包含特殊字符（如`;`、`|`、`&`等）的输入来拼接并执行任意命令，从而导致系统被完全控制。

2. **触发场景**
   ```c
   // 不安全的代码示例：直接拼接用户输入
   #include <stdlib.h>
   void vulnerable_function(const char *user_input) {
       char command[256];
       sprintf(command, "ls %s", user_input);
       system(command);  // 如果user_input为"; rm -rf /"，将导致灾难性后果
   }
   ```
   攻击者输入`; rm -rf /`会导致删除整个文件系统。其他攻击向量包括泄露敏感文件（`/etc/passwd`）、启动反向Shell等。

3. **潜在影响**
   - 完全控制系统（执行任意命令）。
   - 数据泄露或破坏（读取/删除文件）。
   - 进一步横向渗透（如建立持久化后门）。
DESC
	rule_id: "e02361da-8cd0-4c3d-bcce-db14caabe70e"
	title_zh: "检测C语言命令注入漏洞"
	risk: ""
	solution: <<<SOLUTION
### 修复建议

#### 1. 避免直接执行命令
   使用C标准库函数替代命令执行（如`readdir`代替`system("ls")`）：
   ```c
   // 安全示例：使用目录操作API
   #include <dirent.h>
   void safe_list_dir(const char *path) {
       DIR *dir = opendir(path);
       struct dirent *entry;
       while ((entry = readdir(dir)) != NULL) {
           printf("%s\n", entry->d_name);
       }
       closedir(dir);
   }
   ```

#### 2. 严格验证输入
   对用户输入进行白名单校验（仅允许字母、数字和指定符号）：
   ```c
   int is_valid_input(const char *input) {
       const char *allowed_chars = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789-._/";
       for (int i = 0; input[i]; i++) {
           if (!strchr(allowed_chars, input[i])) {
               return 0;
           }
       }
       return 1;
   }
   ```

#### 3. 使用安全的API设计
   如果必须执行命令，应使用`execve`并直接传递参数数组（避免Shell解析）：
   ```c
   // 安全执行命令
   char *args[] = {"/bin/ls", "-l", "safe_dir", NULL};
   execve(args[0], args, NULL);
   ```

#### 4. 最小化权限
   以非特权用户身份运行程序，通过`chroot`或容器限制文件系统访问。
SOLUTION
	reference: <<<REFERENCE
[CWE-77: Command Injection](https://cwe.mitre.org/data/definitions/77.html)
[OWASP Command Injection Defense](https://cheatsheetseries.owasp.org/cheatsheets/OS_Command_Injection_Defense_Cheat_Sheet.html)
REFERENCE
)

system(* #-> as $cmd_sink);
syscall(* #-> as $cmd_sink);
popen(* #-> as $cmd_sink);
execl(* #-> as $cmd_sink);
execlp(* #-> as $cmd_sink);
execle(* #-> as $cmd_sink);
execv(* #-> as $cmd_sink);
execvp(* #-> as $cmd_sink);
execvpe(* #-> as $cmd_sink);
spawnl(* #-> as $cmd_sink);
spawnlp(* #-> as $cmd_sink);
spawnle(* #-> as $cmd_sink);
spawnv(* #-> as $cmd_sink);
spawnvp(* #-> as $cmd_sink);
spawnvpe(* #-> as $cmd_sink);

<include('c-user-input')> as $user_input;

$cmd_sink & $user_input as $high;

alert $high for {
	level: "high",
	type: "vuln",
	title: "C Command Injection Vulnerability Was Detected",
	title_zh: "检测到C语言命令注入漏洞",
	desc: <<<DESC
### 漏洞描述

1. **漏洞原理**
   命令注入是由于应用程序未对用户输入进行严格的过滤或参数化处理，攻击者可通过构造特殊输入篡改原始命令的逻辑。这可能导致非预期的系统命令执行，例如执行任意命令、读取敏感文件或提升权限。

2. **触发场景**
   // 存在漏洞的代码示例
   ```c
   #include <stdio.h>
   #include <stdlib.h>
   #include <string.h>
   void vulnerable_file_list(const char *directory) {
   char command[256];
   // 不安全的命令构建 - 直接拼接用户输入
   sprintf(command, "ls -la %s", directory);
   // 执行系统命令
   system(command);
   }
   ```
   攻击者输入 `; rm -rf /` 可删除系统文件；输入 `| cat /etc/passwd` 可读取敏感文件。

3. **潜在影响**
   - 执行任意系统命令，可能导致数据泄露或系统破坏。
   - 通过命令提权进一步渗透至服务器或其他系统组件。
DESC
	message: "检测到C语言命令注入漏洞，并且从数据源（source）到污染汇聚点（sink）间，没有发现任何过滤函数信息。",
	solution: <<<SOLUTION
### 修复建议

#### 1. 避免直接执行系统命令
使用语言内置的文件操作函数代替命令执行。
```c
#include <dirent.h>
#include <sys/stat.h>

void safe_file_list(const char *directory) {
  DIR *dir;
  struct dirent *entry;
  struct stat file_stat;
  dir = opendir(directory);
  if (dir == NULL) {
    perror("opendir");
    return;
  }
  while ((entry = readdir(dir)) != NULL) {
    char full_path[512];
    snprintf(full_path, sizeof(full_path), "%s/%s", directory, entry->d_name);
    if (stat(full_path, &file_stat) == 0) {
      printf("%s\t%ld bytes\n", entry->d_name, file_stat.st_size);
    }
  }
  closedir(dir);
}
```

#### 2. 输入合法性校验
对用户输入实施类型、格式或范围限制，拒绝非法输入。
```c
int is_safe_path(const char *path) {
  if (!path) return 0;
  const char *dangerous_chars = "..;|&`$(){}\"\\";
  for (int i = 0; path[i]; i++) {
    if (strchr(dangerous_chars, path[i])) {
      return 0;
    }
  }
  if (strlen(path) > 100) {
    return 0;
  }
  return 1;
}
```

#### 3. 使用安全执行函数
如果必须执行命令，使用安全的函数并严格控制环境变量和命令参数。
```c
#include <sys/types.h>
#include <sys/wait.h>
#include <unistd.h>

void safe_exec(const char *safe_path) {
  pid_t pid = fork();
  if (pid == 0) {
    // 子进程执行
    execl("/bin/ls", "ls", "-l", safe_path, NULL);
    _exit(1); // 如果execl失败
  } else if (pid > 0) {
    waitpid(pid, NULL, 0); // 等待子进程结束
  }
}
```
SOLUTION
	risk: "命令注入",
	name: "high",
}

desc(
	lang: c
	alert_min: 1
	'file://unsafe_command.c': <<<UNSAFE
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

void vulnerable_file_list(const char *directory) {
    char command[256];
    
    // 不安全的命令构建 - 直接拼接用户输入
    sprintf(command, "ls -la %s", directory);
    
    // 执行系统命令
    system(command);
}

void vulnerable_process_kill(const char *process_name) {
    char command[256];
    
    // 不安全的命令构建
    sprintf(command, "pkill %s", process_name);
    system(command);
}

int main(int argc, char **argv) {
    if (argc != 2) {
        printf("Usage: %s <directory>\n", argv[0]);
        return 1;
    }
    
    // 直接使用命令行参数，没有验证
    vulnerable_file_list(argv[1]);
    
    // 从环境变量获取进程名
    char *process = getenv("PROCESS_NAME");
    if (process) {
        vulnerable_process_kill(process);
    }
    
    return 0;
}
UNSAFE
	'safefile://safe_command.c': <<<SAFE
#include <stdio.h>
#include <dirent.h>
#include <sys/stat.h>
#include <string.h>
#include <ctype.h>

// 安全的路径验证函数
int is_safe_path(const char *path) {
    if (!path) return 0;
    
    // 检查是否包含危险字符
    const char *dangerous_chars = "..;|&`$(){}[]<>\"'\\";
    for (int i = 0; path[i]; i++) {
        if (strchr(dangerous_chars, path[i])) {
            return 0;
        }
    }
    
    // 检查路径长度
    if (strlen(path) > 100) {
        return 0;
    }
    
    return 1;
}

void safe_file_list(const char *directory) {
    // 验证输入路径
    if (!is_safe_path(directory)) {
        printf("Invalid directory path\n");
        return;
    }
    
    DIR *dir;
    struct dirent *entry;
    struct stat file_stat;
    
    dir = opendir(directory);
    if (dir == NULL) {
        perror("opendir");
        return;
    }
    
    while ((entry = readdir(dir)) != NULL) {
        char full_path[512];
        snprintf(full_path, sizeof(full_path), "%s/%s", directory, entry->d_name);
        
        if (stat(full_path, &file_stat) == 0) {
            printf("%s\t%ld bytes\n", entry->d_name, file_stat.st_size);
        }
    }
    
    closedir(dir);
}

int main(int argc, char **argv) {
    if (argc != 2) {
        printf("Usage: %s <directory>\n", argv[0]);
        return 1;
    }
    
    // 使用安全的文件列表函数
    safe_file_list(argv[1]);
    
    return 0;
}
SAFE
)
