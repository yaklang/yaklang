desc(
	title: "Check C Hard-Coded Password Vulnerability"
	type: audit
	severity: high
	desc: <<<DESC
### 漏洞描述

1. **漏洞原理**
   硬编码密码漏洞是指在C语言源代码中直接以明文形式存储敏感的认证凭据（如用户名、密码、API密钥等）。这种做法极度危险，因为攻击者一旦获取源代码、二进制文件或通过逆向工程，就能轻易提取这些凭据，进而非法访问相关系统或服务。在C语言中，硬编码密码通常表现为字符串常量直接用于认证函数调用。

2. **触发场景**
   ```c
   #include <stdio.h>
   #include <string.h>
   #include <mysql/mysql.h>
   
   int authenticate_user(const char *username) {
       // 硬编码的数据库连接密码
       const char *db_password = "admin123";
       
       MYSQL *conn = mysql_init(NULL);
       if (mysql_real_connect(conn, "localhost", "root", db_password, 
                             "users", 0, NULL, 0) == NULL) {
           return 0;
       }
       
       // 硬编码的管理员密码
       if (strcmp(username, "admin") == 0 && 
           strcmp("hardcoded_password", "hardcoded_password") == 0) {
           return 1;
       }
       
       mysql_close(conn);
       return 0;
   }
   ```
   在上述代码中，数据库密码和管理员密码都被硬编码在源代码中。

3. **潜在影响**
   - **敏感信息泄露**: 攻击者通过逆向工程或源代码泄露获取硬编码的密码。
   - **系统权限滥用**: 获取硬编码凭据后，攻击者可能直接访问数据库、API或其他受保护资源。
   - **合规性问题**: 硬编码敏感信息违反了许多安全标准和合规性要求（如PCI DSS、GDPR等）。
   - **维护困难**: 硬编码密码难以更新，一旦需要修改需要重新编译和部署。
DESC
	rule_id: "f8b2d4c9-1e5a-4f7b-8c3d-9a6e2b4f8d1c"
	title_zh: "检测C语言硬编码密码漏洞"
	solution: <<<SOLUTION
### 修复建议

#### 1. 使用配置文件或环境变量
将敏感凭据存储在应用程序外部的安全配置文件或环境变量中。
```c
#include <stdlib.h>
#include <string.h>

int safe_authenticate() {
    // 从环境变量读取密码
    const char *db_password = getenv("DB_PASSWORD");
    const char *admin_password = getenv("ADMIN_PASSWORD");
    
    if (!db_password || !admin_password) {
        fprintf(stderr, "Required credentials not found in environment\n");
        return 0;
    }
    
    // 使用从环境变量获取的密码
    MYSQL *conn = mysql_init(NULL);
    if (mysql_real_connect(conn, "localhost", "root", db_password, 
                          "users", 0, NULL, 0) == NULL) {
        return 0;
    }
    
    mysql_close(conn);
    return 1;
}
```

#### 2. 使用密钥管理系统
对于更高级别的安全需求，集成密钥管理系统（KMS）或密码保险库。
```c
// 示例：从密钥管理系统获取密码
char* get_password_from_kms(const char* key_id) {
    // 调用KMS API获取密码
    // 这里只是示例，实际实现需要具体的KMS库
    return kms_get_secret(key_id);
}

int secure_authenticate() {
    char *password = get_password_from_kms("db_password_key");
    if (!password) {
        return 0;
    }
    
    // 使用获取的密码
    MYSQL *conn = mysql_init(NULL);
    if (mysql_real_connect(conn, "localhost", "root", password, 
                          "users", 0, NULL, 0) == NULL) {
        free(password);
        return 0;
    }
    
    // 清理内存中的密码
    memset(password, 0, strlen(password));
    free(password);
    mysql_close(conn);
    return 1;
}
```

#### 3. 运行时密码输入
对于交互式应用程序，在运行时提示用户输入密码。
```c
#include <termios.h>
#include <unistd.h>

char* get_password_input(const char* prompt) {
    static char password[256];
    struct termios old, new;
    
    printf("%s", prompt);
    
    // 关闭回显
    tcgetattr(STDIN_FILENO, &old);
    new = old;
    new.c_lflag &= ~ECHO;
    tcsetattr(STDIN_FILENO, TCSANOW, &new);
    
    fgets(password, sizeof(password), stdin);
    
    // 恢复回显
    tcsetattr(STDIN_FILENO, TCSANOW, &old);
    printf("\n");
    
    // 移除换行符
    password[strcspn(password, "\n")] = 0;
    return password;
}
```

#### 4. 使用安全的字符串处理
确保在内存中处理密码时采用安全措施。
```c
void secure_clear_password(char *password) {
    if (password) {
        memset(password, 0, strlen(password));
    }
}
```
SOLUTION
	reference: <<<REFERENCE
[CWE-259: Use of Hard-coded Password](https://cwe.mitre.org/data/definitions/259.html)
[OWASP Hard-coded Password](https://owasp.org/www-community/vulnerabilities/Use_of_hard-coded_password)
REFERENCE
)

<include('c-user-input')> as $user_input;
mysql_real_connect(*<slice(index=3)> #->?{opcode:const} as $high);
crypt(*<slice(index=1)> #->?{opcode:const} as $high);

alert $high for {
	level: "high",
	type: "vuln",
	title: "C Hard-Coded Password Vulnerability Was Detected",
	title_zh: "检测到C语言硬编码密码漏洞",
	desc: <<<DESC
### 漏洞描述

1. **漏洞原理**
   硬编码密码漏洞是由于在源代码中直接以明文形式存储敏感的认证凭据。攻击者一旦获取源代码或通过逆向工程，就能轻易提取这些凭据，进而非法访问相关系统或服务。

2. **触发场景**
   检测到在数据库连接、密码比较或加密函数中使用了硬编码的字符串常量作为密码参数。
   ```c
   // 危险示例
   mysql_real_connect(conn, "localhost", "user", "hardcoded_password", "db", 0, NULL, 0);
   if (strcmp(input_password, "admin123") == 0) {
       // 登录成功
   }
   ```

3. **潜在影响**
   - 敏感信息泄露，攻击者可获取硬编码的认证凭据。
   - 系统权限滥用，攻击者可直接访问受保护的资源。
   - 合规性问题，违反安全标准和合规性要求。
DESC
	message: "检测到C语言代码中存在硬编码密码，认证凭据以明文形式存储在源代码中",
	solution: <<<SOLUTION
### 修复建议

#### 1. 使用环境变量存储密码
```c
const char *password = getenv("DB_PASSWORD");
if (!password) {
    fprintf(stderr, "Password not found in environment\n");
    return -1;
}
mysql_real_connect(conn, "localhost", "user", password, "db", 0, NULL, 0);
```

#### 2. 使用配置文件
```c
// 从安全的配置文件读取密码
FILE *config = fopen("/etc/myapp/config.conf", "r");
char password[256];
if (config && fgets(password, sizeof(password), config)) {
    password[strcspn(password, "\n")] = 0; // 移除换行符
    fclose(config);
}
```

#### 3. 运行时密码输入
```c
char password[256];
printf("Enter password: ");
fgets(password, sizeof(password), stdin);
password[strcspn(password, "\n")] = 0;
```

#### 4. 密码处理后清理内存
```c
// 使用完密码后清理内存
memset(password, 0, strlen(password));
```
SOLUTION
	risk: "硬编码密码",
	name: "high",
}

desc(
	lang: c
	alert_high: 1
	'file://unsafe_password.c': <<<UNSAFE
#include <stdio.h>
#include <string.h>
#include <mysql/mysql.h>
#include <sqlite3.h>

int authenticate_database() {
    // 硬编码的数据库密码
    const char *db_password = "admin123";
    
    MYSQL *conn = mysql_init(NULL);
    if (mysql_real_connect(conn, "localhost", "root", db_password, 
                          "users", 0, NULL, 0) == NULL) {
        printf("Database connection failed\n");
        return 0;
    }
    
    mysql_close(conn);
    return 1;
}

int authenticate_user(const char *username, const char *password) {
    // 硬编码的管理员密码
    if (strcmp(username, "admin") == 0 && 
        strcmp(password, "hardcoded_admin_password") == 0) {
        return 1;
    }
    
    // 硬编码的普通用户密码
    if (strncmp(password, "user123", 7) == 0) {
        return 1;
    }
    
    return 0;
}

int encrypt_data(const char *data) {
    // 硬编码的加密密钥
    char *encrypted = crypt(data, "hardcoded_salt");
    if (encrypted) {
        printf("Encrypted: %s\n", encrypted);
        return 1;
    }
    return 0;
}

int main() {
    authenticate_database();
    authenticate_user("admin", "test");
    encrypt_data("sensitive_data");
    return 0;
}
UNSAFE
	'safefile://safe_password.c': <<<SAFE
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <mysql/mysql.h>
#include <sqlite3.h>

int authenticate_database() {
    // 从环境变量获取数据库密码
    const char *db_password = getenv("DB_PASSWORD");
    if (!db_password) {
        fprintf(stderr, "Database password not found in environment\n");
        return 0;
    }
    
    MYSQL *conn = mysql_init(NULL);
    if (mysql_real_connect(conn, "localhost", "root", db_password, 
                          "users", 0, NULL, 0) == NULL) {
        printf("Database connection failed\n");
        return 0;
    }
    
    mysql_close(conn);
    return 1;
}

int authenticate_user(const char *username, const char *password) {
    // 从配置文件或数据库读取密码哈希进行比较
    const char *admin_hash = getenv("ADMIN_PASSWORD_HASH");
    if (!admin_hash) {
        return 0;
    }
    
    if (strcmp(username, "admin") == 0) {
        // 这里应该使用安全的密码哈希比较
        char *input_hash = crypt(password, admin_hash);
        if (input_hash && strcmp(input_hash, admin_hash) == 0) {
            return 1;
        }
    }
    
    return 0;
}

int encrypt_data(const char *data) {
    // 从环境变量获取加密盐
    const char *salt = getenv("ENCRYPTION_SALT");
    if (!salt) {
        fprintf(stderr, "Encryption salt not found\n");
        return 0;
    }
    
    char *encrypted = crypt(data, salt);
    if (encrypted) {
        printf("Encrypted: %s\n", encrypted);
        return 1;
    }
    return 0;
}

int main() {
    authenticate_database();
    authenticate_user("admin", "test");
    encrypt_data("sensitive_data");
    return 0;
}
SAFE
)
