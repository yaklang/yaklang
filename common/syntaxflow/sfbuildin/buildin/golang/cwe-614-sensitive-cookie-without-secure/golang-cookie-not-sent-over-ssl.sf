desc(
	title: "Detect Golang Cookie Not Sent Over SSL Vulnerability"
	title_zh: "检测Golang Cookie未通过SSL发送漏洞"
	type: audit
	level: low
	risk: "info-exposure"
	desc: <<<DESC
### 漏洞描述

1. **漏洞原理**
   当Golang应用程序在使用`net/http`包的`SetCookie`方法设置Cookie时，若未将`Secure`属性设置为`true`，则该Cookie可能会通过非HTTPS连接传输。这使得敏感的会话信息可能被中间人攻击者截获，导致会话劫持或其他安全风险。`Secure`属性确保Cookie只能通过加密的HTTPS连接传输，提供了额外的安全层。

2. **触发场景**
   ```go
   http.SetCookie(writer, &http.Cookie{
       Name:    "sessionID",
       Value:   "fixedSessionID",
       Path:    "/",
       Expires: time.Now().Add(15 * time.Minute),
       Secure: false, // 漏洞点：Secure未设置为true
   })
   ```
   攻击者可以通过中间人攻击或网络嗅探获取未加密的Cookie，进而伪装成合法用户。

3. **潜在影响**
   - 会话劫持：攻击者可以窃取用户会话Cookie，冒充用户身份。
   - 敏感信息泄露：Cookie中可能包含用户凭证或其他敏感信息。
   - 违反安全合规要求：如PCI DSS等标准要求敏感数据必须加密传输。
DESC
	rule_id: "b46ed5a9-041f-470a-8823-980191db0a2f"
	solution: <<<SOLUTION
### 修复建议

#### 1. 始终启用Secure属性
   在设置Cookie时，确保`Secure`属性设置为`true`，强制Cookie仅通过HTTPS传输。
   ```go
   http.SetCookie(writer, &http.Cookie{
       Name:    "sessionID",
       Value:   "fixedSessionID",
       Path:    "/",
       Expires: time.Now().Add(15 * time.Minute),
       Secure: true, // 修复：启用Secure
   })
   ```

#### 2. 结合HttpOnly属性
   同时启用`HttpOnly`属性，防止JavaScript访问Cookie，降低XSS攻击的影响。
   ```go
   http.SetCookie(writer, &http.Cookie{
       Name:     "sessionID",
       Value:    "fixedSessionID",
       Path:     "/",
       Expires:  time.Now().Add(15 * time.Minute),
       Secure:   true,
       HttpOnly: true, // 增加HttpOnly保护
   })
   ```

#### 3. 强制HTTPS
   配置Web服务器强制使用HTTPS，避免任何HTTP请求。例如，在Nginx中：
   ```nginx
   server {
       listen 80;
       server_name example.com;
       return 301 https://$host$request_uri;
   }
   ```

#### 4. 使用安全框架
   对于大型应用，考虑使用安全框架（如Gorilla Sessions）自动处理Cookie安全属性。
SOLUTION
	reference: <<<REFERENCE
[OWASP Secure Flag](https://owasp.org/www-community/controls/SecureFlag)
[CWE-614: Sensitive Cookie Without 'Secure' Attribute](https://cwe.mitre.org/data/definitions/614.html)
REFERENCE
)

http?{<fullTypeName>?{have: "net/http"}} as $http;

$http.SetCookie as $cookie
$cookie(* as $param);

$param #{
    until: "*.Secure"
}-> as $sink

$sink.Secure?{have: false} as $false
$sink.Secure?{have: true} as $true

$true -->?{have: SetCookie}<getCallee> as $safe

$false as $low
$cookie - $safe as $low

alert $low for {
	solution: <<<SOLUTION
	risk: "info-exposure",
### 修复建议

#### 1. 设置Secure标志
确保Cookie在传输时仅通过HTTPS发送，防止敏感信息被中间人攻击窃取。

```go
// 修复代码示例
http.SetCookie(writer, &http.Cookie{
    Name:    "sessionID",
    Value:   sessionID,
    Path:    "/",
    Expires: time.Now().Add(15 * time.Minute),
    Secure: true, // 添加Secure标志
})
```

#### 2. 使用HttpOnly标志
添加HttpOnly标志可以防止JavaScript访问Cookie，降低XSS攻击的风险。

```go
http.SetCookie(writer, &http.Cookie{
    Name:     "sessionID",
    Value:    sessionID,
    Path:     "/",
    Expires:  time.Now().Add(15 * time.Minute),
    Secure:   true,
    HttpOnly: true, // 添加HttpOnly标志
})
```

SOLUTION
	desc: <<<DESC
### 漏洞描述

1. **漏洞原理**
   由于Cookie未设置Secure标志，攻击者可以通过中间人攻击（如ARP欺骗、DNS欺骗）窃取用户的会话Cookie，从而导致会话劫持。

2. **触发场景**
   ```go
   http.SetCookie(writer, &http.Cookie{
       Name:    "sessionID",
       Value:   sessionID,
       Path:    "/",
       Expires: time.Now().Add(15 * time.Minute),
       // Secure: true,
   })
   ```
   在上述代码中，Cookie的Secure标志未被设置，即使在HTTPS连接下，攻击者仍然可以通过非加密通道获取Cookie。

3. **潜在影响**
   - 攻击者可以劫持用户会话，冒充用户执行操作。
   - 敏感信息泄露，如用户的身份验证凭证。
   - 可能导致进一步的攻击，如数据篡改或权限提升。
DESC
	level: "low",
	type: "vuln",
	title: "Golang Cookie Not Sent Over SSL Vulnerability Was Detected",
	title_zh: "检测到Golang Cookie未通过SSL发送漏洞",
	message: "检测到Golang Cookie未通过SSL发送漏洞，可能导致会话信息被窃取",
	risk: "会话安全问题",
	name: "low",
}

desc(
	lang: golang
	alert_low: 1
	'file://unsafe.go': <<<UNSAFE
package vulinbox

import (
	_ "embed"
	"encoding/json"
	"github.com/yaklang/yaklang/common/log"
	"github.com/yaklang/yaklang/common/utils"
	"net/http"
	"strconv"
	"strings"
	"text/template"
	"time"
)

//go:embed html/mall/vul_mall_register.html
var mallRegisterPage []byte

//go:embed html/mall/vul_mall_login.html
var mallLoginPage []byte

//go:embed html/mall/vul_mall_userProfile.html
var mallUserProfilePage []byte

func (s *VulinServer) mallUserRoute() {
	// var router = s.router
	// malloginGroup := router.PathPrefix("/mall").Name("购物商城").Subrouter()
	mallloginRoutes := []*VulInfo{
		//登陆功能
		{
			DefaultQuery: "",
			Path:         "/user/login",
			// Title:        "商城登陆",
			Handler: func(writer http.ResponseWriter, request *http.Request) {
				if request.Method == http.MethodGet {
					// 返回登录页面
					writer.Header().Set("Content-Type", "text/html")
					writer.Write(mallLoginPage)
					return
				}

				// 解析请求体中的 JSON 数据
				var loginRequest struct {
					Username string 
					Password string 
				}

				err := json.NewDecoder(request.Body).Decode(&loginRequest)
				if err != nil {
					writer.WriteHeader(http.StatusBadRequest)
					writer.Write([]byte("Invalid request"))
					return
				}

				username := loginRequest.Username
				password := loginRequest.Password

				// 在这里执行用户登录逻辑，验证用户名和密码是否正确
				// 检查数据库中是否存在匹配的用户信息
				if username == "" || password == "" {
					writer.WriteHeader(400)
					writer.Write([]byte("username or password cannot be empty"))
					return
				}
				// sql 注入 , 万能密码
				users, err := s.database.GetUserByUnsafe(username, password)
				if err != nil {
					writer.WriteHeader(500)
					writer.Write([]byte("internal error: " + err.Error()))
					return
				}
				user := users[0]
				userMap := utils.InterfaceToMap(user)
				id, err := strconv.Atoi(userMap["id"][0])
				if err != nil {
					id = 0
				}
				// 假设验证通过，返回登录成功消息
				response := struct {
					Id      uint  
					Success bool   
					Message string
				}{
					Id:      uint(id),
					Success: true,
					Message: "Login successful",
				}
				var sessionID = "fixedSessionID"
				// session, err := user.CreateSession(s.database)
				if err != nil {
					return
				}
				http.SetCookie(writer, &http.Cookie{
					Name:    "sessionID",
					Value:   sessionID,
					Path:    "/",
					Expires: time.Now().Add(15 * time.Minute),

					// Secure: true,
				})
				writer.Header().Set("Content-Type", "application/json")
				err = json.NewEncoder(writer).Encode(response)
				if err != nil {
					writer.Write([]byte(err.Error()))
					writer.WriteHeader(http.StatusInternalServerError)
					return
				}
				writer.WriteHeader(http.StatusOK)
				return
			},
			RiskDetected: true,
		},
	}

	for _, v := range mallloginRoutes {
		addRouteWithVulInfo(MallGroup, v)
	}

}
UNSAFE
	'safefile://safe.go': <<<SAFE
package vulinbox

import (
	_ "embed"
	"encoding/json"
	"github.com/yaklang/yaklang/common/log"
	"github.com/yaklang/yaklang/common/utils"
	"net/http"
	"strconv"
	"strings"
	"text/template"
	"time"
)

//go:embed html/mall/vul_mall_register.html
var mallRegisterPage []byte

//go:embed html/mall/vul_mall_login.html
var mallLoginPage []byte

//go:embed html/mall/vul_mall_userProfile.html
var mallUserProfilePage []byte

func (s *VulinServer) mallUserRoute() {
	// var router = s.router
	// malloginGroup := router.PathPrefix("/mall").Name("购物商城").Subrouter()
	mallloginRoutes := []*VulInfo{
		//登陆功能
		{
			DefaultQuery: "",
			Path:         "/user/login",
			// Title:        "商城登陆",
			Handler: func(writer http.ResponseWriter, request *http.Request) {
				if request.Method == http.MethodGet {
					// 返回登录页面
					writer.Header().Set("Content-Type", "text/html")
					writer.Write(mallLoginPage)
					return
				}

				// 解析请求体中的 JSON 数据
				var loginRequest struct {
					Username string 
					Password string 
				}

				err := json.NewDecoder(request.Body).Decode(&loginRequest)
				if err != nil {
					writer.WriteHeader(http.StatusBadRequest)
					writer.Write([]byte("Invalid request"))
					return
				}

				username := loginRequest.Username
				password := loginRequest.Password

				// 在这里执行用户登录逻辑，验证用户名和密码是否正确
				// 检查数据库中是否存在匹配的用户信息
				if username == "" || password == "" {
					writer.WriteHeader(400)
					writer.Write([]byte("username or password cannot be empty"))
					return
				}
				// sql 注入 , 万能密码
				users, err := s.database.GetUserByUnsafe(username, password)
				if err != nil {
					writer.WriteHeader(500)
					writer.Write([]byte("internal error: " + err.Error()))
					return
				}
				user := users[0]
				userMap := utils.InterfaceToMap(user)
				id, err := strconv.Atoi(userMap["id"][0])
				if err != nil {
					id = 0
				}
				// 假设验证通过，返回登录成功消息
				response := struct {
					Id      uint  
					Success bool   
					Message string
				}{
					Id:      uint(id),
					Success: true,
					Message: "Login successful",
				}
				var sessionID = "fixedSessionID"
				// session, err := user.CreateSession(s.database)
				if err != nil {
					return
				}
				http.SetCookie(writer, &http.Cookie{
					Name:    "sessionID",
					Value:   sessionID,
					Path:    "/",
					Expires: time.Now().Add(15 * time.Minute),

					Secure: true,
				})
				writer.Header().Set("Content-Type", "application/json")
				err = json.NewEncoder(writer).Encode(response)
				if err != nil {
					writer.Write([]byte(err.Error()))
					writer.WriteHeader(http.StatusInternalServerError)
					return
				}
				writer.WriteHeader(http.StatusOK)
				return
			},
			RiskDetected: true,
		},
	}

	for _, v := range mallloginRoutes {
		addRouteWithVulInfo(MallGroup, v)
	}

}
SAFE
)

