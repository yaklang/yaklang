desc(
	title: "Check Golang LDAP Injection Vulnerability"
	type: audit
	level: high
	risk: "ldap"
	desc: <<<DESC
### 漏洞描述

1. **漏洞原理**
   LDAP注入攻击是一种常见的安全漏洞，当应用程序通过用户输入直接构造LDAP查询时可能发生。如果未对用户输入进行严格的过滤或转义，攻击者可通过构造恶意的输入篡改LDAP查询逻辑，从而实现非授权访问、数据泄露或其他安全风险。

2. **触发场景**
   // 存在漏洞的代码示例
   ```go
   username := r.URL.Query().Get("username")
   searchRequest := ldap.NewSearchRequest(
       "ou=users,dc=example,dc=com",
       ldap.ScopeWholeSubtree,
       ldap.NeverDerefAliases,
       0, 0, false,
       fmt.Sprintf("(uid=%s)", username), // 用户输入直接拼接，存在注入点
       []string{"dn"},
       nil,
   )
   ```
   攻击者可以通过提交`*))(|(uid=*))`这样的恶意输入来破坏LDAP查询逻辑，绕过认证或获取未经授权的数据。

3. **潜在影响**
   - 敏感数据（如用户凭证、隐私信息）被窃取。
   - 未授权访问系统资源。
   - 数据完整性受损，甚至可能引发连锁攻击。

### 规则目的
该规则用于审计Go语言代码中可能导致LDAP注入漏洞的安全问题。通过识别危险的LDAP查询构造方式，帮助开发者定位并修复潜在的注入点，提升程序安全性。

### 规则详细
- 覆盖了常见的`ldap.NewSearchRequest`方法调用。
- 检测直接拼接用户输入到LDAP查询中的行为。
- 提供参考代码样例以指导如何使用参数化或转义机制避免注入。
DESC
	rule_id: "2b4b5d82-965c-4e2c-ac36-72d950f9143e"
	title_zh: "检测Golang LDAP注入漏洞"
	solution: <<<SOLUTION
### 修复建议

#### 1. 使用转义函数处理用户输入
Go的`gopkg.in/ldap.v2`库提供了`ldap.EscapeFilter`函数，可以用来转义LDAP查询中的特殊字符，避免注入攻击。
```go
import (
    "fmt"
    "net/http"
    ldap "gopkg.in/ldap.v2"
)

func authenticate(w http.ResponseWriter, r *http.Request) bool {
    username := r.URL.Query().Get("username")
    escapedUsername := ldap.EscapeFilter(username) // 转义用户输入

    searchRequest := ldap.NewSearchRequest(
        "ou=users,dc=example,dc=com",
        ldap.ScopeWholeSubtree,
        ldap.NeverDerefAliases,
        0, 0, false,
        fmt.Sprintf("(uid=%s)", escapedUsername), // 使用转义后的值
        []string{"dn"},
        nil,
    )
    // 执行查询...
}
```

#### 2. 实施严格的输入验证
在将用户输入传递给LDAP查询之前，应对其进行严格的验证，例如限定为字母数字字符。
```go
func isValidUsername(username string) bool {
    for _, r := range username {
        if !((r >= 'a' && r <= 'z') || (r >= 'A' && r <= 'Z') || (r >= '0' && r <= '9')) {
            return false
        }
    }
    return true
}

if !isValidUsername(username) {
    log.Printf("Invalid username format: %s", username)
    return false
}
```

#### 3. 避免动态拼接查询条件
尽量使用静态过滤器或构建安全的查询结构，减少手动字符串拼接的风险。
```go
searchRequest := ldap.NewSearchRequest(
    "ou=users,dc=example,dc=com",
    ldap.ScopeWholeSubtree,
    ldap.NeverDerefAliases,
    0, 0, false,
    "(uid=testuser)", // 固定查询条件
    []string{"dn"},
    nil,
)
```

以上方法能够有效防止LDAP注入攻击，提升应用安全性。
SOLUTION
	reference: <<<REFERENCE
https://cheatsheetseries.owasp.org/cheatsheets/LDAP_Injection_Prevention_Cheat_Sheet.html
https://cwe.mitre.org/data/definitions/90.html
REFERENCE
)

<include('golang-ldap-sink')> as $sink;

http?{<fullTypeName>?{have: 'net/http'}} as $entry;
$entry.ResponseWriter as $input
$entry.Request as $input

$sink.Search( * #-> as $param)
$param & $input as $high

alert $high for {
	level: "high",
	type: "vuln",
	title: "Golang LDAP Injection Vulnerability Was Detected",
	title_zh: "检测到Go语言LDAP注入漏洞",
	name: "high",
	message: "检测到Go语言LDAP注入漏洞，并且从数据源（source）到污染汇聚点（sink）间，没有发现任何过滤函数信息。",
	solution: <<<SOLUTION
### 修复建议
#### 1. 使用转义函数
   在构建LDAP查询时，对用户输入进行转义以防止恶意输入篡改逻辑。
   ```go
   import "gopkg.in/ldap.v2"

   escapedUsername := ldap.EscapeFilter(username)
   searchRequest := ldap.NewSearchRequest(
       "ou=users,dc=example,dc=com",
       ldap.ScopeWholeSubtree,
       ldap.NeverDerefAliases,
       0, 0, false,
       fmt.Sprintf("(uid=%s)", escapedUsername),
       []string{"dn"},
       nil,
   )
   ```
#### 2. 输入合法性校验
   对用户输入实施类型、格式或范围限制，拒绝非法输入。
   ```go
   func isValidUsername(username string) bool {
       for _, r := range username {
           if !((r >= 'a' && r <= 'z') || (r >= 'A' && r <= 'Z') || (r >= '0' && r <= '9') || r == '_') {
               return false
           }
       }
       return true
   }
   if !isValidUsername(username) {
       return errors.New("用户名包含非法字符")
   }
   ```
#### 3. 使用参数化或构建器模式
   尽量避免直接拼接字符串，而是通过程序化方式构建LDAP过滤器。
   ```go
   func escapeLDAPFilterForBuilder(filter string) string {
       runes := []rune(filter)
       var b strings.Builder
       for _, r := range runes {
           switch r {
           case '(', ')', '\\', '*', '\u0000':
               fmt.Fprintf(&b, "\\%02x", r)
           default:
               b.WriteRune(r)
           }
       }
       return b.String()
   }
   escapedUsername := escapeLDAPFilterForBuilder(username)
   ```
SOLUTION
	risk: "LDAP注入",
	desc: <<<DESC
### 漏洞描述
1. **漏洞原理**
   LDAP注入攻击发生在应用程序通过用户输入直接构造LDAP查询时。如果用户输入未被正确过滤或转义，攻击者可以注入恶意的LDAP语句，导致未授权访问、数据泄露或其他安全风险。
2. **触发场景**
   // 存在漏洞的代码示例
   ```go
   username := r.URL.Query().Get("username")
   searchRequest := ldap.NewSearchRequest(
       "ou=users,dc=example,dc=com",
       ldap.ScopeWholeSubtree,
       ldap.NeverDerefAliases,
       0, 0, false,
       fmt.Sprintf("(uid=%s)", username), // 潜在的注入点
       []string{"dn"},
       nil,
   )
   ```
   攻击者可以通过输入特殊字符（如 `*` 或 `)`）绕过逻辑，获取敏感信息或执行非预期操作。
3. **潜在影响**
   - 数据库敏感信息（如用户凭证、隐私数据）被窃取。
   - 执行任意LDAP语句（如搜索、修改数据或权限提升）。
   - 通过LDAP提权进一步渗透至服务器或其他系统组件。
DESC
}

desc(
	lang: golang
	alert_high: 1
	'file://unsafe.go': <<<UNSAFE
package main

import (
	"fmt"
	"log"

	"net/http"
	ldap "gopkg.in/ldap.v2"
)

func authenticate(w http.ResponseWriter, r *http.Request) bool {
	username := r.URL.Query().Get("username")
	password := r.URL.Query().Get("password")

	l, err := ldap.Dial("tcp", "ldap.example.com:389")
	if err != nil {
		log.Fatalf("Failed to connect to LDAP server: %s", err)
	}
	defer l.Close()

	// 绑定到 LDAP 服务器
	err = l.Bind("cn=admin,dc=example,dc=com", password)
	if err != nil {
		log.Fatalf("Failed to bind: %s", err)
	}

	// LDAP 查询构造
	searchRequest := ldap.NewSearchRequest(
		"ou=users,dc=example,dc=com",
		ldap.ScopeWholeSubtree,
		ldap.NeverDerefAliases,
		0, 0, false,
		fmt.Sprintf("(uid=%s)", username), // 潜在的注入点
		[]string{"dn"},
		nil,
	)

	// 执行查询
	_, err = l.Search(searchRequest)
	if err != nil {
		log.Fatal(err)
	}

	// 这里省略了密码验证的具体实现
	return true
}
UNSAFE
	'safefile://safe.go': <<<SAFE
package main

import (
	"fmt"
	"log"

	"net/http"
	ldap "gopkg.in/ldap.v2"
)

func authenticate(w http.ResponseWriter, r *http.Request) bool {
	username := "username"
	password := "password"

	l, err := ldap.Dial("tcp", "ldap.example.com:389")
	if err != nil {
		log.Fatalf("Failed to connect to LDAP server: %s", err)
	}
	defer l.Close()

	// 绑定到 LDAP 服务器
	err = l.Bind("cn=admin,dc=example,dc=com", password)
	if err != nil {
		log.Fatalf("Failed to bind: %s", err)
	}

	// LDAP 查询构造
	searchRequest := ldap.NewSearchRequest(
		"ou=users,dc=example,dc=com",
		ldap.ScopeWholeSubtree,
		ldap.NeverDerefAliases,
		0, 0, false,
		fmt.Sprintf("(uid=%s)", username), // 潜在的注入点
		[]string{"dn"},
		nil,
	)

	// 执行查询
	_, err = l.Search(searchRequest)
	if err != nil {
		log.Fatal(err)
	}

	// 这里省略了密码验证的具体实现
	return true
}

SAFE
	"safefile://SafeLdapAuthEscape.go": <<<SAFE
package main

import (
	"fmt"
	"log"

	ldap "gopkg.in/ldap.v2"
)

func authenticateWithStaticFilter(username, password string) bool {
	l, err := ldap.Dial("tcp", "ldap.example.com:389")
	if err != nil {
		log.Fatalf("Failed to connect to LDAP server: %s", err)
	}
	defer l.Close()

	// Bind to the LDAP server
	err = l.Bind("cn=admin,dc=example,dc=com", password)
	if err != nil {
		log.Printf("Failed to bind: %s", err)
		return false
	}

	// Using a parameterized or static filter if the library supports it, or constructing filters carefully.
	// In gopkg.in/ldap.v2, filters can be built using specific filter structures, though for simple cases
	// sprintf is often used with proper escaping.
	// For demonstration, limiting the filter to a known safe format and validating input beforehand.

	// This example assumes 'username' is already validated to be alphanumeric for simplicity,
	// avoiding the direct string formatting injection point even if no explicit escape function is used.
	// In a real application, more robust input validation (e.g., regex, allowlist) should be in place.
	if !isValidUsername(username) {
		log.Printf("Invalid username format: %s", username)
		return false
	}

	searchRequest := ldap.NewSearchRequest(
		"ou=users,dc=example,dc=com",
		ldap.ScopeWholeSubtree,
		ldap.NeverDerefAliases,
		0, 0, false,
		fmt.Sprintf("(uid=%s)", username), // Assuming username is pre-validated to be safe
		[]string{"dn"},
		nil,
	)

	// Execute search
	searchResult, err := l.Search(searchRequest)
	if err != nil {
		log.Printf("LDAP search failed: %s", err)
		return false
	}
	return len(searchResult.Entries) > 0
}

// isValidUsername is a placeholder for actual strict input validation.
// This is crucial for preventing injection when direct string formatting is used.
func isValidUsername(username string) bool {
	// Example: only allows alphanumeric characters and underscores
	for _, r := range username {
		if !((r >= 'a' && r <= 'z') || (r >= 'A' && r <= 'Z') || (r >= '0' && r <= '9') || r == '_') {
			return false
		}
	}
	return true
}

func main() {
	// Example of using the (hypothetically) pre-validated username
	if authenticateWithStaticFilter("valid_user", "password") {
		fmt.Println("Authentication successful with static filter.")
	} else {
		fmt.Println("Authentication failed with static filter.")
	}

	// This would be rejected by isValidUsername, not leading to injection
	if authenticateWithStaticFilter("invalid)(*user", "password") {
		fmt.Println("This should not be success.")
	} else {
		fmt.Println("Authentication failed for invalid user format.")
	}
}
SAFE
	"safefile://SafeLdapAuthWithFilterBuilder.go": <<<SAFE
package main

import (
	"fmt"
	"log"

	ldap "gopkg.in/ldap.v2"
)

// Although gopkg.in/ldap.v2 doesn't have a direct 'parameterized query' in the SQL sense,
// building filters programmatically can offer more safety than raw string concatenation
// if the library handles the underlying escaping.
// This example is conceptual, demonstrating an approach where the filter object itself
// helps to ensure safety by not directly exposing string manipulation injection points.

func authenticateWithFilterBuilder(username, password string) bool {
	l, err := ldap.Dial("tcp", "ldap.example.com:389")
	if err != nil {
		log.Fatalf("Failed to connect to LDAP server: %s", err)
	}
	defer l.Close()

	// Bind to the LDAP server
	err = l.Bind("cn=admin,dc=example,dc=com", password)
	if err != nil {
		log.Printf("Failed to bind: %s", err)
		return false
	}
	
	// This part is conceptual. In gopkg.in/ldap.v2, you primarily use escaped strings
	// for filters, but some newer libraries or wrappers might offer a more object-oriented
	// way to build filters that inherently escapes values.
	// For the purpose of showing a safe pattern, we assume a `BuildSafeFilter` equivalent exists.
	// The `ldap.NewSearchRequest` *does* take a string filter, so this method relies on
	// the `escapeLDAPFilter` function or similar robust external validation.

	// For a practical safe example with gopkg.in/ldap.v2, it comes back to proper escaping.
	// So this example is more about demonstrating the *concept* of building filters safely
	// using a hypothetical builder pattern or strong input validation prior to string formatting,
	// rather than a specific `gopkg.in/ldap.v2` feature that eliminates sprintf entirely.

	// Correct approach in this specific library context is still robust escaping (as in SafeLdapAuthEscape.go)
	// or strict input validation (as in SafeLdapAuthStaticFilter.go) before `fmt.Sprintf`.

	// Re-using the escape function from the first example as the best practice with this library.
	escapedUsername := escapeLDAPFilterForBuilder(username)

	searchRequest := ldap.NewSearchRequest(
		"ou=users,dc=example,dc=com",
		ldap.ScopeWholeSubtree,
		ldap.NeverDerefAliases,
		0, 0, false,
		fmt.Sprintf("(uid=%s)", escapedUsername), // Still uses sprintf, but with escaped input.
		[]string{"dn"},
		nil,
	)

	// Execute search
	searchResult, err := l.Search(searchRequest)
	if err != nil {
		log.Printf("LDAP search failed: %s", err)
		return false
	}
	return len(searchResult.Entries) > 0
}

// escapeLDAPFilterForBuilder is essentially the same as previous escape function,
// emphasizing that with `gopkg.in/ldap.v2`, manual escaping is key.
func escapeLDAPFilterForBuilder(filter string) string {
	runes := []rune(filter)
	var b strings.Builder
	for _, r := range runes {
		switch r {
		case '(', ')', '\\', '*', '\u0000':
			fmt.Fprintf(&b, "\\%02x", r)
		default:
			b.WriteRune(r)
		}
	}
	return b.String()
}

func main() {
	if authenticateWithFilterBuilder("testuser(safely)", "password") {
		fmt.Println("Authentication successful with filter builder concept.")
	} else {
		fmt.Println("Authentication failed with filter builder concept.")
	}
}
SAFE
)
