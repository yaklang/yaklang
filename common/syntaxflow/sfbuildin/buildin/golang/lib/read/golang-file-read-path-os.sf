desc(
	title: "Audit Golang File Read Path Function"
	type: audit
	level: info
	lib: 'golang-file-read-path-os'
	desc: <<<DESC
### 规则描述

1. **风险原理**
   路径穿越漏洞（Path Traversal）是由于应用程序未对用户输入的文件路径进行严格的验证或过滤，攻击者可通过构造特殊输入访问系统中未经授权的文件。这类漏洞通常发生在程序直接使用用户输入作为文件路径参数的情况下，例如通过HTTP请求获取文件名并直接传递给文件操作函数。如果未限制文件路径的范围，攻击者可能利用`../`等路径分隔符实现目录跳转，从而访问敏感信息或破坏关键系统文件。

2. **触发场景**
   ```go
   package main
   import (
       "fmt"
       "net/http"
       "os"
   )

   func readFile(w http.ResponseWriter, r *http.Request) {
       filePath := r.URL.Query().Get("file") // 获取用户输入的文件路径
       data, err := os.ReadFile(filePath)   // 直接使用用户输入作为文件路径
       if err != nil {
           fmt.Fprintf(w, "Error: %v", err)
           return
       }
       fmt.Fprintf(w, "File content: %s", data)
   }

   func main() {
       http.HandleFunc("/read", readFile)
       http.ListenAndServe(":8080", nil)
   }
   ```
   在上述代码中，用户可以通过`?file=../../etc/passwd`这样的输入读取系统文件，导致敏感数据泄露。

3. **潜在影响**
   - 敏感数据泄露：攻击者可以读取系统配置文件、数据库凭证或其他机密信息。
   - 系统完整性受损：攻击者可能删除或篡改关键文件，导致服务中断。
   - 恶意代码执行：在某些情况下，攻击者可利用文件读取漏洞结合其他漏洞进一步渗透系统。

### 1.规则目的
该规则用于审计Golang代码中文件路径读取相关的安全风险，主要检查程序是否直接读取用户输入的文件路径且未经验证其合法性，可能导致路径穿越漏洞。

### 2.规则详细
1. **覆盖高危文件读取函数**
   检测以下Golang文件读取相关函数：
   `os.ReadFile`, `ioutil.ReadFile`。

2. **定位潜在风险点**
   - 用户输入直接作为文件路径参数的代码段。
   - 文件路径未经过严格验证或白名单机制。

3. **示例代码片段**
   触发规则的代码通常表现为将用户输入直接拼接到文件路径变量中，而未实施任何过滤或验证逻辑。
DESC
	rule_id: "a41bacfd-ec4d-4cbc-94cc-f189e2630d06"
	solution: <<<SOLUTION
### 修复建议

#### 1. 对用户输入进行严格验证
确保用户输入的文件路径位于预设的安全目录内，并通过白名单机制限制可访问的文件。例如，仅允许访问特定目录下的文件，而拒绝访问上级目录。
```go
package main
import (
    "fmt"
    "net/http"
    "path/filepath"
    "strings"
)

func readValidatedFile(w http.ResponseWriter, r *http.Request) {
    requestedFile := r.URL.Query().Get("file")
    filename := filepath.Base(requestedFile) // 只取文件名部分，防止路径分隔符

    // 白名单机制
    allowedFiles := map[string]bool{
        "document.txt": true,
        "report.pdf":   true,
    }

    if !allowedFiles[filename] {
        http.Error(w, "Invalid or denied file request.", http.StatusForbidden)
        return
    }

    safeDirPath := "./users_documents/" // 安全目录
    fullPath := filepath.Join(safeDirPath, filename)
    cleanedPath := filepath.Clean(fullPath) // 清理冗余路径分隔符

    // 检查最终路径是否在安全目录内
    if !isPathInDir(cleanedPath, safeDirPath) {
        http.Error(w, "Path traversal attempt detected.", http.StatusForbidden)
        return
    }

    data, err := ioutil.ReadFile(cleanedPath)
    if err != nil {
        fmt.Fprintf(w, "Error reading requested file: %v", err)
        return
    }
    fmt.Fprintf(w, "Requested file content: %s", data)
}

// 辅助函数：判断路径是否在指定目录内
func isPathInDir(path, dir string) bool {
    rel, err := filepath.Rel(dir, path)
    if err != nil {
        return false
    }
    return !filepath.IsAbs(rel) && !strings.HasPrefix(rel, "..")
}
```

#### 2. 使用硬编码的安全路径
避免直接使用用户输入作为文件路径，而是通过硬编码的方式指定安全路径。例如，仅允许加载特定配置文件。
```go
package main
import (
    "encoding/json"
    "fmt"
    "io/ioutil"
    "path/filepath"
)

type Config struct {
    AppName    string `json:"app_name"`
    Version    string `json:"version"`
    DatabaseURL string `json:"database_url"`
}

func LoadConfig() (*Config, error) {
    configPath := filepath.Join(".", "config", "application.json") // 硬编码安全路径
    data, err := ioutil.ReadFile(configPath)
    if err != nil {
        return nil, fmt.Errorf("failed to read config file %s: %w", configPath, err)
    }

    var cfg Config
    err = json.Unmarshal(data, &cfg)
    if err != nil {
        return nil, fmt.Errorf("failed to unmarshal config: %w", err)
    }
    return &cfg, nil
}
```

#### 3. 引入沙箱环境
在更复杂的应用场景中，可以引入沙箱机制或虚拟文件系统，进一步限制文件访问范围。
SOLUTION
	reference: <<<REFERENCE
[CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal')](https://cwe.mitre.org/data/definitions/22.html)
REFERENCE
	title_zh: "审计Golang文件路径读取功能"
)

os?{<fullTypeName>?{have: 'os'}} as $os
$os.ReadFile(* #-> as $output)

alert $output for {
	title: "Check Golang File Read Path Function",
	title_zh: "审计Golang文件路径读取功能",
	level: "info",
	message: "发现Golang代码中可能存在未经验证的文件路径读取操作，建议进一步审查。",
	solution: <<<SOLUTION
### 修复建议

1. **对用户输入的文件路径进行严格的验证和过滤**
   确保其位于安全的目录内。

2. **使用内置的安全函数或库处理文件读取**
   避免直接使用用户输入作为文件路径。

3. **对文件读取操作实施权限控制**
   确保只有授权用户才能访问特定文件。

SOLUTION
	risk: "信息",
	desc: <<<DESC
### 漏洞描述

1. **漏洞原理**
   由于程序未对用户输入进行严格验证，攻击者可能通过构造特殊路径来绕过限制，导致任意文件读取。

2. **触发场景**
   ```go
   package main
   import (
       "fmt"
       "net/http"
       "os"
   )
   func readFile(w http.ResponseWriter, r *http.Request) {
       filePath := r.URL.Query().Get("file") // 未验证用户输入，直接读取文件
       data, err := os.ReadFile(filePath)
       if err != nil {
           fmt.Fprintf(w, "Error: %v", err)
           return
       }
       fmt.Fprintf(w, "File content: %s", data)
   }
   func main() {
       http.HandleFunc("/read", readFile)
       http.ListenAndServe(":8080", nil)
   }
   ```
   攻击者可以通过输入`../../etc/passwd`等路径读取敏感文件。

3. **潜在影响**
   - 敏感数据泄露（如系统配置、用户凭证）
   - 系统文件损坏或覆盖
   - 潜在的恶意代码执行

DESC
	name: "output",
}

desc(
	lang: golang
	alert_min: 1
	'file://fileread.go': <<<PARAM
package main

import (
    "fmt"
    "net/http"
    "os"
)

func readFile(w http.ResponseWriter, r *http.Request) {
    filePath := r.URL.Query().Get("file")

    // 未验证用户输入，直接读取文件
    data, err := os.ReadFile(filePath)
    if err != nil {
        fmt.Fprintf(w, "Error: %v", err)
        return
    }

    fmt.Fprintf(w, "File content: %s", data)
}

func main() {
    http.HandleFunc("/read", readFile)
    http.ListenAndServe(":8080", nil)
}

PARAM
	"safefile://SafeFilePathHandling.go": <<<CODE
// 使用内置的io/ioutil.ReadFile函数读取明确的白名单文件，而不是用户输入
package main

import (
    "fmt"
    "io/ioutil"
    "net/http"
    "path/filepath"
)

func readSafeFile(w http.ResponseWriter, r *http.Request) {
    // 安全方式1: 读取硬编码的、已知安全的文件路径
    safeFilePath := "./data/config.txt"
    data, err := ioutil.ReadFile(safeFilePath)
    if err != nil {
        fmt.Fprintf(w, "Error reading config file: %v", err)
        return
    }
    fmt.Fprintf(w, "Config content: %s", data)
}

func readValidatedFile(w http.ResponseWriter, r *http.Request) {
    requestedFile := r.URL.Query().Get("file")
    // 安全方式2: 对用户输入进行严格验证，只允许特定文件名且不包含路径分隔符
    // 结合 filepath.Base, 即使输入包含路径，也只会取文件名部分
    // 并在预设的安全目录下查找
    filename := filepath.Base(requestedFile)
    
    // 假设我们有一个白名单文件列表或一个专门存放用户可访问文件的目录
    // 这里仅作为示例，实际应用中需要更严格的白名单或沙箱机制
    allowedFiles := map[string]bool{
        "document.txt": true,
        "report.pdf": true,
    }

    if !allowedFiles[filename] {
        http.Error(w, "Invalid or denied file request.", http.StatusForbidden)
        return
    }

    safeDirPath := "./users_documents/"
    fullPath := filepath.Join(safeDirPath, filename)
    
    // 确保最终路径在预期的安全目录内，并防止路径穿越
    // Clean()可以去除冗余路径分隔符，但不能防止`../`穿越
    // EvalSymlinks, Abs, 或更高级的沙箱机制才是彻底的方法
    cleanedPath := filepath.Clean(fullPath)

    // 进一步检查 cleanedPath 是否依然在 safeDirPath 目录下
    // 否则攻击者可以通过输入 '../' 绕过
    if !isPathInDir(cleanedPath, safeDirPath) {
        http.Error(w, "Path traversal attempt detected.", http.StatusForbidden)
        return
    }

    data, err := ioutil.ReadFile(cleanedPath)
    if err != nil {
        fmt.Fprintf(w, "Error reading requested file: %v", err)
        return
    }
    fmt.Fprintf(w, "Requested file content: %s", data)
}

// Helper function to check if a path is within a given directory
func isPathInDir(path, dir string) bool {
    rel, err := filepath.Rel(dir, path)
    if err != nil {
        return false
    }
    // If rel starts with '..' or contains '..', it's outside the dir
    return !filepath.IsAbs(rel) && !strings.HasPrefix(rel, "..")
}

// 为了使用 isPathInDir，需要引入 strings 包
import "strings"

func main() {
    // 创建一些示例文件和目录以供测试
    os.MkdirAll("./data", 0755)
    ioutil.WriteFile("./data/config.txt", []byte("This is a safe configuration content."), 0644)
    os.MkdirAll("./users_documents", 0755)
    ioutil.WriteFile("./users_documents/document.txt", []byte("User document content."), 0644)
    ioutil.WriteFile("./users_documents/report.pdf", []byte("%PDF-1.4..."), 0644)

    http.HandleFunc("/readConfig", readSafeFile)
    http.HandleFunc("/readFile", readValidatedFile)
    http.ListenAndServe(":8080", nil)
}

CODE
	"safefile://ConfigLoader.go": <<<CODE
// 这是一个假想的配置文件加载器，它不会直接读取任意文件，而是从已知位置加载
package main

import (
	"encoding/json"
	"fmt"
	"io/ioutil"
	"path/filepath"
)

type Config struct {
	AppName    string `json:"app_name"`
	Version    string `json:"version"`
	DatabaseURL string `json:"database_url"`
}

// LoadConfig 从硬编码的配置文件路径加载配置
func LoadConfig() (*Config, error) {
	// 硬编码的配置文件路径，而非用户输入
	configPath := filepath.Join(".", "config", "application.json") 

	data, err := ioutil.ReadFile(configPath)
	if err != nil {
		return nil, fmt.Errorf("failed to read config file %s: %w", configPath, err)
	}

	var cfg Config
	err = json.Unmarshal(data, &cfg)
	if err != nil {
		return nil, fmt.Errorf("failed to unmarshal config: %w", err)
	}

	return &cfg, nil
}

func main() {
	// 示例：创建配置文件
	configDir := filepath.Join(".", "config")
	err := os.MkdirAll(configDir, 0755)
	if err != nil {
		fmt.Println("Failed to create config directory:", err)
		return
	}
	
	exampleConfig := Config{
		AppName:    "MyApp",
		Version:    "1.0.0",
		DatabaseURL: "jdbc:mysql://localhost:3306/mydb",
	}
	
	configBytes, _ := json.MarshalIndent(exampleConfig, "", "  ")
	ioutil.WriteFile(filepath.Join(configDir, "application.json"), configBytes, 0644)

	cfg, err := LoadConfig()
	if err != nil {
		fmt.Println("Error loading config:", err)
		return
	}

	fmt.Printf("Application Name: %s\n", cfg.AppName)
	fmt.Printf("Version: %s\n", cfg.Version)
	fmt.Printf("Database URL: %s\n", cfg.DatabaseURL)
}

import "os" // Add os import for MkdirAll and creating example config file

CODE
)
