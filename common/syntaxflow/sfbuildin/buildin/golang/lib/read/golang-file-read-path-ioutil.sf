desc(
	title: "Audit Golang File Read Path ioutil"
	type: audit
	level: info
	lib: 'golang-file-read-path-ioutil'
	desc: <<<DESC
### 规则描述

1. **规则目的**
   该规则用于审计Golang代码中使用`io/ioutil`包中的文件读取功能。它检测代码中是否使用了`ioutil.ReadAll`或`ioutil.ReadFile`函数，这些操作可能引发文件路径泄露等安全风险。目的是确保文件读取不会暴露敏感文件路径信息，从而避免潜在的攻击面。

2. **触发场景**
   - 使用`ioutil.ReadFile`或`ioutil.ReadAll`时，如果没有对文件路径进行严格的权限校验或验证，可能导致未经授权的文件被读取。
   - 示例代码：
   ```go
   package main
   import (
       "fmt"
       "io/ioutil"
       "log"
   )

   func main() {
       fileName := "sensitive_file.txt" // 敏感文件路径
       content, err := ioutil.ReadFile(fileName)
       if err != nil {
           log.Fatalf("Error reading file: %s", err)
           return
       }
       fmt.Println(string(content))
   }
   ```
   在上述代码中，如果文件名来自于用户输入或者未受限制的路径，攻击者可能通过构造恶意路径访问敏感数据（如`/etc/passwd`）。

3. **潜在影响**
   - 泄露系统关键文件（如配置文件、密码文件等），导致敏感信息暴露。
   - 攻击者可以利用路径控制进一步扩大攻击范围，例如通过路径遍历漏洞访问受限资源。
   - 如果结合其他漏洞（如目录遍历），可能导致更严重的信息泄露问题。
DESC
	rule_id: "46cba5f6-bb9e-492e-9842-980cc8514dbd"
	title_zh: "审计Golang ioutil文件读取方法"
	solution: <<<SOLUTION
### 修复建议

#### 1. 使用`os`包替代`io/ioutil`
   `io/ioutil`已被废弃，推荐使用标准库中的`os`包进行文件读取操作。例如，使用`os.ReadFile`代替`ioutil.ReadFile`。
   ```go
   package main
   import (
       "fmt"
       "os"
   )

   func main() {
       fileName := "example.txt"
       data, err := os.ReadFile(fileName) // 安全的文件读取方式
       if err != nil {
           fmt.Printf("Error reading file: %v\n", err)
           return
       }
       fmt.Println(string(data))
   }
   ```

#### 2. 文件路径合法性检查
   在读取文件之前，应对文件路径进行严格的合法性校验，防止路径穿越等攻击。
   ```go
   package main
   import (
       "fmt"
       "os"
       "path/filepath"
   )

   func main() {
       baseDir := "/tmp/safe_directory" // 基础目录
       requestedFile := "../passwd"      // 恶意路径

       absPath, _ := filepath.Abs(filepath.Join(baseDir, requestedFile))
       if !strings.HasPrefix(absPath, baseDir) {
           fmt.Println("Invalid file path")
           return
       }

       content, err := os.ReadFile(absPath)
       if err != nil {
           fmt.Printf("Error reading file: %v\n", err)
           return
       }
       fmt.Println(string(content))
   }
   ```

#### 3. 设置文件操作权限
   对文件操作设置最小权限原则，确保程序仅能访问必要的文件和目录，降低因误用文件读取导致的风险。

#### 4. 避免直接读取用户可控路径
   不要直接将用户提供的路径作为文件读取的目标，应先对其进行规范化处理并验证其安全性。
   ```go
   package main
   import (
       "fmt"
       "os"
       "path/filepath"
   )

   func main() {
       userProvidedPath := "../../secret_file"
       safeBase := "/var/www/html/uploads"

       resolvedPath, _ := filepath.Abs(userProvidedPath)
       if !strings.HasPrefix(resolvedPath, safeBase) {
           fmt.Println("Access denied.")
           return
       }

       content, err := os.ReadFile(resolvedPath)
       if err != nil {
           fmt.Printf("Error reading file: %v\n", err)
           return
       }
       fmt.Println(string(content))
   }
   ```
SOLUTION
	reference: <<<REFERENCE
[Go io/ioutil Documentation (Deprecated)](https://pkg.go.dev/io/ioutil)
[CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal')](https://cwe.mitre.org/data/definitions/22.html)
REFERENCE
)

ioutil?{<fullTypeName>?{have: 'io/ioutil'}} as $entry

$entry.ReadAll(* #-> as $output) 
$entry.ReadFile(* #-> as $output)

alert $output for {
	title: "Audit Golang ioutil File Read Path",
	title_zh: "审计Golang ioutil文件读取方法",
	level: "info",
	desc: <<<DESC
### 规则目的
该规则用于审计Golang代码中使用的`io/ioutil`包的文件读取功能。它检测`ioutil.ReadAll`或`ioutil.ReadFile`函数的调用，这可能引发文件读取路径泄露等安全风险。

### 规则详细
1. **涉及高危函数**
   - `ioutil.ReadAll`
   - `ioutil.ReadFile`
2. **触发场景**
   ```go
   package main
   import (
       "fmt"
       "io/ioutil"
   )
   func main() {
       content, err := ioutil.ReadFile("example.txt")
       if err != nil {
           fmt.Println("Error:", err)
           return
       }
       fmt.Println(string(content))
   }
   ```
3. **潜在影响**
   - 可能暴露敏感文件路径信息。
   - 不当的文件读取可能导致未授权访问或数据泄露。
4. **推荐改进**
   - 使用`os.ReadFile`替代`ioutil.ReadFile`。
   - 引入路径验证逻辑，防止恶意路径利用（如`../`跳转）。

DESC
	name: "output",
	message: "发现Golang代码中使用ioutil包进行文件读取操作，建议进一步审计以确保不会泄露敏感路径信息。",
	solution: <<<SOLUTION
### 安全建议
#### 1. 避免使用已废弃的`io/ioutil`包
推荐改用更安全的文件读取方法，例如使用`os.ReadFile`函数替代`ioutil.ReadFile`，并结合适当的安全检查。
```go
package main
import (
    "fmt"
    "os"
)
func main() {
    fileName := "example.txt"
    content, err := os.ReadFile(fileName) // 推荐的安全做法
    if err != nil {
        fmt.Printf("Error reading file: %v\n", err)
        return
    }
    fmt.Println(string(content))
}
```
#### 2. 确保路径安全性
在处理文件路径时，应避免直接使用用户提供的路径，建议通过`filepath.Join`构建绝对安全路径，并验证权限。
```go
safePath := filepath.Join("/tmp", "secure_data.txt")
content, err := os.ReadFile(safePath)
if err != nil {
    fmt.Printf("Error reading secure path: %v\n", err)
    return
}
fmt.Println(string(content))
```
SOLUTION
	risk: "信息",
}

desc(
	lang: golang
	alert_min: 1
	'file://fileread.go': <<<PARAM
package main

import (
	"fmt"
	"io/ioutil"
	"log"
	"os"
)

func main() {
	// 要写入的文件名
	fileName := "example.txt"

	// 写入数据到文件
	data := []byte("Hello, Go Programming!\nThis is a simple file I/O example.")
	err := ioutil.WriteFile(fileName, data, 0644) // 0644 是文件权限
	if err != nil {
		log.Fatalf("Error writing to file: %s", err)
		return
	}
	fmt.Println("Data written to file successfully.")

	// 读取文件内容
	content, err := ioutil.ReadFile(fileName)
	if err != nil {
		log.Fatalf("Error reading from file: %s", err)
		return
	}

	// 打印文件内容
	fmt.Println("File content:")
	fmt.Println(string(content))
}

PARAM
	"safefile://SecureFileReader.go": <<<CODE
package main

import (
	"fmt"
	"os"
	"path/filepath"
)

func main() {
	fileName := "safe_example.txt"
	data := []byte("This is safe content.\n")

	// 使用os包写入文件，这不是规则关注点，但完整示例需要
	err := os.WriteFile(fileName, data, 0644)
	if err != nil {
		fmt.Printf("Error writing file: %v\n", err)
		return
	}

	// 反向测试用例1: 使用os.ReadFile，这是推荐的安全做法，不会触发ioutil告警
	content, err := os.ReadFile(fileName)
	if err != nil {
		fmt.Printf("Error reading file with os.ReadFile: %v\n", err)
		return
	}
	fmt.Printf("Content read with os.ReadFile: %s\n", string(content))

	// 反向测试用例2: 使用os.Open和io.ReadAll，绕过ioutil
	f, err := os.Open(fileName)
	if err != nil {
		fmt.Printf("Error opening file with os.Open: %v\n", err)
		return
	}
	defer f.Close()

	// 创建一个字节切片来存储文件内容
	fileContent := make([]byte, 1024)
	n, err := f.Read(fileContent)
	if err != nil && err.Error() != "EOF" {
		fmt.Printf("Error reading file with f.Read: %v\n", err)
		return
	}
	fmt.Printf("Content read with f.Read: %s\n", string(fileContent[:n]))

	// 反向测试用例3: 从网络或其他安全源读取数据，不涉及文件系统
	// 例如：从一个安全的API读取数据，与文件读取无关
	// contentFromNetwork := "This is data from network API"
	// fmt.Println(contentFromNetwork)

	// 反向测试用例4: 使用filepath.Join构建绝对安全路径并使用os.ReadFile
	safePath := filepath.Join("/tmp", "secure_data.txt")
	os.WriteFile(safePath, []byte("Secure data here"), 0644)

	secureContent, err := os.ReadFile(safePath)
	if err != nil {
		fmt.Printf("Error reading secure path with os.ReadFile: %v\n", err)
		return	
	}
	fmt.Printf("Secure content read from %s: %s\n", safePath, string(secureContent))
}

CODE
)
