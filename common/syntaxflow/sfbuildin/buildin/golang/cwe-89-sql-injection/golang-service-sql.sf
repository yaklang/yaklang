desc(
	title: "Detect Golang SQL Injection Vulnerability"
	type: audit
	severity: high
	desc: <<<DESC
### 漏洞描述

1. **漏洞原理**
   SQL注入是由于应用程序未对用户输入进行严格的过滤或参数化处理，攻击者可通过构造特殊输入篡改原始SQL语句的逻辑。这可能导致非预期的数据库操作，例如数据泄露、数据篡改或权限绕过。

2. **触发场景**
   // 存在漏洞的代码示例
   ```go
   package main
   import (
       "github.com/gin-gonic/gin"
       service "github.com/godzeo/go-gin-vul/service/vul_service"
   )
   func Sqlli(c *gin.Context) {
       var User string
       if c.Request.Method == "GET" {
           User = c.Query("username")
       }
       loginService := service.LogData{Username: User}
       isExist, _ := loginService.LoginCheck()
       if !isExist {
           c.JSON(403, gin.H{"success": "login fail"})
           return
       }
       c.JSON(200, gin.H{"success": "login succeed " + User})
   }
   ```
   攻击者通过拼接恶意SQL片段（如`' OR '1'='1`）可以绕过认证逻辑，从而非法访问系统。

3. **潜在影响**
   - 数据库敏感信息（如用户凭证、隐私数据）被窃取。
   - 执行任意SQL语句（如插入、删除、修改数据或数据库结构）。
   - 通过数据库提权进一步渗透至服务器或其他系统组件。

DESC
	rule_id: "278c2a17-1b81-49d1-a4a9-d881fba1a0e9"
	title_zh: "检测Golang SQL注入漏洞"
	risk: "sqli"
	solution: <<<SOLUTION
### 修复建议

#### 1. 使用参数化查询（Prepared Statements）
通过预编译SQL语句并绑定用户输入，隔离代码与数据，避免恶意输入篡改逻辑。
```go
// 修复代码示例
func LoginCheck(username, password string) (bool, error) {
    db, err := sql.Open("mysql", "user:password@tcp(127.0.0.1:3306)/database")
    if err != nil {
        return false, fmt.Errorf("failed to connect to database: %w", err)
    }
    defer db.Close()
    query := "SELECT COUNT(*) FROM users WHERE username = ? AND password = ?"
    stmt, err := db.Prepare(query)
    if err != nil {
        return false, fmt.Errorf("failed to prepare statement: %w", err)
    }
    defer stmt.Close()
    var count int
    err = stmt.QueryRow(username, password).Scan(&count)
    if err != nil && err != sql.ErrNoRows {
        return false, fmt.Errorf("query execution failed: %w", err)
    }
    return count > 0, nil
}
```

#### 2. 输入合法性校验
对用户输入实施类型、格式或范围限制，拒绝非法输入。
```go
// 示例：校验输入为数字且范围合法
idStr := c.Param("id")
id, err := strconv.Atoi(idStr)
if err != nil {
    c.JSON(400, gin.H{"error": "Invalid user ID"})
    return
}
```

#### 3. 实施最小权限原则
确保应用程序只拥有执行必要数据库操作的最小权限。
```sql
-- 示例：创建仅具有读取权限的数据库用户
CREATE USER 'readonly_user'@'localhost' IDENTIFIED BY 'password';
GRANT SELECT ON database.* TO 'readonly_user'@'localhost';
FLUSH PRIVILEGES;
```
SOLUTION
	reference: <<<REFERENCE
[CWE-89](https://cwe.mitre.org/data/definitions/89.html)
REFERENCE
)

<include('golang-user-input')> as $input;

*.LoginCheck(* #-> as $param)
*.QueryByID(* #-> as $param)
$param & $input as $high;

alert $high for {
	level: "high",
	type: "vuln",
	title: "Golang SQL Injection Vulnerability Was Detected",
	title_zh: "检测到Golang SQL注入漏洞",
	name: "high",
	message: "检测到Golang服务中的SQL注入漏洞，并且从数据源（source）到污染汇聚点（sink）间，没有发现任何过滤函数信息。",
	solution: <<<SOLUTION
### 修复建议
#### 1. 使用参数化查询（Prepared Statements）
通过预编译SQL语句并绑定用户输入，隔离代码与数据，避免恶意输入篡改逻辑。
```go
query := "SELECT COUNT(*) FROM users WHERE username = ? AND password = ?"
stmt, err := db.Prepare(query)
if err != nil {
    return false, fmt.Errorf("failed to prepare statement: %w", err)
}
defer stmt.Close()
var count int
err = stmt.QueryRow(username, password).Scan(&count)
```
#### 2. 输入合法性校验
对用户输入实施类型、格式或范围限制，拒绝非法输入。
```go
idStr := c.Param("id")
id, err := strconv.Atoi(idStr) // 强制转换为整数
if err != nil {
    c.JSON(400, gin.H{"error": "Invalid user ID"})
    return
}
```
#### 3. 实施最小权限原则
确保应用程序只拥有执行必要数据库操作的最小权限。
```go
// 示例：使用最小权限账号连接数据库
db, err := sql.Open("mysql", "limited_user:password@tcp(127.0.0.1:3306)/database")
```
SOLUTION
	risk: "SQL注入",
	desc: <<<DESC
### 漏洞描述
1. **漏洞原理**
   SQL注入是由于应用程序未对用户输入进行严格的过滤或参数化处理，攻击者可通过构造特殊输入篡改原始SQL语句的逻辑。这可能导致非预期的数据库操作，例如数据泄露、数据篡改或权限绕过。
2. **触发场景**
   ```go
   func Sqlli(c *gin.Context) {
       var User string
       var Password string
       if c.Request.Method == "GET" {
           User = c.Query("username")
           Password = c.Query("password")
       } else if c.Request.Method == "POST" {
           User = c.PostForm("username")
           Password = c.PostForm("password")
       }
       loginService := service.LogData{Username: User, Password: Password}
       isExist, err := loginService.LoginCheck()
       // ...省略其他逻辑
   }
   ```
   在上述代码中，未经验证的`User`和`Password`被直接传递给`LoginCheck`方法，如果该方法内部直接拼接SQL查询，则可能造成SQL注入。
3. **潜在影响**
   - 数据库敏感信息（如用户凭证、隐私数据）被窃取。
   - 执行任意SQL语句（如插入、删除、修改数据或数据库结构）。
   - 通过数据库提权进一步渗透至服务器或其他系统组件。
DESC
}

desc(
	lang: golang
	alert_high: 1
	'file://unsafe.go': <<<UNSAFE
package main

import (
	"github.com/gin-gonic/gin"
	"github.com/godzeo/go-gin-vul/service/safe_service"
	service "github.com/godzeo/go-gin-vul/service/vul_service"
)

func Sqlli(c *gin.Context) {
	var User string
	var Password string

	if c.Request.Method == "GET" {
		User = c.Query("username")
		Password = c.Query("password")
	} else if c.Request.Method == "POST" {
		User = c.PostForm("username")
		Password = c.PostForm("password")
	}
	println("Password=" + Password)

	loginService := service.LogData{Username: User, Password: Password}
	isExist, err := loginService.LoginCheck()
	if err != nil {
		c.JSON(500, gin.H{
			"err": err,
		})
		return
	}

	if !isExist {
		c.JSON(403, gin.H{
			"success": "login fail",
		})
		return
	}

	c.JSON(200, gin.H{
		"success": "login succeed " + User,
	})
}
UNSAFE
	"safefile://SafeSqlExample.go": <<<CODE
// SafeSqlExample.go
package main

import (
	"database/sql"
	"fmt"
	"github.com/gin-gonic/gin"
	_ "github.com/go-sql-driver/mysql"
)

// LoginCheck uses prepared statements to prevent SQL injection.
func LoginCheck(username, password string) (bool, error) {
	// In a real application, you would get a database connection from a pool.
	db, err := sql.Open("mysql", "user:password@tcp(127.0.0.1:3306)/database") // Placeholder DSN
	if err != nil {
		return false, fmt.Errorf("failed to connect to database: %w", err)
	}
	defer db.Close()

	query := "SELECT COUNT(*) FROM users WHERE username = ? AND password = ?"
	stmt, err := db.Prepare(query)
	if err != nil {
		return false, fmt.Errorf("failed to prepare statement: %w", err)
	}
	defer stmt.Close()

	var count int
	err = stmt.QueryRow(username, password).Scan(&count)
	if err != nil && err != sql.ErrNoRows{
		return false, fmt.Errorf("query execution failed: %w", err)
	}

	return count > 0, nil
}

// main function for Gin setup, showing how to call the safe LoginCheck
func main() {
	r := gin.Default()

	r.POST("/login", func(c *gin.Context) {
		username := c.PostForm("username")
		password := c.PostForm("password")

		isExist, err := LoginCheck(username, password) // Calling the safe function
		if err != nil {
			c.JSON(500, gin.H{"error": err.Error()})
			return
		}

		if isExist {
			c.JSON(200, gin.H{"message": "Login successful"})
		} else {
			c.JSON(401, gin.H{"message": "Invalid credentials"})
		}
	})

	r.Run(":8080")
}
CODE
	"safefile://SafeQueryByID.go": <<<CODE
// SafeQueryByID.go
package main

import (
	"database/sql"
	"fmt"
	"github.com/gin-gonic/gin"
	_ "github.com/go-sql-driver/mysql"
	"strconv"
)

// User represents a user entity
type User struct {
	ID int
	Name string
}

// QueryByID safely queries a user by ID using an integer type and prepared statements.
// This prevents SQL injection by ensuring the ID is treated as a number, not part of the query string.
func QueryByID(id int) (*User, error) {
	// In a real application, you would get a database connection from a pool.
	db, err := sql.Open("mysql", "user:password@tcp(127.0.0.1:3306)/database")
	if err != nil {
		return nil, fmt.Errorf("failed to connect to database: %w", err)
	}
	defer db.Close()

	query := "SELECT id, name FROM users WHERE id = ?"
	stmt, err := db.Prepare(query)
	if err != nil {
		return nil, fmt.Errorf("failed to prepare statement: %w", err)
	}
	defer stmt.Close()

	var user User
	err = stmt.QueryRow(id).Scan(&user.ID, &user.Name)
	if err == sql.ErrNoRows {
		return nil, nil // User not found
	} else if err != nil {
		return nil, fmt.Errorf("query execution failed: %w", err)
	}

	return &user, nil
}

// main function for Gin setup, demonstrating safe ID query handling
func main() {
	r := gin.Default()

	r.GET("/user/:id", func(c *gin.Context) {
		idStr := c.Param("id")
		id, err := strconv.Atoi(idStr) // Input validation: convert to int
		if err != nil {
			c.JSON(400, gin.H{"error": "Invalid user ID"})
			return
		}

		user, err := QueryByID(id) // Call the safe function with integer ID
		if err != nil {
			c.JSON(500, gin.H{"error": err.Error()})
			return
		}

		if user == nil {
			c.JSON(404, gin.H{"message": "User not found"})
			return
		}

		c.JSON(200, user)
	})

	r.Run(":8080")
}
CODE
)
