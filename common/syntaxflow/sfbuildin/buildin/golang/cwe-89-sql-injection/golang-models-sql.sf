desc(
	title: "Check Golang Models SQL Injection Vulnerability"
	type: audit
	level: high
	risk: "sqli"
	desc: <<<DESC
### 漏洞描述

1. **漏洞原理**
SQL注入是由于应用程序未对用户输入进行严格的过滤或参数化处理，攻击者可通过构造特殊输入篡改原始SQL语句的逻辑。这可能导致非预期的数据库操作，例如数据泄露、数据篡改或权限绕过。在Golang中，使用`models`库进行数据库操作时，如果直接将用户输入拼接到SQL语句中，就可能发生SQL注入攻击。

2. **触发场景**
以下代码展示了SQL注入的典型场景：
```go
func SQLILoginHandler(c *gin.Context) {
    username := c.PostForm("username")
    password := c.PostForm("password")
    // 故意使用字符串拼接构造SQL语句，易受SQL注入攻击
    query := fmt.Sprintf("SELECT id, name FROM users WHERE name = '%s' AND password = '%s'", username, password)
    var user models.Users
    row := models.DB.Raw(query).Row()
    err := row.Scan(&user.ID, &user.Name)
}
```
攻击者通过输入 `admin' --` 可绕过密码验证，或者通过输入 `1; DROP TABLE users` 删除数据表。

3. **潜在影响**
- 数据库敏感信息（如用户凭证、隐私数据）被窃取。
- 执行任意SQL语句（如插入、删除、修改数据或数据库结构）。
- 通过数据库提权进一步渗透至服务器或其他系统组件。

DESC
	rule_id: "b89f27b3-35ee-48ae-ba75-415da669f60d"
	title_zh: "检测Golang SQL注入漏洞(Models)"
	risk: "sqli"
	solution: <<<SOLUTION
### 修复建议

#### 1. 使用预编译查询
通过预编译SQL语句并绑定用户输入，隔离代码与数据，避免恶意输入篡改逻辑。
```go
func SQLILoginHandler(c *gin.Context) {
    username := c.PostForm("username")
    password := c.PostForm("password")
    query := "SELECT id, name FROM users WHERE name = ? AND password = ?"
    var user models.Users
    err := models.DB.Raw(query, username, password).Scan(&user).Error
    if err != nil {
        c.HTML(http.StatusOK, "vulns/sqli.tmpl", gin.H{"error": "用户名或密码错误"})
        return
    }
    c.HTML(http.StatusOK, "vulns/sqli.tmpl", gin.H{"success": true, "message": fmt.Sprintf("欢迎回来，%s!", user.Name)})
}
```

#### 2. 输入合法性校验
对用户输入实施类型、格式或范围限制，拒绝非法输入。
```go
if !regexp.MustCompile(`^[a-zA-Z0-9_]+$`).MatchString(username) {
    c.HTML(http.StatusOK, "vulns/sqli.tmpl", gin.H{"error": "用户名包含非法字符"})
    return
}
```

#### 3. 使用ORM框架
通过ORM（如GORM）内置的安全机制自动处理参数化，避免手动拼接SQL。
```go
func SQLILoginHandler(c *gin.Context) {
    username := c.PostForm("username")
    password := c.PostForm("password")
    var user models.Users
    err := models.DB.Where("name = ? AND password = ?", username, password).First(&user).Error
    if err != nil {
        c.HTML(http.StatusOK, "vulns/sqli.tmpl", gin.H{"error": "用户名或密码错误"})
        return
    }
    c.HTML(http.StatusOK, "vulns/sqli.tmpl", gin.H{"success": true, "message": fmt.Sprintf("欢迎回来，%s!", user.Name)})
}
```
SOLUTION
	reference: <<<REFERENCE
[SQL注入漏洞](https://owasp.org/www-community/vulnerabilities/SQL_Injection)
[CWE-89](https://cwe.mitre.org/data/definitions/89.html)
REFERENCE
)

<include('golang-user-input')> as $input;
models?{<fullTypeName>?{have:'github.com/seaung/vhub/pkg/models'}} as $entry
$entry.DB.Exec(* #-> as $param) 
$entry.DB.Raw(* #-> as $param) 

$param & $input as $high;

alert $high for {
	type: "vuln",
	title: "Golang SQL Injection Vulnerability Was Detected",
	title_zh: "检测到Golang SQL注入漏洞",
	level: "high",
	risk: "sqli",
	name: "high",
	message: "检测到Golang代码中存在SQL注入漏洞，并且从数据源（source）到污染汇聚点（sink）间，没有发现任何过滤函数信息。",
	solution: <<<SOLUTION
### 修复建议
#### 1. 使用参数化查询
通过预编译SQL语句并绑定用户输入，隔离代码与数据，避免恶意输入篡改逻辑。
```go
username := c.PostForm("username")
password := c.PostForm("password")
query := "SELECT id, name FROM users WHERE name = ? AND password = ?"
models.DB.Raw(query, username, password).Row()
```
#### 2. 输入合法性校验
对用户输入实施类型、格式或范围限制，拒绝非法输入。
```go
if !isValidUsername(username) || !isValidPassword(password) {
    c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid input"})
    return
}
```
#### 3. 使用ORM框架
通过GORM等ORM框架内置的安全机制自动处理参数化，避免手动拼接SQL。
```go
models.DB.Where("name = ? AND password = ?", username, password).First(&user)
```
SOLUTION
	risk: "SQL注入",
	desc: <<<DESC
### 漏洞描述
1. **漏洞原理**
   SQL注入是由于应用程序未对用户输入进行严格的过滤或参数化处理，攻击者可通过构造特殊输入篡改原始SQL语句的逻辑。这可能导致非预期的数据库操作，例如数据泄露、数据篡改或权限绕过。
2. **触发场景**
   ```go
   username := c.PostForm("username")
   password := c.PostForm("password")
   query := fmt.Sprintf("SELECT id, name FROM users WHERE name = '%s' AND password = '%s'", username, password)
   models.DB.Raw(query).Row()
   ```
   攻击者可以输入 `' OR '1'='1` 绕过登录验证逻辑，或者输入 `'; DROP TABLE users--` 删除数据库表。
3. **潜在影响**
   - 数据库敏感信息（如用户凭证、隐私数据）被窃取。
   - 执行任意SQL语句（如插入、删除、修改数据或数据库结构）。
   - 通过数据库提权进一步渗透至服务器或其他系统组件。
DESC
}

desc(
	lang: golang
	alert_high: 1
	'file://unsafe.go': <<<UNSAFE
package api

import (
	"database/sql"
	"fmt"
	"net/http"
	"strings"

	"github.com/gin-gonic/gin"
	"github.com/seaung/vhub/pkg/models"
)

// SQLIHandler 展示SQL注入漏洞演示页面
func SQLIHandler(c *gin.Context) {
	c.HTML(http.StatusOK, "vulns/sqli.tmpl", gin.H{
		"title": "SQL注入漏洞演示",
	})
}

// SQLILoginHandler 演示登录验证中的SQL注入
func SQLILoginHandler(c *gin.Context) {
	username := c.PostForm("username")
	password := c.PostForm("password")

	// 故意使用字符串拼接构造SQL语句，易受SQL注入攻击
	query := fmt.Sprintf("SELECT id, name FROM users WHERE name = '%s' AND password = '%s'", username, password)

	var user models.Users
	row := models.DB.Raw(query).Row()
	err := row.Scan(&user.ID, &user.Name)

	if err == sql.ErrNoRows {
		c.HTML(http.StatusOK, "vulns/sqli.tmpl", gin.H{
			"error": "用户名或密码错误",
		})
		return
	}

	if err != nil {
		c.HTML(http.StatusOK, "vulns/sqli.tmpl", gin.H{
			"error": "查询出错: " + err.Error(),
		})
		return
	}

	c.HTML(http.StatusOK, "vulns/sqli.tmpl", gin.H{
		"success": true,
		"message": fmt.Sprintf("欢迎回来，%s!", user.Name),
	})
}

// SQLISearchHandler 演示消息搜索中的SQL注入
func SQLISearchHandler(c *gin.Context) {
	keyword := c.Query("keyword")

	// 故意使用LIKE语句和字符串拼接，易受SQL注入攻击
	query := fmt.Sprintf("SELECT id, content FROM messages WHERE content LIKE '%%%s%%'", keyword)

	rows, err := models.DB.Raw(query).Rows()
	if err != nil {
		c.HTML(http.StatusOK, "vulns/sqli.tmpl", gin.H{
			"error": "搜索出错: " + err.Error(),
		})
		return
	}
	defer rows.Close()

	var messages []models.Message
	for rows.Next() {
		var msg models.Message
		if err := rows.Scan(&msg.ID, &msg.Content); err != nil {
			continue
		}
		messages = append(messages, msg)
	}

	c.HTML(http.StatusOK, "vulns/sqli.tmpl", gin.H{
		"messages": messages,
		"keyword":  keyword,
	})
}

// SQLIUpdateHandler 演示用户信息更新中的SQL注入
func SQLIUpdateHandler(c *gin.Context) {
	userID := c.PostForm("user_id")
	description := c.PostForm("description")

	// 故意使用字符串拼接构造UPDATE语句，易受SQL注入攻击
	query := fmt.Sprintf("UPDATE users SET description = '%s' WHERE id = %s", description, userID)

	result := models.DB.Exec(query)
	if err := result.Error; err != nil {
		c.HTML(http.StatusOK, "vulns/sqli.tmpl", gin.H{
			"error": "更新失败: " + err.Error(),
		})
		return
	}

	c.HTML(http.StatusOK, "vulns/sqli.tmpl", gin.H{
		"success": true,
		"message": "用户信息已更新",
	})
}
UNSAFE
	'file://safe.go': <<<SAFE
package api

import (
	"database/sql"
	"fmt"
	"net/http"
	"strings"

	"github.com/gin-gonic/gin"
	"github.com/seaung/vhub/pkg/models"
)

// SQLIHandler 展示SQL注入漏洞演示页面
func SQLIHandler(c *gin.Context) {
	c.HTML(http.StatusOK, "vulns/sqli.tmpl", gin.H{
		"title": "SQL注入漏洞演示",
	})
}

// SQLILoginHandler 演示登录验证中的SQL注入
func SQLILoginHandler(c *gin.Context) {
	username := "username"
	password := "password"

	// 故意使用字符串拼接构造SQL语句，易受SQL注入攻击
	query := fmt.Sprintf("SELECT id, name FROM users WHERE name = '%s' AND password = '%s'", username, password)

	var user models.Users
	row := models.DB.Raw(query).Row()
	err := row.Scan(&user.ID, &user.Name)

	if err == sql.ErrNoRows {
		c.HTML(http.StatusOK, "vulns/sqli.tmpl", gin.H{
			"error": "用户名或密码错误",
		})
		return
	}

	if err != nil {
		c.HTML(http.StatusOK, "vulns/sqli.tmpl", gin.H{
			"error": "查询出错: " + err.Error(),
		})
		return
	}

	c.HTML(http.StatusOK, "vulns/sqli.tmpl", gin.H{
		"success": true,
		"message": fmt.Sprintf("欢迎回来，%s!", user.Name),
	})
}

// SQLISearchHandler 演示消息搜索中的SQL注入
func SQLISearchHandler(c *gin.Context) {
	keyword := c.Query("keyword")

	// 故意使用LIKE语句和字符串拼接，易受SQL注入攻击
	query := fmt.Sprintf("SELECT id, content FROM messages WHERE content LIKE '%%%s%%'", keyword)

	rows, err := models.DB.Raw(query).Rows()
	if err != nil {
		c.HTML(http.StatusOK, "vulns/sqli.tmpl", gin.H{
			"error": "搜索出错: " + err.Error(),
		})
		return
	}
	defer rows.Close()

	var messages []models.Message
	for rows.Next() {
		var msg models.Message
		if err := rows.Scan(&msg.ID, &msg.Content); err != nil {
			continue
		}
		messages = append(messages, msg)
	}

	c.HTML(http.StatusOK, "vulns/sqli.tmpl", gin.H{
		"messages": messages,
		"keyword":  keyword,
	})
}

// SQLIUpdateHandler 演示用户信息更新中的SQL注入
func SQLIUpdateHandler(c *gin.Context) {
	userID := c.PostForm("user_id")
	description := c.PostForm("description")

	// 故意使用字符串拼接构造UPDATE语句，易受SQL注入攻击
	query := fmt.Sprintf("UPDATE users SET description = '%s' WHERE id = %s", description, userID)

	result := models.DB.Exec(query)
	if err := result.Error; err != nil {
		c.HTML(http.StatusOK, "vulns/sqli.tmpl", gin.H{
			"error": "更新失败: " + err.Error(),
		})
		return
	}

	c.HTML(http.StatusOK, "vulns/sqli.tmpl", gin.H{
		"success": true,
		"message": "用户信息已更新",
	})
}
SAFE
)
