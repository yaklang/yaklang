desc(
    title: "golang filepath missing permission check",
    type: audit,
    level: low,
    desc: <<<TEXT
此审计规则旨在验证用户输入，及传入的文件路径没有经过过滤与授权，攻击者可通过构造恶意路径实现文件覆盖/删除或路径穿越攻击。
TEXT
)

<include('golang-os-sink')> as $sink;

$sink?{!have: 'Parameter'} as $low;

alert $low for {
    title: 'filedelele missing permission check',
    title_zh: '检测到文件路径未授权',
    type: 'vuln',
    level: 'low',
}

desc(
    lang: golang,
    alert_low: 1,
    'file://main.go': <<<UNSAFE
package main

import (
    "fmt"
    "net/http"
    "os"
)

func deleteFile(w http.ResponseWriter, r *http.Request) {
    fileID := r.URL.Query().Get("file_id")
    user := r.Header.Get("User")

    // 检查用户是否有删除权限
    if !hasPermission(user, "delete_file") {
        fmt.Fprintf(w, "Permission denied")
        return
    }

    // 获取文件路径（假设 fileID 是文件名）
    filePath := getFilePathByID(fileID)

    // 检查文件是否存在
    if _, err := os.Stat(filePath); os.IsNotExist(err) {
        fmt.Fprintf(w, "File not found")
        return
    }

    // 检查文件所有者是否为当前用户
    fileOwner := getFileOwner(filePath)
    if fileOwner != user {
        fmt.Fprintf(w, "Permission denied")
        return
    }

    // 删除文件
    err := os.Remove(filePath)
    if err != nil {
        fmt.Fprintf(w, "Failed to delete file: %v", err)
        return
    }

    fmt.Fprintf(w, "File deleted successfully")
}

func hasPermission(user string, permission string) bool {
    // 模拟检查用户权限
    return user == "user1" && permission == "delete_file"
}

func getFilePathByID(fileID string) string {
    // 假设文件存储在 /files 目录下，fileID 是文件名
    return "/files/" + fileID
}

func getFileOwner(filePath string) string {
    // 模拟获取文件所有者（这里假设文件所有者为 user1）
    return "user1"
}

func main() {
    http.HandleFunc("/delete", deleteFile)
    http.ListenAndServe(":8080", nil)
}
UNSAFE
)
