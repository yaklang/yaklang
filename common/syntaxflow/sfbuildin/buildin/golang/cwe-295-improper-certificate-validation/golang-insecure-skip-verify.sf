desc(
	title: "Detect Golang TLS Certificate Verification Bypass (InsecureSkipVerify)"
	title_zh: "æ£€æµ‹Golang TLSè¯ä¹¦éªŒè¯ç»•è¿‡æ¼æ´(InsecureSkipVerify)"
	type: vuln
	severity: high
	risk: "insecure_tls"
	desc: <<<DESC
### æ¼æ´æè¿°

1. **æ¼æ´åŸç†**
   å½“åœ¨ `tls.Config` ä¸­è®¾ç½® `InsecureSkipVerify: true` æ—¶ï¼ŒGo è¯­è¨€çš„ TLS/SSL å®¢æˆ·ç«¯ä¼šå®Œå…¨è·³è¿‡æœåŠ¡å™¨è¯ä¹¦çš„éªŒè¯ã€‚è¿™æ„å‘³ç€ï¼š
   - ä¸éªŒè¯æœåŠ¡å™¨è¯ä¹¦æ˜¯å¦ç”±å—ä¿¡ä»»çš„è¯ä¹¦é¢å‘æœºæ„ï¼ˆCAï¼‰ç­¾å‘
   - ä¸éªŒè¯è¯ä¹¦æ˜¯å¦è¿‡æœŸ
   - ä¸éªŒè¯è¯ä¹¦ä¸­çš„åŸŸåæ˜¯å¦ä¸è¯·æ±‚çš„æœåŠ¡å™¨åŒ¹é…
   - ä¸æ£€æŸ¥è¯ä¹¦æ˜¯å¦è¢«åŠé”€
   
   è¿™ä½¿å¾—åº”ç”¨ç¨‹åºå®Œå…¨å¤±å»äº†å¯¹æœåŠ¡å™¨èº«ä»½çš„éªŒè¯èƒ½åŠ›ï¼Œæ”»å‡»è€…å¯ä»¥è½»æ˜“ä¼ªé€ æœåŠ¡å™¨èº«ä»½ã€‚

2. **è§¦å‘åœºæ™¯**
   è¯¥æ¼æ´é€šå¸¸å‡ºç°åœ¨ä»¥ä¸‹åœºæ™¯ï¼š
   - å¼€å‘è€…ä¸ºäº†å¿«é€Ÿæµ‹è¯•è€Œä¸´æ—¶ç¦ç”¨è¯ä¹¦éªŒè¯ï¼Œä½†å¿˜è®°åœ¨ç”Ÿäº§ç¯å¢ƒä¸­æ¢å¤
   - è¿æ¥ä½¿ç”¨è‡ªç­¾åè¯ä¹¦çš„å†…éƒ¨æœåŠ¡å™¨ï¼Œä½†é‡‡ç”¨äº†ä¸å®‰å…¨çš„æ–¹å¼
   - å¯¹ TLS/SSL åŸç†ç†è§£ä¸è¶³ï¼Œè¯¯ä»¥ä¸ºè¿™åªæ˜¯ä¸€ä¸ª"è­¦å‘Š"è€Œéä¸¥é‡çš„å®‰å…¨é—®é¢˜
   
   ```go
   // ä¸å®‰å…¨çš„é…ç½®ç¤ºä¾‹
   client := &http.Client{
       Transport: &http.Transport{
           TLSClientConfig: &tls.Config{
               InsecureSkipVerify: true, // å±é™©ï¼
           },
       },
   }
   resp, _ := client.Get("https://api.example.com")
   ```

3. **æ½œåœ¨å½±å“**
   - **ä¸­é—´äººæ”»å‡»ï¼ˆMITMï¼‰**ï¼šæ”»å‡»è€…å¯ä»¥æ‹¦æˆªå¹¶ç¯¡æ”¹å®¢æˆ·ç«¯ä¸æœåŠ¡å™¨ä¹‹é—´çš„æ‰€æœ‰é€šä¿¡
   - **æ•°æ®çªƒå–**ï¼šæ”»å‡»è€…å¯ä»¥è¯»å–ä¼ è¾“ä¸­çš„æ•æ„Ÿæ•°æ®ï¼Œå¦‚ç™»å½•å‡­è¯ã€APIå¯†é’¥ã€ä¸ªäººä¿¡æ¯ç­‰
   - **æ•°æ®ç¯¡æ”¹**ï¼šæ”»å‡»è€…å¯ä»¥ä¿®æ”¹è¯·æ±‚å’Œå“åº”å†…å®¹ï¼Œæ³¨å…¥æ¶æ„ä»£ç æˆ–æ•°æ®
   - **èº«ä»½å†’å……**ï¼šæ”»å‡»è€…å¯ä»¥ä¼ªè£…æˆåˆæ³•æœåŠ¡å™¨ï¼Œæ¬ºéª—å®¢æˆ·ç«¯
   - **è¿ååˆè§„è¦æ±‚**ï¼šè¿å PCI DSSã€HIPAA ç­‰å®‰å…¨æ ‡å‡†ï¼Œå¯¼è‡´å®¡è®¡å¤±è´¥
   - **å£°èª‰æŸå®³**ï¼šä¸€æ—¦å‘ç”Ÿå®‰å…¨äº‹æ•…ï¼Œä¼šä¸¥é‡æŸå®³ä¼ä¸šå£°èª‰å’Œå®¢æˆ·ä¿¡ä»»

4. **ä¸ºä»€ä¹ˆå¼€å‘è€…ä¼šä½¿ç”¨è¿™ä¸ªè®¾ç½®**
   å°½ç®¡æåº¦ä¸å®‰å…¨ï¼Œå¼€å‘è€…å¯èƒ½åœ¨ä»¥ä¸‹æƒ…å†µä¸‹ä½¿ç”¨ï¼š
   - ä½¿ç”¨è‡ªç­¾åè¯ä¹¦çš„æµ‹è¯•ç¯å¢ƒ
   - è¯ä¹¦é…ç½®é”™è¯¯ï¼ˆåŸŸåä¸åŒ¹é…ã€è¯ä¹¦é“¾ä¸å®Œæ•´ï¼‰
   - å¿«é€ŸåŸå‹å¼€å‘æ—¶ä¸ºäº†"æ–¹ä¾¿"
   - å¯¹å®‰å…¨é£é™©è®¤è¯†ä¸è¶³

DESC
	rule_id: "f8e9a1b2-c3d4-5e6f-a7b8-c9d0e1f2a3b4"
	solution: <<<SOLUTION
### ä¿®å¤å»ºè®®

#### ğŸ”´ ç”Ÿäº§ç¯å¢ƒï¼šä½¿ç”¨å—ä¿¡ä»»çš„CAè¯ä¹¦ï¼ˆå¿…é¡»ï¼‰

**æœ€ä½³å®è·µ**ï¼šä»å…¬å…±è¯ä¹¦é¢å‘æœºæ„è·å–æœ‰æ•ˆè¯ä¹¦ï¼Œè®©ç³»ç»Ÿè‡ªåŠ¨éªŒè¯ã€‚

```go
// å®‰å…¨çš„é»˜è®¤é…ç½® - ä½¿ç”¨ç³»ç»Ÿé»˜è®¤çš„å—ä¿¡ä»»CA
client := &http.Client{
    // ä¸éœ€è¦ç‰¹æ®Šé…ç½®ï¼Œé»˜è®¤å°±ä¼šéªŒè¯è¯ä¹¦
    Timeout: 10 * time.Second,
}
resp, err := client.Get("https://api.example.com")
```

#### ğŸŸ¡ å†…éƒ¨ç¯å¢ƒï¼šé…ç½®è‡ªå®šä¹‰CAï¼ˆæ¨èï¼‰

å¦‚æœå¿…é¡»ä½¿ç”¨å†…éƒ¨CAç­¾å‘çš„è¯ä¹¦ï¼Œæ­£ç¡®çš„åšæ³•æ˜¯å°†CAè¯ä¹¦æ·»åŠ åˆ°ä¿¡ä»»åˆ—è¡¨ã€‚

```go
package main

import (
    "crypto/tls"
    "crypto/x509"
    "io/ioutil"
    "log"
    "net/http"
)

func createSecureClient() (*http.Client, error) {
    // 1. è¯»å–å†…éƒ¨CAçš„æ ¹è¯ä¹¦
    caCert, err := ioutil.ReadFile("./internal-ca-root.crt")
    if err != nil {
        return nil, err
    }

    // 2. åˆ›å»ºè¯ä¹¦æ± å¹¶æ·»åŠ CAè¯ä¹¦
    caCertPool := x509.NewCertPool()
    if !caCertPool.AppendCertsFromPEM(caCert) {
        return nil, fmt.Errorf("failed to parse CA certificate")
    }

    // 3. é…ç½®TLSï¼ŒæŒ‡å®šè‡ªå®šä¹‰CAï¼Œä¿æŒéªŒè¯å¼€å¯
    tlsConfig := &tls.Config{
        RootCAs: caCertPool, // ä½¿ç”¨è‡ªå®šä¹‰CA
        MinVersion: tls.VersionTLS12, // å¼ºåˆ¶ä½¿ç”¨TLS 1.2æˆ–æ›´é«˜ç‰ˆæœ¬
        // InsecureSkipVerify: false, // é»˜è®¤ä¸ºfalseï¼Œå¿…é¡»ä¿æŒéªŒè¯å¼€å¯ï¼
    }

    // 4. åˆ›å»ºå®‰å…¨çš„HTTPå®¢æˆ·ç«¯
    client := &http.Client{
        Transport: &http.Transport{
            TLSClientConfig: tlsConfig,
        },
        Timeout: 30 * time.Second,
    }

    return client, nil
}

func main() {
    client, err := createSecureClient()
    if err != nil {
        log.Fatal(err)
    }

    resp, err := client.Get("https://internal-server.company.com")
    if err != nil {
        log.Fatal(err)
    }
    defer resp.Body.Close()
    // ... å¤„ç†å“åº”
}
```

#### ğŸŸ  å¤šCAè¯ä¹¦æ”¯æŒ

å¦‚æœéœ€è¦åŒæ—¶ä¿¡ä»»ç³»ç»ŸCAå’Œè‡ªå®šä¹‰CAï¼š

```go
func createClientWithMultipleCAs() (*http.Client, error) {
    // 1. è·å–ç³»ç»Ÿé»˜è®¤çš„CAè¯ä¹¦æ± 
    systemCertPool, err := x509.SystemCertPool()
    if err != nil {
        // å¦‚æœæ— æ³•è·å–ç³»ç»Ÿè¯ä¹¦æ± ï¼Œåˆ›å»ºæ–°çš„ç©ºæ± 
        systemCertPool = x509.NewCertPool()
    }

    // 2. æ·»åŠ è‡ªå®šä¹‰CAè¯ä¹¦
    customCA, err := ioutil.ReadFile("./custom-ca.crt")
    if err != nil {
        return nil, err
    }
    systemCertPool.AppendCertsFromPEM(customCA)

    // 3. é…ç½®TLS
    tlsConfig := &tls.Config{
        RootCAs: systemCertPool, // åŒæ—¶ä¿¡ä»»ç³»ç»ŸCAå’Œè‡ªå®šä¹‰CA
        MinVersion: tls.VersionTLS12,
    }

    client := &http.Client{
        Transport: &http.Transport{
            TLSClientConfig: tlsConfig,
        },
    }

    return client, nil
}
```

#### ğŸ”µ å®¢æˆ·ç«¯è¯ä¹¦è®¤è¯ï¼ˆåŒå‘TLSï¼‰

å¦‚æœæœåŠ¡å™¨è¦æ±‚å®¢æˆ·ç«¯è¯ä¹¦ï¼š

```go
func createMutualTLSClient() (*http.Client, error) {
    // 1. åŠ è½½å®¢æˆ·ç«¯è¯ä¹¦å’Œç§é’¥
    clientCert, err := tls.LoadX509KeyPair("client-cert.pem", "client-key.pem")
    if err != nil {
        return nil, err
    }

    // 2. åŠ è½½æœåŠ¡å™¨CAè¯ä¹¦
    caCert, err := ioutil.ReadFile("server-ca.crt")
    if err != nil {
        return nil, err
    }

    caCertPool := x509.NewCertPool()
    caCertPool.AppendCertsFromPEM(caCert)

    // 3. é…ç½®åŒå‘TLS
    tlsConfig := &tls.Config{
        Certificates: []tls.Certificate{clientCert}, // å®¢æˆ·ç«¯è¯ä¹¦
        RootCAs:      caCertPool,                    // æœåŠ¡å™¨CA
        MinVersion:   tls.VersionTLS12,
    }

    client := &http.Client{
        Transport: &http.Transport{
            TLSClientConfig: tlsConfig,
        },
    }

    return client, nil
}
```

#### âš ï¸ æµ‹è¯•ç¯å¢ƒçš„ä¸´æ—¶æ–¹æ¡ˆï¼ˆä»…é™å¼€å‘ï¼Œç»ä¸ç”¨äºç”Ÿäº§ï¼‰

å¦‚æœåœ¨å¼€å‘é˜¶æ®µç¡®å®éœ€è¦ä¸´æ—¶ç¦ç”¨éªŒè¯ï¼ˆæä¸æ¨èï¼‰ï¼Œè‡³å°‘åº”è¯¥ï¼š

1. **ä½¿ç”¨ç¯å¢ƒå˜é‡æ§åˆ¶**
2. **è®°å½•æ˜ç¡®çš„è­¦å‘Šæ—¥å¿—**
3. **ç¡®ä¿ç”Ÿäº§ç¯å¢ƒå¼ºåˆ¶å¯ç”¨éªŒè¯**

```go
func createClientWithEnvControl() *http.Client {
    skipVerify := os.Getenv("INSECURE_SKIP_VERIFY") == "true"
    
    if skipVerify {
        log.Println("âš ï¸  WARNING: TLS certificate verification is DISABLED!")
        log.Println("âš ï¸  This should NEVER be used in production!")
        log.Println("âš ï¸  Application is vulnerable to man-in-the-middle attacks!")
    }

    tlsConfig := &tls.Config{
        InsecureSkipVerify: skipVerify,
        MinVersion:         tls.VersionTLS12,
    }

    // ç”Ÿäº§ç¯å¢ƒå¼ºåˆ¶æ£€æŸ¥
    if os.Getenv("ENVIRONMENT") == "production" && skipVerify {
        log.Fatal("âŒ FATAL: InsecureSkipVerify cannot be true in production!")
    }

    return &http.Client{
        Transport: &http.Transport{
            TLSClientConfig: tlsConfig,
        },
    }
}
```

#### ğŸ“‹ å®‰å…¨æ£€æŸ¥æ¸…å•

åœ¨éƒ¨ç½²å‰ï¼Œè¯·ç¡®ä¿ï¼š

- [ ] **ç»ä¸åœ¨ç”Ÿäº§ç¯å¢ƒè®¾ç½® `InsecureSkipVerify: true`**
- [ ] **ä½¿ç”¨å—ä¿¡ä»»çš„CAç­¾å‘è¯ä¹¦ï¼Œæˆ–æ­£ç¡®é…ç½®è‡ªå®šä¹‰CA**
- [ ] **å¼ºåˆ¶ä½¿ç”¨ TLS 1.2 æˆ–æ›´é«˜ç‰ˆæœ¬** (`MinVersion: tls.VersionTLS12`)
- [ ] **å®šæœŸæ›´æ–°å’Œè½®æ¢è¯ä¹¦**
- [ ] **ç›‘æ§è¯ä¹¦åˆ°æœŸæ—¶é—´**
- [ ] **ä½¿ç”¨å®‰å…¨çš„å¯†ç å¥—ä»¶** (å¯é€‰é…ç½® `CipherSuites`)
- [ ] **ä»£ç å®¡æŸ¥æ—¶é‡ç‚¹æ£€æŸ¥ TLS é…ç½®**
- [ ] **åœ¨ CI/CD ä¸­é›†æˆå®‰å…¨æ‰«æ**

SOLUTION
	reference: <<<REFERENCE
[CWE-295: Improper Certificate Validation](https://cwe.mitre.org/data/definitions/295.html)
[OWASP: Insufficient Transport Layer Protection](https://owasp.org/www-community/vulnerabilities/Insufficient_Transport_Layer_Protection)
[Go crypto/tls Documentation](https://pkg.go.dev/crypto/tls)
[RFC 5280: Internet X.509 Public Key Infrastructure](https://tools.ietf.org/html/rfc5280)
REFERENCE
)

// TODO: æˆ‘å‘ç°http.Clientçš„fullTypeNameæ²¡æœ‰æ¥ä¸Šhttpï¼Œè¿™é‡Œå…ˆæš‚æ—¶ç”¨*ä»£æ›¿ä¹‹åå†ç²¾ç¡®ä¿®æ”¹
*.InsecureSkipVerify?{have: 'true'} as $high;

alert $high for {
	type: "vuln",
	title: "Golang TLS Certificate Verification Bypass Detected (InsecureSkipVerify: true)",
	title_zh: "æ£€æµ‹åˆ°Golang TLSè¯ä¹¦éªŒè¯ç»•è¿‡æ¼æ´(InsecureSkipVerify: true)",
	level: "high",
	name: "high",
	message: "æ£€æµ‹åˆ°æåº¦å±é™©çš„ TLS é…ç½®ï¼šInsecureSkipVerify è¢«è®¾ç½®ä¸º trueï¼Œè¿™ä¼šå®Œå…¨ç¦ç”¨è¯ä¹¦éªŒè¯ï¼Œä½¿åº”ç”¨ç¨‹åºå®¹æ˜“é­å—ä¸­é—´äººæ”»å‡»(MITM)ã€‚æ‰€æœ‰é€šè¿‡æ­¤é…ç½®å»ºç«‹çš„ HTTPS è¿æ¥éƒ½æ˜¯ä¸å®‰å…¨çš„ï¼Œæ”»å‡»è€…å¯ä»¥æ‹¦æˆªã€è¯»å–å’Œç¯¡æ”¹æ‰€æœ‰ä¼ è¾“æ•°æ®ã€‚",
	solution: <<<SOLUTION
### ç«‹å³ä¿®å¤æ­¥éª¤

#### ğŸš¨ ç´§æ€¥æƒ…å†µï¼ˆç”Ÿäº§ç¯å¢ƒï¼‰
1. **ç«‹å³ç§»é™¤æˆ–æ³¨é‡Šæ‰ `InsecureSkipVerify: true`**
2. **ç¡®ä¿ä½¿ç”¨å—ä¿¡ä»»çš„CAç­¾å‘çš„æœ‰æ•ˆè¯ä¹¦**
3. **é‡æ–°éƒ¨ç½²åº”ç”¨ç¨‹åº**

#### ğŸ“‹ æ ¹æœ¬è§£å†³æ–¹æ¡ˆ

**æ–¹æ¡ˆA - ä½¿ç”¨å…¬å…±CAè¯ä¹¦ï¼ˆæ¨èï¼‰**
```go
// åˆ é™¤ä¸å®‰å…¨çš„é…ç½®ï¼Œä½¿ç”¨é»˜è®¤çš„å®‰å…¨è®¾ç½®
client := &http.Client{
    Timeout: 10 * time.Second,
}
```

**æ–¹æ¡ˆB - é…ç½®è‡ªå®šä¹‰CAï¼ˆå†…éƒ¨ç¯å¢ƒï¼‰**
```go
caCert, _ := ioutil.ReadFile("./ca-cert.crt")
caCertPool := x509.NewCertPool()
caCertPool.AppendCertsFromPEM(caCert)

tlsConfig := &tls.Config{
    RootCAs: caCertPool, // æŒ‡å®šä¿¡ä»»çš„CA
    MinVersion: tls.VersionTLS12,
    // ä¸è¦è®¾ç½® InsecureSkipVerifyï¼
}

client := &http.Client{
    Transport: &http.Transport{
        TLSClientConfig: tlsConfig,
    },
}
```

âš ï¸ **ç»ä¸è¦åœ¨ç”Ÿäº§ç¯å¢ƒä¸­ä½¿ç”¨ `InsecureSkipVerify: true`ï¼**
SOLUTION
	risk: "ä¸å®‰å…¨çš„TLSé…ç½®",
	desc: <<<DESC
### è¯¦ç»†è¯´æ˜

æ£€æµ‹åˆ°ä»£ç ä¸­å­˜åœ¨ `tls.Config{InsecureSkipVerify: true}` é…ç½®ã€‚

**é£é™©ç­‰çº§ï¼šğŸ”´ highï¼ˆä¸¥é‡ï¼‰**

**å…·ä½“é—®é¢˜**ï¼š
- æœåŠ¡å™¨è¯ä¹¦çš„æœ‰æ•ˆæ€§ä¸ä¼šè¢«éªŒè¯
- è¯ä¹¦è¿‡æœŸã€åŸŸåä¸åŒ¹é…ã€è¯ä¹¦é“¾ä¸å®Œæ•´ç­‰é—®é¢˜éƒ½ä¼šè¢«å¿½ç•¥
- æ— æ³•ç¡®è®¤è¿æ¥çš„æœåŠ¡å™¨èº«ä»½æ˜¯å¦å¯ä¿¡

**æ”»å‡»åœºæ™¯ç¤ºä¾‹**ï¼š
1. æ”»å‡»è€…åœ¨ç½‘ç»œä¸­é—´æ‹¦æˆªå®¢æˆ·ç«¯è¯·æ±‚
2. ä½¿ç”¨è‡ªå·±çš„è¯ä¹¦ä¼ªè£…æˆç›®æ ‡æœåŠ¡å™¨
3. å› ä¸º `InsecureSkipVerify: true`ï¼Œå®¢æˆ·ç«¯æ¥å—äº†æ”»å‡»è€…çš„è¯ä¹¦
4. æ”»å‡»è€…å¯ä»¥è¯»å–ã€ç¯¡æ”¹æ‰€æœ‰é€šä¿¡å†…å®¹

**å—å½±å“çš„æ“ä½œ**ï¼š
- HTTPS API è°ƒç”¨
- æ•°æ®åº“è¿æ¥ï¼ˆPostgreSQLã€MySQL ç­‰ä½¿ç”¨ TLSï¼‰
- æ¶ˆæ¯é˜Ÿåˆ—è¿æ¥ï¼ˆRabbitMQã€Kafka ç­‰ä½¿ç”¨ TLSï¼‰
- ä»»ä½•ä½¿ç”¨è¯¥ TLS é…ç½®çš„ç½‘ç»œé€šä¿¡
DESC
}

desc(
	lang: golang
	alert_high: 1
	'file://unsafe_insecure_skip_verify.go': <<<UNSAFE
package main

import (
	"crypto/tls"
	"fmt"
	"io/ioutil"
	"net/http"
)

// æ¡ˆä¾‹1: åœ¨ http.Transport ä¸­è®¾ç½®
func unsafeHTTPClient1() {
	client := &http.Client{
		Transport: &http.Transport{
			TLSClientConfig: &tls.Config{
				InsecureSkipVerify: true, // â† ä¸¥é‡æ¼æ´ï¼
			},
		},
	}

	resp, err := client.Get("https://api.example.com/data")
	if err != nil {
		fmt.Println("Error:", err)
		return
	}
	defer resp.Body.Close()

	body, _ := ioutil.ReadAll(resp.Body)
	fmt.Println(string(body))
}

// æ¡ˆä¾‹2: åˆ›å»º TLS é…ç½®åä½¿ç”¨
func unsafeHTTPClient2() {
	tlsConfig := &tls.Config{
		InsecureSkipVerify: true, // â† ä¸¥é‡æ¼æ´ï¼
	}

	transport := &http.Transport{
		TLSClientConfig: tlsConfig,
	}

	client := &http.Client{
		Transport: transport,
	}

	client.Get("https://internal-api.company.com")
}

// æ¡ˆä¾‹3: åˆ†æ­¥è®¾ç½®å­—æ®µ
func unsafeHTTPClient3() {
	config := &tls.Config{}
	config.InsecureSkipVerify = true // â† ä¸¥é‡æ¼æ´ï¼

	client := &http.Client{
		Transport: &http.Transport{
			TLSClientConfig: config,
		},
	}

	client.Post("https://api.example.com/submit", "application/json", nil)
}

// æ¡ˆä¾‹4: åœ¨æ•°æ®åº“è¿æ¥ä¸­ä½¿ç”¨ï¼ˆå¦‚ PostgreSQLï¼‰
func unsafeDatabaseConnection() {
	tlsConfig := &tls.Config{
		InsecureSkipVerify: true, // â† ä¸¥é‡æ¼æ´ï¼
	}
	
	// è¿™ä¸ªä¸å®‰å…¨çš„é…ç½®å¯èƒ½è¢«ç”¨äºæ•°æ®åº“è¿æ¥
	_ = tlsConfig
}

func main() {
	unsafeHTTPClient1()
	unsafeHTTPClient2()
	unsafeHTTPClient3()
}
UNSAFE

	'safefile://safe_default_verification.go': <<<SAFE
package main

import (
	"fmt"
	"io/ioutil"
	"net/http"
	"time"
)

// æ–¹æ¡ˆ1: ä½¿ç”¨é»˜è®¤é…ç½®ï¼ˆæœ€å®‰å…¨ï¼Œæœ€ç®€å•ï¼‰
func safeHTTPClientDefault() {
	// ä¸éœ€è¦ä»»ä½•ç‰¹æ®Šé…ç½®ï¼Œé»˜è®¤å°±ä¼šéªŒè¯è¯ä¹¦
	client := &http.Client{
		Timeout: 10 * time.Second,
	}

	resp, err := client.Get("https://api.example.com/data")
	if err != nil {
		fmt.Println("Error:", err)
		return
	}
	defer resp.Body.Close()

	body, _ := ioutil.ReadAll(resp.Body)
	fmt.Println(string(body))
}

// æ–¹æ¡ˆ2: æ˜¾å¼é…ç½®å®‰å…¨çš„ TLS è®¾ç½®
func safeHTTPClientExplicit() {
	client := &http.Client{
		Transport: &http.Transport{
			TLSClientConfig: &tls.Config{
				// InsecureSkipVerify: false, // è¿™æ˜¯é»˜è®¤å€¼ï¼Œä¸éœ€è¦æ˜¾å¼è®¾ç½®
				MinVersion: tls.VersionTLS12, // å¼ºåˆ¶ä½¿ç”¨ TLS 1.2+
			},
		},
		Timeout: 30 * time.Second,
	}

	resp, err := client.Get("https://secure-api.example.com/data")
	if err != nil {
		fmt.Println("Error:", err)
		return
	}
	defer resp.Body.Close()
}

func main() {
	safeHTTPClientDefault()
	safeHTTPClientExplicit()
}
SAFE

	'safefile://safe_custom_ca.go': <<<SAFE
package main

import (
	"crypto/tls"
	"crypto/x509"
	"fmt"
	"io/ioutil"
	"log"
	"net/http"
	"time"
)

// æ–¹æ¡ˆ3: ä½¿ç”¨è‡ªå®šä¹‰CAè¯ä¹¦ï¼ˆé€‚ç”¨äºå†…éƒ¨æœåŠ¡å™¨ï¼‰
func safeHTTPClientWithCustomCA() (*http.Client, error) {
	// 1. è¯»å–å†…éƒ¨CAçš„æ ¹è¯ä¹¦æ–‡ä»¶
	caCert, err := ioutil.ReadFile("./internal-ca-root.crt")
	if err != nil {
		return nil, fmt.Errorf("failed to read CA certificate: %v", err)
	}

	// 2. åˆ›å»ºè¯ä¹¦æ± å¹¶æ·»åŠ CAè¯ä¹¦
	caCertPool := x509.NewCertPool()
	if !caCertPool.AppendCertsFromPEM(caCert) {
		return nil, fmt.Errorf("failed to parse CA certificate")
	}

	// 3. é…ç½®TLSï¼Œä½¿ç”¨è‡ªå®šä¹‰CAï¼Œä¿æŒéªŒè¯å¼€å¯
	tlsConfig := &tls.Config{
		RootCAs:    caCertPool,           // æŒ‡å®šä¿¡ä»»çš„CA
		MinVersion: tls.VersionTLS12,     // å¼ºåˆ¶ TLS 1.2+
		// InsecureSkipVerify: false,     // å¿…é¡»ä¿æŒéªŒè¯å¼€å¯ï¼ˆè¿™æ˜¯é»˜è®¤å€¼ï¼‰
	}

	// 4. åˆ›å»ºHTTPå®¢æˆ·ç«¯
	client := &http.Client{
		Transport: &http.Transport{
			TLSClientConfig: tlsConfig,
		},
		Timeout: 30 * time.Second,
	}

	return client, nil
}

// æ–¹æ¡ˆ4: åŒæ—¶ä¿¡ä»»ç³»ç»ŸCAå’Œè‡ªå®šä¹‰CA
func safeHTTPClientWithMultipleCAs() (*http.Client, error) {
	// 1. è·å–ç³»ç»Ÿé»˜è®¤çš„CAè¯ä¹¦æ± 
	systemCertPool, err := x509.SystemCertPool()
	if err != nil {
		// å¦‚æœæ— æ³•è·å–ç³»ç»Ÿè¯ä¹¦æ± ï¼Œåˆ›å»ºæ–°çš„ç©ºæ± 
		log.Printf("Warning: failed to load system cert pool: %v", err)
		systemCertPool = x509.NewCertPool()
	}

	// 2. è¯»å–å¹¶æ·»åŠ è‡ªå®šä¹‰CAè¯ä¹¦
	customCA, err := ioutil.ReadFile("./custom-ca.crt")
	if err != nil {
		return nil, fmt.Errorf("failed to read custom CA: %v", err)
	}

	if !systemCertPool.AppendCertsFromPEM(customCA) {
		return nil, fmt.Errorf("failed to parse custom CA certificate")
	}

	// 3. é…ç½®TLS
	tlsConfig := &tls.Config{
		RootCAs:    systemCertPool,       // åŒæ—¶ä¿¡ä»»ç³»ç»ŸCAå’Œè‡ªå®šä¹‰CA
		MinVersion: tls.VersionTLS12,
	}

	client := &http.Client{
		Transport: &http.Transport{
			TLSClientConfig: tlsConfig,
		},
		Timeout: 30 * time.Second,
	}

	return client, nil
}

func main() {
	// ä½¿ç”¨è‡ªå®šä¹‰CAçš„å®‰å…¨å®¢æˆ·ç«¯
	client, err := safeHTTPClientWithCustomCA()
	if err != nil {
		log.Fatal(err)
	}

	resp, err := client.Get("https://internal-server.company.com/api")
	if err != nil {
		log.Printf("Request failed: %v", err)
		return
	}
	defer resp.Body.Close()

	fmt.Printf("Response status: %s\n", resp.Status)
}
SAFE

	'safefile://safe_mutual_tls.go': <<<SAFE
package main

import (
	"crypto/tls"
	"crypto/x509"
	"fmt"
	"io/ioutil"
	"log"
	"net/http"
)

// æ–¹æ¡ˆ5: åŒå‘TLSè®¤è¯ï¼ˆå®¢æˆ·ç«¯è¯ä¹¦ + æœåŠ¡å™¨è¯ä¹¦éªŒè¯ï¼‰
func safeHTTPClientWithMutualTLS() (*http.Client, error) {
	// 1. åŠ è½½å®¢æˆ·ç«¯è¯ä¹¦å’Œç§é’¥
	clientCert, err := tls.LoadX509KeyPair(
		"./client-cert.pem",
		"./client-key.pem",
	)
	if err != nil {
		return nil, fmt.Errorf("failed to load client certificate: %v", err)
	}

	// 2. åŠ è½½æœåŠ¡å™¨CAè¯ä¹¦
	serverCACert, err := ioutil.ReadFile("./server-ca.crt")
	if err != nil {
		return nil, fmt.Errorf("failed to read server CA certificate: %v", err)
	}

	caCertPool := x509.NewCertPool()
	if !caCertPool.AppendCertsFromPEM(serverCACert) {
		return nil, fmt.Errorf("failed to parse server CA certificate")
	}

	// 3. é…ç½®åŒå‘TLS
	tlsConfig := &tls.Config{
		Certificates: []tls.Certificate{clientCert}, // å®¢æˆ·ç«¯è¯ä¹¦
		RootCAs:      caCertPool,                    // æœåŠ¡å™¨CAè¯ä¹¦
		MinVersion:   tls.VersionTLS12,
		// InsecureSkipVerify: false, // å¿…é¡»éªŒè¯æœåŠ¡å™¨è¯ä¹¦
	}

	client := &http.Client{
		Transport: &http.Transport{
			TLSClientConfig: tlsConfig,
		},
	}

	return client, nil
}

func main() {
	client, err := safeHTTPClientWithMutualTLS()
	if err != nil {
		log.Fatal(err)
	}

	resp, err := client.Get("https://secure-api.example.com/protected")
	if err != nil {
		log.Fatal(err)
	}
	defer resp.Body.Close()

	fmt.Printf("Mutual TLS connection successful: %s\n", resp.Status)
}
SAFE
)

