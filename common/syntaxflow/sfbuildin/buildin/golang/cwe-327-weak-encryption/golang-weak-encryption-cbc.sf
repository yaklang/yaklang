desc(
	title: "Detect Golang Weak Encryption Using AES-CBC Mode"
	title_zh: "æ£€æµ‹Golangä½¿ç”¨AES-CBCå¼±åŠ å¯†æ¨¡å¼"
	type: vuln
	severity: high
	risk: "weak_encryption"
	desc: <<<DESC
### æ¼æ´æè¿°

1. **æ¼æ´åŸç†**
   åœ¨ Go è¯­è¨€ä¸­ä½¿ç”¨ `cipher.NewCBCEncrypter` å’Œ `cipher.NewCBCDecrypter` åˆ›å»ºçš„ AES-CBC åŠ å¯†æ¨¡å¼å­˜åœ¨ä¸¥é‡çš„å®‰å…¨ç¼ºé™·ã€‚CBCï¼ˆCipher Block Chainingï¼‰æ¨¡å¼è™½ç„¶æ˜¯ç»å…¸çš„åˆ†ç»„å¯†ç æ¨¡å¼ï¼Œä½†åœ¨ç°ä»£å®‰å…¨æ ‡å‡†ä¸‹å·²è¢«è®¤ä¸ºæ˜¯ä¸å®‰å…¨çš„ï¼Œä¸»è¦é—®é¢˜åŒ…æ‹¬ï¼š
   
   - **ç¼ºä¹è®¤è¯æ€§ï¼ˆAuthenticationï¼‰**: CBC æ¨¡å¼ä¸æä¾›å¯†æ–‡å®Œæ•´æ€§éªŒè¯ã€‚æ”»å‡»è€…å¯ä»¥ç¯¡æ”¹å¯†æ–‡ï¼Œè€Œæ¥æ”¶æ–¹åœ¨è§£å¯†æ—¶æ— æ³•æ£€æµ‹åˆ°ç¯¡æ”¹ï¼Œè¿™å¯èƒ½å¯¼è‡´æ•°æ®å®Œæ•´æ€§è¢«ç ´å
   - **å¡«å……é¢„è¨€æ”»å‡»ï¼ˆPadding Oracle Attackï¼‰**: CBC æ¨¡å¼éœ€è¦å¯¹æ•°æ®è¿›è¡Œå¡«å……ï¼Œæ”»å‡»è€…å¯ä»¥é€šè¿‡è§‚å¯Ÿè§£å¯†é”™è¯¯ä¿¡æ¯æ¥é€å­—èŠ‚æ¢å¤æ˜æ–‡
   - **æ“ä½œå¤æ‚æ€§**: éœ€è¦æ‰‹åŠ¨å¤„ç† IVï¼ˆåˆå§‹åŒ–å‘é‡ï¼‰å’Œå¡«å……ï¼Œå®¹æ˜“å› å®ç°ä¸å½“å¼•å…¥å®‰å…¨æ¼æ´
   - **æ— æ³•æ£€æµ‹é‡æ”¾æ”»å‡»**: å³ä½¿å¯†æ–‡æœªè¢«ç¯¡æ”¹ï¼Œæ”»å‡»è€…ä¹Ÿå¯ä»¥é‡æ”¾æ—§çš„å¯†æ–‡
   
   **å¯¹æ¯”å®‰å…¨çš„ GCM æ¨¡å¼**:
   
   | ç‰¹æ€§ | CBC æ¨¡å¼ | GCM æ¨¡å¼ï¼ˆæ¨èï¼‰ |
   |------|---------|----------------|
   | **è®¤è¯æ€§** | âŒ æ— æ³•éªŒè¯å¯†æ–‡å®Œæ•´æ€§ | âœ… è‡ªåŠ¨ç”Ÿæˆè®¤è¯æ ‡ç­¾ï¼Œç¡®ä¿å®Œæ•´æ€§ |
   | **å¡«å……æ”»å‡»** | âŒ æ˜“å—å¡«å……é¢„è¨€æ”»å‡» | âœ… å…ç–«ï¼ˆæ— éœ€å¡«å……ï¼‰ |
   | **æ“ä½œå¤æ‚åº¦** | âš ï¸ éœ€æ‰‹åŠ¨å¤„ç† IV å’Œå¡«å…… | âœ… API ç®€æ´ï¼Œä¸æ˜“å‡ºé”™ |
   | **æ€§èƒ½** | âš ï¸ ä¸­ç­‰ | âœ… æ›´å¿«ï¼ˆç¡¬ä»¶åŠ é€Ÿæ”¯æŒï¼‰ |
   | **å®‰å…¨æ ‡å‡†** | âŒ å·²è¿‡æ—¶ï¼Œä¸æ¨è | âœ… NIST æ¨èï¼Œè¡Œä¸šæ ‡å‡† |

2. **è§¦å‘åœºæ™¯**
   è¯¥æ¼æ´é€šå¸¸å‡ºç°åœ¨ä»¥ä¸‹åœºæ™¯ï¼š
   - å¼€å‘è€…ä½¿ç”¨è¿‡æ—¶çš„åŠ å¯†ç¤ºä¾‹æˆ–æ•™ç¨‹ä»£ç 
   - ä»å…¶ä»–è¯­è¨€æˆ–æ—§ç³»ç»Ÿè¿ç§»æ—¶æ²¿ç”¨äº† CBC æ¨¡å¼
   - ä¸äº†è§£ CBC æ¨¡å¼çš„å®‰å…¨ç¼ºé™·ï¼Œè®¤ä¸º"åŠ å¯†äº†å°±å®‰å…¨"
   - éœ€è¦å¤„ç†æ•æ„Ÿæ•°æ®ï¼ˆå¯†ç ã€ä»¤ç‰Œã€ä¸ªäººä¿¡æ¯ã€æ”¯ä»˜æ•°æ®ï¼‰ä½†ä½¿ç”¨äº†å¼±åŠ å¯†
   
   ```go
   // ä¸å®‰å…¨çš„ CBC æ¨¡å¼åŠ å¯†
   func EncryptAESCBC(plaintext, key []byte) ([]byte, error) {
       block, err := aes.NewCipher(key)
       if err != nil {
           return nil, err
       }

       // æ·»åŠ  PKCS7 å¡«å……
       plaintext = PKCS7Padding(plaintext, aes.BlockSize)
       
       ciphertext := make([]byte, aes.BlockSize+len(plaintext))
       iv := ciphertext[:aes.BlockSize]
       
       if _, err := io.ReadFull(rand.Reader, iv); err != nil {
           return nil, err
       }

       // å±é™©ï¼šä½¿ç”¨ CBC æ¨¡å¼
       mode := cipher.NewCBCEncrypter(block, iv) // â† æ¼æ´ç‚¹
       mode.CryptBlocks(ciphertext[aes.BlockSize:], plaintext)
       
       return ciphertext, nil
   }

   // ä¸å®‰å…¨çš„ CBC æ¨¡å¼è§£å¯†
   func DecryptAESCBC(ciphertext, key []byte) ([]byte, error) {
       block, err := aes.NewCipher(key)
       if err != nil {
           return nil, err
       }

       if len(ciphertext) < aes.BlockSize {
           return nil, errors.New("ciphertext too short")
       }

       iv := ciphertext[:aes.BlockSize]
       ciphertext = ciphertext[aes.BlockSize:]

       // å±é™©ï¼šä½¿ç”¨ CBC æ¨¡å¼
       mode := cipher.NewCBCDecrypter(block, iv) // â† æ¼æ´ç‚¹
       mode.CryptBlocks(ciphertext, ciphertext)
       
       // ç§»é™¤å¡«å……
       plaintext := PKCS7UnPadding(ciphertext)
       
       return plaintext, nil
   }
   ```

3. **æ½œåœ¨å½±å“**
   - **æ•°æ®ç¯¡æ”¹æ”»å‡»**: 
     - æ”»å‡»è€…å¯ä»¥ä¿®æ”¹å¯†æ–‡çš„ç‰¹å®šä½ç½®ï¼Œå½±å“è§£å¯†åçš„æ˜æ–‡
     - æ— æ³•éªŒè¯æ•°æ®å®Œæ•´æ€§ï¼Œå¯èƒ½å¯¼è‡´ä¸šåŠ¡é€»è¾‘è¢«ç ´å
     - åœ¨é‡‘èã€åŒ»ç–—ç­‰åœºæ™¯å¯èƒ½é€ æˆä¸¥é‡åæœ
   
   - **å¡«å……é¢„è¨€æ”»å‡»ï¼ˆPadding Oracle Attackï¼‰**:
     - é€šè¿‡è§‚å¯Ÿè§£å¯†é”™è¯¯ï¼ˆå¦‚ "padding error"ï¼‰ï¼Œæ”»å‡»è€…å¯ä»¥é€å­—èŠ‚æ¢å¤æ˜æ–‡
     - è‘—åæ¡ˆä¾‹ï¼š2002 å¹´å¯¹ ASP.NET çš„æ”»å‡»ï¼ŒæˆåŠŸè§£å¯†äº†åŠ å¯†çš„ ViewState
     - å³ä½¿ä¸çŸ¥é“å¯†é’¥ï¼Œæ”»å‡»è€…ä¹Ÿå¯èƒ½æ¢å¤æ˜æ–‡æ•°æ®
   
   - **æ•æ„Ÿæ•°æ®æ³„éœ²**:
     - åŠ å¯†çš„å¯†ç ã€ä»¤ç‰Œã€API å¯†é’¥å¯èƒ½è¢«è§£å¯†
     - ä¸ªäººèº«ä»½ä¿¡æ¯ï¼ˆPIIï¼‰ã€æ”¯ä»˜ä¿¡æ¯å¯èƒ½æ³„éœ²
     - ä¼šè¯ Cookie å¯èƒ½è¢«ä¼ªé€ æˆ–ç¯¡æ”¹
   
   - **åˆè§„è¿è§„**:
     - **NIST SP 800-38D** æ˜ç¡®æ¨èä½¿ç”¨ GCM ç­‰è®¤è¯åŠ å¯†æ¨¡å¼
     - **PCI DSS** è¦æ±‚ä½¿ç”¨å¼ºåŠ å¯†ç®—æ³•å’Œæ¨¡å¼
     - **FIPS 140-2/3** è®¤è¯è¦æ±‚ä½¿ç”¨è®¤è¯åŠ å¯†
   
   - **å®é™…æ”»å‡»æ¡ˆä¾‹**:
     - **2002 - ASP.NET Padding Oracle**: æˆåŠŸè§£å¯†åŠ å¯†çš„ ViewState
     - **2010 - JavaServer Faces**: åˆ©ç”¨ CBC å¡«å……é¢„è¨€æ”»å‡»è·å–ä¼šè¯æ•°æ®
     - **2011 - BEAST Attack**: é’ˆå¯¹ TLS 1.0 CBC æ¨¡å¼çš„æ”»å‡»
     - **2013 - Lucky Thirteen**: é’ˆå¯¹ TLS CBC å®ç°çš„æ—¶åºæ”»å‡»

4. **ä¸ºä»€ä¹ˆå¼€å‘è€…è¿˜åœ¨ä½¿ç”¨ CBC æ¨¡å¼**
   - æ—©æœŸæ•™ç¨‹å’Œç¤ºä¾‹ä»£ç ä½¿ç”¨ CBC
   - ä¸é—ç•™ç³»ç»Ÿå…¼å®¹æ€§è¦æ±‚
   - ä¸äº†è§£ç°ä»£åŠ å¯†æœ€ä½³å®è·µ
   - è¯¯è®¤ä¸º CBC è¶³å¤Ÿå®‰å…¨ï¼ˆ"å·²ç»åŠ å¯†äº†"ï¼‰

DESC
	rule_id: "c3d4e5f6-weak-cbc-001"
	solution: <<<SOLUTION
### ä¿®å¤å»ºè®®

#### ğŸ”´ æ–¹æ¡ˆ 1: è¿ç§»åˆ° AES-GCM æ¨¡å¼ï¼ˆå¼ºçƒˆæ¨èï¼‰

**æœ€ä½³å®è·µ**ï¼šä½¿ç”¨ AES-GCMï¼ˆGalois/Counter Modeï¼‰æ›¿ä»£ CBCï¼Œæä¾›åŠ å¯†å’Œè®¤è¯åŒé‡ä¿æŠ¤ã€‚

```go
package main

import (
    "crypto/aes"
    "crypto/cipher"
    "crypto/rand"
    "errors"
    "io"
)

// EncryptAESGCM ä½¿ç”¨ AES-GCM æ¨¡å¼åŠ å¯†æ•°æ®ï¼ˆæ¨èï¼‰
func EncryptAESGCM(plaintext, key []byte) ([]byte, error) {
    // 1. åˆ›å»º AES cipher block
    block, err := aes.NewCipher(key)
    if err != nil {
        return nil, err
    }

    // 2. åˆ›å»º GCM æ¨¡å¼
    gcm, err := cipher.NewGCM(block)
    if err != nil {
        return nil, err
    }

    // 3. ç”Ÿæˆéšæœº nonceï¼ˆç›¸å½“äº IVï¼‰
    nonce := make([]byte, gcm.NonceSize()) // é€šå¸¸æ˜¯ 12 å­—èŠ‚
    if _, err := io.ReadFull(rand.Reader, nonce); err != nil {
        return nil, err
    }

    // 4. åŠ å¯†å¹¶è®¤è¯
    // Seal ä¼šè‡ªåŠ¨åŠ å¯†æ•°æ®å¹¶é™„åŠ è®¤è¯æ ‡ç­¾ï¼ˆauthentication tagï¼‰
    // è¿”å›æ ¼å¼: [nonce | ciphertext | auth_tag]
    ciphertext := gcm.Seal(nonce, nonce, plaintext, nil)
    
    return ciphertext, nil
}

// DecryptAESGCM ä½¿ç”¨ AES-GCM æ¨¡å¼è§£å¯†æ•°æ®
func DecryptAESGCM(ciphertext, key []byte) ([]byte, error) {
    // 1. åˆ›å»º AES cipher block
    block, err := aes.NewCipher(key)
    if err != nil {
        return nil, err
    }

    // 2. åˆ›å»º GCM æ¨¡å¼
    gcm, err := cipher.NewGCM(block)
    if err != nil {
        return nil, err
    }

    // 3. æå– nonce
    nonceSize := gcm.NonceSize()
    if len(ciphertext) < nonceSize {
        return nil, errors.New("ciphertext too short")
    }

    nonce := ciphertext[:nonceSize]
    ciphertext = ciphertext[nonceSize:]

    // 4. è§£å¯†å¹¶éªŒè¯
    // Open ä¼šè‡ªåŠ¨éªŒè¯è®¤è¯æ ‡ç­¾ï¼Œå¦‚æœå¯†æ–‡è¢«ç¯¡æ”¹ä¼šè¿”å›é”™è¯¯
    plaintext, err := gcm.Open(nil, nonce, ciphertext, nil)
    if err != nil {
        return nil, err // è®¤è¯å¤±è´¥ï¼å¯†æ–‡å¯èƒ½è¢«ç¯¡æ”¹
    }

    return plaintext, nil
}
```

**GCM æ¨¡å¼çš„ä¼˜åŠ¿**:
- âœ… **å†…ç½®è®¤è¯**: è‡ªåŠ¨éªŒè¯å¯†æ–‡å®Œæ•´æ€§ï¼Œä»»ä½•ç¯¡æ”¹éƒ½ä¼šè¢«æ£€æµ‹
- âœ… **æ— éœ€å¡«å……**: é¿å…å¡«å……é¢„è¨€æ”»å‡»
- âœ… **æ€§èƒ½ä¼˜ç§€**: æ”¯æŒç¡¬ä»¶åŠ é€Ÿï¼ˆAES-NIï¼‰
- âœ… **API ç®€æ´**: å‡å°‘å®ç°é”™è¯¯
- âœ… **ä¸šç•Œæ ‡å‡†**: NIST æ¨èï¼ŒTLS 1.3 é»˜è®¤æ¨¡å¼

#### ğŸŸ¡ æ–¹æ¡ˆ 2: ä½¿ç”¨ AES-GCM å¹¶æ”¯æŒé™„åŠ è®¤è¯æ•°æ®ï¼ˆAADï¼‰

**é«˜çº§ç”¨æ³•**ï¼šGCM æ”¯æŒé™„åŠ è®¤è¯æ•°æ®ï¼ˆAdditional Authenticated Dataï¼‰ï¼Œå¯ä»¥å°†ä¸€äº›ä¸éœ€è¦åŠ å¯†ä½†éœ€è¦è®¤è¯çš„æ•°æ®ï¼ˆå¦‚åè®®å¤´ã€ç‰ˆæœ¬å·ï¼‰åŒ…å«åœ¨è®¤è¯è®¡ç®—ä¸­ã€‚

```go
// EncryptAESGCMWithAAD ä½¿ç”¨ AES-GCM åŠ å¯†ï¼Œå¹¶æ”¯æŒé™„åŠ è®¤è¯æ•°æ®
func EncryptAESGCMWithAAD(plaintext, key, additionalData []byte) ([]byte, error) {
    block, err := aes.NewCipher(key)
    if err != nil {
        return nil, err
    }

    gcm, err := cipher.NewGCM(block)
    if err != nil {
        return nil, err
    }

    nonce := make([]byte, gcm.NonceSize())
    if _, err := io.ReadFull(rand.Reader, nonce); err != nil {
        return nil, err
    }

    // ç¬¬å››ä¸ªå‚æ•°æ˜¯é™„åŠ è®¤è¯æ•°æ®ï¼ˆAADï¼‰
    // AAD ä¸ä¼šè¢«åŠ å¯†ï¼Œä½†ä¼šè¢«åŒ…å«åœ¨è®¤è¯è®¡ç®—ä¸­
    ciphertext := gcm.Seal(nonce, nonce, plaintext, additionalData)
    
    return ciphertext, nil
}

// DecryptAESGCMWithAAD ä½¿ç”¨ AES-GCM è§£å¯†ï¼Œå¹¶éªŒè¯é™„åŠ è®¤è¯æ•°æ®
func DecryptAESGCMWithAAD(ciphertext, key, additionalData []byte) ([]byte, error) {
    block, err := aes.NewCipher(key)
    if err != nil {
        return nil, err
    }

    gcm, err := cipher.NewGCM(block)
    if err != nil {
        return nil, err
    }

    nonceSize := gcm.NonceSize()
    if len(ciphertext) < nonceSize {
        return nil, errors.New("ciphertext too short")
    }

    nonce := ciphertext[:nonceSize]
    ciphertext = ciphertext[nonceSize:]

    // æä¾›ç›¸åŒçš„ AADï¼Œå¦åˆ™è®¤è¯ä¼šå¤±è´¥
    plaintext, err := gcm.Open(nil, nonce, ciphertext, additionalData)
    if err != nil {
        return nil, err // AAD ä¸åŒ¹é…æˆ–å¯†æ–‡è¢«ç¯¡æ”¹
    }

    return plaintext, nil
}

// ä½¿ç”¨ç¤ºä¾‹
func example() {
    key := make([]byte, 32) // AES-256
    io.ReadFull(rand.Reader, key)
    
    plaintext := []byte("sensitive data")
    aad := []byte("version:1.0;user:alice") // é™„åŠ è®¤è¯æ•°æ®
    
    // åŠ å¯†
    ciphertext, _ := EncryptAESGCMWithAAD(plaintext, key, aad)
    
    // è§£å¯†ï¼ˆå¿…é¡»æä¾›ç›¸åŒçš„ AADï¼‰
    decrypted, err := DecryptAESGCMWithAAD(ciphertext, key, aad)
    if err != nil {
        log.Fatal("Authentication failed!") // AAD ä¸åŒ¹é…æˆ–å¯†æ–‡è¢«ç¯¡æ”¹
    }
}
```

#### ğŸŸ¢ æ–¹æ¡ˆ 3: ä½¿ç”¨ ChaCha20-Poly1305ï¼ˆå¤‡é€‰æ–¹æ¡ˆï¼‰

**æ›¿ä»£é€‰æ‹©**ï¼šå¦‚æœä¸æƒ³ä½¿ç”¨ AES-GCMï¼Œå¯ä»¥ä½¿ç”¨ ChaCha20-Poly1305ï¼Œå®ƒåŒæ ·æ˜¯è®¤è¯åŠ å¯†æ¨¡å¼ã€‚

```go
import (
    "crypto/rand"
    "errors"
    "io"
    
    "golang.org/x/crypto/chacha20poly1305"
)

// EncryptChaCha20Poly1305 ä½¿ç”¨ ChaCha20-Poly1305 åŠ å¯†
func EncryptChaCha20Poly1305(plaintext, key []byte) ([]byte, error) {
    // å¯†é’¥å¿…é¡»æ˜¯ 32 å­—èŠ‚
    if len(key) != chacha20poly1305.KeySize {
        return nil, errors.New("invalid key size")
    }

    aead, err := chacha20poly1305.New(key)
    if err != nil {
        return nil, err
    }

    nonce := make([]byte, aead.NonceSize()) // 12 å­—èŠ‚
    if _, err := io.ReadFull(rand.Reader, nonce); err != nil {
        return nil, err
    }

    ciphertext := aead.Seal(nonce, nonce, plaintext, nil)
    return ciphertext, nil
}

// DecryptChaCha20Poly1305 ä½¿ç”¨ ChaCha20-Poly1305 è§£å¯†
func DecryptChaCha20Poly1305(ciphertext, key []byte) ([]byte, error) {
    if len(key) != chacha20poly1305.KeySize {
        return nil, errors.New("invalid key size")
    }

    aead, err := chacha20poly1305.New(key)
    if err != nil {
        return nil, err
    }

    nonceSize := aead.NonceSize()
    if len(ciphertext) < nonceSize {
        return nil, errors.New("ciphertext too short")
    }

    nonce := ciphertext[:nonceSize]
    ciphertext = ciphertext[nonceSize:]

    plaintext, err := aead.Open(nil, nonce, ciphertext, nil)
    if err != nil {
        return nil, err
    }

    return plaintext, nil
}
```

**ChaCha20-Poly1305 ä¼˜åŠ¿**:
- âœ… ä¸ä¾èµ–ç¡¬ä»¶åŠ é€Ÿï¼Œè½¯ä»¶å®ç°æ€§èƒ½ä¼˜ç§€
- âœ… æŠ—æ—¶åºæ”»å‡»
- âœ… ç§»åŠ¨è®¾å¤‡å’ŒåµŒå…¥å¼ç³»ç»Ÿå‹å¥½

#### ğŸ”µ æ–¹æ¡ˆ 4: è¿ç§»ç­–ç•¥ï¼ˆå¤„ç†é—ç•™æ•°æ®ï¼‰

**å¦‚æœç³»ç»Ÿå·²æœ‰ CBC åŠ å¯†çš„æ•°æ®**ï¼Œéœ€è¦å¹³æ»‘è¿ç§»ï¼š

```go
// æ•°æ®ç‰ˆæœ¬æ ‡è¯†
const (
    VersionCBC = 0x01 // é—ç•™çš„ CBC æ¨¡å¼
    VersionGCM = 0x02 // æ–°çš„ GCM æ¨¡å¼
)

// EncryptAdaptive æ–°æ•°æ®ä½¿ç”¨ GCM æ¨¡å¼
func EncryptAdaptive(plaintext, key []byte) ([]byte, error) {
    // ä½¿ç”¨ GCM åŠ å¯†
    ciphertext, err := EncryptAESGCM(plaintext, key)
    if err != nil {
        return nil, err
    }
    
    // æ·»åŠ ç‰ˆæœ¬æ ‡è¯†
    result := make([]byte, 1+len(ciphertext))
    result[0] = VersionGCM
    copy(result[1:], ciphertext)
    
    return result, nil
}

// DecryptAdaptive å…¼å®¹å¤„ç† CBC å’Œ GCM æ•°æ®
func DecryptAdaptive(data, key []byte) ([]byte, error) {
    if len(data) < 1 {
        return nil, errors.New("data too short")
    }
    
    version := data[0]
    ciphertext := data[1:]
    
    switch version {
    case VersionGCM:
        // ä½¿ç”¨ GCM è§£å¯†ï¼ˆæ–°æ•°æ®ï¼‰
        return DecryptAESGCM(ciphertext, key)
        
    case VersionCBC:
        // ä½¿ç”¨ CBC è§£å¯†ï¼ˆé—ç•™æ•°æ®ï¼‰
        log.Println("âš ï¸  WARNING: Using deprecated CBC mode for legacy data")
        plaintext, err := DecryptAESCBC(ciphertext, key)
        if err != nil {
            return nil, err
        }
        
        // é‡è¦ï¼šè§£å¯†åç«‹å³ç”¨ GCM é‡æ–°åŠ å¯†å¹¶æ›´æ–°å­˜å‚¨
        go func() {
            newCiphertext, _ := EncryptAdaptive(plaintext, key)
            // æ›´æ–°æ•°æ®åº“æˆ–å­˜å‚¨
            updateStorage(newCiphertext)
        }()
        
        return plaintext, nil
        
    default:
        return nil, errors.New("unknown encryption version")
    }
}

// è¿ç§»ä»»åŠ¡ï¼šæ‰¹é‡è½¬æ¢é—ç•™æ•°æ®
func MigrateLegacyData(db Database, key []byte) error {
    // æŸ¥è¯¢æ‰€æœ‰ CBC åŠ å¯†çš„æ•°æ®
    records, err := db.Query("SELECT id, encrypted_data FROM users WHERE encryption_version = ?", VersionCBC)
    if err != nil {
        return err
    }
    
    for _, record := range records {
        // è§£å¯†æ—§æ•°æ®
        plaintext, err := DecryptAESCBC(record.EncryptedData, key)
        if err != nil {
            log.Printf("Failed to decrypt record %d: %v", record.ID, err)
            continue
        }
        
        // ç”¨ GCM é‡æ–°åŠ å¯†
        newCiphertext, err := EncryptAESGCM(plaintext, key)
        if err != nil {
            log.Printf("Failed to re-encrypt record %d: %v", record.ID, err)
            continue
        }
        
        // æ›´æ–°æ•°æ®åº“
        err = db.Update("UPDATE users SET encrypted_data = ?, encryption_version = ? WHERE id = ?",
            newCiphertext, VersionGCM, record.ID)
        if err != nil {
            log.Printf("Failed to update record %d: %v", record.ID, err)
            continue
        }
        
        log.Printf("Migrated record %d from CBC to GCM", record.ID)
    }
    
    return nil
}
```

#### ğŸ“‹ å¯†é’¥ç®¡ç†æœ€ä½³å®è·µ

**æ— è®ºä½¿ç”¨å“ªç§åŠ å¯†æ¨¡å¼ï¼Œå¯†é’¥ç®¡ç†éƒ½è‡³å…³é‡è¦**ï¼š

```go
import (
    "crypto/rand"
    "encoding/base64"
)

// GenerateSecureKey ç”Ÿæˆå®‰å…¨çš„éšæœºå¯†é’¥
func GenerateSecureKey(size int) ([]byte, error) {
    key := make([]byte, size)
    if _, err := io.ReadFull(rand.Reader, key); err != nil {
        return nil, err
    }
    return key, nil
}

// å¯†é’¥å¤§å°é€‰æ‹©
const (
    KeySize128 = 16 // AES-128 (è¶³å¤Ÿå®‰å…¨ï¼Œæ€§èƒ½å¥½)
    KeySize192 = 24 // AES-192 (ä¸­ç­‰)
    KeySize256 = 32 // AES-256 (æœ€é«˜å®‰å…¨æ€§)
)

// æœ€ä½³å®è·µç¤ºä¾‹
func example() {
    // 1. ç”Ÿæˆå¼ºå¯†é’¥ï¼ˆAES-256ï¼‰
    key, err := GenerateSecureKey(KeySize256)
    if err != nil {
        log.Fatal(err)
    }
    
    // 2. å®‰å…¨å­˜å‚¨å¯†é’¥ï¼ˆä½¿ç”¨å¯†é’¥ç®¡ç†æœåŠ¡ï¼‰
    // âŒ ä¸è¦ç¡¬ç¼–ç ï¼škey := []byte("my-secret-key")
    // âœ… ä½¿ç”¨ç¯å¢ƒå˜é‡æˆ–å¯†é’¥ç®¡ç†æœåŠ¡
    SaveKeyToVault(key) // å¦‚ AWS KMS, HashiCorp Vault, Azure Key Vault
    
    // 3. å®šæœŸè½®æ¢å¯†é’¥
    // å»ºè®®æ¯ 90 å¤©è½®æ¢ä¸€æ¬¡
    
    // 4. ä½¿ç”¨å¯†é’¥æ´¾ç”Ÿï¼ˆä»å¯†ç ç”Ÿæˆå¯†é’¥ï¼‰
    // å¦‚æœä»ç”¨æˆ·å¯†ç æ´¾ç”Ÿï¼Œä½¿ç”¨ PBKDF2ã€bcrypt æˆ– Argon2
}
```

#### âš ï¸ å®‰å…¨æ£€æŸ¥æ¸…å•

åœ¨è¿ç§»åˆ° GCM æˆ–éƒ¨ç½²æ–°ä»£ç å‰ï¼Œè¯·ç¡®ä¿ï¼š

- [ ] **åˆ é™¤æ‰€æœ‰ CBC æ¨¡å¼ä»£ç **ï¼ˆæˆ–ä»…ä¿ç•™ç”¨äºè¿ç§»é—ç•™æ•°æ®ï¼‰
- [ ] **ä½¿ç”¨ AES-GCM æˆ– ChaCha20-Poly1305**
- [ ] **ç”Ÿæˆå®‰å…¨çš„éšæœºå¯†é’¥**ï¼ˆä½¿ç”¨ `crypto/rand`ï¼‰
- [ ] **å¯†é’¥é•¿åº¦æ­£ç¡®**ï¼ˆAES-128/192/256: 16/24/32 å­—èŠ‚ï¼‰
- [ ] **ä¸åœ¨ä»£ç ä¸­ç¡¬ç¼–ç å¯†é’¥**
- [ ] **ä½¿ç”¨å¯†é’¥ç®¡ç†æœåŠ¡**ï¼ˆAWS KMSã€HashiCorp Vault ç­‰ï¼‰
- [ ] **å®šæœŸè½®æ¢å¯†é’¥**ï¼ˆå»ºè®® 90 å¤©ï¼‰
- [ ] **è®°å½•å’Œç›‘æ§è§£å¯†å¤±è´¥**ï¼ˆå¯èƒ½è¡¨ç¤ºæ”»å‡»ï¼‰
- [ ] **åœ¨æµ‹è¯•ç¯å¢ƒéªŒè¯åŠ å¯†/è§£å¯†æµç¨‹**
- [ ] **åˆ¶å®šé—ç•™æ•°æ®è¿ç§»è®¡åˆ’**ï¼ˆå¦‚æœ‰ CBC æ•°æ®ï¼‰
- [ ] **æ›´æ–°æ–‡æ¡£å’ŒåŸ¹è®­å¼€å‘å›¢é˜Ÿ**

SOLUTION
	reference: <<<REFERENCE
[CWE-327: Use of a Broken or Risky Cryptographic Algorithm](https://cwe.mitre.org/data/definitions/327.html)
[NIST SP 800-38D: Recommendation for Block Cipher Modes of Operation: Galois/Counter Mode (GCM)](https://csrc.nist.gov/publications/detail/sp/800-38d/final)
[Go crypto/cipher Package](https://pkg.go.dev/crypto/cipher)
[OWASP: Cryptographic Storage Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html)
[Padding Oracle Attack](https://en.wikipedia.org/wiki/Padding_oracle_attack)
REFERENCE
)

cipher?{<fullTypeName>?{have: 'crypto/cipher'}} as $cipher
aes?{<fullTypeName>?{have: 'crypto/aes'}} as $aes

$cipher.NewCBCEncrypter(* #-> as $block, * #-> as $iv) as $cbc_encrypter;
$cipher.NewCBCDecrypter(* #-> as $block, * #-> as $iv) as $cbc_decrypter;

$cbc_encrypter as $weak_cbc;
$cbc_decrypter as $weak_cbc;

$weak_cbc as $high;

alert $high for {
	type: "vuln",
	title: "Golang Weak Encryption Using AES-CBC Mode Detected",
	title_zh: "æ£€æµ‹åˆ°Golangä½¿ç”¨AES-CBCå¼±åŠ å¯†æ¨¡å¼",
	level: "high",
	name: "high",
	message: "æ£€æµ‹åˆ°ä½¿ç”¨ AES-CBC åŠ å¯†æ¨¡å¼ï¼Œè¿™æ˜¯ä¸€ç§ä¸å®‰å…¨çš„åŠ å¯†æ–¹å¼ã€‚CBC æ¨¡å¼ä¸æä¾›å¯†æ–‡å®Œæ•´æ€§éªŒè¯ï¼ˆæ— è®¤è¯ï¼‰ï¼Œå®¹æ˜“é­å—å¡«å……é¢„è¨€æ”»å‡»ï¼ˆPadding Oracle Attackï¼‰å’Œæ•°æ®ç¯¡æ”¹æ”»å‡»ã€‚æ”»å‡»è€…å¯ä»¥åœ¨ä¸çŸ¥é“å¯†é’¥çš„æƒ…å†µä¸‹ï¼Œé€šè¿‡è§‚å¯Ÿè§£å¯†é”™è¯¯é€å­—èŠ‚æ¢å¤æ˜æ–‡ï¼Œæˆ–ç¯¡æ”¹å¯†æ–‡è€Œä¸è¢«æ£€æµ‹ã€‚åº”è¯¥ä½¿ç”¨ AES-GCM æˆ– ChaCha20-Poly1305 ç­‰è®¤è¯åŠ å¯†æ¨¡å¼ã€‚",
	solution: <<<SOLUTION
### ä¿®å¤å»ºè®®

**ç«‹å³è¿ç§»åˆ° AES-GCM æ¨¡å¼ï¼ˆè®¤è¯åŠ å¯†ï¼‰**ï¼š

```go
import (
    "crypto/aes"
    "crypto/cipher"
    "crypto/rand"
    "io"
)

// âœ… å®‰å…¨ï¼šä½¿ç”¨ AES-GCM
func EncryptAESGCM(plaintext, key []byte) ([]byte, error) {
    block, err := aes.NewCipher(key)
    if err != nil {
        return nil, err
    }

    gcm, err := cipher.NewGCM(block)
    if err != nil {
        return nil, err
    }

    nonce := make([]byte, gcm.NonceSize())
    io.ReadFull(rand.Reader, nonce)

    // Seal è‡ªåŠ¨åŠ å¯†å¹¶æ·»åŠ è®¤è¯æ ‡ç­¾
    ciphertext := gcm.Seal(nonce, nonce, plaintext, nil)
    return ciphertext, nil
}

func DecryptAESGCM(ciphertext, key []byte) ([]byte, error) {
    block, err := aes.NewCipher(key)
    if err != nil {
        return nil, err
    }

    gcm, err := cipher.NewGCM(block)
    if err != nil {
        return nil, err
    }

    nonceSize := gcm.NonceSize()
    nonce, ciphertext := ciphertext[:nonceSize], ciphertext[nonceSize:]

    // Open è‡ªåŠ¨éªŒè¯è®¤è¯æ ‡ç­¾ï¼Œå¦‚æœå¯†æ–‡è¢«ç¯¡æ”¹ä¼šè¿”å›é”™è¯¯
    return gcm.Open(nil, nonce, ciphertext, nil)
}
```

**GCM æ¨¡å¼çš„ä¼˜åŠ¿**ï¼š
- âœ… æä¾›åŠ å¯† + è®¤è¯åŒé‡ä¿æŠ¤
- âœ… è‡ªåŠ¨æ£€æµ‹å¯†æ–‡ç¯¡æ”¹
- âœ… å…ç–«å¡«å……é¢„è¨€æ”»å‡»ï¼ˆæ— éœ€å¡«å……ï¼‰
- âœ… NIST æ¨èæ ‡å‡†
SOLUTION
	risk: "å¼±åŠ å¯†ç®—æ³•",
	desc: <<<DESC
### è¯¦ç»†è¯´æ˜

æ£€æµ‹åˆ°ä»£ç ä¸­ä½¿ç”¨ `cipher.NewCBCEncrypter` æˆ– `cipher.NewCBCDecrypter` åˆ›å»º CBC æ¨¡å¼åŠ å¯†å™¨ã€‚

**é£é™©ç­‰çº§ï¼šğŸŸ  HIGHï¼ˆé«˜å±ï¼‰**

**é—®é¢˜**ï¼š
- CBC æ¨¡å¼ä¸æä¾›å¯†æ–‡å®Œæ•´æ€§éªŒè¯ï¼ˆæ— è®¤è¯ï¼‰
- å®¹æ˜“é­å—å¡«å……é¢„è¨€æ”»å‡»ï¼ˆPadding Oracle Attackï¼‰
- æ”»å‡»è€…å¯ä»¥ç¯¡æ”¹å¯†æ–‡è€Œä¸è¢«æ£€æµ‹
- æ”»å‡»è€…å¯èƒ½åœ¨ä¸çŸ¥é“å¯†é’¥çš„æƒ…å†µä¸‹æ¢å¤æ˜æ–‡

**è‘—åæ”»å‡»æ¡ˆä¾‹**ï¼š
- 2002: ASP.NET Padding Oracle Attack
- 2010: JavaServer Faces CBC æ”»å‡»
- 2011: BEAST Attack (TLS 1.0)

**åˆè§„è¦æ±‚**ï¼š
- NIST SP 800-38D æ¨èä½¿ç”¨ GCM æ¨¡å¼
- PCI DSS è¦æ±‚ä½¿ç”¨å¼ºåŠ å¯†
- FIPS 140-2/3 è¦æ±‚è®¤è¯åŠ å¯†

**å»ºè®®**ï¼š
- ä½¿ç”¨ AES-GCMï¼ˆ`cipher.NewGCM`ï¼‰æ›¿ä»£ CBC
- æˆ–ä½¿ç”¨ ChaCha20-Poly1305
- è¿ç§»æ‰€æœ‰é—ç•™çš„ CBC åŠ å¯†æ•°æ®
DESC
}

desc(
	lang: golang
	alert_high: 2
	'file://unsafe_aes_cbc.go': <<<UNSAFE
package main

import (
	"crypto/aes"
	"crypto/cipher"
	"crypto/rand"
	"errors"
	"io"
)

// æ¡ˆä¾‹ 1: ä½¿ç”¨ CBC æ¨¡å¼åŠ å¯†ï¼ˆä¸å®‰å…¨ï¼‰
func EncryptAESCBC(plaintext, key []byte) ([]byte, error) {
	block, err := aes.NewCipher(key)
	if err != nil {
		return nil, err
	}

	// æ·»åŠ  PKCS7 å¡«å……
	plaintext = PKCS7Padding(plaintext, aes.BlockSize)
	
	ciphertext := make([]byte, aes.BlockSize+len(plaintext))
	iv := ciphertext[:aes.BlockSize]
	
	if _, err := io.ReadFull(rand.Reader, iv); err != nil {
		return nil, err
	}

	// å±é™©ï¼šä½¿ç”¨ CBC æ¨¡å¼åŠ å¯†
	mode := cipher.NewCBCEncrypter(block, iv) // â† æ¼æ´ç‚¹
	mode.CryptBlocks(ciphertext[aes.BlockSize:], plaintext)
	
	return ciphertext, nil
}

// æ¡ˆä¾‹ 2: ä½¿ç”¨ CBC æ¨¡å¼è§£å¯†ï¼ˆä¸å®‰å…¨ï¼‰
func DecryptAESCBC(ciphertext, key []byte) ([]byte, error) {
	block, err := aes.NewCipher(key)
	if err != nil {
		return nil, err
	}

	if len(ciphertext) < aes.BlockSize {
		return nil, errors.New("ciphertext too short")
	}

	iv := ciphertext[:aes.BlockSize]
	ciphertext = ciphertext[aes.BlockSize:]

	if len(ciphertext)%aes.BlockSize != 0 {
		return nil, errors.New("ciphertext is not a multiple of block size")
	}

	// å±é™©ï¼šä½¿ç”¨ CBC æ¨¡å¼è§£å¯†
	mode := cipher.NewCBCDecrypter(block, iv) // â† æ¼æ´ç‚¹
	mode.CryptBlocks(ciphertext, ciphertext)
	
	// ç§»é™¤å¡«å…… - å¯èƒ½æ³„éœ²å¡«å……é”™è¯¯ä¿¡æ¯ï¼ˆPadding Oracleï¼‰
	plaintext, err := PKCS7UnPadding(ciphertext)
	if err != nil {
		return nil, err // â† æ”»å‡»è€…å¯ä»¥åˆ©ç”¨è¿™ä¸ªé”™è¯¯
	}
	
	return plaintext, nil
}

// æ¡ˆä¾‹ 3: å¤„ç†æ•æ„Ÿæ•°æ®ä½†ä½¿ç”¨ CBC
func EncryptPassword(password string, key []byte) ([]byte, error) {
	// å±é™©ï¼šå¯†ç ä½¿ç”¨ CBC åŠ å¯†ï¼Œå®¹æ˜“è¢«æ”»å‡»
	return EncryptAESCBC([]byte(password), key)
}

func EncryptAPIKey(apiKey string, key []byte) ([]byte, error) {
	// å±é™©ï¼šAPI å¯†é’¥ä½¿ç”¨ CBC åŠ å¯†
	return EncryptAESCBC([]byte(apiKey), key)
}

// PKCS7 å¡«å……
func PKCS7Padding(data []byte, blockSize int) []byte {
	padding := blockSize - len(data)%blockSize
	padtext := make([]byte, padding)
	for i := range padtext {
		padtext[i] = byte(padding)
	}
	return append(data, padtext...)
}

// PKCS7 å»å¡«å…… - å¡«å……é¢„è¨€æ”»å‡»çš„æ¥æº
func PKCS7UnPadding(data []byte) ([]byte, error) {
	length := len(data)
	if length == 0 {
		return nil, errors.New("invalid padding")
	}
	
	padding := int(data[length-1])
	if padding > length || padding > 16 {
		return nil, errors.New("invalid padding") // â† æ”»å‡»è€…å¯ä»¥åˆ©ç”¨è¿™ä¸ªé”™è¯¯
	}
	
	// éªŒè¯å¡«å……
	for i := 0; i < padding; i++ {
		if data[length-1-i] != byte(padding) {
			return nil, errors.New("invalid padding") // â† å¡«å……é¢„è¨€
		}
	}
	
	return data[:length-padding], nil
}

func main() {
	key := make([]byte, 32) // AES-256
	io.ReadFull(rand.Reader, key)
	
	// åŠ å¯†æ•æ„Ÿæ•°æ®
	encrypted, _ := EncryptPassword("mySecretPassword", key)
	
	// è§£å¯†
	decrypted, err := DecryptAESCBC(encrypted, key)
	if err != nil {
		// æ”»å‡»è€…å¯ä»¥é€šè¿‡è§‚å¯Ÿè¿™ä¸ªé”™è¯¯æ¥æ¢å¤æ˜æ–‡
		println("Decryption failed:", err.Error())
	}
}
UNSAFE

	'safefile://safe_aes_gcm.go': <<<SAFE
package main

import (
	"crypto/aes"
	"crypto/cipher"
	"crypto/rand"
	"errors"
	"io"
	"log"
)

// æ–¹æ¡ˆ 1: ä½¿ç”¨ AES-GCM åŠ å¯†ï¼ˆæ¨èï¼‰
func EncryptAESGCM(plaintext, key []byte) ([]byte, error) {
	// 1. åˆ›å»º AES cipher
	block, err := aes.NewCipher(key)
	if err != nil {
		return nil, err
	}

	// 2. åˆ›å»º GCM æ¨¡å¼
	gcm, err := cipher.NewGCM(block)
	if err != nil {
		return nil, err
	}

	// 3. ç”Ÿæˆéšæœº nonce
	nonce := make([]byte, gcm.NonceSize())
	if _, err := io.ReadFull(rand.Reader, nonce); err != nil {
		return nil, err
	}

	// 4. åŠ å¯†å¹¶è®¤è¯
	// Seal è‡ªåŠ¨åŠ å¯†æ•°æ®å¹¶é™„åŠ è®¤è¯æ ‡ç­¾
	ciphertext := gcm.Seal(nonce, nonce, plaintext, nil)
	
	return ciphertext, nil
}

// ä½¿ç”¨ AES-GCM è§£å¯†
func DecryptAESGCM(ciphertext, key []byte) ([]byte, error) {
	block, err := aes.NewCipher(key)
	if err != nil {
		return nil, err
	}

	gcm, err := cipher.NewGCM(block)
	if err != nil {
		return nil, err
	}

	nonceSize := gcm.NonceSize()
	if len(ciphertext) < nonceSize {
		return nil, errors.New("ciphertext too short")
	}

	nonce := ciphertext[:nonceSize]
	ciphertext = ciphertext[nonceSize:]

	// Open è‡ªåŠ¨éªŒè¯è®¤è¯æ ‡ç­¾
	// å¦‚æœå¯†æ–‡è¢«ç¯¡æ”¹ï¼Œä¼šè¿”å›é”™è¯¯
	plaintext, err := gcm.Open(nil, nonce, ciphertext, nil)
	if err != nil {
		return nil, err // è®¤è¯å¤±è´¥ï¼
	}

	return plaintext, nil
}

// æ–¹æ¡ˆ 2: ä½¿ç”¨ AES-GCM å¹¶æ”¯æŒé™„åŠ è®¤è¯æ•°æ®
func EncryptAESGCMWithAAD(plaintext, key, additionalData []byte) ([]byte, error) {
	block, err := aes.NewCipher(key)
	if err != nil {
		return nil, err
	}

	gcm, err := cipher.NewGCM(block)
	if err != nil {
		return nil, err
	}

	nonce := make([]byte, gcm.NonceSize())
	if _, err := io.ReadFull(rand.Reader, nonce); err != nil {
		return nil, err
	}

	// é™„åŠ è®¤è¯æ•°æ®ï¼ˆAADï¼‰ä¸ä¼šè¢«åŠ å¯†ï¼Œä½†ä¼šè¢«è®¤è¯
	ciphertext := gcm.Seal(nonce, nonce, plaintext, additionalData)
	
	return ciphertext, nil
}

func DecryptAESGCMWithAAD(ciphertext, key, additionalData []byte) ([]byte, error) {
	block, err := aes.NewCipher(key)
	if err != nil {
		return nil, err
	}

	gcm, err := cipher.NewGCM(block)
	if err != nil {
		return nil, err
	}

	nonceSize := gcm.NonceSize()
	if len(ciphertext) < nonceSize {
		return nil, errors.New("ciphertext too short")
	}

	nonce := ciphertext[:nonceSize]
	ciphertext = ciphertext[nonceSize:]

	// AAD å¿…é¡»åŒ¹é…ï¼Œå¦åˆ™è®¤è¯å¤±è´¥
	plaintext, err := gcm.Open(nil, nonce, ciphertext, additionalData)
	if err != nil {
		return nil, err
	}

	return plaintext, nil
}

// å®‰å…¨åœ°åŠ å¯†æ•æ„Ÿæ•°æ®
func EncryptPassword(password string, key []byte) ([]byte, error) {
	// å®‰å…¨ï¼šä½¿ç”¨ GCM åŠ å¯†å¯†ç 
	return EncryptAESGCM([]byte(password), key)
}

func EncryptAPIKey(apiKey string, key []byte) ([]byte, error) {
	// å®‰å…¨ï¼šä½¿ç”¨ GCM åŠ å¯† API å¯†é’¥
	// å¯ä»¥æ·»åŠ  AAD æ¥ç»‘å®šä¸Šä¸‹æ–‡ä¿¡æ¯
	aad := []byte("api-key-v1")
	return EncryptAESGCMWithAAD([]byte(apiKey), key, aad)
}

func main() {
	// ç”Ÿæˆå®‰å…¨çš„å¯†é’¥
	key := make([]byte, 32) // AES-256
	if _, err := io.ReadFull(rand.Reader, key); err != nil {
		log.Fatal(err)
	}
	
	// åŠ å¯†
	plaintext := []byte("sensitive data")
	encrypted, err := EncryptAESGCM(plaintext, key)
	if err != nil {
		log.Fatal(err)
	}
	
	// è§£å¯†
	decrypted, err := DecryptAESGCM(encrypted, key)
	if err != nil {
		log.Println("Authentication failed! Data may have been tampered with.")
		return
	}
	
	log.Printf("Decrypted: %s\n", decrypted)
}
SAFE

	'safefile://safe_chacha20_poly1305.go': <<<SAFE
package main

import (
	"crypto/rand"
	"errors"
	"io"
	"log"
	
	"golang.org/x/crypto/chacha20poly1305"
)

// æ–¹æ¡ˆ 3: ä½¿ç”¨ ChaCha20-Poly1305ï¼ˆå¤‡é€‰è®¤è¯åŠ å¯†ï¼‰
func EncryptChaCha20Poly1305(plaintext, key []byte) ([]byte, error) {
	// å¯†é’¥å¿…é¡»æ˜¯ 32 å­—èŠ‚
	if len(key) != chacha20poly1305.KeySize {
		return nil, errors.New("invalid key size, must be 32 bytes")
	}

	// åˆ›å»º ChaCha20-Poly1305 AEAD
	aead, err := chacha20poly1305.New(key)
	if err != nil {
		return nil, err
	}

	// ç”Ÿæˆéšæœº nonceï¼ˆ12 å­—èŠ‚ï¼‰
	nonce := make([]byte, aead.NonceSize())
	if _, err := io.ReadFull(rand.Reader, nonce); err != nil {
		return nil, err
	}

	// åŠ å¯†å¹¶è®¤è¯
	ciphertext := aead.Seal(nonce, nonce, plaintext, nil)
	return ciphertext, nil
}

func DecryptChaCha20Poly1305(ciphertext, key []byte) ([]byte, error) {
	if len(key) != chacha20poly1305.KeySize {
		return nil, errors.New("invalid key size, must be 32 bytes")
	}

	aead, err := chacha20poly1305.New(key)
	if err != nil {
		return nil, err
	}

	nonceSize := aead.NonceSize()
	if len(ciphertext) < nonceSize {
		return nil, errors.New("ciphertext too short")
	}

	nonce := ciphertext[:nonceSize]
	ciphertext = ciphertext[nonceSize:]

	// è§£å¯†å¹¶éªŒè¯è®¤è¯æ ‡ç­¾
	plaintext, err := aead.Open(nil, nonce, ciphertext, nil)
	if err != nil {
		return nil, err // è®¤è¯å¤±è´¥
	}

	return plaintext, nil
}

func main() {
	// ç”Ÿæˆ 32 å­—èŠ‚å¯†é’¥
	key := make([]byte, chacha20poly1305.KeySize)
	if _, err := io.ReadFull(rand.Reader, key); err != nil {
		log.Fatal(err)
	}
	
	plaintext := []byte("ChaCha20-Poly1305 is fast and secure!")
	
	// åŠ å¯†
	encrypted, err := EncryptChaCha20Poly1305(plaintext, key)
	if err != nil {
		log.Fatal(err)
	}
	
	// è§£å¯†
	decrypted, err := DecryptChaCha20Poly1305(encrypted, key)
	if err != nil {
		log.Println("Authentication failed!")
		return
	}
	
	log.Printf("Decrypted: %s\n", decrypted)
}
SAFE
)

