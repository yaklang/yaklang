desc(
	title: "Audit Golang DB Hard-Coded Password"
	title_zh: "审计Golang数据库硬编码密码"
	type: audit
	level: high
	risk: "weak-pass"
	desc: <<<DESC
### 规则目的

该规则用于审计Golang代码中是否存在数据库连接的硬编码密码，这是一种常见的安全风险。硬编码密码意味着密码直接写在源代码中，这会导致以下问题：

1. **安全风险**：如果源代码泄露，攻击者可以直接获取数据库密码，进而访问或篡改数据库数据。
2. **维护困难**：如果需要更改密码，必须重新编译并部署代码，增加了维护成本。

### 规则详细

1. **检测目标**：该规则通过静态分析Golang代码，检测是否存在直接硬编码的数据库密码。
2. **检测方法**：规则会扫描代码中的数据库连接配置，查找`Password`字段是否为常量值（如字符串字面量）。
3. **示例代码**：
   ```go
   db.Save(&VulinUser{
       Username: "admin",
       Password: "admin", // 硬编码密码
       Age:      25,
       Role:     "admin",
   })
   ```
DESC
	rule_id: "7b106696-307d-42f3-a41d-3aae2e4233dd"
	title_zh: "审计Golang数据库硬编码密码"
	solution: <<<SOLUTION
### 修复建议

#### 1. 使用环境变量
将密码存储在环境变量中，通过代码读取环境变量来获取密码。这种方式可以避免密码直接暴露在源代码中。
```go
password := os.Getenv("DB_PASSWORD")
db.Save(&VulinUser{
    Username: "admin",
    Password: password, // 从环境变量读取密码
    Age:      25,
    Role:     "admin",
})
```

#### 2. 使用配置文件
将密码存储在配置文件中，配置文件可以通过加密或其他安全措施保护。
```go
config := LoadConfig("config.yaml")
db.Save(&VulinUser{
    Username: "admin",
    Password: config.DBPassword, // 从配置文件读取密码
    Age:      25,
    Role:     "admin",
})
```

#### 3. 使用密钥管理服务（KMS）
对于高安全性要求的场景，可以使用密钥管理服务（如AWS KMS、Hashicorp Vault）来动态获取密码。
```go
password := GetSecretFromKMS("db-password")
db.Save(&VulinUser{
    Username: "admin",
    Password: password, // 从KMS获取密码
    Age:      25,
    Role:     "admin",
})
```

#### 4. 使用随机生成的密码
对于测试或开发环境，可以使用随机生成的密码，避免使用固定密码。
```go
import "github.com/google/uuid"
db.Save(&VulinUser{
    Username: "admin",
    Password: uuid.NewString(), // 随机生成密码
    Age:      25,
    Role:     "admin",
})
```
SOLUTION
	reference: <<<REFERENCE
none
REFERENCE
)

*.Save(*<slice(index=1)> as $sink);

$sink #{
    until: "*.Password"
}-> as $passwd;

$passwd.Password?{opcode: const} as $high;

alert $high for {
	type: "vuln",
	title: "Golang Database Hard-Coded Password Vulnerability Was Found",
	title_zh: "发现Golang数据库硬编码密码漏洞",
	level: "high",
	message: "检测到Golang数据库硬编码密码漏洞，建议立即修复以避免潜在的数据泄露风险",
	solution: <<<SOLUTION
### 修复建议
#### 1. 避免硬编码密码
在代码中直接使用硬编码密码是一个严重的风险，应该使用环境变量或安全配置管理工具来存储和访问敏感信息。

```golang
// 修复代码示例: 使用环境变量
password := os.Getenv("DB_PASSWORD")
db, err := gorm.Open("sqlite3", password)
```

#### 2. 使用加密存储
如果必须存储密码，应该使用加密机制保护敏感信息。

```golang
// 示例: 使用加密库存储
encryptedPassword := encrypt(password, encryptionKey)
```

#### 3. 实施安全审计
定期审计代码库中的敏感信息，确保没有硬编码的凭证。
SOLUTION
	desc: <<<DESC
### 漏洞描述
1. **漏洞原理**
   硬编码密码是将数据库密码或其他敏感信息直接写入源代码中的不良实践。这使得攻击者可以通过查看源代码或反向工程直接获取敏感信息，可能导致未经授权的数据库访问和数据泄露。

2. **触发场景**
   // 存在漏洞的代码示例
   ```golang
   db.Save(&VulinUser{
       Username: "admin",
       Password: "admin", // 硬编码密码
       Age:      25,
       Role:     "admin",
       Remake:   "我是管理员",
   })
   ```

3. **潜在影响**
   - 攻击者可以直接获取数据库凭证，导致数据泄露
   - 可能导致完全控制系统访问权限
   - 违反数据保护法规和安全标准
DESC
	name: "high",
	risk: "weak-pass",
}

desc(
	lang: golang
	alert_high: 1
	'file://unsafe.go': <<<UNSAFE
package vulinbox

import (
	"fmt"
	"github.com/jinzhu/gorm"
	_ "github.com/mattn/go-sqlite3"
	"github.com/samber/lo"
	"github.com/yaklang/yaklang/common/consts"
	"github.com/yaklang/yaklang/common/log"
	"github.com/yaklang/yaklang/common/utils"
	"github.com/yaklang/yaklang/common/yak/yaklib/codec"
)

type dbm struct {
	db *gorm.DB
}

func newDBM() (*dbm, error) {
	fp, err := consts.TempFile("*.db")
	if err != nil {
		return nil, err
	}
	name := fp.Name()
	log.Infof("db file: %s", name)
	fp.Close()
	db, err := consts.CreateVulinboxDatabase(name)
	if err != nil {
		return nil, err
	}

	var i any
	if err := db.Raw("select md5('a')").Row().Scan(&i); err != nil {
		return nil, utils.Errorf("sqlite3 md5 function register failed: %v", err)
	}
	if fmt.Sprint(i) != codec.Md5("a") {
		return nil, utils.Errorf("sqlite3 md5 function register failed: %v", i)
	}
	log.Infof("verify md5 function is called: %v", i)

	db.Save(&VulinUser{
		Username: "admin",
		Password: "admin",
		Age:      25,
		Role:     "admin",
		Remake:   "我是管理员",
	})
	db.Save(&VulinUser{
		Username: "root",
		Password: "p@ssword",
		Age:      25,
		Role:     "admin",
		Remake:   "我是管理员",
	})
	db.Save(&VulinUser{
		Username: "user1",
		Password: "password123",
		Age:      25,
		Role:     "user",
		Remake:   "我是用户",
	})
	db.Save(&VulinUser{
		Username: "user1111",
		Password: "123456",
		Age:      25,
		Role:     "user",
		Remake:   "我是用户",
	})
	db.Save(&VulinUser{
		Username: "user_2",
		Password: "666666",
		Age:      25,
		Role:     "user",
		Remake:   "我是用户",
	})
	db.Save(&VulinUser{
		Username: "user_8",
		Password: "88888888",
		Age:      25,
		Role:     "user",
		Remake:   "我是用户",
	})
	// 生成随机用户
	for _, u := range generateRandomUsers(20) {
		db.Save(&u)
	}
	return &dbm{db}, nil
}


UNSAFE
	'safefile://safe.go': <<<SAFE
package vulinbox

import (
	"fmt"
	"github.com/jinzhu/gorm"
	_ "github.com/mattn/go-sqlite3"
	"github.com/samber/lo"
	"github.com/google/uuid"
	"github.com/yaklang/yaklang/common/consts"
	"github.com/yaklang/yaklang/common/log"
	"github.com/yaklang/yaklang/common/utils"
	"github.com/yaklang/yaklang/common/yak/yaklib/codec"
)

type dbm struct {
	db *gorm.DB
}

func newDBM() (*dbm, error) {
	fp, err := consts.TempFile("*.db")
	if err != nil {
		return nil, err
	}
	name := fp.Name()
	log.Infof("db file: %s", name)
	fp.Close()
	db, err := consts.CreateVulinboxDatabase(name)
	if err != nil {
		return nil, err
	}

	var i any
	if err := db.Raw("select md5('a')").Row().Scan(&i); err != nil {
		return nil, utils.Errorf("sqlite3 md5 function register failed: %v", err)
	}
	if fmt.Sprint(i) != codec.Md5("a") {
		return nil, utils.Errorf("sqlite3 md5 function register failed: %v", i)
	}
	log.Infof("verify md5 function is called: %v", i)

	db.Save(&VulinUser{
		Username: "admin",
		Password: uuid.NewString(),
		Age:      25,
		Role:     "admin",
		Remake:   "我是管理员",
	})
	db.Save(&VulinUser{
		Username: "root",
		Password: uuid.NewString(),
		Age:      25,
		Role:     "admin",
		Remake:   "我是管理员",
	})
	db.Save(&VulinUser{
		Username: "user1",
		Password: uuid.NewString(),
		Age:      25,
		Role:     "user",
		Remake:   "我是用户",
	})
	db.Save(&VulinUser{
		Username: "user1111",
		Password: uuid.NewString(),
		Age:      25,
		Role:     "user",
		Remake:   "我是用户",
	})
	db.Save(&VulinUser{
		Username: "user_2",
		Password: uuid.NewString(),
		Age:      25,
		Role:     "user",
		Remake:   "我是用户",
	})
	db.Save(&VulinUser{
		Username: "user_8",
		Password: uuid.NewString(),
		Age:      25,
		Role:     "user",
		Remake:   "我是用户",
	})
	// 生成随机用户
	for _, u := range generateRandomUsers(20) {
		db.Save(&u)
	}
	return &dbm{db}, nil
}

SAFE
)
