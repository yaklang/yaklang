desc(
	title: "Detect Golang HTTP Server Using Plaintext (Unencrypted) Communication"
	title_zh: "æ£€æµ‹Golang HTTPæœåŠ¡å™¨ä½¿ç”¨æ˜æ–‡(æœªåŠ å¯†)é€šä¿¡"
	type: vuln
	severity: high
	risk: "cleartext_transmission"
	desc: <<<DESC
### æ¼æ´æè¿°

1. **æ¼æ´åŸç†**
   ä½¿ç”¨ `http.ListenAndServe()` åˆ›å»ºçš„ HTTP æœåŠ¡å™¨é€šè¿‡æ˜æ–‡ä¼ è¾“æ‰€æœ‰æ•°æ®ï¼Œæ²¡æœ‰ä»»ä½•åŠ å¯†ä¿æŠ¤ã€‚è¿™æ„å‘³ç€ï¼š
   - æ‰€æœ‰è¯·æ±‚å’Œå“åº”å†…å®¹ï¼ˆåŒ…æ‹¬æ•æ„Ÿæ•°æ®ï¼‰éƒ½ä»¥æ˜æ–‡å½¢å¼åœ¨ç½‘ç»œä¸­ä¼ è¾“
   - æ”»å‡»è€…å¯ä»¥åœ¨ä¼ è¾“è·¯å¾„çš„ä»»ä½•èŠ‚ç‚¹æ‹¦æˆªå’Œè¯»å–æ‰€æœ‰é€šä¿¡å†…å®¹
   - æ— æ³•éªŒè¯æœåŠ¡å™¨çš„çœŸå®èº«ä»½ï¼Œå®¢æˆ·ç«¯å¯èƒ½è¿æ¥åˆ°ä¼ªè£…çš„æœåŠ¡å™¨
   - æ•°æ®åœ¨ä¼ è¾“è¿‡ç¨‹ä¸­å¯èƒ½è¢«ç¯¡æ”¹ï¼Œä¸”æ¥æ”¶æ–¹æ— æ³•æ£€æµ‹åˆ°
   
   ä¸ HTTPS ç›¸æ¯”ï¼ŒHTTP å®Œå…¨ç¼ºä¹ï¼š
   - **æœºå¯†æ€§**: æ•°æ®åŠ å¯†ï¼Œé˜²æ­¢çªƒå¬
   - **å®Œæ•´æ€§**: æ•°æ®ç­¾åï¼Œé˜²æ­¢ç¯¡æ”¹
   - **èº«ä»½è®¤è¯**: è¯ä¹¦éªŒè¯ï¼Œé˜²æ­¢ä¼ªè£…

2. **è§¦å‘åœºæ™¯**
   è¯¥æ¼æ´é€šå¸¸å‡ºç°åœ¨ä»¥ä¸‹åœºæ™¯ï¼š
   - å¼€å‘è€…ä¸ºäº†ç®€å•æ–¹ä¾¿ï¼Œåœ¨ç”Ÿäº§ç¯å¢ƒä¸­ä½¿ç”¨ HTTP è€Œé HTTPS
   - è¯¯è®¤ä¸ºå†…ç½‘ç¯å¢ƒä¸éœ€è¦åŠ å¯†ï¼ˆä½†å†…ç½‘æ”»å‡»åŒæ ·å±é™©ï¼‰
   - ä½¿ç”¨äº† HTTP ä½†å¤„ç†æ•æ„Ÿæ•°æ®ï¼ˆç™»å½•å‡­è¯ã€æ”¯ä»˜ä¿¡æ¯ã€ä¸ªäººéšç§ï¼‰
   - æ²¡æœ‰æ„è¯†åˆ°æ˜æ–‡ä¼ è¾“çš„ä¸¥é‡å®‰å…¨é£é™©
   
   ```go
   // ä¸å®‰å…¨çš„æœåŠ¡å™¨å¯åŠ¨æ–¹å¼
   func main() {
       http.HandleFunc("/login", loginHandler)
       http.HandleFunc("/payment", paymentHandler)
       
       // å±é™©ï¼æ‰€æœ‰æ•°æ®æ˜æ–‡ä¼ è¾“
       log.Fatal(http.ListenAndServe(":8080", nil))
   }
   
   func loginHandler(w http.ResponseWriter, r *http.Request) {
       username := r.FormValue("username")
       password := r.FormValue("password") // å¯†ç æ˜æ–‡ä¼ è¾“ï¼
       // ... å¤„ç†ç™»å½•
   }
   ```

3. **æ½œåœ¨å½±å“**
   - **æ•æ„Ÿæ•°æ®æ³„éœ²**: æ”»å‡»è€…å¯ä»¥ä½¿ç”¨ Wireshark ç­‰å·¥å…·è½»æ¾æ•è·å¹¶æŸ¥çœ‹ï¼š
     - ç”¨æˆ·åå’Œå¯†ç 
     - ä¼šè¯ Cookie å’Œ Token
     - API å¯†é’¥å’Œè®¿é—®ä»¤ç‰Œ
     - ä¸ªäººèº«ä»½ä¿¡æ¯ï¼ˆå§“åã€èº«ä»½è¯å·ã€æ‰‹æœºå·ï¼‰
     - æ”¯ä»˜ä¿¡æ¯ï¼ˆé“¶è¡Œå¡å·ã€CVVï¼‰
     - å•†ä¸šæœºå¯†å’Œæ•æ„Ÿæ–‡æ¡£
   
   - **ä¸­é—´äººæ”»å‡»ï¼ˆMITMï¼‰**: æ”»å‡»è€…å¯ä»¥ï¼š
     - ä¼ªè£…æˆæœåŠ¡å™¨ï¼Œæ¬ºéª—å®¢æˆ·ç«¯
     - æ‹¦æˆªå¹¶ä¿®æ”¹è¯·æ±‚å’Œå“åº”å†…å®¹
     - æ³¨å…¥æ¶æ„ä»£ç ï¼ˆå¦‚ JavaScriptï¼‰åˆ°å“åº”ä¸­
     - åŠ«æŒç”¨æˆ·ä¼šè¯ï¼ˆSession Hijackingï¼‰
   
   - **æ•°æ®ç¯¡æ”¹**: æ”»å‡»è€…å¯ä»¥ï¼š
     - ä¿®æ”¹äº¤æ˜“é‡‘é¢
     - ç¯¡æ”¹è®¢å•ä¿¡æ¯
     - æ›´æ”¹ç”¨æˆ·æƒé™
     - æ³¨å…¥æ¶æ„æ•°æ®
   
   - **åˆè§„è¿è§„**: è¿åä»¥ä¸‹å®‰å…¨æ ‡å‡†å’Œæ³•è§„ï¼š
     - PCI DSSï¼ˆæ”¯ä»˜å¡è¡Œä¸šæ ‡å‡†ï¼‰æ˜ç¡®è¦æ±‚ä¼ è¾“æ•æ„Ÿæ•°æ®å¿…é¡»åŠ å¯†
     - GDPRï¼ˆé€šç”¨æ•°æ®ä¿æŠ¤æ¡ä¾‹ï¼‰è¦æ±‚ä¿æŠ¤ä¸ªäººæ•°æ®ä¼ è¾“å®‰å…¨
     - HIPAAï¼ˆåŒ»ç–—ä¿¡æ¯ä¿æŠ¤æ³•ï¼‰è¦æ±‚åŒ»ç–—æ•°æ®ä¼ è¾“åŠ å¯†
     - SOC 2 å’Œ ISO 27001 ç­‰åˆè§„è¦æ±‚
   
   - **å£°èª‰æŸå®³**: ä¸€æ—¦å‘ç”Ÿæ•°æ®æ³„éœ²äº‹æ•…ï¼š
     - ç”¨æˆ·ä¿¡ä»»åº¦æ€¥å‰§ä¸‹é™
     - æ³•å¾‹è¯‰è®¼å’Œå·¨é¢ç½šæ¬¾
     - åª’ä½“è´Ÿé¢æŠ¥é“
     - ä¸šåŠ¡æŸå¤±

4. **æ”»å‡»éš¾åº¦**
   - **æä½**: ä½¿ç”¨å…è´¹å·¥å…·ï¼ˆå¦‚ Wiresharkã€tcpdumpï¼‰å³å¯å®æ–½æ”»å‡»
   - **æ”»å‡»åœºæ™¯**: 
     - å…¬å…± WiFi ç½‘ç»œï¼ˆå’–å•¡åº—ã€æœºåœºã€é…’åº—ï¼‰
     - è¢«æ”»é™·çš„è·¯ç”±å™¨
     - ISP æˆ–ç½‘ç»œæœåŠ¡æä¾›å•†
     - å…±äº«ç½‘ç»œç¯å¢ƒï¼ˆå¦‚å¤§å­¦ã€å…¬å¸ï¼‰

DESC
	rule_id: "b2c3d4e5-http-plaintext-001"
	solution: <<<SOLUTION
### ä¿®å¤å»ºè®®

#### ğŸ”´ æ–¹æ¡ˆ 1: ä½¿ç”¨ ListenAndServeTLSï¼ˆæ ‡å‡†æ–¹æ¡ˆï¼‰

**æœ€ç›´æ¥çš„ä¿®å¤**ï¼šå°† `http.ListenAndServe` æ›¿æ¢ä¸º `http.ListenAndServeTLS`ã€‚

```go
package main

import (
    "log"
    "net/http"
)

func main() {
    // è®¾ç½®è·¯ç”±
    http.HandleFunc("/", homeHandler)
    http.HandleFunc("/api/data", apiHandler)

    // å®‰å…¨çš„ HTTPS æœåŠ¡å™¨
    log.Println("Starting HTTPS server on :8443")
    log.Fatal(http.ListenAndServeTLS(
        ":8443",           // ç›‘å¬ç«¯å£ï¼ˆHTTPS é€šå¸¸ä½¿ç”¨ 443 æˆ– 8443ï¼‰
        "cert.pem",        // SSL è¯ä¹¦æ–‡ä»¶
        "key.pem",         // ç§é’¥æ–‡ä»¶
        nil,               // Handlerï¼ˆnil è¡¨ç¤ºä½¿ç”¨ DefaultServeMuxï¼‰
    ))
}
```

#### ğŸŸ¡ æ–¹æ¡ˆ 2: é…ç½®å®‰å…¨çš„ http.Serverï¼ˆæ¨èï¼‰

**æ›´å¥½çš„åšæ³•**ï¼šæ˜¾å¼é…ç½® `http.Server`ï¼Œè®¾ç½®å®‰å…¨çš„è¶…æ—¶å‚æ•°ã€‚

```go
package main

import (
    "crypto/tls"
    "log"
    "net/http"
    "time"
)

func main() {
    // é…ç½®è·¯ç”±
    mux := http.NewServeMux()
    mux.HandleFunc("/", homeHandler)
    mux.HandleFunc("/api/data", apiHandler)

    // é…ç½®å®‰å…¨çš„ HTTPS æœåŠ¡å™¨
    server := &http.Server{
        Addr:         ":8443",
        Handler:      mux,
        ReadTimeout:  10 * time.Second,  // é˜²æ­¢æ…¢é€Ÿè¯»å–æ”»å‡»
        WriteTimeout: 10 * time.Second,  // é˜²æ­¢æ…¢é€Ÿå†™å…¥æ”»å‡»
        IdleTimeout:  120 * time.Second, // ç©ºé—²è¿æ¥è¶…æ—¶
        
        // TLS é…ç½®ï¼ˆå¯é€‰ï¼Œå¢å¼ºå®‰å…¨æ€§ï¼‰
        TLSConfig: &tls.Config{
            MinVersion:               tls.VersionTLS12, // æœ€ä½ TLS 1.2
            CurvePreferences:         []tls.CurveID{tls.CurveP521, tls.CurveP384, tls.CurveP256},
            PreferServerCipherSuites: true,
            CipherSuites: []uint16{
                tls.TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384,
                tls.TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA,
                tls.TLS_RSA_WITH_AES_256_GCM_SHA384,
                tls.TLS_RSA_WITH_AES_256_CBC_SHA,
            },
        },
    }

    log.Println("Starting secure HTTPS server on :8443")
    log.Fatal(server.ListenAndServeTLS("cert.pem", "key.pem"))
}
```

#### ğŸ”µ æ–¹æ¡ˆ 3: HTTP è‡ªåŠ¨é‡å®šå‘åˆ° HTTPS

**ç”Ÿäº§ç¯å¢ƒæœ€ä½³å®è·µ**ï¼šåŒæ—¶ç›‘å¬ HTTP å’Œ HTTPSï¼Œå°† HTTP æµé‡è‡ªåŠ¨é‡å®šå‘åˆ° HTTPSã€‚

```go
package main

import (
    "crypto/tls"
    "fmt"
    "log"
    "net/http"
    "time"
)

func main() {
    // é…ç½®è·¯ç”±
    mux := http.NewServeMux()
    mux.HandleFunc("/", homeHandler)
    mux.HandleFunc("/api/data", apiHandler)

    // HTTPS æœåŠ¡å™¨
    httpsServer := &http.Server{
        Addr:         ":443",
        Handler:      mux,
        ReadTimeout:  10 * time.Second,
        WriteTimeout: 10 * time.Second,
        IdleTimeout:  120 * time.Second,
        TLSConfig: &tls.Config{
            MinVersion: tls.VersionTLS12,
        },
    }

    // HTTP æœåŠ¡å™¨ - ä»…ç”¨äºé‡å®šå‘åˆ° HTTPS
    httpServer := &http.Server{
        Addr:         ":80",
        Handler:      http.HandlerFunc(redirectToHTTPS),
        ReadTimeout:  5 * time.Second,
        WriteTimeout: 5 * time.Second,
    }

    // åœ¨åå°å¯åŠ¨ HTTP é‡å®šå‘æœåŠ¡å™¨
    go func() {
        log.Println("Starting HTTP redirect server on :80")
        if err := httpServer.ListenAndServe(); err != nil && err != http.ErrServerClosed {
            log.Fatalf("HTTP server failed: %v", err)
        }
    }()

    // å¯åŠ¨ HTTPS æœåŠ¡å™¨ï¼ˆä¸»æœåŠ¡ï¼‰
    log.Println("Starting HTTPS server on :443")
    log.Fatal(httpsServer.ListenAndServeTLS("cert.pem", "key.pem"))
}

// HTTP åˆ° HTTPS çš„é‡å®šå‘å¤„ç†å™¨
func redirectToHTTPS(w http.ResponseWriter, r *http.Request) {
    // æ„å»º HTTPS URL
    httpsURL := fmt.Sprintf("https://%s%s", r.Host, r.RequestURI)
    
    // 301 æ°¸ä¹…é‡å®šå‘
    http.Redirect(w, r, httpsURL, http.StatusMovedPermanently)
}
```

#### ğŸŸ¢ æ–¹æ¡ˆ 4: ä½¿ç”¨åå‘ä»£ç†ï¼ˆä¼ä¸šçº§æ–¹æ¡ˆï¼‰

**å¤§è§„æ¨¡ç”Ÿäº§ç¯å¢ƒ**ï¼šåœ¨åº”ç”¨å‰éƒ¨ç½²åå‘ä»£ç†ï¼ˆå¦‚ Nginxã€Caddyï¼‰å¤„ç† HTTPSã€‚

**Nginx é…ç½®ç¤ºä¾‹**ï¼š
```nginx
server {
    listen 80;
    server_name example.com;
    
    # é‡å®šå‘åˆ° HTTPS
    return 301 https://$server_name$request_uri;
}

server {
    listen 443 ssl http2;
    server_name example.com;

    # SSL è¯ä¹¦é…ç½®
    ssl_certificate /etc/ssl/certs/cert.pem;
    ssl_certificate_key /etc/ssl/private/key.pem;
    
    # SSL å®‰å…¨é…ç½®
    ssl_protocols TLSv1.2 TLSv1.3;
    ssl_ciphers HIGH:!aNULL:!MD5;
    ssl_prefer_server_ciphers on;

    # ä»£ç†åˆ°åç«¯ Go åº”ç”¨ï¼ˆå¯ä»¥ä½¿ç”¨ HTTPï¼‰
    location / {
        proxy_pass http://localhost:8080;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
    }
}
```

**Go åº”ç”¨ä»£ç **ï¼ˆåœ¨åå‘ä»£ç†åå¯ä»¥ä½¿ç”¨ HTTPï¼‰ï¼š
```go
func main() {
    // åº”ç”¨è¿è¡Œåœ¨åå‘ä»£ç†åï¼Œç›‘å¬æœ¬åœ° HTTP
    // å¤–éƒ¨ HTTPS ç”± Nginx å¤„ç†
    server := &http.Server{
        Addr:    "localhost:8080",
        Handler: mux,
    }
    
    log.Println("Starting HTTP server on localhost:8080 (behind reverse proxy)")
    log.Fatal(server.ListenAndServe()) // è¿™é‡Œå¯ä»¥ä½¿ç”¨ HTTPï¼Œå› ä¸ºæœ‰åå‘ä»£ç†
}
```

#### ğŸ“‹ è·å– SSL/TLS è¯ä¹¦

**ç”Ÿäº§ç¯å¢ƒ - Let's Encryptï¼ˆå…è´¹ï¼Œæ¨èï¼‰**:

```bash
# å®‰è£… certbot
sudo apt-get update
sudo apt-get install certbot

# è·å–è¯ä¹¦ï¼ˆéœ€è¦åŸŸåå’Œå…¬ç½‘è®¿é—®ï¼‰
sudo certbot certonly --standalone -d yourdomain.com -d www.yourdomain.com

# è¯ä¹¦æ–‡ä»¶ä½ç½®
# /etc/letsencrypt/live/yourdomain.com/fullchain.pem  # è¯ä¹¦
# /etc/letsencrypt/live/yourdomain.com/privkey.pem    # ç§é’¥

# è‡ªåŠ¨ç»­æœŸï¼ˆLet's Encrypt è¯ä¹¦ 90 å¤©æœ‰æ•ˆï¼‰
sudo certbot renew --dry-run
```

**å¼€å‘/æµ‹è¯•ç¯å¢ƒ - è‡ªç­¾åè¯ä¹¦**:

```bash
# ä½¿ç”¨ OpenSSL ç”Ÿæˆè‡ªç­¾åè¯ä¹¦
openssl req -x509 -nodes -days 365 -newkey rsa:2048 \
    -keyout key.pem -out cert.pem \
    -subj "/C=CN/ST=Beijing/L=Beijing/O=MyCompany/CN=localhost"

# ç”Ÿæˆçš„æ–‡ä»¶ï¼š
# - cert.pem: SSL è¯ä¹¦
# - key.pem: ç§é’¥
```

**ä½¿ç”¨ Go å†…ç½®å·¥å…·ç”Ÿæˆï¼ˆæ›´ç®€å•ï¼‰**:

```bash
# Go 1.14+ å†…ç½®è¯ä¹¦ç”Ÿæˆå·¥å…·
go run $GOROOT/src/crypto/tls/generate_cert.go --host localhost
```

#### ğŸ”’ å¢å¼ºå®‰å…¨æ€§çš„é¢å¤–é…ç½®

**1. HSTSï¼ˆHTTP Strict Transport Securityï¼‰**

å¼ºåˆ¶æµè§ˆå™¨å§‹ç»ˆä½¿ç”¨ HTTPSï¼š

```go
func securityHeadersMiddleware(next http.Handler) http.Handler {
    return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
        // HSTS: å¼ºåˆ¶ HTTPSï¼Œæœ‰æ•ˆæœŸ 1 å¹´
        w.Header().Set("Strict-Transport-Security", "max-age=31536000; includeSubDomains; preload")
        
        // å…¶ä»–å®‰å…¨å¤´
        w.Header().Set("X-Content-Type-Options", "nosniff")
        w.Header().Set("X-Frame-Options", "DENY")
        w.Header().Set("X-XSS-Protection", "1; mode=block")
        w.Header().Set("Content-Security-Policy", "default-src 'self'")
        
        next.ServeHTTP(w, r)
    })
}

func main() {
    mux := http.NewServeMux()
    mux.HandleFunc("/", homeHandler)
    
    // åº”ç”¨å®‰å…¨å¤´ä¸­é—´ä»¶
    handler := securityHeadersMiddleware(mux)
    
    server := &http.Server{
        Addr:    ":443",
        Handler: handler,
    }
    
    log.Fatal(server.ListenAndServeTLS("cert.pem", "key.pem"))
}
```

**2. è¯ä¹¦è‡ªåŠ¨ç»­æœŸï¼ˆLet's Encrypt + Goï¼‰**

```go
import (
    "golang.org/x/crypto/acme/autocert"
)

func main() {
    // è‡ªåŠ¨è·å–å’Œç»­æœŸ Let's Encrypt è¯ä¹¦
    certManager := autocert.Manager{
        Prompt:     autocert.AcceptTOS,
        HostPolicy: autocert.HostWhitelist("yourdomain.com", "www.yourdomain.com"),
        Cache:      autocert.DirCache("/etc/letsencrypt/cache"), // è¯ä¹¦ç¼“å­˜ç›®å½•
    }

    server := &http.Server{
        Addr:    ":443",
        Handler: mux,
        TLSConfig: &tls.Config{
            GetCertificate: certManager.GetCertificate,
            MinVersion:     tls.VersionTLS12,
        },
    }

    // å¯åŠ¨ HTTP-01 challenge æœåŠ¡å™¨ï¼ˆLet's Encrypt éªŒè¯éœ€è¦ï¼‰
    go http.ListenAndServe(":80", certManager.HTTPHandler(nil))

    log.Fatal(server.ListenAndServeTLS("", "")) // è¯ä¹¦ç”± certManager ç®¡ç†ï¼Œç•™ç©º
}
```

#### âš ï¸ æ³¨æ„äº‹é¡¹

1. **è¯ä¹¦æ–‡ä»¶æƒé™**ï¼šç¡®ä¿ç§é’¥æ–‡ä»¶æƒé™ä¸º 600ï¼ˆåªæœ‰æ‰€æœ‰è€…å¯è¯»å†™ï¼‰
   ```bash
   chmod 600 key.pem
   chmod 644 cert.pem
   ```

2. **è¯ä¹¦æœ‰æ•ˆæœŸç›‘æ§**ï¼šè®¾ç½®ç›‘æ§å’Œå‘Šè­¦ï¼Œæå‰ 30 å¤©æé†’ç»­æœŸ

3. **ç«¯å£é€‰æ‹©**ï¼š
   - ç”Ÿäº§ç¯å¢ƒï¼šä½¿ç”¨æ ‡å‡†ç«¯å£ 443ï¼ˆHTTPSï¼‰å’Œ 80ï¼ˆHTTP é‡å®šå‘ï¼‰
   - å¼€å‘ç¯å¢ƒï¼šå¯ä»¥ä½¿ç”¨ 8443ã€8080 ç­‰é«˜ç«¯å£

4. **é˜²ç«å¢™é…ç½®**ï¼šç¡®ä¿é˜²ç«å¢™å…è®¸ 443 ç«¯å£å…¥ç«™æµé‡

5. **æ€§èƒ½ä¼˜åŒ–**ï¼š
   - å¯ç”¨ HTTP/2ï¼ˆGo 1.6+ è‡ªåŠ¨æ”¯æŒï¼‰
   - ä½¿ç”¨è¿æ¥æ± å¤ç”¨
   - è€ƒè™‘ä½¿ç”¨ CDN åˆ†å‘é™æ€å†…å®¹

SOLUTION
	reference: <<<REFERENCE
[CWE-319: Cleartext Transmission of Sensitive Information](https://cwe.mitre.org/data/definitions/319.html)
[OWASP: Insufficient Transport Layer Protection](https://owasp.org/www-community/vulnerabilities/Insufficient_Transport_Layer_Protection)
[Go net/http Package](https://pkg.go.dev/net/http)
[Let's Encrypt](https://letsencrypt.org/)
[Mozilla SSL Configuration Generator](https://ssl-config.mozilla.org/)
REFERENCE
)

// TODO: æˆ‘å‘ç°http.Serverçš„fullTypeNameæ²¡æœ‰æ¥ä¸Šhttpï¼Œè¿™é‡Œå…ˆæš‚æ—¶ç”¨*ä»£æ›¿ä¹‹åå†ç²¾ç¡®ä¿®æ”¹
*.ListenAndServe(*<slice(index=0)> as $addr, * #-> as $handler) as $listen_and_serve;
$http_server.ListenAndServe(* #-> as $params) as $server_listen;

$listen_and_serve as $insecure_listener;
$server_listen as $insecure_listener;

$insecure_listener as $high;

alert $high for {
	type: "vuln",
	title: "Golang HTTP Server Using Plaintext Communication",
	title_zh: "æ£€æµ‹åˆ°Golang HTTPæœåŠ¡å™¨ä½¿ç”¨æ˜æ–‡é€šä¿¡",
	level: "high",
	name: "high",
	message: "æ£€æµ‹åˆ°å®‰å…¨æ¼æ´ï¼šHTTP æœåŠ¡å™¨æ­£åœ¨ä½¿ç”¨æ˜æ–‡ï¼ˆæœªåŠ å¯†ï¼‰åè®®ã€‚æ‰€æœ‰æ•°æ®ä¼ è¾“éƒ½æ˜¯æ˜æ–‡çš„ï¼Œæ”»å‡»è€…å¯ä»¥æ‹¦æˆªå’Œè¯»å–ä¼ è¾“å†…å®¹ï¼ŒåŒ…æ‹¬å¯†ç ã€ä»¤ç‰Œç­‰æ•æ„Ÿä¿¡æ¯ã€‚åº”è¯¥ä½¿ç”¨ HTTPSï¼ˆhttp.ListenAndServeTLSï¼‰æ¥åŠ å¯†æ‰€æœ‰é€šä¿¡ã€‚",
	solution: <<<SOLUTION
### ä¿®å¤å»ºè®®

**æ–¹æ¡ˆ 1 - ä½¿ç”¨ ListenAndServeTLSï¼ˆæ¨èï¼‰**ï¼š
```go
// å®‰å…¨çš„ HTTPS æœåŠ¡å™¨
log.Fatal(http.ListenAndServeTLS(":8443", "cert.pem", "key.pem", nil))
```

**æ–¹æ¡ˆ 2 - é…ç½®å®‰å…¨çš„ http.Server**ï¼š
```go
server := &http.Server{
    Addr:         ":8443",
    Handler:      mux,
    ReadTimeout:  10 * time.Second,
    WriteTimeout: 10 * time.Second,
    IdleTimeout:  120 * time.Second,
    TLSConfig: &tls.Config{
        MinVersion: tls.VersionTLS12,
    },
}
log.Fatal(server.ListenAndServeTLS("cert.pem", "key.pem"))
```

**æ–¹æ¡ˆ 3 - HTTP è‡ªåŠ¨é‡å®šå‘åˆ° HTTPS**ï¼š
- å¯åŠ¨ä¸¤ä¸ªæœåŠ¡å™¨
- HTTP æœåŠ¡å™¨ï¼ˆ:80ï¼‰ä»…ç”¨äºé‡å®šå‘
- HTTPS æœåŠ¡å™¨ï¼ˆ:443ï¼‰å¤„ç†æ‰€æœ‰å®é™…æµé‡

**è·å–è¯ä¹¦**ï¼š
- ç”Ÿäº§ç¯å¢ƒï¼šLet's Encrypt æˆ–å•†ä¸š CA
- æµ‹è¯•ç¯å¢ƒï¼šè‡ªç­¾åè¯ä¹¦ï¼ˆOpenSSLï¼‰
SOLUTION
	risk: "æ˜æ–‡ä¼ è¾“",
	desc: <<<DESC
### è¯¦ç»†è¯´æ˜

æ£€æµ‹åˆ°ä»£ç ä¸­ä½¿ç”¨ `http.ListenAndServe()` æˆ– `Server.ListenAndServe()` å¯åŠ¨ HTTP æœåŠ¡å™¨ã€‚

**é£é™©ç­‰çº§ï¼šğŸŸ  HIGHï¼ˆé«˜å±ï¼‰**

**é—®é¢˜**ï¼š
- HTTP åè®®ä¸åŠ å¯†ï¼Œæ‰€æœ‰æ•°æ®æ˜æ–‡ä¼ è¾“
- å®¹æ˜“é­å—çªƒå¬ã€ä¸­é—´äººæ”»å‡»ã€æ•°æ®ç¯¡æ”¹
- å¦‚æœå¤„ç†æ•æ„Ÿæ•°æ®ï¼Œé£é™©æ›´é«˜

**å»ºè®®**ï¼š
- ä½¿ç”¨ `http.ListenAndServeTLS()` å¯ç”¨ HTTPS
- é…ç½® SSL/TLS è¯ä¹¦
- æ·»åŠ å®‰å…¨å¤´ï¼ˆHSTS ç­‰ï¼‰
DESC
}

desc(
	lang: golang
	alert_high: 1
	alert_critical: 1
	'file://unsafe_http_server.go': <<<UNSAFE
package main

import (
	"fmt"
	"log"
	"net/http"
)

// æ¡ˆä¾‹ 1: ç›´æ¥ä½¿ç”¨ ListenAndServeï¼ˆæœ€å¸¸è§ï¼‰
func unsafeServer1() {
	http.HandleFunc("/", homeHandler)
	http.HandleFunc("/login", loginHandler)
	
	// å±é™©ï¼šæ˜æ–‡ HTTP æœåŠ¡å™¨ï¼Œç›‘å¬æ‰€æœ‰ç½‘ç»œæ¥å£
	log.Fatal(http.ListenAndServe(":8080", nil))
}

// æ¡ˆä¾‹ 2: ä½¿ç”¨ Server ç»“æ„ä½“ä½†æ²¡æœ‰ TLS
func unsafeServer2() {
	mux := http.NewServeMux()
	mux.HandleFunc("/api/data", apiHandler)
	
	server := &http.Server{
		Addr:    ":8080",
		Handler: mux,
	}
	
	// å±é™©ï¼šä»ç„¶æ˜¯æ˜æ–‡ HTTP
	log.Fatal(server.ListenAndServe())
}

// æ¡ˆä¾‹ 3: ç›‘å¬å…¬ç½‘åœ°å€ï¼ˆæœ€å±é™©ï¼‰
func unsafeServer3() {
	http.HandleFunc("/payment", paymentHandler)
	
	// æåº¦å±é™©ï¼šæ˜æ–‡ HTTP + å…¬ç½‘åœ°å€
	// ä»»ä½•äººéƒ½å¯ä»¥æ‹¦æˆªæ”¯ä»˜ä¿¡æ¯
	log.Fatal(http.ListenAndServe("0.0.0.0:8080", nil))
}

// æ¡ˆä¾‹ 4: å¤„ç†æ•æ„Ÿæ•°æ®ä½†ä½¿ç”¨ HTTP
func loginHandler(w http.ResponseWriter, r *http.Request) {
	// ä»è¡¨å•è·å–å¯†ç 
	password := r.FormValue("password")
	
	// å±é™©ï¼šå¯†ç é€šè¿‡æ˜æ–‡ HTTP ä¼ è¾“ï¼Œå¯ä»¥è¢«æ‹¦æˆª
	if authenticate(password) {
		http.SetCookie(w, &http.Cookie{
			Name:  "session",
			Value: generateSessionToken(),
			// å³ä½¿è®¾ç½®äº† HttpOnlyï¼Œä½†é€šè¿‡ HTTP ä¼ è¾“ä»ç„¶ä¸å®‰å…¨
			HttpOnly: true,
		})
	}
}

func paymentHandler(w http.ResponseWriter, r *http.Request) {
	// è·å–æ”¯ä»˜ä¿¡æ¯
	cardNumber := r.FormValue("card_number")
	cvv := r.FormValue("cvv")
	
	// æåº¦å±é™©ï¼šæ”¯ä»˜ä¿¡æ¯æ˜æ–‡ä¼ è¾“
	// ä¸¥é‡è¿å PCI DSS æ ‡å‡†
	processPayment(cardNumber, cvv)
}

func homeHandler(w http.ResponseWriter, r *http.Request) {
	fmt.Fprintf(w, "Welcome!")
}

func apiHandler(w http.ResponseWriter, r *http.Request) {
	// API å¯èƒ½åŒ…å«æ•æ„Ÿæ•°æ®
	fmt.Fprintf(w, `{"user": "admin", "token": "secret123"}`)
}

func authenticate(password string) bool {
	return password == "secret"
}

func generateSessionToken() string {
	return "token123"
}

func processPayment(cardNumber, cvv string) {
	// å¤„ç†æ”¯ä»˜
}

func main() {
	unsafeServer1()
	// unsafeServer2()
	// unsafeServer3()
}
UNSAFE
	'safefile://safe_https_server.go': <<<SAFE
package main

import (
	"crypto/tls"
	"log"
	"net/http"
	"time"
)

// æ–¹æ¡ˆ 1: ä½¿ç”¨ ListenAndServeTLSï¼ˆæœ€ç®€å•ï¼‰
func safeServer1() {
	http.HandleFunc("/", homeHandler)
	http.HandleFunc("/login", loginHandler)
	
	// å®‰å…¨ï¼šä½¿ç”¨ HTTPS
	log.Println("Starting HTTPS server on :8443")
	log.Fatal(http.ListenAndServeTLS(
		":8443",
		"cert.pem",  // SSL è¯ä¹¦
		"key.pem",   // ç§é’¥
		nil,
	))
}

// æ–¹æ¡ˆ 2: é…ç½®å®‰å…¨çš„ http.Serverï¼ˆæ¨èï¼‰
func safeServer2() {
	mux := http.NewServeMux()
	mux.HandleFunc("/", homeHandler)
	mux.HandleFunc("/api/data", apiHandler)

	server := &http.Server{
		Addr:         ":8443",
		Handler:      mux,
		ReadTimeout:  10 * time.Second,
		WriteTimeout: 10 * time.Second,
		IdleTimeout:  120 * time.Second,
		
		// TLS å®‰å…¨é…ç½®
		TLSConfig: &tls.Config{
			MinVersion:               tls.VersionTLS12, // æœ€ä½ TLS 1.2
			CurvePreferences:         []tls.CurveID{tls.CurveP521, tls.CurveP384, tls.CurveP256},
			PreferServerCipherSuites: true,
			CipherSuites: []uint16{
				tls.TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384,
				tls.TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA,
				tls.TLS_RSA_WITH_AES_256_GCM_SHA384,
				tls.TLS_RSA_WITH_AES_256_CBC_SHA,
			},
		},
	}

	log.Println("Starting secure HTTPS server on :8443")
	log.Fatal(server.ListenAndServeTLS("cert.pem", "key.pem"))
}

func homeHandler(w http.ResponseWriter, r *http.Request) {
	// æ·»åŠ å®‰å…¨å“åº”å¤´
	w.Header().Set("Strict-Transport-Security", "max-age=31536000; includeSubDomains")
	w.Header().Set("X-Content-Type-Options", "nosniff")
	w.Header().Set("X-Frame-Options", "DENY")
	
	w.Write([]byte("Welcome to secure site!"))
}

func loginHandler(w http.ResponseWriter, r *http.Request) {
	// å¯†ç é€šè¿‡ HTTPS åŠ å¯†ä¼ è¾“ï¼Œå®‰å…¨
	password := r.FormValue("password")
	
	if authenticate(password) {
		http.SetCookie(w, &http.Cookie{
			Name:     "session",
			Value:    generateSessionToken(),
			HttpOnly: true,
			Secure:   true, // åªé€šè¿‡ HTTPS ä¼ è¾“
			SameSite: http.SameSiteStrictMode,
		})
	}
}

func apiHandler(w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Content-Type", "application/json")
	w.Write([]byte(`{"status": "secure"}`))
}

func authenticate(password string) bool {
	return true // ç¤ºä¾‹
}

func generateSessionToken() string {
	return "secure_token"
}

func main() {
	safeServer2()
}
SAFE
	'safefile://safe_http_redirect_to_https.go': <<<SAFE
package main

import (
	"crypto/tls"
	"fmt"
	"log"
	"net/http"
	"time"
)

// æ–¹æ¡ˆ 3: HTTP è‡ªåŠ¨é‡å®šå‘åˆ° HTTPSï¼ˆç”Ÿäº§ç¯å¢ƒæœ€ä½³å®è·µï¼‰
func main() {
	// é…ç½®è·¯ç”±
	mux := http.NewServeMux()
	mux.HandleFunc("/", homeHandler)
	mux.HandleFunc("/api/data", apiHandler)

	// HTTPS æœåŠ¡å™¨ï¼ˆä¸»æœåŠ¡ï¼‰
	httpsServer := &http.Server{
		Addr:         ":443",
		Handler:      addSecurityHeaders(mux),
		ReadTimeout:  10 * time.Second,
		WriteTimeout: 10 * time.Second,
		IdleTimeout:  120 * time.Second,
		TLSConfig: &tls.Config{
			MinVersion: tls.VersionTLS12,
		},
	}

	// HTTP æœåŠ¡å™¨ï¼ˆä»…ç”¨äºé‡å®šå‘ï¼‰
	httpServer := &http.Server{
		Addr:         ":80",
		Handler:      http.HandlerFunc(redirectToHTTPS),
		ReadTimeout:  5 * time.Second,
		WriteTimeout: 5 * time.Second,
	}

	// å¯åŠ¨ HTTP é‡å®šå‘æœåŠ¡å™¨ï¼ˆåå°ï¼‰
	go func() {
		log.Println("Starting HTTP redirect server on :80")
		if err := httpServer.ListenAndServe(); err != nil && err != http.ErrServerClosed {
			log.Fatalf("HTTP server error: %v", err)
		}
	}()

	// å¯åŠ¨ HTTPS æœåŠ¡å™¨ï¼ˆä¸»è¿›ç¨‹ï¼‰
	log.Println("Starting HTTPS server on :443")
	log.Fatal(httpsServer.ListenAndServeTLS("cert.pem", "key.pem"))
}

// HTTP åˆ° HTTPS é‡å®šå‘
func redirectToHTTPS(w http.ResponseWriter, r *http.Request) {
	httpsURL := fmt.Sprintf("https://%s%s", r.Host, r.RequestURI)
	http.Redirect(w, r, httpsURL, http.StatusMovedPermanently)
}

// æ·»åŠ å®‰å…¨å“åº”å¤´ä¸­é—´ä»¶
func addSecurityHeaders(next http.Handler) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		// HSTS: å¼ºåˆ¶ HTTPS
		w.Header().Set("Strict-Transport-Security", "max-age=31536000; includeSubDomains; preload")
		
		// å…¶ä»–å®‰å…¨å¤´
		w.Header().Set("X-Content-Type-Options", "nosniff")
		w.Header().Set("X-Frame-Options", "DENY")
		w.Header().Set("X-XSS-Protection", "1; mode=block")
		w.Header().Set("Content-Security-Policy", "default-src 'self'")
		
		next.ServeHTTP(w, r)
	})
}

func homeHandler(w http.ResponseWriter, r *http.Request) {
	w.Write([]byte("Secure HTTPS Connection"))
}

func apiHandler(w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Content-Type", "application/json")
	w.Write([]byte(`{"secure": true}`))
}
SAFE
	'safefile://safe_localhost_only.go': <<<SAFE
package main

import (
	"log"
	"net/http"
)

// ç‰¹æ®Šæƒ…å†µï¼šå¦‚æœæœåŠ¡å™¨åªç›‘å¬æœ¬åœ°å›ç¯åœ°å€ï¼ˆlocalhost/127.0.0.1ï¼‰
// å¹¶ä¸”åªç”¨äºæœ¬åœ°å¼€å‘æˆ–ä¸æœ¬æœºå…¶ä»–è¿›ç¨‹é€šä¿¡ï¼Œå¯ä»¥æš‚æ—¶ä½¿ç”¨ HTTP
// ä½†ä»ç„¶å»ºè®®åœ¨ç”Ÿäº§ç¯å¢ƒä½¿ç”¨ HTTPS

func localhostOnlyServer() {
	http.HandleFunc("/", func(w http.ResponseWriter, r *http.Request) {
		w.Write([]byte("Local development server"))
	})

	// åªç›‘å¬ localhostï¼Œä¸å¯¹å¤–æš´éœ²
	// è¿™ç§æƒ…å†µé£é™©è¾ƒä½ï¼Œä½†ä»ä¸å»ºè®®å¤„ç†æ•æ„Ÿæ•°æ®
	log.Println("Starting local HTTP server on localhost:8080")
	log.Println("âš ï¸  This server is only accessible from localhost")
	log.Println("âš ï¸  Do NOT use this configuration in production")
	
	log.Fatal(http.ListenAndServe("localhost:8080", nil))
	// æˆ–è€…: log.Fatal(http.ListenAndServe("127.0.0.1:8080", nil))
}

func main() {
	localhostOnlyServer()
}
SAFE
)

