desc(
	title: "Detect Golang HTTP Server Using Plaintext Communication"
	title_zh: "检测Golang HTTP服务器使用明文通信"
	type: vuln
	severity: mid
	desc: <<<DESC
### 漏洞描述

1. **漏洞原理**
   HTTP明文通信是指服务器与客户端之间的数据传输未经过加密处理，所有信息都以明文形式传输。这使得攻击者可以通过网络监听手段（如中间人攻击）轻易截获和读取传输的所有数据，包括敏感信息如用户凭证、会话令牌、支付信息等。Golang中通过`http.ListenAndServe`或`http.Server.ListenAndServe`方法启动的HTTP服务器默认使用明文传输，存在严重安全风险。

2. **触发场景**
   ```go
   // 案例 1: 直接使用 ListenAndServe（最常见）
   func unsafeServer1() {
       http.HandleFunc("/", homeHandler)
       http.HandleFunc("/login", loginHandler)
       // 危险：明文 HTTP 服务器，监听所有网络接口
       log.Fatal(http.ListenAndServe(":8080", nil))
   }

   // 案例 2: 使用 Server 结构体但没有 TLS
   func unsafeServer2() {
       mux := http.NewServeMux()
       mux.HandleFunc("/api/data", apiHandler)
       server := &http.Server{
           Addr:    ":8080",
           Handler: mux,
       }
       // 危险：仍然是明文 HTTP
       log.Fatal(server.ListenAndServe())
   }
   ```
   攻击者可以利用网络嗅探工具（如Wireshark）截获明文传输的数据，或通过中间人攻击篡改数据内容。

3. **潜在影响**
   - 敏感信息（如用户密码、信用卡号、会话令牌）泄露。
   - 攻击者可篡改传输数据（如修改支付金额、注入恶意脚本）。
   - 违反数据安全合规要求（如PCI DSS、GDPR）。
DESC
	rule_id: "bfb17df9-f448-49b8-9201-fe85843a86d8"
	solution: <<<SOLUTION
### 修复建议

#### 1. 使用HTTPS（TLS加密）
   ```go
   // 方案 1: 使用 ListenAndServeTLS（最简单）
   func safeServer1() {
       http.HandleFunc("/", homeHandler)
       http.HandleFunc("/login", loginHandler)
       log.Fatal(http.ListenAndServeTLS(
           ":8443",
           "cert.pem",  // SSL证书
           "key.pem",   // 私钥
           nil,
       ))
   }

   // 方案 2: 配置安全的http.Server（推荐）
   func safeServer2() {
       server := &http.Server{
           Addr: ":8443",
           TLSConfig: &tls.Config{
               MinVersion: tls.VersionTLS12,
               CipherSuites: []uint16{
                   tls.TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384,
                   tls.TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384,
               },
           },
       }
       log.Fatal(server.ListenAndServeTLS("cert.pem", "key.pem"))
   }
   ```

#### 2. 生产环境强制HTTPS重定向
   ```go
   // HTTP到HTTPS重定向
   func redirectToHTTPS(w http.ResponseWriter, r *http.Request) {
       httpsURL := fmt.Sprintf("https://%s%s", r.Host, r.RequestURI)
       http.Redirect(w, r, httpsURL, http.StatusMovedPermanently)
   }

   // 启动HTTP重定向服务（:80）和HTTPS主服务（:443）
   go http.ListenAndServe(":80", http.HandlerFunc(redirectToHTTPS))
   log.Fatal(httpsServer.ListenAndServeTLS("cert.pem", "key.pem"))
   ```

#### 3. 安全配置补充
   - 使用HSTS头强制HTTPS：`w.Header().Set("Strict-Transport-Security", "max-age=31536000")`
   - 对Cookie设置Secure和HttpOnly属性
   - 禁用不安全的TLS版本（如TLS 1.0/1.1）
SOLUTION
	reference: <<<REFERENCE
https://owasp.org/www-community/vulnerabilities/Insecure_Transport
https://cheatsheetseries.owasp.org/cheatsheets/Transport_Layer_Protection_Cheat_Sheet.html
[CWE-319](https://cwe.mitre.org/data/definitions/319.html)
REFERENCE
)

*.ListenAndServe() as $mid;

alert $mid for {
	type: "vuln",
	title: "Golang HTTP Server Using Plaintext Communication Was Detected",
	title_zh: "检测到Golang HTTP服务器使用明文通信",
	level: "mid",
	name: "mid",
	message: "检测到安全漏洞：HTTP 服务器正在使用明文（未加密）协议。所有数据传输都是明文的，攻击者可以拦截和读取传输内容，包括密码、令牌等敏感信息。应该使用 HTTPS（http.ListenAndServeTLS）来加密所有通信。",
	solution: <<<SOLUTION
### 修复建议

#### 1. 使用HTTPS服务器
将`ListenAndServe`替换为`ListenAndServeTLS`，并提供有效的SSL证书和私钥。
```golang
log.Fatal(http.ListenAndServeTLS(
   ":8443",
   "cert.pem",  // SSL证书
   "key.pem",   // 私钥
   nil,
))
```

#### 2. 生产环境最佳实践
对于生产环境，建议同时运行HTTP(80端口)和HTTPS(443端口)服务器，HTTP服务器只做重定向。
```golang
// HTTP重定向服务器
go func() {
   httpServer := &http.Server{
      Addr: ":80",
      Handler: http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
         httpsURL := fmt.Sprintf("https://%s%s", r.Host, r.RequestURI)
         http.Redirect(w, r, httpsURL, http.StatusMovedPermanently)
      }),
   }
   log.Fatal(httpServer.ListenAndServe())
}()

// HTTPS主服务器
httpsServer := &http.Server{
   Addr: ":443",
   Handler: mux,
}
log.Fatal(httpsServer.ListenAndServeTLS("cert.pem", "key.pem"))
```

#### 3. 安全配置推荐
即使是HTTPS也需要合理的TLS配置以避免弱加密算法：
```golang
server := &http.Server{
   TLSConfig: &tls.Config{
      MinVersion:               tls.VersionTLS12,
      CurvePreferences:         []tls.CurveID{tls.CurveP521, tls.CurveP384, tls.CurveP256},
      PreferServerCipherSuites: true,
   },
}
```
SOLUTION
	risk: "明文传输",
	desc: <<<DESC
### 漏洞描述

1. **漏洞原理**
   HTTP明文通信意味着服务器与客户端之间的所有数据传输都是未加密的，攻击者可以通过中间人攻击(MITM)拦截和读取传输内容，包括敏感信息如密码、会话令牌等。这对于处理认证、支付或任何隐私数据的服务尤为危险。

2. **触发场景**
   ```golang
   http.HandleFunc("/", homeHandler)
   log.Fatal(http.ListenAndServe(":8080", nil))
   ```
   以上代码展示了常见的Golang HTTP服务器实现，使用`ListenAndServe`而非`ListenAndServeTLS`，导致通信未加密。

3. **潜在影响**
   - 敏感数据泄露（用户凭证、支付信息等）
   - 会话劫持（通过窃取Cookie或令牌）
   - 违反数据保护法规（如GDPR、PCI DSS）
   - 企业声誉受损
DESC
}

desc(
	lang: golang
	alert_mid: 1
	alert_critical: 1
	'file://unsafe_http_server.go': <<<UNSAFE
package main

import (
	"fmt"
	"log"
	"net/http"
)

// 案例 1: 直接使用 ListenAndServe（最常见）
func unsafeServer1() {
	http.HandleFunc("/", homeHandler)
	http.HandleFunc("/login", loginHandler)
	
	// 危险：明文 HTTP 服务器，监听所有网络接口
	log.Fatal(http.ListenAndServe(":8080", nil))
}

// 案例 2: 使用 Server 结构体但没有 TLS
func unsafeServer2() {
	mux := http.NewServeMux()
	mux.HandleFunc("/api/data", apiHandler)
	
	server := &http.Server{
		Addr:    ":8080",
		Handler: mux,
	}
	
	// 危险：仍然是明文 HTTP
	log.Fatal(server.ListenAndServe())
}

// 案例 3: 监听公网地址（最危险）
func unsafeServer3() {
	http.HandleFunc("/payment", paymentHandler)
	
	// 极度危险：明文 HTTP + 公网地址
	// 任何人都可以拦截支付信息
	log.Fatal(http.ListenAndServe("0.0.0.0:8080", nil))
}

// 案例 4: 处理敏感数据但使用 HTTP
func loginHandler(w http.ResponseWriter, r *http.Request) {
	// 从表单获取密码
	password := r.FormValue("password")
	
	// 危险：密码通过明文 HTTP 传输，可以被拦截
	if authenticate(password) {
		http.SetCookie(w, &http.Cookie{
			Name:  "session",
			Value: generateSessionToken(),
			// 即使设置了 HttpOnly，但通过 HTTP 传输仍然不安全
			HttpOnly: true,
		})
	}
}

func paymentHandler(w http.ResponseWriter, r *http.Request) {
	// 获取支付信息
	cardNumber := r.FormValue("card_number")
	cvv := r.FormValue("cvv")
	
	// 极度危险：支付信息明文传输
	// 严重违反 PCI DSS 标准
	processPayment(cardNumber, cvv)
}

func homeHandler(w http.ResponseWriter, r *http.Request) {
	fmt.Fprintf(w, "Welcome!")
}

func apiHandler(w http.ResponseWriter, r *http.Request) {
	// API 可能包含敏感数据
	fmt.Fprintf(w, `{"user": "admin", "token": "secret123"}`)
}

func authenticate(password string) bool {
	return password == "secret"
}

func generateSessionToken() string {
	return "token123"
}

func processPayment(cardNumber, cvv string) {
	// 处理支付
}

func main() {
	unsafeServer1()
	// unsafeServer2()
	// unsafeServer3()
}
UNSAFE
	'safefile://safe_https_server.go': <<<SAFE
package main

import (
	"crypto/tls"
	"log"
	"net/http"
	"time"
)

// 方案 1: 使用 ListenAndServeTLS（最简单）
func safeServer1() {
	http.HandleFunc("/", homeHandler)
	http.HandleFunc("/login", loginHandler)
	
	// 安全：使用 HTTPS
	log.Println("Starting HTTPS server on :8443")
	log.Fatal(http.ListenAndServeTLS(
		":8443",
		"cert.pem",  // SSL 证书
		"key.pem",   // 私钥
		nil,
	))
}

// 方案 2: 配置安全的 http.Server（推荐）
func safeServer2() {
	mux := http.NewServeMux()
	mux.HandleFunc("/", homeHandler)
	mux.HandleFunc("/api/data", apiHandler)

	server := &http.Server{
		Addr:         ":8443",
		Handler:      mux,
		ReadTimeout:  10 * time.Second,
		WriteTimeout: 10 * time.Second,
		IdleTimeout:  120 * time.Second,
		
		// TLS 安全配置
		TLSConfig: &tls.Config{
			MinVersion:               tls.VersionTLS12, // 最低 TLS 1.2
			CurvePreferences:         []tls.CurveID{tls.CurveP521, tls.CurveP384, tls.CurveP256},
			PreferServerCipherSuites: true,
			CipherSuites: []uint16{
				tls.TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384,
				tls.TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA,
				tls.TLS_RSA_WITH_AES_256_GCM_SHA384,
				tls.TLS_RSA_WITH_AES_256_CBC_SHA,
			},
		},
	}

	log.Println("Starting secure HTTPS server on :8443")
	log.Fatal(server.ListenAndServeTLS("cert.pem", "key.pem"))
}

func homeHandler(w http.ResponseWriter, r *http.Request) {
	// 添加安全响应头
	w.Header().Set("Strict-Transport-Security", "max-age=31536000; includeSubDomains")
	w.Header().Set("X-Content-Type-Options", "nosniff")
	w.Header().Set("X-Frame-Options", "DENY")
	
	w.Write([]byte("Welcome to secure site!"))
}

func loginHandler(w http.ResponseWriter, r *http.Request) {
	// 密码通过 HTTPS 加密传输，安全
	password := r.FormValue("password")
	
	if authenticate(password) {
		http.SetCookie(w, &http.Cookie{
			Name:     "session",
			Value:    generateSessionToken(),
			HttpOnly: true,
			Secure:   true, // 只通过 HTTPS 传输
			SameSite: http.SameSiteStrictMode,
		})
	}
}

func apiHandler(w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Content-Type", "application/json")
	w.Write([]byte(`{"status": "secure"}`))
}

func authenticate(password string) bool {
	return true // 示例
}

func generateSessionToken() string {
	return "secure_token"
}

func main() {
	safeServer2()
}
SAFE
	'safefile://safe_http_redirect_to_https.go': <<<SAFE
package main

import (
	"crypto/tls"
	"fmt"
	"log"
	"net/http"
	"time"
)

// 方案 3: HTTP 自动重定向到 HTTPS（生产环境最佳实践）
func main() {
	// 配置路由
	mux := http.NewServeMux()
	mux.HandleFunc("/", homeHandler)
	mux.HandleFunc("/api/data", apiHandler)

	// HTTPS 服务器（主服务）
	httpsServer := &http.Server{
		Addr:         ":443",
		Handler:      addSecurityHeaders(mux),
		ReadTimeout:  10 * time.Second,
		WriteTimeout: 10 * time.Second,
		IdleTimeout:  120 * time.Second,
		TLSConfig: &tls.Config{
			MinVersion: tls.VersionTLS12,
		},
	}

	// HTTP 服务器（仅用于重定向）
	httpServer := &http.Server{
		Addr:         ":80",
		Handler:      http.HandlerFunc(redirectToHTTPS),
		ReadTimeout:  5 * time.Second,
		WriteTimeout: 5 * time.Second,
	}

	// 启动 HTTP 重定向服务器（后台）
	go func() {
		log.Println("Starting HTTP redirect server on :80")
		if err := httpServer.ListenAndServe(); err != nil && err != http.ErrServerClosed {
			log.Fatalf("HTTP server error: %v", err)
		}
	}()

	// 启动 HTTPS 服务器（主进程）
	log.Println("Starting HTTPS server on :443")
	log.Fatal(httpsServer.ListenAndServeTLS("cert.pem", "key.pem"))
}

// HTTP 到 HTTPS 重定向
func redirectToHTTPS(w http.ResponseWriter, r *http.Request) {
	httpsURL := fmt.Sprintf("https://%s%s", r.Host, r.RequestURI)
	http.Redirect(w, r, httpsURL, http.StatusMovedPermanently)
}

// 添加安全响应头中间件
func addSecurityHeaders(next http.Handler) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		// HSTS: 强制 HTTPS
		w.Header().Set("Strict-Transport-Security", "max-age=31536000; includeSubDomains; preload")
		
		// 其他安全头
		w.Header().Set("X-Content-Type-Options", "nosniff")
		w.Header().Set("X-Frame-Options", "DENY")
		w.Header().Set("X-XSS-Protection", "1; mode=block")
		w.Header().Set("Content-Security-Policy", "default-src 'self'")
		
		next.ServeHTTP(w, r)
	})
}

func homeHandler(w http.ResponseWriter, r *http.Request) {
	w.Write([]byte("Secure HTTPS Connection"))
}

func apiHandler(w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Content-Type", "application/json")
	w.Write([]byte(`{"secure": true}`))
}
SAFE
	'safefile://safe_localhost_only.go': <<<SAFE
package main

import (
	"log"
	"net/http"
)

// 特殊情况：如果服务器只监听本地回环地址（localhost/127.0.0.1）
// 并且只用于本地开发或与本机其他进程通信，可以暂时使用 HTTP
// 但仍然建议在生产环境使用 HTTPS

func localhostOnlyServer() {
	http.HandleFunc("/", func(w http.ResponseWriter, r *http.Request) {
		w.Write([]byte("Local development server"))
	})

	// 只监听 localhost，不对外暴露
	// 这种情况风险较低，但仍不建议处理敏感数据
	log.Println("Starting local HTTP server on localhost:8080")
	log.Println("⚠️  This server is only accessible from localhost")
	log.Println("⚠️  Do NOT use this configuration in production")
	
	log.Fatal(http.ListenAndServe("localhost:8080", nil))
	// 或者: log.Fatal(http.ListenAndServe("127.0.0.1:8080", nil))
}

func main() {
	localhostOnlyServer()
}
SAFE
)

