
desc(
	title: "Check PHP Unfiltered Directory Reading"
	title_zh: "检测PHP未过滤目录读取"
	risk: "audit"
	level: "low"
	desc: <<<DESC
### 漏洞描述

1. **漏洞原理**
   未经过滤的目录读取漏洞（Path Traversal/Directory Traversal）源于应用程序在处理用户提供的文件或目录路径时，未能对特殊字符（如 `..`、`/`、`\`）进行充分的过滤或验证。攻击者通过构造恶意路径，可以访问到本不应允许访问的文件或目录，例如应用程序的配置文件、源代码，甚至获取系统敏感信息。

2. **触发场景**
   当PHP代码使用用户输入直接作为 `dir()`、`opendir()`、`scandir()` 等目录操作函数的参数，且未对输入进行严格的路径规范化或过滤时，就可能触发此漏洞。例如，以下代码直接使用`$_GET['path']`作为`dir()`的参数：
   ```php
   <?php
   function readDir($path) {
       $dh = dir($path);
       while (($file = $dh->read()) !== false) {
           echo $file . "\n";
       }
   }
   readDir($_GET["path"]);
   ?>
   ```
   攻击者可以通过构造类似 `../../etc/passwd` 的path参数，尝试读取系统密码文件。

3. **潜在影响**
   - 泄露服务器上任意文件或目录的内容，包括配置文件、敏感文档、用户数据等。
   - 进一步结合其他漏洞，可能导致远程代码执行或系统控制权限的获取。
   - 泄露应用程序源码，帮助攻击者发现其他潜在漏洞。
DESC
	rule_id: "bf141248-59ef-4fb0-b521-ff7c8339d44d"
	solution: <<<SOLUTION
### 修复建议

1. **严格过滤用户输入**
   对所有来自用户的输入（如 `$_GET`, `$_POST`, `$_COOKIE` 等）进行严格的过滤和验证。使用白名单方式限制允许访问的目录或文件名，禁止包含特殊字符（如 `..`, `/`, `\`, `%00` 空字节等）。

2. **规范化路径**
   在处理用户输入路径之前，先对其进行规范化。可以使用 `realpath()` 或自定义函数来获取文件的绝对路径，并检查该路径是否在预期的安全范围内。
   ```php
   <?php
   function readDirSafe($path) {
       // 规范化路径并检查是否在指定根目录下
       $baseDir = '/var/www/uploads/'; // 指定安全根目录
       $realPath = realpath($baseDir . '/' . $path);
       if ($realPath === false || strpos($realPath, $baseDir) !== 0) {
           // 输入无效或超出范围
           echo "Invalid path.\n";
           return;
       }
       
       // 安全地读取目录
       $dh = dir($realPath);
       if ($dh) {
           while (($file = $dh->read()) !== false) {
               echo $file . "\n";
           }
           $dh->close();
       }
   }
   readDirSafe($_GET["path"]);
   ?>
   ```

3. **权限控制**
   确保执行文件操作的进程拥有最小必要的权限，限制其对敏感目录的访问。
SOLUTION
	reference: <<<REFERENCE
[CWE-73: External Control of File Name or Path](https://cwe.mitre.org/data/definitions/73.html)
REFERENCE
)

<include('php-param')> as $params;
<include('php-tp-all-extern-variable-param-source')> as $params

dir(* as $allParams)
$allParams?{<self> #{include: <<<CODE
* & $params
CODE
}->} as $sink

alert $sink for {
	title: "PHP Unfiltered Directory Reading Vulnerability",
	title_zh: "PHP未过滤目录读取漏洞",
	solution: <<<CODE
### 修复建议

#### 1. 输入验证与过滤
对所有用户提供的输入路径进行严格的验证和过滤。确保不允许使用相对路径（例如“..”）或绝对路径，并验证路径是否在允许访问的目录白名单中。
```php
<?php
function safeReadDir($path, $baseDir) {
    // 1. 检查是否包含非法字符
    if (preg_match('/\.\./', $path)) {
        return 'Invalid path: contains relative paths.';
    }

    // 2. 构建完整路径并进行realpath规范化
    $fullPath = realpath($baseDir . '/' . $path);

    // 3. 确保路径在允许的baseDir下
    if (strpos($fullPath, realpath($baseDir)) !== 0) {
        return 'Invalid path: outside base directory.';
    }

    // 4. 使用安全的scandir替代dir
    $files = scandir($fullPath);

    if ($files === false) {
        return 'Could not read directory.';
    }

    // 5. 返回过滤后的文件列表
    return array_diff($files, ['.', '..']);  // 移除 . 和 ..
}

// 示例用法：
$baseDirectory = '/var/www/safe_uploads'; // 设置基础目录
$userInputPath = $_GET['path'] ?? '';   // 获取用户输入

$files = safeReadDir($userInputPath, $baseDirectory);

if (is_array($files)) {
    echo 'Files: ' . implode(', ', $files);
} else {
    echo $files;  // 输出错误消息
}
?>
```
#### 2. 路径规范化
使用`realpath()`函数将用户提供的路径转换为绝对路径，然后确保该路径位于允许的目录范围内。这可以防止路径遍历攻击。

#### 3. 最小权限原则
确保运行PHP进程的用户具有执行目录操作所需的最小权限。避免使用具有过高权限的用户身份运行Web服务器。

#### 4. 使用内置函数进行安全操作
使用如`scandir()`等更安全的内置函数，替代已弃用的或存在安全风险的函数。

#### 5. 日志记录
记录所有目录读取尝试，尤其是在发生错误或检测到潜在攻击时，以便进行后续分析和审计。
CODE
	desc: <<<CODE
### 漏洞描述
1. **漏洞原理**
PHP未过滤目录读取漏洞（也称为路径遍历漏洞）发生在应用程序允许用户控制用于访问文件或目录的路径时。如果应用程序没有充分验证或清理用户提供的输入，攻击者可以操纵路径以访问受限的文件和目录，从而可能导致敏感信息泄露或执行恶意代码。

2. **触发场景**
以下是一个PHP代码示例，显示了如何触发此漏洞：
```php
<?php
$path = $_GET['path'];  // 从URL参数获取用户提供的路径

// 直接使用用户提供的路径来读取目录
$files = scandir($path);

if ($files) {
    foreach ($files as $file) {
        echo $file . "\n";
    }
}
?>
```
攻击者可以修改`path`参数，例如设置为`../../etc/passwd`，来尝试读取服务器上的敏感文件。

3. **潜在影响**
- **信息泄露**：攻击者可以访问和下载敏感文件和目录，例如配置文件、数据库连接信息、源代码等。
- **系统入侵**：通过访问包含敏感信息的配置文件，攻击者可能能够进一步入侵系统。
- **代码执行**：在某些情况下，攻击者可能能够上传恶意文件到服务器上，并通过路径遍历漏洞来执行这些文件。
CODE
	level: "high",
}
desc(
	lang: "php"
	'file:///unsafe.php': <<<CODE
<?php
function readDir($path){
    $dh = dir($path);
    while (($file = $dh->read()) !== false) {
        echo $file . "\n";
    }
}
readDir($_GET["path"]);
CODE
)
