desc(
	title: "Detect PHP Unsafe File Upload"
	title_zh: "检测PHP不安全的文件上传漏洞"
	type: vul
	desc: <<<DESC
### 漏洞描述

1. **漏洞原理**
文件上传漏洞是指用户上传了一个可执行的脚本文件，并通过此脚本文件获得了执行服务器端命令的能力。这种攻击方式是最为直接和有效的，“文件上传”本身没有问题，有问题的是文件上传后，服务器怎么处理、解释文件。如果服务器的处理逻辑做的不够安全，则会导致严重的后果。
a. **任意文件上传**: 未对上传文件的类型、内容进行严格校验，或者对文件名称和路径未进行有效处理，导致攻击者可以上传任意类型（特别是可执行脚本）的文件到服务器。
b. **恶意文件包含**: 攻击者上传恶意文件后，若应用程序存在文件包含漏洞，则可能导致远程代码执行。
c. **文件名和路径操纵**: 攻击者可能通过修改请求中的文件名、路径信息，将文件上传到非预期的敏感目录，甚至覆盖现有重要文件。

2. **触发场景**
当应用程序允许用户上传文件，但未对上传的文件类型、内容、大小、文件名以及存储路径进行充分的验证和过滤时，可能存在文件上传漏洞。特别是在处理`$_FILES`全局变量或使用`move_uploaded_file`等函数时，需要警惕。

```php
<?php
    class UploadController {
        public function uploadFile() {
            $file = $_FILES['file'];
            $uploadDir = 'public/uploads/';  // 直接存储在Web可访问目录

            // 不安全的文件类型检测（仅依赖客户端MIME类型）
            if ($file['type'] === 'image/jpeg') {
                $targetPath = $uploadDir . $file['name'];
                move_uploaded_file($file['tmp_name'], $targetPath); // 直接使用原始文件名
                echo "文件上传成功！";
            }
        }
    }
?>
```
在上述示例中，仅依靠客户端提供的`file['type']`进行文件类型判断是不安全的，攻击者可以轻易绕过。同时，直接使用原始文件名 `$file['name']` 存在目录遍历（Path Traversal）和文件覆盖的风险。

3. **潜在影响**
- 攻击者上传WebShell，获取服务器的控制权。
- 绕过身份认证，执行恶意操作。
- 篡改网站内容，发布恶意信息。
- 泄露服务器敏感信息。
- 消耗服务器资源，导致拒绝服务。
- 与其他漏洞（如文件包含）结合，导致更严重的危害。
DESC
	rule_id: "7138efeb-bd0b-4dd1-a728-a5d84c3bfa61"
	solution: <<<SOLUTION
### 修复建议

#### 1. 严格校验文件类型和内容
- **白名单校验**: 优先使用允许上传的文件类型白名单，而不是禁止黑名单。从服务器端获取文件的真实 MIME 类型和内容，而不是仅依赖客户端发送的`Content-Type`。
- **文件头校验(Magic Number)**: 检查文件的实际文件头（magic number），判断文件真实类型，防止攻击者通过修改后缀绕过。
- **图片文件二次处理**: 对于允许上传的图片文件，进行二次处理（如缩放、加水印）可以破坏文件中可能隐藏的恶意代码。

```php
<?php
    class UploadController {
        public function uploadFile() {
            $file = $_FILES['file'];
            $uploadDir = 'public/uploads/';

            // 1. 校验文件是否存在且无上传错误
            if (!isset($file['error']) || is_array($file['error'])) {
                 throw new RuntimeException('Invalid parameters.');
            }
            switch ($file['error']) {
                case UPLOAD_ERR_OK:
                    break;
                case UPLOAD_ERR_NO_FILE:
                    throw new RuntimeException('No file sent.');
                case UPLOAD_ERR_INI_SIZE:
                case UPLOAD_ERR_FORM_SIZE:
                    throw new RuntimeException('Exceeded filesize limit.');
                default:
                    throw new RuntimeException('Unknown errors.');
            }

            // 2. 限制文件大小
            if ($file['size'] > 1000000) { // 限制1MB
                throw new RuntimeException('Exceeded filesize limit.');
            }

            // 3. 白名单校验文件类型和文件头 (仅供示例，实际应用需更严格)
            $finfo = new finfo(FILEINFO_MIME_TYPE);
            $mimeType = $finfo->file($file['tmp_name']);
            $allowedTypes = ['image/jpeg', 'image/png', 'image/gif'];

            if (!in_array($mimeType, $allowedTypes)) {
                 throw new RuntimeException('Invalid file format.');
            }

            // 4. 生成安全的文件名，而不是使用原始文件名
            $ext = array_search($mimeType, $allowedTypes, true);
            $newName = sprintf('%s.%s', sha1_file($file['tmp_name']), $ext);
            $targetPath = $uploadDir . $newName;

            // 5. 移动上传的文件
            if (!move_uploaded_file($file['tmp_name'], $targetPath)) {
                throw new RuntimeException('Failed to move uploaded file.');
            }

            echo "文件上传成功！新的文件名为: " . $newName;
        }
    }
?>
```

#### 2. 安全的文件名和存储路径处理
- **重命名文件**: 不要直接使用用户上传的文件名，使用哈希值、UUID或其他随机字符串生成新的文件名，并附加通过安全方式检测到的正确文件扩展名。
- **限制上传目录**: 确保文件上传到Web服务器不可直接访问的目录（如在Web根目录之外），通过应用程序进行安全访问控制。
- **防止目录遍历**: 清理或禁止文件名和路径中的特殊字符（如`../`），防止攻击者上传到非预期目录。

#### 3. 设置文件执行权限
- 确保上传文件目录禁用脚本执行权限，即使文件本身是可执行脚本，也無法在服务器上运行。可以通过修改Web服务器的配置文件来实现。
SOLUTION
	reference: <<<REFERENCE
[CWE-434: Unrestricted Upload of File with Dangerous Type](https://cwe.mitre.org/data/definitions/434.html)
[OWASP Top 10: A01:2021 - Broken Access Control (包含文件上传的相关风险)](https://owasp.org/Top10/zh_CN/A01_2021-Broken_Access_Control/)
[OWASP Cheat Sheet Series: File Upload Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/File_Upload_Cheat_Sheet.html)
REFERENCE
)
<include('php-filter-function')> as $filter

<include('php-param')> as $params;
<include('php-tp-all-extern-variable-param-source')> as $params
<include('php-file-write')> as $source
_FILES.* as $params
_FILES as $params


move_uploaded_file(* as $source)
./move|putFile/?{<getFunc><getCurrentBlueprint><fullTypeName>?{any: "Controller","controller"}}(,* as $source)

$source?{<self> #{include: <<<CODE
* & $params
CODE}->} as $sink


$sink<dataflow(include=<<<CODE
* & $params as $__next__
CODE,exclude=<<<CODE
*?{opcode: call} as $__next__
CODE)> as $high

alert $high for {
	title: "Unsafe File Upload Without Validation",
	title_zh: "未经验证的高危文件上传",
	solution: <<<CODE
### 修复建议

#### 1. 严格校验文件类型和内容
- **白名单校验**: 优先使用允许上传的文件类型白名单，而不是禁止黑名单。从服务器端获取文件的真实 MIME 类型和内容，而不是仅依赖客户端发送的`Content-Type`。
- **文件头校验(Magic Number)**: 检查文件的实际文件头（magic number），判断文件真实类型，防止攻击者通过修改后缀绕过。
- **图片文件二次处理**: 对于允许上传的图片文件，进行二次处理（如缩放、加水印）可以破坏文件中可能隐藏的恶意代码。

```php
<?php
    class UploadController {
        public function uploadFile() {
            $file = $_FILES['file'];
            $uploadDir = 'public/uploads/';

            // 1. 校验文件是否存在且无上传错误
            if (!isset($file['error']) || is_array($file['error'])) {
                 throw new RuntimeException('Invalid parameters.');
            }
            switch ($file['error']) {
                case UPLOAD_ERR_OK:
                    break;
                case UPLOAD_ERR_NO_FILE:
                    throw new RuntimeException('No file sent.');
                case UPLOAD_ERR_INI_SIZE:
                case UPLOAD_ERR_FORM_SIZE:
                    throw new RuntimeException('Exceeded filesize limit.');
                default:
                    throw new RuntimeException('Unknown errors.');
            }

            // 2. 限制文件大小
            if ($file['size'] > 1000000) { // 限制1MB
                throw new RuntimeException('Exceeded filesize limit.');
            }

            // 3. 白名单校验文件类型和文件头 (仅供示例，实际应用需更严格)
            $finfo = new finfo(FILEINFO_MIME_TYPE);
            $mimeType = $finfo->file($file['tmp_name']);
            $allowedTypes = ['image/jpeg', 'image/png', 'image/gif'];

            if (!in_array($mimeType, $allowedTypes)) {
                 throw new RuntimeException('Invalid file format.');
            }

            // 4. 生成安全的文件名，而不是使用原始文件名
            $ext = array_search($mimeType, $allowedTypes, true);
            $newName = sprintf('%!s(MISSING).%!s(MISSING)', sha1_file($file['tmp_name']), $ext);
            $targetPath = $uploadDir . $newName;

            // 5. 移动上传的文件
            if (!move_uploaded_file($file['tmp_name'], $targetPath)) {
                throw new RuntimeException('Failed to move uploaded file.');
            }

            echo "文件上传成功！新的文件名为: " . $newName;
        }
    }
?>
```

#### 2. 安全的文件名和存储路径处理
- **重命名文件**: 不要直接使用用户上传的文件名，使用哈希值、UUID或其他随机字符串生成新的文件名，并附加通过安全方式检测到的正确文件扩展名。
- **限制上传目录**: 确保文件上传到Web服务器不可直接访问的目录（如在Web根目录之外），通过应用程序进行安全访问控制。
- **防止目录遍历**: 清理或禁止文件名和路径中的特殊字符（如`../`），防止攻击者上传到非预期目录。

#### 3. 设置文件执行权限
- 确保上传文件目录禁用脚本执行权限，即使文件本身是可执行脚本，也無法在服务器上运行。可以通过修改Web服务器的配置文件来实现。
CODE
	desc: <<<CODE
### 漏洞描述

1. **漏洞原理**
文件上传漏洞是指用户上传了一个可执行的脚本文件，并通过此脚本文件获得了执行服务器端命令的能力。这种攻击方式是最为直接和有效的，“文件上传”本身没有问题，有问题的是文件上传后，服务器怎么处理、解释文件。如果服务器的处理逻辑做的不够安全，则会导致严重的后果。
a. **任意文件上传**: 未对上传文件的类型、内容进行严格校验，或者对文件名称和路径未进行有效处理，导致攻击者可以上传任意类型（特别是可执行脚本）的文件到服务器。
b. **恶意文件包含**: 攻击者上传恶意文件后，若应用程序存在文件包含漏洞，则可能导致远程代码执行。
c. **文件名和路径操纵**: 攻击者可能通过修改请求中的文件名、路径信息，将文件上传到非预期的敏感目录，甚至覆盖现有重要文件。

2. **触发场景**
当应用程序允许用户上传文件，但未对上传的文件类型、内容、大小、文件名以及存储路径进行充分的验证和过滤时，可能存在文件上传漏洞。特别是在处理`$_FILES`全局变量或使用`move_uploaded_file`等函数时，需要警惕。

```php
<?php
    class UploadController {
        public function uploadFile() {
            $file = $_FILES['file'];
            $uploadDir = 'public/uploads/';  // 直接存储在Web可访问目录

            // 不安全的文件类型检测（仅依赖客户端MIME类型）
            if ($file['type'] === 'image/jpeg') {
                $targetPath = $uploadDir . $file['name'];
                move_uploaded_file($file['tmp_name'], $targetPath); // 直接使用原始文件名
                echo "文件上传成功！";
            }
        }
    }
?>
```
在上述示例中，仅依靠客户端提供的`file['type']`进行文件类型判断是不安全的，攻击者可以轻易绕过。同时，直接使用原始文件名 `$file['name']` 存在目录遍历（Path Traversal）和文件覆盖的风险。

3. **潜在影响**
- 攻击者上传WebShell，获取服务器的控制权。
- 绕过身份认证，执行恶意操作。
- 篡改网站内容，发布恶意信息。
- 泄露服务器敏感信息。
- 消耗服务器资源，导致拒绝服务。
- 与其他漏洞（如文件包含）结合，导致更严重的危害。
CODE
	level: "high",
}
$sink<dataflow(include=<<<CODE
* & $params as $__next__
CODE,exclude=<<<CODE
*?{opcode:call && <self><getCallee> & $filter} as $__next__
CODE)> as $highAndMid

$highAndMid - $high as $mid
alert $mid for {
	desc: <<<CODE
### 风险描述

1. **风险原理**
不安全的文件类型检测是指应用程序未对上传的文件类型进行充分验证，仅仅依赖于客户端提供的 MIME 类型或者文件扩展名进行判断。攻击者可以修改这些信息，绕过服务器端的检查，上传恶意文件。

2. **触发场景**
当应用程序使用以下方式进行文件类型检测时，可能存在风险：

- 仅验证客户端 Content-Type 头部。
- 使用黑名单策略，禁止上传某些文件类型。
- 未对文件内容进行实际分析。

```php
<?php
    class UploadController {
        public function uploadFile() {
            $file = $_FILES['file'];
            $uploadDir = 'public/uploads/';

            // 仅依赖客户端 MIME 类型进行判断
            if ($file['type'] === 'image/jpeg') {
                $targetPath = $uploadDir . $file['name'];
                move_uploaded_file($file['tmp_name'], $targetPath);
                echo "文件上传成功！";
            }
        }
    }
?>
```

3. **潜在影响**
- 允许上传恶意脚本文件，例如 PHP、ASP 等，导致远程代码执行。
- 上传包含恶意代码的图片文件，例如包含 XSS 代码的 PNG 文件。
- 绕过访问控制，上传敏感信息文件。
CODE
	level: "mid",
	title: "Insecure File Type Detection",
	title_zh: "不安全的文件类型检测",
	solution: <<<CODE
### 修复建议

#### 1. 严格校验文件类型和内容
- **白名单校验**: 优先使用允许上传的文件类型白名单，而不是禁止黑名单。从服务器端获取文件的真实 MIME 类型和内容，而不是仅依赖客户端发送的`Content-Type`。
- **文件头校验(Magic Number)**: 检查文件的实际文件头（magic number），判断文件真实类型，防止攻击者通过修改后缀绕过。
- **图片文件二次处理**: 对于允许上传的图片文件，进行二次处理（如缩放、加水印）可以破坏文件中可能隐藏的恶意代码。

```php
<?php
    class UploadController {
        public function uploadFile() {
            $file = $_FILES['file'];
            $uploadDir = 'public/uploads/';

            // 1. 校验文件是否存在且无上传错误
            if (!isset($file['error']) || is_array($file['error'])) {
                 throw new RuntimeException('Invalid parameters.');
            }
            switch ($file['error']) {
                case UPLOAD_ERR_OK:
                    break;
                case UPLOAD_ERR_NO_FILE:
                    throw new RuntimeException('No file sent.');
                case UPLOAD_ERR_INI_SIZE:
                case UPLOAD_ERR_FORM_SIZE:
                    throw new RuntimeException('Exceeded filesize limit.');
                default:
                    throw new RuntimeException('Unknown errors.');
            }

            // 2. 限制文件大小
            if ($file['size'] > 1000000) { // 限制1MB
                throw new RuntimeException('Exceeded filesize limit.');
            }

            // 3. 白名单校验文件类型和文件头 (仅供示例，实际应用需更严格)
            $finfo = new finfo(FILEINFO_MIME_TYPE);
            $mimeType = $finfo->file($file['tmp_name']);
            $allowedTypes = ['image/jpeg', 'image/png', 'image/gif'];

            if (!in_array($mimeType, $allowedTypes)) {
                 throw new RuntimeException('Invalid file format.');
            }

            // 4. 生成安全的文件名，而不是使用原始文件名
            $ext = array_search($mimeType, $allowedTypes, true);
            $newName = sprintf('%!s(MISSING).%!s(MISSING)', sha1_file($file['tmp_name']), $ext);
            $targetPath = $uploadDir . $newName;

            // 5. 移动上传的文件
            if (!move_uploaded_file($file['tmp_name'], $targetPath)) {
                throw new RuntimeException('Failed to move uploaded file.');
            }

            echo "文件上传成功！新的文件名为: " . $newName;
        }
    }
?>
```

#### 2. 安全的文件名和存储路径处理
- **重命名文件**: 不要直接使用用户上传的文件名，使用哈希值、UUID或其他随机字符串生成新的文件名，并附加通过安全方式检测到的正确文件扩展名。
- **限制上传目录**: 确保文件上传到Web服务器不可直接访问的目录（如在Web根目录之外），通过应用程序进行安全访问控制。
- **防止目录遍历**: 清理或禁止文件名和路径中的特殊字符（如`../`），防止攻击者上传到非预期目录。

#### 3. 设置文件执行权限
- 确保上传文件目录禁用脚本执行权限，即使文件本身是可执行脚本，也無法在服务器上运行。可以通过修改Web服务器的配置文件来实现。
CODE
}
$sink - $high - $mid as $low

alert $low for {
	title: "Potential File Storage Path Misconfiguration",
	title_zh: "潜在的文件存储路径配置问题",
	solution: <<<CODE
### 修复建议

#### 1. 规范化文件存储路径
- **使用绝对路径**: 避免使用相对路径存储文件，确保文件存储在预期的位置。
- **避免 Web 可访问目录**: 将上传的文件存储在 Web 服务器无法直接访问的目录中，防止恶意用户直接访问上传的文件。

#### 2. 实施访问控制
- **身份验证和授权**: 确保只有经过身份验证和授权的用户才能上传和访问文件。
- **最小权限原则**: 授予用户执行其任务所需的最小权限。

#### 3. 路径遍历保护
- **清理用户输入**: 在使用用户提供的文件名或路径之前，清理所有特殊字符（例如 `../`），防止目录遍历攻击。
- **使用安全函数**: 使用安全的文件操作函数，例如 `realpath()`，以确保文件路径是安全的。

#### 4. 日志和监控
- **记录文件上传事件**: 记录所有文件上传事件，包括上传时间、用户、文件名和存储路径。
- **监控异常活动**: 监控文件上传目录中的异常活动，例如未经授权的访问或修改。
CODE
	desc: <<<CODE
### 风险描述

1. **风险原理**
文件存储路径配置问题是指应用程序在存储上传的文件时，未正确配置存储路径，导致文件存储在不安全的位置（例如 Web 可访问目录）或存在目录遍历漏洞。

2. **触发场景**
当应用程序使用以下方式存储文件时，可能存在风险：

- 将文件存储在 Web 服务器可以直接访问的目录中。
- 使用相对路径存储文件，可能导致文件存储在非预期的位置。
- 未对用户提供的文件名或路径进行充分的验证，可能导致目录遍历攻击。

```php
<?php
    class UploadController {
        public function uploadFile() {
            $file = $_FILES['file'];
            $uploadDir = 'public/uploads/';  // 直接存储在Web可访问目录

            $targetPath = $uploadDir . $file['name']; // 使用原始文件名
            move_uploaded_file($file['tmp_name'], $targetPath);
            echo "文件上传成功！";
        }
    }
?>
```

3. **潜在影响**
- 允许未经授权的用户访问上传的文件。
- 允许攻击者通过目录遍历漏洞上传文件到任意位置。
- 可能导致敏感信息泄露或远程代码执行。
CODE
	level: "low",
}
desc(
	lang: "php"
	alert_min: 1
	"file:///upload.php": <<<TEXT
<?php
    class UploadController {
        public function uploadFile() {
            $file = $_FILES['file'];
            $uploadDir = 'public/uploads/';  // 直接存储在Web可访问目录

            // 不安全的文件类型检测（仅依赖客户端MIME类型）
            if ($file['type'] === 'image/jpeg') {
                $targetPath = $uploadDir . $file['name'];
                move_uploaded_file($file['tmp_name'], $targetPath); // 直接使用原始文件名
                echo "文件上传成功！";
            }
        }
    }
TEXT
	"file:///upload2.php": <<<TEXT
<?php
    class uploads{
        public function upload(){
            $path = $_GET["path"];
            $file = $_GET["file"];
            validate($validate)->check(DataHelper::objToArray($file));
            $savename = \think\facade\Filesystem::disk('public')->putFile($path, $file);
        }
    }
TEXT
)
