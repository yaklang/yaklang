desc(
	title: "Audit PHP ThinkPHP Authentication Bypass"
	title_zh: "审计PHP ThinkPHP认证绕过漏洞"
	risk: "Credential Hardcoding"
	type: vul
	level: "low"
	desc: <<<DESC
### 漏洞描述

1. **漏洞原理**
   ThinkPHP框架中的认证绕过漏洞通常由于开发者未能正确实施身份验证和授权控制机制。攻击者可以通过操纵请求参数、利用逻辑缺陷或直接访问未经保护的端点来绕过认证流程。这种漏洞的核心在于应用程序对用户权限的验证不充分，导致未授权用户可以执行敏感操作。

2. **触发场景**
   在ThinkPHP应用中，认证绕过可能出现在以下场景：
   - 控制器方法未应用中间件进行权限校验
   - 直接从请求参数获取用户标识而未验证其合法性
   - 认证逻辑存在缺陷，如可预测的令牌或可绕过的条件检查

   ```php
   // 存在漏洞的代码示例
   namespace app\index\controller;
   use think\Controller;
   
   class User extends Controller {
       public function deleteUser() {
           $userId = input('user_id'); // 未经验证的用户输入
           // 直接执行删除操作，未检查当前用户权限
           $this->model->where('id', $userId)->delete();
       }
   }
   ```

3. **潜在影响**
   - 未授权访问敏感功能或数据
   - 恶意用户可提升自身权限
   - 系统关键功能被未授权操纵
   - 可能导致数据泄露或系统完整性破坏
DESC
	rule_id: "dbe0c15c-9321-4281-b9a1-937077a41efa"
	solution: <<<SOLUTION
### 修复建议

#### 1. 实施严格的中间件验证
在ThinkPHP中应当为所有需要认证的路由应用认证中间件：
```php
// 定义认证中间件
class AuthMiddleware {
    public function handle($request, \Closure $next) {
        if (!session('user_id')) {
            return redirect('/login');
        }
        return $next($request);
    }
}

// 路由中应用中间件
Route::rule('user/profile', 'user/profile')->middleware(AuthMiddleware::class);
```

#### 2. 实现权限控制系统
对于敏感操作应当实现细粒度的权限控制：
```php
// 在控制器中检查权限
public function deleteUser() {
    if (!auth()->user()->can('delete_users')) {
        throw new \think\exception\UnauthorizedException;
    }
    // 安全删除逻辑
}
```

#### 3. 参数安全处理
对所有的用户输入进行严格验证：
```php
// 使用验证器确保参数安全
$validate = Validate::rule('user_id', 'require|number|gt:0');
if (!$validate->check(input())) {
    throw new \think\exception\ValidateException;
}
```

#### 4. 定期安全审计
建议定期使用安全扫描工具检查应用中的认证缺陷，并及时更新框架版本以修复已知漏洞。
SOLUTION
	reference: <<<REFERENCE
[CWE-287: Improper Authentication](https://cwe.mitre.org/data/definitions/287.html)
[ThinkPHP Security Best Practices](https://www.thinkphp.cn/doc)
REFERENCE
)
ldap_bind(*<slice(start=2)>?{opcode: const} as $pass)
ldap_exop_passwd(,*?{opcode: const} as $pass,*?{opcode: const} as $pass)
ldap_bind_ext(,*?{opcode: const} as $pass)

$pass as $sink

alert $sink for {
	title: "Detect PHP ThinkPHP Authentication Bypass Vulnerability",
	title_zh: "检测PHP ThinkPHP认证绕过漏洞",
	solution: <<<CODE
### 修复建议

1. **实施严格的中间件验证**
   所有需要认证的路由必须应用认证中间件，确保未经认证的请求无法访问敏感功能。

   ```php
   // 应用中间件示例
   Route::rule('admin/*', 'admin/*')->middleware(AuthMiddleware::class);
   ```

2. **参数安全验证**
   对所有用户输入参数进行严格验证，确保符合预期格式和范围：
   ```php
   // 使用验证器
   $validate = new \think\Validate([
       'user_id' => 'require|number|gt:0'
   ]);
   ```

3. **权限最小化原则**
   用户只应拥有完成其功能所需的最小权限，避免过度授权。
CODE
	desc: <<<CODE
### 漏洞描述

1. **漏洞原理**
   ThinkPHP框架中的认证绕过漏洞是指攻击者能够规避或绕过应用程序的身份验证机制，从而以未授权的身份访问受保护的资源或执行敏感操作。这通常发生在应用程序未能对用户身份或权限进行充分验证时，例如，通过操纵请求参数、利用逻辑缺陷、或者直接访问未受保护的API端点。此类漏洞的核心在于身份验证逻辑的薄弱或实施不当，允许非授权用户获取本不应有的访问权限。

2. **触发场景**
   在ThinkPHP应用中，常见的认证绕过触发场景包括：
   - **未严格校验的用户输入：** 当应用程序直接从请求参数（如URL、POST数据或HTTP头）中获取用户ID、角色或其他身份标识，而未对这些输入进行充分的合法性验证或签名检查时，攻击者可以通过篡改这些参数来伪造身份。
   - **中间件或权限逻辑缺失：** 某些控制器方法或路由没有正确配置认证中间件或进行细粒度的权限检查，导致即使未登录或权限不足的用户也能直接访问。
   - **逻辑缺陷：** 身份验证流程中存在可预测的令牌、弱会话管理、或者在特定条件下可绕过的条件判断。
   - **示例代码：**
     ```php
     // 存在漏洞的代码示例
     namespace app\index\controller;
     use think\Controller;
     class User extends Controller {
         public function deleteUser() {
             $userId = input('user_id'); // 未经验证的用户输入，攻击者可随意指定
             // 假设这里没有权限检查，直接执行删除
             $this->model->where('id', $userId)->delete();
         }
     }
     ```
     攻击者可能通过发送 `POST /user/deleteUser?user_id=123` 请求，删除任意用户，即使他不是管理员。

3. **潜在影响**
   认证绕过漏洞可能导致严重的安全后果：
   - **敏感信息泄露：** 攻击者可以访问并窃取受保护的用户数据、业务数据或配置信息。
   - **权限提升：** 普通用户可能绕过认证，获取管理员权限，从而完全控制应用程序。
   - **业务逻辑篡改：** 攻击者可以执行未经授权的敏感操作，如修改、删除关键数据，或执行恶意操作。
   - **系统完整性破坏：** 如果绕过认证后能执行文件操作或命令执行，可能导致服务器被入侵。
   - **信任度受损：** 用户和合作伙伴对系统的信任度降低，可能带来声誉和经济损失。
CODE
	level: "high",
}

desc(
	lang: "php"
	alert_min: "1"
	"file:///unsafe.php": <<<UNSAFE
<?php
// 不安全示例：密码直接明文写入代码
$ldapconn = ldap_connect("ldap.example.com");
ldap_bind($ldapconn, "cn=admin", "Admin@123");
UNSAFE
)
