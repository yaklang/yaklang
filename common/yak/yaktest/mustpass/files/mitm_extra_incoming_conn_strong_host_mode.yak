// Test for strong host mode functionality
// Tests verify:
// 1. Strong host mode with correct localAddr succeeds
// 2. Strong host mode with invalid localAddr (non-routable IP) fails

ctx, cancel = context.WithTimeout(context.New(), time.ParseDuration("10s")~)

// ============================================
// Test 1: Correct localAddr - should succeed
// ============================================
println("[TEST 1] Testing correct localAddr (127.0.0.1)...")
mitmPort1 = os.GetRandomAvailableTCPPort()
connChan1 = make(chan any)

go func {
    defer func {
        err = recover()
    }
    err = mitm.Start(mitmPort1,
        mitm.extraIncomingConnChanWithStrongLocalHost("127.0.0.1", connChan1),
        mitm.context(ctx)
    )
}

sleep(0.1)

// Create a local HTTP server
targetPort1 = os.GetRandomAvailableTCPPort()
go func {
    defer func {
        err = recover()
    }
    err = httpserver.Serve("127.0.0.1", targetPort1, 
        httpserver.handler((rsp, req) => {
            rsp.WriteHeader(200)
            rsp.Write("OK")
        }),
        httpserver.context(ctx)
    )
}

sleep(0.1)

// Forward connection through MITM
tcpPort1 = os.GetRandomAvailableTCPPort()
go func {
    defer func {
        err = recover()
    }
    err = tcp.Serve("127.0.0.1", tcpPort1, 
        tcp.serverCallback((conn) => {
            connChan1 <- conn
        }), 
        tcp.serverContext(ctx)
    )
}

sleep(0.1)

// Send request
conn1, err = tcp.Connect("127.0.0.1", tcpPort1)
if err != nil {
    die(f"Test 1: tcp.Connect failed: ${err}")
}

httpReq1 = f"GET / HTTP/1.1\r\nHost: 127.0.0.1:{targetPort1}\r\nConnection: close\r\n\r\n"
err = conn1.Send(httpReq1)
if err != nil {
    die(f"Test 1: conn.Send failed: ${err}")
}

response1, err = conn1.RecvTimeout(1)
if err != nil {
    die(f"Test 1: Failed to receive response: ${err}")
}

conn1.Close()

// Assert: Request should succeed with correct localAddr
assert len(response1) > 0, "Test 1: Response should not be empty"
assert str.Contains(string(response1), "HTTP/1.1"), "Test 1: Response should contain HTTP status"

println("[TEST 1] ✓ Passed: Correct localAddr succeeds")

// ============================================
// Test 2: Invalid localAddr (non-routable IP) - should fail
// ============================================
println("[TEST 2] Testing invalid localAddr (non-routable IP 192.0.2.1)...")
mitmPort2 = os.GetRandomAvailableTCPPort()
connChan2 = make(chan any)
dialError2 = false

go func {
    defer func {
        err = recover()
    }
    err = mitm.Start(mitmPort2,
        mitm.extraIncomingConnChanWithStrongLocalHost("192.0.2.1", connChan2), // Invalid: non-routable IP
        mitm.context(ctx)
    )
}

sleep(0.1)

targetPort2 = os.GetRandomAvailableTCPPort()
go func {
    defer func {
        err = recover()
    }
    err = httpserver.Serve("127.0.0.1", targetPort2, 
        httpserver.handler((rsp, req) => {
            rsp.WriteHeader(200)
            rsp.Write("OK")
        }),
        httpserver.context(ctx)
    )
}

sleep(0.1)

tcpPort2 = os.GetRandomAvailableTCPPort()
go func {
    defer func {
        err = recover()
    }
    err = tcp.Serve("127.0.0.1", tcpPort2, 
        tcp.serverCallback((conn) => {
            connChan2 <- conn
        }), 
        tcp.serverContext(ctx)
    )
}

sleep(0.1)

conn2, err = tcp.Connect("127.0.0.1", tcpPort2)
if err != nil {
    die(f"Test 2: tcp.Connect failed: ${err}")
}

httpReq2 = f"GET / HTTP/1.1\r\nHost: 127.0.0.1:{targetPort2}\r\nConnection: close\r\n\r\n"
err = conn2.Send(httpReq2)
if err != nil {
    die(f"Test 2: conn.Send failed: ${err}")
}

response2, err = conn2.RecvTimeout(1)
if err != nil {
    dialError2 = true
    println(f"[TEST 2] Expected error occurred: ${err}")
} else {
    println(f"[TEST 2] Response received: {len(response2)} bytes")
}

conn2.Close()

// Assert: Non-routable IP as localAddr should fail or produce error
// If strong host mode works correctly, binding to 192.0.2.1 should fail
// because this IP is not available on the local machine
// However, some systems may allow binding even if the IP is not available,
// so we check if the response contains an error or if dial failed
hasError = dialError2
if !hasError && len(response2) > 0 {
    // Check if response contains error indicators
    responseStr = string(response2)
    hasError = str.Contains(responseStr, "500") || str.Contains(responseStr, "502") || str.Contains(responseStr, "503") || str.Contains(responseStr, "504") || str.Contains(responseStr, "error") || str.Contains(responseStr, "Error")
}
assert hasError, "Test 2: Dial should fail or produce error with invalid localAddr (non-routable IP 192.0.2.1) - strong host mode should prevent binding to unavailable IP"

println("[TEST 2] ✓ Passed: Invalid localAddr (non-routable IP) fails as expected")

// Cleanup
cancel()
sleep(0.1)

println("\n[TEST] ✓ All tests passed!")
println("[TEST] ✓ Strong host mode functionality verified:")
println("  - Correct localAddr: Succeeds")
println("  - Invalid localAddr (non-routable IP): Fails as expected")
