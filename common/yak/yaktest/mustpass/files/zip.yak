raw = zip.CompressRaw({
    "a.txt": "Content in a.txt",
    "b.txt": "Content in b.txt",
    "test.log": "ERROR: test error\nINFO: test info\nDEBUG: test debug",
    "config.json": `{"name": "test", "port": 8080}`,
    "src/main.yak": "func main() {\n    println(\"hello\")\n}",
})~

a = yakit.GetHomeTempDir()

fileName = f"${str.RandStr(10)}.zip"
baseFile = file.Join(a, fileName)
println(baseFile)
file.Save(baseFile, raw)

defer file.Remove(baseFile)

// Test basic Recursive functionality
count=0
files = []
zip.Recursive(baseFile, (dir, path, info) => {
    count++
    if dir {
        return
    }
    files = append(files, path)
})
println(count)
println(files)
assert "a.txt" in files
assert "b.txt" in files
assert count >= 2

// Test RecursiveFromRaw
count = 0
files = []
rawFile = file.ReadFile(baseFile)~
zip.RecursiveFromRaw(rawFile, (dir, path, info) => {
    count++
    if dir {
        return
    }
    files = append(files, path)
})
println(count)
println(files)
assert "a.txt" in files
assert "b.txt" in files
assert count >= 2

// Test GrepRegexp
println("\n=== Testing GrepRegexp ===")
grepResults = zip.GrepRegexp(baseFile, "ERROR.*")~
assert len(grepResults) > 0, "should find ERROR pattern"
println("GrepRegexp found:", len(grepResults), "results")
for result in grepResults {
    println("  ", result.FileName, ":", result.LineNumber, "-", result.Line)
    assert result.FileName == "test.log"
}

// Test GrepSubString with case sensitivity
println("\n=== Testing GrepSubString ===")
grepResults = zip.GrepSubString(baseFile, "Content", zip.grepCaseSensitive())~
assert len(grepResults) >= 2, "should find 'Content' in at least 2 files"
println("GrepSubString found:", len(grepResults), "results")

// Test GrepSubString with limit
grepResults = zip.GrepSubString(baseFile, "test", zip.grepLimit(2))~
assert len(grepResults) <= 2, "should respect limit"
println("GrepSubString with limit found:", len(grepResults), "results")

// Test GrepRawRegexp with context
println("\n=== Testing GrepRawRegexp with context ===")
grepResults = zip.GrepRawRegexp(rawFile, "ERROR", zip.grepContextLine(1))~
assert len(grepResults) > 0, "should find ERROR"
for result in grepResults {
    println("File:", result.FileName, "Line:", result.LineNumber)
    println("Match:", result.Line)
    if len(result.ContextAfter) > 0 {
        println("Context after:", result.ContextAfter)
    }
}

// Test GrepRawSubString
println("\n=== Testing GrepRawSubString ===")
grepResults = zip.GrepRawSubString(rawFile, "info")~
assert len(grepResults) > 0, "should find 'info' (case insensitive)"
println("GrepRawSubString found:", len(grepResults), "results")

// Test ExtractFile
println("\n=== Testing ExtractFile ===")
content = zip.ExtractFile(baseFile, "a.txt")~
assert content == "Content in a.txt", "extracted content should match"
println("ExtractFile success:", content)

// Test ExtractFile with path
content = zip.ExtractFile(baseFile, "src/main.yak")~
assert str.Contains(content, "func main"), "should contain function definition"
println("ExtractFile with path success")

// Test ExtractFileFromRaw
println("\n=== Testing ExtractFileFromRaw ===")
content = zip.ExtractFileFromRaw(rawFile, "b.txt")~
assert content == "Content in b.txt", "extracted content should match"
println("ExtractFileFromRaw success:", content)

// Test ExtractFiles
println("\n=== Testing ExtractFiles ===")
results = zip.ExtractFiles(baseFile, ["a.txt", "b.txt", "config.json"])~
assert len(results) == 3, "should extract 3 files"
for result in results {
    assert result.Error == nil, sprintf("extract %s should not have error", result.FileName)
    assert len(result.Content) > 0, "content should not be empty"
    println("Extracted:", result.FileName, "-", len(result.Content), "bytes")
}

// Test ExtractFilesFromRaw
println("\n=== Testing ExtractFilesFromRaw ===")
results = zip.ExtractFilesFromRaw(rawFile, ["test.log", "config.json"])~
assert len(results) == 2, "should extract 2 files"
for result in results {
    assert result.Error == nil, sprintf("extract %s should not have error", result.FileName)
    println("Extracted from raw:", result.FileName, "-", len(result.Content), "bytes")
}

// Test ExtractByPattern
println("\n=== Testing ExtractByPattern ===")
results = zip.ExtractByPattern(baseFile, "*.txt")~
assert len(results) >= 2, "should extract at least 2 .txt files"
println("ExtractByPattern (*.txt) found:", len(results), "files")
for result in results {
    assert str.HasSuffix(result.FileName, ".txt") || str.Contains(result.FileName, ".txt"), "should be .txt file"
    println("  ", result.FileName)
}

// Test ExtractByPattern with wildcard
results = zip.ExtractByPattern(baseFile, "*")~
assert len(results) >= 5, "should extract all files"
println("ExtractByPattern (*) found:", len(results), "files")

// Test ExtractByPatternFromRaw
println("\n=== Testing ExtractByPatternFromRaw ===")
results = zip.ExtractByPatternFromRaw(rawFile, "*.json")~
assert len(results) >= 1, "should extract at least 1 .json file"
for result in results {
    assert str.HasSuffix(result.FileName, ".json"), "should be .json file"
    println("Extracted JSON:", result.FileName)
}

// Test extract non-existent file
println("\n=== Testing error handling ===")
try {
    content = zip.ExtractFile(baseFile, "nonexistent.txt")~
    assert false, "should fail when extracting non-existent file"
} catch err {
    println("Expected error for non-existent file:", err)
}

// Test GrepPath functionality
println("\n=== Testing GrepPath ===")

// Create a more complex structure for path testing
complexRaw = zip.CompressRaw({
    "src/main.go": "package main",
    "src/utils/helper.go": "package utils",
    "src/api/handler.go": "package api",
    "test/main_test.go": "package main",
    "test/utils_test.go": "package utils",
    "vendor/lib.go": "package vendor",
    "docs/README.md": "# README",
    "config.json": "{}",
})~

complexFile = file.Join(a, f"${str.RandStr(10)}_complex.zip")
file.Save(complexFile, complexRaw)
defer file.Remove(complexFile)

// Test GrepPathRegexp - search for .go files
results = zip.GrepPathRegexp(complexFile, `\.go$`)~
assert len(results) >= 5, f"should find at least 5 .go files, found ${len(results)}"
println("Found", len(results), ".go files")
for r in results {
    assert str.HasSuffix(r.FileName, ".go"), "should end with .go"
}

// Test GrepPathSubString - case insensitive
results = zip.GrepPathSubString(complexFile, "test")~
assert len(results) >= 2, "should find at least 2 files with 'test'"
println("Found", len(results), "files with 'test'")

// Test GrepPathSubString - case sensitive
results = zip.GrepPathSubString(complexFile, "TEST", zip.grepCaseSensitive())~
println("Found", len(results), "files with 'TEST' (case sensitive)")

// Test path filtering with include
println("\n=== Testing Path Filtering ===")

// Include only src/ directory
results = zip.GrepSubString(complexFile, "package", 
    zip.grepIncludePathSubString("src/"))~
assert len(results) >= 3, "should find at least 3 files in src/"
println("Found", len(results), "matches in src/")
for r in results {
    assert str.HasPrefix(r.FileName, "src/"), f"${r.FileName} should be in src/"
}

// Exclude test and vendor directories
results = zip.GrepSubString(complexFile, "package",
    zip.grepExcludePathSubString("test", "vendor"))~
println("Found", len(results), "matches excluding test and vendor")
for r in results {
    assert !str.Contains(r.FileName, "test"), f"${r.FileName} should not contain test"
    assert !str.Contains(r.FileName, "vendor"), f"${r.FileName} should not contain vendor"
}

// Include only .go files using regexp
results = zip.GrepSubString(complexFile, "package",
    zip.grepIncludePathRegexp(`\.go$`))~
assert len(results) >= 5, "should find at least 5 .go files"
println("Found", len(results), "matches in .go files")
for r in results {
    assert str.HasSuffix(r.FileName, ".go"), f"${r.FileName} should end with .go"
}

// Exclude test files using regexp
results = zip.GrepSubString(complexFile, "package",
    zip.grepExcludePathRegexp(`_test\.go$`))~
println("Found", len(results), "matches excluding test files")
for r in results {
    assert !str.Contains(r.FileName, "_test.go"), f"${r.FileName} should not be a test file"
}

// Combined filters - only src/ .go files, excluding test
results = zip.GrepSubString(complexFile, "package",
    zip.grepIncludePathSubString("src/"),
    zip.grepIncludePathRegexp(`\.go$`),
    zip.grepExcludePathRegexp(`_test\.go$`))~
assert len(results) >= 3, "should find at least 3 files"
println("Found", len(results), "matches with combined filters")
for r in results {
    assert str.HasPrefix(r.FileName, "src/"), f"${r.FileName} should be in src/"
    assert str.HasSuffix(r.FileName, ".go"), f"${r.FileName} should end with .go"
}

// Test ZipGrepSearcher with path features
println("\n=== Testing ZipGrepSearcher Path Features ===")

searcher = zip.NewGrepSearcher(complexFile)~

// GrepPathRegexp
pathResults = searcher.GrepPathRegexp(`\.go$`)~
assert len(pathResults) >= 5, "searcher should find .go files"
println("Searcher found", len(pathResults), ".go files")

// GrepPathSubString
pathResults = searcher.GrepPathSubString("src")~
assert len(pathResults) >= 3, "searcher should find files with 'src'"
println("Searcher found", len(pathResults), "files with 'src'")

// GrepSubString with path filters
contentResults = searcher.GrepSubString("package",
    zip.grepIncludePathSubString("src/"),
    zip.grepExcludePathSubString("vendor"))~
assert len(contentResults) >= 3, "searcher should find matches in src/"
println("Searcher found", len(contentResults), "matches in src/ (excluding vendor)")

// Test that path search results have correct properties
println("\n=== Testing GrepPath Result Properties ===")
pathResults = zip.GrepPathSubString(complexFile, ".go")~
assert len(pathResults) >= 1, "should have path results"
for r in pathResults {
    assert r.LineNumber == 0, "path search should have LineNumber=0"
    assert r.Line == r.FileName, "path search Line should equal FileName"
    assert str.HasPrefix(r.ScoreMethod, "path_"), f"ScoreMethod should start with 'path_', got ${r.ScoreMethod}"
    println(f"Path result: ${r.FileName} (Score: ${r.Score}, Method: ${r.ScoreMethod})")
}

println("\n=== All zip tests passed! ===")


