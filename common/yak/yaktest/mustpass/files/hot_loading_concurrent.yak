yakit.AutoInitYakit()

start = time.Now().Unix()// è®°å½•å¼€å§‹æ—¶é—´ æ—¶é—´æˆ³

Hot_Loading_Func = cli.Text(
    "Hot_Loading_Func", 
    cli.setVerboseName("æ–¹æ³•"), 
    cli.setDefault("beforeRequest = (req) => {\n\n\n\n\n\n\n\n\n   println(\"è¿™ä¸ªæ˜¯æµ‹è¯•è¾“å‡º\")    \nreturn req\n}"),
)

cli.check()

info = {
    "Include_Key_Word":[
        {
        "Include_Key_Word_Way":"123",
        "Place":false,
        "Discard_Or_Save":"1111"
        }
    ]
    
}

infoMap = make(map[string]any)
for k, v := range info {
    infoMap[string(k)] = v
}

/*
    é€šè¿‡ç±»å‹åˆ¤æ–­å­˜åœ¨é”®å
*/
mapkeyExist = (v) =>{
        //åˆ¤æ–­è·¯å¾„å­˜åœ¨
    if !string(type(v)) {
        // yakit.StatusCard("æ²¡è¿™ä¸ªé”®å€¼å¯¹ï¼š",v)
        return
    }
    return v
}

/*
    é¿å…å¹¶å‘è¯»å†™map
    è®¾ç½®mapè¯»å†™é”
    mapSync
*/
mapSync = sync.NewLock()
Hot_Loading_FuncSync = sync.NewLock()

getMap = (key) => {
    mapSync.Lock()
    defer mapSync.Unlock()
    v = json.Find(infoMap, "$."+key)
    if !(mapkeyExist(v)){
        //ä¸å­˜åœ¨é”®å
        return error("ä¸å­˜åœ¨é”®å")
    }
    return v
}

/*
    é€šè¿‡jsonä¿®æ”¹å†…å®¹
*/
setMap = (key,value) => {
    mapSync.Lock()
    defer mapSync.Unlock()
    if !(mapkeyExist(json.Find(infoMap, "$."+key))){
        //ä¸å­˜åœ¨é”®å
        return error("ä¸å­˜åœ¨é”®å")
    }
    infoMap = json.ReplaceAll(infoMap, "$."+key, value)
}

totalTasks := 20
maxConcurrency := 30 // æœ€å¤§å¹¶å‘æ•°

completedTasksLock = sync.NewLock()
completedTasks := 0

// åˆ›å»º SizedWaitGroup æ¥æ§åˆ¶å¹¶å‘åº¦
wg = sync.NewSizedWaitGroup(maxConcurrency)

println(sprintf("ğŸš€ å¼€å§‹å¹¶å‘æ‰§è¡Œ %d ä¸ªä»»åŠ¡ï¼Œæœ€å¤§å¹¶å‘æ•°ï¼š%d\n", totalTasks, maxConcurrency))

// å¹¶å‘å¯åŠ¨æ‰€æœ‰ä»»åŠ¡
for taskID := 1; taskID <= totalTasks; taskID++ {
    id = taskID
    wg.Add()
    go func(taskIdx) {
        defer wg.Done()
        println(sprintf("ä»»åŠ¡ %d å¼€å§‹\n", taskIdx))
        
        // æ¨¡æ‹Ÿä»»åŠ¡è€—æ—¶
        Hot_Loading_FuncSync.Lock()
        defer Hot_Loading_FuncSync.Unlock()
        // ä¿®å¤ï¼šé¿å…å¹¶å‘è¯»å†™
        // æ‰§è¡Œ beforeRequest
        err := eval(Hot_Loading_Func)
        assert err == nil, sprintf("eval failed for task %d: %v", taskIdx, err)
        // è°ƒç”¨ beforeRequest é‡æ–°èµ‹å€¼æ–°åŒ…
        // println(Hot_Loading_Func)
        pack = beforeRequest("123")
        assert pack != nil, sprintf("beforeRequest returned nil for task %d", taskIdx)
        assert pack == "123", sprintf("beforeRequest should return input for task %d", taskIdx)
        
        // ä½¿ç”¨é”ä¿æŠ¤ completedTasks çš„å¹¶å‘è®¿é—®
        completedTasksLock.Lock()
        completedTasks++
        completedTasksLock.Unlock()
        
        println(sprintf("ä»»åŠ¡ %d å®Œæˆ\n", taskIdx))
    }(id)
}

// ç­‰å¾…æ‰€æœ‰ä»»åŠ¡å®Œæˆ
wg.Wait()

println("æ‰€æœ‰ä»»åŠ¡å®Œæˆ")
assert completedTasks == totalTasks, sprintf("expected %d completed tasks, got %d", totalTasks, completedTasks)

// éªŒè¯ getMap å’Œ setMap å‡½æ•°æ­£å¸¸å·¥ä½œ
result = getMap("Include_Key_Word")
assert result != nil, "getMap should return value for existing key"
assert len(result) > 0, "getMap result should not be empty"

// éªŒè¯ mapSync é”æ­£å¸¸å·¥ä½œï¼ˆæ²¡æœ‰å´©æºƒè¯´æ˜é”æœºåˆ¶æ­£å¸¸ï¼‰
mapSync.Lock()
mapSync.Unlock()
assert true, "mapSync lock/unlock should work without panic"

// éªŒè¯ Hot_Loading_FuncSync é”æ­£å¸¸å·¥ä½œ
Hot_Loading_FuncSync.Lock()
Hot_Loading_FuncSync.Unlock()
assert true, "Hot_Loading_FuncSync lock/unlock should work without panic"

elapsed := time.Since(time.Unix(start, 0))
assert elapsed > 0, "elapsed time should be greater than 0"
yakit.StatusCard("ç”¨æ—¶ï¼š", elapsed)
println(sprintf("æµ‹è¯•é€šè¿‡ï¼šæ‰€æœ‰ %d ä¸ªä»»åŠ¡å®Œæˆï¼Œç”¨æ—¶ %v", totalTasks, elapsed))

