// 测试 L2TP 服务器和客户端功能
println("Testing L2TP Server and Client Functionality")

// 测试1: 启动和停止 L2TP 服务器
port = os.GetRandomAvailableUDPPort()
println(sprintf("Starting L2TP server on port %d", port))

server, err = l2tp.Serve(
    l2tp.host("0.0.0.0"),
    l2tp.port(port),
)
if err != nil {
    die(sprintf("Failed to start L2TP server: %v", err))
}
assert server != nil, "Server should not be nil"

sleep(0.5) // 等待服务器启动

err = server.Stop()
if err != nil {
    die(sprintf("Failed to stop server: %v", err))
}
println("✓ Test 1: Basic server start/stop passed")


// 测试2: 带认证和配置的服务器
port2 = os.GetRandomAvailableUDPPort()
println(sprintf("Starting L2TP server with auth on port %d", port2))

authCalled = false
server2, err = l2tp.Serve(
    l2tp.host("0.0.0.0"),
    l2tp.port(port2),
    l2tp.hostname("test-server"),
    l2tp.auth((username, password) => {
        println(sprintf("Auth callback: user=%s, pass=%s", username, password))
        authCalled = true
        return username == "testuser" && password == "testpass"
    }),
    l2tp.ipPool("192.168.100.10", "192.168.100.100"),
)
if err != nil {
    die(sprintf("Failed to start L2TP server with auth: %v", err))
}
assert server2 != nil, "Server should not be nil"

sleep(0.5)

err = server2.Stop()
if err != nil {
    die(sprintf("Failed to stop server2: %v", err))
}
println("✓ Test 2: Server with hostname and IP pool passed")


// 测试3: 服务器端数据包回调功能
port3 = os.GetRandomAvailableUDPPort()
println(sprintf("Starting L2TP server with packet callback on port %d", port3))

serverPacketReceived = false
server3, err = l2tp.Serve(
    l2tp.host("0.0.0.0"),
    l2tp.port(port3),
    l2tp.callback((data) => {
        println(sprintf("Server received packet: %d bytes", len(data)))
        serverPacketReceived = true
    }),
)
if err != nil {
    die(sprintf("Failed to start L2TP server with packet callback: %v", err))
}
assert server3 != nil, "Server should not be nil"

sleep(0.5)

err = server3.Stop()
if err != nil {
    die(sprintf("Failed to stop server3: %v", err))
}
println("✓ Test 3: Server packet callback configuration passed")


// 测试4: 客户端连接到服务器
port4 = os.GetRandomAvailableUDPPort()
println(sprintf("Starting L2TP server for client test on port %d", port4))

clientPacketReceived = false
server4, err = l2tp.Serve(
    l2tp.host("0.0.0.0"),
    l2tp.port(port4),
    l2tp.auth((username, password) => {
        println(sprintf("Server auth: user=%s, pass=%s", username, password))
        return username == "testclient" && password == "clientpass"
    }),
    l2tp.callback((data) => {
        println(sprintf("Server received packet from client: %d bytes", len(data)))
        clientPacketReceived = true
    }),
)
if err != nil {
    die(sprintf("Failed to start L2TP server for client test: %v", err))
}
assert server4 != nil, "Server should not be nil"

sleep(0.5)

// 创建客户端连接
println("Creating L2TP client connection...")
client, err = l2tp.Connect("127.0.0.1", port4,
    l2tp.clientAuth("testclient", "clientpass"),
)
if err != nil {
    server4.Stop()
    die(sprintf("Failed to create L2TP client: %v", err))
}
assert client != nil, "Client should not be nil"

sleep(1.0) // 等待连接建立

// 客户端注入数据包，服务器应该能收到
println("Client injecting test packet...")
testPacket = []byte{0x45, 0x00, 0x00, 0x28, 0xab, 0xcd, 0x00, 0x00, 0x40, 0x11, 0x00, 0x00, 0xc0, 0xa8, 0x64, 0x0a, 0xc0, 0xa8, 0x64, 0x01}
err = client.InjectPacket(testPacket)
if err != nil {
    println(sprintf("Client inject packet warning: %v", err))
}

sleep(1.0) // 等待数据包传输

// 断开客户端
println("Disconnecting client...")
err = client.Close()
if err != nil {
    println(sprintf("Warning: Failed to close client: %v", err))
}

err = server4.Stop()
if err != nil {
    die(sprintf("Failed to stop server4: %v", err))
}

println("✓ Test 4: Client connection and packet injection passed")


// 测试5: 客户端接收服务器数据包回调
port5 = os.GetRandomAvailableUDPPort()
println(sprintf("Starting L2TP server for client callback test on port %d", port5))

server5, err = l2tp.Serve(
    l2tp.host("0.0.0.0"),
    l2tp.port(port5),
    l2tp.auth((username, password) => {
        return username == "test" && password == "test"
    }),
)
if err != nil {
    die(sprintf("Failed to start L2TP server for callback test: %v", err))
}
assert server5 != nil, "Server should not be nil"

sleep(0.5)

// 创建带回调的客户端
clientCallbackReceived = false
println("Creating L2TP client with packet callback...")
client2, err = l2tp.Connect("127.0.0.1", port5,
    l2tp.clientAuth("test", "test"),
    l2tp.clientCallback((data) => {
        println(sprintf("Client received packet from server: %d bytes", len(data)))
        clientCallbackReceived = true
    }),
)
if err != nil {
    server5.Stop()
    die(sprintf("Failed to create L2TP client with callback: %v", err))
}
assert client2 != nil, "Client should not be nil"

sleep(1.0) // 等待连接建立

// 验证客户端 ID 信息
tunnelID = client2.GetTunnelID()
peerTunnelID = client2.GetPeerTunnelID()
sessionID = client2.GetSessionID()
peerSessionID = client2.GetPeerSessionID()

println(sprintf("Client tunnel ID: %d, Peer tunnel ID: %d", tunnelID, peerTunnelID))
println(sprintf("Client session ID: %d, Peer session ID: %d", sessionID, peerSessionID))

assert tunnelID > 0, "Tunnel ID should be greater than 0"
assert peerTunnelID > 0, "Peer tunnel ID should be greater than 0"
assert sessionID > 0, "Session ID should be greater than 0"
assert peerSessionID > 0, "Peer session ID should be greater than 0"

// 清理客户端2
err = client2.Close()
if err != nil {
    println(sprintf("Warning: Failed to close client2: %v", err))
}

err = server5.Stop()
if err != nil {
    die(sprintf("Failed to stop server5: %v", err))
}

println("✓ Test 5: Client callback and ID verification passed")


// 测试6: 客户端超时配置
port6 = os.GetRandomAvailableUDPPort()
println(sprintf("Starting L2TP server for timeout test on port %d", port6))

server6, err = l2tp.Serve(
    l2tp.host("0.0.0.0"),
    l2tp.port(port6),
    l2tp.auth((username, password) => {
        return username == "timeout" && password == "test"
    }),
)
if err != nil {
    die(sprintf("Failed to start L2TP server for timeout test: %v", err))
}
assert server6 != nil, "Server should not be nil"

sleep(0.5)

// 创建带超时配置的客户端
println("Creating L2TP client with custom timeout...")
client3, err = l2tp.Connect("127.0.0.1", port6,
    l2tp.clientAuth("timeout", "test"),
    l2tp.clientTimeout(5.0),
)
if err != nil {
    server6.Stop()
    die(sprintf("Failed to create L2TP client with timeout: %v", err))
}
assert client3 != nil, "Client should not be nil"

sleep(1.0) // 等待连接建立

// 清理客户端3
err = client3.Close()
if err != nil {
    println(sprintf("Warning: Failed to close client3: %v", err))
}

err = server6.Stop()
if err != nil {
    die(sprintf("Failed to stop server6: %v", err))
}

println("✓ Test 6: Client timeout configuration passed")


// 测试7: 多客户端并发连接
port7 = os.GetRandomAvailableUDPPort()
println(sprintf("Starting L2TP server for multi-client test on port %d", port7))

server7, err = l2tp.Serve(
    l2tp.host("0.0.0.0"),
    l2tp.port(port7),
    l2tp.auth((username, password) => {
        return password == "multi"
    }),
)
if err != nil {
    die(sprintf("Failed to start L2TP server for multi-client test: %v", err))
}
assert server7 != nil, "Server should not be nil"

sleep(0.5)

// 创建多个客户端
println("Creating multiple L2TP clients...")
clients = []

for i = 0; i < 3; i++ {
    clientName = sprintf("client%d", i)
    println(sprintf("Creating client: %s", clientName))
    
    c, err = l2tp.Connect("127.0.0.1", port7,
        l2tp.clientAuth(clientName, "multi"),
    )
    if err != nil {
        // 清理已创建的客户端
        for j = 0; j < len(clients); j++ {
            clients[j].Close()
        }
        server7.Stop()
        die(sprintf("Failed to create client %s: %v", clientName, err))
    }
    assert c != nil, sprintf("Client %s should not be nil", clientName)
    clients = append(clients, c)
    
    sleep(0.5) // 等待每个客户端连接建立
}

println(sprintf("Successfully created %d concurrent clients", len(clients)))

// 验证每个客户端都有独立的隧道和会话
tunnelIDs = []
sessionIDs = []
for i = 0; i < len(clients); i++ {
    tid = clients[i].GetTunnelID()
    sid = clients[i].GetSessionID()
    println(sprintf("Client %d: Tunnel ID=%d, Session ID=%d", i, tid, sid))
    
    // 检查 ID 是否已存在（应该都是唯一的）
    for j = 0; j < len(tunnelIDs); j++ {
        if tunnelIDs[j] == tid {
            die(sprintf("Duplicate tunnel ID detected: %d", tid))
        }
    }
    tunnelIDs = append(tunnelIDs, tid)
    sessionIDs = append(sessionIDs, sid)
}

// 每个客户端注入一个测试数据包
println("Each client injecting test packet...")
for i = 0; i < len(clients); i++ {
    packet = []byte{0x45, 0x00, 0x00, 0x1c, 0x00, byte(i), 0x00, 0x00, 0x40, 0x01}
    err = clients[i].InjectPacket(packet)
    if err != nil {
        println(sprintf("Client %d inject warning: %v", i, err))
    }
}

sleep(1.0) // 等待数据包传输

// 清理所有客户端
println("Closing all clients...")
for i = 0; i < len(clients); i++ {
    err = clients[i].Close()
    if err != nil {
        println(sprintf("Warning: Failed to close client %d: %v", i, err))
    }
}

err = server7.Stop()
if err != nil {
    die(sprintf("Failed to stop server7: %v", err))
}

println("✓ Test 7: Multiple concurrent clients passed")


// 测试8: 客户端认证失败测试
port8 = os.GetRandomAvailableUDPPort()
println(sprintf("Starting L2TP server for auth failure test on port %d", port8))

authFailureDetected = false
server8, err = l2tp.Serve(
    l2tp.host("0.0.0.0"),
    l2tp.port(port8),
    l2tp.auth((username, password) => {
        println(sprintf("Auth attempt: user=%s, pass=%s", username, password))
        if username == "wronguser" {
            authFailureDetected = true
            return false
        }
        return username == "rightuser" && password == "rightpass"
    }),
)
if err != nil {
    die(sprintf("Failed to start L2TP server for auth failure test: %v", err))
}
assert server8 != nil, "Server should not be nil"

sleep(0.5)

// 测试正确的认证
println("Testing successful authentication...")
client4, err = l2tp.Connect("127.0.0.1", port8,
    l2tp.clientAuth("rightuser", "rightpass"),
    l2tp.clientTimeout(5.0),
)
if err != nil {
    server8.Stop()
    die(sprintf("Failed to connect with valid credentials: %v", err))
}
assert client4 != nil, "Client with valid credentials should not be nil"

sleep(1.0)

// 验证连接成功
tid = client4.GetTunnelID()
assert tid > 0, "Valid client should have tunnel ID"

err = client4.Close()
if err != nil {
    println(sprintf("Warning: Failed to close client4: %v", err))
}

println("✓ Test 8a: Successful authentication passed")

// 注意: 认证失败的客户端测试可能会导致连接超时，这是预期行为
// 我们主要测试成功的认证流程

err = server8.Stop()
if err != nil {
    die(sprintf("Failed to stop server8: %v", err))
}

println("✓ Test 8: Client authentication tests passed")


// 测试9: 客户端数据包双向传输
port9 = os.GetRandomAvailableUDPPort()
println(sprintf("Starting L2TP server for bidirectional test on port %d", port9))

serverReceivedCount = 0
clientReceivedCount = 0

server9, err = l2tp.Serve(
    l2tp.host("0.0.0.0"),
    l2tp.port(port9),
    l2tp.auth((username, password) => {
        return username == "bidirectional" && password == "test"
    }),
    l2tp.callback((data) => {
        println(sprintf("Server received packet: %d bytes", len(data)))
        serverReceivedCount++
    }),
)
if err != nil {
    die(sprintf("Failed to start L2TP server for bidirectional test: %v", err))
}
assert server9 != nil, "Server should not be nil"

sleep(0.5)

// 创建带回调的客户端
println("Creating L2TP client for bidirectional test...")
client5, err = l2tp.Connect("127.0.0.1", port9,
    l2tp.clientAuth("bidirectional", "test"),
    l2tp.clientCallback((data) => {
        println(sprintf("Client received packet: %d bytes", len(data)))
        clientReceivedCount++
    }),
)
if err != nil {
    server9.Stop()
    die(sprintf("Failed to create L2TP client for bidirectional test: %v", err))
}
assert client5 != nil, "Client should not be nil"

sleep(1.0) // 等待连接建立

// 客户端发送多个数据包
println("Client sending multiple packets...")
for i = 0; i < 5; i++ {
    // 构造简单的 IP 数据包头
    packet = []byte{
        0x45, 0x00, 0x00, 0x20,  // IP version, IHL, TOS, Total Length
        byte(i >> 8), byte(i),   // Identification
        0x00, 0x00,              // Flags, Fragment Offset
        0x40, 0x11,              // TTL, Protocol (UDP)
        0x00, 0x00,              // Header Checksum
        0xc0, 0xa8, 0x01, 0x0a,  // Source IP
        0xc0, 0xa8, 0x01, 0x01,  // Dest IP
        // UDP header would follow
        0x12, 0x34, 0x56, 0x78,
        0x00, 0x08, 0x00, 0x00,
    }
    
    err = client5.InjectPacket(packet)
    if err != nil {
        println(sprintf("Warning: Packet %d injection failed: %v", i, err))
    }
    sleep(0.1)
}

sleep(1.0) // 等待数据包传输

println(sprintf("Server received %d packets", serverReceivedCount))
println(sprintf("Client received %d packets", clientReceivedCount))

// 验证服务器至少收到了一些包
assert serverReceivedCount > 0, "Server should have received at least some packets"

// 清理
err = client5.Close()
if err != nil {
    println(sprintf("Warning: Failed to close client5: %v", err))
}

err = server9.Stop()
if err != nil {
    die(sprintf("Failed to stop server9: %v", err))
}

println("✓ Test 9: Bidirectional packet transmission passed")


println("=" * 50)
println("All L2TP tests passed successfully!")
println(sprintf("Total tests: 9 (including %d client tests)", 6))
println("=" * 50)

