// 文件权限变更检测测试
// 测试功能：权限变更事件捕获、属主变更检测
// 兼容 Windows 和 Linux 平台

// 创建临时测试文件
testFile, err = file.TempFileName("file_permission_test_*.txt")
assert err == nil, sprintf("Failed to create temp file: %v", err)
defer file.Remove(testFile)

file.Save(testFile, "Test content for permission change")

// 1. 测试权限变更检测
config = {
    "watch_paths": [file.GetDirPath(testFile)],
    "recursive": false,
    "monitor_ops": [filemonitor.OP_CHMOD, filemonitor.OP_CHOWN],
    "poll_interval": 0.2  // 轮询间隔，单位为秒（0.2秒 = 200毫秒）
}

monitor, err = filemonitor.NewMonitor(config)
assert err == nil, sprintf("Failed to create monitor: %v", err)

permissionEvents = []
monitor.SetEventCallback(func(event) {
    if event.Type == filemonitor.OP_CHMOD || event.Type == filemonitor.OP_CHOWN {
        permissionEvents = append(permissionEvents, event)
    }
})

err = monitor.Start()
assert err == nil, sprintf("Failed to start monitor: %v", err)

// 等待文件信息初始化完成（initializeFileInfo 是异步的）
// 轮询间隔是 200ms，等待 1 秒确保文件信息被初始化
sleep(1)

// 获取当前权限
currentInfo, err = file.Stat(testFile)
assert err == nil, sprintf("Failed to stat file: %v", err)
currentMode = currentInfo.Mode()
println(sprintf("Current file mode: %s (0%o)", currentInfo.Mode().String(), currentMode))

// 修改文件权限（如果可能）
// Windows 和 Linux 都支持 os.Chmod，但权限模型不同
// 在 Windows 上，使用只读/可写权限切换；在 Linux 上，使用执行权限切换
newMode = currentMode
if os.OS == "windows" {
    // Windows 上切换只读权限
    if currentMode & 0200 != 0 {
        // 如果当前有写权限，移除写权限
        newMode = currentMode &^ 0200
    } else {
        // 如果当前没有写权限，添加写权限
        newMode = currentMode | 0200
    }
} else {
    // Linux 上切换执行权限
    newMode = currentMode ^ 0100
}

println(sprintf("Attempting to change file mode from 0%o to 0%o", currentMode, newMode))
err = os.Chmod(testFile, newMode)
if err == nil {
    // 验证权限确实改变了
    afterInfo, err2 = file.Stat(testFile)
    modeChanged = false
    if err2 == nil {
        afterMode = afterInfo.Mode()
        println(sprintf("File mode after chmod: %s (0%o)", afterInfo.Mode().String(), afterMode))
        modeChanged = (afterMode != currentMode)
        if !modeChanged {
            println("Warning: File mode did not change after chmod, permission change may not be supported on this system")
        }
    }
    
    // 等待文件监控系统检测到权限变更（轮询间隔是 200ms，等待 1 秒确保检测到）
    sleep(1)
    
    println(sprintf("Total permission events captured: %d", len(permissionEvents)))
    eventIndex = 0
    for event in permissionEvents {
        println(sprintf("Event %d: Type=%s, Path=%s", eventIndex, event.Type, event.Path))
        eventIndex = eventIndex + 1
    }
    
    // 只有在权限确实改变的情况下才验证权限变更事件
    if modeChanged {
        // 验证权限变更事件
        assert len(permissionEvents) > 0, sprintf("Should capture permission change event, got %d events", len(permissionEvents))
        
        chmodEvent = nil
        for event in permissionEvents {
            if event.Type == filemonitor.OP_CHMOD && event.Path == testFile {
                chmodEvent = event
                break
            }
        }
        
        assert chmodEvent != nil, "Should have chmod event"
        assert chmodEvent.OldMode != "", "Chmod event should have old mode"
        assert chmodEvent.NewMode != "", "Chmod event should have new mode"
        assert chmodEvent.OldMode != chmodEvent.NewMode, "Chmod event old/new mode should differ"
        println(sprintf("Permission changed from %s to %s", chmodEvent.OldMode, chmodEvent.NewMode))
    } else {
        println("Skipping permission change event validation because mode did not change on this system")
    }
    
    // 恢复原权限
    os.Chmod(testFile, currentMode)
} else {
    // 如果权限变更失败（某些系统上可能不支持），跳过权限变更测试
    println(sprintf("Failed to change file permission (may not be supported on this system): %v", err))
}

monitor.Stop()

// 2. 测试权限信息记录
// 验证日志中包含权限信息
config2 = {
    "watch_paths": [file.GetDirPath(testFile)],
    "recursive": false
}

monitor2, err = filemonitor.NewMonitor(config2)
assert err == nil, sprintf("Failed to create monitor: %v", err)

logEntries = []
monitor2.SetLogCallback(func(log) {
    logEntries = append(logEntries, log)
})

err = monitor2.Start()
assert err == nil, sprintf("Failed to start monitor: %v", err)

sleep(1)

// 触发一个文件操作
file.Save(testFile, "Modified content")
sleep(1)

monitor2.Stop()

// 验证日志包含权限信息
assert len(logEntries) > 0, "Should have log entries"
for logEntry in logEntries {
    if logEntry.FilePath == testFile {
        assert logEntry.FileMode != "", "Log entry should have file mode"
        println(sprintf("File mode recorded: %s", logEntry.FileMode))
        break
    }
}

println("File permission tests passed!")
