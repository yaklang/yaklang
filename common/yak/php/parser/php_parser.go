// Code generated from java-escape by ANTLR 4.11.1. DO NOT EDIT.

package phpparser // PHPParser
import (
	"fmt"
	"strconv"
	"sync"

	"github.com/antlr/antlr4/runtime/Go/antlr/v4"
)

// Suppress unused import errors
var _ = fmt.Printf
var _ = strconv.Itoa
var _ = sync.Once{}

type PHPParser struct {
	*antlr.BaseParser
}

var phpparserParserStaticData struct {
	once                   sync.Once
	serializedATN          []int32
	literalNames           []string
	symbolicNames          []string
	ruleNames              []string
	predictionContextCache *antlr.PredictionContextCache
	atn                    *antlr.ATN
	decisionToDFA          []*antlr.DFA
}

func phpparserParserInit() {
	staticData := &phpparserParserStaticData
	staticData.literalNames = []string{
		"", "", "", "'<?xml'", "", "", "", "", "", "", "", "", "", "'?>'", "",
		"", "'/>'", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "'#['", "'abstract'",
		"'array'", "'as'", "'binary'", "", "", "'break'", "'callable'", "'case'",
		"'catch'", "'class'", "'clone'", "'const'", "'continue'", "'define'",
		"'defined'", "'declare'", "'default'", "'do'", "'real'", "'double'",
		"'echo'", "'else'", "'elseif'", "'empty'", "'enum'", "'enddeclare'",
		"'endfor'", "'endforeach'", "'endif'", "'endswitch'", "'endwhile'",
		"'eval'", "'assert'", "'die'", "'exit'", "'extends'", "'final'", "'finally'",
		"'float'", "'for'", "'foreach'", "'function'", "'global'", "'goto'",
		"'if'", "'implements'", "'import'", "'include'", "'include_once'", "'instanceof'",
		"'insteadof'", "'int8'", "'int16'", "'int64'", "", "'interface'", "'isset'",
		"'list'", "'and'", "'or'", "'xor'", "'match'", "'namespace'", "'new'",
		"'null'", "'object'", "'parent'", "'partial'", "'print'", "'private'",
		"'protected'", "'public'", "'readonly'", "'require'", "'require_once'",
		"'resource'", "'return'", "'static'", "'string'", "'switch'", "'throw'",
		"'trait'", "'try'", "'clrtypeof'", "", "'unicode'", "'unset'", "'use'",
		"'var'", "'while'", "'yield'", "'from'", "'fn'", "'ticks'", "'encoding'",
		"'strict_types'", "'__get'", "'__set'", "'__call'", "'__callstatic'",
		"'__construct'", "'__destruct'", "'__wakeup'", "'__sleep'", "'__autoload'",
		"'__isset'", "'__unset'", "'__tostring'", "'__invoke'", "'__set_state'",
		"'__clone'", "'__debuginfo'", "'__namespace__'", "'__class__'", "'__trait__'",
		"'__function__'", "'__method__'", "'__line__'", "'__file__'", "'__dir__'",
		"'<=>'", "'=>'", "'++'", "'--'", "'==='", "'!=='", "'=='", "", "'<='",
		"'>='", "'+='", "'-='", "'*='", "'**'", "'**='", "'/='", "'.='", "'%='",
		"'<<='", "'>>='", "'&='", "'|='", "'^='", "'||'", "'&&'", "'??'", "'??='",
		"'<<'", "'>>'", "'::'", "'->'", "'\\'", "'...'", "", "", "'&'", "'|'",
		"'!'", "'^'", "'+'", "'-'", "'*'", "'%'", "", "'~'", "'@'", "", "'.'",
		"", "'('", "')'", "'['", "']'", "", "'}'", "','", "':'", "';'", "",
		"'''", "'`'", "'set_include_path'",
	}
	staticData.symbolicNames = []string{
		"", "SeaWhitespace", "HtmlText", "XmlStart", "PHPStart", "HtmlScriptOpen",
		"HtmlStyleOpen", "HtmlComment", "HtmlDtd", "HtmlOpen", "Shebang", "Error",
		"XmlText", "XmlClose", "PHPStartInside", "HtmlClose", "HtmlSlashClose",
		"HtmlSlash", "HtmlEquals", "HtmlStartQuoteString", "HtmlStartDoubleQuoteString",
		"HtmlHex", "HtmlDecimal", "HtmlSpace", "HtmlName", "ErrorInside", "PHPStartInsideQuoteString",
		"HtmlEndQuoteString", "HtmlQuoteString", "ErrorHtmlQuote", "PHPStartDoubleQuoteString",
		"HtmlEndDoubleQuoteString", "HtmlDoubleQuoteString", "ErrorHtmlDoubleQuote",
		"ScriptText", "HtmlScriptClose", "PHPStartInsideScript", "StyleBody",
		"PHPEnd", "Whitespace", "MultiLineComment", "SingleLineComment", "ShellStyleComment",
		"AttributeStart", "Abstract", "Array", "As", "BinaryCast", "BoolType",
		"BooleanConstant", "Break", "Callable", "Case", "Catch", "Class", "Clone",
		"Const", "Continue", "Define", "Defined", "Declare", "Default", "Do",
		"DoubleCast", "DoubleType", "Echo", "Else", "ElseIf", "Empty", "Enum_",
		"EndDeclare", "EndFor", "EndForeach", "EndIf", "EndSwitch", "EndWhile",
		"Eval", "Assert", "Die", "Exit", "Extends", "Final", "Finally", "FloatCast",
		"For", "Foreach", "Function_", "Global", "Goto", "If", "Implements",
		"Import", "Include", "IncludeOnce", "InstanceOf", "InsteadOf", "Int8Cast",
		"Int16Cast", "Int64Type", "IntType", "Interface", "IsSet", "List", "LogicalAnd",
		"LogicalOr", "LogicalXor", "Match_", "Namespace", "New", "Null", "ObjectType",
		"Parent_", "Partial", "Print", "Private", "Protected", "Public", "Readonly",
		"Require", "RequireOnce", "Resource", "Return", "Static", "StringType",
		"Switch", "Throw", "Trait", "Try", "Typeof", "UintCast", "UnicodeCast",
		"Unset", "Use", "Var", "While", "Yield", "From", "LambdaFn", "Ticks",
		"Encoding", "StrictTypes", "Get", "Set", "Call", "CallStatic", "Constructor",
		"Destruct", "Wakeup", "Sleep", "Autoload", "IsSet__", "Unset__", "ToString__",
		"Invoke", "SetState", "Clone__", "DebugInfo", "Namespace__", "Class__",
		"Traic__", "Function__", "Method__", "Line__", "File__", "Dir__", "Spaceship",
		"DoubleArrow", "Inc", "Dec", "IsIdentical", "IsNoidentical", "IsEqual",
		"IsNotEq", "IsSmallerOrEqual", "IsGreaterOrEqual", "PlusEqual", "MinusEqual",
		"MulEqual", "Pow", "PowEqual", "DivEqual", "Concaequal", "ModEqual",
		"ShiftLeftEqual", "ShiftRightEqual", "AndEqual", "OrEqual", "XorEqual",
		"BooleanOr", "BooleanAnd", "NullCoalescing", "NullCoalescingEqual",
		"ShiftLeft", "ShiftRight", "DoubleColon", "ObjectOperator", "NamespaceSeparator",
		"Ellipsis", "Less", "Greater", "Ampersand", "Pipe", "Bang", "Caret",
		"Plus", "Minus", "Asterisk", "Percent", "Divide", "Tilde", "SuppressWarnings",
		"Dollar", "Dot", "QuestionMark", "OpenRoundBracket", "CloseRoundBracket",
		"OpenSquareBracket", "CloseSquareBracket", "OpenCurlyBracket", "CloseCurlyBracket",
		"Comma", "Colon", "SemiColon", "Eq", "Quote", "BackQuote", "Set_Include_Path",
		"VarName", "Label", "Octal", "Decimal", "Real", "Hex", "Binary", "BackQuoteString",
		"SingleQuoteString", "DoubleQuote", "StartNowDoc", "StartHereDoc", "ErrorPhp",
		"CurlyDollar", "UnicodeEscape", "StringPart", "Comment", "PHPEndSingleLineComment",
		"CommentEnd", "HereDocText", "XmlText2",
	}
	staticData.ruleNames = []string{
		"htmlDocument", "htmlDocumentElement", "inlineHtml", "htmlElement",
		"scriptText", "phpBlock", "importStatement", "topStatement", "useDeclaration",
		"useDeclarationContentList", "useDeclarationContent", "namespaceDeclaration",
		"namespaceStatement", "functionDeclaration", "classDeclaration", "classEntryType",
		"interfaceList", "typeParameterList", "typeParameterWithDefaultsList",
		"typeParameterDecl", "typeParameterWithDefaultDecl", "attributes", "attributeGroup",
		"attribute", "innerStatementList", "innerStatement", "labelStatement",
		"statement", "emptyStatement_", "blockStatement", "ifStatement", "elseIfStatement",
		"elseIfColonStatement", "elseStatement", "elseColonStatement", "whileStatement",
		"doWhileStatement", "forStatement", "forInit", "forUpdate", "switchStatement",
		"switchCaseBlock", "switchDefaultBlock", "switchBlock", "breakStatement",
		"continueStatement", "returnStatement", "expressionStatement", "unsetStatement",
		"foreachStatement", "tryCatchFinally", "catchClause", "finallyStatement",
		"throwStatement", "gotoStatement", "declareStatement", "inlineHtmlStatement",
		"declareList", "directive", "formalParameterList", "formalParameter",
		"typeHint", "globalStatement", "globalVar", "echoStatement", "staticVariableStatement",
		"classStatement", "traitAdaptations", "traitAdaptationStatement", "traitPrecedence",
		"traitAlias", "traitMethodReference", "baseCtorCall", "returnTypeDecl",
		"methodBody", "propertyModifiers", "memberModifiers", "variableInitializer",
		"identifierInitializer", "globalConstantDeclaration", "enumDeclaration",
		"enumItem", "expressionList", "parentheses", "fullyQualifiedNamespaceExpr",
		"staticClassExpr", "staticClassExprFunctionMember", "staticClassExprVariableMember",
		"memberCallKey", "indexMemberCallKey", "expression", "flexiVariable",
		"defineExpr", "variable", "include", "leftArrayCreation", "assignable",
		"arrayCreation", "arrayDestructuring", "indexedDestructItem", "keyedDestructItem",
		"lambdaFunctionExpr", "matchExpr", "matchItem", "newExpr", "assignmentOperator",
		"yieldExpression", "arrayItemList", "arrayItem", "lambdaFunctionUseVars",
		"lambdaFunctionUseVar", "qualifiedStaticTypeRef", "typeRef", "anonymousClass",
		"indirectTypeRef", "qualifiedNamespaceName", "namespaceNameList", "namespaceNameTail",
		"qualifiedNamespaceNameList", "arguments", "actualArgument", "argumentName",
		"constantInitializer", "constantString", "constant", "literalConstant",
		"numericConstant", "classConstant", "stringConstant", "string", "interpolatedStringPart",
		"chainList", "chain", "chainOrigin", "memberAccess", "functionCall",
		"functionCallName", "actualArguments", "chainBase", "keyedFieldName",
		"keyedSimpleFieldName", "keyedVariable", "squareCurlyExpression", "assignmentList",
		"assignmentListElement", "modifier", "identifier", "key", "memberModifier",
		"magicConstant", "magicMethod", "primitiveType", "castOperation",
	}
	staticData.predictionContextCache = antlr.NewPredictionContextCache()
	staticData.serializedATN = []int32{
		4, 1, 247, 2107, 2, 0, 7, 0, 2, 1, 7, 1, 2, 2, 7, 2, 2, 3, 7, 3, 2, 4,
		7, 4, 2, 5, 7, 5, 2, 6, 7, 6, 2, 7, 7, 7, 2, 8, 7, 8, 2, 9, 7, 9, 2, 10,
		7, 10, 2, 11, 7, 11, 2, 12, 7, 12, 2, 13, 7, 13, 2, 14, 7, 14, 2, 15, 7,
		15, 2, 16, 7, 16, 2, 17, 7, 17, 2, 18, 7, 18, 2, 19, 7, 19, 2, 20, 7, 20,
		2, 21, 7, 21, 2, 22, 7, 22, 2, 23, 7, 23, 2, 24, 7, 24, 2, 25, 7, 25, 2,
		26, 7, 26, 2, 27, 7, 27, 2, 28, 7, 28, 2, 29, 7, 29, 2, 30, 7, 30, 2, 31,
		7, 31, 2, 32, 7, 32, 2, 33, 7, 33, 2, 34, 7, 34, 2, 35, 7, 35, 2, 36, 7,
		36, 2, 37, 7, 37, 2, 38, 7, 38, 2, 39, 7, 39, 2, 40, 7, 40, 2, 41, 7, 41,
		2, 42, 7, 42, 2, 43, 7, 43, 2, 44, 7, 44, 2, 45, 7, 45, 2, 46, 7, 46, 2,
		47, 7, 47, 2, 48, 7, 48, 2, 49, 7, 49, 2, 50, 7, 50, 2, 51, 7, 51, 2, 52,
		7, 52, 2, 53, 7, 53, 2, 54, 7, 54, 2, 55, 7, 55, 2, 56, 7, 56, 2, 57, 7,
		57, 2, 58, 7, 58, 2, 59, 7, 59, 2, 60, 7, 60, 2, 61, 7, 61, 2, 62, 7, 62,
		2, 63, 7, 63, 2, 64, 7, 64, 2, 65, 7, 65, 2, 66, 7, 66, 2, 67, 7, 67, 2,
		68, 7, 68, 2, 69, 7, 69, 2, 70, 7, 70, 2, 71, 7, 71, 2, 72, 7, 72, 2, 73,
		7, 73, 2, 74, 7, 74, 2, 75, 7, 75, 2, 76, 7, 76, 2, 77, 7, 77, 2, 78, 7,
		78, 2, 79, 7, 79, 2, 80, 7, 80, 2, 81, 7, 81, 2, 82, 7, 82, 2, 83, 7, 83,
		2, 84, 7, 84, 2, 85, 7, 85, 2, 86, 7, 86, 2, 87, 7, 87, 2, 88, 7, 88, 2,
		89, 7, 89, 2, 90, 7, 90, 2, 91, 7, 91, 2, 92, 7, 92, 2, 93, 7, 93, 2, 94,
		7, 94, 2, 95, 7, 95, 2, 96, 7, 96, 2, 97, 7, 97, 2, 98, 7, 98, 2, 99, 7,
		99, 2, 100, 7, 100, 2, 101, 7, 101, 2, 102, 7, 102, 2, 103, 7, 103, 2,
		104, 7, 104, 2, 105, 7, 105, 2, 106, 7, 106, 2, 107, 7, 107, 2, 108, 7,
		108, 2, 109, 7, 109, 2, 110, 7, 110, 2, 111, 7, 111, 2, 112, 7, 112, 2,
		113, 7, 113, 2, 114, 7, 114, 2, 115, 7, 115, 2, 116, 7, 116, 2, 117, 7,
		117, 2, 118, 7, 118, 2, 119, 7, 119, 2, 120, 7, 120, 2, 121, 7, 121, 2,
		122, 7, 122, 2, 123, 7, 123, 2, 124, 7, 124, 2, 125, 7, 125, 2, 126, 7,
		126, 2, 127, 7, 127, 2, 128, 7, 128, 2, 129, 7, 129, 2, 130, 7, 130, 2,
		131, 7, 131, 2, 132, 7, 132, 2, 133, 7, 133, 2, 134, 7, 134, 2, 135, 7,
		135, 2, 136, 7, 136, 2, 137, 7, 137, 2, 138, 7, 138, 2, 139, 7, 139, 2,
		140, 7, 140, 2, 141, 7, 141, 2, 142, 7, 142, 2, 143, 7, 143, 2, 144, 7,
		144, 2, 145, 7, 145, 2, 146, 7, 146, 2, 147, 7, 147, 2, 148, 7, 148, 2,
		149, 7, 149, 2, 150, 7, 150, 2, 151, 7, 151, 2, 152, 7, 152, 1, 0, 3, 0,
		308, 8, 0, 1, 0, 5, 0, 311, 8, 0, 10, 0, 12, 0, 314, 9, 0, 1, 0, 1, 0,
		1, 1, 1, 1, 3, 1, 320, 8, 1, 1, 2, 4, 2, 323, 8, 2, 11, 2, 12, 2, 324,
		1, 2, 3, 2, 328, 8, 2, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3,
		1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3,
		1, 3, 1, 3, 5, 3, 352, 8, 3, 10, 3, 12, 3, 355, 9, 3, 1, 3, 3, 3, 358,
		8, 3, 1, 4, 4, 4, 361, 8, 4, 11, 4, 12, 4, 362, 1, 5, 5, 5, 366, 8, 5,
		10, 5, 12, 5, 369, 9, 5, 1, 5, 4, 5, 372, 8, 5, 11, 5, 12, 5, 373, 1, 5,
		3, 5, 377, 8, 5, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 7, 1, 7, 1, 7, 1, 7,
		1, 7, 1, 7, 1, 7, 3, 7, 391, 8, 7, 1, 8, 1, 8, 3, 8, 395, 8, 8, 1, 8, 1,
		8, 1, 8, 1, 9, 3, 9, 401, 8, 9, 1, 9, 1, 9, 1, 9, 3, 9, 406, 8, 9, 1, 9,
		5, 9, 409, 8, 9, 10, 9, 12, 9, 412, 9, 9, 1, 10, 1, 10, 1, 11, 1, 11, 3,
		11, 418, 8, 11, 1, 11, 1, 11, 5, 11, 422, 8, 11, 10, 11, 12, 11, 425, 9,
		11, 1, 11, 1, 11, 1, 11, 1, 11, 3, 11, 431, 8, 11, 1, 12, 1, 12, 1, 12,
		1, 12, 1, 12, 3, 12, 438, 8, 12, 1, 13, 3, 13, 441, 8, 13, 1, 13, 1, 13,
		3, 13, 445, 8, 13, 1, 13, 1, 13, 1, 13, 1, 13, 1, 13, 1, 13, 3, 13, 453,
		8, 13, 1, 13, 3, 13, 456, 8, 13, 1, 13, 1, 13, 1, 14, 3, 14, 461, 8, 14,
		1, 14, 3, 14, 464, 8, 14, 1, 14, 3, 14, 467, 8, 14, 1, 14, 3, 14, 470,
		8, 14, 1, 14, 1, 14, 1, 14, 1, 14, 3, 14, 476, 8, 14, 1, 14, 1, 14, 3,
		14, 480, 8, 14, 1, 14, 1, 14, 1, 14, 1, 14, 3, 14, 486, 8, 14, 3, 14, 488,
		8, 14, 1, 14, 1, 14, 5, 14, 492, 8, 14, 10, 14, 12, 14, 495, 9, 14, 1,
		14, 1, 14, 1, 15, 1, 15, 1, 16, 1, 16, 1, 16, 5, 16, 504, 8, 16, 10, 16,
		12, 16, 507, 9, 16, 1, 17, 1, 17, 1, 17, 5, 17, 512, 8, 17, 10, 17, 12,
		17, 515, 9, 17, 1, 18, 1, 18, 1, 18, 5, 18, 520, 8, 18, 10, 18, 12, 18,
		523, 9, 18, 1, 19, 3, 19, 526, 8, 19, 1, 19, 1, 19, 1, 20, 3, 20, 531,
		8, 20, 1, 20, 1, 20, 1, 20, 1, 20, 3, 20, 537, 8, 20, 1, 21, 4, 21, 540,
		8, 21, 11, 21, 12, 21, 541, 1, 22, 1, 22, 1, 22, 1, 22, 3, 22, 548, 8,
		22, 1, 22, 1, 22, 1, 22, 5, 22, 553, 8, 22, 10, 22, 12, 22, 556, 9, 22,
		1, 22, 1, 22, 1, 23, 1, 23, 3, 23, 562, 8, 23, 1, 24, 5, 24, 565, 8, 24,
		10, 24, 12, 24, 568, 9, 24, 1, 25, 1, 25, 1, 25, 3, 25, 573, 8, 25, 1,
		26, 1, 26, 1, 26, 1, 27, 1, 27, 1, 27, 1, 27, 1, 27, 1, 27, 1, 27, 1, 27,
		1, 27, 1, 27, 1, 27, 1, 27, 1, 27, 1, 27, 1, 27, 1, 27, 1, 27, 1, 27, 1,
		27, 1, 27, 1, 27, 1, 27, 1, 27, 1, 27, 1, 27, 3, 27, 603, 8, 27, 1, 28,
		1, 28, 1, 29, 1, 29, 1, 29, 1, 29, 1, 30, 1, 30, 1, 30, 1, 30, 5, 30, 615,
		8, 30, 10, 30, 12, 30, 618, 9, 30, 1, 30, 3, 30, 621, 8, 30, 1, 30, 1,
		30, 1, 30, 1, 30, 1, 30, 5, 30, 628, 8, 30, 10, 30, 12, 30, 631, 9, 30,
		1, 30, 3, 30, 634, 8, 30, 1, 30, 1, 30, 1, 30, 3, 30, 639, 8, 30, 1, 31,
		1, 31, 1, 31, 1, 31, 1, 32, 1, 32, 1, 32, 1, 32, 1, 32, 1, 33, 1, 33, 1,
		33, 1, 34, 1, 34, 1, 34, 1, 34, 1, 35, 1, 35, 1, 35, 1, 35, 1, 35, 1, 35,
		1, 35, 1, 35, 3, 35, 665, 8, 35, 1, 36, 1, 36, 1, 36, 1, 36, 1, 36, 1,
		36, 1, 37, 1, 37, 1, 37, 3, 37, 676, 8, 37, 1, 37, 1, 37, 3, 37, 680, 8,
		37, 1, 37, 1, 37, 3, 37, 684, 8, 37, 1, 37, 1, 37, 1, 37, 1, 37, 1, 37,
		1, 37, 1, 37, 3, 37, 693, 8, 37, 1, 38, 1, 38, 1, 39, 1, 39, 1, 40, 1,
		40, 1, 40, 1, 40, 3, 40, 703, 8, 40, 1, 40, 1, 40, 5, 40, 707, 8, 40, 10,
		40, 12, 40, 710, 9, 40, 1, 40, 1, 40, 1, 40, 3, 40, 715, 8, 40, 1, 40,
		1, 40, 5, 40, 719, 8, 40, 10, 40, 12, 40, 722, 9, 40, 1, 40, 1, 40, 3,
		40, 726, 8, 40, 1, 41, 1, 41, 1, 41, 1, 41, 5, 41, 732, 8, 41, 10, 41,
		12, 41, 735, 9, 41, 1, 41, 1, 41, 1, 42, 1, 42, 1, 42, 5, 42, 742, 8, 42,
		10, 42, 12, 42, 745, 9, 42, 1, 42, 1, 42, 1, 43, 1, 43, 1, 43, 3, 43, 752,
		8, 43, 1, 43, 1, 43, 5, 43, 756, 8, 43, 10, 43, 12, 43, 759, 9, 43, 4,
		43, 761, 8, 43, 11, 43, 12, 43, 762, 1, 43, 1, 43, 1, 44, 1, 44, 3, 44,
		769, 8, 44, 1, 44, 1, 44, 1, 45, 1, 45, 3, 45, 775, 8, 45, 1, 45, 1, 45,
		1, 46, 1, 46, 3, 46, 781, 8, 46, 1, 46, 1, 46, 1, 47, 1, 47, 1, 47, 1,
		48, 1, 48, 1, 48, 1, 48, 1, 48, 1, 48, 1, 49, 1, 49, 1, 49, 1, 49, 1, 49,
		1, 49, 1, 49, 1, 49, 1, 49, 1, 49, 1, 49, 3, 49, 805, 8, 49, 1, 49, 1,
		49, 1, 49, 3, 49, 810, 8, 49, 1, 49, 3, 49, 813, 8, 49, 1, 49, 1, 49, 1,
		49, 1, 49, 1, 49, 1, 49, 1, 49, 1, 49, 3, 49, 823, 8, 49, 1, 49, 3, 49,
		826, 8, 49, 1, 49, 1, 49, 1, 49, 1, 49, 1, 49, 1, 49, 1, 49, 1, 49, 1,
		49, 1, 49, 1, 49, 3, 49, 839, 8, 49, 1, 49, 1, 49, 1, 49, 1, 49, 1, 49,
		1, 49, 3, 49, 847, 8, 49, 1, 50, 1, 50, 1, 50, 4, 50, 852, 8, 50, 11, 50,
		12, 50, 853, 1, 50, 3, 50, 857, 8, 50, 1, 50, 5, 50, 860, 8, 50, 10, 50,
		12, 50, 863, 9, 50, 1, 50, 3, 50, 866, 8, 50, 1, 51, 1, 51, 1, 51, 1, 51,
		1, 51, 5, 51, 873, 8, 51, 10, 51, 12, 51, 876, 9, 51, 1, 51, 3, 51, 879,
		8, 51, 1, 51, 1, 51, 1, 51, 1, 52, 1, 52, 1, 52, 1, 53, 1, 53, 1, 53, 1,
		53, 1, 54, 1, 54, 1, 54, 1, 54, 1, 55, 1, 55, 1, 55, 1, 55, 1, 55, 1, 55,
		1, 55, 1, 55, 1, 55, 1, 55, 3, 55, 905, 8, 55, 1, 56, 4, 56, 908, 8, 56,
		11, 56, 12, 56, 909, 1, 57, 1, 57, 1, 57, 5, 57, 915, 8, 57, 10, 57, 12,
		57, 918, 9, 57, 1, 58, 1, 58, 1, 58, 1, 58, 3, 58, 924, 8, 58, 1, 58, 1,
		58, 1, 58, 1, 58, 1, 58, 1, 58, 3, 58, 932, 8, 58, 1, 59, 3, 59, 935, 8,
		59, 1, 59, 1, 59, 5, 59, 939, 8, 59, 10, 59, 12, 59, 942, 9, 59, 1, 59,
		3, 59, 945, 8, 59, 1, 60, 3, 60, 948, 8, 60, 1, 60, 5, 60, 951, 8, 60,
		10, 60, 12, 60, 954, 9, 60, 1, 60, 3, 60, 957, 8, 60, 1, 60, 3, 60, 960,
		8, 60, 1, 60, 3, 60, 963, 8, 60, 1, 60, 3, 60, 966, 8, 60, 1, 60, 1, 60,
		1, 61, 1, 61, 1, 61, 1, 61, 3, 61, 974, 8, 61, 1, 61, 1, 61, 1, 61, 5,
		61, 979, 8, 61, 10, 61, 12, 61, 982, 9, 61, 1, 62, 1, 62, 1, 62, 1, 62,
		5, 62, 988, 8, 62, 10, 62, 12, 62, 991, 9, 62, 1, 62, 1, 62, 1, 63, 1,
		63, 1, 63, 1, 63, 1, 63, 1, 63, 1, 63, 1, 63, 3, 63, 1003, 8, 63, 1, 64,
		1, 64, 1, 64, 1, 64, 1, 65, 1, 65, 1, 65, 1, 65, 5, 65, 1013, 8, 65, 10,
		65, 12, 65, 1016, 9, 65, 1, 65, 1, 65, 1, 66, 1, 66, 1, 66, 1, 66, 1, 66,
		3, 66, 1025, 8, 66, 1, 66, 1, 66, 3, 66, 1029, 8, 66, 1, 66, 1, 66, 1,
		66, 5, 66, 1034, 8, 66, 10, 66, 12, 66, 1037, 9, 66, 1, 66, 1, 66, 1, 66,
		3, 66, 1042, 8, 66, 1, 66, 3, 66, 1045, 8, 66, 1, 66, 1, 66, 3, 66, 1049,
		8, 66, 1, 66, 1, 66, 1, 66, 5, 66, 1054, 8, 66, 10, 66, 12, 66, 1057, 9,
		66, 1, 66, 1, 66, 1, 66, 3, 66, 1062, 8, 66, 1, 66, 3, 66, 1065, 8, 66,
		1, 66, 1, 66, 3, 66, 1069, 8, 66, 1, 66, 1, 66, 1, 66, 1, 66, 1, 66, 1,
		66, 3, 66, 1077, 8, 66, 1, 66, 1, 66, 3, 66, 1081, 8, 66, 1, 67, 1, 67,
		1, 67, 5, 67, 1086, 8, 67, 10, 67, 12, 67, 1089, 9, 67, 1, 67, 3, 67, 1092,
		8, 67, 1, 68, 1, 68, 3, 68, 1096, 8, 68, 1, 69, 1, 69, 1, 69, 1, 69, 1,
		69, 1, 69, 1, 69, 1, 70, 1, 70, 1, 70, 1, 70, 3, 70, 1109, 8, 70, 1, 70,
		3, 70, 1112, 8, 70, 1, 70, 1, 70, 1, 71, 1, 71, 1, 71, 3, 71, 1119, 8,
		71, 1, 71, 1, 71, 1, 72, 1, 72, 1, 72, 3, 72, 1126, 8, 72, 1, 73, 1, 73,
		3, 73, 1130, 8, 73, 1, 73, 1, 73, 1, 74, 1, 74, 3, 74, 1136, 8, 74, 1,
		75, 1, 75, 3, 75, 1140, 8, 75, 1, 76, 4, 76, 1143, 8, 76, 11, 76, 12, 76,
		1144, 1, 77, 1, 77, 1, 77, 3, 77, 1150, 8, 77, 1, 78, 1, 78, 1, 78, 1,
		78, 1, 79, 3, 79, 1157, 8, 79, 1, 79, 1, 79, 1, 79, 1, 79, 5, 79, 1163,
		8, 79, 10, 79, 12, 79, 1166, 9, 79, 1, 79, 1, 79, 1, 80, 1, 80, 1, 80,
		1, 80, 3, 80, 1174, 8, 80, 1, 80, 1, 80, 3, 80, 1178, 8, 80, 1, 80, 1,
		80, 5, 80, 1182, 8, 80, 10, 80, 12, 80, 1185, 9, 80, 1, 80, 1, 80, 1, 81,
		1, 81, 1, 81, 1, 81, 3, 81, 1193, 8, 81, 1, 81, 1, 81, 1, 81, 3, 81, 1198,
		8, 81, 1, 81, 1, 81, 1, 81, 1, 81, 1, 81, 3, 81, 1205, 8, 81, 1, 82, 1,
		82, 1, 82, 5, 82, 1210, 8, 82, 10, 82, 12, 82, 1213, 9, 82, 1, 83, 1, 83,
		1, 83, 1, 83, 1, 84, 1, 84, 1, 84, 1, 84, 1, 84, 5, 84, 1224, 8, 84, 10,
		84, 12, 84, 1227, 9, 84, 1, 84, 1, 84, 1, 85, 1, 85, 3, 85, 1233, 8, 85,
		1, 86, 1, 86, 1, 86, 1, 86, 1, 86, 1, 86, 1, 86, 1, 86, 1, 86, 1, 86, 1,
		86, 1, 86, 1, 86, 1, 86, 1, 86, 1, 86, 3, 86, 1251, 8, 86, 1, 87, 1, 87,
		1, 87, 1, 87, 1, 87, 1, 87, 1, 87, 1, 87, 1, 87, 1, 87, 1, 87, 1, 87, 1,
		87, 1, 87, 1, 87, 1, 87, 3, 87, 1269, 8, 87, 1, 88, 1, 88, 1, 88, 3, 88,
		1274, 8, 88, 1, 89, 1, 89, 1, 89, 3, 89, 1279, 8, 89, 1, 90, 1, 90, 1,
		90, 1, 90, 1, 90, 1, 90, 1, 90, 1, 90, 3, 90, 1289, 8, 90, 1, 90, 1, 90,
		1, 90, 1, 90, 1, 90, 1, 90, 1, 90, 1, 90, 1, 90, 1, 90, 1, 90, 1, 90, 1,
		90, 1, 90, 1, 90, 1, 90, 1, 90, 1, 90, 1, 90, 1, 90, 1, 90, 1, 90, 1, 90,
		1, 90, 1, 90, 1, 90, 1, 90, 1, 90, 1, 90, 1, 90, 1, 90, 1, 90, 1, 90, 1,
		90, 1, 90, 1, 90, 1, 90, 3, 90, 1328, 8, 90, 1, 90, 3, 90, 1331, 8, 90,
		1, 90, 1, 90, 1, 90, 1, 90, 1, 90, 1, 90, 1, 90, 1, 90, 1, 90, 1, 90, 1,
		90, 1, 90, 1, 90, 1, 90, 1, 90, 1, 90, 1, 90, 1, 90, 1, 90, 1, 90, 1, 90,
		1, 90, 1, 90, 1, 90, 1, 90, 1, 90, 1, 90, 1, 90, 1, 90, 1, 90, 1, 90, 1,
		90, 3, 90, 1365, 8, 90, 1, 90, 1, 90, 1, 90, 1, 90, 1, 90, 1, 90, 1, 90,
		1, 90, 1, 90, 1, 90, 1, 90, 1, 90, 1, 90, 1, 90, 1, 90, 1, 90, 1, 90, 1,
		90, 1, 90, 1, 90, 1, 90, 1, 90, 1, 90, 1, 90, 1, 90, 1, 90, 1, 90, 1, 90,
		1, 90, 1, 90, 1, 90, 1, 90, 1, 90, 1, 90, 1, 90, 1, 90, 3, 90, 1403, 8,
		90, 1, 90, 1, 90, 1, 90, 1, 90, 1, 90, 1, 90, 1, 90, 1, 90, 1, 90, 1, 90,
		1, 90, 1, 90, 1, 90, 1, 90, 1, 90, 1, 90, 1, 90, 1, 90, 1, 90, 1, 90, 1,
		90, 1, 90, 1, 90, 1, 90, 1, 90, 1, 90, 1, 90, 1, 90, 1, 90, 1, 90, 1, 90,
		1, 90, 5, 90, 1437, 8, 90, 10, 90, 12, 90, 1440, 9, 90, 1, 91, 1, 91, 1,
		91, 1, 91, 1, 91, 1, 91, 3, 91, 1448, 8, 91, 1, 91, 1, 91, 1, 91, 1, 91,
		3, 91, 1454, 8, 91, 1, 91, 1, 91, 1, 91, 1, 91, 5, 91, 1460, 8, 91, 10,
		91, 12, 91, 1463, 9, 91, 1, 92, 1, 92, 1, 92, 1, 92, 1, 92, 1, 92, 1, 92,
		1, 92, 1, 92, 1, 92, 1, 92, 1, 92, 3, 92, 1477, 8, 92, 1, 93, 1, 93, 4,
		93, 1481, 8, 93, 11, 93, 12, 93, 1482, 1, 93, 1, 93, 4, 93, 1487, 8, 93,
		11, 93, 12, 93, 1488, 1, 93, 1, 93, 1, 93, 1, 93, 3, 93, 1495, 8, 93, 1,
		94, 1, 94, 1, 94, 1, 95, 1, 95, 1, 95, 3, 95, 1503, 8, 95, 1, 95, 1, 95,
		1, 95, 3, 95, 1508, 8, 95, 1, 96, 1, 96, 3, 96, 1512, 8, 96, 1, 97, 1,
		97, 1, 97, 3, 97, 1517, 8, 97, 1, 97, 1, 97, 1, 97, 1, 97, 3, 97, 1523,
		8, 97, 1, 97, 1, 97, 1, 97, 3, 97, 1528, 8, 97, 1, 97, 3, 97, 1531, 8,
		97, 1, 98, 1, 98, 5, 98, 1535, 8, 98, 10, 98, 12, 98, 1538, 9, 98, 1, 98,
		1, 98, 4, 98, 1542, 8, 98, 11, 98, 12, 98, 1543, 1, 98, 5, 98, 1547, 8,
		98, 10, 98, 12, 98, 1550, 9, 98, 1, 98, 5, 98, 1553, 8, 98, 10, 98, 12,
		98, 1556, 9, 98, 1, 98, 1, 98, 1, 98, 1, 98, 1, 98, 4, 98, 1563, 8, 98,
		11, 98, 12, 98, 1564, 1, 98, 5, 98, 1568, 8, 98, 10, 98, 12, 98, 1571,
		9, 98, 1, 98, 3, 98, 1574, 8, 98, 1, 98, 1, 98, 3, 98, 1578, 8, 98, 1,
		99, 3, 99, 1581, 8, 99, 1, 99, 1, 99, 1, 100, 1, 100, 1, 100, 3, 100, 1588,
		8, 100, 1, 100, 3, 100, 1591, 8, 100, 1, 100, 1, 100, 1, 101, 3, 101, 1596,
		8, 101, 1, 101, 1, 101, 3, 101, 1600, 8, 101, 1, 101, 1, 101, 1, 101, 1,
		101, 3, 101, 1606, 8, 101, 1, 101, 1, 101, 3, 101, 1610, 8, 101, 1, 101,
		1, 101, 1, 101, 1, 101, 1, 101, 1, 101, 1, 101, 1, 101, 1, 101, 3, 101,
		1621, 8, 101, 1, 102, 1, 102, 1, 102, 1, 102, 1, 102, 1, 102, 1, 102, 1,
		102, 5, 102, 1631, 8, 102, 10, 102, 12, 102, 1634, 9, 102, 1, 102, 3, 102,
		1637, 8, 102, 1, 102, 1, 102, 1, 103, 1, 103, 1, 103, 5, 103, 1644, 8,
		103, 10, 103, 12, 103, 1647, 9, 103, 1, 103, 1, 103, 1, 103, 1, 104, 1,
		104, 1, 104, 1, 104, 1, 104, 3, 104, 1657, 8, 104, 3, 104, 1659, 8, 104,
		1, 105, 1, 105, 1, 106, 1, 106, 1, 106, 1, 106, 3, 106, 1667, 8, 106, 1,
		106, 1, 106, 3, 106, 1671, 8, 106, 1, 107, 1, 107, 1, 107, 5, 107, 1676,
		8, 107, 10, 107, 12, 107, 1679, 9, 107, 1, 107, 3, 107, 1682, 8, 107, 1,
		108, 1, 108, 1, 108, 3, 108, 1687, 8, 108, 1, 108, 1, 108, 1, 108, 3, 108,
		1692, 8, 108, 1, 108, 1, 108, 3, 108, 1696, 8, 108, 1, 109, 1, 109, 1,
		109, 1, 109, 1, 109, 5, 109, 1703, 8, 109, 10, 109, 12, 109, 1706, 9, 109,
		1, 109, 1, 109, 1, 110, 3, 110, 1711, 8, 110, 1, 110, 1, 110, 1, 111, 1,
		111, 3, 111, 1717, 8, 111, 1, 112, 1, 112, 3, 112, 1721, 8, 112, 1, 112,
		1, 112, 1, 112, 3, 112, 1726, 8, 112, 1, 113, 3, 113, 1729, 8, 113, 1,
		113, 3, 113, 1732, 8, 113, 1, 113, 3, 113, 1735, 8, 113, 1, 113, 3, 113,
		1738, 8, 113, 1, 113, 1, 113, 1, 113, 3, 113, 1743, 8, 113, 1, 113, 1,
		113, 3, 113, 1747, 8, 113, 1, 113, 1, 113, 1, 113, 1, 113, 3, 113, 1753,
		8, 113, 3, 113, 1755, 8, 113, 1, 113, 3, 113, 1758, 8, 113, 1, 113, 1,
		113, 5, 113, 1762, 8, 113, 10, 113, 12, 113, 1765, 9, 113, 1, 113, 1, 113,
		1, 114, 1, 114, 1, 114, 5, 114, 1772, 8, 114, 10, 114, 12, 114, 1775, 9,
		114, 1, 115, 3, 115, 1778, 8, 115, 1, 115, 3, 115, 1781, 8, 115, 1, 115,
		1, 115, 1, 116, 1, 116, 1, 116, 1, 116, 4, 116, 1789, 8, 116, 11, 116,
		12, 116, 1790, 1, 116, 1, 116, 3, 116, 1795, 8, 116, 3, 116, 1797, 8, 116,
		1, 117, 1, 117, 1, 117, 3, 117, 1802, 8, 117, 1, 117, 1, 117, 1, 117, 1,
		117, 5, 117, 1808, 8, 117, 10, 117, 12, 117, 1811, 9, 117, 1, 117, 3, 117,
		1814, 8, 117, 1, 117, 1, 117, 3, 117, 1818, 8, 117, 1, 118, 1, 118, 1,
		118, 5, 118, 1823, 8, 118, 10, 118, 12, 118, 1826, 9, 118, 1, 119, 1, 119,
		3, 119, 1830, 8, 119, 1, 119, 1, 119, 5, 119, 1834, 8, 119, 10, 119, 12,
		119, 1837, 9, 119, 1, 119, 3, 119, 1840, 8, 119, 1, 119, 1, 119, 1, 120,
		3, 120, 1845, 8, 120, 1, 120, 3, 120, 1848, 8, 120, 1, 120, 1, 120, 1,
		120, 3, 120, 1853, 8, 120, 1, 121, 1, 121, 1, 121, 1, 122, 1, 122, 1, 122,
		5, 122, 1861, 8, 122, 10, 122, 12, 122, 1864, 9, 122, 1, 122, 1, 122, 1,
		122, 1, 122, 3, 122, 1870, 8, 122, 3, 122, 1872, 8, 122, 1, 122, 1, 122,
		1, 122, 1, 122, 3, 122, 1878, 8, 122, 3, 122, 1880, 8, 122, 1, 122, 1,
		122, 1, 122, 1, 122, 3, 122, 1886, 8, 122, 1, 123, 1, 123, 3, 123, 1890,
		8, 123, 1, 124, 1, 124, 1, 124, 3, 124, 1895, 8, 124, 1, 125, 1, 125, 1,
		125, 1, 125, 3, 125, 1901, 8, 125, 1, 126, 1, 126, 1, 127, 1, 127, 1, 127,
		1, 127, 1, 127, 1, 127, 3, 127, 1911, 8, 127, 1, 127, 1, 127, 1, 127, 3,
		127, 1916, 8, 127, 1, 127, 1, 127, 1, 127, 3, 127, 1921, 8, 127, 3, 127,
		1923, 8, 127, 1, 128, 1, 128, 1, 129, 1, 129, 4, 129, 1929, 8, 129, 11,
		129, 12, 129, 1930, 1, 129, 1, 129, 4, 129, 1935, 8, 129, 11, 129, 12,
		129, 1936, 1, 129, 1, 129, 1, 129, 5, 129, 1942, 8, 129, 10, 129, 12, 129,
		1945, 9, 129, 1, 129, 3, 129, 1948, 8, 129, 1, 130, 1, 130, 1, 130, 3,
		130, 1953, 8, 130, 1, 131, 1, 131, 1, 131, 5, 131, 1958, 8, 131, 10, 131,
		12, 131, 1961, 9, 131, 1, 132, 1, 132, 5, 132, 1965, 8, 132, 10, 132, 12,
		132, 1968, 9, 132, 1, 132, 3, 132, 1971, 8, 132, 1, 133, 1, 133, 1, 133,
		1, 133, 1, 133, 1, 133, 3, 133, 1979, 8, 133, 1, 134, 1, 134, 1, 134, 3,
		134, 1984, 8, 134, 1, 135, 1, 135, 1, 135, 1, 136, 1, 136, 1, 136, 1, 136,
		1, 136, 3, 136, 1994, 8, 136, 1, 137, 4, 137, 1997, 8, 137, 11, 137, 12,
		137, 1998, 1, 137, 5, 137, 2002, 8, 137, 10, 137, 12, 137, 2005, 9, 137,
		1, 138, 1, 138, 1, 138, 3, 138, 2010, 8, 138, 1, 138, 1, 138, 1, 138, 1,
		138, 3, 138, 2016, 8, 138, 1, 139, 1, 139, 3, 139, 2020, 8, 139, 1, 140,
		1, 140, 1, 140, 1, 140, 1, 140, 3, 140, 2027, 8, 140, 1, 140, 5, 140, 2030,
		8, 140, 10, 140, 12, 140, 2033, 9, 140, 1, 141, 5, 141, 2036, 8, 141, 10,
		141, 12, 141, 2039, 9, 141, 1, 141, 1, 141, 1, 141, 1, 141, 1, 141, 1,
		141, 3, 141, 2047, 8, 141, 1, 141, 5, 141, 2050, 8, 141, 10, 141, 12, 141,
		2053, 9, 141, 1, 142, 1, 142, 3, 142, 2057, 8, 142, 1, 142, 1, 142, 1,
		142, 1, 142, 1, 142, 3, 142, 2064, 8, 142, 1, 143, 3, 143, 2067, 8, 143,
		1, 143, 1, 143, 3, 143, 2071, 8, 143, 5, 143, 2073, 8, 143, 10, 143, 12,
		143, 2076, 9, 143, 1, 144, 1, 144, 1, 144, 1, 144, 1, 144, 1, 144, 1, 144,
		3, 144, 2085, 8, 144, 1, 145, 1, 145, 1, 146, 1, 146, 1, 146, 1, 146, 3,
		146, 2093, 8, 146, 1, 147, 1, 147, 1, 148, 1, 148, 1, 149, 1, 149, 1, 150,
		1, 150, 1, 151, 1, 151, 1, 152, 1, 152, 1, 152, 0, 3, 122, 180, 182, 153,
		0, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30, 32, 34, 36,
		38, 40, 42, 44, 46, 48, 50, 52, 54, 56, 58, 60, 62, 64, 66, 68, 70, 72,
		74, 76, 78, 80, 82, 84, 86, 88, 90, 92, 94, 96, 98, 100, 102, 104, 106,
		108, 110, 112, 114, 116, 118, 120, 122, 124, 126, 128, 130, 132, 134, 136,
		138, 140, 142, 144, 146, 148, 150, 152, 154, 156, 158, 160, 162, 164, 166,
		168, 170, 172, 174, 176, 178, 180, 182, 184, 186, 188, 190, 192, 194, 196,
		198, 200, 202, 204, 206, 208, 210, 212, 214, 216, 218, 220, 222, 224, 226,
		228, 230, 232, 234, 236, 238, 240, 242, 244, 246, 248, 250, 252, 254, 256,
		258, 260, 262, 264, 266, 268, 270, 272, 274, 276, 278, 280, 282, 284, 286,
		288, 290, 292, 294, 296, 298, 300, 302, 304, 0, 27, 2, 0, 38, 38, 244,
		244, 2, 0, 56, 56, 86, 86, 2, 0, 54, 54, 126, 126, 1, 0, 221, 222, 2, 0,
		99, 99, 123, 123, 1, 0, 78, 79, 1, 0, 76, 77, 1, 0, 209, 210, 2, 0, 202,
		202, 204, 205, 1, 0, 167, 168, 1, 0, 206, 208, 2, 0, 204, 205, 212, 212,
		1, 0, 192, 193, 2, 0, 173, 174, 198, 199, 1, 0, 169, 172, 2, 0, 92, 93,
		118, 119, 4, 0, 175, 177, 179, 187, 191, 191, 223, 223, 1, 0, 204, 205,
		2, 0, 229, 230, 232, 233, 2, 0, 54, 54, 111, 111, 2, 0, 44, 44, 81, 81,
		8, 0, 44, 57, 60, 75, 80, 91, 94, 100, 102, 117, 120, 124, 126, 130, 132,
		164, 4, 0, 44, 44, 81, 81, 114, 117, 122, 122, 1, 0, 157, 164, 1, 0, 141,
		156, 7, 0, 45, 45, 48, 48, 64, 64, 98, 99, 110, 110, 120, 120, 123, 123,
		9, 0, 45, 45, 47, 48, 63, 64, 83, 83, 96, 99, 110, 110, 120, 120, 123,
		123, 129, 131, 2355, 0, 307, 1, 0, 0, 0, 2, 319, 1, 0, 0, 0, 4, 327, 1,
		0, 0, 0, 6, 357, 1, 0, 0, 0, 8, 360, 1, 0, 0, 0, 10, 367, 1, 0, 0, 0, 12,
		378, 1, 0, 0, 0, 14, 390, 1, 0, 0, 0, 16, 392, 1, 0, 0, 0, 18, 400, 1,
		0, 0, 0, 20, 413, 1, 0, 0, 0, 22, 415, 1, 0, 0, 0, 24, 437, 1, 0, 0, 0,
		26, 440, 1, 0, 0, 0, 28, 460, 1, 0, 0, 0, 30, 498, 1, 0, 0, 0, 32, 500,
		1, 0, 0, 0, 34, 508, 1, 0, 0, 0, 36, 516, 1, 0, 0, 0, 38, 525, 1, 0, 0,
		0, 40, 530, 1, 0, 0, 0, 42, 539, 1, 0, 0, 0, 44, 543, 1, 0, 0, 0, 46, 559,
		1, 0, 0, 0, 48, 566, 1, 0, 0, 0, 50, 572, 1, 0, 0, 0, 52, 574, 1, 0, 0,
		0, 54, 602, 1, 0, 0, 0, 56, 604, 1, 0, 0, 0, 58, 606, 1, 0, 0, 0, 60, 638,
		1, 0, 0, 0, 62, 640, 1, 0, 0, 0, 64, 644, 1, 0, 0, 0, 66, 649, 1, 0, 0,
		0, 68, 652, 1, 0, 0, 0, 70, 656, 1, 0, 0, 0, 72, 666, 1, 0, 0, 0, 74, 672,
		1, 0, 0, 0, 76, 694, 1, 0, 0, 0, 78, 696, 1, 0, 0, 0, 80, 698, 1, 0, 0,
		0, 82, 727, 1, 0, 0, 0, 84, 738, 1, 0, 0, 0, 86, 760, 1, 0, 0, 0, 88, 766,
		1, 0, 0, 0, 90, 772, 1, 0, 0, 0, 92, 778, 1, 0, 0, 0, 94, 784, 1, 0, 0,
		0, 96, 787, 1, 0, 0, 0, 98, 793, 1, 0, 0, 0, 100, 848, 1, 0, 0, 0, 102,
		867, 1, 0, 0, 0, 104, 883, 1, 0, 0, 0, 106, 886, 1, 0, 0, 0, 108, 890,
		1, 0, 0, 0, 110, 894, 1, 0, 0, 0, 112, 907, 1, 0, 0, 0, 114, 911, 1, 0,
		0, 0, 116, 931, 1, 0, 0, 0, 118, 934, 1, 0, 0, 0, 120, 947, 1, 0, 0, 0,
		122, 973, 1, 0, 0, 0, 124, 983, 1, 0, 0, 0, 126, 1002, 1, 0, 0, 0, 128,
		1004, 1, 0, 0, 0, 130, 1008, 1, 0, 0, 0, 132, 1080, 1, 0, 0, 0, 134, 1091,
		1, 0, 0, 0, 136, 1095, 1, 0, 0, 0, 138, 1097, 1, 0, 0, 0, 140, 1104, 1,
		0, 0, 0, 142, 1118, 1, 0, 0, 0, 144, 1122, 1, 0, 0, 0, 146, 1127, 1, 0,
		0, 0, 148, 1135, 1, 0, 0, 0, 150, 1139, 1, 0, 0, 0, 152, 1142, 1, 0, 0,
		0, 154, 1146, 1, 0, 0, 0, 156, 1151, 1, 0, 0, 0, 158, 1156, 1, 0, 0, 0,
		160, 1169, 1, 0, 0, 0, 162, 1204, 1, 0, 0, 0, 164, 1206, 1, 0, 0, 0, 166,
		1214, 1, 0, 0, 0, 168, 1218, 1, 0, 0, 0, 170, 1232, 1, 0, 0, 0, 172, 1250,
		1, 0, 0, 0, 174, 1268, 1, 0, 0, 0, 176, 1273, 1, 0, 0, 0, 178, 1278, 1,
		0, 0, 0, 180, 1364, 1, 0, 0, 0, 182, 1441, 1, 0, 0, 0, 184, 1476, 1, 0,
		0, 0, 186, 1494, 1, 0, 0, 0, 188, 1496, 1, 0, 0, 0, 190, 1507, 1, 0, 0,
		0, 192, 1511, 1, 0, 0, 0, 194, 1530, 1, 0, 0, 0, 196, 1577, 1, 0, 0, 0,
		198, 1580, 1, 0, 0, 0, 200, 1587, 1, 0, 0, 0, 202, 1620, 1, 0, 0, 0, 204,
		1622, 1, 0, 0, 0, 206, 1640, 1, 0, 0, 0, 208, 1658, 1, 0, 0, 0, 210, 1660,
		1, 0, 0, 0, 212, 1662, 1, 0, 0, 0, 214, 1672, 1, 0, 0, 0, 216, 1695, 1,
		0, 0, 0, 218, 1697, 1, 0, 0, 0, 220, 1710, 1, 0, 0, 0, 222, 1716, 1, 0,
		0, 0, 224, 1725, 1, 0, 0, 0, 226, 1728, 1, 0, 0, 0, 228, 1768, 1, 0, 0,
		0, 230, 1777, 1, 0, 0, 0, 232, 1796, 1, 0, 0, 0, 234, 1817, 1, 0, 0, 0,
		236, 1819, 1, 0, 0, 0, 238, 1827, 1, 0, 0, 0, 240, 1852, 1, 0, 0, 0, 242,
		1854, 1, 0, 0, 0, 244, 1885, 1, 0, 0, 0, 246, 1889, 1, 0, 0, 0, 248, 1894,
		1, 0, 0, 0, 250, 1900, 1, 0, 0, 0, 252, 1902, 1, 0, 0, 0, 254, 1922, 1,
		0, 0, 0, 256, 1924, 1, 0, 0, 0, 258, 1947, 1, 0, 0, 0, 260, 1952, 1, 0,
		0, 0, 262, 1954, 1, 0, 0, 0, 264, 1970, 1, 0, 0, 0, 266, 1978, 1, 0, 0,
		0, 268, 1980, 1, 0, 0, 0, 270, 1985, 1, 0, 0, 0, 272, 1993, 1, 0, 0, 0,
		274, 1996, 1, 0, 0, 0, 276, 2015, 1, 0, 0, 0, 278, 2019, 1, 0, 0, 0, 280,
		2026, 1, 0, 0, 0, 282, 2037, 1, 0, 0, 0, 284, 2063, 1, 0, 0, 0, 286, 2066,
		1, 0, 0, 0, 288, 2084, 1, 0, 0, 0, 290, 2086, 1, 0, 0, 0, 292, 2092, 1,
		0, 0, 0, 294, 2094, 1, 0, 0, 0, 296, 2096, 1, 0, 0, 0, 298, 2098, 1, 0,
		0, 0, 300, 2100, 1, 0, 0, 0, 302, 2102, 1, 0, 0, 0, 304, 2104, 1, 0, 0,
		0, 306, 308, 5, 10, 0, 0, 307, 306, 1, 0, 0, 0, 307, 308, 1, 0, 0, 0, 308,
		312, 1, 0, 0, 0, 309, 311, 3, 2, 1, 0, 310, 309, 1, 0, 0, 0, 311, 314,
		1, 0, 0, 0, 312, 310, 1, 0, 0, 0, 312, 313, 1, 0, 0, 0, 313, 315, 1, 0,
		0, 0, 314, 312, 1, 0, 0, 0, 315, 316, 5, 0, 0, 1, 316, 1, 1, 0, 0, 0, 317,
		320, 3, 4, 2, 0, 318, 320, 3, 10, 5, 0, 319, 317, 1, 0, 0, 0, 319, 318,
		1, 0, 0, 0, 320, 3, 1, 0, 0, 0, 321, 323, 3, 6, 3, 0, 322, 321, 1, 0, 0,
		0, 323, 324, 1, 0, 0, 0, 324, 322, 1, 0, 0, 0, 324, 325, 1, 0, 0, 0, 325,
		328, 1, 0, 0, 0, 326, 328, 3, 8, 4, 0, 327, 322, 1, 0, 0, 0, 327, 326,
		1, 0, 0, 0, 328, 5, 1, 0, 0, 0, 329, 358, 5, 8, 0, 0, 330, 358, 5, 15,
		0, 0, 331, 358, 5, 6, 0, 0, 332, 358, 5, 9, 0, 0, 333, 358, 5, 24, 0, 0,
		334, 358, 5, 16, 0, 0, 335, 358, 5, 17, 0, 0, 336, 358, 5, 2, 0, 0, 337,
		358, 5, 18, 0, 0, 338, 358, 5, 19, 0, 0, 339, 358, 5, 27, 0, 0, 340, 358,
		5, 20, 0, 0, 341, 358, 5, 31, 0, 0, 342, 358, 5, 21, 0, 0, 343, 358, 5,
		22, 0, 0, 344, 358, 5, 28, 0, 0, 345, 358, 5, 32, 0, 0, 346, 358, 5, 37,
		0, 0, 347, 358, 5, 5, 0, 0, 348, 358, 5, 35, 0, 0, 349, 353, 5, 3, 0, 0,
		350, 352, 5, 12, 0, 0, 351, 350, 1, 0, 0, 0, 352, 355, 1, 0, 0, 0, 353,
		351, 1, 0, 0, 0, 353, 354, 1, 0, 0, 0, 354, 356, 1, 0, 0, 0, 355, 353,
		1, 0, 0, 0, 356, 358, 5, 13, 0, 0, 357, 329, 1, 0, 0, 0, 357, 330, 1, 0,
		0, 0, 357, 331, 1, 0, 0, 0, 357, 332, 1, 0, 0, 0, 357, 333, 1, 0, 0, 0,
		357, 334, 1, 0, 0, 0, 357, 335, 1, 0, 0, 0, 357, 336, 1, 0, 0, 0, 357,
		337, 1, 0, 0, 0, 357, 338, 1, 0, 0, 0, 357, 339, 1, 0, 0, 0, 357, 340,
		1, 0, 0, 0, 357, 341, 1, 0, 0, 0, 357, 342, 1, 0, 0, 0, 357, 343, 1, 0,
		0, 0, 357, 344, 1, 0, 0, 0, 357, 345, 1, 0, 0, 0, 357, 346, 1, 0, 0, 0,
		357, 347, 1, 0, 0, 0, 357, 348, 1, 0, 0, 0, 357, 349, 1, 0, 0, 0, 358,
		7, 1, 0, 0, 0, 359, 361, 5, 34, 0, 0, 360, 359, 1, 0, 0, 0, 361, 362, 1,
		0, 0, 0, 362, 360, 1, 0, 0, 0, 362, 363, 1, 0, 0, 0, 363, 9, 1, 0, 0, 0,
		364, 366, 3, 12, 6, 0, 365, 364, 1, 0, 0, 0, 366, 369, 1, 0, 0, 0, 367,
		365, 1, 0, 0, 0, 367, 368, 1, 0, 0, 0, 368, 371, 1, 0, 0, 0, 369, 367,
		1, 0, 0, 0, 370, 372, 3, 14, 7, 0, 371, 370, 1, 0, 0, 0, 372, 373, 1, 0,
		0, 0, 373, 371, 1, 0, 0, 0, 373, 374, 1, 0, 0, 0, 374, 376, 1, 0, 0, 0,
		375, 377, 7, 0, 0, 0, 376, 375, 1, 0, 0, 0, 376, 377, 1, 0, 0, 0, 377,
		11, 1, 0, 0, 0, 378, 379, 5, 91, 0, 0, 379, 380, 5, 107, 0, 0, 380, 381,
		3, 232, 116, 0, 381, 382, 5, 222, 0, 0, 382, 13, 1, 0, 0, 0, 383, 391,
		3, 54, 27, 0, 384, 391, 3, 16, 8, 0, 385, 391, 3, 22, 11, 0, 386, 391,
		3, 26, 13, 0, 387, 391, 3, 28, 14, 0, 388, 391, 3, 158, 79, 0, 389, 391,
		3, 160, 80, 0, 390, 383, 1, 0, 0, 0, 390, 384, 1, 0, 0, 0, 390, 385, 1,
		0, 0, 0, 390, 386, 1, 0, 0, 0, 390, 387, 1, 0, 0, 0, 390, 388, 1, 0, 0,
		0, 390, 389, 1, 0, 0, 0, 391, 15, 1, 0, 0, 0, 392, 394, 5, 132, 0, 0, 393,
		395, 7, 1, 0, 0, 394, 393, 1, 0, 0, 0, 394, 395, 1, 0, 0, 0, 395, 396,
		1, 0, 0, 0, 396, 397, 3, 18, 9, 0, 397, 398, 5, 222, 0, 0, 398, 17, 1,
		0, 0, 0, 399, 401, 5, 196, 0, 0, 400, 399, 1, 0, 0, 0, 400, 401, 1, 0,
		0, 0, 401, 402, 1, 0, 0, 0, 402, 410, 3, 20, 10, 0, 403, 405, 5, 220, 0,
		0, 404, 406, 5, 196, 0, 0, 405, 404, 1, 0, 0, 0, 405, 406, 1, 0, 0, 0,
		406, 407, 1, 0, 0, 0, 407, 409, 3, 20, 10, 0, 408, 403, 1, 0, 0, 0, 409,
		412, 1, 0, 0, 0, 410, 408, 1, 0, 0, 0, 410, 411, 1, 0, 0, 0, 411, 19, 1,
		0, 0, 0, 412, 410, 1, 0, 0, 0, 413, 414, 3, 232, 116, 0, 414, 21, 1, 0,
		0, 0, 415, 430, 5, 107, 0, 0, 416, 418, 3, 232, 116, 0, 417, 416, 1, 0,
		0, 0, 417, 418, 1, 0, 0, 0, 418, 419, 1, 0, 0, 0, 419, 423, 5, 218, 0,
		0, 420, 422, 3, 24, 12, 0, 421, 420, 1, 0, 0, 0, 422, 425, 1, 0, 0, 0,
		423, 421, 1, 0, 0, 0, 423, 424, 1, 0, 0, 0, 424, 426, 1, 0, 0, 0, 425,
		423, 1, 0, 0, 0, 426, 431, 5, 219, 0, 0, 427, 428, 3, 232, 116, 0, 428,
		429, 5, 222, 0, 0, 429, 431, 1, 0, 0, 0, 430, 417, 1, 0, 0, 0, 430, 427,
		1, 0, 0, 0, 431, 23, 1, 0, 0, 0, 432, 438, 3, 54, 27, 0, 433, 438, 3, 16,
		8, 0, 434, 438, 3, 26, 13, 0, 435, 438, 3, 28, 14, 0, 436, 438, 3, 158,
		79, 0, 437, 432, 1, 0, 0, 0, 437, 433, 1, 0, 0, 0, 437, 434, 1, 0, 0, 0,
		437, 435, 1, 0, 0, 0, 437, 436, 1, 0, 0, 0, 438, 25, 1, 0, 0, 0, 439, 441,
		3, 42, 21, 0, 440, 439, 1, 0, 0, 0, 440, 441, 1, 0, 0, 0, 441, 442, 1,
		0, 0, 0, 442, 444, 5, 86, 0, 0, 443, 445, 5, 200, 0, 0, 444, 443, 1, 0,
		0, 0, 444, 445, 1, 0, 0, 0, 445, 446, 1, 0, 0, 0, 446, 447, 3, 292, 146,
		0, 447, 448, 5, 214, 0, 0, 448, 449, 3, 118, 59, 0, 449, 455, 5, 215, 0,
		0, 450, 452, 5, 221, 0, 0, 451, 453, 5, 213, 0, 0, 452, 451, 1, 0, 0, 0,
		452, 453, 1, 0, 0, 0, 453, 454, 1, 0, 0, 0, 454, 456, 3, 122, 61, 0, 455,
		450, 1, 0, 0, 0, 455, 456, 1, 0, 0, 0, 456, 457, 1, 0, 0, 0, 457, 458,
		3, 58, 29, 0, 458, 27, 1, 0, 0, 0, 459, 461, 3, 42, 21, 0, 460, 459, 1,
		0, 0, 0, 460, 461, 1, 0, 0, 0, 461, 463, 1, 0, 0, 0, 462, 464, 5, 114,
		0, 0, 463, 462, 1, 0, 0, 0, 463, 464, 1, 0, 0, 0, 464, 466, 1, 0, 0, 0,
		465, 467, 3, 290, 145, 0, 466, 465, 1, 0, 0, 0, 466, 467, 1, 0, 0, 0, 467,
		469, 1, 0, 0, 0, 468, 470, 5, 112, 0, 0, 469, 468, 1, 0, 0, 0, 469, 470,
		1, 0, 0, 0, 470, 487, 1, 0, 0, 0, 471, 472, 3, 30, 15, 0, 472, 475, 3,
		292, 146, 0, 473, 474, 5, 80, 0, 0, 474, 476, 3, 222, 111, 0, 475, 473,
		1, 0, 0, 0, 475, 476, 1, 0, 0, 0, 476, 479, 1, 0, 0, 0, 477, 478, 5, 90,
		0, 0, 478, 480, 3, 32, 16, 0, 479, 477, 1, 0, 0, 0, 479, 480, 1, 0, 0,
		0, 480, 488, 1, 0, 0, 0, 481, 482, 5, 100, 0, 0, 482, 485, 3, 292, 146,
		0, 483, 484, 5, 80, 0, 0, 484, 486, 3, 32, 16, 0, 485, 483, 1, 0, 0, 0,
		485, 486, 1, 0, 0, 0, 486, 488, 1, 0, 0, 0, 487, 471, 1, 0, 0, 0, 487,
		481, 1, 0, 0, 0, 488, 489, 1, 0, 0, 0, 489, 493, 5, 218, 0, 0, 490, 492,
		3, 132, 66, 0, 491, 490, 1, 0, 0, 0, 492, 495, 1, 0, 0, 0, 493, 491, 1,
		0, 0, 0, 493, 494, 1, 0, 0, 0, 494, 496, 1, 0, 0, 0, 495, 493, 1, 0, 0,
		0, 496, 497, 5, 219, 0, 0, 497, 29, 1, 0, 0, 0, 498, 499, 7, 2, 0, 0, 499,
		31, 1, 0, 0, 0, 500, 505, 3, 222, 111, 0, 501, 502, 5, 220, 0, 0, 502,
		504, 3, 222, 111, 0, 503, 501, 1, 0, 0, 0, 504, 507, 1, 0, 0, 0, 505, 503,
		1, 0, 0, 0, 505, 506, 1, 0, 0, 0, 506, 33, 1, 0, 0, 0, 507, 505, 1, 0,
		0, 0, 508, 513, 3, 38, 19, 0, 509, 510, 5, 220, 0, 0, 510, 512, 3, 38,
		19, 0, 511, 509, 1, 0, 0, 0, 512, 515, 1, 0, 0, 0, 513, 511, 1, 0, 0, 0,
		513, 514, 1, 0, 0, 0, 514, 35, 1, 0, 0, 0, 515, 513, 1, 0, 0, 0, 516, 521,
		3, 40, 20, 0, 517, 518, 5, 220, 0, 0, 518, 520, 3, 40, 20, 0, 519, 517,
		1, 0, 0, 0, 520, 523, 1, 0, 0, 0, 521, 519, 1, 0, 0, 0, 521, 522, 1, 0,
		0, 0, 522, 37, 1, 0, 0, 0, 523, 521, 1, 0, 0, 0, 524, 526, 3, 42, 21, 0,
		525, 524, 1, 0, 0, 0, 525, 526, 1, 0, 0, 0, 526, 527, 1, 0, 0, 0, 527,
		528, 3, 292, 146, 0, 528, 39, 1, 0, 0, 0, 529, 531, 3, 42, 21, 0, 530,
		529, 1, 0, 0, 0, 530, 531, 1, 0, 0, 0, 531, 532, 1, 0, 0, 0, 532, 533,
		3, 292, 146, 0, 533, 536, 5, 223, 0, 0, 534, 537, 3, 222, 111, 0, 535,
		537, 3, 302, 151, 0, 536, 534, 1, 0, 0, 0, 536, 535, 1, 0, 0, 0, 537, 41,
		1, 0, 0, 0, 538, 540, 3, 44, 22, 0, 539, 538, 1, 0, 0, 0, 540, 541, 1,
		0, 0, 0, 541, 539, 1, 0, 0, 0, 541, 542, 1, 0, 0, 0, 542, 43, 1, 0, 0,
		0, 543, 547, 5, 43, 0, 0, 544, 545, 3, 292, 146, 0, 545, 546, 5, 221, 0,
		0, 546, 548, 1, 0, 0, 0, 547, 544, 1, 0, 0, 0, 547, 548, 1, 0, 0, 0, 548,
		549, 1, 0, 0, 0, 549, 554, 3, 46, 23, 0, 550, 551, 5, 220, 0, 0, 551, 553,
		3, 46, 23, 0, 552, 550, 1, 0, 0, 0, 553, 556, 1, 0, 0, 0, 554, 552, 1,
		0, 0, 0, 554, 555, 1, 0, 0, 0, 555, 557, 1, 0, 0, 0, 556, 554, 1, 0, 0,
		0, 557, 558, 5, 217, 0, 0, 558, 45, 1, 0, 0, 0, 559, 561, 3, 230, 115,
		0, 560, 562, 3, 238, 119, 0, 561, 560, 1, 0, 0, 0, 561, 562, 1, 0, 0, 0,
		562, 47, 1, 0, 0, 0, 563, 565, 3, 50, 25, 0, 564, 563, 1, 0, 0, 0, 565,
		568, 1, 0, 0, 0, 566, 564, 1, 0, 0, 0, 566, 567, 1, 0, 0, 0, 567, 49, 1,
		0, 0, 0, 568, 566, 1, 0, 0, 0, 569, 573, 3, 54, 27, 0, 570, 573, 3, 26,
		13, 0, 571, 573, 3, 28, 14, 0, 572, 569, 1, 0, 0, 0, 572, 570, 1, 0, 0,
		0, 572, 571, 1, 0, 0, 0, 573, 51, 1, 0, 0, 0, 574, 575, 5, 228, 0, 0, 575,
		576, 5, 221, 0, 0, 576, 53, 1, 0, 0, 0, 577, 603, 3, 52, 26, 0, 578, 603,
		3, 58, 29, 0, 579, 603, 3, 60, 30, 0, 580, 603, 3, 70, 35, 0, 581, 603,
		3, 72, 36, 0, 582, 603, 3, 74, 37, 0, 583, 603, 3, 80, 40, 0, 584, 603,
		3, 88, 44, 0, 585, 603, 3, 90, 45, 0, 586, 603, 3, 92, 46, 0, 587, 588,
		3, 212, 106, 0, 588, 589, 5, 222, 0, 0, 589, 603, 1, 0, 0, 0, 590, 603,
		3, 124, 62, 0, 591, 603, 3, 130, 65, 0, 592, 603, 3, 128, 64, 0, 593, 603,
		3, 94, 47, 0, 594, 603, 3, 96, 48, 0, 595, 603, 3, 98, 49, 0, 596, 603,
		3, 100, 50, 0, 597, 603, 3, 106, 53, 0, 598, 603, 3, 108, 54, 0, 599, 603,
		3, 110, 55, 0, 600, 603, 3, 56, 28, 0, 601, 603, 3, 112, 56, 0, 602, 577,
		1, 0, 0, 0, 602, 578, 1, 0, 0, 0, 602, 579, 1, 0, 0, 0, 602, 580, 1, 0,
		0, 0, 602, 581, 1, 0, 0, 0, 602, 582, 1, 0, 0, 0, 602, 583, 1, 0, 0, 0,
		602, 584, 1, 0, 0, 0, 602, 585, 1, 0, 0, 0, 602, 586, 1, 0, 0, 0, 602,
		587, 1, 0, 0, 0, 602, 590, 1, 0, 0, 0, 602, 591, 1, 0, 0, 0, 602, 592,
		1, 0, 0, 0, 602, 593, 1, 0, 0, 0, 602, 594, 1, 0, 0, 0, 602, 595, 1, 0,
		0, 0, 602, 596, 1, 0, 0, 0, 602, 597, 1, 0, 0, 0, 602, 598, 1, 0, 0, 0,
		602, 599, 1, 0, 0, 0, 602, 600, 1, 0, 0, 0, 602, 601, 1, 0, 0, 0, 603,
		55, 1, 0, 0, 0, 604, 605, 5, 222, 0, 0, 605, 57, 1, 0, 0, 0, 606, 607,
		5, 218, 0, 0, 607, 608, 3, 48, 24, 0, 608, 609, 5, 219, 0, 0, 609, 59,
		1, 0, 0, 0, 610, 611, 5, 89, 0, 0, 611, 612, 3, 166, 83, 0, 612, 616, 3,
		54, 27, 0, 613, 615, 3, 62, 31, 0, 614, 613, 1, 0, 0, 0, 615, 618, 1, 0,
		0, 0, 616, 614, 1, 0, 0, 0, 616, 617, 1, 0, 0, 0, 617, 620, 1, 0, 0, 0,
		618, 616, 1, 0, 0, 0, 619, 621, 3, 66, 33, 0, 620, 619, 1, 0, 0, 0, 620,
		621, 1, 0, 0, 0, 621, 639, 1, 0, 0, 0, 622, 623, 5, 89, 0, 0, 623, 624,
		3, 166, 83, 0, 624, 625, 5, 221, 0, 0, 625, 629, 3, 48, 24, 0, 626, 628,
		3, 64, 32, 0, 627, 626, 1, 0, 0, 0, 628, 631, 1, 0, 0, 0, 629, 627, 1,
		0, 0, 0, 629, 630, 1, 0, 0, 0, 630, 633, 1, 0, 0, 0, 631, 629, 1, 0, 0,
		0, 632, 634, 3, 68, 34, 0, 633, 632, 1, 0, 0, 0, 633, 634, 1, 0, 0, 0,
		634, 635, 1, 0, 0, 0, 635, 636, 5, 73, 0, 0, 636, 637, 5, 222, 0, 0, 637,
		639, 1, 0, 0, 0, 638, 610, 1, 0, 0, 0, 638, 622, 1, 0, 0, 0, 639, 61, 1,
		0, 0, 0, 640, 641, 5, 67, 0, 0, 641, 642, 3, 166, 83, 0, 642, 643, 3, 54,
		27, 0, 643, 63, 1, 0, 0, 0, 644, 645, 5, 67, 0, 0, 645, 646, 3, 166, 83,
		0, 646, 647, 5, 221, 0, 0, 647, 648, 3, 48, 24, 0, 648, 65, 1, 0, 0, 0,
		649, 650, 5, 66, 0, 0, 650, 651, 3, 54, 27, 0, 651, 67, 1, 0, 0, 0, 652,
		653, 5, 66, 0, 0, 653, 654, 5, 221, 0, 0, 654, 655, 3, 48, 24, 0, 655,
		69, 1, 0, 0, 0, 656, 657, 5, 134, 0, 0, 657, 664, 3, 166, 83, 0, 658, 665,
		3, 54, 27, 0, 659, 660, 5, 221, 0, 0, 660, 661, 3, 48, 24, 0, 661, 662,
		5, 75, 0, 0, 662, 663, 5, 222, 0, 0, 663, 665, 1, 0, 0, 0, 664, 658, 1,
		0, 0, 0, 664, 659, 1, 0, 0, 0, 665, 71, 1, 0, 0, 0, 666, 667, 5, 62, 0,
		0, 667, 668, 3, 54, 27, 0, 668, 669, 5, 134, 0, 0, 669, 670, 3, 166, 83,
		0, 670, 671, 5, 222, 0, 0, 671, 73, 1, 0, 0, 0, 672, 673, 5, 84, 0, 0,
		673, 675, 5, 214, 0, 0, 674, 676, 3, 76, 38, 0, 675, 674, 1, 0, 0, 0, 675,
		676, 1, 0, 0, 0, 676, 677, 1, 0, 0, 0, 677, 679, 5, 222, 0, 0, 678, 680,
		3, 164, 82, 0, 679, 678, 1, 0, 0, 0, 679, 680, 1, 0, 0, 0, 680, 681, 1,
		0, 0, 0, 681, 683, 5, 222, 0, 0, 682, 684, 3, 78, 39, 0, 683, 682, 1, 0,
		0, 0, 683, 684, 1, 0, 0, 0, 684, 685, 1, 0, 0, 0, 685, 692, 5, 215, 0,
		0, 686, 693, 3, 54, 27, 0, 687, 688, 5, 221, 0, 0, 688, 689, 3, 48, 24,
		0, 689, 690, 5, 71, 0, 0, 690, 691, 5, 222, 0, 0, 691, 693, 1, 0, 0, 0,
		692, 686, 1, 0, 0, 0, 692, 687, 1, 0, 0, 0, 693, 75, 1, 0, 0, 0, 694, 695,
		3, 164, 82, 0, 695, 77, 1, 0, 0, 0, 696, 697, 3, 164, 82, 0, 697, 79, 1,
		0, 0, 0, 698, 699, 5, 124, 0, 0, 699, 725, 3, 166, 83, 0, 700, 702, 5,
		218, 0, 0, 701, 703, 5, 222, 0, 0, 702, 701, 1, 0, 0, 0, 702, 703, 1, 0,
		0, 0, 703, 708, 1, 0, 0, 0, 704, 707, 3, 82, 41, 0, 705, 707, 3, 84, 42,
		0, 706, 704, 1, 0, 0, 0, 706, 705, 1, 0, 0, 0, 707, 710, 1, 0, 0, 0, 708,
		706, 1, 0, 0, 0, 708, 709, 1, 0, 0, 0, 709, 711, 1, 0, 0, 0, 710, 708,
		1, 0, 0, 0, 711, 726, 5, 219, 0, 0, 712, 714, 5, 221, 0, 0, 713, 715, 5,
		222, 0, 0, 714, 713, 1, 0, 0, 0, 714, 715, 1, 0, 0, 0, 715, 720, 1, 0,
		0, 0, 716, 719, 3, 82, 41, 0, 717, 719, 3, 84, 42, 0, 718, 716, 1, 0, 0,
		0, 718, 717, 1, 0, 0, 0, 719, 722, 1, 0, 0, 0, 720, 718, 1, 0, 0, 0, 720,
		721, 1, 0, 0, 0, 721, 723, 1, 0, 0, 0, 722, 720, 1, 0, 0, 0, 723, 724,
		5, 74, 0, 0, 724, 726, 5, 222, 0, 0, 725, 700, 1, 0, 0, 0, 725, 712, 1,
		0, 0, 0, 726, 81, 1, 0, 0, 0, 727, 728, 5, 52, 0, 0, 728, 729, 3, 180,
		90, 0, 729, 733, 7, 3, 0, 0, 730, 732, 5, 222, 0, 0, 731, 730, 1, 0, 0,
		0, 732, 735, 1, 0, 0, 0, 733, 731, 1, 0, 0, 0, 733, 734, 1, 0, 0, 0, 734,
		736, 1, 0, 0, 0, 735, 733, 1, 0, 0, 0, 736, 737, 3, 48, 24, 0, 737, 83,
		1, 0, 0, 0, 738, 739, 5, 61, 0, 0, 739, 743, 7, 3, 0, 0, 740, 742, 5, 222,
		0, 0, 741, 740, 1, 0, 0, 0, 742, 745, 1, 0, 0, 0, 743, 741, 1, 0, 0, 0,
		743, 744, 1, 0, 0, 0, 744, 746, 1, 0, 0, 0, 745, 743, 1, 0, 0, 0, 746,
		747, 3, 48, 24, 0, 747, 85, 1, 0, 0, 0, 748, 749, 5, 52, 0, 0, 749, 752,
		3, 180, 90, 0, 750, 752, 5, 61, 0, 0, 751, 748, 1, 0, 0, 0, 751, 750, 1,
		0, 0, 0, 752, 753, 1, 0, 0, 0, 753, 757, 7, 3, 0, 0, 754, 756, 5, 222,
		0, 0, 755, 754, 1, 0, 0, 0, 756, 759, 1, 0, 0, 0, 757, 755, 1, 0, 0, 0,
		757, 758, 1, 0, 0, 0, 758, 761, 1, 0, 0, 0, 759, 757, 1, 0, 0, 0, 760,
		751, 1, 0, 0, 0, 761, 762, 1, 0, 0, 0, 762, 760, 1, 0, 0, 0, 762, 763,
		1, 0, 0, 0, 763, 764, 1, 0, 0, 0, 764, 765, 3, 48, 24, 0, 765, 87, 1, 0,
		0, 0, 766, 768, 5, 50, 0, 0, 767, 769, 3, 180, 90, 0, 768, 767, 1, 0, 0,
		0, 768, 769, 1, 0, 0, 0, 769, 770, 1, 0, 0, 0, 770, 771, 5, 222, 0, 0,
		771, 89, 1, 0, 0, 0, 772, 774, 5, 57, 0, 0, 773, 775, 3, 180, 90, 0, 774,
		773, 1, 0, 0, 0, 774, 775, 1, 0, 0, 0, 775, 776, 1, 0, 0, 0, 776, 777,
		5, 222, 0, 0, 777, 91, 1, 0, 0, 0, 778, 780, 5, 121, 0, 0, 779, 781, 3,
		180, 90, 0, 780, 779, 1, 0, 0, 0, 780, 781, 1, 0, 0, 0, 781, 782, 1, 0,
		0, 0, 782, 783, 5, 222, 0, 0, 783, 93, 1, 0, 0, 0, 784, 785, 3, 180, 90,
		0, 785, 786, 5, 222, 0, 0, 786, 95, 1, 0, 0, 0, 787, 788, 5, 131, 0, 0,
		788, 789, 5, 214, 0, 0, 789, 790, 3, 262, 131, 0, 790, 791, 5, 215, 0,
		0, 791, 792, 5, 222, 0, 0, 792, 97, 1, 0, 0, 0, 793, 838, 5, 85, 0, 0,
		794, 795, 5, 214, 0, 0, 795, 796, 3, 180, 90, 0, 796, 797, 5, 46, 0, 0,
		797, 798, 3, 196, 98, 0, 798, 799, 5, 215, 0, 0, 799, 839, 1, 0, 0, 0,
		800, 801, 5, 214, 0, 0, 801, 802, 3, 264, 132, 0, 802, 804, 5, 46, 0, 0,
		803, 805, 5, 200, 0, 0, 804, 803, 1, 0, 0, 0, 804, 805, 1, 0, 0, 0, 805,
		806, 1, 0, 0, 0, 806, 812, 3, 192, 96, 0, 807, 809, 5, 166, 0, 0, 808,
		810, 5, 200, 0, 0, 809, 808, 1, 0, 0, 0, 809, 810, 1, 0, 0, 0, 810, 811,
		1, 0, 0, 0, 811, 813, 3, 264, 132, 0, 812, 807, 1, 0, 0, 0, 812, 813, 1,
		0, 0, 0, 813, 814, 1, 0, 0, 0, 814, 815, 5, 215, 0, 0, 815, 839, 1, 0,
		0, 0, 816, 817, 5, 214, 0, 0, 817, 818, 3, 180, 90, 0, 818, 819, 5, 46,
		0, 0, 819, 825, 3, 192, 96, 0, 820, 822, 5, 166, 0, 0, 821, 823, 5, 200,
		0, 0, 822, 821, 1, 0, 0, 0, 822, 823, 1, 0, 0, 0, 823, 824, 1, 0, 0, 0,
		824, 826, 3, 264, 132, 0, 825, 820, 1, 0, 0, 0, 825, 826, 1, 0, 0, 0, 826,
		827, 1, 0, 0, 0, 827, 828, 5, 215, 0, 0, 828, 839, 1, 0, 0, 0, 829, 830,
		5, 214, 0, 0, 830, 831, 3, 264, 132, 0, 831, 832, 5, 46, 0, 0, 832, 833,
		5, 102, 0, 0, 833, 834, 5, 214, 0, 0, 834, 835, 3, 286, 143, 0, 835, 836,
		5, 215, 0, 0, 836, 837, 5, 215, 0, 0, 837, 839, 1, 0, 0, 0, 838, 794, 1,
		0, 0, 0, 838, 800, 1, 0, 0, 0, 838, 816, 1, 0, 0, 0, 838, 829, 1, 0, 0,
		0, 839, 846, 1, 0, 0, 0, 840, 847, 3, 54, 27, 0, 841, 842, 5, 221, 0, 0,
		842, 843, 3, 48, 24, 0, 843, 844, 5, 72, 0, 0, 844, 845, 5, 222, 0, 0,
		845, 847, 1, 0, 0, 0, 846, 840, 1, 0, 0, 0, 846, 841, 1, 0, 0, 0, 847,
		99, 1, 0, 0, 0, 848, 849, 5, 127, 0, 0, 849, 865, 3, 58, 29, 0, 850, 852,
		3, 102, 51, 0, 851, 850, 1, 0, 0, 0, 852, 853, 1, 0, 0, 0, 853, 851, 1,
		0, 0, 0, 853, 854, 1, 0, 0, 0, 854, 856, 1, 0, 0, 0, 855, 857, 3, 104,
		52, 0, 856, 855, 1, 0, 0, 0, 856, 857, 1, 0, 0, 0, 857, 866, 1, 0, 0, 0,
		858, 860, 3, 102, 51, 0, 859, 858, 1, 0, 0, 0, 860, 863, 1, 0, 0, 0, 861,
		859, 1, 0, 0, 0, 861, 862, 1, 0, 0, 0, 862, 864, 1, 0, 0, 0, 863, 861,
		1, 0, 0, 0, 864, 866, 3, 104, 52, 0, 865, 851, 1, 0, 0, 0, 865, 861, 1,
		0, 0, 0, 866, 101, 1, 0, 0, 0, 867, 868, 5, 53, 0, 0, 868, 869, 5, 214,
		0, 0, 869, 874, 3, 222, 111, 0, 870, 871, 5, 201, 0, 0, 871, 873, 3, 222,
		111, 0, 872, 870, 1, 0, 0, 0, 873, 876, 1, 0, 0, 0, 874, 872, 1, 0, 0,
		0, 874, 875, 1, 0, 0, 0, 875, 878, 1, 0, 0, 0, 876, 874, 1, 0, 0, 0, 877,
		879, 5, 227, 0, 0, 878, 877, 1, 0, 0, 0, 878, 879, 1, 0, 0, 0, 879, 880,
		1, 0, 0, 0, 880, 881, 5, 215, 0, 0, 881, 882, 3, 58, 29, 0, 882, 103, 1,
		0, 0, 0, 883, 884, 5, 82, 0, 0, 884, 885, 3, 58, 29, 0, 885, 105, 1, 0,
		0, 0, 886, 887, 5, 125, 0, 0, 887, 888, 3, 180, 90, 0, 888, 889, 5, 222,
		0, 0, 889, 107, 1, 0, 0, 0, 890, 891, 5, 88, 0, 0, 891, 892, 3, 292, 146,
		0, 892, 893, 5, 222, 0, 0, 893, 109, 1, 0, 0, 0, 894, 895, 5, 60, 0, 0,
		895, 896, 5, 214, 0, 0, 896, 897, 3, 114, 57, 0, 897, 904, 5, 215, 0, 0,
		898, 905, 3, 54, 27, 0, 899, 900, 5, 221, 0, 0, 900, 901, 3, 48, 24, 0,
		901, 902, 5, 70, 0, 0, 902, 903, 5, 222, 0, 0, 903, 905, 1, 0, 0, 0, 904,
		898, 1, 0, 0, 0, 904, 899, 1, 0, 0, 0, 905, 111, 1, 0, 0, 0, 906, 908,
		3, 4, 2, 0, 907, 906, 1, 0, 0, 0, 908, 909, 1, 0, 0, 0, 909, 907, 1, 0,
		0, 0, 909, 910, 1, 0, 0, 0, 910, 113, 1, 0, 0, 0, 911, 916, 3, 116, 58,
		0, 912, 913, 5, 220, 0, 0, 913, 915, 3, 116, 58, 0, 914, 912, 1, 0, 0,
		0, 915, 918, 1, 0, 0, 0, 916, 914, 1, 0, 0, 0, 916, 917, 1, 0, 0, 0, 917,
		115, 1, 0, 0, 0, 918, 916, 1, 0, 0, 0, 919, 920, 5, 138, 0, 0, 920, 923,
		5, 223, 0, 0, 921, 924, 3, 252, 126, 0, 922, 924, 5, 231, 0, 0, 923, 921,
		1, 0, 0, 0, 923, 922, 1, 0, 0, 0, 924, 932, 1, 0, 0, 0, 925, 926, 5, 139,
		0, 0, 926, 927, 5, 223, 0, 0, 927, 932, 5, 235, 0, 0, 928, 929, 5, 140,
		0, 0, 929, 930, 5, 223, 0, 0, 930, 932, 3, 252, 126, 0, 931, 919, 1, 0,
		0, 0, 931, 925, 1, 0, 0, 0, 931, 928, 1, 0, 0, 0, 932, 117, 1, 0, 0, 0,
		933, 935, 3, 120, 60, 0, 934, 933, 1, 0, 0, 0, 934, 935, 1, 0, 0, 0, 935,
		940, 1, 0, 0, 0, 936, 937, 5, 220, 0, 0, 937, 939, 3, 120, 60, 0, 938,
		936, 1, 0, 0, 0, 939, 942, 1, 0, 0, 0, 940, 938, 1, 0, 0, 0, 940, 941,
		1, 0, 0, 0, 941, 944, 1, 0, 0, 0, 942, 940, 1, 0, 0, 0, 943, 945, 5, 220,
		0, 0, 944, 943, 1, 0, 0, 0, 944, 945, 1, 0, 0, 0, 945, 119, 1, 0, 0, 0,
		946, 948, 3, 42, 21, 0, 947, 946, 1, 0, 0, 0, 947, 948, 1, 0, 0, 0, 948,
		952, 1, 0, 0, 0, 949, 951, 3, 296, 148, 0, 950, 949, 1, 0, 0, 0, 951, 954,
		1, 0, 0, 0, 952, 950, 1, 0, 0, 0, 952, 953, 1, 0, 0, 0, 953, 956, 1, 0,
		0, 0, 954, 952, 1, 0, 0, 0, 955, 957, 5, 213, 0, 0, 956, 955, 1, 0, 0,
		0, 956, 957, 1, 0, 0, 0, 957, 959, 1, 0, 0, 0, 958, 960, 3, 122, 61, 0,
		959, 958, 1, 0, 0, 0, 959, 960, 1, 0, 0, 0, 960, 962, 1, 0, 0, 0, 961,
		963, 5, 200, 0, 0, 962, 961, 1, 0, 0, 0, 962, 963, 1, 0, 0, 0, 963, 965,
		1, 0, 0, 0, 964, 966, 5, 197, 0, 0, 965, 964, 1, 0, 0, 0, 965, 966, 1,
		0, 0, 0, 966, 967, 1, 0, 0, 0, 967, 968, 3, 154, 77, 0, 968, 121, 1, 0,
		0, 0, 969, 970, 6, 61, -1, 0, 970, 974, 5, 51, 0, 0, 971, 974, 3, 302,
		151, 0, 972, 974, 3, 222, 111, 0, 973, 969, 1, 0, 0, 0, 973, 971, 1, 0,
		0, 0, 973, 972, 1, 0, 0, 0, 974, 980, 1, 0, 0, 0, 975, 976, 10, 1, 0, 0,
		976, 977, 5, 201, 0, 0, 977, 979, 3, 122, 61, 2, 978, 975, 1, 0, 0, 0,
		979, 982, 1, 0, 0, 0, 980, 978, 1, 0, 0, 0, 980, 981, 1, 0, 0, 0, 981,
		123, 1, 0, 0, 0, 982, 980, 1, 0, 0, 0, 983, 984, 5, 87, 0, 0, 984, 989,
		3, 126, 63, 0, 985, 986, 5, 220, 0, 0, 986, 988, 3, 126, 63, 0, 987, 985,
		1, 0, 0, 0, 988, 991, 1, 0, 0, 0, 989, 987, 1, 0, 0, 0, 989, 990, 1, 0,
		0, 0, 990, 992, 1, 0, 0, 0, 991, 989, 1, 0, 0, 0, 992, 993, 5, 222, 0,
		0, 993, 125, 1, 0, 0, 0, 994, 1003, 5, 227, 0, 0, 995, 996, 5, 211, 0,
		0, 996, 1003, 3, 264, 132, 0, 997, 998, 5, 211, 0, 0, 998, 999, 5, 218,
		0, 0, 999, 1000, 3, 180, 90, 0, 1000, 1001, 5, 219, 0, 0, 1001, 1003, 1,
		0, 0, 0, 1002, 994, 1, 0, 0, 0, 1002, 995, 1, 0, 0, 0, 1002, 997, 1, 0,
		0, 0, 1003, 127, 1, 0, 0, 0, 1004, 1005, 5, 65, 0, 0, 1005, 1006, 3, 164,
		82, 0, 1006, 1007, 5, 222, 0, 0, 1007, 129, 1, 0, 0, 0, 1008, 1009, 5,
		122, 0, 0, 1009, 1014, 3, 154, 77, 0, 1010, 1011, 5, 220, 0, 0, 1011, 1013,
		3, 154, 77, 0, 1012, 1010, 1, 0, 0, 0, 1013, 1016, 1, 0, 0, 0, 1014, 1012,
		1, 0, 0, 0, 1014, 1015, 1, 0, 0, 0, 1015, 1017, 1, 0, 0, 0, 1016, 1014,
		1, 0, 0, 0, 1017, 1018, 5, 222, 0, 0, 1018, 131, 1, 0, 0, 0, 1019, 1020,
		5, 132, 0, 0, 1020, 1021, 3, 236, 118, 0, 1021, 1022, 3, 134, 67, 0, 1022,
		1081, 1, 0, 0, 0, 1023, 1025, 3, 42, 21, 0, 1024, 1023, 1, 0, 0, 0, 1024,
		1025, 1, 0, 0, 0, 1025, 1026, 1, 0, 0, 0, 1026, 1028, 3, 150, 75, 0, 1027,
		1029, 3, 122, 61, 0, 1028, 1027, 1, 0, 0, 0, 1028, 1029, 1, 0, 0, 0, 1029,
		1030, 1, 0, 0, 0, 1030, 1035, 3, 154, 77, 0, 1031, 1032, 5, 220, 0, 0,
		1032, 1034, 3, 154, 77, 0, 1033, 1031, 1, 0, 0, 0, 1034, 1037, 1, 0, 0,
		0, 1035, 1033, 1, 0, 0, 0, 1035, 1036, 1, 0, 0, 0, 1036, 1038, 1, 0, 0,
		0, 1037, 1035, 1, 0, 0, 0, 1038, 1039, 5, 222, 0, 0, 1039, 1081, 1, 0,
		0, 0, 1040, 1042, 3, 42, 21, 0, 1041, 1040, 1, 0, 0, 0, 1041, 1042, 1,
		0, 0, 0, 1042, 1044, 1, 0, 0, 0, 1043, 1045, 3, 152, 76, 0, 1044, 1043,
		1, 0, 0, 0, 1044, 1045, 1, 0, 0, 0, 1045, 1046, 1, 0, 0, 0, 1046, 1048,
		5, 56, 0, 0, 1047, 1049, 3, 122, 61, 0, 1048, 1047, 1, 0, 0, 0, 1048, 1049,
		1, 0, 0, 0, 1049, 1050, 1, 0, 0, 0, 1050, 1055, 3, 156, 78, 0, 1051, 1052,
		5, 220, 0, 0, 1052, 1054, 3, 156, 78, 0, 1053, 1051, 1, 0, 0, 0, 1054,
		1057, 1, 0, 0, 0, 1055, 1053, 1, 0, 0, 0, 1055, 1056, 1, 0, 0, 0, 1056,
		1058, 1, 0, 0, 0, 1057, 1055, 1, 0, 0, 0, 1058, 1059, 5, 222, 0, 0, 1059,
		1081, 1, 0, 0, 0, 1060, 1062, 3, 42, 21, 0, 1061, 1060, 1, 0, 0, 0, 1061,
		1062, 1, 0, 0, 0, 1062, 1064, 1, 0, 0, 0, 1063, 1065, 3, 152, 76, 0, 1064,
		1063, 1, 0, 0, 0, 1064, 1065, 1, 0, 0, 0, 1065, 1066, 1, 0, 0, 0, 1066,
		1068, 5, 86, 0, 0, 1067, 1069, 5, 200, 0, 0, 1068, 1067, 1, 0, 0, 0, 1068,
		1069, 1, 0, 0, 0, 1069, 1070, 1, 0, 0, 0, 1070, 1071, 3, 292, 146, 0, 1071,
		1072, 5, 214, 0, 0, 1072, 1073, 3, 118, 59, 0, 1073, 1076, 5, 215, 0, 0,
		1074, 1077, 3, 144, 72, 0, 1075, 1077, 3, 146, 73, 0, 1076, 1074, 1, 0,
		0, 0, 1076, 1075, 1, 0, 0, 0, 1076, 1077, 1, 0, 0, 0, 1077, 1078, 1, 0,
		0, 0, 1078, 1079, 3, 148, 74, 0, 1079, 1081, 1, 0, 0, 0, 1080, 1019, 1,
		0, 0, 0, 1080, 1024, 1, 0, 0, 0, 1080, 1041, 1, 0, 0, 0, 1080, 1061, 1,
		0, 0, 0, 1081, 133, 1, 0, 0, 0, 1082, 1092, 5, 222, 0, 0, 1083, 1087, 5,
		218, 0, 0, 1084, 1086, 3, 136, 68, 0, 1085, 1084, 1, 0, 0, 0, 1086, 1089,
		1, 0, 0, 0, 1087, 1085, 1, 0, 0, 0, 1087, 1088, 1, 0, 0, 0, 1088, 1090,
		1, 0, 0, 0, 1089, 1087, 1, 0, 0, 0, 1090, 1092, 5, 219, 0, 0, 1091, 1082,
		1, 0, 0, 0, 1091, 1083, 1, 0, 0, 0, 1092, 135, 1, 0, 0, 0, 1093, 1096,
		3, 138, 69, 0, 1094, 1096, 3, 140, 70, 0, 1095, 1093, 1, 0, 0, 0, 1095,
		1094, 1, 0, 0, 0, 1096, 137, 1, 0, 0, 0, 1097, 1098, 3, 230, 115, 0, 1098,
		1099, 5, 194, 0, 0, 1099, 1100, 3, 292, 146, 0, 1100, 1101, 5, 95, 0, 0,
		1101, 1102, 3, 236, 118, 0, 1102, 1103, 5, 222, 0, 0, 1103, 139, 1, 0,
		0, 0, 1104, 1105, 3, 142, 71, 0, 1105, 1111, 5, 46, 0, 0, 1106, 1112, 3,
		296, 148, 0, 1107, 1109, 3, 296, 148, 0, 1108, 1107, 1, 0, 0, 0, 1108,
		1109, 1, 0, 0, 0, 1109, 1110, 1, 0, 0, 0, 1110, 1112, 3, 292, 146, 0, 1111,
		1106, 1, 0, 0, 0, 1111, 1108, 1, 0, 0, 0, 1112, 1113, 1, 0, 0, 0, 1113,
		1114, 5, 222, 0, 0, 1114, 141, 1, 0, 0, 0, 1115, 1116, 3, 230, 115, 0,
		1116, 1117, 5, 194, 0, 0, 1117, 1119, 1, 0, 0, 0, 1118, 1115, 1, 0, 0,
		0, 1118, 1119, 1, 0, 0, 0, 1119, 1120, 1, 0, 0, 0, 1120, 1121, 3, 292,
		146, 0, 1121, 143, 1, 0, 0, 0, 1122, 1123, 5, 221, 0, 0, 1123, 1125, 3,
		292, 146, 0, 1124, 1126, 3, 238, 119, 0, 1125, 1124, 1, 0, 0, 0, 1125,
		1126, 1, 0, 0, 0, 1126, 145, 1, 0, 0, 0, 1127, 1129, 5, 221, 0, 0, 1128,
		1130, 5, 213, 0, 0, 1129, 1128, 1, 0, 0, 0, 1129, 1130, 1, 0, 0, 0, 1130,
		1131, 1, 0, 0, 0, 1131, 1132, 3, 122, 61, 0, 1132, 147, 1, 0, 0, 0, 1133,
		1136, 5, 222, 0, 0, 1134, 1136, 3, 58, 29, 0, 1135, 1133, 1, 0, 0, 0, 1135,
		1134, 1, 0, 0, 0, 1136, 149, 1, 0, 0, 0, 1137, 1140, 3, 152, 76, 0, 1138,
		1140, 5, 133, 0, 0, 1139, 1137, 1, 0, 0, 0, 1139, 1138, 1, 0, 0, 0, 1140,
		151, 1, 0, 0, 0, 1141, 1143, 3, 296, 148, 0, 1142, 1141, 1, 0, 0, 0, 1143,
		1144, 1, 0, 0, 0, 1144, 1142, 1, 0, 0, 0, 1144, 1145, 1, 0, 0, 0, 1145,
		153, 1, 0, 0, 0, 1146, 1149, 5, 227, 0, 0, 1147, 1148, 5, 223, 0, 0, 1148,
		1150, 3, 244, 122, 0, 1149, 1147, 1, 0, 0, 0, 1149, 1150, 1, 0, 0, 0, 1150,
		155, 1, 0, 0, 0, 1151, 1152, 3, 292, 146, 0, 1152, 1153, 5, 223, 0, 0,
		1153, 1154, 3, 244, 122, 0, 1154, 157, 1, 0, 0, 0, 1155, 1157, 3, 42, 21,
		0, 1156, 1155, 1, 0, 0, 0, 1156, 1157, 1, 0, 0, 0, 1157, 1158, 1, 0, 0,
		0, 1158, 1159, 5, 56, 0, 0, 1159, 1164, 3, 156, 78, 0, 1160, 1161, 5, 220,
		0, 0, 1161, 1163, 3, 156, 78, 0, 1162, 1160, 1, 0, 0, 0, 1163, 1166, 1,
		0, 0, 0, 1164, 1162, 1, 0, 0, 0, 1164, 1165, 1, 0, 0, 0, 1165, 1167, 1,
		0, 0, 0, 1166, 1164, 1, 0, 0, 0, 1167, 1168, 5, 222, 0, 0, 1168, 159, 1,
		0, 0, 0, 1169, 1170, 5, 69, 0, 0, 1170, 1173, 3, 292, 146, 0, 1171, 1172,
		5, 221, 0, 0, 1172, 1174, 7, 4, 0, 0, 1173, 1171, 1, 0, 0, 0, 1173, 1174,
		1, 0, 0, 0, 1174, 1177, 1, 0, 0, 0, 1175, 1176, 5, 90, 0, 0, 1176, 1178,
		3, 32, 16, 0, 1177, 1175, 1, 0, 0, 0, 1177, 1178, 1, 0, 0, 0, 1178, 1179,
		1, 0, 0, 0, 1179, 1183, 5, 218, 0, 0, 1180, 1182, 3, 162, 81, 0, 1181,
		1180, 1, 0, 0, 0, 1182, 1185, 1, 0, 0, 0, 1183, 1181, 1, 0, 0, 0, 1183,
		1184, 1, 0, 0, 0, 1184, 1186, 1, 0, 0, 0, 1185, 1183, 1, 0, 0, 0, 1186,
		1187, 5, 219, 0, 0, 1187, 161, 1, 0, 0, 0, 1188, 1189, 5, 52, 0, 0, 1189,
		1192, 3, 292, 146, 0, 1190, 1191, 5, 223, 0, 0, 1191, 1193, 3, 180, 90,
		0, 1192, 1190, 1, 0, 0, 0, 1192, 1193, 1, 0, 0, 0, 1193, 1194, 1, 0, 0,
		0, 1194, 1195, 5, 222, 0, 0, 1195, 1205, 1, 0, 0, 0, 1196, 1198, 3, 152,
		76, 0, 1197, 1196, 1, 0, 0, 0, 1197, 1198, 1, 0, 0, 0, 1198, 1199, 1, 0,
		0, 0, 1199, 1205, 3, 26, 13, 0, 1200, 1201, 5, 132, 0, 0, 1201, 1202, 3,
		236, 118, 0, 1202, 1203, 3, 134, 67, 0, 1203, 1205, 1, 0, 0, 0, 1204, 1188,
		1, 0, 0, 0, 1204, 1197, 1, 0, 0, 0, 1204, 1200, 1, 0, 0, 0, 1205, 163,
		1, 0, 0, 0, 1206, 1211, 3, 180, 90, 0, 1207, 1208, 5, 220, 0, 0, 1208,
		1210, 3, 180, 90, 0, 1209, 1207, 1, 0, 0, 0, 1210, 1213, 1, 0, 0, 0, 1211,
		1209, 1, 0, 0, 0, 1211, 1212, 1, 0, 0, 0, 1212, 165, 1, 0, 0, 0, 1213,
		1211, 1, 0, 0, 0, 1214, 1215, 5, 214, 0, 0, 1215, 1216, 3, 180, 90, 0,
		1216, 1217, 5, 215, 0, 0, 1217, 167, 1, 0, 0, 0, 1218, 1219, 3, 292, 146,
		0, 1219, 1225, 5, 196, 0, 0, 1220, 1221, 3, 292, 146, 0, 1221, 1222, 5,
		196, 0, 0, 1222, 1224, 1, 0, 0, 0, 1223, 1220, 1, 0, 0, 0, 1224, 1227,
		1, 0, 0, 0, 1225, 1223, 1, 0, 0, 0, 1225, 1226, 1, 0, 0, 0, 1226, 1228,
		1, 0, 0, 0, 1227, 1225, 1, 0, 0, 0, 1228, 1229, 3, 292, 146, 0, 1229, 169,
		1, 0, 0, 0, 1230, 1233, 3, 172, 86, 0, 1231, 1233, 3, 174, 87, 0, 1232,
		1230, 1, 0, 0, 0, 1232, 1231, 1, 0, 0, 0, 1233, 171, 1, 0, 0, 0, 1234,
		1235, 3, 168, 84, 0, 1235, 1236, 5, 194, 0, 0, 1236, 1237, 3, 292, 146,
		0, 1237, 1251, 1, 0, 0, 0, 1238, 1239, 3, 292, 146, 0, 1239, 1240, 5, 194,
		0, 0, 1240, 1241, 3, 292, 146, 0, 1241, 1251, 1, 0, 0, 0, 1242, 1243, 3,
		258, 129, 0, 1243, 1244, 5, 194, 0, 0, 1244, 1245, 3, 292, 146, 0, 1245,
		1251, 1, 0, 0, 0, 1246, 1247, 3, 186, 93, 0, 1247, 1248, 5, 194, 0, 0,
		1248, 1249, 3, 292, 146, 0, 1249, 1251, 1, 0, 0, 0, 1250, 1234, 1, 0, 0,
		0, 1250, 1238, 1, 0, 0, 0, 1250, 1242, 1, 0, 0, 0, 1250, 1246, 1, 0, 0,
		0, 1251, 173, 1, 0, 0, 0, 1252, 1253, 3, 168, 84, 0, 1253, 1254, 5, 194,
		0, 0, 1254, 1255, 5, 227, 0, 0, 1255, 1269, 1, 0, 0, 0, 1256, 1257, 3,
		292, 146, 0, 1257, 1258, 5, 194, 0, 0, 1258, 1259, 5, 227, 0, 0, 1259,
		1269, 1, 0, 0, 0, 1260, 1261, 3, 258, 129, 0, 1261, 1262, 5, 194, 0, 0,
		1262, 1263, 5, 227, 0, 0, 1263, 1269, 1, 0, 0, 0, 1264, 1265, 3, 186, 93,
		0, 1265, 1266, 5, 194, 0, 0, 1266, 1267, 5, 227, 0, 0, 1267, 1269, 1, 0,
		0, 0, 1268, 1252, 1, 0, 0, 0, 1268, 1256, 1, 0, 0, 0, 1268, 1260, 1, 0,
		0, 0, 1268, 1264, 1, 0, 0, 0, 1269, 175, 1, 0, 0, 0, 1270, 1274, 3, 292,
		146, 0, 1271, 1274, 3, 258, 129, 0, 1272, 1274, 3, 186, 93, 0, 1273, 1270,
		1, 0, 0, 0, 1273, 1271, 1, 0, 0, 0, 1273, 1272, 1, 0, 0, 0, 1274, 177,
		1, 0, 0, 0, 1275, 1279, 3, 176, 88, 0, 1276, 1279, 3, 252, 126, 0, 1277,
		1279, 3, 180, 90, 0, 1278, 1275, 1, 0, 0, 0, 1278, 1276, 1, 0, 0, 0, 1278,
		1277, 1, 0, 0, 0, 1279, 179, 1, 0, 0, 0, 1280, 1281, 6, 90, -1, 0, 1281,
		1282, 5, 55, 0, 0, 1282, 1365, 3, 180, 90, 54, 1283, 1365, 3, 208, 104,
		0, 1284, 1365, 3, 168, 84, 0, 1285, 1365, 3, 292, 146, 0, 1286, 1365, 3,
		170, 85, 0, 1287, 1289, 5, 200, 0, 0, 1288, 1287, 1, 0, 0, 0, 1288, 1289,
		1, 0, 0, 0, 1289, 1290, 1, 0, 0, 0, 1290, 1365, 3, 182, 91, 0, 1291, 1365,
		3, 194, 97, 0, 1292, 1365, 3, 248, 124, 0, 1293, 1365, 3, 258, 129, 0,
		1294, 1365, 3, 184, 92, 0, 1295, 1296, 5, 113, 0, 0, 1296, 1365, 3, 180,
		90, 41, 1297, 1365, 5, 228, 0, 0, 1298, 1365, 5, 234, 0, 0, 1299, 1300,
		5, 214, 0, 0, 1300, 1301, 3, 180, 90, 0, 1301, 1302, 5, 215, 0, 0, 1302,
		1365, 1, 0, 0, 0, 1303, 1365, 3, 188, 94, 0, 1304, 1305, 5, 226, 0, 0,
		1305, 1365, 3, 180, 90, 36, 1306, 1365, 5, 135, 0, 0, 1307, 1308, 5, 102,
		0, 0, 1308, 1309, 5, 214, 0, 0, 1309, 1310, 3, 286, 143, 0, 1310, 1311,
		5, 215, 0, 0, 1311, 1312, 5, 223, 0, 0, 1312, 1313, 3, 180, 90, 34, 1313,
		1365, 1, 0, 0, 0, 1314, 1315, 5, 101, 0, 0, 1315, 1316, 5, 214, 0, 0, 1316,
		1317, 3, 262, 131, 0, 1317, 1318, 5, 215, 0, 0, 1318, 1365, 1, 0, 0, 0,
		1319, 1320, 5, 68, 0, 0, 1320, 1321, 5, 214, 0, 0, 1321, 1322, 3, 264,
		132, 0, 1322, 1323, 5, 215, 0, 0, 1323, 1365, 1, 0, 0, 0, 1324, 1330, 7,
		5, 0, 0, 1325, 1327, 5, 214, 0, 0, 1326, 1328, 3, 180, 90, 0, 1327, 1326,
		1, 0, 0, 0, 1327, 1328, 1, 0, 0, 0, 1328, 1329, 1, 0, 0, 0, 1329, 1331,
		5, 215, 0, 0, 1330, 1325, 1, 0, 0, 0, 1330, 1331, 1, 0, 0, 0, 1331, 1365,
		1, 0, 0, 0, 1332, 1333, 7, 6, 0, 0, 1333, 1365, 3, 180, 90, 30, 1334, 1335,
		5, 125, 0, 0, 1335, 1365, 3, 180, 90, 29, 1336, 1365, 3, 202, 101, 0, 1337,
		1365, 3, 204, 102, 0, 1338, 1339, 5, 214, 0, 0, 1339, 1340, 3, 304, 152,
		0, 1340, 1341, 5, 215, 0, 0, 1341, 1342, 3, 180, 90, 26, 1342, 1365, 1,
		0, 0, 0, 1343, 1344, 7, 7, 0, 0, 1344, 1365, 3, 180, 90, 25, 1345, 1346,
		7, 8, 0, 0, 1346, 1365, 3, 180, 90, 24, 1347, 1348, 7, 9, 0, 0, 1348, 1365,
		3, 182, 91, 0, 1349, 1350, 3, 182, 91, 0, 1350, 1351, 7, 9, 0, 0, 1351,
		1365, 1, 0, 0, 0, 1352, 1353, 3, 190, 95, 0, 1353, 1354, 5, 223, 0, 0,
		1354, 1355, 3, 180, 90, 6, 1355, 1365, 1, 0, 0, 0, 1356, 1357, 3, 174,
		87, 0, 1357, 1358, 3, 210, 105, 0, 1358, 1359, 3, 180, 90, 5, 1359, 1365,
		1, 0, 0, 0, 1360, 1361, 3, 182, 91, 0, 1361, 1362, 3, 210, 105, 0, 1362,
		1363, 3, 180, 90, 4, 1363, 1365, 1, 0, 0, 0, 1364, 1280, 1, 0, 0, 0, 1364,
		1283, 1, 0, 0, 0, 1364, 1284, 1, 0, 0, 0, 1364, 1285, 1, 0, 0, 0, 1364,
		1286, 1, 0, 0, 0, 1364, 1288, 1, 0, 0, 0, 1364, 1291, 1, 0, 0, 0, 1364,
		1292, 1, 0, 0, 0, 1364, 1293, 1, 0, 0, 0, 1364, 1294, 1, 0, 0, 0, 1364,
		1295, 1, 0, 0, 0, 1364, 1297, 1, 0, 0, 0, 1364, 1298, 1, 0, 0, 0, 1364,
		1299, 1, 0, 0, 0, 1364, 1303, 1, 0, 0, 0, 1364, 1304, 1, 0, 0, 0, 1364,
		1306, 1, 0, 0, 0, 1364, 1307, 1, 0, 0, 0, 1364, 1314, 1, 0, 0, 0, 1364,
		1319, 1, 0, 0, 0, 1364, 1324, 1, 0, 0, 0, 1364, 1332, 1, 0, 0, 0, 1364,
		1334, 1, 0, 0, 0, 1364, 1336, 1, 0, 0, 0, 1364, 1337, 1, 0, 0, 0, 1364,
		1338, 1, 0, 0, 0, 1364, 1343, 1, 0, 0, 0, 1364, 1345, 1, 0, 0, 0, 1364,
		1347, 1, 0, 0, 0, 1364, 1349, 1, 0, 0, 0, 1364, 1352, 1, 0, 0, 0, 1364,
		1356, 1, 0, 0, 0, 1364, 1360, 1, 0, 0, 0, 1365, 1438, 1, 0, 0, 0, 1366,
		1367, 10, 21, 0, 0, 1367, 1368, 5, 178, 0, 0, 1368, 1437, 3, 180, 90, 21,
		1369, 1370, 10, 19, 0, 0, 1370, 1371, 7, 10, 0, 0, 1371, 1437, 3, 180,
		90, 20, 1372, 1373, 10, 18, 0, 0, 1373, 1374, 7, 11, 0, 0, 1374, 1437,
		3, 180, 90, 19, 1375, 1376, 10, 17, 0, 0, 1376, 1377, 7, 12, 0, 0, 1377,
		1437, 3, 180, 90, 18, 1378, 1379, 10, 16, 0, 0, 1379, 1380, 7, 13, 0, 0,
		1380, 1437, 3, 180, 90, 17, 1381, 1382, 10, 15, 0, 0, 1382, 1383, 7, 14,
		0, 0, 1383, 1437, 3, 180, 90, 16, 1384, 1385, 10, 14, 0, 0, 1385, 1386,
		5, 200, 0, 0, 1386, 1437, 3, 180, 90, 15, 1387, 1388, 10, 13, 0, 0, 1388,
		1389, 5, 203, 0, 0, 1389, 1437, 3, 180, 90, 14, 1390, 1391, 10, 12, 0,
		0, 1391, 1392, 5, 201, 0, 0, 1392, 1437, 3, 180, 90, 13, 1393, 1394, 10,
		11, 0, 0, 1394, 1395, 5, 189, 0, 0, 1395, 1437, 3, 180, 90, 12, 1396, 1397,
		10, 10, 0, 0, 1397, 1398, 5, 188, 0, 0, 1398, 1437, 3, 180, 90, 11, 1399,
		1400, 10, 9, 0, 0, 1400, 1402, 5, 213, 0, 0, 1401, 1403, 3, 180, 90, 0,
		1402, 1401, 1, 0, 0, 0, 1402, 1403, 1, 0, 0, 0, 1403, 1404, 1, 0, 0, 0,
		1404, 1405, 5, 221, 0, 0, 1405, 1437, 3, 180, 90, 10, 1406, 1407, 10, 8,
		0, 0, 1407, 1408, 5, 190, 0, 0, 1408, 1437, 3, 180, 90, 9, 1409, 1410,
		10, 7, 0, 0, 1410, 1411, 5, 165, 0, 0, 1411, 1437, 3, 180, 90, 8, 1412,
		1413, 10, 3, 0, 0, 1413, 1414, 5, 103, 0, 0, 1414, 1437, 3, 180, 90, 4,
		1415, 1416, 10, 2, 0, 0, 1416, 1417, 5, 105, 0, 0, 1417, 1437, 3, 180,
		90, 3, 1418, 1419, 10, 1, 0, 0, 1419, 1420, 5, 104, 0, 0, 1420, 1437, 3,
		180, 90, 2, 1421, 1422, 10, 51, 0, 0, 1422, 1423, 5, 216, 0, 0, 1423, 1424,
		3, 178, 89, 0, 1424, 1425, 5, 217, 0, 0, 1425, 1437, 1, 0, 0, 0, 1426,
		1427, 10, 50, 0, 0, 1427, 1428, 5, 218, 0, 0, 1428, 1429, 3, 178, 89, 0,
		1429, 1430, 5, 219, 0, 0, 1430, 1437, 1, 0, 0, 0, 1431, 1432, 10, 49, 0,
		0, 1432, 1437, 3, 238, 119, 0, 1433, 1434, 10, 20, 0, 0, 1434, 1435, 5,
		94, 0, 0, 1435, 1437, 3, 224, 112, 0, 1436, 1366, 1, 0, 0, 0, 1436, 1369,
		1, 0, 0, 0, 1436, 1372, 1, 0, 0, 0, 1436, 1375, 1, 0, 0, 0, 1436, 1378,
		1, 0, 0, 0, 1436, 1381, 1, 0, 0, 0, 1436, 1384, 1, 0, 0, 0, 1436, 1387,
		1, 0, 0, 0, 1436, 1390, 1, 0, 0, 0, 1436, 1393, 1, 0, 0, 0, 1436, 1396,
		1, 0, 0, 0, 1436, 1399, 1, 0, 0, 0, 1436, 1406, 1, 0, 0, 0, 1436, 1409,
		1, 0, 0, 0, 1436, 1412, 1, 0, 0, 0, 1436, 1415, 1, 0, 0, 0, 1436, 1418,
		1, 0, 0, 0, 1436, 1421, 1, 0, 0, 0, 1436, 1426, 1, 0, 0, 0, 1436, 1431,
		1, 0, 0, 0, 1436, 1433, 1, 0, 0, 0, 1437, 1440, 1, 0, 0, 0, 1438, 1436,
		1, 0, 0, 0, 1438, 1439, 1, 0, 0, 0, 1439, 181, 1, 0, 0, 0, 1440, 1438,
		1, 0, 0, 0, 1441, 1442, 6, 91, -1, 0, 1442, 1443, 3, 186, 93, 0, 1443,
		1461, 1, 0, 0, 0, 1444, 1445, 10, 3, 0, 0, 1445, 1447, 5, 216, 0, 0, 1446,
		1448, 3, 178, 89, 0, 1447, 1446, 1, 0, 0, 0, 1447, 1448, 1, 0, 0, 0, 1448,
		1449, 1, 0, 0, 0, 1449, 1460, 5, 217, 0, 0, 1450, 1451, 10, 2, 0, 0, 1451,
		1453, 5, 218, 0, 0, 1452, 1454, 3, 178, 89, 0, 1453, 1452, 1, 0, 0, 0,
		1453, 1454, 1, 0, 0, 0, 1454, 1455, 1, 0, 0, 0, 1455, 1460, 5, 219, 0,
		0, 1456, 1457, 10, 1, 0, 0, 1457, 1458, 5, 195, 0, 0, 1458, 1460, 3, 176,
		88, 0, 1459, 1444, 1, 0, 0, 0, 1459, 1450, 1, 0, 0, 0, 1459, 1456, 1, 0,
		0, 0, 1460, 1463, 1, 0, 0, 0, 1461, 1459, 1, 0, 0, 0, 1461, 1462, 1, 0,
		0, 0, 1462, 183, 1, 0, 0, 0, 1463, 1461, 1, 0, 0, 0, 1464, 1465, 5, 58,
		0, 0, 1465, 1466, 5, 214, 0, 0, 1466, 1467, 3, 246, 123, 0, 1467, 1468,
		5, 220, 0, 0, 1468, 1469, 3, 180, 90, 0, 1469, 1470, 5, 215, 0, 0, 1470,
		1477, 1, 0, 0, 0, 1471, 1472, 5, 59, 0, 0, 1472, 1473, 5, 214, 0, 0, 1473,
		1474, 3, 246, 123, 0, 1474, 1475, 5, 215, 0, 0, 1475, 1477, 1, 0, 0, 0,
		1476, 1464, 1, 0, 0, 0, 1476, 1471, 1, 0, 0, 0, 1477, 185, 1, 0, 0, 0,
		1478, 1495, 5, 227, 0, 0, 1479, 1481, 5, 211, 0, 0, 1480, 1479, 1, 0, 0,
		0, 1481, 1482, 1, 0, 0, 0, 1482, 1480, 1, 0, 0, 0, 1482, 1483, 1, 0, 0,
		0, 1483, 1484, 1, 0, 0, 0, 1484, 1495, 5, 227, 0, 0, 1485, 1487, 5, 211,
		0, 0, 1486, 1485, 1, 0, 0, 0, 1487, 1488, 1, 0, 0, 0, 1488, 1486, 1, 0,
		0, 0, 1488, 1489, 1, 0, 0, 0, 1489, 1490, 1, 0, 0, 0, 1490, 1491, 5, 218,
		0, 0, 1491, 1492, 3, 180, 90, 0, 1492, 1493, 5, 219, 0, 0, 1493, 1495,
		1, 0, 0, 0, 1494, 1478, 1, 0, 0, 0, 1494, 1480, 1, 0, 0, 0, 1494, 1486,
		1, 0, 0, 0, 1495, 187, 1, 0, 0, 0, 1496, 1497, 7, 15, 0, 0, 1497, 1498,
		3, 180, 90, 0, 1498, 189, 1, 0, 0, 0, 1499, 1500, 3, 292, 146, 0, 1500,
		1502, 5, 214, 0, 0, 1501, 1503, 3, 214, 107, 0, 1502, 1501, 1, 0, 0, 0,
		1502, 1503, 1, 0, 0, 0, 1503, 1504, 1, 0, 0, 0, 1504, 1505, 5, 215, 0,
		0, 1505, 1508, 1, 0, 0, 0, 1506, 1508, 3, 196, 98, 0, 1507, 1499, 1, 0,
		0, 0, 1507, 1506, 1, 0, 0, 0, 1508, 191, 1, 0, 0, 0, 1509, 1512, 3, 264,
		132, 0, 1510, 1512, 3, 194, 97, 0, 1511, 1509, 1, 0, 0, 0, 1511, 1510,
		1, 0, 0, 0, 1512, 193, 1, 0, 0, 0, 1513, 1514, 5, 45, 0, 0, 1514, 1516,
		5, 214, 0, 0, 1515, 1517, 3, 214, 107, 0, 1516, 1515, 1, 0, 0, 0, 1516,
		1517, 1, 0, 0, 0, 1517, 1518, 1, 0, 0, 0, 1518, 1531, 5, 215, 0, 0, 1519,
		1520, 5, 102, 0, 0, 1520, 1522, 5, 214, 0, 0, 1521, 1523, 3, 214, 107,
		0, 1522, 1521, 1, 0, 0, 0, 1522, 1523, 1, 0, 0, 0, 1523, 1524, 1, 0, 0,
		0, 1524, 1531, 5, 215, 0, 0, 1525, 1527, 5, 216, 0, 0, 1526, 1528, 3, 214,
		107, 0, 1527, 1526, 1, 0, 0, 0, 1527, 1528, 1, 0, 0, 0, 1528, 1529, 1,
		0, 0, 0, 1529, 1531, 5, 217, 0, 0, 1530, 1513, 1, 0, 0, 0, 1530, 1519,
		1, 0, 0, 0, 1530, 1525, 1, 0, 0, 0, 1531, 195, 1, 0, 0, 0, 1532, 1536,
		5, 216, 0, 0, 1533, 1535, 5, 220, 0, 0, 1534, 1533, 1, 0, 0, 0, 1535, 1538,
		1, 0, 0, 0, 1536, 1534, 1, 0, 0, 0, 1536, 1537, 1, 0, 0, 0, 1537, 1539,
		1, 0, 0, 0, 1538, 1536, 1, 0, 0, 0, 1539, 1548, 3, 198, 99, 0, 1540, 1542,
		5, 220, 0, 0, 1541, 1540, 1, 0, 0, 0, 1542, 1543, 1, 0, 0, 0, 1543, 1541,
		1, 0, 0, 0, 1543, 1544, 1, 0, 0, 0, 1544, 1545, 1, 0, 0, 0, 1545, 1547,
		3, 198, 99, 0, 1546, 1541, 1, 0, 0, 0, 1547, 1550, 1, 0, 0, 0, 1548, 1546,
		1, 0, 0, 0, 1548, 1549, 1, 0, 0, 0, 1549, 1554, 1, 0, 0, 0, 1550, 1548,
		1, 0, 0, 0, 1551, 1553, 5, 220, 0, 0, 1552, 1551, 1, 0, 0, 0, 1553, 1556,
		1, 0, 0, 0, 1554, 1552, 1, 0, 0, 0, 1554, 1555, 1, 0, 0, 0, 1555, 1557,
		1, 0, 0, 0, 1556, 1554, 1, 0, 0, 0, 1557, 1558, 5, 217, 0, 0, 1558, 1578,
		1, 0, 0, 0, 1559, 1560, 5, 216, 0, 0, 1560, 1569, 3, 200, 100, 0, 1561,
		1563, 5, 220, 0, 0, 1562, 1561, 1, 0, 0, 0, 1563, 1564, 1, 0, 0, 0, 1564,
		1562, 1, 0, 0, 0, 1564, 1565, 1, 0, 0, 0, 1565, 1566, 1, 0, 0, 0, 1566,
		1568, 3, 200, 100, 0, 1567, 1562, 1, 0, 0, 0, 1568, 1571, 1, 0, 0, 0, 1569,
		1567, 1, 0, 0, 0, 1569, 1570, 1, 0, 0, 0, 1570, 1573, 1, 0, 0, 0, 1571,
		1569, 1, 0, 0, 0, 1572, 1574, 5, 220, 0, 0, 1573, 1572, 1, 0, 0, 0, 1573,
		1574, 1, 0, 0, 0, 1574, 1575, 1, 0, 0, 0, 1575, 1576, 5, 217, 0, 0, 1576,
		1578, 1, 0, 0, 0, 1577, 1532, 1, 0, 0, 0, 1577, 1559, 1, 0, 0, 0, 1578,
		197, 1, 0, 0, 0, 1579, 1581, 5, 200, 0, 0, 1580, 1579, 1, 0, 0, 0, 1580,
		1581, 1, 0, 0, 0, 1581, 1582, 1, 0, 0, 0, 1582, 1583, 3, 264, 132, 0, 1583,
		199, 1, 0, 0, 0, 1584, 1585, 3, 180, 90, 0, 1585, 1586, 5, 166, 0, 0, 1586,
		1588, 1, 0, 0, 0, 1587, 1584, 1, 0, 0, 0, 1587, 1588, 1, 0, 0, 0, 1588,
		1590, 1, 0, 0, 0, 1589, 1591, 5, 200, 0, 0, 1590, 1589, 1, 0, 0, 0, 1590,
		1591, 1, 0, 0, 0, 1591, 1592, 1, 0, 0, 0, 1592, 1593, 3, 264, 132, 0, 1593,
		201, 1, 0, 0, 0, 1594, 1596, 5, 122, 0, 0, 1595, 1594, 1, 0, 0, 0, 1595,
		1596, 1, 0, 0, 0, 1596, 1597, 1, 0, 0, 0, 1597, 1599, 5, 86, 0, 0, 1598,
		1600, 5, 200, 0, 0, 1599, 1598, 1, 0, 0, 0, 1599, 1600, 1, 0, 0, 0, 1600,
		1601, 1, 0, 0, 0, 1601, 1602, 5, 214, 0, 0, 1602, 1603, 3, 118, 59, 0,
		1603, 1605, 5, 215, 0, 0, 1604, 1606, 3, 218, 109, 0, 1605, 1604, 1, 0,
		0, 0, 1605, 1606, 1, 0, 0, 0, 1606, 1609, 1, 0, 0, 0, 1607, 1608, 5, 221,
		0, 0, 1608, 1610, 3, 122, 61, 0, 1609, 1607, 1, 0, 0, 0, 1609, 1610, 1,
		0, 0, 0, 1610, 1611, 1, 0, 0, 0, 1611, 1612, 3, 58, 29, 0, 1612, 1621,
		1, 0, 0, 0, 1613, 1614, 5, 137, 0, 0, 1614, 1615, 5, 214, 0, 0, 1615, 1616,
		3, 118, 59, 0, 1616, 1617, 5, 215, 0, 0, 1617, 1618, 5, 166, 0, 0, 1618,
		1619, 3, 180, 90, 0, 1619, 1621, 1, 0, 0, 0, 1620, 1595, 1, 0, 0, 0, 1620,
		1613, 1, 0, 0, 0, 1621, 203, 1, 0, 0, 0, 1622, 1623, 5, 106, 0, 0, 1623,
		1624, 5, 214, 0, 0, 1624, 1625, 3, 180, 90, 0, 1625, 1626, 5, 215, 0, 0,
		1626, 1627, 5, 218, 0, 0, 1627, 1632, 3, 206, 103, 0, 1628, 1629, 5, 220,
		0, 0, 1629, 1631, 3, 206, 103, 0, 1630, 1628, 1, 0, 0, 0, 1631, 1634, 1,
		0, 0, 0, 1632, 1630, 1, 0, 0, 0, 1632, 1633, 1, 0, 0, 0, 1633, 1636, 1,
		0, 0, 0, 1634, 1632, 1, 0, 0, 0, 1635, 1637, 5, 220, 0, 0, 1636, 1635,
		1, 0, 0, 0, 1636, 1637, 1, 0, 0, 0, 1637, 1638, 1, 0, 0, 0, 1638, 1639,
		5, 219, 0, 0, 1639, 205, 1, 0, 0, 0, 1640, 1645, 3, 180, 90, 0, 1641, 1642,
		5, 220, 0, 0, 1642, 1644, 3, 180, 90, 0, 1643, 1641, 1, 0, 0, 0, 1644,
		1647, 1, 0, 0, 0, 1645, 1643, 1, 0, 0, 0, 1645, 1646, 1, 0, 0, 0, 1646,
		1648, 1, 0, 0, 0, 1647, 1645, 1, 0, 0, 0, 1648, 1649, 5, 166, 0, 0, 1649,
		1650, 3, 180, 90, 0, 1650, 207, 1, 0, 0, 0, 1651, 1652, 5, 108, 0, 0, 1652,
		1659, 3, 226, 113, 0, 1653, 1654, 5, 108, 0, 0, 1654, 1656, 3, 224, 112,
		0, 1655, 1657, 3, 238, 119, 0, 1656, 1655, 1, 0, 0, 0, 1656, 1657, 1, 0,
		0, 0, 1657, 1659, 1, 0, 0, 0, 1658, 1651, 1, 0, 0, 0, 1658, 1653, 1, 0,
		0, 0, 1659, 209, 1, 0, 0, 0, 1660, 1661, 7, 16, 0, 0, 1661, 211, 1, 0,
		0, 0, 1662, 1670, 5, 135, 0, 0, 1663, 1666, 3, 180, 90, 0, 1664, 1665,
		5, 166, 0, 0, 1665, 1667, 3, 180, 90, 0, 1666, 1664, 1, 0, 0, 0, 1666,
		1667, 1, 0, 0, 0, 1667, 1671, 1, 0, 0, 0, 1668, 1669, 5, 136, 0, 0, 1669,
		1671, 3, 180, 90, 0, 1670, 1663, 1, 0, 0, 0, 1670, 1668, 1, 0, 0, 0, 1671,
		213, 1, 0, 0, 0, 1672, 1677, 3, 216, 108, 0, 1673, 1674, 5, 220, 0, 0,
		1674, 1676, 3, 216, 108, 0, 1675, 1673, 1, 0, 0, 0, 1676, 1679, 1, 0, 0,
		0, 1677, 1675, 1, 0, 0, 0, 1677, 1678, 1, 0, 0, 0, 1678, 1681, 1, 0, 0,
		0, 1679, 1677, 1, 0, 0, 0, 1680, 1682, 5, 220, 0, 0, 1681, 1680, 1, 0,
		0, 0, 1681, 1682, 1, 0, 0, 0, 1682, 215, 1, 0, 0, 0, 1683, 1686, 3, 180,
		90, 0, 1684, 1685, 5, 166, 0, 0, 1685, 1687, 3, 180, 90, 0, 1686, 1684,
		1, 0, 0, 0, 1686, 1687, 1, 0, 0, 0, 1687, 1696, 1, 0, 0, 0, 1688, 1689,
		3, 180, 90, 0, 1689, 1690, 5, 166, 0, 0, 1690, 1692, 1, 0, 0, 0, 1691,
		1688, 1, 0, 0, 0, 1691, 1692, 1, 0, 0, 0, 1692, 1693, 1, 0, 0, 0, 1693,
		1694, 5, 200, 0, 0, 1694, 1696, 3, 264, 132, 0, 1695, 1683, 1, 0, 0, 0,
		1695, 1691, 1, 0, 0, 0, 1696, 217, 1, 0, 0, 0, 1697, 1698, 5, 132, 0, 0,
		1698, 1699, 5, 214, 0, 0, 1699, 1704, 3, 220, 110, 0, 1700, 1701, 5, 220,
		0, 0, 1701, 1703, 3, 220, 110, 0, 1702, 1700, 1, 0, 0, 0, 1703, 1706, 1,
		0, 0, 0, 1704, 1702, 1, 0, 0, 0, 1704, 1705, 1, 0, 0, 0, 1705, 1707, 1,
		0, 0, 0, 1706, 1704, 1, 0, 0, 0, 1707, 1708, 5, 215, 0, 0, 1708, 219, 1,
		0, 0, 0, 1709, 1711, 5, 200, 0, 0, 1710, 1709, 1, 0, 0, 0, 1710, 1711,
		1, 0, 0, 0, 1711, 1712, 1, 0, 0, 0, 1712, 1713, 5, 227, 0, 0, 1713, 221,
		1, 0, 0, 0, 1714, 1717, 3, 230, 115, 0, 1715, 1717, 5, 122, 0, 0, 1716,
		1714, 1, 0, 0, 0, 1716, 1715, 1, 0, 0, 0, 1717, 223, 1, 0, 0, 0, 1718,
		1721, 3, 230, 115, 0, 1719, 1721, 3, 228, 114, 0, 1720, 1718, 1, 0, 0,
		0, 1720, 1719, 1, 0, 0, 0, 1721, 1726, 1, 0, 0, 0, 1722, 1726, 3, 302,
		151, 0, 1723, 1726, 5, 122, 0, 0, 1724, 1726, 3, 226, 113, 0, 1725, 1720,
		1, 0, 0, 0, 1725, 1722, 1, 0, 0, 0, 1725, 1723, 1, 0, 0, 0, 1725, 1724,
		1, 0, 0, 0, 1726, 225, 1, 0, 0, 0, 1727, 1729, 3, 42, 21, 0, 1728, 1727,
		1, 0, 0, 0, 1728, 1729, 1, 0, 0, 0, 1729, 1731, 1, 0, 0, 0, 1730, 1732,
		5, 114, 0, 0, 1731, 1730, 1, 0, 0, 0, 1731, 1732, 1, 0, 0, 0, 1732, 1734,
		1, 0, 0, 0, 1733, 1735, 3, 290, 145, 0, 1734, 1733, 1, 0, 0, 0, 1734, 1735,
		1, 0, 0, 0, 1735, 1737, 1, 0, 0, 0, 1736, 1738, 5, 112, 0, 0, 1737, 1736,
		1, 0, 0, 0, 1737, 1738, 1, 0, 0, 0, 1738, 1754, 1, 0, 0, 0, 1739, 1742,
		3, 30, 15, 0, 1740, 1741, 5, 80, 0, 0, 1741, 1743, 3, 222, 111, 0, 1742,
		1740, 1, 0, 0, 0, 1742, 1743, 1, 0, 0, 0, 1743, 1746, 1, 0, 0, 0, 1744,
		1745, 5, 90, 0, 0, 1745, 1747, 3, 32, 16, 0, 1746, 1744, 1, 0, 0, 0, 1746,
		1747, 1, 0, 0, 0, 1747, 1755, 1, 0, 0, 0, 1748, 1749, 5, 100, 0, 0, 1749,
		1752, 3, 292, 146, 0, 1750, 1751, 5, 80, 0, 0, 1751, 1753, 3, 32, 16, 0,
		1752, 1750, 1, 0, 0, 0, 1752, 1753, 1, 0, 0, 0, 1753, 1755, 1, 0, 0, 0,
		1754, 1739, 1, 0, 0, 0, 1754, 1748, 1, 0, 0, 0, 1755, 1757, 1, 0, 0, 0,
		1756, 1758, 3, 238, 119, 0, 1757, 1756, 1, 0, 0, 0, 1757, 1758, 1, 0, 0,
		0, 1758, 1759, 1, 0, 0, 0, 1759, 1763, 5, 218, 0, 0, 1760, 1762, 3, 132,
		66, 0, 1761, 1760, 1, 0, 0, 0, 1762, 1765, 1, 0, 0, 0, 1763, 1761, 1, 0,
		0, 0, 1763, 1764, 1, 0, 0, 0, 1764, 1766, 1, 0, 0, 0, 1765, 1763, 1, 0,
		0, 0, 1766, 1767, 5, 219, 0, 0, 1767, 227, 1, 0, 0, 0, 1768, 1773, 3, 276,
		138, 0, 1769, 1770, 5, 195, 0, 0, 1770, 1772, 3, 278, 139, 0, 1771, 1769,
		1, 0, 0, 0, 1772, 1775, 1, 0, 0, 0, 1773, 1771, 1, 0, 0, 0, 1773, 1774,
		1, 0, 0, 0, 1774, 229, 1, 0, 0, 0, 1775, 1773, 1, 0, 0, 0, 1776, 1778,
		5, 107, 0, 0, 1777, 1776, 1, 0, 0, 0, 1777, 1778, 1, 0, 0, 0, 1778, 1780,
		1, 0, 0, 0, 1779, 1781, 5, 196, 0, 0, 1780, 1779, 1, 0, 0, 0, 1780, 1781,
		1, 0, 0, 0, 1781, 1782, 1, 0, 0, 0, 1782, 1783, 3, 232, 116, 0, 1783, 231,
		1, 0, 0, 0, 1784, 1797, 3, 292, 146, 0, 1785, 1788, 3, 292, 146, 0, 1786,
		1787, 5, 196, 0, 0, 1787, 1789, 3, 292, 146, 0, 1788, 1786, 1, 0, 0, 0,
		1789, 1790, 1, 0, 0, 0, 1790, 1788, 1, 0, 0, 0, 1790, 1791, 1, 0, 0, 0,
		1791, 1794, 1, 0, 0, 0, 1792, 1793, 5, 196, 0, 0, 1793, 1795, 3, 234, 117,
		0, 1794, 1792, 1, 0, 0, 0, 1794, 1795, 1, 0, 0, 0, 1795, 1797, 1, 0, 0,
		0, 1796, 1784, 1, 0, 0, 0, 1796, 1785, 1, 0, 0, 0, 1797, 233, 1, 0, 0,
		0, 1798, 1801, 3, 292, 146, 0, 1799, 1800, 5, 46, 0, 0, 1800, 1802, 3,
		292, 146, 0, 1801, 1799, 1, 0, 0, 0, 1801, 1802, 1, 0, 0, 0, 1802, 1818,
		1, 0, 0, 0, 1803, 1804, 5, 218, 0, 0, 1804, 1809, 3, 234, 117, 0, 1805,
		1806, 5, 220, 0, 0, 1806, 1808, 3, 234, 117, 0, 1807, 1805, 1, 0, 0, 0,
		1808, 1811, 1, 0, 0, 0, 1809, 1807, 1, 0, 0, 0, 1809, 1810, 1, 0, 0, 0,
		1810, 1813, 1, 0, 0, 0, 1811, 1809, 1, 0, 0, 0, 1812, 1814, 5, 220, 0,
		0, 1813, 1812, 1, 0, 0, 0, 1813, 1814, 1, 0, 0, 0, 1814, 1815, 1, 0, 0,
		0, 1815, 1816, 5, 219, 0, 0, 1816, 1818, 1, 0, 0, 0, 1817, 1798, 1, 0,
		0, 0, 1817, 1803, 1, 0, 0, 0, 1818, 235, 1, 0, 0, 0, 1819, 1824, 3, 230,
		115, 0, 1820, 1821, 5, 220, 0, 0, 1821, 1823, 3, 230, 115, 0, 1822, 1820,
		1, 0, 0, 0, 1823, 1826, 1, 0, 0, 0, 1824, 1822, 1, 0, 0, 0, 1824, 1825,
		1, 0, 0, 0, 1825, 237, 1, 0, 0, 0, 1826, 1824, 1, 0, 0, 0, 1827, 1829,
		5, 214, 0, 0, 1828, 1830, 3, 240, 120, 0, 1829, 1828, 1, 0, 0, 0, 1829,
		1830, 1, 0, 0, 0, 1830, 1835, 1, 0, 0, 0, 1831, 1832, 5, 220, 0, 0, 1832,
		1834, 3, 240, 120, 0, 1833, 1831, 1, 0, 0, 0, 1834, 1837, 1, 0, 0, 0, 1835,
		1833, 1, 0, 0, 0, 1835, 1836, 1, 0, 0, 0, 1836, 1839, 1, 0, 0, 0, 1837,
		1835, 1, 0, 0, 0, 1838, 1840, 5, 220, 0, 0, 1839, 1838, 1, 0, 0, 0, 1839,
		1840, 1, 0, 0, 0, 1840, 1841, 1, 0, 0, 0, 1841, 1842, 5, 215, 0, 0, 1842,
		239, 1, 0, 0, 0, 1843, 1845, 3, 242, 121, 0, 1844, 1843, 1, 0, 0, 0, 1844,
		1845, 1, 0, 0, 0, 1845, 1847, 1, 0, 0, 0, 1846, 1848, 5, 197, 0, 0, 1847,
		1846, 1, 0, 0, 0, 1847, 1848, 1, 0, 0, 0, 1848, 1849, 1, 0, 0, 0, 1849,
		1853, 3, 180, 90, 0, 1850, 1851, 5, 200, 0, 0, 1851, 1853, 3, 264, 132,
		0, 1852, 1844, 1, 0, 0, 0, 1852, 1850, 1, 0, 0, 0, 1853, 241, 1, 0, 0,
		0, 1854, 1855, 3, 292, 146, 0, 1855, 1856, 5, 221, 0, 0, 1856, 243, 1,
		0, 0, 0, 1857, 1862, 3, 246, 123, 0, 1858, 1859, 5, 212, 0, 0, 1859, 1861,
		3, 246, 123, 0, 1860, 1858, 1, 0, 0, 0, 1861, 1864, 1, 0, 0, 0, 1862, 1860,
		1, 0, 0, 0, 1862, 1863, 1, 0, 0, 0, 1863, 1886, 1, 0, 0, 0, 1864, 1862,
		1, 0, 0, 0, 1865, 1866, 5, 45, 0, 0, 1866, 1871, 5, 214, 0, 0, 1867, 1869,
		3, 214, 107, 0, 1868, 1870, 5, 220, 0, 0, 1869, 1868, 1, 0, 0, 0, 1869,
		1870, 1, 0, 0, 0, 1870, 1872, 1, 0, 0, 0, 1871, 1867, 1, 0, 0, 0, 1871,
		1872, 1, 0, 0, 0, 1872, 1873, 1, 0, 0, 0, 1873, 1886, 5, 215, 0, 0, 1874,
		1879, 5, 216, 0, 0, 1875, 1877, 3, 214, 107, 0, 1876, 1878, 5, 220, 0,
		0, 1877, 1876, 1, 0, 0, 0, 1877, 1878, 1, 0, 0, 0, 1878, 1880, 1, 0, 0,
		0, 1879, 1875, 1, 0, 0, 0, 1879, 1880, 1, 0, 0, 0, 1880, 1881, 1, 0, 0,
		0, 1881, 1886, 5, 217, 0, 0, 1882, 1883, 7, 17, 0, 0, 1883, 1886, 3, 244,
		122, 0, 1884, 1886, 3, 180, 90, 0, 1885, 1857, 1, 0, 0, 0, 1885, 1865,
		1, 0, 0, 0, 1885, 1874, 1, 0, 0, 0, 1885, 1882, 1, 0, 0, 0, 1885, 1884,
		1, 0, 0, 0, 1886, 245, 1, 0, 0, 0, 1887, 1890, 3, 258, 129, 0, 1888, 1890,
		3, 248, 124, 0, 1889, 1887, 1, 0, 0, 0, 1889, 1888, 1, 0, 0, 0, 1890, 247,
		1, 0, 0, 0, 1891, 1895, 5, 109, 0, 0, 1892, 1895, 3, 250, 125, 0, 1893,
		1895, 3, 298, 149, 0, 1894, 1891, 1, 0, 0, 0, 1894, 1892, 1, 0, 0, 0, 1894,
		1893, 1, 0, 0, 0, 1895, 249, 1, 0, 0, 0, 1896, 1901, 5, 231, 0, 0, 1897,
		1901, 5, 49, 0, 0, 1898, 1901, 3, 252, 126, 0, 1899, 1901, 3, 256, 128,
		0, 1900, 1896, 1, 0, 0, 0, 1900, 1897, 1, 0, 0, 0, 1900, 1898, 1, 0, 0,
		0, 1900, 1899, 1, 0, 0, 0, 1901, 251, 1, 0, 0, 0, 1902, 1903, 7, 18, 0,
		0, 1903, 253, 1, 0, 0, 0, 1904, 1905, 7, 19, 0, 0, 1905, 1910, 5, 194,
		0, 0, 1906, 1911, 3, 292, 146, 0, 1907, 1911, 5, 145, 0, 0, 1908, 1911,
		5, 141, 0, 0, 1909, 1911, 5, 142, 0, 0, 1910, 1906, 1, 0, 0, 0, 1910, 1907,
		1, 0, 0, 0, 1910, 1908, 1, 0, 0, 0, 1910, 1909, 1, 0, 0, 0, 1911, 1923,
		1, 0, 0, 0, 1912, 1916, 3, 222, 111, 0, 1913, 1916, 3, 282, 141, 0, 1914,
		1916, 3, 258, 129, 0, 1915, 1912, 1, 0, 0, 0, 1915, 1913, 1, 0, 0, 0, 1915,
		1914, 1, 0, 0, 0, 1916, 1917, 1, 0, 0, 0, 1917, 1920, 5, 194, 0, 0, 1918,
		1921, 3, 292, 146, 0, 1919, 1921, 3, 282, 141, 0, 1920, 1918, 1, 0, 0,
		0, 1920, 1919, 1, 0, 0, 0, 1921, 1923, 1, 0, 0, 0, 1922, 1904, 1, 0, 0,
		0, 1922, 1915, 1, 0, 0, 0, 1923, 255, 1, 0, 0, 0, 1924, 1925, 5, 228, 0,
		0, 1925, 257, 1, 0, 0, 0, 1926, 1928, 5, 238, 0, 0, 1927, 1929, 5, 246,
		0, 0, 1928, 1927, 1, 0, 0, 0, 1929, 1930, 1, 0, 0, 0, 1930, 1928, 1, 0,
		0, 0, 1930, 1931, 1, 0, 0, 0, 1931, 1948, 1, 0, 0, 0, 1932, 1934, 5, 237,
		0, 0, 1933, 1935, 5, 246, 0, 0, 1934, 1933, 1, 0, 0, 0, 1935, 1936, 1,
		0, 0, 0, 1936, 1934, 1, 0, 0, 0, 1936, 1937, 1, 0, 0, 0, 1937, 1948, 1,
		0, 0, 0, 1938, 1948, 5, 235, 0, 0, 1939, 1943, 5, 236, 0, 0, 1940, 1942,
		3, 260, 130, 0, 1941, 1940, 1, 0, 0, 0, 1942, 1945, 1, 0, 0, 0, 1943, 1941,
		1, 0, 0, 0, 1943, 1944, 1, 0, 0, 0, 1944, 1946, 1, 0, 0, 0, 1945, 1943,
		1, 0, 0, 0, 1946, 1948, 5, 236, 0, 0, 1947, 1926, 1, 0, 0, 0, 1947, 1932,
		1, 0, 0, 0, 1947, 1938, 1, 0, 0, 0, 1947, 1939, 1, 0, 0, 0, 1948, 259,
		1, 0, 0, 0, 1949, 1953, 5, 242, 0, 0, 1950, 1953, 5, 241, 0, 0, 1951, 1953,
		3, 264, 132, 0, 1952, 1949, 1, 0, 0, 0, 1952, 1950, 1, 0, 0, 0, 1952, 1951,
		1, 0, 0, 0, 1953, 261, 1, 0, 0, 0, 1954, 1959, 3, 264, 132, 0, 1955, 1956,
		5, 220, 0, 0, 1956, 1958, 3, 264, 132, 0, 1957, 1955, 1, 0, 0, 0, 1958,
		1961, 1, 0, 0, 0, 1959, 1957, 1, 0, 0, 0, 1959, 1960, 1, 0, 0, 0, 1960,
		263, 1, 0, 0, 0, 1961, 1959, 1, 0, 0, 0, 1962, 1966, 3, 266, 133, 0, 1963,
		1965, 3, 268, 134, 0, 1964, 1963, 1, 0, 0, 0, 1965, 1968, 1, 0, 0, 0, 1966,
		1964, 1, 0, 0, 0, 1966, 1967, 1, 0, 0, 0, 1967, 1971, 1, 0, 0, 0, 1968,
		1966, 1, 0, 0, 0, 1969, 1971, 3, 194, 97, 0, 1970, 1962, 1, 0, 0, 0, 1970,
		1969, 1, 0, 0, 0, 1971, 265, 1, 0, 0, 0, 1972, 1979, 3, 276, 138, 0, 1973,
		1979, 3, 270, 135, 0, 1974, 1975, 5, 214, 0, 0, 1975, 1976, 3, 208, 104,
		0, 1976, 1977, 5, 215, 0, 0, 1977, 1979, 1, 0, 0, 0, 1978, 1972, 1, 0,
		0, 0, 1978, 1973, 1, 0, 0, 0, 1978, 1974, 1, 0, 0, 0, 1979, 267, 1, 0,
		0, 0, 1980, 1981, 5, 195, 0, 0, 1981, 1983, 3, 278, 139, 0, 1982, 1984,
		3, 274, 137, 0, 1983, 1982, 1, 0, 0, 0, 1983, 1984, 1, 0, 0, 0, 1984, 269,
		1, 0, 0, 0, 1985, 1986, 3, 272, 136, 0, 1986, 1987, 3, 274, 137, 0, 1987,
		271, 1, 0, 0, 0, 1988, 1994, 3, 230, 115, 0, 1989, 1994, 3, 254, 127, 0,
		1990, 1994, 3, 276, 138, 0, 1991, 1994, 3, 166, 83, 0, 1992, 1994, 5, 228,
		0, 0, 1993, 1988, 1, 0, 0, 0, 1993, 1989, 1, 0, 0, 0, 1993, 1990, 1, 0,
		0, 0, 1993, 1991, 1, 0, 0, 0, 1993, 1992, 1, 0, 0, 0, 1994, 273, 1, 0,
		0, 0, 1995, 1997, 3, 238, 119, 0, 1996, 1995, 1, 0, 0, 0, 1997, 1998, 1,
		0, 0, 0, 1998, 1996, 1, 0, 0, 0, 1998, 1999, 1, 0, 0, 0, 1999, 2003, 1,
		0, 0, 0, 2000, 2002, 3, 284, 142, 0, 2001, 2000, 1, 0, 0, 0, 2002, 2005,
		1, 0, 0, 0, 2003, 2001, 1, 0, 0, 0, 2003, 2004, 1, 0, 0, 0, 2004, 275,
		1, 0, 0, 0, 2005, 2003, 1, 0, 0, 0, 2006, 2009, 3, 282, 141, 0, 2007, 2008,
		5, 194, 0, 0, 2008, 2010, 3, 282, 141, 0, 2009, 2007, 1, 0, 0, 0, 2009,
		2010, 1, 0, 0, 0, 2010, 2016, 1, 0, 0, 0, 2011, 2012, 3, 222, 111, 0, 2012,
		2013, 5, 194, 0, 0, 2013, 2014, 3, 282, 141, 0, 2014, 2016, 1, 0, 0, 0,
		2015, 2006, 1, 0, 0, 0, 2015, 2011, 1, 0, 0, 0, 2016, 277, 1, 0, 0, 0,
		2017, 2020, 3, 280, 140, 0, 2018, 2020, 3, 282, 141, 0, 2019, 2017, 1,
		0, 0, 0, 2019, 2018, 1, 0, 0, 0, 2020, 279, 1, 0, 0, 0, 2021, 2027, 3,
		292, 146, 0, 2022, 2023, 5, 218, 0, 0, 2023, 2024, 3, 180, 90, 0, 2024,
		2025, 5, 219, 0, 0, 2025, 2027, 1, 0, 0, 0, 2026, 2021, 1, 0, 0, 0, 2026,
		2022, 1, 0, 0, 0, 2027, 2031, 1, 0, 0, 0, 2028, 2030, 3, 284, 142, 0, 2029,
		2028, 1, 0, 0, 0, 2030, 2033, 1, 0, 0, 0, 2031, 2029, 1, 0, 0, 0, 2031,
		2032, 1, 0, 0, 0, 2032, 281, 1, 0, 0, 0, 2033, 2031, 1, 0, 0, 0, 2034,
		2036, 5, 211, 0, 0, 2035, 2034, 1, 0, 0, 0, 2036, 2039, 1, 0, 0, 0, 2037,
		2035, 1, 0, 0, 0, 2037, 2038, 1, 0, 0, 0, 2038, 2046, 1, 0, 0, 0, 2039,
		2037, 1, 0, 0, 0, 2040, 2047, 5, 227, 0, 0, 2041, 2042, 5, 211, 0, 0, 2042,
		2043, 5, 218, 0, 0, 2043, 2044, 3, 180, 90, 0, 2044, 2045, 5, 219, 0, 0,
		2045, 2047, 1, 0, 0, 0, 2046, 2040, 1, 0, 0, 0, 2046, 2041, 1, 0, 0, 0,
		2047, 2051, 1, 0, 0, 0, 2048, 2050, 3, 284, 142, 0, 2049, 2048, 1, 0, 0,
		0, 2050, 2053, 1, 0, 0, 0, 2051, 2049, 1, 0, 0, 0, 2051, 2052, 1, 0, 0,
		0, 2052, 283, 1, 0, 0, 0, 2053, 2051, 1, 0, 0, 0, 2054, 2056, 5, 216, 0,
		0, 2055, 2057, 3, 180, 90, 0, 2056, 2055, 1, 0, 0, 0, 2056, 2057, 1, 0,
		0, 0, 2057, 2058, 1, 0, 0, 0, 2058, 2064, 5, 217, 0, 0, 2059, 2060, 5,
		218, 0, 0, 2060, 2061, 3, 180, 90, 0, 2061, 2062, 5, 219, 0, 0, 2062, 2064,
		1, 0, 0, 0, 2063, 2054, 1, 0, 0, 0, 2063, 2059, 1, 0, 0, 0, 2064, 285,
		1, 0, 0, 0, 2065, 2067, 3, 288, 144, 0, 2066, 2065, 1, 0, 0, 0, 2066, 2067,
		1, 0, 0, 0, 2067, 2074, 1, 0, 0, 0, 2068, 2070, 5, 220, 0, 0, 2069, 2071,
		3, 288, 144, 0, 2070, 2069, 1, 0, 0, 0, 2070, 2071, 1, 0, 0, 0, 2071, 2073,
		1, 0, 0, 0, 2072, 2068, 1, 0, 0, 0, 2073, 2076, 1, 0, 0, 0, 2074, 2072,
		1, 0, 0, 0, 2074, 2075, 1, 0, 0, 0, 2075, 287, 1, 0, 0, 0, 2076, 2074,
		1, 0, 0, 0, 2077, 2085, 3, 264, 132, 0, 2078, 2079, 5, 102, 0, 0, 2079,
		2080, 5, 214, 0, 0, 2080, 2081, 3, 286, 143, 0, 2081, 2082, 5, 215, 0,
		0, 2082, 2085, 1, 0, 0, 0, 2083, 2085, 3, 216, 108, 0, 2084, 2077, 1, 0,
		0, 0, 2084, 2078, 1, 0, 0, 0, 2084, 2083, 1, 0, 0, 0, 2085, 289, 1, 0,
		0, 0, 2086, 2087, 7, 20, 0, 0, 2087, 291, 1, 0, 0, 0, 2088, 2093, 5, 228,
		0, 0, 2089, 2093, 3, 294, 147, 0, 2090, 2091, 5, 196, 0, 0, 2091, 2093,
		3, 292, 146, 0, 2092, 2088, 1, 0, 0, 0, 2092, 2089, 1, 0, 0, 0, 2092, 2090,
		1, 0, 0, 0, 2093, 293, 1, 0, 0, 0, 2094, 2095, 7, 21, 0, 0, 2095, 295,
		1, 0, 0, 0, 2096, 2097, 7, 22, 0, 0, 2097, 297, 1, 0, 0, 0, 2098, 2099,
		7, 23, 0, 0, 2099, 299, 1, 0, 0, 0, 2100, 2101, 7, 24, 0, 0, 2101, 301,
		1, 0, 0, 0, 2102, 2103, 7, 25, 0, 0, 2103, 303, 1, 0, 0, 0, 2104, 2105,
		7, 26, 0, 0, 2105, 305, 1, 0, 0, 0, 265, 307, 312, 319, 324, 327, 353,
		357, 362, 367, 373, 376, 390, 394, 400, 405, 410, 417, 423, 430, 437, 440,
		444, 452, 455, 460, 463, 466, 469, 475, 479, 485, 487, 493, 505, 513, 521,
		525, 530, 536, 541, 547, 554, 561, 566, 572, 602, 616, 620, 629, 633, 638,
		664, 675, 679, 683, 692, 702, 706, 708, 714, 718, 720, 725, 733, 743, 751,
		757, 762, 768, 774, 780, 804, 809, 812, 822, 825, 838, 846, 853, 856, 861,
		865, 874, 878, 904, 909, 916, 923, 931, 934, 940, 944, 947, 952, 956, 959,
		962, 965, 973, 980, 989, 1002, 1014, 1024, 1028, 1035, 1041, 1044, 1048,
		1055, 1061, 1064, 1068, 1076, 1080, 1087, 1091, 1095, 1108, 1111, 1118,
		1125, 1129, 1135, 1139, 1144, 1149, 1156, 1164, 1173, 1177, 1183, 1192,
		1197, 1204, 1211, 1225, 1232, 1250, 1268, 1273, 1278, 1288, 1327, 1330,
		1364, 1402, 1436, 1438, 1447, 1453, 1459, 1461, 1476, 1482, 1488, 1494,
		1502, 1507, 1511, 1516, 1522, 1527, 1530, 1536, 1543, 1548, 1554, 1564,
		1569, 1573, 1577, 1580, 1587, 1590, 1595, 1599, 1605, 1609, 1620, 1632,
		1636, 1645, 1656, 1658, 1666, 1670, 1677, 1681, 1686, 1691, 1695, 1704,
		1710, 1716, 1720, 1725, 1728, 1731, 1734, 1737, 1742, 1746, 1752, 1754,
		1757, 1763, 1773, 1777, 1780, 1790, 1794, 1796, 1801, 1809, 1813, 1817,
		1824, 1829, 1835, 1839, 1844, 1847, 1852, 1862, 1869, 1871, 1877, 1879,
		1885, 1889, 1894, 1900, 1910, 1915, 1920, 1922, 1930, 1936, 1943, 1947,
		1952, 1959, 1966, 1970, 1978, 1983, 1993, 1998, 2003, 2009, 2015, 2019,
		2026, 2031, 2037, 2046, 2051, 2056, 2063, 2066, 2070, 2074, 2084, 2092,
	}
	deserializer := antlr.NewATNDeserializer(nil)
	staticData.atn = deserializer.Deserialize(staticData.serializedATN)
	atn := staticData.atn
	staticData.decisionToDFA = make([]*antlr.DFA, len(atn.DecisionToState))
	decisionToDFA := staticData.decisionToDFA
	for index, state := range atn.DecisionToState {
		decisionToDFA[index] = antlr.NewDFA(state, index)
	}
}

// PHPParserInit initializes any static state used to implement PHPParser. By default the
// static state used to implement the parser is lazily initialized during the first call to
// NewPHPParser(). You can call this function if you wish to initialize the static state ahead
// of time.
func PHPParserInit() {
	staticData := &phpparserParserStaticData
	staticData.once.Do(phpparserParserInit)
}

// NewPHPParser produces a new parser instance for the optional input antlr.TokenStream.
func NewPHPParser(input antlr.TokenStream) *PHPParser {
	PHPParserInit()
	this := new(PHPParser)
	this.BaseParser = antlr.NewBaseParser(input)
	staticData := &phpparserParserStaticData
	this.Interpreter = antlr.NewParserATNSimulator(this, staticData.atn, staticData.decisionToDFA, staticData.predictionContextCache)
	this.RuleNames = staticData.ruleNames
	this.LiteralNames = staticData.literalNames
	this.SymbolicNames = staticData.symbolicNames
	this.GrammarFileName = "java-escape"

	return this
}

// PHPParser tokens.
const (
	PHPParserEOF                        = antlr.TokenEOF
	PHPParserSeaWhitespace              = 1
	PHPParserHtmlText                   = 2
	PHPParserXmlStart                   = 3
	PHPParserPHPStart                   = 4
	PHPParserHtmlScriptOpen             = 5
	PHPParserHtmlStyleOpen              = 6
	PHPParserHtmlComment                = 7
	PHPParserHtmlDtd                    = 8
	PHPParserHtmlOpen                   = 9
	PHPParserShebang                    = 10
	PHPParserError                      = 11
	PHPParserXmlText                    = 12
	PHPParserXmlClose                   = 13
	PHPParserPHPStartInside             = 14
	PHPParserHtmlClose                  = 15
	PHPParserHtmlSlashClose             = 16
	PHPParserHtmlSlash                  = 17
	PHPParserHtmlEquals                 = 18
	PHPParserHtmlStartQuoteString       = 19
	PHPParserHtmlStartDoubleQuoteString = 20
	PHPParserHtmlHex                    = 21
	PHPParserHtmlDecimal                = 22
	PHPParserHtmlSpace                  = 23
	PHPParserHtmlName                   = 24
	PHPParserErrorInside                = 25
	PHPParserPHPStartInsideQuoteString  = 26
	PHPParserHtmlEndQuoteString         = 27
	PHPParserHtmlQuoteString            = 28
	PHPParserErrorHtmlQuote             = 29
	PHPParserPHPStartDoubleQuoteString  = 30
	PHPParserHtmlEndDoubleQuoteString   = 31
	PHPParserHtmlDoubleQuoteString      = 32
	PHPParserErrorHtmlDoubleQuote       = 33
	PHPParserScriptText                 = 34
	PHPParserHtmlScriptClose            = 35
	PHPParserPHPStartInsideScript       = 36
	PHPParserStyleBody                  = 37
	PHPParserPHPEnd                     = 38
	PHPParserWhitespace                 = 39
	PHPParserMultiLineComment           = 40
	PHPParserSingleLineComment          = 41
	PHPParserShellStyleComment          = 42
	PHPParserAttributeStart             = 43
	PHPParserAbstract                   = 44
	PHPParserArray                      = 45
	PHPParserAs                         = 46
	PHPParserBinaryCast                 = 47
	PHPParserBoolType                   = 48
	PHPParserBooleanConstant            = 49
	PHPParserBreak                      = 50
	PHPParserCallable                   = 51
	PHPParserCase                       = 52
	PHPParserCatch                      = 53
	PHPParserClass                      = 54
	PHPParserClone                      = 55
	PHPParserConst                      = 56
	PHPParserContinue                   = 57
	PHPParserDefine                     = 58
	PHPParserDefined                    = 59
	PHPParserDeclare                    = 60
	PHPParserDefault                    = 61
	PHPParserDo                         = 62
	PHPParserDoubleCast                 = 63
	PHPParserDoubleType                 = 64
	PHPParserEcho                       = 65
	PHPParserElse                       = 66
	PHPParserElseIf                     = 67
	PHPParserEmpty                      = 68
	PHPParserEnum_                      = 69
	PHPParserEndDeclare                 = 70
	PHPParserEndFor                     = 71
	PHPParserEndForeach                 = 72
	PHPParserEndIf                      = 73
	PHPParserEndSwitch                  = 74
	PHPParserEndWhile                   = 75
	PHPParserEval                       = 76
	PHPParserAssert                     = 77
	PHPParserDie                        = 78
	PHPParserExit                       = 79
	PHPParserExtends                    = 80
	PHPParserFinal                      = 81
	PHPParserFinally                    = 82
	PHPParserFloatCast                  = 83
	PHPParserFor                        = 84
	PHPParserForeach                    = 85
	PHPParserFunction_                  = 86
	PHPParserGlobal                     = 87
	PHPParserGoto                       = 88
	PHPParserIf                         = 89
	PHPParserImplements                 = 90
	PHPParserImport                     = 91
	PHPParserInclude                    = 92
	PHPParserIncludeOnce                = 93
	PHPParserInstanceOf                 = 94
	PHPParserInsteadOf                  = 95
	PHPParserInt8Cast                   = 96
	PHPParserInt16Cast                  = 97
	PHPParserInt64Type                  = 98
	PHPParserIntType                    = 99
	PHPParserInterface                  = 100
	PHPParserIsSet                      = 101
	PHPParserList                       = 102
	PHPParserLogicalAnd                 = 103
	PHPParserLogicalOr                  = 104
	PHPParserLogicalXor                 = 105
	PHPParserMatch_                     = 106
	PHPParserNamespace                  = 107
	PHPParserNew                        = 108
	PHPParserNull                       = 109
	PHPParserObjectType                 = 110
	PHPParserParent_                    = 111
	PHPParserPartial                    = 112
	PHPParserPrint                      = 113
	PHPParserPrivate                    = 114
	PHPParserProtected                  = 115
	PHPParserPublic                     = 116
	PHPParserReadonly                   = 117
	PHPParserRequire                    = 118
	PHPParserRequireOnce                = 119
	PHPParserResource                   = 120
	PHPParserReturn                     = 121
	PHPParserStatic                     = 122
	PHPParserStringType                 = 123
	PHPParserSwitch                     = 124
	PHPParserThrow                      = 125
	PHPParserTrait                      = 126
	PHPParserTry                        = 127
	PHPParserTypeof                     = 128
	PHPParserUintCast                   = 129
	PHPParserUnicodeCast                = 130
	PHPParserUnset                      = 131
	PHPParserUse                        = 132
	PHPParserVar                        = 133
	PHPParserWhile                      = 134
	PHPParserYield                      = 135
	PHPParserFrom                       = 136
	PHPParserLambdaFn                   = 137
	PHPParserTicks                      = 138
	PHPParserEncoding                   = 139
	PHPParserStrictTypes                = 140
	PHPParserGet                        = 141
	PHPParserSet                        = 142
	PHPParserCall                       = 143
	PHPParserCallStatic                 = 144
	PHPParserConstructor                = 145
	PHPParserDestruct                   = 146
	PHPParserWakeup                     = 147
	PHPParserSleep                      = 148
	PHPParserAutoload                   = 149
	PHPParserIsSet__                    = 150
	PHPParserUnset__                    = 151
	PHPParserToString__                 = 152
	PHPParserInvoke                     = 153
	PHPParserSetState                   = 154
	PHPParserClone__                    = 155
	PHPParserDebugInfo                  = 156
	PHPParserNamespace__                = 157
	PHPParserClass__                    = 158
	PHPParserTraic__                    = 159
	PHPParserFunction__                 = 160
	PHPParserMethod__                   = 161
	PHPParserLine__                     = 162
	PHPParserFile__                     = 163
	PHPParserDir__                      = 164
	PHPParserSpaceship                  = 165
	PHPParserDoubleArrow                = 166
	PHPParserInc                        = 167
	PHPParserDec                        = 168
	PHPParserIsIdentical                = 169
	PHPParserIsNoidentical              = 170
	PHPParserIsEqual                    = 171
	PHPParserIsNotEq                    = 172
	PHPParserIsSmallerOrEqual           = 173
	PHPParserIsGreaterOrEqual           = 174
	PHPParserPlusEqual                  = 175
	PHPParserMinusEqual                 = 176
	PHPParserMulEqual                   = 177
	PHPParserPow                        = 178
	PHPParserPowEqual                   = 179
	PHPParserDivEqual                   = 180
	PHPParserConcaequal                 = 181
	PHPParserModEqual                   = 182
	PHPParserShiftLeftEqual             = 183
	PHPParserShiftRightEqual            = 184
	PHPParserAndEqual                   = 185
	PHPParserOrEqual                    = 186
	PHPParserXorEqual                   = 187
	PHPParserBooleanOr                  = 188
	PHPParserBooleanAnd                 = 189
	PHPParserNullCoalescing             = 190
	PHPParserNullCoalescingEqual        = 191
	PHPParserShiftLeft                  = 192
	PHPParserShiftRight                 = 193
	PHPParserDoubleColon                = 194
	PHPParserObjectOperator             = 195
	PHPParserNamespaceSeparator         = 196
	PHPParserEllipsis                   = 197
	PHPParserLess                       = 198
	PHPParserGreater                    = 199
	PHPParserAmpersand                  = 200
	PHPParserPipe                       = 201
	PHPParserBang                       = 202
	PHPParserCaret                      = 203
	PHPParserPlus                       = 204
	PHPParserMinus                      = 205
	PHPParserAsterisk                   = 206
	PHPParserPercent                    = 207
	PHPParserDivide                     = 208
	PHPParserTilde                      = 209
	PHPParserSuppressWarnings           = 210
	PHPParserDollar                     = 211
	PHPParserDot                        = 212
	PHPParserQuestionMark               = 213
	PHPParserOpenRoundBracket           = 214
	PHPParserCloseRoundBracket          = 215
	PHPParserOpenSquareBracket          = 216
	PHPParserCloseSquareBracket         = 217
	PHPParserOpenCurlyBracket           = 218
	PHPParserCloseCurlyBracket          = 219
	PHPParserComma                      = 220
	PHPParserColon                      = 221
	PHPParserSemiColon                  = 222
	PHPParserEq                         = 223
	PHPParserQuote                      = 224
	PHPParserBackQuote                  = 225
	PHPParserSet_Include_Path           = 226
	PHPParserVarName                    = 227
	PHPParserLabel                      = 228
	PHPParserOctal                      = 229
	PHPParserDecimal                    = 230
	PHPParserReal                       = 231
	PHPParserHex                        = 232
	PHPParserBinary                     = 233
	PHPParserBackQuoteString            = 234
	PHPParserSingleQuoteString          = 235
	PHPParserDoubleQuote                = 236
	PHPParserStartNowDoc                = 237
	PHPParserStartHereDoc               = 238
	PHPParserErrorPhp                   = 239
	PHPParserCurlyDollar                = 240
	PHPParserUnicodeEscape              = 241
	PHPParserStringPart                 = 242
	PHPParserComment                    = 243
	PHPParserPHPEndSingleLineComment    = 244
	PHPParserCommentEnd                 = 245
	PHPParserHereDocText                = 246
	PHPParserXmlText2                   = 247
)

// PHPParser rules.
const (
	PHPParserRULE_htmlDocument                  = 0
	PHPParserRULE_htmlDocumentElement           = 1
	PHPParserRULE_inlineHtml                    = 2
	PHPParserRULE_htmlElement                   = 3
	PHPParserRULE_scriptText                    = 4
	PHPParserRULE_phpBlock                      = 5
	PHPParserRULE_importStatement               = 6
	PHPParserRULE_topStatement                  = 7
	PHPParserRULE_useDeclaration                = 8
	PHPParserRULE_useDeclarationContentList     = 9
	PHPParserRULE_useDeclarationContent         = 10
	PHPParserRULE_namespaceDeclaration          = 11
	PHPParserRULE_namespaceStatement            = 12
	PHPParserRULE_functionDeclaration           = 13
	PHPParserRULE_classDeclaration              = 14
	PHPParserRULE_classEntryType                = 15
	PHPParserRULE_interfaceList                 = 16
	PHPParserRULE_typeParameterList             = 17
	PHPParserRULE_typeParameterWithDefaultsList = 18
	PHPParserRULE_typeParameterDecl             = 19
	PHPParserRULE_typeParameterWithDefaultDecl  = 20
	PHPParserRULE_attributes                    = 21
	PHPParserRULE_attributeGroup                = 22
	PHPParserRULE_attribute                     = 23
	PHPParserRULE_innerStatementList            = 24
	PHPParserRULE_innerStatement                = 25
	PHPParserRULE_labelStatement                = 26
	PHPParserRULE_statement                     = 27
	PHPParserRULE_emptyStatement_               = 28
	PHPParserRULE_blockStatement                = 29
	PHPParserRULE_ifStatement                   = 30
	PHPParserRULE_elseIfStatement               = 31
	PHPParserRULE_elseIfColonStatement          = 32
	PHPParserRULE_elseStatement                 = 33
	PHPParserRULE_elseColonStatement            = 34
	PHPParserRULE_whileStatement                = 35
	PHPParserRULE_doWhileStatement              = 36
	PHPParserRULE_forStatement                  = 37
	PHPParserRULE_forInit                       = 38
	PHPParserRULE_forUpdate                     = 39
	PHPParserRULE_switchStatement               = 40
	PHPParserRULE_switchCaseBlock               = 41
	PHPParserRULE_switchDefaultBlock            = 42
	PHPParserRULE_switchBlock                   = 43
	PHPParserRULE_breakStatement                = 44
	PHPParserRULE_continueStatement             = 45
	PHPParserRULE_returnStatement               = 46
	PHPParserRULE_expressionStatement           = 47
	PHPParserRULE_unsetStatement                = 48
	PHPParserRULE_foreachStatement              = 49
	PHPParserRULE_tryCatchFinally               = 50
	PHPParserRULE_catchClause                   = 51
	PHPParserRULE_finallyStatement              = 52
	PHPParserRULE_throwStatement                = 53
	PHPParserRULE_gotoStatement                 = 54
	PHPParserRULE_declareStatement              = 55
	PHPParserRULE_inlineHtmlStatement           = 56
	PHPParserRULE_declareList                   = 57
	PHPParserRULE_directive                     = 58
	PHPParserRULE_formalParameterList           = 59
	PHPParserRULE_formalParameter               = 60
	PHPParserRULE_typeHint                      = 61
	PHPParserRULE_globalStatement               = 62
	PHPParserRULE_globalVar                     = 63
	PHPParserRULE_echoStatement                 = 64
	PHPParserRULE_staticVariableStatement       = 65
	PHPParserRULE_classStatement                = 66
	PHPParserRULE_traitAdaptations              = 67
	PHPParserRULE_traitAdaptationStatement      = 68
	PHPParserRULE_traitPrecedence               = 69
	PHPParserRULE_traitAlias                    = 70
	PHPParserRULE_traitMethodReference          = 71
	PHPParserRULE_baseCtorCall                  = 72
	PHPParserRULE_returnTypeDecl                = 73
	PHPParserRULE_methodBody                    = 74
	PHPParserRULE_propertyModifiers             = 75
	PHPParserRULE_memberModifiers               = 76
	PHPParserRULE_variableInitializer           = 77
	PHPParserRULE_identifierInitializer         = 78
	PHPParserRULE_globalConstantDeclaration     = 79
	PHPParserRULE_enumDeclaration               = 80
	PHPParserRULE_enumItem                      = 81
	PHPParserRULE_expressionList                = 82
	PHPParserRULE_parentheses                   = 83
	PHPParserRULE_fullyQualifiedNamespaceExpr   = 84
	PHPParserRULE_staticClassExpr               = 85
	PHPParserRULE_staticClassExprFunctionMember = 86
	PHPParserRULE_staticClassExprVariableMember = 87
	PHPParserRULE_memberCallKey                 = 88
	PHPParserRULE_indexMemberCallKey            = 89
	PHPParserRULE_expression                    = 90
	PHPParserRULE_flexiVariable                 = 91
	PHPParserRULE_defineExpr                    = 92
	PHPParserRULE_variable                      = 93
	PHPParserRULE_include                       = 94
	PHPParserRULE_leftArrayCreation             = 95
	PHPParserRULE_assignable                    = 96
	PHPParserRULE_arrayCreation                 = 97
	PHPParserRULE_arrayDestructuring            = 98
	PHPParserRULE_indexedDestructItem           = 99
	PHPParserRULE_keyedDestructItem             = 100
	PHPParserRULE_lambdaFunctionExpr            = 101
	PHPParserRULE_matchExpr                     = 102
	PHPParserRULE_matchItem                     = 103
	PHPParserRULE_newExpr                       = 104
	PHPParserRULE_assignmentOperator            = 105
	PHPParserRULE_yieldExpression               = 106
	PHPParserRULE_arrayItemList                 = 107
	PHPParserRULE_arrayItem                     = 108
	PHPParserRULE_lambdaFunctionUseVars         = 109
	PHPParserRULE_lambdaFunctionUseVar          = 110
	PHPParserRULE_qualifiedStaticTypeRef        = 111
	PHPParserRULE_typeRef                       = 112
	PHPParserRULE_anonymousClass                = 113
	PHPParserRULE_indirectTypeRef               = 114
	PHPParserRULE_qualifiedNamespaceName        = 115
	PHPParserRULE_namespaceNameList             = 116
	PHPParserRULE_namespaceNameTail             = 117
	PHPParserRULE_qualifiedNamespaceNameList    = 118
	PHPParserRULE_arguments                     = 119
	PHPParserRULE_actualArgument                = 120
	PHPParserRULE_argumentName                  = 121
	PHPParserRULE_constantInitializer           = 122
	PHPParserRULE_constantString                = 123
	PHPParserRULE_constant                      = 124
	PHPParserRULE_literalConstant               = 125
	PHPParserRULE_numericConstant               = 126
	PHPParserRULE_classConstant                 = 127
	PHPParserRULE_stringConstant                = 128
	PHPParserRULE_string                        = 129
	PHPParserRULE_interpolatedStringPart        = 130
	PHPParserRULE_chainList                     = 131
	PHPParserRULE_chain                         = 132
	PHPParserRULE_chainOrigin                   = 133
	PHPParserRULE_memberAccess                  = 134
	PHPParserRULE_functionCall                  = 135
	PHPParserRULE_functionCallName              = 136
	PHPParserRULE_actualArguments               = 137
	PHPParserRULE_chainBase                     = 138
	PHPParserRULE_keyedFieldName                = 139
	PHPParserRULE_keyedSimpleFieldName          = 140
	PHPParserRULE_keyedVariable                 = 141
	PHPParserRULE_squareCurlyExpression         = 142
	PHPParserRULE_assignmentList                = 143
	PHPParserRULE_assignmentListElement         = 144
	PHPParserRULE_modifier                      = 145
	PHPParserRULE_identifier                    = 146
	PHPParserRULE_key                           = 147
	PHPParserRULE_memberModifier                = 148
	PHPParserRULE_magicConstant                 = 149
	PHPParserRULE_magicMethod                   = 150
	PHPParserRULE_primitiveType                 = 151
	PHPParserRULE_castOperation                 = 152
)

// IHtmlDocumentContext is an interface to support dynamic dispatch.
type IHtmlDocumentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsHtmlDocumentContext differentiates from other interfaces.
	IsHtmlDocumentContext()
}

type HtmlDocumentContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyHtmlDocumentContext() *HtmlDocumentContext {
	var p = new(HtmlDocumentContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PHPParserRULE_htmlDocument
	return p
}

func (*HtmlDocumentContext) IsHtmlDocumentContext() {}

func NewHtmlDocumentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *HtmlDocumentContext {
	var p = new(HtmlDocumentContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PHPParserRULE_htmlDocument

	return p
}

func (s *HtmlDocumentContext) GetParser() antlr.Parser { return s.parser }

func (s *HtmlDocumentContext) EOF() antlr.TerminalNode {
	return s.GetToken(PHPParserEOF, 0)
}

func (s *HtmlDocumentContext) Shebang() antlr.TerminalNode {
	return s.GetToken(PHPParserShebang, 0)
}

func (s *HtmlDocumentContext) AllHtmlDocumentElement() []IHtmlDocumentElementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IHtmlDocumentElementContext); ok {
			len++
		}
	}

	tst := make([]IHtmlDocumentElementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IHtmlDocumentElementContext); ok {
			tst[i] = t.(IHtmlDocumentElementContext)
			i++
		}
	}

	return tst
}

func (s *HtmlDocumentContext) HtmlDocumentElement(i int) IHtmlDocumentElementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IHtmlDocumentElementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IHtmlDocumentElementContext)
}

func (s *HtmlDocumentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *HtmlDocumentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *HtmlDocumentContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PHPParserVisitor:
		return t.VisitHtmlDocument(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PHPParser) HtmlDocument() (localctx IHtmlDocumentContext) {
	this := p
	_ = this

	localctx = NewHtmlDocumentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 0, PHPParserRULE_htmlDocument)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(307)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == PHPParserShebang {
		{
			p.SetState(306)
			p.Match(PHPParserShebang)
		}

	}
	p.SetState(312)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for (int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-8600244223124) != 0 || (int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&-1) != 0 || (int64((_la-128)) & ^0x3f) == 0 && ((int64(1)<<(_la-128))&1786706395135) != 0 || (int64((_la-196)) & ^0x3f) == 0 && ((int64(1)<<(_la-196))&8795091952465) != 0 {
		{
			p.SetState(309)
			p.HtmlDocumentElement()
		}

		p.SetState(314)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(315)
		p.Match(PHPParserEOF)
	}

	return localctx
}

// IHtmlDocumentElementContext is an interface to support dynamic dispatch.
type IHtmlDocumentElementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsHtmlDocumentElementContext differentiates from other interfaces.
	IsHtmlDocumentElementContext()
}

type HtmlDocumentElementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyHtmlDocumentElementContext() *HtmlDocumentElementContext {
	var p = new(HtmlDocumentElementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PHPParserRULE_htmlDocumentElement
	return p
}

func (*HtmlDocumentElementContext) IsHtmlDocumentElementContext() {}

func NewHtmlDocumentElementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *HtmlDocumentElementContext {
	var p = new(HtmlDocumentElementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PHPParserRULE_htmlDocumentElement

	return p
}

func (s *HtmlDocumentElementContext) GetParser() antlr.Parser { return s.parser }

func (s *HtmlDocumentElementContext) InlineHtml() IInlineHtmlContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInlineHtmlContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInlineHtmlContext)
}

func (s *HtmlDocumentElementContext) PhpBlock() IPhpBlockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPhpBlockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPhpBlockContext)
}

func (s *HtmlDocumentElementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *HtmlDocumentElementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *HtmlDocumentElementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PHPParserVisitor:
		return t.VisitHtmlDocumentElement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PHPParser) HtmlDocumentElement() (localctx IHtmlDocumentElementContext) {
	this := p
	_ = this

	localctx = NewHtmlDocumentElementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 2, PHPParserRULE_htmlDocumentElement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(319)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 2, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(317)
			p.InlineHtml()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(318)
			p.PhpBlock()
		}

	}

	return localctx
}

// IInlineHtmlContext is an interface to support dynamic dispatch.
type IInlineHtmlContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInlineHtmlContext differentiates from other interfaces.
	IsInlineHtmlContext()
}

type InlineHtmlContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInlineHtmlContext() *InlineHtmlContext {
	var p = new(InlineHtmlContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PHPParserRULE_inlineHtml
	return p
}

func (*InlineHtmlContext) IsInlineHtmlContext() {}

func NewInlineHtmlContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InlineHtmlContext {
	var p = new(InlineHtmlContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PHPParserRULE_inlineHtml

	return p
}

func (s *InlineHtmlContext) GetParser() antlr.Parser { return s.parser }

func (s *InlineHtmlContext) AllHtmlElement() []IHtmlElementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IHtmlElementContext); ok {
			len++
		}
	}

	tst := make([]IHtmlElementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IHtmlElementContext); ok {
			tst[i] = t.(IHtmlElementContext)
			i++
		}
	}

	return tst
}

func (s *InlineHtmlContext) HtmlElement(i int) IHtmlElementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IHtmlElementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IHtmlElementContext)
}

func (s *InlineHtmlContext) ScriptText() IScriptTextContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IScriptTextContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IScriptTextContext)
}

func (s *InlineHtmlContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InlineHtmlContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InlineHtmlContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PHPParserVisitor:
		return t.VisitInlineHtml(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PHPParser) InlineHtml() (localctx IInlineHtmlContext) {
	this := p
	_ = this

	localctx = NewInlineHtmlContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 4, PHPParserRULE_inlineHtml)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.SetState(327)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case PHPParserHtmlText, PHPParserXmlStart, PHPParserHtmlScriptOpen, PHPParserHtmlStyleOpen, PHPParserHtmlDtd, PHPParserHtmlOpen, PHPParserHtmlClose, PHPParserHtmlSlashClose, PHPParserHtmlSlash, PHPParserHtmlEquals, PHPParserHtmlStartQuoteString, PHPParserHtmlStartDoubleQuoteString, PHPParserHtmlHex, PHPParserHtmlDecimal, PHPParserHtmlName, PHPParserHtmlEndQuoteString, PHPParserHtmlQuoteString, PHPParserHtmlEndDoubleQuoteString, PHPParserHtmlDoubleQuoteString, PHPParserHtmlScriptClose, PHPParserStyleBody:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(322)
		p.GetErrorHandler().Sync(p)
		_alt = 1
		for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			switch _alt {
			case 1:
				{
					p.SetState(321)
					p.HtmlElement()
				}

			default:
				panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			}

			p.SetState(324)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 3, p.GetParserRuleContext())
		}

	case PHPParserScriptText:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(326)
			p.ScriptText()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IHtmlElementContext is an interface to support dynamic dispatch.
type IHtmlElementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsHtmlElementContext differentiates from other interfaces.
	IsHtmlElementContext()
}

type HtmlElementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyHtmlElementContext() *HtmlElementContext {
	var p = new(HtmlElementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PHPParserRULE_htmlElement
	return p
}

func (*HtmlElementContext) IsHtmlElementContext() {}

func NewHtmlElementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *HtmlElementContext {
	var p = new(HtmlElementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PHPParserRULE_htmlElement

	return p
}

func (s *HtmlElementContext) GetParser() antlr.Parser { return s.parser }

func (s *HtmlElementContext) HtmlDtd() antlr.TerminalNode {
	return s.GetToken(PHPParserHtmlDtd, 0)
}

func (s *HtmlElementContext) HtmlClose() antlr.TerminalNode {
	return s.GetToken(PHPParserHtmlClose, 0)
}

func (s *HtmlElementContext) HtmlStyleOpen() antlr.TerminalNode {
	return s.GetToken(PHPParserHtmlStyleOpen, 0)
}

func (s *HtmlElementContext) HtmlOpen() antlr.TerminalNode {
	return s.GetToken(PHPParserHtmlOpen, 0)
}

func (s *HtmlElementContext) HtmlName() antlr.TerminalNode {
	return s.GetToken(PHPParserHtmlName, 0)
}

func (s *HtmlElementContext) HtmlSlashClose() antlr.TerminalNode {
	return s.GetToken(PHPParserHtmlSlashClose, 0)
}

func (s *HtmlElementContext) HtmlSlash() antlr.TerminalNode {
	return s.GetToken(PHPParserHtmlSlash, 0)
}

func (s *HtmlElementContext) HtmlText() antlr.TerminalNode {
	return s.GetToken(PHPParserHtmlText, 0)
}

func (s *HtmlElementContext) HtmlEquals() antlr.TerminalNode {
	return s.GetToken(PHPParserHtmlEquals, 0)
}

func (s *HtmlElementContext) HtmlStartQuoteString() antlr.TerminalNode {
	return s.GetToken(PHPParserHtmlStartQuoteString, 0)
}

func (s *HtmlElementContext) HtmlEndQuoteString() antlr.TerminalNode {
	return s.GetToken(PHPParserHtmlEndQuoteString, 0)
}

func (s *HtmlElementContext) HtmlStartDoubleQuoteString() antlr.TerminalNode {
	return s.GetToken(PHPParserHtmlStartDoubleQuoteString, 0)
}

func (s *HtmlElementContext) HtmlEndDoubleQuoteString() antlr.TerminalNode {
	return s.GetToken(PHPParserHtmlEndDoubleQuoteString, 0)
}

func (s *HtmlElementContext) HtmlHex() antlr.TerminalNode {
	return s.GetToken(PHPParserHtmlHex, 0)
}

func (s *HtmlElementContext) HtmlDecimal() antlr.TerminalNode {
	return s.GetToken(PHPParserHtmlDecimal, 0)
}

func (s *HtmlElementContext) HtmlQuoteString() antlr.TerminalNode {
	return s.GetToken(PHPParserHtmlQuoteString, 0)
}

func (s *HtmlElementContext) HtmlDoubleQuoteString() antlr.TerminalNode {
	return s.GetToken(PHPParserHtmlDoubleQuoteString, 0)
}

func (s *HtmlElementContext) StyleBody() antlr.TerminalNode {
	return s.GetToken(PHPParserStyleBody, 0)
}

func (s *HtmlElementContext) HtmlScriptOpen() antlr.TerminalNode {
	return s.GetToken(PHPParserHtmlScriptOpen, 0)
}

func (s *HtmlElementContext) HtmlScriptClose() antlr.TerminalNode {
	return s.GetToken(PHPParserHtmlScriptClose, 0)
}

func (s *HtmlElementContext) XmlStart() antlr.TerminalNode {
	return s.GetToken(PHPParserXmlStart, 0)
}

func (s *HtmlElementContext) XmlClose() antlr.TerminalNode {
	return s.GetToken(PHPParserXmlClose, 0)
}

func (s *HtmlElementContext) AllXmlText() []antlr.TerminalNode {
	return s.GetTokens(PHPParserXmlText)
}

func (s *HtmlElementContext) XmlText(i int) antlr.TerminalNode {
	return s.GetToken(PHPParserXmlText, i)
}

func (s *HtmlElementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *HtmlElementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *HtmlElementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PHPParserVisitor:
		return t.VisitHtmlElement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PHPParser) HtmlElement() (localctx IHtmlElementContext) {
	this := p
	_ = this

	localctx = NewHtmlElementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 6, PHPParserRULE_htmlElement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(357)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case PHPParserHtmlDtd:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(329)
			p.Match(PHPParserHtmlDtd)
		}

	case PHPParserHtmlClose:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(330)
			p.Match(PHPParserHtmlClose)
		}

	case PHPParserHtmlStyleOpen:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(331)
			p.Match(PHPParserHtmlStyleOpen)
		}

	case PHPParserHtmlOpen:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(332)
			p.Match(PHPParserHtmlOpen)
		}

	case PHPParserHtmlName:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(333)
			p.Match(PHPParserHtmlName)
		}

	case PHPParserHtmlSlashClose:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(334)
			p.Match(PHPParserHtmlSlashClose)
		}

	case PHPParserHtmlSlash:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(335)
			p.Match(PHPParserHtmlSlash)
		}

	case PHPParserHtmlText:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(336)
			p.Match(PHPParserHtmlText)
		}

	case PHPParserHtmlEquals:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(337)
			p.Match(PHPParserHtmlEquals)
		}

	case PHPParserHtmlStartQuoteString:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(338)
			p.Match(PHPParserHtmlStartQuoteString)
		}

	case PHPParserHtmlEndQuoteString:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(339)
			p.Match(PHPParserHtmlEndQuoteString)
		}

	case PHPParserHtmlStartDoubleQuoteString:
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(340)
			p.Match(PHPParserHtmlStartDoubleQuoteString)
		}

	case PHPParserHtmlEndDoubleQuoteString:
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(341)
			p.Match(PHPParserHtmlEndDoubleQuoteString)
		}

	case PHPParserHtmlHex:
		p.EnterOuterAlt(localctx, 14)
		{
			p.SetState(342)
			p.Match(PHPParserHtmlHex)
		}

	case PHPParserHtmlDecimal:
		p.EnterOuterAlt(localctx, 15)
		{
			p.SetState(343)
			p.Match(PHPParserHtmlDecimal)
		}

	case PHPParserHtmlQuoteString:
		p.EnterOuterAlt(localctx, 16)
		{
			p.SetState(344)
			p.Match(PHPParserHtmlQuoteString)
		}

	case PHPParserHtmlDoubleQuoteString:
		p.EnterOuterAlt(localctx, 17)
		{
			p.SetState(345)
			p.Match(PHPParserHtmlDoubleQuoteString)
		}

	case PHPParserStyleBody:
		p.EnterOuterAlt(localctx, 18)
		{
			p.SetState(346)
			p.Match(PHPParserStyleBody)
		}

	case PHPParserHtmlScriptOpen:
		p.EnterOuterAlt(localctx, 19)
		{
			p.SetState(347)
			p.Match(PHPParserHtmlScriptOpen)
		}

	case PHPParserHtmlScriptClose:
		p.EnterOuterAlt(localctx, 20)
		{
			p.SetState(348)
			p.Match(PHPParserHtmlScriptClose)
		}

	case PHPParserXmlStart:
		p.EnterOuterAlt(localctx, 21)
		{
			p.SetState(349)
			p.Match(PHPParserXmlStart)
		}
		p.SetState(353)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == PHPParserXmlText {
			{
				p.SetState(350)
				p.Match(PHPParserXmlText)
			}

			p.SetState(355)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(356)
			p.Match(PHPParserXmlClose)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IScriptTextContext is an interface to support dynamic dispatch.
type IScriptTextContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsScriptTextContext differentiates from other interfaces.
	IsScriptTextContext()
}

type ScriptTextContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyScriptTextContext() *ScriptTextContext {
	var p = new(ScriptTextContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PHPParserRULE_scriptText
	return p
}

func (*ScriptTextContext) IsScriptTextContext() {}

func NewScriptTextContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ScriptTextContext {
	var p = new(ScriptTextContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PHPParserRULE_scriptText

	return p
}

func (s *ScriptTextContext) GetParser() antlr.Parser { return s.parser }

func (s *ScriptTextContext) AllScriptText() []antlr.TerminalNode {
	return s.GetTokens(PHPParserScriptText)
}

func (s *ScriptTextContext) ScriptText(i int) antlr.TerminalNode {
	return s.GetToken(PHPParserScriptText, i)
}

func (s *ScriptTextContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ScriptTextContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ScriptTextContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PHPParserVisitor:
		return t.VisitScriptText(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PHPParser) ScriptText() (localctx IScriptTextContext) {
	this := p
	_ = this

	localctx = NewScriptTextContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 8, PHPParserRULE_scriptText)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(360)
	p.GetErrorHandler().Sync(p)
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			{
				p.SetState(359)
				p.Match(PHPParserScriptText)
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(362)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 7, p.GetParserRuleContext())
	}

	return localctx
}

// IPhpBlockContext is an interface to support dynamic dispatch.
type IPhpBlockContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPhpBlockContext differentiates from other interfaces.
	IsPhpBlockContext()
}

type PhpBlockContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPhpBlockContext() *PhpBlockContext {
	var p = new(PhpBlockContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PHPParserRULE_phpBlock
	return p
}

func (*PhpBlockContext) IsPhpBlockContext() {}

func NewPhpBlockContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PhpBlockContext {
	var p = new(PhpBlockContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PHPParserRULE_phpBlock

	return p
}

func (s *PhpBlockContext) GetParser() antlr.Parser { return s.parser }

func (s *PhpBlockContext) AllImportStatement() []IImportStatementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IImportStatementContext); ok {
			len++
		}
	}

	tst := make([]IImportStatementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IImportStatementContext); ok {
			tst[i] = t.(IImportStatementContext)
			i++
		}
	}

	return tst
}

func (s *PhpBlockContext) ImportStatement(i int) IImportStatementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IImportStatementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IImportStatementContext)
}

func (s *PhpBlockContext) AllTopStatement() []ITopStatementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITopStatementContext); ok {
			len++
		}
	}

	tst := make([]ITopStatementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITopStatementContext); ok {
			tst[i] = t.(ITopStatementContext)
			i++
		}
	}

	return tst
}

func (s *PhpBlockContext) TopStatement(i int) ITopStatementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITopStatementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITopStatementContext)
}

func (s *PhpBlockContext) PHPEnd() antlr.TerminalNode {
	return s.GetToken(PHPParserPHPEnd, 0)
}

func (s *PhpBlockContext) PHPEndSingleLineComment() antlr.TerminalNode {
	return s.GetToken(PHPParserPHPEndSingleLineComment, 0)
}

func (s *PhpBlockContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PhpBlockContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PhpBlockContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PHPParserVisitor:
		return t.VisitPhpBlock(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PHPParser) PhpBlock() (localctx IPhpBlockContext) {
	this := p
	_ = this

	localctx = NewPhpBlockContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 10, PHPParserRULE_phpBlock)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(367)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 8, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(364)
				p.ImportStatement()
			}

		}
		p.SetState(369)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 8, p.GetParserRuleContext())
	}
	p.SetState(371)
	p.GetErrorHandler().Sync(p)
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			{
				p.SetState(370)
				p.TopStatement()
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(373)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 9, p.GetParserRuleContext())
	}
	p.SetState(376)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == PHPParserPHPEnd || _la == PHPParserPHPEndSingleLineComment {
		{
			p.SetState(375)
			_la = p.GetTokenStream().LA(1)

			if !(_la == PHPParserPHPEnd || _la == PHPParserPHPEndSingleLineComment) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}

	return localctx
}

// IImportStatementContext is an interface to support dynamic dispatch.
type IImportStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsImportStatementContext differentiates from other interfaces.
	IsImportStatementContext()
}

type ImportStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyImportStatementContext() *ImportStatementContext {
	var p = new(ImportStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PHPParserRULE_importStatement
	return p
}

func (*ImportStatementContext) IsImportStatementContext() {}

func NewImportStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ImportStatementContext {
	var p = new(ImportStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PHPParserRULE_importStatement

	return p
}

func (s *ImportStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ImportStatementContext) Import() antlr.TerminalNode {
	return s.GetToken(PHPParserImport, 0)
}

func (s *ImportStatementContext) Namespace() antlr.TerminalNode {
	return s.GetToken(PHPParserNamespace, 0)
}

func (s *ImportStatementContext) NamespaceNameList() INamespaceNameListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INamespaceNameListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INamespaceNameListContext)
}

func (s *ImportStatementContext) SemiColon() antlr.TerminalNode {
	return s.GetToken(PHPParserSemiColon, 0)
}

func (s *ImportStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ImportStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ImportStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PHPParserVisitor:
		return t.VisitImportStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PHPParser) ImportStatement() (localctx IImportStatementContext) {
	this := p
	_ = this

	localctx = NewImportStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 12, PHPParserRULE_importStatement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(378)
		p.Match(PHPParserImport)
	}
	{
		p.SetState(379)
		p.Match(PHPParserNamespace)
	}
	{
		p.SetState(380)
		p.NamespaceNameList()
	}
	{
		p.SetState(381)
		p.Match(PHPParserSemiColon)
	}

	return localctx
}

// ITopStatementContext is an interface to support dynamic dispatch.
type ITopStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTopStatementContext differentiates from other interfaces.
	IsTopStatementContext()
}

type TopStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTopStatementContext() *TopStatementContext {
	var p = new(TopStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PHPParserRULE_topStatement
	return p
}

func (*TopStatementContext) IsTopStatementContext() {}

func NewTopStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TopStatementContext {
	var p = new(TopStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PHPParserRULE_topStatement

	return p
}

func (s *TopStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *TopStatementContext) Statement() IStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *TopStatementContext) UseDeclaration() IUseDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUseDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUseDeclarationContext)
}

func (s *TopStatementContext) NamespaceDeclaration() INamespaceDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INamespaceDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INamespaceDeclarationContext)
}

func (s *TopStatementContext) FunctionDeclaration() IFunctionDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionDeclarationContext)
}

func (s *TopStatementContext) ClassDeclaration() IClassDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClassDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClassDeclarationContext)
}

func (s *TopStatementContext) GlobalConstantDeclaration() IGlobalConstantDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGlobalConstantDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGlobalConstantDeclarationContext)
}

func (s *TopStatementContext) EnumDeclaration() IEnumDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEnumDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEnumDeclarationContext)
}

func (s *TopStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TopStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TopStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PHPParserVisitor:
		return t.VisitTopStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PHPParser) TopStatement() (localctx ITopStatementContext) {
	this := p
	_ = this

	localctx = NewTopStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 14, PHPParserRULE_topStatement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(390)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 11, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(383)
			p.Statement()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(384)
			p.UseDeclaration()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(385)
			p.NamespaceDeclaration()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(386)
			p.FunctionDeclaration()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(387)
			p.ClassDeclaration()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(388)
			p.GlobalConstantDeclaration()
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(389)
			p.EnumDeclaration()
		}

	}

	return localctx
}

// IUseDeclarationContext is an interface to support dynamic dispatch.
type IUseDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsUseDeclarationContext differentiates from other interfaces.
	IsUseDeclarationContext()
}

type UseDeclarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUseDeclarationContext() *UseDeclarationContext {
	var p = new(UseDeclarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PHPParserRULE_useDeclaration
	return p
}

func (*UseDeclarationContext) IsUseDeclarationContext() {}

func NewUseDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UseDeclarationContext {
	var p = new(UseDeclarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PHPParserRULE_useDeclaration

	return p
}

func (s *UseDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *UseDeclarationContext) Use() antlr.TerminalNode {
	return s.GetToken(PHPParserUse, 0)
}

func (s *UseDeclarationContext) UseDeclarationContentList() IUseDeclarationContentListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUseDeclarationContentListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUseDeclarationContentListContext)
}

func (s *UseDeclarationContext) SemiColon() antlr.TerminalNode {
	return s.GetToken(PHPParserSemiColon, 0)
}

func (s *UseDeclarationContext) Function_() antlr.TerminalNode {
	return s.GetToken(PHPParserFunction_, 0)
}

func (s *UseDeclarationContext) Const() antlr.TerminalNode {
	return s.GetToken(PHPParserConst, 0)
}

func (s *UseDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UseDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UseDeclarationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PHPParserVisitor:
		return t.VisitUseDeclaration(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PHPParser) UseDeclaration() (localctx IUseDeclarationContext) {
	this := p
	_ = this

	localctx = NewUseDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 16, PHPParserRULE_useDeclaration)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(392)
		p.Match(PHPParserUse)
	}
	p.SetState(394)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 12, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(393)
			_la = p.GetTokenStream().LA(1)

			if !(_la == PHPParserConst || _la == PHPParserFunction_) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}
	{
		p.SetState(396)
		p.UseDeclarationContentList()
	}
	{
		p.SetState(397)
		p.Match(PHPParserSemiColon)
	}

	return localctx
}

// IUseDeclarationContentListContext is an interface to support dynamic dispatch.
type IUseDeclarationContentListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsUseDeclarationContentListContext differentiates from other interfaces.
	IsUseDeclarationContentListContext()
}

type UseDeclarationContentListContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUseDeclarationContentListContext() *UseDeclarationContentListContext {
	var p = new(UseDeclarationContentListContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PHPParserRULE_useDeclarationContentList
	return p
}

func (*UseDeclarationContentListContext) IsUseDeclarationContentListContext() {}

func NewUseDeclarationContentListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UseDeclarationContentListContext {
	var p = new(UseDeclarationContentListContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PHPParserRULE_useDeclarationContentList

	return p
}

func (s *UseDeclarationContentListContext) GetParser() antlr.Parser { return s.parser }

func (s *UseDeclarationContentListContext) AllUseDeclarationContent() []IUseDeclarationContentContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IUseDeclarationContentContext); ok {
			len++
		}
	}

	tst := make([]IUseDeclarationContentContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IUseDeclarationContentContext); ok {
			tst[i] = t.(IUseDeclarationContentContext)
			i++
		}
	}

	return tst
}

func (s *UseDeclarationContentListContext) UseDeclarationContent(i int) IUseDeclarationContentContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUseDeclarationContentContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUseDeclarationContentContext)
}

func (s *UseDeclarationContentListContext) AllNamespaceSeparator() []antlr.TerminalNode {
	return s.GetTokens(PHPParserNamespaceSeparator)
}

func (s *UseDeclarationContentListContext) NamespaceSeparator(i int) antlr.TerminalNode {
	return s.GetToken(PHPParserNamespaceSeparator, i)
}

func (s *UseDeclarationContentListContext) AllComma() []antlr.TerminalNode {
	return s.GetTokens(PHPParserComma)
}

func (s *UseDeclarationContentListContext) Comma(i int) antlr.TerminalNode {
	return s.GetToken(PHPParserComma, i)
}

func (s *UseDeclarationContentListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UseDeclarationContentListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UseDeclarationContentListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PHPParserVisitor:
		return t.VisitUseDeclarationContentList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PHPParser) UseDeclarationContentList() (localctx IUseDeclarationContentListContext) {
	this := p
	_ = this

	localctx = NewUseDeclarationContentListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 18, PHPParserRULE_useDeclarationContentList)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(400)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 13, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(399)
			p.Match(PHPParserNamespaceSeparator)
		}

	}
	{
		p.SetState(402)
		p.UseDeclarationContent()
	}
	p.SetState(410)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == PHPParserComma {
		{
			p.SetState(403)
			p.Match(PHPParserComma)
		}
		p.SetState(405)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 14, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(404)
				p.Match(PHPParserNamespaceSeparator)
			}

		}
		{
			p.SetState(407)
			p.UseDeclarationContent()
		}

		p.SetState(412)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IUseDeclarationContentContext is an interface to support dynamic dispatch.
type IUseDeclarationContentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsUseDeclarationContentContext differentiates from other interfaces.
	IsUseDeclarationContentContext()
}

type UseDeclarationContentContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUseDeclarationContentContext() *UseDeclarationContentContext {
	var p = new(UseDeclarationContentContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PHPParserRULE_useDeclarationContent
	return p
}

func (*UseDeclarationContentContext) IsUseDeclarationContentContext() {}

func NewUseDeclarationContentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UseDeclarationContentContext {
	var p = new(UseDeclarationContentContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PHPParserRULE_useDeclarationContent

	return p
}

func (s *UseDeclarationContentContext) GetParser() antlr.Parser { return s.parser }

func (s *UseDeclarationContentContext) NamespaceNameList() INamespaceNameListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INamespaceNameListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INamespaceNameListContext)
}

func (s *UseDeclarationContentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UseDeclarationContentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UseDeclarationContentContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PHPParserVisitor:
		return t.VisitUseDeclarationContent(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PHPParser) UseDeclarationContent() (localctx IUseDeclarationContentContext) {
	this := p
	_ = this

	localctx = NewUseDeclarationContentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 20, PHPParserRULE_useDeclarationContent)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(413)
		p.NamespaceNameList()
	}

	return localctx
}

// INamespaceDeclarationContext is an interface to support dynamic dispatch.
type INamespaceDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsNamespaceDeclarationContext differentiates from other interfaces.
	IsNamespaceDeclarationContext()
}

type NamespaceDeclarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNamespaceDeclarationContext() *NamespaceDeclarationContext {
	var p = new(NamespaceDeclarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PHPParserRULE_namespaceDeclaration
	return p
}

func (*NamespaceDeclarationContext) IsNamespaceDeclarationContext() {}

func NewNamespaceDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NamespaceDeclarationContext {
	var p = new(NamespaceDeclarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PHPParserRULE_namespaceDeclaration

	return p
}

func (s *NamespaceDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *NamespaceDeclarationContext) Namespace() antlr.TerminalNode {
	return s.GetToken(PHPParserNamespace, 0)
}

func (s *NamespaceDeclarationContext) OpenCurlyBracket() antlr.TerminalNode {
	return s.GetToken(PHPParserOpenCurlyBracket, 0)
}

func (s *NamespaceDeclarationContext) CloseCurlyBracket() antlr.TerminalNode {
	return s.GetToken(PHPParserCloseCurlyBracket, 0)
}

func (s *NamespaceDeclarationContext) NamespaceNameList() INamespaceNameListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INamespaceNameListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INamespaceNameListContext)
}

func (s *NamespaceDeclarationContext) SemiColon() antlr.TerminalNode {
	return s.GetToken(PHPParserSemiColon, 0)
}

func (s *NamespaceDeclarationContext) AllNamespaceStatement() []INamespaceStatementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(INamespaceStatementContext); ok {
			len++
		}
	}

	tst := make([]INamespaceStatementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(INamespaceStatementContext); ok {
			tst[i] = t.(INamespaceStatementContext)
			i++
		}
	}

	return tst
}

func (s *NamespaceDeclarationContext) NamespaceStatement(i int) INamespaceStatementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INamespaceStatementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(INamespaceStatementContext)
}

func (s *NamespaceDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NamespaceDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NamespaceDeclarationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PHPParserVisitor:
		return t.VisitNamespaceDeclaration(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PHPParser) NamespaceDeclaration() (localctx INamespaceDeclarationContext) {
	this := p
	_ = this

	localctx = NewNamespaceDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 22, PHPParserRULE_namespaceDeclaration)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(415)
		p.Match(PHPParserNamespace)
	}
	p.SetState(430)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 18, p.GetParserRuleContext()) {
	case 1:
		p.SetState(417)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if (int64((_la-44)) & ^0x3f) == 0 && ((int64(1)<<(_la-44))&-144959677430546433) != 0 || (int64((_la-108)) & ^0x3f) == 0 && ((int64(1)<<(_la-108))&144115188067333119) != 0 || _la == PHPParserNamespaceSeparator || _la == PHPParserLabel {
			{
				p.SetState(416)
				p.NamespaceNameList()
			}

		}
		{
			p.SetState(419)
			p.Match(PHPParserOpenCurlyBracket)
		}
		p.SetState(423)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for (int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-8600244223124) != 0 || (int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&-1) != 0 || (int64((_la-128)) & ^0x3f) == 0 && ((int64(1)<<(_la-128))&1786706395135) != 0 || (int64((_la-196)) & ^0x3f) == 0 && ((int64(1)<<(_la-196))&8795091952465) != 0 {
			{
				p.SetState(420)
				p.NamespaceStatement()
			}

			p.SetState(425)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(426)
			p.Match(PHPParserCloseCurlyBracket)
		}

	case 2:
		{
			p.SetState(427)
			p.NamespaceNameList()
		}
		{
			p.SetState(428)
			p.Match(PHPParserSemiColon)
		}

	}

	return localctx
}

// INamespaceStatementContext is an interface to support dynamic dispatch.
type INamespaceStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsNamespaceStatementContext differentiates from other interfaces.
	IsNamespaceStatementContext()
}

type NamespaceStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNamespaceStatementContext() *NamespaceStatementContext {
	var p = new(NamespaceStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PHPParserRULE_namespaceStatement
	return p
}

func (*NamespaceStatementContext) IsNamespaceStatementContext() {}

func NewNamespaceStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NamespaceStatementContext {
	var p = new(NamespaceStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PHPParserRULE_namespaceStatement

	return p
}

func (s *NamespaceStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *NamespaceStatementContext) Statement() IStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *NamespaceStatementContext) UseDeclaration() IUseDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUseDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUseDeclarationContext)
}

func (s *NamespaceStatementContext) FunctionDeclaration() IFunctionDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionDeclarationContext)
}

func (s *NamespaceStatementContext) ClassDeclaration() IClassDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClassDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClassDeclarationContext)
}

func (s *NamespaceStatementContext) GlobalConstantDeclaration() IGlobalConstantDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGlobalConstantDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGlobalConstantDeclarationContext)
}

func (s *NamespaceStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NamespaceStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NamespaceStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PHPParserVisitor:
		return t.VisitNamespaceStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PHPParser) NamespaceStatement() (localctx INamespaceStatementContext) {
	this := p
	_ = this

	localctx = NewNamespaceStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 24, PHPParserRULE_namespaceStatement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(437)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 19, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(432)
			p.Statement()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(433)
			p.UseDeclaration()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(434)
			p.FunctionDeclaration()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(435)
			p.ClassDeclaration()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(436)
			p.GlobalConstantDeclaration()
		}

	}

	return localctx
}

// IFunctionDeclarationContext is an interface to support dynamic dispatch.
type IFunctionDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFunctionDeclarationContext differentiates from other interfaces.
	IsFunctionDeclarationContext()
}

type FunctionDeclarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunctionDeclarationContext() *FunctionDeclarationContext {
	var p = new(FunctionDeclarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PHPParserRULE_functionDeclaration
	return p
}

func (*FunctionDeclarationContext) IsFunctionDeclarationContext() {}

func NewFunctionDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FunctionDeclarationContext {
	var p = new(FunctionDeclarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PHPParserRULE_functionDeclaration

	return p
}

func (s *FunctionDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *FunctionDeclarationContext) Function_() antlr.TerminalNode {
	return s.GetToken(PHPParserFunction_, 0)
}

func (s *FunctionDeclarationContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *FunctionDeclarationContext) OpenRoundBracket() antlr.TerminalNode {
	return s.GetToken(PHPParserOpenRoundBracket, 0)
}

func (s *FunctionDeclarationContext) FormalParameterList() IFormalParameterListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFormalParameterListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFormalParameterListContext)
}

func (s *FunctionDeclarationContext) CloseRoundBracket() antlr.TerminalNode {
	return s.GetToken(PHPParserCloseRoundBracket, 0)
}

func (s *FunctionDeclarationContext) BlockStatement() IBlockStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBlockStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBlockStatementContext)
}

func (s *FunctionDeclarationContext) Attributes() IAttributesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAttributesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAttributesContext)
}

func (s *FunctionDeclarationContext) Ampersand() antlr.TerminalNode {
	return s.GetToken(PHPParserAmpersand, 0)
}

func (s *FunctionDeclarationContext) Colon() antlr.TerminalNode {
	return s.GetToken(PHPParserColon, 0)
}

func (s *FunctionDeclarationContext) TypeHint() ITypeHintContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeHintContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeHintContext)
}

func (s *FunctionDeclarationContext) QuestionMark() antlr.TerminalNode {
	return s.GetToken(PHPParserQuestionMark, 0)
}

func (s *FunctionDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FunctionDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FunctionDeclarationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PHPParserVisitor:
		return t.VisitFunctionDeclaration(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PHPParser) FunctionDeclaration() (localctx IFunctionDeclarationContext) {
	this := p
	_ = this

	localctx = NewFunctionDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 26, PHPParserRULE_functionDeclaration)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(440)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == PHPParserAttributeStart {
		{
			p.SetState(439)
			p.Attributes()
		}

	}
	{
		p.SetState(442)
		p.Match(PHPParserFunction_)
	}
	p.SetState(444)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == PHPParserAmpersand {
		{
			p.SetState(443)
			p.Match(PHPParserAmpersand)
		}

	}
	{
		p.SetState(446)
		p.Identifier()
	}
	{
		p.SetState(447)
		p.Match(PHPParserOpenRoundBracket)
	}
	{
		p.SetState(448)
		p.FormalParameterList()
	}
	{
		p.SetState(449)
		p.Match(PHPParserCloseRoundBracket)
	}
	p.SetState(455)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == PHPParserColon {
		{
			p.SetState(450)
			p.Match(PHPParserColon)
		}
		p.SetState(452)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == PHPParserQuestionMark {
			{
				p.SetState(451)
				p.Match(PHPParserQuestionMark)
			}

		}
		{
			p.SetState(454)
			p.typeHint(0)
		}

	}
	{
		p.SetState(457)
		p.BlockStatement()
	}

	return localctx
}

// IClassDeclarationContext is an interface to support dynamic dispatch.
type IClassDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsClassDeclarationContext differentiates from other interfaces.
	IsClassDeclarationContext()
}

type ClassDeclarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyClassDeclarationContext() *ClassDeclarationContext {
	var p = new(ClassDeclarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PHPParserRULE_classDeclaration
	return p
}

func (*ClassDeclarationContext) IsClassDeclarationContext() {}

func NewClassDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ClassDeclarationContext {
	var p = new(ClassDeclarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PHPParserRULE_classDeclaration

	return p
}

func (s *ClassDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *ClassDeclarationContext) OpenCurlyBracket() antlr.TerminalNode {
	return s.GetToken(PHPParserOpenCurlyBracket, 0)
}

func (s *ClassDeclarationContext) CloseCurlyBracket() antlr.TerminalNode {
	return s.GetToken(PHPParserCloseCurlyBracket, 0)
}

func (s *ClassDeclarationContext) ClassEntryType() IClassEntryTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClassEntryTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClassEntryTypeContext)
}

func (s *ClassDeclarationContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ClassDeclarationContext) Interface() antlr.TerminalNode {
	return s.GetToken(PHPParserInterface, 0)
}

func (s *ClassDeclarationContext) Attributes() IAttributesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAttributesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAttributesContext)
}

func (s *ClassDeclarationContext) Private() antlr.TerminalNode {
	return s.GetToken(PHPParserPrivate, 0)
}

func (s *ClassDeclarationContext) Modifier() IModifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IModifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IModifierContext)
}

func (s *ClassDeclarationContext) Partial() antlr.TerminalNode {
	return s.GetToken(PHPParserPartial, 0)
}

func (s *ClassDeclarationContext) AllClassStatement() []IClassStatementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IClassStatementContext); ok {
			len++
		}
	}

	tst := make([]IClassStatementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IClassStatementContext); ok {
			tst[i] = t.(IClassStatementContext)
			i++
		}
	}

	return tst
}

func (s *ClassDeclarationContext) ClassStatement(i int) IClassStatementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClassStatementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClassStatementContext)
}

func (s *ClassDeclarationContext) Extends() antlr.TerminalNode {
	return s.GetToken(PHPParserExtends, 0)
}

func (s *ClassDeclarationContext) QualifiedStaticTypeRef() IQualifiedStaticTypeRefContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedStaticTypeRefContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedStaticTypeRefContext)
}

func (s *ClassDeclarationContext) Implements() antlr.TerminalNode {
	return s.GetToken(PHPParserImplements, 0)
}

func (s *ClassDeclarationContext) InterfaceList() IInterfaceListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInterfaceListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInterfaceListContext)
}

func (s *ClassDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ClassDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ClassDeclarationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PHPParserVisitor:
		return t.VisitClassDeclaration(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PHPParser) ClassDeclaration() (localctx IClassDeclarationContext) {
	this := p
	_ = this

	localctx = NewClassDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 28, PHPParserRULE_classDeclaration)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(460)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == PHPParserAttributeStart {
		{
			p.SetState(459)
			p.Attributes()
		}

	}
	p.SetState(463)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == PHPParserPrivate {
		{
			p.SetState(462)
			p.Match(PHPParserPrivate)
		}

	}
	p.SetState(466)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == PHPParserAbstract || _la == PHPParserFinal {
		{
			p.SetState(465)
			p.Modifier()
		}

	}
	p.SetState(469)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == PHPParserPartial {
		{
			p.SetState(468)
			p.Match(PHPParserPartial)
		}

	}
	p.SetState(487)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case PHPParserClass, PHPParserTrait:
		{
			p.SetState(471)
			p.ClassEntryType()
		}
		{
			p.SetState(472)
			p.Identifier()
		}
		p.SetState(475)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == PHPParserExtends {
			{
				p.SetState(473)
				p.Match(PHPParserExtends)
			}
			{
				p.SetState(474)
				p.QualifiedStaticTypeRef()
			}

		}
		p.SetState(479)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == PHPParserImplements {
			{
				p.SetState(477)
				p.Match(PHPParserImplements)
			}
			{
				p.SetState(478)
				p.InterfaceList()
			}

		}

	case PHPParserInterface:
		{
			p.SetState(481)
			p.Match(PHPParserInterface)
		}
		{
			p.SetState(482)
			p.Identifier()
		}
		p.SetState(485)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == PHPParserExtends {
			{
				p.SetState(483)
				p.Match(PHPParserExtends)
			}
			{
				p.SetState(484)
				p.InterfaceList()
			}

		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}
	{
		p.SetState(489)
		p.Match(PHPParserOpenCurlyBracket)
	}
	p.SetState(493)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for (int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&72083982316994560) != 0 || (int64((_la-81)) & ^0x3f) == 0 && ((int64(1)<<(_la-81))&6757727313330209) != 0 {
		{
			p.SetState(490)
			p.ClassStatement()
		}

		p.SetState(495)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(496)
		p.Match(PHPParserCloseCurlyBracket)
	}

	return localctx
}

// IClassEntryTypeContext is an interface to support dynamic dispatch.
type IClassEntryTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsClassEntryTypeContext differentiates from other interfaces.
	IsClassEntryTypeContext()
}

type ClassEntryTypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyClassEntryTypeContext() *ClassEntryTypeContext {
	var p = new(ClassEntryTypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PHPParserRULE_classEntryType
	return p
}

func (*ClassEntryTypeContext) IsClassEntryTypeContext() {}

func NewClassEntryTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ClassEntryTypeContext {
	var p = new(ClassEntryTypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PHPParserRULE_classEntryType

	return p
}

func (s *ClassEntryTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *ClassEntryTypeContext) Class() antlr.TerminalNode {
	return s.GetToken(PHPParserClass, 0)
}

func (s *ClassEntryTypeContext) Trait() antlr.TerminalNode {
	return s.GetToken(PHPParserTrait, 0)
}

func (s *ClassEntryTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ClassEntryTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ClassEntryTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PHPParserVisitor:
		return t.VisitClassEntryType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PHPParser) ClassEntryType() (localctx IClassEntryTypeContext) {
	this := p
	_ = this

	localctx = NewClassEntryTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 30, PHPParserRULE_classEntryType)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(498)
		_la = p.GetTokenStream().LA(1)

		if !(_la == PHPParserClass || _la == PHPParserTrait) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IInterfaceListContext is an interface to support dynamic dispatch.
type IInterfaceListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInterfaceListContext differentiates from other interfaces.
	IsInterfaceListContext()
}

type InterfaceListContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInterfaceListContext() *InterfaceListContext {
	var p = new(InterfaceListContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PHPParserRULE_interfaceList
	return p
}

func (*InterfaceListContext) IsInterfaceListContext() {}

func NewInterfaceListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InterfaceListContext {
	var p = new(InterfaceListContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PHPParserRULE_interfaceList

	return p
}

func (s *InterfaceListContext) GetParser() antlr.Parser { return s.parser }

func (s *InterfaceListContext) AllQualifiedStaticTypeRef() []IQualifiedStaticTypeRefContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IQualifiedStaticTypeRefContext); ok {
			len++
		}
	}

	tst := make([]IQualifiedStaticTypeRefContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IQualifiedStaticTypeRefContext); ok {
			tst[i] = t.(IQualifiedStaticTypeRefContext)
			i++
		}
	}

	return tst
}

func (s *InterfaceListContext) QualifiedStaticTypeRef(i int) IQualifiedStaticTypeRefContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedStaticTypeRefContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedStaticTypeRefContext)
}

func (s *InterfaceListContext) AllComma() []antlr.TerminalNode {
	return s.GetTokens(PHPParserComma)
}

func (s *InterfaceListContext) Comma(i int) antlr.TerminalNode {
	return s.GetToken(PHPParserComma, i)
}

func (s *InterfaceListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InterfaceListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InterfaceListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PHPParserVisitor:
		return t.VisitInterfaceList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PHPParser) InterfaceList() (localctx IInterfaceListContext) {
	this := p
	_ = this

	localctx = NewInterfaceListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 32, PHPParserRULE_interfaceList)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(500)
		p.QualifiedStaticTypeRef()
	}
	p.SetState(505)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == PHPParserComma {
		{
			p.SetState(501)
			p.Match(PHPParserComma)
		}
		{
			p.SetState(502)
			p.QualifiedStaticTypeRef()
		}

		p.SetState(507)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// ITypeParameterListContext is an interface to support dynamic dispatch.
type ITypeParameterListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTypeParameterListContext differentiates from other interfaces.
	IsTypeParameterListContext()
}

type TypeParameterListContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeParameterListContext() *TypeParameterListContext {
	var p = new(TypeParameterListContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PHPParserRULE_typeParameterList
	return p
}

func (*TypeParameterListContext) IsTypeParameterListContext() {}

func NewTypeParameterListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeParameterListContext {
	var p = new(TypeParameterListContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PHPParserRULE_typeParameterList

	return p
}

func (s *TypeParameterListContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeParameterListContext) AllTypeParameterDecl() []ITypeParameterDeclContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITypeParameterDeclContext); ok {
			len++
		}
	}

	tst := make([]ITypeParameterDeclContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITypeParameterDeclContext); ok {
			tst[i] = t.(ITypeParameterDeclContext)
			i++
		}
	}

	return tst
}

func (s *TypeParameterListContext) TypeParameterDecl(i int) ITypeParameterDeclContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeParameterDeclContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeParameterDeclContext)
}

func (s *TypeParameterListContext) AllComma() []antlr.TerminalNode {
	return s.GetTokens(PHPParserComma)
}

func (s *TypeParameterListContext) Comma(i int) antlr.TerminalNode {
	return s.GetToken(PHPParserComma, i)
}

func (s *TypeParameterListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeParameterListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeParameterListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PHPParserVisitor:
		return t.VisitTypeParameterList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PHPParser) TypeParameterList() (localctx ITypeParameterListContext) {
	this := p
	_ = this

	localctx = NewTypeParameterListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 34, PHPParserRULE_typeParameterList)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(508)
		p.TypeParameterDecl()
	}
	p.SetState(513)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == PHPParserComma {
		{
			p.SetState(509)
			p.Match(PHPParserComma)
		}
		{
			p.SetState(510)
			p.TypeParameterDecl()
		}

		p.SetState(515)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// ITypeParameterWithDefaultsListContext is an interface to support dynamic dispatch.
type ITypeParameterWithDefaultsListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTypeParameterWithDefaultsListContext differentiates from other interfaces.
	IsTypeParameterWithDefaultsListContext()
}

type TypeParameterWithDefaultsListContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeParameterWithDefaultsListContext() *TypeParameterWithDefaultsListContext {
	var p = new(TypeParameterWithDefaultsListContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PHPParserRULE_typeParameterWithDefaultsList
	return p
}

func (*TypeParameterWithDefaultsListContext) IsTypeParameterWithDefaultsListContext() {}

func NewTypeParameterWithDefaultsListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeParameterWithDefaultsListContext {
	var p = new(TypeParameterWithDefaultsListContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PHPParserRULE_typeParameterWithDefaultsList

	return p
}

func (s *TypeParameterWithDefaultsListContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeParameterWithDefaultsListContext) AllTypeParameterWithDefaultDecl() []ITypeParameterWithDefaultDeclContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITypeParameterWithDefaultDeclContext); ok {
			len++
		}
	}

	tst := make([]ITypeParameterWithDefaultDeclContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITypeParameterWithDefaultDeclContext); ok {
			tst[i] = t.(ITypeParameterWithDefaultDeclContext)
			i++
		}
	}

	return tst
}

func (s *TypeParameterWithDefaultsListContext) TypeParameterWithDefaultDecl(i int) ITypeParameterWithDefaultDeclContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeParameterWithDefaultDeclContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeParameterWithDefaultDeclContext)
}

func (s *TypeParameterWithDefaultsListContext) AllComma() []antlr.TerminalNode {
	return s.GetTokens(PHPParserComma)
}

func (s *TypeParameterWithDefaultsListContext) Comma(i int) antlr.TerminalNode {
	return s.GetToken(PHPParserComma, i)
}

func (s *TypeParameterWithDefaultsListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeParameterWithDefaultsListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeParameterWithDefaultsListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PHPParserVisitor:
		return t.VisitTypeParameterWithDefaultsList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PHPParser) TypeParameterWithDefaultsList() (localctx ITypeParameterWithDefaultsListContext) {
	this := p
	_ = this

	localctx = NewTypeParameterWithDefaultsListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 36, PHPParserRULE_typeParameterWithDefaultsList)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(516)
		p.TypeParameterWithDefaultDecl()
	}
	p.SetState(521)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == PHPParserComma {
		{
			p.SetState(517)
			p.Match(PHPParserComma)
		}
		{
			p.SetState(518)
			p.TypeParameterWithDefaultDecl()
		}

		p.SetState(523)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// ITypeParameterDeclContext is an interface to support dynamic dispatch.
type ITypeParameterDeclContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTypeParameterDeclContext differentiates from other interfaces.
	IsTypeParameterDeclContext()
}

type TypeParameterDeclContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeParameterDeclContext() *TypeParameterDeclContext {
	var p = new(TypeParameterDeclContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PHPParserRULE_typeParameterDecl
	return p
}

func (*TypeParameterDeclContext) IsTypeParameterDeclContext() {}

func NewTypeParameterDeclContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeParameterDeclContext {
	var p = new(TypeParameterDeclContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PHPParserRULE_typeParameterDecl

	return p
}

func (s *TypeParameterDeclContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeParameterDeclContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *TypeParameterDeclContext) Attributes() IAttributesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAttributesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAttributesContext)
}

func (s *TypeParameterDeclContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeParameterDeclContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeParameterDeclContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PHPParserVisitor:
		return t.VisitTypeParameterDecl(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PHPParser) TypeParameterDecl() (localctx ITypeParameterDeclContext) {
	this := p
	_ = this

	localctx = NewTypeParameterDeclContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 38, PHPParserRULE_typeParameterDecl)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(525)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == PHPParserAttributeStart {
		{
			p.SetState(524)
			p.Attributes()
		}

	}
	{
		p.SetState(527)
		p.Identifier()
	}

	return localctx
}

// ITypeParameterWithDefaultDeclContext is an interface to support dynamic dispatch.
type ITypeParameterWithDefaultDeclContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTypeParameterWithDefaultDeclContext differentiates from other interfaces.
	IsTypeParameterWithDefaultDeclContext()
}

type TypeParameterWithDefaultDeclContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeParameterWithDefaultDeclContext() *TypeParameterWithDefaultDeclContext {
	var p = new(TypeParameterWithDefaultDeclContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PHPParserRULE_typeParameterWithDefaultDecl
	return p
}

func (*TypeParameterWithDefaultDeclContext) IsTypeParameterWithDefaultDeclContext() {}

func NewTypeParameterWithDefaultDeclContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeParameterWithDefaultDeclContext {
	var p = new(TypeParameterWithDefaultDeclContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PHPParserRULE_typeParameterWithDefaultDecl

	return p
}

func (s *TypeParameterWithDefaultDeclContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeParameterWithDefaultDeclContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *TypeParameterWithDefaultDeclContext) Eq() antlr.TerminalNode {
	return s.GetToken(PHPParserEq, 0)
}

func (s *TypeParameterWithDefaultDeclContext) QualifiedStaticTypeRef() IQualifiedStaticTypeRefContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedStaticTypeRefContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedStaticTypeRefContext)
}

func (s *TypeParameterWithDefaultDeclContext) PrimitiveType() IPrimitiveTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrimitiveTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrimitiveTypeContext)
}

func (s *TypeParameterWithDefaultDeclContext) Attributes() IAttributesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAttributesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAttributesContext)
}

func (s *TypeParameterWithDefaultDeclContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeParameterWithDefaultDeclContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeParameterWithDefaultDeclContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PHPParserVisitor:
		return t.VisitTypeParameterWithDefaultDecl(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PHPParser) TypeParameterWithDefaultDecl() (localctx ITypeParameterWithDefaultDeclContext) {
	this := p
	_ = this

	localctx = NewTypeParameterWithDefaultDeclContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 40, PHPParserRULE_typeParameterWithDefaultDecl)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(530)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == PHPParserAttributeStart {
		{
			p.SetState(529)
			p.Attributes()
		}

	}
	{
		p.SetState(532)
		p.Identifier()
	}
	{
		p.SetState(533)
		p.Match(PHPParserEq)
	}
	p.SetState(536)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 38, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(534)
			p.QualifiedStaticTypeRef()
		}

	case 2:
		{
			p.SetState(535)
			p.PrimitiveType()
		}

	}

	return localctx
}

// IAttributesContext is an interface to support dynamic dispatch.
type IAttributesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAttributesContext differentiates from other interfaces.
	IsAttributesContext()
}

type AttributesContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAttributesContext() *AttributesContext {
	var p = new(AttributesContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PHPParserRULE_attributes
	return p
}

func (*AttributesContext) IsAttributesContext() {}

func NewAttributesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AttributesContext {
	var p = new(AttributesContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PHPParserRULE_attributes

	return p
}

func (s *AttributesContext) GetParser() antlr.Parser { return s.parser }

func (s *AttributesContext) AllAttributeGroup() []IAttributeGroupContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAttributeGroupContext); ok {
			len++
		}
	}

	tst := make([]IAttributeGroupContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAttributeGroupContext); ok {
			tst[i] = t.(IAttributeGroupContext)
			i++
		}
	}

	return tst
}

func (s *AttributesContext) AttributeGroup(i int) IAttributeGroupContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAttributeGroupContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAttributeGroupContext)
}

func (s *AttributesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AttributesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AttributesContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PHPParserVisitor:
		return t.VisitAttributes(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PHPParser) Attributes() (localctx IAttributesContext) {
	this := p
	_ = this

	localctx = NewAttributesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 42, PHPParserRULE_attributes)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(539)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = _la == PHPParserAttributeStart {
		{
			p.SetState(538)
			p.AttributeGroup()
		}

		p.SetState(541)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IAttributeGroupContext is an interface to support dynamic dispatch.
type IAttributeGroupContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAttributeGroupContext differentiates from other interfaces.
	IsAttributeGroupContext()
}

type AttributeGroupContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAttributeGroupContext() *AttributeGroupContext {
	var p = new(AttributeGroupContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PHPParserRULE_attributeGroup
	return p
}

func (*AttributeGroupContext) IsAttributeGroupContext() {}

func NewAttributeGroupContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AttributeGroupContext {
	var p = new(AttributeGroupContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PHPParserRULE_attributeGroup

	return p
}

func (s *AttributeGroupContext) GetParser() antlr.Parser { return s.parser }

func (s *AttributeGroupContext) AttributeStart() antlr.TerminalNode {
	return s.GetToken(PHPParserAttributeStart, 0)
}

func (s *AttributeGroupContext) AllAttribute() []IAttributeContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAttributeContext); ok {
			len++
		}
	}

	tst := make([]IAttributeContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAttributeContext); ok {
			tst[i] = t.(IAttributeContext)
			i++
		}
	}

	return tst
}

func (s *AttributeGroupContext) Attribute(i int) IAttributeContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAttributeContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAttributeContext)
}

func (s *AttributeGroupContext) CloseSquareBracket() antlr.TerminalNode {
	return s.GetToken(PHPParserCloseSquareBracket, 0)
}

func (s *AttributeGroupContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *AttributeGroupContext) Colon() antlr.TerminalNode {
	return s.GetToken(PHPParserColon, 0)
}

func (s *AttributeGroupContext) AllComma() []antlr.TerminalNode {
	return s.GetTokens(PHPParserComma)
}

func (s *AttributeGroupContext) Comma(i int) antlr.TerminalNode {
	return s.GetToken(PHPParserComma, i)
}

func (s *AttributeGroupContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AttributeGroupContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AttributeGroupContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PHPParserVisitor:
		return t.VisitAttributeGroup(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PHPParser) AttributeGroup() (localctx IAttributeGroupContext) {
	this := p
	_ = this

	localctx = NewAttributeGroupContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 44, PHPParserRULE_attributeGroup)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(543)
		p.Match(PHPParserAttributeStart)
	}
	p.SetState(547)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 40, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(544)
			p.Identifier()
		}
		{
			p.SetState(545)
			p.Match(PHPParserColon)
		}

	}
	{
		p.SetState(549)
		p.Attribute()
	}
	p.SetState(554)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == PHPParserComma {
		{
			p.SetState(550)
			p.Match(PHPParserComma)
		}
		{
			p.SetState(551)
			p.Attribute()
		}

		p.SetState(556)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(557)
		p.Match(PHPParserCloseSquareBracket)
	}

	return localctx
}

// IAttributeContext is an interface to support dynamic dispatch.
type IAttributeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAttributeContext differentiates from other interfaces.
	IsAttributeContext()
}

type AttributeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAttributeContext() *AttributeContext {
	var p = new(AttributeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PHPParserRULE_attribute
	return p
}

func (*AttributeContext) IsAttributeContext() {}

func NewAttributeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AttributeContext {
	var p = new(AttributeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PHPParserRULE_attribute

	return p
}

func (s *AttributeContext) GetParser() antlr.Parser { return s.parser }

func (s *AttributeContext) QualifiedNamespaceName() IQualifiedNamespaceNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNamespaceNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNamespaceNameContext)
}

func (s *AttributeContext) Arguments() IArgumentsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArgumentsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArgumentsContext)
}

func (s *AttributeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AttributeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AttributeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PHPParserVisitor:
		return t.VisitAttribute(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PHPParser) Attribute() (localctx IAttributeContext) {
	this := p
	_ = this

	localctx = NewAttributeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 46, PHPParserRULE_attribute)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(559)
		p.QualifiedNamespaceName()
	}
	p.SetState(561)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == PHPParserOpenRoundBracket {
		{
			p.SetState(560)
			p.Arguments()
		}

	}

	return localctx
}

// IInnerStatementListContext is an interface to support dynamic dispatch.
type IInnerStatementListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInnerStatementListContext differentiates from other interfaces.
	IsInnerStatementListContext()
}

type InnerStatementListContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInnerStatementListContext() *InnerStatementListContext {
	var p = new(InnerStatementListContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PHPParserRULE_innerStatementList
	return p
}

func (*InnerStatementListContext) IsInnerStatementListContext() {}

func NewInnerStatementListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InnerStatementListContext {
	var p = new(InnerStatementListContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PHPParserRULE_innerStatementList

	return p
}

func (s *InnerStatementListContext) GetParser() antlr.Parser { return s.parser }

func (s *InnerStatementListContext) AllInnerStatement() []IInnerStatementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IInnerStatementContext); ok {
			len++
		}
	}

	tst := make([]IInnerStatementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IInnerStatementContext); ok {
			tst[i] = t.(IInnerStatementContext)
			i++
		}
	}

	return tst
}

func (s *InnerStatementListContext) InnerStatement(i int) IInnerStatementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInnerStatementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInnerStatementContext)
}

func (s *InnerStatementListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InnerStatementListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InnerStatementListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PHPParserVisitor:
		return t.VisitInnerStatementList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PHPParser) InnerStatementList() (localctx IInnerStatementListContext) {
	this := p
	_ = this

	localctx = NewInnerStatementListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 48, PHPParserRULE_innerStatementList)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(566)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 43, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(563)
				p.InnerStatement()
			}

		}
		p.SetState(568)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 43, p.GetParserRuleContext())
	}

	return localctx
}

// IInnerStatementContext is an interface to support dynamic dispatch.
type IInnerStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInnerStatementContext differentiates from other interfaces.
	IsInnerStatementContext()
}

type InnerStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInnerStatementContext() *InnerStatementContext {
	var p = new(InnerStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PHPParserRULE_innerStatement
	return p
}

func (*InnerStatementContext) IsInnerStatementContext() {}

func NewInnerStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InnerStatementContext {
	var p = new(InnerStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PHPParserRULE_innerStatement

	return p
}

func (s *InnerStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *InnerStatementContext) Statement() IStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *InnerStatementContext) FunctionDeclaration() IFunctionDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionDeclarationContext)
}

func (s *InnerStatementContext) ClassDeclaration() IClassDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClassDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClassDeclarationContext)
}

func (s *InnerStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InnerStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InnerStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PHPParserVisitor:
		return t.VisitInnerStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PHPParser) InnerStatement() (localctx IInnerStatementContext) {
	this := p
	_ = this

	localctx = NewInnerStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 50, PHPParserRULE_innerStatement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(572)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 44, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(569)
			p.Statement()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(570)
			p.FunctionDeclaration()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(571)
			p.ClassDeclaration()
		}

	}

	return localctx
}

// ILabelStatementContext is an interface to support dynamic dispatch.
type ILabelStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLabelStatementContext differentiates from other interfaces.
	IsLabelStatementContext()
}

type LabelStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLabelStatementContext() *LabelStatementContext {
	var p = new(LabelStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PHPParserRULE_labelStatement
	return p
}

func (*LabelStatementContext) IsLabelStatementContext() {}

func NewLabelStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LabelStatementContext {
	var p = new(LabelStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PHPParserRULE_labelStatement

	return p
}

func (s *LabelStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *LabelStatementContext) Label() antlr.TerminalNode {
	return s.GetToken(PHPParserLabel, 0)
}

func (s *LabelStatementContext) Colon() antlr.TerminalNode {
	return s.GetToken(PHPParserColon, 0)
}

func (s *LabelStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LabelStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LabelStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PHPParserVisitor:
		return t.VisitLabelStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PHPParser) LabelStatement() (localctx ILabelStatementContext) {
	this := p
	_ = this

	localctx = NewLabelStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 52, PHPParserRULE_labelStatement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(574)
		p.Match(PHPParserLabel)
	}
	{
		p.SetState(575)
		p.Match(PHPParserColon)
	}

	return localctx
}

// IStatementContext is an interface to support dynamic dispatch.
type IStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsStatementContext differentiates from other interfaces.
	IsStatementContext()
}

type StatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStatementContext() *StatementContext {
	var p = new(StatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PHPParserRULE_statement
	return p
}

func (*StatementContext) IsStatementContext() {}

func NewStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StatementContext {
	var p = new(StatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PHPParserRULE_statement

	return p
}

func (s *StatementContext) GetParser() antlr.Parser { return s.parser }

func (s *StatementContext) LabelStatement() ILabelStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILabelStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILabelStatementContext)
}

func (s *StatementContext) BlockStatement() IBlockStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBlockStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBlockStatementContext)
}

func (s *StatementContext) IfStatement() IIfStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIfStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIfStatementContext)
}

func (s *StatementContext) WhileStatement() IWhileStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWhileStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWhileStatementContext)
}

func (s *StatementContext) DoWhileStatement() IDoWhileStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDoWhileStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDoWhileStatementContext)
}

func (s *StatementContext) ForStatement() IForStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IForStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IForStatementContext)
}

func (s *StatementContext) SwitchStatement() ISwitchStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISwitchStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISwitchStatementContext)
}

func (s *StatementContext) BreakStatement() IBreakStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBreakStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBreakStatementContext)
}

func (s *StatementContext) ContinueStatement() IContinueStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IContinueStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IContinueStatementContext)
}

func (s *StatementContext) ReturnStatement() IReturnStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReturnStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReturnStatementContext)
}

func (s *StatementContext) YieldExpression() IYieldExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IYieldExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IYieldExpressionContext)
}

func (s *StatementContext) SemiColon() antlr.TerminalNode {
	return s.GetToken(PHPParserSemiColon, 0)
}

func (s *StatementContext) GlobalStatement() IGlobalStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGlobalStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGlobalStatementContext)
}

func (s *StatementContext) StaticVariableStatement() IStaticVariableStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStaticVariableStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStaticVariableStatementContext)
}

func (s *StatementContext) EchoStatement() IEchoStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEchoStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEchoStatementContext)
}

func (s *StatementContext) ExpressionStatement() IExpressionStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionStatementContext)
}

func (s *StatementContext) UnsetStatement() IUnsetStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnsetStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnsetStatementContext)
}

func (s *StatementContext) ForeachStatement() IForeachStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IForeachStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IForeachStatementContext)
}

func (s *StatementContext) TryCatchFinally() ITryCatchFinallyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITryCatchFinallyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITryCatchFinallyContext)
}

func (s *StatementContext) ThrowStatement() IThrowStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IThrowStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IThrowStatementContext)
}

func (s *StatementContext) GotoStatement() IGotoStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGotoStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGotoStatementContext)
}

func (s *StatementContext) DeclareStatement() IDeclareStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDeclareStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDeclareStatementContext)
}

func (s *StatementContext) EmptyStatement_() IEmptyStatement_Context {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEmptyStatement_Context); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEmptyStatement_Context)
}

func (s *StatementContext) InlineHtmlStatement() IInlineHtmlStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInlineHtmlStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInlineHtmlStatementContext)
}

func (s *StatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PHPParserVisitor:
		return t.VisitStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PHPParser) Statement() (localctx IStatementContext) {
	this := p
	_ = this

	localctx = NewStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 54, PHPParserRULE_statement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(602)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 45, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(577)
			p.LabelStatement()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(578)
			p.BlockStatement()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(579)
			p.IfStatement()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(580)
			p.WhileStatement()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(581)
			p.DoWhileStatement()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(582)
			p.ForStatement()
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(583)
			p.SwitchStatement()
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(584)
			p.BreakStatement()
		}

	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(585)
			p.ContinueStatement()
		}

	case 10:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(586)
			p.ReturnStatement()
		}

	case 11:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(587)
			p.YieldExpression()
		}
		{
			p.SetState(588)
			p.Match(PHPParserSemiColon)
		}

	case 12:
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(590)
			p.GlobalStatement()
		}

	case 13:
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(591)
			p.StaticVariableStatement()
		}

	case 14:
		p.EnterOuterAlt(localctx, 14)
		{
			p.SetState(592)
			p.EchoStatement()
		}

	case 15:
		p.EnterOuterAlt(localctx, 15)
		{
			p.SetState(593)
			p.ExpressionStatement()
		}

	case 16:
		p.EnterOuterAlt(localctx, 16)
		{
			p.SetState(594)
			p.UnsetStatement()
		}

	case 17:
		p.EnterOuterAlt(localctx, 17)
		{
			p.SetState(595)
			p.ForeachStatement()
		}

	case 18:
		p.EnterOuterAlt(localctx, 18)
		{
			p.SetState(596)
			p.TryCatchFinally()
		}

	case 19:
		p.EnterOuterAlt(localctx, 19)
		{
			p.SetState(597)
			p.ThrowStatement()
		}

	case 20:
		p.EnterOuterAlt(localctx, 20)
		{
			p.SetState(598)
			p.GotoStatement()
		}

	case 21:
		p.EnterOuterAlt(localctx, 21)
		{
			p.SetState(599)
			p.DeclareStatement()
		}

	case 22:
		p.EnterOuterAlt(localctx, 22)
		{
			p.SetState(600)
			p.EmptyStatement_()
		}

	case 23:
		p.EnterOuterAlt(localctx, 23)
		{
			p.SetState(601)
			p.InlineHtmlStatement()
		}

	}

	return localctx
}

// IEmptyStatement_Context is an interface to support dynamic dispatch.
type IEmptyStatement_Context interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEmptyStatement_Context differentiates from other interfaces.
	IsEmptyStatement_Context()
}

type EmptyStatement_Context struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEmptyStatement_Context() *EmptyStatement_Context {
	var p = new(EmptyStatement_Context)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PHPParserRULE_emptyStatement_
	return p
}

func (*EmptyStatement_Context) IsEmptyStatement_Context() {}

func NewEmptyStatement_Context(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EmptyStatement_Context {
	var p = new(EmptyStatement_Context)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PHPParserRULE_emptyStatement_

	return p
}

func (s *EmptyStatement_Context) GetParser() antlr.Parser { return s.parser }

func (s *EmptyStatement_Context) SemiColon() antlr.TerminalNode {
	return s.GetToken(PHPParserSemiColon, 0)
}

func (s *EmptyStatement_Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EmptyStatement_Context) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EmptyStatement_Context) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PHPParserVisitor:
		return t.VisitEmptyStatement_(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PHPParser) EmptyStatement_() (localctx IEmptyStatement_Context) {
	this := p
	_ = this

	localctx = NewEmptyStatement_Context(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 56, PHPParserRULE_emptyStatement_)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(604)
		p.Match(PHPParserSemiColon)
	}

	return localctx
}

// IBlockStatementContext is an interface to support dynamic dispatch.
type IBlockStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsBlockStatementContext differentiates from other interfaces.
	IsBlockStatementContext()
}

type BlockStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBlockStatementContext() *BlockStatementContext {
	var p = new(BlockStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PHPParserRULE_blockStatement
	return p
}

func (*BlockStatementContext) IsBlockStatementContext() {}

func NewBlockStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BlockStatementContext {
	var p = new(BlockStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PHPParserRULE_blockStatement

	return p
}

func (s *BlockStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *BlockStatementContext) OpenCurlyBracket() antlr.TerminalNode {
	return s.GetToken(PHPParserOpenCurlyBracket, 0)
}

func (s *BlockStatementContext) InnerStatementList() IInnerStatementListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInnerStatementListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInnerStatementListContext)
}

func (s *BlockStatementContext) CloseCurlyBracket() antlr.TerminalNode {
	return s.GetToken(PHPParserCloseCurlyBracket, 0)
}

func (s *BlockStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BlockStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BlockStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PHPParserVisitor:
		return t.VisitBlockStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PHPParser) BlockStatement() (localctx IBlockStatementContext) {
	this := p
	_ = this

	localctx = NewBlockStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 58, PHPParserRULE_blockStatement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(606)
		p.Match(PHPParserOpenCurlyBracket)
	}
	{
		p.SetState(607)
		p.InnerStatementList()
	}
	{
		p.SetState(608)
		p.Match(PHPParserCloseCurlyBracket)
	}

	return localctx
}

// IIfStatementContext is an interface to support dynamic dispatch.
type IIfStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsIfStatementContext differentiates from other interfaces.
	IsIfStatementContext()
}

type IfStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIfStatementContext() *IfStatementContext {
	var p = new(IfStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PHPParserRULE_ifStatement
	return p
}

func (*IfStatementContext) IsIfStatementContext() {}

func NewIfStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IfStatementContext {
	var p = new(IfStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PHPParserRULE_ifStatement

	return p
}

func (s *IfStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *IfStatementContext) If() antlr.TerminalNode {
	return s.GetToken(PHPParserIf, 0)
}

func (s *IfStatementContext) Parentheses() IParenthesesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IParenthesesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IParenthesesContext)
}

func (s *IfStatementContext) Statement() IStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *IfStatementContext) AllElseIfStatement() []IElseIfStatementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IElseIfStatementContext); ok {
			len++
		}
	}

	tst := make([]IElseIfStatementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IElseIfStatementContext); ok {
			tst[i] = t.(IElseIfStatementContext)
			i++
		}
	}

	return tst
}

func (s *IfStatementContext) ElseIfStatement(i int) IElseIfStatementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IElseIfStatementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IElseIfStatementContext)
}

func (s *IfStatementContext) ElseStatement() IElseStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IElseStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IElseStatementContext)
}

func (s *IfStatementContext) Colon() antlr.TerminalNode {
	return s.GetToken(PHPParserColon, 0)
}

func (s *IfStatementContext) InnerStatementList() IInnerStatementListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInnerStatementListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInnerStatementListContext)
}

func (s *IfStatementContext) EndIf() antlr.TerminalNode {
	return s.GetToken(PHPParserEndIf, 0)
}

func (s *IfStatementContext) SemiColon() antlr.TerminalNode {
	return s.GetToken(PHPParserSemiColon, 0)
}

func (s *IfStatementContext) AllElseIfColonStatement() []IElseIfColonStatementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IElseIfColonStatementContext); ok {
			len++
		}
	}

	tst := make([]IElseIfColonStatementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IElseIfColonStatementContext); ok {
			tst[i] = t.(IElseIfColonStatementContext)
			i++
		}
	}

	return tst
}

func (s *IfStatementContext) ElseIfColonStatement(i int) IElseIfColonStatementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IElseIfColonStatementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IElseIfColonStatementContext)
}

func (s *IfStatementContext) ElseColonStatement() IElseColonStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IElseColonStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IElseColonStatementContext)
}

func (s *IfStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IfStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IfStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PHPParserVisitor:
		return t.VisitIfStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PHPParser) IfStatement() (localctx IIfStatementContext) {
	this := p
	_ = this

	localctx = NewIfStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 60, PHPParserRULE_ifStatement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.SetState(638)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 50, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(610)
			p.Match(PHPParserIf)
		}
		{
			p.SetState(611)
			p.Parentheses()
		}
		{
			p.SetState(612)
			p.Statement()
		}
		p.SetState(616)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 46, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(613)
					p.ElseIfStatement()
				}

			}
			p.SetState(618)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 46, p.GetParserRuleContext())
		}
		p.SetState(620)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 47, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(619)
				p.ElseStatement()
			}

		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(622)
			p.Match(PHPParserIf)
		}
		{
			p.SetState(623)
			p.Parentheses()
		}
		{
			p.SetState(624)
			p.Match(PHPParserColon)
		}
		{
			p.SetState(625)
			p.InnerStatementList()
		}
		p.SetState(629)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == PHPParserElseIf {
			{
				p.SetState(626)
				p.ElseIfColonStatement()
			}

			p.SetState(631)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		p.SetState(633)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == PHPParserElse {
			{
				p.SetState(632)
				p.ElseColonStatement()
			}

		}
		{
			p.SetState(635)
			p.Match(PHPParserEndIf)
		}
		{
			p.SetState(636)
			p.Match(PHPParserSemiColon)
		}

	}

	return localctx
}

// IElseIfStatementContext is an interface to support dynamic dispatch.
type IElseIfStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsElseIfStatementContext differentiates from other interfaces.
	IsElseIfStatementContext()
}

type ElseIfStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyElseIfStatementContext() *ElseIfStatementContext {
	var p = new(ElseIfStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PHPParserRULE_elseIfStatement
	return p
}

func (*ElseIfStatementContext) IsElseIfStatementContext() {}

func NewElseIfStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ElseIfStatementContext {
	var p = new(ElseIfStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PHPParserRULE_elseIfStatement

	return p
}

func (s *ElseIfStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ElseIfStatementContext) ElseIf() antlr.TerminalNode {
	return s.GetToken(PHPParserElseIf, 0)
}

func (s *ElseIfStatementContext) Parentheses() IParenthesesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IParenthesesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IParenthesesContext)
}

func (s *ElseIfStatementContext) Statement() IStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *ElseIfStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ElseIfStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ElseIfStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PHPParserVisitor:
		return t.VisitElseIfStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PHPParser) ElseIfStatement() (localctx IElseIfStatementContext) {
	this := p
	_ = this

	localctx = NewElseIfStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 62, PHPParserRULE_elseIfStatement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(640)
		p.Match(PHPParserElseIf)
	}
	{
		p.SetState(641)
		p.Parentheses()
	}
	{
		p.SetState(642)
		p.Statement()
	}

	return localctx
}

// IElseIfColonStatementContext is an interface to support dynamic dispatch.
type IElseIfColonStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsElseIfColonStatementContext differentiates from other interfaces.
	IsElseIfColonStatementContext()
}

type ElseIfColonStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyElseIfColonStatementContext() *ElseIfColonStatementContext {
	var p = new(ElseIfColonStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PHPParserRULE_elseIfColonStatement
	return p
}

func (*ElseIfColonStatementContext) IsElseIfColonStatementContext() {}

func NewElseIfColonStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ElseIfColonStatementContext {
	var p = new(ElseIfColonStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PHPParserRULE_elseIfColonStatement

	return p
}

func (s *ElseIfColonStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ElseIfColonStatementContext) ElseIf() antlr.TerminalNode {
	return s.GetToken(PHPParserElseIf, 0)
}

func (s *ElseIfColonStatementContext) Parentheses() IParenthesesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IParenthesesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IParenthesesContext)
}

func (s *ElseIfColonStatementContext) Colon() antlr.TerminalNode {
	return s.GetToken(PHPParserColon, 0)
}

func (s *ElseIfColonStatementContext) InnerStatementList() IInnerStatementListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInnerStatementListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInnerStatementListContext)
}

func (s *ElseIfColonStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ElseIfColonStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ElseIfColonStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PHPParserVisitor:
		return t.VisitElseIfColonStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PHPParser) ElseIfColonStatement() (localctx IElseIfColonStatementContext) {
	this := p
	_ = this

	localctx = NewElseIfColonStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 64, PHPParserRULE_elseIfColonStatement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(644)
		p.Match(PHPParserElseIf)
	}
	{
		p.SetState(645)
		p.Parentheses()
	}
	{
		p.SetState(646)
		p.Match(PHPParserColon)
	}
	{
		p.SetState(647)
		p.InnerStatementList()
	}

	return localctx
}

// IElseStatementContext is an interface to support dynamic dispatch.
type IElseStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsElseStatementContext differentiates from other interfaces.
	IsElseStatementContext()
}

type ElseStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyElseStatementContext() *ElseStatementContext {
	var p = new(ElseStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PHPParserRULE_elseStatement
	return p
}

func (*ElseStatementContext) IsElseStatementContext() {}

func NewElseStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ElseStatementContext {
	var p = new(ElseStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PHPParserRULE_elseStatement

	return p
}

func (s *ElseStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ElseStatementContext) Else() antlr.TerminalNode {
	return s.GetToken(PHPParserElse, 0)
}

func (s *ElseStatementContext) Statement() IStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *ElseStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ElseStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ElseStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PHPParserVisitor:
		return t.VisitElseStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PHPParser) ElseStatement() (localctx IElseStatementContext) {
	this := p
	_ = this

	localctx = NewElseStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 66, PHPParserRULE_elseStatement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(649)
		p.Match(PHPParserElse)
	}
	{
		p.SetState(650)
		p.Statement()
	}

	return localctx
}

// IElseColonStatementContext is an interface to support dynamic dispatch.
type IElseColonStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsElseColonStatementContext differentiates from other interfaces.
	IsElseColonStatementContext()
}

type ElseColonStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyElseColonStatementContext() *ElseColonStatementContext {
	var p = new(ElseColonStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PHPParserRULE_elseColonStatement
	return p
}

func (*ElseColonStatementContext) IsElseColonStatementContext() {}

func NewElseColonStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ElseColonStatementContext {
	var p = new(ElseColonStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PHPParserRULE_elseColonStatement

	return p
}

func (s *ElseColonStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ElseColonStatementContext) Else() antlr.TerminalNode {
	return s.GetToken(PHPParserElse, 0)
}

func (s *ElseColonStatementContext) Colon() antlr.TerminalNode {
	return s.GetToken(PHPParserColon, 0)
}

func (s *ElseColonStatementContext) InnerStatementList() IInnerStatementListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInnerStatementListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInnerStatementListContext)
}

func (s *ElseColonStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ElseColonStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ElseColonStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PHPParserVisitor:
		return t.VisitElseColonStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PHPParser) ElseColonStatement() (localctx IElseColonStatementContext) {
	this := p
	_ = this

	localctx = NewElseColonStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 68, PHPParserRULE_elseColonStatement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(652)
		p.Match(PHPParserElse)
	}
	{
		p.SetState(653)
		p.Match(PHPParserColon)
	}
	{
		p.SetState(654)
		p.InnerStatementList()
	}

	return localctx
}

// IWhileStatementContext is an interface to support dynamic dispatch.
type IWhileStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsWhileStatementContext differentiates from other interfaces.
	IsWhileStatementContext()
}

type WhileStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWhileStatementContext() *WhileStatementContext {
	var p = new(WhileStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PHPParserRULE_whileStatement
	return p
}

func (*WhileStatementContext) IsWhileStatementContext() {}

func NewWhileStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WhileStatementContext {
	var p = new(WhileStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PHPParserRULE_whileStatement

	return p
}

func (s *WhileStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *WhileStatementContext) While() antlr.TerminalNode {
	return s.GetToken(PHPParserWhile, 0)
}

func (s *WhileStatementContext) Parentheses() IParenthesesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IParenthesesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IParenthesesContext)
}

func (s *WhileStatementContext) Statement() IStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *WhileStatementContext) Colon() antlr.TerminalNode {
	return s.GetToken(PHPParserColon, 0)
}

func (s *WhileStatementContext) InnerStatementList() IInnerStatementListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInnerStatementListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInnerStatementListContext)
}

func (s *WhileStatementContext) EndWhile() antlr.TerminalNode {
	return s.GetToken(PHPParserEndWhile, 0)
}

func (s *WhileStatementContext) SemiColon() antlr.TerminalNode {
	return s.GetToken(PHPParserSemiColon, 0)
}

func (s *WhileStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WhileStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WhileStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PHPParserVisitor:
		return t.VisitWhileStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PHPParser) WhileStatement() (localctx IWhileStatementContext) {
	this := p
	_ = this

	localctx = NewWhileStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 70, PHPParserRULE_whileStatement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(656)
		p.Match(PHPParserWhile)
	}
	{
		p.SetState(657)
		p.Parentheses()
	}
	p.SetState(664)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case PHPParserHtmlText, PHPParserXmlStart, PHPParserHtmlScriptOpen, PHPParserHtmlStyleOpen, PHPParserHtmlDtd, PHPParserHtmlOpen, PHPParserHtmlClose, PHPParserHtmlSlashClose, PHPParserHtmlSlash, PHPParserHtmlEquals, PHPParserHtmlStartQuoteString, PHPParserHtmlStartDoubleQuoteString, PHPParserHtmlHex, PHPParserHtmlDecimal, PHPParserHtmlName, PHPParserHtmlEndQuoteString, PHPParserHtmlQuoteString, PHPParserHtmlEndDoubleQuoteString, PHPParserHtmlDoubleQuoteString, PHPParserScriptText, PHPParserHtmlScriptClose, PHPParserStyleBody, PHPParserAbstract, PHPParserArray, PHPParserAs, PHPParserBinaryCast, PHPParserBoolType, PHPParserBooleanConstant, PHPParserBreak, PHPParserCallable, PHPParserCase, PHPParserCatch, PHPParserClass, PHPParserClone, PHPParserConst, PHPParserContinue, PHPParserDefine, PHPParserDefined, PHPParserDeclare, PHPParserDefault, PHPParserDo, PHPParserDoubleCast, PHPParserDoubleType, PHPParserEcho, PHPParserElse, PHPParserElseIf, PHPParserEmpty, PHPParserEnum_, PHPParserEndDeclare, PHPParserEndFor, PHPParserEndForeach, PHPParserEndIf, PHPParserEndSwitch, PHPParserEndWhile, PHPParserEval, PHPParserAssert, PHPParserDie, PHPParserExit, PHPParserExtends, PHPParserFinal, PHPParserFinally, PHPParserFloatCast, PHPParserFor, PHPParserForeach, PHPParserFunction_, PHPParserGlobal, PHPParserGoto, PHPParserIf, PHPParserImplements, PHPParserImport, PHPParserInclude, PHPParserIncludeOnce, PHPParserInstanceOf, PHPParserInsteadOf, PHPParserInt8Cast, PHPParserInt16Cast, PHPParserInt64Type, PHPParserIntType, PHPParserInterface, PHPParserIsSet, PHPParserList, PHPParserLogicalAnd, PHPParserLogicalOr, PHPParserLogicalXor, PHPParserMatch_, PHPParserNamespace, PHPParserNew, PHPParserNull, PHPParserObjectType, PHPParserParent_, PHPParserPartial, PHPParserPrint, PHPParserPrivate, PHPParserProtected, PHPParserPublic, PHPParserReadonly, PHPParserRequire, PHPParserRequireOnce, PHPParserResource, PHPParserReturn, PHPParserStatic, PHPParserStringType, PHPParserSwitch, PHPParserThrow, PHPParserTrait, PHPParserTry, PHPParserTypeof, PHPParserUintCast, PHPParserUnicodeCast, PHPParserUnset, PHPParserUse, PHPParserVar, PHPParserWhile, PHPParserYield, PHPParserFrom, PHPParserLambdaFn, PHPParserTicks, PHPParserEncoding, PHPParserStrictTypes, PHPParserGet, PHPParserSet, PHPParserCall, PHPParserCallStatic, PHPParserConstructor, PHPParserDestruct, PHPParserWakeup, PHPParserSleep, PHPParserAutoload, PHPParserIsSet__, PHPParserUnset__, PHPParserToString__, PHPParserInvoke, PHPParserSetState, PHPParserClone__, PHPParserDebugInfo, PHPParserNamespace__, PHPParserClass__, PHPParserTraic__, PHPParserFunction__, PHPParserMethod__, PHPParserLine__, PHPParserFile__, PHPParserDir__, PHPParserInc, PHPParserDec, PHPParserNamespaceSeparator, PHPParserAmpersand, PHPParserBang, PHPParserPlus, PHPParserMinus, PHPParserTilde, PHPParserSuppressWarnings, PHPParserDollar, PHPParserOpenRoundBracket, PHPParserOpenSquareBracket, PHPParserOpenCurlyBracket, PHPParserSemiColon, PHPParserSet_Include_Path, PHPParserVarName, PHPParserLabel, PHPParserOctal, PHPParserDecimal, PHPParserReal, PHPParserHex, PHPParserBinary, PHPParserBackQuoteString, PHPParserSingleQuoteString, PHPParserDoubleQuote, PHPParserStartNowDoc, PHPParserStartHereDoc:
		{
			p.SetState(658)
			p.Statement()
		}

	case PHPParserColon:
		{
			p.SetState(659)
			p.Match(PHPParserColon)
		}
		{
			p.SetState(660)
			p.InnerStatementList()
		}
		{
			p.SetState(661)
			p.Match(PHPParserEndWhile)
		}
		{
			p.SetState(662)
			p.Match(PHPParserSemiColon)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IDoWhileStatementContext is an interface to support dynamic dispatch.
type IDoWhileStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDoWhileStatementContext differentiates from other interfaces.
	IsDoWhileStatementContext()
}

type DoWhileStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDoWhileStatementContext() *DoWhileStatementContext {
	var p = new(DoWhileStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PHPParserRULE_doWhileStatement
	return p
}

func (*DoWhileStatementContext) IsDoWhileStatementContext() {}

func NewDoWhileStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DoWhileStatementContext {
	var p = new(DoWhileStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PHPParserRULE_doWhileStatement

	return p
}

func (s *DoWhileStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *DoWhileStatementContext) Do() antlr.TerminalNode {
	return s.GetToken(PHPParserDo, 0)
}

func (s *DoWhileStatementContext) Statement() IStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *DoWhileStatementContext) While() antlr.TerminalNode {
	return s.GetToken(PHPParserWhile, 0)
}

func (s *DoWhileStatementContext) Parentheses() IParenthesesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IParenthesesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IParenthesesContext)
}

func (s *DoWhileStatementContext) SemiColon() antlr.TerminalNode {
	return s.GetToken(PHPParserSemiColon, 0)
}

func (s *DoWhileStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DoWhileStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DoWhileStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PHPParserVisitor:
		return t.VisitDoWhileStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PHPParser) DoWhileStatement() (localctx IDoWhileStatementContext) {
	this := p
	_ = this

	localctx = NewDoWhileStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 72, PHPParserRULE_doWhileStatement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(666)
		p.Match(PHPParserDo)
	}
	{
		p.SetState(667)
		p.Statement()
	}
	{
		p.SetState(668)
		p.Match(PHPParserWhile)
	}
	{
		p.SetState(669)
		p.Parentheses()
	}
	{
		p.SetState(670)
		p.Match(PHPParserSemiColon)
	}

	return localctx
}

// IForStatementContext is an interface to support dynamic dispatch.
type IForStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsForStatementContext differentiates from other interfaces.
	IsForStatementContext()
}

type ForStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyForStatementContext() *ForStatementContext {
	var p = new(ForStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PHPParserRULE_forStatement
	return p
}

func (*ForStatementContext) IsForStatementContext() {}

func NewForStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ForStatementContext {
	var p = new(ForStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PHPParserRULE_forStatement

	return p
}

func (s *ForStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ForStatementContext) For() antlr.TerminalNode {
	return s.GetToken(PHPParserFor, 0)
}

func (s *ForStatementContext) OpenRoundBracket() antlr.TerminalNode {
	return s.GetToken(PHPParserOpenRoundBracket, 0)
}

func (s *ForStatementContext) AllSemiColon() []antlr.TerminalNode {
	return s.GetTokens(PHPParserSemiColon)
}

func (s *ForStatementContext) SemiColon(i int) antlr.TerminalNode {
	return s.GetToken(PHPParserSemiColon, i)
}

func (s *ForStatementContext) CloseRoundBracket() antlr.TerminalNode {
	return s.GetToken(PHPParserCloseRoundBracket, 0)
}

func (s *ForStatementContext) Statement() IStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *ForStatementContext) Colon() antlr.TerminalNode {
	return s.GetToken(PHPParserColon, 0)
}

func (s *ForStatementContext) InnerStatementList() IInnerStatementListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInnerStatementListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInnerStatementListContext)
}

func (s *ForStatementContext) EndFor() antlr.TerminalNode {
	return s.GetToken(PHPParserEndFor, 0)
}

func (s *ForStatementContext) ForInit() IForInitContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IForInitContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IForInitContext)
}

func (s *ForStatementContext) ExpressionList() IExpressionListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionListContext)
}

func (s *ForStatementContext) ForUpdate() IForUpdateContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IForUpdateContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IForUpdateContext)
}

func (s *ForStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ForStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ForStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PHPParserVisitor:
		return t.VisitForStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PHPParser) ForStatement() (localctx IForStatementContext) {
	this := p
	_ = this

	localctx = NewForStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 74, PHPParserRULE_forStatement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(672)
		p.Match(PHPParserFor)
	}
	{
		p.SetState(673)
		p.Match(PHPParserOpenRoundBracket)
	}
	p.SetState(675)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if (int64((_la-44)) & ^0x3f) == 0 && ((int64(1)<<(_la-44))&-1) != 0 || (int64((_la-108)) & ^0x3f) == 0 && ((int64(1)<<(_la-108))&1873497444977737727) != 0 || (int64((_la-196)) & ^0x3f) == 0 && ((int64(1)<<(_la-196))&8795020649297) != 0 {
		{
			p.SetState(674)
			p.ForInit()
		}

	}
	{
		p.SetState(677)
		p.Match(PHPParserSemiColon)
	}
	p.SetState(679)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if (int64((_la-44)) & ^0x3f) == 0 && ((int64(1)<<(_la-44))&-1) != 0 || (int64((_la-108)) & ^0x3f) == 0 && ((int64(1)<<(_la-108))&1873497444977737727) != 0 || (int64((_la-196)) & ^0x3f) == 0 && ((int64(1)<<(_la-196))&8795020649297) != 0 {
		{
			p.SetState(678)
			p.ExpressionList()
		}

	}
	{
		p.SetState(681)
		p.Match(PHPParserSemiColon)
	}
	p.SetState(683)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if (int64((_la-44)) & ^0x3f) == 0 && ((int64(1)<<(_la-44))&-1) != 0 || (int64((_la-108)) & ^0x3f) == 0 && ((int64(1)<<(_la-108))&1873497444977737727) != 0 || (int64((_la-196)) & ^0x3f) == 0 && ((int64(1)<<(_la-196))&8795020649297) != 0 {
		{
			p.SetState(682)
			p.ForUpdate()
		}

	}
	{
		p.SetState(685)
		p.Match(PHPParserCloseRoundBracket)
	}
	p.SetState(692)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case PHPParserHtmlText, PHPParserXmlStart, PHPParserHtmlScriptOpen, PHPParserHtmlStyleOpen, PHPParserHtmlDtd, PHPParserHtmlOpen, PHPParserHtmlClose, PHPParserHtmlSlashClose, PHPParserHtmlSlash, PHPParserHtmlEquals, PHPParserHtmlStartQuoteString, PHPParserHtmlStartDoubleQuoteString, PHPParserHtmlHex, PHPParserHtmlDecimal, PHPParserHtmlName, PHPParserHtmlEndQuoteString, PHPParserHtmlQuoteString, PHPParserHtmlEndDoubleQuoteString, PHPParserHtmlDoubleQuoteString, PHPParserScriptText, PHPParserHtmlScriptClose, PHPParserStyleBody, PHPParserAbstract, PHPParserArray, PHPParserAs, PHPParserBinaryCast, PHPParserBoolType, PHPParserBooleanConstant, PHPParserBreak, PHPParserCallable, PHPParserCase, PHPParserCatch, PHPParserClass, PHPParserClone, PHPParserConst, PHPParserContinue, PHPParserDefine, PHPParserDefined, PHPParserDeclare, PHPParserDefault, PHPParserDo, PHPParserDoubleCast, PHPParserDoubleType, PHPParserEcho, PHPParserElse, PHPParserElseIf, PHPParserEmpty, PHPParserEnum_, PHPParserEndDeclare, PHPParserEndFor, PHPParserEndForeach, PHPParserEndIf, PHPParserEndSwitch, PHPParserEndWhile, PHPParserEval, PHPParserAssert, PHPParserDie, PHPParserExit, PHPParserExtends, PHPParserFinal, PHPParserFinally, PHPParserFloatCast, PHPParserFor, PHPParserForeach, PHPParserFunction_, PHPParserGlobal, PHPParserGoto, PHPParserIf, PHPParserImplements, PHPParserImport, PHPParserInclude, PHPParserIncludeOnce, PHPParserInstanceOf, PHPParserInsteadOf, PHPParserInt8Cast, PHPParserInt16Cast, PHPParserInt64Type, PHPParserIntType, PHPParserInterface, PHPParserIsSet, PHPParserList, PHPParserLogicalAnd, PHPParserLogicalOr, PHPParserLogicalXor, PHPParserMatch_, PHPParserNamespace, PHPParserNew, PHPParserNull, PHPParserObjectType, PHPParserParent_, PHPParserPartial, PHPParserPrint, PHPParserPrivate, PHPParserProtected, PHPParserPublic, PHPParserReadonly, PHPParserRequire, PHPParserRequireOnce, PHPParserResource, PHPParserReturn, PHPParserStatic, PHPParserStringType, PHPParserSwitch, PHPParserThrow, PHPParserTrait, PHPParserTry, PHPParserTypeof, PHPParserUintCast, PHPParserUnicodeCast, PHPParserUnset, PHPParserUse, PHPParserVar, PHPParserWhile, PHPParserYield, PHPParserFrom, PHPParserLambdaFn, PHPParserTicks, PHPParserEncoding, PHPParserStrictTypes, PHPParserGet, PHPParserSet, PHPParserCall, PHPParserCallStatic, PHPParserConstructor, PHPParserDestruct, PHPParserWakeup, PHPParserSleep, PHPParserAutoload, PHPParserIsSet__, PHPParserUnset__, PHPParserToString__, PHPParserInvoke, PHPParserSetState, PHPParserClone__, PHPParserDebugInfo, PHPParserNamespace__, PHPParserClass__, PHPParserTraic__, PHPParserFunction__, PHPParserMethod__, PHPParserLine__, PHPParserFile__, PHPParserDir__, PHPParserInc, PHPParserDec, PHPParserNamespaceSeparator, PHPParserAmpersand, PHPParserBang, PHPParserPlus, PHPParserMinus, PHPParserTilde, PHPParserSuppressWarnings, PHPParserDollar, PHPParserOpenRoundBracket, PHPParserOpenSquareBracket, PHPParserOpenCurlyBracket, PHPParserSemiColon, PHPParserSet_Include_Path, PHPParserVarName, PHPParserLabel, PHPParserOctal, PHPParserDecimal, PHPParserReal, PHPParserHex, PHPParserBinary, PHPParserBackQuoteString, PHPParserSingleQuoteString, PHPParserDoubleQuote, PHPParserStartNowDoc, PHPParserStartHereDoc:
		{
			p.SetState(686)
			p.Statement()
		}

	case PHPParserColon:
		{
			p.SetState(687)
			p.Match(PHPParserColon)
		}
		{
			p.SetState(688)
			p.InnerStatementList()
		}
		{
			p.SetState(689)
			p.Match(PHPParserEndFor)
		}
		{
			p.SetState(690)
			p.Match(PHPParserSemiColon)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IForInitContext is an interface to support dynamic dispatch.
type IForInitContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsForInitContext differentiates from other interfaces.
	IsForInitContext()
}

type ForInitContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyForInitContext() *ForInitContext {
	var p = new(ForInitContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PHPParserRULE_forInit
	return p
}

func (*ForInitContext) IsForInitContext() {}

func NewForInitContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ForInitContext {
	var p = new(ForInitContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PHPParserRULE_forInit

	return p
}

func (s *ForInitContext) GetParser() antlr.Parser { return s.parser }

func (s *ForInitContext) ExpressionList() IExpressionListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionListContext)
}

func (s *ForInitContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ForInitContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ForInitContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PHPParserVisitor:
		return t.VisitForInit(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PHPParser) ForInit() (localctx IForInitContext) {
	this := p
	_ = this

	localctx = NewForInitContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 76, PHPParserRULE_forInit)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(694)
		p.ExpressionList()
	}

	return localctx
}

// IForUpdateContext is an interface to support dynamic dispatch.
type IForUpdateContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsForUpdateContext differentiates from other interfaces.
	IsForUpdateContext()
}

type ForUpdateContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyForUpdateContext() *ForUpdateContext {
	var p = new(ForUpdateContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PHPParserRULE_forUpdate
	return p
}

func (*ForUpdateContext) IsForUpdateContext() {}

func NewForUpdateContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ForUpdateContext {
	var p = new(ForUpdateContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PHPParserRULE_forUpdate

	return p
}

func (s *ForUpdateContext) GetParser() antlr.Parser { return s.parser }

func (s *ForUpdateContext) ExpressionList() IExpressionListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionListContext)
}

func (s *ForUpdateContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ForUpdateContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ForUpdateContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PHPParserVisitor:
		return t.VisitForUpdate(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PHPParser) ForUpdate() (localctx IForUpdateContext) {
	this := p
	_ = this

	localctx = NewForUpdateContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 78, PHPParserRULE_forUpdate)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(696)
		p.ExpressionList()
	}

	return localctx
}

// ISwitchStatementContext is an interface to support dynamic dispatch.
type ISwitchStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSwitchStatementContext differentiates from other interfaces.
	IsSwitchStatementContext()
}

type SwitchStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySwitchStatementContext() *SwitchStatementContext {
	var p = new(SwitchStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PHPParserRULE_switchStatement
	return p
}

func (*SwitchStatementContext) IsSwitchStatementContext() {}

func NewSwitchStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SwitchStatementContext {
	var p = new(SwitchStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PHPParserRULE_switchStatement

	return p
}

func (s *SwitchStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *SwitchStatementContext) Switch() antlr.TerminalNode {
	return s.GetToken(PHPParserSwitch, 0)
}

func (s *SwitchStatementContext) Parentheses() IParenthesesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IParenthesesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IParenthesesContext)
}

func (s *SwitchStatementContext) OpenCurlyBracket() antlr.TerminalNode {
	return s.GetToken(PHPParserOpenCurlyBracket, 0)
}

func (s *SwitchStatementContext) CloseCurlyBracket() antlr.TerminalNode {
	return s.GetToken(PHPParserCloseCurlyBracket, 0)
}

func (s *SwitchStatementContext) Colon() antlr.TerminalNode {
	return s.GetToken(PHPParserColon, 0)
}

func (s *SwitchStatementContext) EndSwitch() antlr.TerminalNode {
	return s.GetToken(PHPParserEndSwitch, 0)
}

func (s *SwitchStatementContext) AllSemiColon() []antlr.TerminalNode {
	return s.GetTokens(PHPParserSemiColon)
}

func (s *SwitchStatementContext) SemiColon(i int) antlr.TerminalNode {
	return s.GetToken(PHPParserSemiColon, i)
}

func (s *SwitchStatementContext) AllSwitchCaseBlock() []ISwitchCaseBlockContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISwitchCaseBlockContext); ok {
			len++
		}
	}

	tst := make([]ISwitchCaseBlockContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISwitchCaseBlockContext); ok {
			tst[i] = t.(ISwitchCaseBlockContext)
			i++
		}
	}

	return tst
}

func (s *SwitchStatementContext) SwitchCaseBlock(i int) ISwitchCaseBlockContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISwitchCaseBlockContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISwitchCaseBlockContext)
}

func (s *SwitchStatementContext) AllSwitchDefaultBlock() []ISwitchDefaultBlockContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISwitchDefaultBlockContext); ok {
			len++
		}
	}

	tst := make([]ISwitchDefaultBlockContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISwitchDefaultBlockContext); ok {
			tst[i] = t.(ISwitchDefaultBlockContext)
			i++
		}
	}

	return tst
}

func (s *SwitchStatementContext) SwitchDefaultBlock(i int) ISwitchDefaultBlockContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISwitchDefaultBlockContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISwitchDefaultBlockContext)
}

func (s *SwitchStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SwitchStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SwitchStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PHPParserVisitor:
		return t.VisitSwitchStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PHPParser) SwitchStatement() (localctx ISwitchStatementContext) {
	this := p
	_ = this

	localctx = NewSwitchStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 80, PHPParserRULE_switchStatement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(698)
		p.Match(PHPParserSwitch)
	}
	{
		p.SetState(699)
		p.Parentheses()
	}
	p.SetState(725)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case PHPParserOpenCurlyBracket:
		{
			p.SetState(700)
			p.Match(PHPParserOpenCurlyBracket)
		}
		p.SetState(702)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == PHPParserSemiColon {
			{
				p.SetState(701)
				p.Match(PHPParserSemiColon)
			}

		}
		p.SetState(708)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == PHPParserCase || _la == PHPParserDefault {
			p.SetState(706)
			p.GetErrorHandler().Sync(p)

			switch p.GetTokenStream().LA(1) {
			case PHPParserCase:
				{
					p.SetState(704)
					p.SwitchCaseBlock()
				}

			case PHPParserDefault:
				{
					p.SetState(705)
					p.SwitchDefaultBlock()
				}

			default:
				panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			}

			p.SetState(710)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(711)
			p.Match(PHPParserCloseCurlyBracket)
		}

	case PHPParserColon:
		{
			p.SetState(712)
			p.Match(PHPParserColon)
		}
		p.SetState(714)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == PHPParserSemiColon {
			{
				p.SetState(713)
				p.Match(PHPParserSemiColon)
			}

		}
		p.SetState(720)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == PHPParserCase || _la == PHPParserDefault {
			p.SetState(718)
			p.GetErrorHandler().Sync(p)

			switch p.GetTokenStream().LA(1) {
			case PHPParserCase:
				{
					p.SetState(716)
					p.SwitchCaseBlock()
				}

			case PHPParserDefault:
				{
					p.SetState(717)
					p.SwitchDefaultBlock()
				}

			default:
				panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			}

			p.SetState(722)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(723)
			p.Match(PHPParserEndSwitch)
		}
		{
			p.SetState(724)
			p.Match(PHPParserSemiColon)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ISwitchCaseBlockContext is an interface to support dynamic dispatch.
type ISwitchCaseBlockContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSwitchCaseBlockContext differentiates from other interfaces.
	IsSwitchCaseBlockContext()
}

type SwitchCaseBlockContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySwitchCaseBlockContext() *SwitchCaseBlockContext {
	var p = new(SwitchCaseBlockContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PHPParserRULE_switchCaseBlock
	return p
}

func (*SwitchCaseBlockContext) IsSwitchCaseBlockContext() {}

func NewSwitchCaseBlockContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SwitchCaseBlockContext {
	var p = new(SwitchCaseBlockContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PHPParserRULE_switchCaseBlock

	return p
}

func (s *SwitchCaseBlockContext) GetParser() antlr.Parser { return s.parser }

func (s *SwitchCaseBlockContext) Case() antlr.TerminalNode {
	return s.GetToken(PHPParserCase, 0)
}

func (s *SwitchCaseBlockContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *SwitchCaseBlockContext) InnerStatementList() IInnerStatementListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInnerStatementListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInnerStatementListContext)
}

func (s *SwitchCaseBlockContext) Colon() antlr.TerminalNode {
	return s.GetToken(PHPParserColon, 0)
}

func (s *SwitchCaseBlockContext) AllSemiColon() []antlr.TerminalNode {
	return s.GetTokens(PHPParserSemiColon)
}

func (s *SwitchCaseBlockContext) SemiColon(i int) antlr.TerminalNode {
	return s.GetToken(PHPParserSemiColon, i)
}

func (s *SwitchCaseBlockContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SwitchCaseBlockContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SwitchCaseBlockContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PHPParserVisitor:
		return t.VisitSwitchCaseBlock(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PHPParser) SwitchCaseBlock() (localctx ISwitchCaseBlockContext) {
	this := p
	_ = this

	localctx = NewSwitchCaseBlockContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 82, PHPParserRULE_switchCaseBlock)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(727)
		p.Match(PHPParserCase)
	}
	{
		p.SetState(728)
		p.expression(0)
	}
	{
		p.SetState(729)
		_la = p.GetTokenStream().LA(1)

		if !(_la == PHPParserColon || _la == PHPParserSemiColon) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	p.SetState(733)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 63, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(730)
				p.Match(PHPParserSemiColon)
			}

		}
		p.SetState(735)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 63, p.GetParserRuleContext())
	}
	{
		p.SetState(736)
		p.InnerStatementList()
	}

	return localctx
}

// ISwitchDefaultBlockContext is an interface to support dynamic dispatch.
type ISwitchDefaultBlockContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSwitchDefaultBlockContext differentiates from other interfaces.
	IsSwitchDefaultBlockContext()
}

type SwitchDefaultBlockContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySwitchDefaultBlockContext() *SwitchDefaultBlockContext {
	var p = new(SwitchDefaultBlockContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PHPParserRULE_switchDefaultBlock
	return p
}

func (*SwitchDefaultBlockContext) IsSwitchDefaultBlockContext() {}

func NewSwitchDefaultBlockContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SwitchDefaultBlockContext {
	var p = new(SwitchDefaultBlockContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PHPParserRULE_switchDefaultBlock

	return p
}

func (s *SwitchDefaultBlockContext) GetParser() antlr.Parser { return s.parser }

func (s *SwitchDefaultBlockContext) Default() antlr.TerminalNode {
	return s.GetToken(PHPParserDefault, 0)
}

func (s *SwitchDefaultBlockContext) InnerStatementList() IInnerStatementListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInnerStatementListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInnerStatementListContext)
}

func (s *SwitchDefaultBlockContext) Colon() antlr.TerminalNode {
	return s.GetToken(PHPParserColon, 0)
}

func (s *SwitchDefaultBlockContext) AllSemiColon() []antlr.TerminalNode {
	return s.GetTokens(PHPParserSemiColon)
}

func (s *SwitchDefaultBlockContext) SemiColon(i int) antlr.TerminalNode {
	return s.GetToken(PHPParserSemiColon, i)
}

func (s *SwitchDefaultBlockContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SwitchDefaultBlockContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SwitchDefaultBlockContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PHPParserVisitor:
		return t.VisitSwitchDefaultBlock(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PHPParser) SwitchDefaultBlock() (localctx ISwitchDefaultBlockContext) {
	this := p
	_ = this

	localctx = NewSwitchDefaultBlockContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 84, PHPParserRULE_switchDefaultBlock)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(738)
		p.Match(PHPParserDefault)
	}
	{
		p.SetState(739)
		_la = p.GetTokenStream().LA(1)

		if !(_la == PHPParserColon || _la == PHPParserSemiColon) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	p.SetState(743)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 64, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(740)
				p.Match(PHPParserSemiColon)
			}

		}
		p.SetState(745)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 64, p.GetParserRuleContext())
	}
	{
		p.SetState(746)
		p.InnerStatementList()
	}

	return localctx
}

// ISwitchBlockContext is an interface to support dynamic dispatch.
type ISwitchBlockContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSwitchBlockContext differentiates from other interfaces.
	IsSwitchBlockContext()
}

type SwitchBlockContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySwitchBlockContext() *SwitchBlockContext {
	var p = new(SwitchBlockContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PHPParserRULE_switchBlock
	return p
}

func (*SwitchBlockContext) IsSwitchBlockContext() {}

func NewSwitchBlockContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SwitchBlockContext {
	var p = new(SwitchBlockContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PHPParserRULE_switchBlock

	return p
}

func (s *SwitchBlockContext) GetParser() antlr.Parser { return s.parser }

func (s *SwitchBlockContext) InnerStatementList() IInnerStatementListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInnerStatementListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInnerStatementListContext)
}

func (s *SwitchBlockContext) AllColon() []antlr.TerminalNode {
	return s.GetTokens(PHPParserColon)
}

func (s *SwitchBlockContext) Colon(i int) antlr.TerminalNode {
	return s.GetToken(PHPParserColon, i)
}

func (s *SwitchBlockContext) AllSemiColon() []antlr.TerminalNode {
	return s.GetTokens(PHPParserSemiColon)
}

func (s *SwitchBlockContext) SemiColon(i int) antlr.TerminalNode {
	return s.GetToken(PHPParserSemiColon, i)
}

func (s *SwitchBlockContext) AllDefault() []antlr.TerminalNode {
	return s.GetTokens(PHPParserDefault)
}

func (s *SwitchBlockContext) Default(i int) antlr.TerminalNode {
	return s.GetToken(PHPParserDefault, i)
}

func (s *SwitchBlockContext) AllCase() []antlr.TerminalNode {
	return s.GetTokens(PHPParserCase)
}

func (s *SwitchBlockContext) Case(i int) antlr.TerminalNode {
	return s.GetToken(PHPParserCase, i)
}

func (s *SwitchBlockContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *SwitchBlockContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *SwitchBlockContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SwitchBlockContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SwitchBlockContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PHPParserVisitor:
		return t.VisitSwitchBlock(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PHPParser) SwitchBlock() (localctx ISwitchBlockContext) {
	this := p
	_ = this

	localctx = NewSwitchBlockContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 86, PHPParserRULE_switchBlock)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(760)
	p.GetErrorHandler().Sync(p)
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			p.SetState(751)
			p.GetErrorHandler().Sync(p)

			switch p.GetTokenStream().LA(1) {
			case PHPParserCase:
				{
					p.SetState(748)
					p.Match(PHPParserCase)
				}
				{
					p.SetState(749)
					p.expression(0)
				}

			case PHPParserDefault:
				{
					p.SetState(750)
					p.Match(PHPParserDefault)
				}

			default:
				panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			}
			{
				p.SetState(753)
				_la = p.GetTokenStream().LA(1)

				if !(_la == PHPParserColon || _la == PHPParserSemiColon) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}
			p.SetState(757)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 66, p.GetParserRuleContext())

			for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
				if _alt == 1 {
					{
						p.SetState(754)
						p.Match(PHPParserSemiColon)
					}

				}
				p.SetState(759)
				p.GetErrorHandler().Sync(p)
				_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 66, p.GetParserRuleContext())
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(762)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 67, p.GetParserRuleContext())
	}
	{
		p.SetState(764)
		p.InnerStatementList()
	}

	return localctx
}

// IBreakStatementContext is an interface to support dynamic dispatch.
type IBreakStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsBreakStatementContext differentiates from other interfaces.
	IsBreakStatementContext()
}

type BreakStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBreakStatementContext() *BreakStatementContext {
	var p = new(BreakStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PHPParserRULE_breakStatement
	return p
}

func (*BreakStatementContext) IsBreakStatementContext() {}

func NewBreakStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BreakStatementContext {
	var p = new(BreakStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PHPParserRULE_breakStatement

	return p
}

func (s *BreakStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *BreakStatementContext) Break() antlr.TerminalNode {
	return s.GetToken(PHPParserBreak, 0)
}

func (s *BreakStatementContext) SemiColon() antlr.TerminalNode {
	return s.GetToken(PHPParserSemiColon, 0)
}

func (s *BreakStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *BreakStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BreakStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BreakStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PHPParserVisitor:
		return t.VisitBreakStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PHPParser) BreakStatement() (localctx IBreakStatementContext) {
	this := p
	_ = this

	localctx = NewBreakStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 88, PHPParserRULE_breakStatement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(766)
		p.Match(PHPParserBreak)
	}
	p.SetState(768)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if (int64((_la-44)) & ^0x3f) == 0 && ((int64(1)<<(_la-44))&-1) != 0 || (int64((_la-108)) & ^0x3f) == 0 && ((int64(1)<<(_la-108))&1873497444977737727) != 0 || (int64((_la-196)) & ^0x3f) == 0 && ((int64(1)<<(_la-196))&8795020649297) != 0 {
		{
			p.SetState(767)
			p.expression(0)
		}

	}
	{
		p.SetState(770)
		p.Match(PHPParserSemiColon)
	}

	return localctx
}

// IContinueStatementContext is an interface to support dynamic dispatch.
type IContinueStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsContinueStatementContext differentiates from other interfaces.
	IsContinueStatementContext()
}

type ContinueStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyContinueStatementContext() *ContinueStatementContext {
	var p = new(ContinueStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PHPParserRULE_continueStatement
	return p
}

func (*ContinueStatementContext) IsContinueStatementContext() {}

func NewContinueStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ContinueStatementContext {
	var p = new(ContinueStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PHPParserRULE_continueStatement

	return p
}

func (s *ContinueStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ContinueStatementContext) Continue() antlr.TerminalNode {
	return s.GetToken(PHPParserContinue, 0)
}

func (s *ContinueStatementContext) SemiColon() antlr.TerminalNode {
	return s.GetToken(PHPParserSemiColon, 0)
}

func (s *ContinueStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ContinueStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ContinueStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ContinueStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PHPParserVisitor:
		return t.VisitContinueStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PHPParser) ContinueStatement() (localctx IContinueStatementContext) {
	this := p
	_ = this

	localctx = NewContinueStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 90, PHPParserRULE_continueStatement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(772)
		p.Match(PHPParserContinue)
	}
	p.SetState(774)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if (int64((_la-44)) & ^0x3f) == 0 && ((int64(1)<<(_la-44))&-1) != 0 || (int64((_la-108)) & ^0x3f) == 0 && ((int64(1)<<(_la-108))&1873497444977737727) != 0 || (int64((_la-196)) & ^0x3f) == 0 && ((int64(1)<<(_la-196))&8795020649297) != 0 {
		{
			p.SetState(773)
			p.expression(0)
		}

	}
	{
		p.SetState(776)
		p.Match(PHPParserSemiColon)
	}

	return localctx
}

// IReturnStatementContext is an interface to support dynamic dispatch.
type IReturnStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsReturnStatementContext differentiates from other interfaces.
	IsReturnStatementContext()
}

type ReturnStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReturnStatementContext() *ReturnStatementContext {
	var p = new(ReturnStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PHPParserRULE_returnStatement
	return p
}

func (*ReturnStatementContext) IsReturnStatementContext() {}

func NewReturnStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReturnStatementContext {
	var p = new(ReturnStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PHPParserRULE_returnStatement

	return p
}

func (s *ReturnStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ReturnStatementContext) Return() antlr.TerminalNode {
	return s.GetToken(PHPParserReturn, 0)
}

func (s *ReturnStatementContext) SemiColon() antlr.TerminalNode {
	return s.GetToken(PHPParserSemiColon, 0)
}

func (s *ReturnStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ReturnStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReturnStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReturnStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PHPParserVisitor:
		return t.VisitReturnStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PHPParser) ReturnStatement() (localctx IReturnStatementContext) {
	this := p
	_ = this

	localctx = NewReturnStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 92, PHPParserRULE_returnStatement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(778)
		p.Match(PHPParserReturn)
	}
	p.SetState(780)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if (int64((_la-44)) & ^0x3f) == 0 && ((int64(1)<<(_la-44))&-1) != 0 || (int64((_la-108)) & ^0x3f) == 0 && ((int64(1)<<(_la-108))&1873497444977737727) != 0 || (int64((_la-196)) & ^0x3f) == 0 && ((int64(1)<<(_la-196))&8795020649297) != 0 {
		{
			p.SetState(779)
			p.expression(0)
		}

	}
	{
		p.SetState(782)
		p.Match(PHPParserSemiColon)
	}

	return localctx
}

// IExpressionStatementContext is an interface to support dynamic dispatch.
type IExpressionStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExpressionStatementContext differentiates from other interfaces.
	IsExpressionStatementContext()
}

type ExpressionStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpressionStatementContext() *ExpressionStatementContext {
	var p = new(ExpressionStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PHPParserRULE_expressionStatement
	return p
}

func (*ExpressionStatementContext) IsExpressionStatementContext() {}

func NewExpressionStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExpressionStatementContext {
	var p = new(ExpressionStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PHPParserRULE_expressionStatement

	return p
}

func (s *ExpressionStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ExpressionStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ExpressionStatementContext) SemiColon() antlr.TerminalNode {
	return s.GetToken(PHPParserSemiColon, 0)
}

func (s *ExpressionStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExpressionStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExpressionStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PHPParserVisitor:
		return t.VisitExpressionStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PHPParser) ExpressionStatement() (localctx IExpressionStatementContext) {
	this := p
	_ = this

	localctx = NewExpressionStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 94, PHPParserRULE_expressionStatement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(784)
		p.expression(0)
	}
	{
		p.SetState(785)
		p.Match(PHPParserSemiColon)
	}

	return localctx
}

// IUnsetStatementContext is an interface to support dynamic dispatch.
type IUnsetStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsUnsetStatementContext differentiates from other interfaces.
	IsUnsetStatementContext()
}

type UnsetStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnsetStatementContext() *UnsetStatementContext {
	var p = new(UnsetStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PHPParserRULE_unsetStatement
	return p
}

func (*UnsetStatementContext) IsUnsetStatementContext() {}

func NewUnsetStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UnsetStatementContext {
	var p = new(UnsetStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PHPParserRULE_unsetStatement

	return p
}

func (s *UnsetStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *UnsetStatementContext) Unset() antlr.TerminalNode {
	return s.GetToken(PHPParserUnset, 0)
}

func (s *UnsetStatementContext) OpenRoundBracket() antlr.TerminalNode {
	return s.GetToken(PHPParserOpenRoundBracket, 0)
}

func (s *UnsetStatementContext) ChainList() IChainListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IChainListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IChainListContext)
}

func (s *UnsetStatementContext) CloseRoundBracket() antlr.TerminalNode {
	return s.GetToken(PHPParserCloseRoundBracket, 0)
}

func (s *UnsetStatementContext) SemiColon() antlr.TerminalNode {
	return s.GetToken(PHPParserSemiColon, 0)
}

func (s *UnsetStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnsetStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UnsetStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PHPParserVisitor:
		return t.VisitUnsetStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PHPParser) UnsetStatement() (localctx IUnsetStatementContext) {
	this := p
	_ = this

	localctx = NewUnsetStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 96, PHPParserRULE_unsetStatement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(787)
		p.Match(PHPParserUnset)
	}
	{
		p.SetState(788)
		p.Match(PHPParserOpenRoundBracket)
	}
	{
		p.SetState(789)
		p.ChainList()
	}
	{
		p.SetState(790)
		p.Match(PHPParserCloseRoundBracket)
	}
	{
		p.SetState(791)
		p.Match(PHPParserSemiColon)
	}

	return localctx
}

// IForeachStatementContext is an interface to support dynamic dispatch.
type IForeachStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsForeachStatementContext differentiates from other interfaces.
	IsForeachStatementContext()
}

type ForeachStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyForeachStatementContext() *ForeachStatementContext {
	var p = new(ForeachStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PHPParserRULE_foreachStatement
	return p
}

func (*ForeachStatementContext) IsForeachStatementContext() {}

func NewForeachStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ForeachStatementContext {
	var p = new(ForeachStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PHPParserRULE_foreachStatement

	return p
}

func (s *ForeachStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ForeachStatementContext) Foreach() antlr.TerminalNode {
	return s.GetToken(PHPParserForeach, 0)
}

func (s *ForeachStatementContext) AllOpenRoundBracket() []antlr.TerminalNode {
	return s.GetTokens(PHPParserOpenRoundBracket)
}

func (s *ForeachStatementContext) OpenRoundBracket(i int) antlr.TerminalNode {
	return s.GetToken(PHPParserOpenRoundBracket, i)
}

func (s *ForeachStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ForeachStatementContext) As() antlr.TerminalNode {
	return s.GetToken(PHPParserAs, 0)
}

func (s *ForeachStatementContext) ArrayDestructuring() IArrayDestructuringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArrayDestructuringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArrayDestructuringContext)
}

func (s *ForeachStatementContext) AllCloseRoundBracket() []antlr.TerminalNode {
	return s.GetTokens(PHPParserCloseRoundBracket)
}

func (s *ForeachStatementContext) CloseRoundBracket(i int) antlr.TerminalNode {
	return s.GetToken(PHPParserCloseRoundBracket, i)
}

func (s *ForeachStatementContext) AllChain() []IChainContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IChainContext); ok {
			len++
		}
	}

	tst := make([]IChainContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IChainContext); ok {
			tst[i] = t.(IChainContext)
			i++
		}
	}

	return tst
}

func (s *ForeachStatementContext) Chain(i int) IChainContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IChainContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IChainContext)
}

func (s *ForeachStatementContext) Assignable() IAssignableContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAssignableContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAssignableContext)
}

func (s *ForeachStatementContext) List() antlr.TerminalNode {
	return s.GetToken(PHPParserList, 0)
}

func (s *ForeachStatementContext) AssignmentList() IAssignmentListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAssignmentListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAssignmentListContext)
}

func (s *ForeachStatementContext) Statement() IStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *ForeachStatementContext) Colon() antlr.TerminalNode {
	return s.GetToken(PHPParserColon, 0)
}

func (s *ForeachStatementContext) InnerStatementList() IInnerStatementListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInnerStatementListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInnerStatementListContext)
}

func (s *ForeachStatementContext) EndForeach() antlr.TerminalNode {
	return s.GetToken(PHPParserEndForeach, 0)
}

func (s *ForeachStatementContext) SemiColon() antlr.TerminalNode {
	return s.GetToken(PHPParserSemiColon, 0)
}

func (s *ForeachStatementContext) AllAmpersand() []antlr.TerminalNode {
	return s.GetTokens(PHPParserAmpersand)
}

func (s *ForeachStatementContext) Ampersand(i int) antlr.TerminalNode {
	return s.GetToken(PHPParserAmpersand, i)
}

func (s *ForeachStatementContext) DoubleArrow() antlr.TerminalNode {
	return s.GetToken(PHPParserDoubleArrow, 0)
}

func (s *ForeachStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ForeachStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ForeachStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PHPParserVisitor:
		return t.VisitForeachStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PHPParser) ForeachStatement() (localctx IForeachStatementContext) {
	this := p
	_ = this

	localctx = NewForeachStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 98, PHPParserRULE_foreachStatement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(793)
		p.Match(PHPParserForeach)
	}
	p.SetState(838)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 76, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(794)
			p.Match(PHPParserOpenRoundBracket)
		}
		{
			p.SetState(795)
			p.expression(0)
		}
		{
			p.SetState(796)
			p.Match(PHPParserAs)
		}
		{
			p.SetState(797)
			p.ArrayDestructuring()
		}
		{
			p.SetState(798)
			p.Match(PHPParserCloseRoundBracket)
		}

	case 2:
		{
			p.SetState(800)
			p.Match(PHPParserOpenRoundBracket)
		}
		{
			p.SetState(801)
			p.Chain()
		}
		{
			p.SetState(802)
			p.Match(PHPParserAs)
		}
		p.SetState(804)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == PHPParserAmpersand {
			{
				p.SetState(803)
				p.Match(PHPParserAmpersand)
			}

		}
		{
			p.SetState(806)
			p.Assignable()
		}
		p.SetState(812)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == PHPParserDoubleArrow {
			{
				p.SetState(807)
				p.Match(PHPParserDoubleArrow)
			}
			p.SetState(809)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == PHPParserAmpersand {
				{
					p.SetState(808)
					p.Match(PHPParserAmpersand)
				}

			}
			{
				p.SetState(811)
				p.Chain()
			}

		}
		{
			p.SetState(814)
			p.Match(PHPParserCloseRoundBracket)
		}

	case 3:
		{
			p.SetState(816)
			p.Match(PHPParserOpenRoundBracket)
		}
		{
			p.SetState(817)
			p.expression(0)
		}
		{
			p.SetState(818)
			p.Match(PHPParserAs)
		}
		{
			p.SetState(819)
			p.Assignable()
		}
		p.SetState(825)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == PHPParserDoubleArrow {
			{
				p.SetState(820)
				p.Match(PHPParserDoubleArrow)
			}
			p.SetState(822)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == PHPParserAmpersand {
				{
					p.SetState(821)
					p.Match(PHPParserAmpersand)
				}

			}
			{
				p.SetState(824)
				p.Chain()
			}

		}
		{
			p.SetState(827)
			p.Match(PHPParserCloseRoundBracket)
		}

	case 4:
		{
			p.SetState(829)
			p.Match(PHPParserOpenRoundBracket)
		}
		{
			p.SetState(830)
			p.Chain()
		}
		{
			p.SetState(831)
			p.Match(PHPParserAs)
		}
		{
			p.SetState(832)
			p.Match(PHPParserList)
		}
		{
			p.SetState(833)
			p.Match(PHPParserOpenRoundBracket)
		}
		{
			p.SetState(834)
			p.AssignmentList()
		}
		{
			p.SetState(835)
			p.Match(PHPParserCloseRoundBracket)
		}
		{
			p.SetState(836)
			p.Match(PHPParserCloseRoundBracket)
		}

	}
	p.SetState(846)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case PHPParserHtmlText, PHPParserXmlStart, PHPParserHtmlScriptOpen, PHPParserHtmlStyleOpen, PHPParserHtmlDtd, PHPParserHtmlOpen, PHPParserHtmlClose, PHPParserHtmlSlashClose, PHPParserHtmlSlash, PHPParserHtmlEquals, PHPParserHtmlStartQuoteString, PHPParserHtmlStartDoubleQuoteString, PHPParserHtmlHex, PHPParserHtmlDecimal, PHPParserHtmlName, PHPParserHtmlEndQuoteString, PHPParserHtmlQuoteString, PHPParserHtmlEndDoubleQuoteString, PHPParserHtmlDoubleQuoteString, PHPParserScriptText, PHPParserHtmlScriptClose, PHPParserStyleBody, PHPParserAbstract, PHPParserArray, PHPParserAs, PHPParserBinaryCast, PHPParserBoolType, PHPParserBooleanConstant, PHPParserBreak, PHPParserCallable, PHPParserCase, PHPParserCatch, PHPParserClass, PHPParserClone, PHPParserConst, PHPParserContinue, PHPParserDefine, PHPParserDefined, PHPParserDeclare, PHPParserDefault, PHPParserDo, PHPParserDoubleCast, PHPParserDoubleType, PHPParserEcho, PHPParserElse, PHPParserElseIf, PHPParserEmpty, PHPParserEnum_, PHPParserEndDeclare, PHPParserEndFor, PHPParserEndForeach, PHPParserEndIf, PHPParserEndSwitch, PHPParserEndWhile, PHPParserEval, PHPParserAssert, PHPParserDie, PHPParserExit, PHPParserExtends, PHPParserFinal, PHPParserFinally, PHPParserFloatCast, PHPParserFor, PHPParserForeach, PHPParserFunction_, PHPParserGlobal, PHPParserGoto, PHPParserIf, PHPParserImplements, PHPParserImport, PHPParserInclude, PHPParserIncludeOnce, PHPParserInstanceOf, PHPParserInsteadOf, PHPParserInt8Cast, PHPParserInt16Cast, PHPParserInt64Type, PHPParserIntType, PHPParserInterface, PHPParserIsSet, PHPParserList, PHPParserLogicalAnd, PHPParserLogicalOr, PHPParserLogicalXor, PHPParserMatch_, PHPParserNamespace, PHPParserNew, PHPParserNull, PHPParserObjectType, PHPParserParent_, PHPParserPartial, PHPParserPrint, PHPParserPrivate, PHPParserProtected, PHPParserPublic, PHPParserReadonly, PHPParserRequire, PHPParserRequireOnce, PHPParserResource, PHPParserReturn, PHPParserStatic, PHPParserStringType, PHPParserSwitch, PHPParserThrow, PHPParserTrait, PHPParserTry, PHPParserTypeof, PHPParserUintCast, PHPParserUnicodeCast, PHPParserUnset, PHPParserUse, PHPParserVar, PHPParserWhile, PHPParserYield, PHPParserFrom, PHPParserLambdaFn, PHPParserTicks, PHPParserEncoding, PHPParserStrictTypes, PHPParserGet, PHPParserSet, PHPParserCall, PHPParserCallStatic, PHPParserConstructor, PHPParserDestruct, PHPParserWakeup, PHPParserSleep, PHPParserAutoload, PHPParserIsSet__, PHPParserUnset__, PHPParserToString__, PHPParserInvoke, PHPParserSetState, PHPParserClone__, PHPParserDebugInfo, PHPParserNamespace__, PHPParserClass__, PHPParserTraic__, PHPParserFunction__, PHPParserMethod__, PHPParserLine__, PHPParserFile__, PHPParserDir__, PHPParserInc, PHPParserDec, PHPParserNamespaceSeparator, PHPParserAmpersand, PHPParserBang, PHPParserPlus, PHPParserMinus, PHPParserTilde, PHPParserSuppressWarnings, PHPParserDollar, PHPParserOpenRoundBracket, PHPParserOpenSquareBracket, PHPParserOpenCurlyBracket, PHPParserSemiColon, PHPParserSet_Include_Path, PHPParserVarName, PHPParserLabel, PHPParserOctal, PHPParserDecimal, PHPParserReal, PHPParserHex, PHPParserBinary, PHPParserBackQuoteString, PHPParserSingleQuoteString, PHPParserDoubleQuote, PHPParserStartNowDoc, PHPParserStartHereDoc:
		{
			p.SetState(840)
			p.Statement()
		}

	case PHPParserColon:
		{
			p.SetState(841)
			p.Match(PHPParserColon)
		}
		{
			p.SetState(842)
			p.InnerStatementList()
		}
		{
			p.SetState(843)
			p.Match(PHPParserEndForeach)
		}
		{
			p.SetState(844)
			p.Match(PHPParserSemiColon)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ITryCatchFinallyContext is an interface to support dynamic dispatch.
type ITryCatchFinallyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTryCatchFinallyContext differentiates from other interfaces.
	IsTryCatchFinallyContext()
}

type TryCatchFinallyContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTryCatchFinallyContext() *TryCatchFinallyContext {
	var p = new(TryCatchFinallyContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PHPParserRULE_tryCatchFinally
	return p
}

func (*TryCatchFinallyContext) IsTryCatchFinallyContext() {}

func NewTryCatchFinallyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TryCatchFinallyContext {
	var p = new(TryCatchFinallyContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PHPParserRULE_tryCatchFinally

	return p
}

func (s *TryCatchFinallyContext) GetParser() antlr.Parser { return s.parser }

func (s *TryCatchFinallyContext) Try() antlr.TerminalNode {
	return s.GetToken(PHPParserTry, 0)
}

func (s *TryCatchFinallyContext) BlockStatement() IBlockStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBlockStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBlockStatementContext)
}

func (s *TryCatchFinallyContext) FinallyStatement() IFinallyStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFinallyStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFinallyStatementContext)
}

func (s *TryCatchFinallyContext) AllCatchClause() []ICatchClauseContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ICatchClauseContext); ok {
			len++
		}
	}

	tst := make([]ICatchClauseContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ICatchClauseContext); ok {
			tst[i] = t.(ICatchClauseContext)
			i++
		}
	}

	return tst
}

func (s *TryCatchFinallyContext) CatchClause(i int) ICatchClauseContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICatchClauseContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICatchClauseContext)
}

func (s *TryCatchFinallyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TryCatchFinallyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TryCatchFinallyContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PHPParserVisitor:
		return t.VisitTryCatchFinally(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PHPParser) TryCatchFinally() (localctx ITryCatchFinallyContext) {
	this := p
	_ = this

	localctx = NewTryCatchFinallyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 100, PHPParserRULE_tryCatchFinally)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(848)
		p.Match(PHPParserTry)
	}
	{
		p.SetState(849)
		p.BlockStatement()
	}
	p.SetState(865)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 81, p.GetParserRuleContext()) {
	case 1:
		p.SetState(851)
		p.GetErrorHandler().Sync(p)
		_alt = 1
		for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			switch _alt {
			case 1:
				{
					p.SetState(850)
					p.CatchClause()
				}

			default:
				panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			}

			p.SetState(853)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 78, p.GetParserRuleContext())
		}
		p.SetState(856)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 79, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(855)
				p.FinallyStatement()
			}

		}

	case 2:
		p.SetState(861)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == PHPParserCatch {
			{
				p.SetState(858)
				p.CatchClause()
			}

			p.SetState(863)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(864)
			p.FinallyStatement()
		}

	}

	return localctx
}

// ICatchClauseContext is an interface to support dynamic dispatch.
type ICatchClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCatchClauseContext differentiates from other interfaces.
	IsCatchClauseContext()
}

type CatchClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCatchClauseContext() *CatchClauseContext {
	var p = new(CatchClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PHPParserRULE_catchClause
	return p
}

func (*CatchClauseContext) IsCatchClauseContext() {}

func NewCatchClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CatchClauseContext {
	var p = new(CatchClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PHPParserRULE_catchClause

	return p
}

func (s *CatchClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *CatchClauseContext) Catch() antlr.TerminalNode {
	return s.GetToken(PHPParserCatch, 0)
}

func (s *CatchClauseContext) OpenRoundBracket() antlr.TerminalNode {
	return s.GetToken(PHPParserOpenRoundBracket, 0)
}

func (s *CatchClauseContext) AllQualifiedStaticTypeRef() []IQualifiedStaticTypeRefContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IQualifiedStaticTypeRefContext); ok {
			len++
		}
	}

	tst := make([]IQualifiedStaticTypeRefContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IQualifiedStaticTypeRefContext); ok {
			tst[i] = t.(IQualifiedStaticTypeRefContext)
			i++
		}
	}

	return tst
}

func (s *CatchClauseContext) QualifiedStaticTypeRef(i int) IQualifiedStaticTypeRefContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedStaticTypeRefContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedStaticTypeRefContext)
}

func (s *CatchClauseContext) CloseRoundBracket() antlr.TerminalNode {
	return s.GetToken(PHPParserCloseRoundBracket, 0)
}

func (s *CatchClauseContext) BlockStatement() IBlockStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBlockStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBlockStatementContext)
}

func (s *CatchClauseContext) AllPipe() []antlr.TerminalNode {
	return s.GetTokens(PHPParserPipe)
}

func (s *CatchClauseContext) Pipe(i int) antlr.TerminalNode {
	return s.GetToken(PHPParserPipe, i)
}

func (s *CatchClauseContext) VarName() antlr.TerminalNode {
	return s.GetToken(PHPParserVarName, 0)
}

func (s *CatchClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CatchClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CatchClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PHPParserVisitor:
		return t.VisitCatchClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PHPParser) CatchClause() (localctx ICatchClauseContext) {
	this := p
	_ = this

	localctx = NewCatchClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 102, PHPParserRULE_catchClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(867)
		p.Match(PHPParserCatch)
	}
	{
		p.SetState(868)
		p.Match(PHPParserOpenRoundBracket)
	}
	{
		p.SetState(869)
		p.QualifiedStaticTypeRef()
	}
	p.SetState(874)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == PHPParserPipe {
		{
			p.SetState(870)
			p.Match(PHPParserPipe)
		}
		{
			p.SetState(871)
			p.QualifiedStaticTypeRef()
		}

		p.SetState(876)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(878)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == PHPParserVarName {
		{
			p.SetState(877)
			p.Match(PHPParserVarName)
		}

	}
	{
		p.SetState(880)
		p.Match(PHPParserCloseRoundBracket)
	}
	{
		p.SetState(881)
		p.BlockStatement()
	}

	return localctx
}

// IFinallyStatementContext is an interface to support dynamic dispatch.
type IFinallyStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFinallyStatementContext differentiates from other interfaces.
	IsFinallyStatementContext()
}

type FinallyStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFinallyStatementContext() *FinallyStatementContext {
	var p = new(FinallyStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PHPParserRULE_finallyStatement
	return p
}

func (*FinallyStatementContext) IsFinallyStatementContext() {}

func NewFinallyStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FinallyStatementContext {
	var p = new(FinallyStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PHPParserRULE_finallyStatement

	return p
}

func (s *FinallyStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *FinallyStatementContext) Finally() antlr.TerminalNode {
	return s.GetToken(PHPParserFinally, 0)
}

func (s *FinallyStatementContext) BlockStatement() IBlockStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBlockStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBlockStatementContext)
}

func (s *FinallyStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FinallyStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FinallyStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PHPParserVisitor:
		return t.VisitFinallyStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PHPParser) FinallyStatement() (localctx IFinallyStatementContext) {
	this := p
	_ = this

	localctx = NewFinallyStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 104, PHPParserRULE_finallyStatement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(883)
		p.Match(PHPParserFinally)
	}
	{
		p.SetState(884)
		p.BlockStatement()
	}

	return localctx
}

// IThrowStatementContext is an interface to support dynamic dispatch.
type IThrowStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsThrowStatementContext differentiates from other interfaces.
	IsThrowStatementContext()
}

type ThrowStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyThrowStatementContext() *ThrowStatementContext {
	var p = new(ThrowStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PHPParserRULE_throwStatement
	return p
}

func (*ThrowStatementContext) IsThrowStatementContext() {}

func NewThrowStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ThrowStatementContext {
	var p = new(ThrowStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PHPParserRULE_throwStatement

	return p
}

func (s *ThrowStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ThrowStatementContext) Throw() antlr.TerminalNode {
	return s.GetToken(PHPParserThrow, 0)
}

func (s *ThrowStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ThrowStatementContext) SemiColon() antlr.TerminalNode {
	return s.GetToken(PHPParserSemiColon, 0)
}

func (s *ThrowStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ThrowStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ThrowStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PHPParserVisitor:
		return t.VisitThrowStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PHPParser) ThrowStatement() (localctx IThrowStatementContext) {
	this := p
	_ = this

	localctx = NewThrowStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 106, PHPParserRULE_throwStatement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(886)
		p.Match(PHPParserThrow)
	}
	{
		p.SetState(887)
		p.expression(0)
	}
	{
		p.SetState(888)
		p.Match(PHPParserSemiColon)
	}

	return localctx
}

// IGotoStatementContext is an interface to support dynamic dispatch.
type IGotoStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsGotoStatementContext differentiates from other interfaces.
	IsGotoStatementContext()
}

type GotoStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGotoStatementContext() *GotoStatementContext {
	var p = new(GotoStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PHPParserRULE_gotoStatement
	return p
}

func (*GotoStatementContext) IsGotoStatementContext() {}

func NewGotoStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GotoStatementContext {
	var p = new(GotoStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PHPParserRULE_gotoStatement

	return p
}

func (s *GotoStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *GotoStatementContext) Goto() antlr.TerminalNode {
	return s.GetToken(PHPParserGoto, 0)
}

func (s *GotoStatementContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *GotoStatementContext) SemiColon() antlr.TerminalNode {
	return s.GetToken(PHPParserSemiColon, 0)
}

func (s *GotoStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GotoStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GotoStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PHPParserVisitor:
		return t.VisitGotoStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PHPParser) GotoStatement() (localctx IGotoStatementContext) {
	this := p
	_ = this

	localctx = NewGotoStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 108, PHPParserRULE_gotoStatement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(890)
		p.Match(PHPParserGoto)
	}
	{
		p.SetState(891)
		p.Identifier()
	}
	{
		p.SetState(892)
		p.Match(PHPParserSemiColon)
	}

	return localctx
}

// IDeclareStatementContext is an interface to support dynamic dispatch.
type IDeclareStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDeclareStatementContext differentiates from other interfaces.
	IsDeclareStatementContext()
}

type DeclareStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDeclareStatementContext() *DeclareStatementContext {
	var p = new(DeclareStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PHPParserRULE_declareStatement
	return p
}

func (*DeclareStatementContext) IsDeclareStatementContext() {}

func NewDeclareStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DeclareStatementContext {
	var p = new(DeclareStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PHPParserRULE_declareStatement

	return p
}

func (s *DeclareStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *DeclareStatementContext) Declare() antlr.TerminalNode {
	return s.GetToken(PHPParserDeclare, 0)
}

func (s *DeclareStatementContext) OpenRoundBracket() antlr.TerminalNode {
	return s.GetToken(PHPParserOpenRoundBracket, 0)
}

func (s *DeclareStatementContext) DeclareList() IDeclareListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDeclareListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDeclareListContext)
}

func (s *DeclareStatementContext) CloseRoundBracket() antlr.TerminalNode {
	return s.GetToken(PHPParserCloseRoundBracket, 0)
}

func (s *DeclareStatementContext) Statement() IStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *DeclareStatementContext) Colon() antlr.TerminalNode {
	return s.GetToken(PHPParserColon, 0)
}

func (s *DeclareStatementContext) InnerStatementList() IInnerStatementListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInnerStatementListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInnerStatementListContext)
}

func (s *DeclareStatementContext) EndDeclare() antlr.TerminalNode {
	return s.GetToken(PHPParserEndDeclare, 0)
}

func (s *DeclareStatementContext) SemiColon() antlr.TerminalNode {
	return s.GetToken(PHPParserSemiColon, 0)
}

func (s *DeclareStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DeclareStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DeclareStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PHPParserVisitor:
		return t.VisitDeclareStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PHPParser) DeclareStatement() (localctx IDeclareStatementContext) {
	this := p
	_ = this

	localctx = NewDeclareStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 110, PHPParserRULE_declareStatement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(894)
		p.Match(PHPParserDeclare)
	}
	{
		p.SetState(895)
		p.Match(PHPParserOpenRoundBracket)
	}
	{
		p.SetState(896)
		p.DeclareList()
	}
	{
		p.SetState(897)
		p.Match(PHPParserCloseRoundBracket)
	}
	p.SetState(904)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case PHPParserHtmlText, PHPParserXmlStart, PHPParserHtmlScriptOpen, PHPParserHtmlStyleOpen, PHPParserHtmlDtd, PHPParserHtmlOpen, PHPParserHtmlClose, PHPParserHtmlSlashClose, PHPParserHtmlSlash, PHPParserHtmlEquals, PHPParserHtmlStartQuoteString, PHPParserHtmlStartDoubleQuoteString, PHPParserHtmlHex, PHPParserHtmlDecimal, PHPParserHtmlName, PHPParserHtmlEndQuoteString, PHPParserHtmlQuoteString, PHPParserHtmlEndDoubleQuoteString, PHPParserHtmlDoubleQuoteString, PHPParserScriptText, PHPParserHtmlScriptClose, PHPParserStyleBody, PHPParserAbstract, PHPParserArray, PHPParserAs, PHPParserBinaryCast, PHPParserBoolType, PHPParserBooleanConstant, PHPParserBreak, PHPParserCallable, PHPParserCase, PHPParserCatch, PHPParserClass, PHPParserClone, PHPParserConst, PHPParserContinue, PHPParserDefine, PHPParserDefined, PHPParserDeclare, PHPParserDefault, PHPParserDo, PHPParserDoubleCast, PHPParserDoubleType, PHPParserEcho, PHPParserElse, PHPParserElseIf, PHPParserEmpty, PHPParserEnum_, PHPParserEndDeclare, PHPParserEndFor, PHPParserEndForeach, PHPParserEndIf, PHPParserEndSwitch, PHPParserEndWhile, PHPParserEval, PHPParserAssert, PHPParserDie, PHPParserExit, PHPParserExtends, PHPParserFinal, PHPParserFinally, PHPParserFloatCast, PHPParserFor, PHPParserForeach, PHPParserFunction_, PHPParserGlobal, PHPParserGoto, PHPParserIf, PHPParserImplements, PHPParserImport, PHPParserInclude, PHPParserIncludeOnce, PHPParserInstanceOf, PHPParserInsteadOf, PHPParserInt8Cast, PHPParserInt16Cast, PHPParserInt64Type, PHPParserIntType, PHPParserInterface, PHPParserIsSet, PHPParserList, PHPParserLogicalAnd, PHPParserLogicalOr, PHPParserLogicalXor, PHPParserMatch_, PHPParserNamespace, PHPParserNew, PHPParserNull, PHPParserObjectType, PHPParserParent_, PHPParserPartial, PHPParserPrint, PHPParserPrivate, PHPParserProtected, PHPParserPublic, PHPParserReadonly, PHPParserRequire, PHPParserRequireOnce, PHPParserResource, PHPParserReturn, PHPParserStatic, PHPParserStringType, PHPParserSwitch, PHPParserThrow, PHPParserTrait, PHPParserTry, PHPParserTypeof, PHPParserUintCast, PHPParserUnicodeCast, PHPParserUnset, PHPParserUse, PHPParserVar, PHPParserWhile, PHPParserYield, PHPParserFrom, PHPParserLambdaFn, PHPParserTicks, PHPParserEncoding, PHPParserStrictTypes, PHPParserGet, PHPParserSet, PHPParserCall, PHPParserCallStatic, PHPParserConstructor, PHPParserDestruct, PHPParserWakeup, PHPParserSleep, PHPParserAutoload, PHPParserIsSet__, PHPParserUnset__, PHPParserToString__, PHPParserInvoke, PHPParserSetState, PHPParserClone__, PHPParserDebugInfo, PHPParserNamespace__, PHPParserClass__, PHPParserTraic__, PHPParserFunction__, PHPParserMethod__, PHPParserLine__, PHPParserFile__, PHPParserDir__, PHPParserInc, PHPParserDec, PHPParserNamespaceSeparator, PHPParserAmpersand, PHPParserBang, PHPParserPlus, PHPParserMinus, PHPParserTilde, PHPParserSuppressWarnings, PHPParserDollar, PHPParserOpenRoundBracket, PHPParserOpenSquareBracket, PHPParserOpenCurlyBracket, PHPParserSemiColon, PHPParserSet_Include_Path, PHPParserVarName, PHPParserLabel, PHPParserOctal, PHPParserDecimal, PHPParserReal, PHPParserHex, PHPParserBinary, PHPParserBackQuoteString, PHPParserSingleQuoteString, PHPParserDoubleQuote, PHPParserStartNowDoc, PHPParserStartHereDoc:
		{
			p.SetState(898)
			p.Statement()
		}

	case PHPParserColon:
		{
			p.SetState(899)
			p.Match(PHPParserColon)
		}
		{
			p.SetState(900)
			p.InnerStatementList()
		}
		{
			p.SetState(901)
			p.Match(PHPParserEndDeclare)
		}
		{
			p.SetState(902)
			p.Match(PHPParserSemiColon)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IInlineHtmlStatementContext is an interface to support dynamic dispatch.
type IInlineHtmlStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInlineHtmlStatementContext differentiates from other interfaces.
	IsInlineHtmlStatementContext()
}

type InlineHtmlStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInlineHtmlStatementContext() *InlineHtmlStatementContext {
	var p = new(InlineHtmlStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PHPParserRULE_inlineHtmlStatement
	return p
}

func (*InlineHtmlStatementContext) IsInlineHtmlStatementContext() {}

func NewInlineHtmlStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InlineHtmlStatementContext {
	var p = new(InlineHtmlStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PHPParserRULE_inlineHtmlStatement

	return p
}

func (s *InlineHtmlStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *InlineHtmlStatementContext) AllInlineHtml() []IInlineHtmlContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IInlineHtmlContext); ok {
			len++
		}
	}

	tst := make([]IInlineHtmlContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IInlineHtmlContext); ok {
			tst[i] = t.(IInlineHtmlContext)
			i++
		}
	}

	return tst
}

func (s *InlineHtmlStatementContext) InlineHtml(i int) IInlineHtmlContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInlineHtmlContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInlineHtmlContext)
}

func (s *InlineHtmlStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InlineHtmlStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InlineHtmlStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PHPParserVisitor:
		return t.VisitInlineHtmlStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PHPParser) InlineHtmlStatement() (localctx IInlineHtmlStatementContext) {
	this := p
	_ = this

	localctx = NewInlineHtmlStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 112, PHPParserRULE_inlineHtmlStatement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(907)
	p.GetErrorHandler().Sync(p)
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			{
				p.SetState(906)
				p.InlineHtml()
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(909)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 85, p.GetParserRuleContext())
	}

	return localctx
}

// IDeclareListContext is an interface to support dynamic dispatch.
type IDeclareListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDeclareListContext differentiates from other interfaces.
	IsDeclareListContext()
}

type DeclareListContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDeclareListContext() *DeclareListContext {
	var p = new(DeclareListContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PHPParserRULE_declareList
	return p
}

func (*DeclareListContext) IsDeclareListContext() {}

func NewDeclareListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DeclareListContext {
	var p = new(DeclareListContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PHPParserRULE_declareList

	return p
}

func (s *DeclareListContext) GetParser() antlr.Parser { return s.parser }

func (s *DeclareListContext) AllDirective() []IDirectiveContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IDirectiveContext); ok {
			len++
		}
	}

	tst := make([]IDirectiveContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IDirectiveContext); ok {
			tst[i] = t.(IDirectiveContext)
			i++
		}
	}

	return tst
}

func (s *DeclareListContext) Directive(i int) IDirectiveContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDirectiveContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDirectiveContext)
}

func (s *DeclareListContext) AllComma() []antlr.TerminalNode {
	return s.GetTokens(PHPParserComma)
}

func (s *DeclareListContext) Comma(i int) antlr.TerminalNode {
	return s.GetToken(PHPParserComma, i)
}

func (s *DeclareListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DeclareListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DeclareListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PHPParserVisitor:
		return t.VisitDeclareList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PHPParser) DeclareList() (localctx IDeclareListContext) {
	this := p
	_ = this

	localctx = NewDeclareListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 114, PHPParserRULE_declareList)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(911)
		p.Directive()
	}
	p.SetState(916)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == PHPParserComma {
		{
			p.SetState(912)
			p.Match(PHPParserComma)
		}
		{
			p.SetState(913)
			p.Directive()
		}

		p.SetState(918)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IDirectiveContext is an interface to support dynamic dispatch.
type IDirectiveContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDirectiveContext differentiates from other interfaces.
	IsDirectiveContext()
}

type DirectiveContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDirectiveContext() *DirectiveContext {
	var p = new(DirectiveContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PHPParserRULE_directive
	return p
}

func (*DirectiveContext) IsDirectiveContext() {}

func NewDirectiveContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DirectiveContext {
	var p = new(DirectiveContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PHPParserRULE_directive

	return p
}

func (s *DirectiveContext) GetParser() antlr.Parser { return s.parser }

func (s *DirectiveContext) Ticks() antlr.TerminalNode {
	return s.GetToken(PHPParserTicks, 0)
}

func (s *DirectiveContext) Eq() antlr.TerminalNode {
	return s.GetToken(PHPParserEq, 0)
}

func (s *DirectiveContext) NumericConstant() INumericConstantContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INumericConstantContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INumericConstantContext)
}

func (s *DirectiveContext) Real() antlr.TerminalNode {
	return s.GetToken(PHPParserReal, 0)
}

func (s *DirectiveContext) Encoding() antlr.TerminalNode {
	return s.GetToken(PHPParserEncoding, 0)
}

func (s *DirectiveContext) SingleQuoteString() antlr.TerminalNode {
	return s.GetToken(PHPParserSingleQuoteString, 0)
}

func (s *DirectiveContext) StrictTypes() antlr.TerminalNode {
	return s.GetToken(PHPParserStrictTypes, 0)
}

func (s *DirectiveContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DirectiveContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DirectiveContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PHPParserVisitor:
		return t.VisitDirective(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PHPParser) Directive() (localctx IDirectiveContext) {
	this := p
	_ = this

	localctx = NewDirectiveContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 116, PHPParserRULE_directive)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(931)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case PHPParserTicks:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(919)
			p.Match(PHPParserTicks)
		}
		{
			p.SetState(920)
			p.Match(PHPParserEq)
		}
		p.SetState(923)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case PHPParserOctal, PHPParserDecimal, PHPParserHex, PHPParserBinary:
			{
				p.SetState(921)
				p.NumericConstant()
			}

		case PHPParserReal:
			{
				p.SetState(922)
				p.Match(PHPParserReal)
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

	case PHPParserEncoding:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(925)
			p.Match(PHPParserEncoding)
		}
		{
			p.SetState(926)
			p.Match(PHPParserEq)
		}
		{
			p.SetState(927)
			p.Match(PHPParserSingleQuoteString)
		}

	case PHPParserStrictTypes:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(928)
			p.Match(PHPParserStrictTypes)
		}
		{
			p.SetState(929)
			p.Match(PHPParserEq)
		}
		{
			p.SetState(930)
			p.NumericConstant()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IFormalParameterListContext is an interface to support dynamic dispatch.
type IFormalParameterListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFormalParameterListContext differentiates from other interfaces.
	IsFormalParameterListContext()
}

type FormalParameterListContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFormalParameterListContext() *FormalParameterListContext {
	var p = new(FormalParameterListContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PHPParserRULE_formalParameterList
	return p
}

func (*FormalParameterListContext) IsFormalParameterListContext() {}

func NewFormalParameterListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FormalParameterListContext {
	var p = new(FormalParameterListContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PHPParserRULE_formalParameterList

	return p
}

func (s *FormalParameterListContext) GetParser() antlr.Parser { return s.parser }

func (s *FormalParameterListContext) AllFormalParameter() []IFormalParameterContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IFormalParameterContext); ok {
			len++
		}
	}

	tst := make([]IFormalParameterContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IFormalParameterContext); ok {
			tst[i] = t.(IFormalParameterContext)
			i++
		}
	}

	return tst
}

func (s *FormalParameterListContext) FormalParameter(i int) IFormalParameterContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFormalParameterContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFormalParameterContext)
}

func (s *FormalParameterListContext) AllComma() []antlr.TerminalNode {
	return s.GetTokens(PHPParserComma)
}

func (s *FormalParameterListContext) Comma(i int) antlr.TerminalNode {
	return s.GetToken(PHPParserComma, i)
}

func (s *FormalParameterListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FormalParameterListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FormalParameterListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PHPParserVisitor:
		return t.VisitFormalParameterList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PHPParser) FormalParameterList() (localctx IFormalParameterListContext) {
	this := p
	_ = this

	localctx = NewFormalParameterListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 118, PHPParserRULE_formalParameterList)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(934)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if (int64((_la-43)) & ^0x3f) == 0 && ((int64(1)<<(_la-43))&-289919354861092865) != 0 || (int64((_la-107)) & ^0x3f) == 0 && ((int64(1)<<(_la-107))&288230376134666239) != 0 || (int64((_la-196)) & ^0x3f) == 0 && ((int64(1)<<(_la-196))&6442582035) != 0 {
		{
			p.SetState(933)
			p.FormalParameter()
		}

	}
	p.SetState(940)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 90, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(936)
				p.Match(PHPParserComma)
			}
			{
				p.SetState(937)
				p.FormalParameter()
			}

		}
		p.SetState(942)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 90, p.GetParserRuleContext())
	}
	p.SetState(944)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == PHPParserComma {
		{
			p.SetState(943)
			p.Match(PHPParserComma)
		}

	}

	return localctx
}

// IFormalParameterContext is an interface to support dynamic dispatch.
type IFormalParameterContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFormalParameterContext differentiates from other interfaces.
	IsFormalParameterContext()
}

type FormalParameterContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFormalParameterContext() *FormalParameterContext {
	var p = new(FormalParameterContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PHPParserRULE_formalParameter
	return p
}

func (*FormalParameterContext) IsFormalParameterContext() {}

func NewFormalParameterContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FormalParameterContext {
	var p = new(FormalParameterContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PHPParserRULE_formalParameter

	return p
}

func (s *FormalParameterContext) GetParser() antlr.Parser { return s.parser }

func (s *FormalParameterContext) VariableInitializer() IVariableInitializerContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVariableInitializerContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVariableInitializerContext)
}

func (s *FormalParameterContext) Attributes() IAttributesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAttributesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAttributesContext)
}

func (s *FormalParameterContext) AllMemberModifier() []IMemberModifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IMemberModifierContext); ok {
			len++
		}
	}

	tst := make([]IMemberModifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IMemberModifierContext); ok {
			tst[i] = t.(IMemberModifierContext)
			i++
		}
	}

	return tst
}

func (s *FormalParameterContext) MemberModifier(i int) IMemberModifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMemberModifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMemberModifierContext)
}

func (s *FormalParameterContext) QuestionMark() antlr.TerminalNode {
	return s.GetToken(PHPParserQuestionMark, 0)
}

func (s *FormalParameterContext) TypeHint() ITypeHintContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeHintContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeHintContext)
}

func (s *FormalParameterContext) Ampersand() antlr.TerminalNode {
	return s.GetToken(PHPParserAmpersand, 0)
}

func (s *FormalParameterContext) Ellipsis() antlr.TerminalNode {
	return s.GetToken(PHPParserEllipsis, 0)
}

func (s *FormalParameterContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FormalParameterContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FormalParameterContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PHPParserVisitor:
		return t.VisitFormalParameter(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PHPParser) FormalParameter() (localctx IFormalParameterContext) {
	this := p
	_ = this

	localctx = NewFormalParameterContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 120, PHPParserRULE_formalParameter)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(947)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == PHPParserAttributeStart {
		{
			p.SetState(946)
			p.Attributes()
		}

	}
	p.SetState(952)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 93, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(949)
				p.MemberModifier()
			}

		}
		p.SetState(954)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 93, p.GetParserRuleContext())
	}
	p.SetState(956)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == PHPParserQuestionMark {
		{
			p.SetState(955)
			p.Match(PHPParserQuestionMark)
		}

	}
	p.SetState(959)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if (int64((_la-44)) & ^0x3f) == 0 && ((int64(1)<<(_la-44))&-144959677430546433) != 0 || (int64((_la-108)) & ^0x3f) == 0 && ((int64(1)<<(_la-108))&144115188067333119) != 0 || _la == PHPParserNamespaceSeparator || _la == PHPParserLabel {
		{
			p.SetState(958)
			p.typeHint(0)
		}

	}
	p.SetState(962)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == PHPParserAmpersand {
		{
			p.SetState(961)
			p.Match(PHPParserAmpersand)
		}

	}
	p.SetState(965)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == PHPParserEllipsis {
		{
			p.SetState(964)
			p.Match(PHPParserEllipsis)
		}

	}
	{
		p.SetState(967)
		p.VariableInitializer()
	}

	return localctx
}

// ITypeHintContext is an interface to support dynamic dispatch.
type ITypeHintContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTypeHintContext differentiates from other interfaces.
	IsTypeHintContext()
}

type TypeHintContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeHintContext() *TypeHintContext {
	var p = new(TypeHintContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PHPParserRULE_typeHint
	return p
}

func (*TypeHintContext) IsTypeHintContext() {}

func NewTypeHintContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeHintContext {
	var p = new(TypeHintContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PHPParserRULE_typeHint

	return p
}

func (s *TypeHintContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeHintContext) Callable() antlr.TerminalNode {
	return s.GetToken(PHPParserCallable, 0)
}

func (s *TypeHintContext) PrimitiveType() IPrimitiveTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrimitiveTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrimitiveTypeContext)
}

func (s *TypeHintContext) QualifiedStaticTypeRef() IQualifiedStaticTypeRefContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedStaticTypeRefContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedStaticTypeRefContext)
}

func (s *TypeHintContext) AllTypeHint() []ITypeHintContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITypeHintContext); ok {
			len++
		}
	}

	tst := make([]ITypeHintContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITypeHintContext); ok {
			tst[i] = t.(ITypeHintContext)
			i++
		}
	}

	return tst
}

func (s *TypeHintContext) TypeHint(i int) ITypeHintContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeHintContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeHintContext)
}

func (s *TypeHintContext) Pipe() antlr.TerminalNode {
	return s.GetToken(PHPParserPipe, 0)
}

func (s *TypeHintContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeHintContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeHintContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PHPParserVisitor:
		return t.VisitTypeHint(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PHPParser) TypeHint() (localctx ITypeHintContext) {
	return p.typeHint(0)
}

func (p *PHPParser) typeHint(_p int) (localctx ITypeHintContext) {
	this := p
	_ = this

	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()
	_parentState := p.GetState()
	localctx = NewTypeHintContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx ITypeHintContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 122
	p.EnterRecursionRule(localctx, 122, PHPParserRULE_typeHint, _p)

	defer func() {
		p.UnrollRecursionContexts(_parentctx)
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(973)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 98, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(970)
			p.Match(PHPParserCallable)
		}

	case 2:
		{
			p.SetState(971)
			p.PrimitiveType()
		}

	case 3:
		{
			p.SetState(972)
			p.QualifiedStaticTypeRef()
		}

	}
	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(980)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 99, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			localctx = NewTypeHintContext(p, _parentctx, _parentState)
			p.PushNewRecursionContext(localctx, _startState, PHPParserRULE_typeHint)
			p.SetState(975)

			if !(p.Precpred(p.GetParserRuleContext(), 1)) {
				panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 1)", ""))
			}
			{
				p.SetState(976)
				p.Match(PHPParserPipe)
			}
			{
				p.SetState(977)
				p.typeHint(2)
			}

		}
		p.SetState(982)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 99, p.GetParserRuleContext())
	}

	return localctx
}

// IGlobalStatementContext is an interface to support dynamic dispatch.
type IGlobalStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsGlobalStatementContext differentiates from other interfaces.
	IsGlobalStatementContext()
}

type GlobalStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGlobalStatementContext() *GlobalStatementContext {
	var p = new(GlobalStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PHPParserRULE_globalStatement
	return p
}

func (*GlobalStatementContext) IsGlobalStatementContext() {}

func NewGlobalStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GlobalStatementContext {
	var p = new(GlobalStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PHPParserRULE_globalStatement

	return p
}

func (s *GlobalStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *GlobalStatementContext) Global() antlr.TerminalNode {
	return s.GetToken(PHPParserGlobal, 0)
}

func (s *GlobalStatementContext) AllGlobalVar() []IGlobalVarContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IGlobalVarContext); ok {
			len++
		}
	}

	tst := make([]IGlobalVarContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IGlobalVarContext); ok {
			tst[i] = t.(IGlobalVarContext)
			i++
		}
	}

	return tst
}

func (s *GlobalStatementContext) GlobalVar(i int) IGlobalVarContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGlobalVarContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGlobalVarContext)
}

func (s *GlobalStatementContext) SemiColon() antlr.TerminalNode {
	return s.GetToken(PHPParserSemiColon, 0)
}

func (s *GlobalStatementContext) AllComma() []antlr.TerminalNode {
	return s.GetTokens(PHPParserComma)
}

func (s *GlobalStatementContext) Comma(i int) antlr.TerminalNode {
	return s.GetToken(PHPParserComma, i)
}

func (s *GlobalStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GlobalStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GlobalStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PHPParserVisitor:
		return t.VisitGlobalStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PHPParser) GlobalStatement() (localctx IGlobalStatementContext) {
	this := p
	_ = this

	localctx = NewGlobalStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 124, PHPParserRULE_globalStatement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(983)
		p.Match(PHPParserGlobal)
	}
	{
		p.SetState(984)
		p.GlobalVar()
	}
	p.SetState(989)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == PHPParserComma {
		{
			p.SetState(985)
			p.Match(PHPParserComma)
		}
		{
			p.SetState(986)
			p.GlobalVar()
		}

		p.SetState(991)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(992)
		p.Match(PHPParserSemiColon)
	}

	return localctx
}

// IGlobalVarContext is an interface to support dynamic dispatch.
type IGlobalVarContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsGlobalVarContext differentiates from other interfaces.
	IsGlobalVarContext()
}

type GlobalVarContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGlobalVarContext() *GlobalVarContext {
	var p = new(GlobalVarContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PHPParserRULE_globalVar
	return p
}

func (*GlobalVarContext) IsGlobalVarContext() {}

func NewGlobalVarContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GlobalVarContext {
	var p = new(GlobalVarContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PHPParserRULE_globalVar

	return p
}

func (s *GlobalVarContext) GetParser() antlr.Parser { return s.parser }

func (s *GlobalVarContext) VarName() antlr.TerminalNode {
	return s.GetToken(PHPParserVarName, 0)
}

func (s *GlobalVarContext) Dollar() antlr.TerminalNode {
	return s.GetToken(PHPParserDollar, 0)
}

func (s *GlobalVarContext) Chain() IChainContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IChainContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IChainContext)
}

func (s *GlobalVarContext) OpenCurlyBracket() antlr.TerminalNode {
	return s.GetToken(PHPParserOpenCurlyBracket, 0)
}

func (s *GlobalVarContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *GlobalVarContext) CloseCurlyBracket() antlr.TerminalNode {
	return s.GetToken(PHPParserCloseCurlyBracket, 0)
}

func (s *GlobalVarContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GlobalVarContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GlobalVarContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PHPParserVisitor:
		return t.VisitGlobalVar(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PHPParser) GlobalVar() (localctx IGlobalVarContext) {
	this := p
	_ = this

	localctx = NewGlobalVarContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 126, PHPParserRULE_globalVar)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1002)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 101, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(994)
			p.Match(PHPParserVarName)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(995)
			p.Match(PHPParserDollar)
		}
		{
			p.SetState(996)
			p.Chain()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(997)
			p.Match(PHPParserDollar)
		}
		{
			p.SetState(998)
			p.Match(PHPParserOpenCurlyBracket)
		}
		{
			p.SetState(999)
			p.expression(0)
		}
		{
			p.SetState(1000)
			p.Match(PHPParserCloseCurlyBracket)
		}

	}

	return localctx
}

// IEchoStatementContext is an interface to support dynamic dispatch.
type IEchoStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEchoStatementContext differentiates from other interfaces.
	IsEchoStatementContext()
}

type EchoStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEchoStatementContext() *EchoStatementContext {
	var p = new(EchoStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PHPParserRULE_echoStatement
	return p
}

func (*EchoStatementContext) IsEchoStatementContext() {}

func NewEchoStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EchoStatementContext {
	var p = new(EchoStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PHPParserRULE_echoStatement

	return p
}

func (s *EchoStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *EchoStatementContext) Echo() antlr.TerminalNode {
	return s.GetToken(PHPParserEcho, 0)
}

func (s *EchoStatementContext) ExpressionList() IExpressionListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionListContext)
}

func (s *EchoStatementContext) SemiColon() antlr.TerminalNode {
	return s.GetToken(PHPParserSemiColon, 0)
}

func (s *EchoStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EchoStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EchoStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PHPParserVisitor:
		return t.VisitEchoStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PHPParser) EchoStatement() (localctx IEchoStatementContext) {
	this := p
	_ = this

	localctx = NewEchoStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 128, PHPParserRULE_echoStatement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1004)
		p.Match(PHPParserEcho)
	}
	{
		p.SetState(1005)
		p.ExpressionList()
	}
	{
		p.SetState(1006)
		p.Match(PHPParserSemiColon)
	}

	return localctx
}

// IStaticVariableStatementContext is an interface to support dynamic dispatch.
type IStaticVariableStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsStaticVariableStatementContext differentiates from other interfaces.
	IsStaticVariableStatementContext()
}

type StaticVariableStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStaticVariableStatementContext() *StaticVariableStatementContext {
	var p = new(StaticVariableStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PHPParserRULE_staticVariableStatement
	return p
}

func (*StaticVariableStatementContext) IsStaticVariableStatementContext() {}

func NewStaticVariableStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StaticVariableStatementContext {
	var p = new(StaticVariableStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PHPParserRULE_staticVariableStatement

	return p
}

func (s *StaticVariableStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *StaticVariableStatementContext) Static() antlr.TerminalNode {
	return s.GetToken(PHPParserStatic, 0)
}

func (s *StaticVariableStatementContext) AllVariableInitializer() []IVariableInitializerContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IVariableInitializerContext); ok {
			len++
		}
	}

	tst := make([]IVariableInitializerContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IVariableInitializerContext); ok {
			tst[i] = t.(IVariableInitializerContext)
			i++
		}
	}

	return tst
}

func (s *StaticVariableStatementContext) VariableInitializer(i int) IVariableInitializerContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVariableInitializerContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVariableInitializerContext)
}

func (s *StaticVariableStatementContext) SemiColon() antlr.TerminalNode {
	return s.GetToken(PHPParserSemiColon, 0)
}

func (s *StaticVariableStatementContext) AllComma() []antlr.TerminalNode {
	return s.GetTokens(PHPParserComma)
}

func (s *StaticVariableStatementContext) Comma(i int) antlr.TerminalNode {
	return s.GetToken(PHPParserComma, i)
}

func (s *StaticVariableStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StaticVariableStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StaticVariableStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PHPParserVisitor:
		return t.VisitStaticVariableStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PHPParser) StaticVariableStatement() (localctx IStaticVariableStatementContext) {
	this := p
	_ = this

	localctx = NewStaticVariableStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 130, PHPParserRULE_staticVariableStatement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1008)
		p.Match(PHPParserStatic)
	}
	{
		p.SetState(1009)
		p.VariableInitializer()
	}
	p.SetState(1014)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == PHPParserComma {
		{
			p.SetState(1010)
			p.Match(PHPParserComma)
		}
		{
			p.SetState(1011)
			p.VariableInitializer()
		}

		p.SetState(1016)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1017)
		p.Match(PHPParserSemiColon)
	}

	return localctx
}

// IClassStatementContext is an interface to support dynamic dispatch.
type IClassStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsClassStatementContext differentiates from other interfaces.
	IsClassStatementContext()
}

type ClassStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyClassStatementContext() *ClassStatementContext {
	var p = new(ClassStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PHPParserRULE_classStatement
	return p
}

func (*ClassStatementContext) IsClassStatementContext() {}

func NewClassStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ClassStatementContext {
	var p = new(ClassStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PHPParserRULE_classStatement

	return p
}

func (s *ClassStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ClassStatementContext) CopyFrom(ctx *ClassStatementContext) {
	s.BaseParserRuleContext.CopyFrom(ctx.BaseParserRuleContext)
}

func (s *ClassStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ClassStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type FunctionContext struct {
	*ClassStatementContext
}

func NewFunctionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *FunctionContext {
	var p = new(FunctionContext)

	p.ClassStatementContext = NewEmptyClassStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ClassStatementContext))

	return p
}

func (s *FunctionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FunctionContext) Function_() antlr.TerminalNode {
	return s.GetToken(PHPParserFunction_, 0)
}

func (s *FunctionContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *FunctionContext) OpenRoundBracket() antlr.TerminalNode {
	return s.GetToken(PHPParserOpenRoundBracket, 0)
}

func (s *FunctionContext) FormalParameterList() IFormalParameterListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFormalParameterListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFormalParameterListContext)
}

func (s *FunctionContext) CloseRoundBracket() antlr.TerminalNode {
	return s.GetToken(PHPParserCloseRoundBracket, 0)
}

func (s *FunctionContext) MethodBody() IMethodBodyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMethodBodyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMethodBodyContext)
}

func (s *FunctionContext) Attributes() IAttributesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAttributesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAttributesContext)
}

func (s *FunctionContext) MemberModifiers() IMemberModifiersContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMemberModifiersContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMemberModifiersContext)
}

func (s *FunctionContext) Ampersand() antlr.TerminalNode {
	return s.GetToken(PHPParserAmpersand, 0)
}

func (s *FunctionContext) BaseCtorCall() IBaseCtorCallContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBaseCtorCallContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBaseCtorCallContext)
}

func (s *FunctionContext) ReturnTypeDecl() IReturnTypeDeclContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReturnTypeDeclContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReturnTypeDeclContext)
}

func (s *FunctionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PHPParserVisitor:
		return t.VisitFunction(s)

	default:
		return t.VisitChildren(s)
	}
}

type TraitUseContext struct {
	*ClassStatementContext
}

func NewTraitUseContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TraitUseContext {
	var p = new(TraitUseContext)

	p.ClassStatementContext = NewEmptyClassStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ClassStatementContext))

	return p
}

func (s *TraitUseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TraitUseContext) Use() antlr.TerminalNode {
	return s.GetToken(PHPParserUse, 0)
}

func (s *TraitUseContext) QualifiedNamespaceNameList() IQualifiedNamespaceNameListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNamespaceNameListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNamespaceNameListContext)
}

func (s *TraitUseContext) TraitAdaptations() ITraitAdaptationsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITraitAdaptationsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITraitAdaptationsContext)
}

func (s *TraitUseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PHPParserVisitor:
		return t.VisitTraitUse(s)

	default:
		return t.VisitChildren(s)
	}
}

type ConstContext struct {
	*ClassStatementContext
}

func NewConstContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ConstContext {
	var p = new(ConstContext)

	p.ClassStatementContext = NewEmptyClassStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ClassStatementContext))

	return p
}

func (s *ConstContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ConstContext) Const() antlr.TerminalNode {
	return s.GetToken(PHPParserConst, 0)
}

func (s *ConstContext) AllIdentifierInitializer() []IIdentifierInitializerContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierInitializerContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierInitializerContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierInitializerContext); ok {
			tst[i] = t.(IIdentifierInitializerContext)
			i++
		}
	}

	return tst
}

func (s *ConstContext) IdentifierInitializer(i int) IIdentifierInitializerContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierInitializerContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierInitializerContext)
}

func (s *ConstContext) SemiColon() antlr.TerminalNode {
	return s.GetToken(PHPParserSemiColon, 0)
}

func (s *ConstContext) Attributes() IAttributesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAttributesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAttributesContext)
}

func (s *ConstContext) MemberModifiers() IMemberModifiersContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMemberModifiersContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMemberModifiersContext)
}

func (s *ConstContext) TypeHint() ITypeHintContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeHintContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeHintContext)
}

func (s *ConstContext) AllComma() []antlr.TerminalNode {
	return s.GetTokens(PHPParserComma)
}

func (s *ConstContext) Comma(i int) antlr.TerminalNode {
	return s.GetToken(PHPParserComma, i)
}

func (s *ConstContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PHPParserVisitor:
		return t.VisitConst(s)

	default:
		return t.VisitChildren(s)
	}
}

type PropertyModifiersVariableContext struct {
	*ClassStatementContext
}

func NewPropertyModifiersVariableContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *PropertyModifiersVariableContext {
	var p = new(PropertyModifiersVariableContext)

	p.ClassStatementContext = NewEmptyClassStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ClassStatementContext))

	return p
}

func (s *PropertyModifiersVariableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PropertyModifiersVariableContext) PropertyModifiers() IPropertyModifiersContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyModifiersContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyModifiersContext)
}

func (s *PropertyModifiersVariableContext) AllVariableInitializer() []IVariableInitializerContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IVariableInitializerContext); ok {
			len++
		}
	}

	tst := make([]IVariableInitializerContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IVariableInitializerContext); ok {
			tst[i] = t.(IVariableInitializerContext)
			i++
		}
	}

	return tst
}

func (s *PropertyModifiersVariableContext) VariableInitializer(i int) IVariableInitializerContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVariableInitializerContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVariableInitializerContext)
}

func (s *PropertyModifiersVariableContext) SemiColon() antlr.TerminalNode {
	return s.GetToken(PHPParserSemiColon, 0)
}

func (s *PropertyModifiersVariableContext) Attributes() IAttributesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAttributesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAttributesContext)
}

func (s *PropertyModifiersVariableContext) TypeHint() ITypeHintContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeHintContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeHintContext)
}

func (s *PropertyModifiersVariableContext) AllComma() []antlr.TerminalNode {
	return s.GetTokens(PHPParserComma)
}

func (s *PropertyModifiersVariableContext) Comma(i int) antlr.TerminalNode {
	return s.GetToken(PHPParserComma, i)
}

func (s *PropertyModifiersVariableContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PHPParserVisitor:
		return t.VisitPropertyModifiersVariable(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PHPParser) ClassStatement() (localctx IClassStatementContext) {
	this := p
	_ = this

	localctx = NewClassStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 132, PHPParserRULE_classStatement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1080)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 114, p.GetParserRuleContext()) {
	case 1:
		localctx = NewTraitUseContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1019)
			p.Match(PHPParserUse)
		}
		{
			p.SetState(1020)
			p.QualifiedNamespaceNameList()
		}
		{
			p.SetState(1021)
			p.TraitAdaptations()
		}

	case 2:
		localctx = NewPropertyModifiersVariableContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		p.SetState(1024)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == PHPParserAttributeStart {
			{
				p.SetState(1023)
				p.Attributes()
			}

		}
		{
			p.SetState(1026)
			p.PropertyModifiers()
		}
		p.SetState(1028)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if (int64((_la-44)) & ^0x3f) == 0 && ((int64(1)<<(_la-44))&-144959677430546433) != 0 || (int64((_la-108)) & ^0x3f) == 0 && ((int64(1)<<(_la-108))&144115188067333119) != 0 || _la == PHPParserNamespaceSeparator || _la == PHPParserLabel {
			{
				p.SetState(1027)
				p.typeHint(0)
			}

		}
		{
			p.SetState(1030)
			p.VariableInitializer()
		}
		p.SetState(1035)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == PHPParserComma {
			{
				p.SetState(1031)
				p.Match(PHPParserComma)
			}
			{
				p.SetState(1032)
				p.VariableInitializer()
			}

			p.SetState(1037)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1038)
			p.Match(PHPParserSemiColon)
		}

	case 3:
		localctx = NewConstContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		p.SetState(1041)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == PHPParserAttributeStart {
			{
				p.SetState(1040)
				p.Attributes()
			}

		}
		p.SetState(1044)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == PHPParserAbstract || (int64((_la-81)) & ^0x3f) == 0 && ((int64(1)<<(_la-81))&2327872274433) != 0 {
			{
				p.SetState(1043)
				p.MemberModifiers()
			}

		}
		{
			p.SetState(1046)
			p.Match(PHPParserConst)
		}
		p.SetState(1048)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 108, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1047)
				p.typeHint(0)
			}

		}
		{
			p.SetState(1050)
			p.IdentifierInitializer()
		}
		p.SetState(1055)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == PHPParserComma {
			{
				p.SetState(1051)
				p.Match(PHPParserComma)
			}
			{
				p.SetState(1052)
				p.IdentifierInitializer()
			}

			p.SetState(1057)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1058)
			p.Match(PHPParserSemiColon)
		}

	case 4:
		localctx = NewFunctionContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		p.SetState(1061)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == PHPParserAttributeStart {
			{
				p.SetState(1060)
				p.Attributes()
			}

		}
		p.SetState(1064)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == PHPParserAbstract || (int64((_la-81)) & ^0x3f) == 0 && ((int64(1)<<(_la-81))&2327872274433) != 0 {
			{
				p.SetState(1063)
				p.MemberModifiers()
			}

		}
		{
			p.SetState(1066)
			p.Match(PHPParserFunction_)
		}
		p.SetState(1068)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == PHPParserAmpersand {
			{
				p.SetState(1067)
				p.Match(PHPParserAmpersand)
			}

		}
		{
			p.SetState(1070)
			p.Identifier()
		}
		{
			p.SetState(1071)
			p.Match(PHPParserOpenRoundBracket)
		}
		{
			p.SetState(1072)
			p.FormalParameterList()
		}
		{
			p.SetState(1073)
			p.Match(PHPParserCloseRoundBracket)
		}
		p.SetState(1076)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 113, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1074)
				p.BaseCtorCall()
			}

		} else if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 113, p.GetParserRuleContext()) == 2 {
			{
				p.SetState(1075)
				p.ReturnTypeDecl()
			}

		}
		{
			p.SetState(1078)
			p.MethodBody()
		}

	}

	return localctx
}

// ITraitAdaptationsContext is an interface to support dynamic dispatch.
type ITraitAdaptationsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTraitAdaptationsContext differentiates from other interfaces.
	IsTraitAdaptationsContext()
}

type TraitAdaptationsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTraitAdaptationsContext() *TraitAdaptationsContext {
	var p = new(TraitAdaptationsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PHPParserRULE_traitAdaptations
	return p
}

func (*TraitAdaptationsContext) IsTraitAdaptationsContext() {}

func NewTraitAdaptationsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TraitAdaptationsContext {
	var p = new(TraitAdaptationsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PHPParserRULE_traitAdaptations

	return p
}

func (s *TraitAdaptationsContext) GetParser() antlr.Parser { return s.parser }

func (s *TraitAdaptationsContext) SemiColon() antlr.TerminalNode {
	return s.GetToken(PHPParserSemiColon, 0)
}

func (s *TraitAdaptationsContext) OpenCurlyBracket() antlr.TerminalNode {
	return s.GetToken(PHPParserOpenCurlyBracket, 0)
}

func (s *TraitAdaptationsContext) CloseCurlyBracket() antlr.TerminalNode {
	return s.GetToken(PHPParserCloseCurlyBracket, 0)
}

func (s *TraitAdaptationsContext) AllTraitAdaptationStatement() []ITraitAdaptationStatementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITraitAdaptationStatementContext); ok {
			len++
		}
	}

	tst := make([]ITraitAdaptationStatementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITraitAdaptationStatementContext); ok {
			tst[i] = t.(ITraitAdaptationStatementContext)
			i++
		}
	}

	return tst
}

func (s *TraitAdaptationsContext) TraitAdaptationStatement(i int) ITraitAdaptationStatementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITraitAdaptationStatementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITraitAdaptationStatementContext)
}

func (s *TraitAdaptationsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TraitAdaptationsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TraitAdaptationsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PHPParserVisitor:
		return t.VisitTraitAdaptations(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PHPParser) TraitAdaptations() (localctx ITraitAdaptationsContext) {
	this := p
	_ = this

	localctx = NewTraitAdaptationsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 134, PHPParserRULE_traitAdaptations)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1091)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case PHPParserSemiColon:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1082)
			p.Match(PHPParserSemiColon)
		}

	case PHPParserOpenCurlyBracket:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1083)
			p.Match(PHPParserOpenCurlyBracket)
		}
		p.SetState(1087)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for (int64((_la-44)) & ^0x3f) == 0 && ((int64(1)<<(_la-44))&-144959677430546433) != 0 || (int64((_la-108)) & ^0x3f) == 0 && ((int64(1)<<(_la-108))&144115188067333119) != 0 || _la == PHPParserNamespaceSeparator || _la == PHPParserLabel {
			{
				p.SetState(1084)
				p.TraitAdaptationStatement()
			}

			p.SetState(1089)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1090)
			p.Match(PHPParserCloseCurlyBracket)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ITraitAdaptationStatementContext is an interface to support dynamic dispatch.
type ITraitAdaptationStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTraitAdaptationStatementContext differentiates from other interfaces.
	IsTraitAdaptationStatementContext()
}

type TraitAdaptationStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTraitAdaptationStatementContext() *TraitAdaptationStatementContext {
	var p = new(TraitAdaptationStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PHPParserRULE_traitAdaptationStatement
	return p
}

func (*TraitAdaptationStatementContext) IsTraitAdaptationStatementContext() {}

func NewTraitAdaptationStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TraitAdaptationStatementContext {
	var p = new(TraitAdaptationStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PHPParserRULE_traitAdaptationStatement

	return p
}

func (s *TraitAdaptationStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *TraitAdaptationStatementContext) TraitPrecedence() ITraitPrecedenceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITraitPrecedenceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITraitPrecedenceContext)
}

func (s *TraitAdaptationStatementContext) TraitAlias() ITraitAliasContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITraitAliasContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITraitAliasContext)
}

func (s *TraitAdaptationStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TraitAdaptationStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TraitAdaptationStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PHPParserVisitor:
		return t.VisitTraitAdaptationStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PHPParser) TraitAdaptationStatement() (localctx ITraitAdaptationStatementContext) {
	this := p
	_ = this

	localctx = NewTraitAdaptationStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 136, PHPParserRULE_traitAdaptationStatement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1095)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 117, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1093)
			p.TraitPrecedence()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1094)
			p.TraitAlias()
		}

	}

	return localctx
}

// ITraitPrecedenceContext is an interface to support dynamic dispatch.
type ITraitPrecedenceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTraitPrecedenceContext differentiates from other interfaces.
	IsTraitPrecedenceContext()
}

type TraitPrecedenceContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTraitPrecedenceContext() *TraitPrecedenceContext {
	var p = new(TraitPrecedenceContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PHPParserRULE_traitPrecedence
	return p
}

func (*TraitPrecedenceContext) IsTraitPrecedenceContext() {}

func NewTraitPrecedenceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TraitPrecedenceContext {
	var p = new(TraitPrecedenceContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PHPParserRULE_traitPrecedence

	return p
}

func (s *TraitPrecedenceContext) GetParser() antlr.Parser { return s.parser }

func (s *TraitPrecedenceContext) QualifiedNamespaceName() IQualifiedNamespaceNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNamespaceNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNamespaceNameContext)
}

func (s *TraitPrecedenceContext) DoubleColon() antlr.TerminalNode {
	return s.GetToken(PHPParserDoubleColon, 0)
}

func (s *TraitPrecedenceContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *TraitPrecedenceContext) InsteadOf() antlr.TerminalNode {
	return s.GetToken(PHPParserInsteadOf, 0)
}

func (s *TraitPrecedenceContext) QualifiedNamespaceNameList() IQualifiedNamespaceNameListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNamespaceNameListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNamespaceNameListContext)
}

func (s *TraitPrecedenceContext) SemiColon() antlr.TerminalNode {
	return s.GetToken(PHPParserSemiColon, 0)
}

func (s *TraitPrecedenceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TraitPrecedenceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TraitPrecedenceContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PHPParserVisitor:
		return t.VisitTraitPrecedence(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PHPParser) TraitPrecedence() (localctx ITraitPrecedenceContext) {
	this := p
	_ = this

	localctx = NewTraitPrecedenceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 138, PHPParserRULE_traitPrecedence)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1097)
		p.QualifiedNamespaceName()
	}
	{
		p.SetState(1098)
		p.Match(PHPParserDoubleColon)
	}
	{
		p.SetState(1099)
		p.Identifier()
	}
	{
		p.SetState(1100)
		p.Match(PHPParserInsteadOf)
	}
	{
		p.SetState(1101)
		p.QualifiedNamespaceNameList()
	}
	{
		p.SetState(1102)
		p.Match(PHPParserSemiColon)
	}

	return localctx
}

// ITraitAliasContext is an interface to support dynamic dispatch.
type ITraitAliasContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTraitAliasContext differentiates from other interfaces.
	IsTraitAliasContext()
}

type TraitAliasContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTraitAliasContext() *TraitAliasContext {
	var p = new(TraitAliasContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PHPParserRULE_traitAlias
	return p
}

func (*TraitAliasContext) IsTraitAliasContext() {}

func NewTraitAliasContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TraitAliasContext {
	var p = new(TraitAliasContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PHPParserRULE_traitAlias

	return p
}

func (s *TraitAliasContext) GetParser() antlr.Parser { return s.parser }

func (s *TraitAliasContext) TraitMethodReference() ITraitMethodReferenceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITraitMethodReferenceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITraitMethodReferenceContext)
}

func (s *TraitAliasContext) As() antlr.TerminalNode {
	return s.GetToken(PHPParserAs, 0)
}

func (s *TraitAliasContext) SemiColon() antlr.TerminalNode {
	return s.GetToken(PHPParserSemiColon, 0)
}

func (s *TraitAliasContext) MemberModifier() IMemberModifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMemberModifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMemberModifierContext)
}

func (s *TraitAliasContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *TraitAliasContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TraitAliasContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TraitAliasContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PHPParserVisitor:
		return t.VisitTraitAlias(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PHPParser) TraitAlias() (localctx ITraitAliasContext) {
	this := p
	_ = this

	localctx = NewTraitAliasContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 140, PHPParserRULE_traitAlias)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1104)
		p.TraitMethodReference()
	}
	{
		p.SetState(1105)
		p.Match(PHPParserAs)
	}
	p.SetState(1111)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 119, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(1106)
			p.MemberModifier()
		}

	case 2:
		p.SetState(1108)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 118, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1107)
				p.MemberModifier()
			}

		}
		{
			p.SetState(1110)
			p.Identifier()
		}

	}
	{
		p.SetState(1113)
		p.Match(PHPParserSemiColon)
	}

	return localctx
}

// ITraitMethodReferenceContext is an interface to support dynamic dispatch.
type ITraitMethodReferenceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTraitMethodReferenceContext differentiates from other interfaces.
	IsTraitMethodReferenceContext()
}

type TraitMethodReferenceContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTraitMethodReferenceContext() *TraitMethodReferenceContext {
	var p = new(TraitMethodReferenceContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PHPParserRULE_traitMethodReference
	return p
}

func (*TraitMethodReferenceContext) IsTraitMethodReferenceContext() {}

func NewTraitMethodReferenceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TraitMethodReferenceContext {
	var p = new(TraitMethodReferenceContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PHPParserRULE_traitMethodReference

	return p
}

func (s *TraitMethodReferenceContext) GetParser() antlr.Parser { return s.parser }

func (s *TraitMethodReferenceContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *TraitMethodReferenceContext) QualifiedNamespaceName() IQualifiedNamespaceNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNamespaceNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNamespaceNameContext)
}

func (s *TraitMethodReferenceContext) DoubleColon() antlr.TerminalNode {
	return s.GetToken(PHPParserDoubleColon, 0)
}

func (s *TraitMethodReferenceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TraitMethodReferenceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TraitMethodReferenceContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PHPParserVisitor:
		return t.VisitTraitMethodReference(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PHPParser) TraitMethodReference() (localctx ITraitMethodReferenceContext) {
	this := p
	_ = this

	localctx = NewTraitMethodReferenceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 142, PHPParserRULE_traitMethodReference)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1118)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 120, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1115)
			p.QualifiedNamespaceName()
		}
		{
			p.SetState(1116)
			p.Match(PHPParserDoubleColon)
		}

	}
	{
		p.SetState(1120)
		p.Identifier()
	}

	return localctx
}

// IBaseCtorCallContext is an interface to support dynamic dispatch.
type IBaseCtorCallContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsBaseCtorCallContext differentiates from other interfaces.
	IsBaseCtorCallContext()
}

type BaseCtorCallContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBaseCtorCallContext() *BaseCtorCallContext {
	var p = new(BaseCtorCallContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PHPParserRULE_baseCtorCall
	return p
}

func (*BaseCtorCallContext) IsBaseCtorCallContext() {}

func NewBaseCtorCallContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BaseCtorCallContext {
	var p = new(BaseCtorCallContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PHPParserRULE_baseCtorCall

	return p
}

func (s *BaseCtorCallContext) GetParser() antlr.Parser { return s.parser }

func (s *BaseCtorCallContext) Colon() antlr.TerminalNode {
	return s.GetToken(PHPParserColon, 0)
}

func (s *BaseCtorCallContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *BaseCtorCallContext) Arguments() IArgumentsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArgumentsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArgumentsContext)
}

func (s *BaseCtorCallContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BaseCtorCallContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BaseCtorCallContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PHPParserVisitor:
		return t.VisitBaseCtorCall(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PHPParser) BaseCtorCall() (localctx IBaseCtorCallContext) {
	this := p
	_ = this

	localctx = NewBaseCtorCallContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 144, PHPParserRULE_baseCtorCall)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1122)
		p.Match(PHPParserColon)
	}
	{
		p.SetState(1123)
		p.Identifier()
	}
	p.SetState(1125)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == PHPParserOpenRoundBracket {
		{
			p.SetState(1124)
			p.Arguments()
		}

	}

	return localctx
}

// IReturnTypeDeclContext is an interface to support dynamic dispatch.
type IReturnTypeDeclContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsReturnTypeDeclContext differentiates from other interfaces.
	IsReturnTypeDeclContext()
}

type ReturnTypeDeclContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReturnTypeDeclContext() *ReturnTypeDeclContext {
	var p = new(ReturnTypeDeclContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PHPParserRULE_returnTypeDecl
	return p
}

func (*ReturnTypeDeclContext) IsReturnTypeDeclContext() {}

func NewReturnTypeDeclContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReturnTypeDeclContext {
	var p = new(ReturnTypeDeclContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PHPParserRULE_returnTypeDecl

	return p
}

func (s *ReturnTypeDeclContext) GetParser() antlr.Parser { return s.parser }

func (s *ReturnTypeDeclContext) Colon() antlr.TerminalNode {
	return s.GetToken(PHPParserColon, 0)
}

func (s *ReturnTypeDeclContext) TypeHint() ITypeHintContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeHintContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeHintContext)
}

func (s *ReturnTypeDeclContext) QuestionMark() antlr.TerminalNode {
	return s.GetToken(PHPParserQuestionMark, 0)
}

func (s *ReturnTypeDeclContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReturnTypeDeclContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReturnTypeDeclContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PHPParserVisitor:
		return t.VisitReturnTypeDecl(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PHPParser) ReturnTypeDecl() (localctx IReturnTypeDeclContext) {
	this := p
	_ = this

	localctx = NewReturnTypeDeclContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 146, PHPParserRULE_returnTypeDecl)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1127)
		p.Match(PHPParserColon)
	}
	p.SetState(1129)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == PHPParserQuestionMark {
		{
			p.SetState(1128)
			p.Match(PHPParserQuestionMark)
		}

	}
	{
		p.SetState(1131)
		p.typeHint(0)
	}

	return localctx
}

// IMethodBodyContext is an interface to support dynamic dispatch.
type IMethodBodyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMethodBodyContext differentiates from other interfaces.
	IsMethodBodyContext()
}

type MethodBodyContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMethodBodyContext() *MethodBodyContext {
	var p = new(MethodBodyContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PHPParserRULE_methodBody
	return p
}

func (*MethodBodyContext) IsMethodBodyContext() {}

func NewMethodBodyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MethodBodyContext {
	var p = new(MethodBodyContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PHPParserRULE_methodBody

	return p
}

func (s *MethodBodyContext) GetParser() antlr.Parser { return s.parser }

func (s *MethodBodyContext) SemiColon() antlr.TerminalNode {
	return s.GetToken(PHPParserSemiColon, 0)
}

func (s *MethodBodyContext) BlockStatement() IBlockStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBlockStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBlockStatementContext)
}

func (s *MethodBodyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MethodBodyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MethodBodyContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PHPParserVisitor:
		return t.VisitMethodBody(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PHPParser) MethodBody() (localctx IMethodBodyContext) {
	this := p
	_ = this

	localctx = NewMethodBodyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 148, PHPParserRULE_methodBody)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1135)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case PHPParserSemiColon:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1133)
			p.Match(PHPParserSemiColon)
		}

	case PHPParserOpenCurlyBracket:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1134)
			p.BlockStatement()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IPropertyModifiersContext is an interface to support dynamic dispatch.
type IPropertyModifiersContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPropertyModifiersContext differentiates from other interfaces.
	IsPropertyModifiersContext()
}

type PropertyModifiersContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPropertyModifiersContext() *PropertyModifiersContext {
	var p = new(PropertyModifiersContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PHPParserRULE_propertyModifiers
	return p
}

func (*PropertyModifiersContext) IsPropertyModifiersContext() {}

func NewPropertyModifiersContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PropertyModifiersContext {
	var p = new(PropertyModifiersContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PHPParserRULE_propertyModifiers

	return p
}

func (s *PropertyModifiersContext) GetParser() antlr.Parser { return s.parser }

func (s *PropertyModifiersContext) MemberModifiers() IMemberModifiersContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMemberModifiersContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMemberModifiersContext)
}

func (s *PropertyModifiersContext) Var() antlr.TerminalNode {
	return s.GetToken(PHPParserVar, 0)
}

func (s *PropertyModifiersContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PropertyModifiersContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PropertyModifiersContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PHPParserVisitor:
		return t.VisitPropertyModifiers(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PHPParser) PropertyModifiers() (localctx IPropertyModifiersContext) {
	this := p
	_ = this

	localctx = NewPropertyModifiersContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 150, PHPParserRULE_propertyModifiers)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1139)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case PHPParserAbstract, PHPParserFinal, PHPParserPrivate, PHPParserProtected, PHPParserPublic, PHPParserReadonly, PHPParserStatic:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1137)
			p.MemberModifiers()
		}

	case PHPParserVar:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1138)
			p.Match(PHPParserVar)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IMemberModifiersContext is an interface to support dynamic dispatch.
type IMemberModifiersContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMemberModifiersContext differentiates from other interfaces.
	IsMemberModifiersContext()
}

type MemberModifiersContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMemberModifiersContext() *MemberModifiersContext {
	var p = new(MemberModifiersContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PHPParserRULE_memberModifiers
	return p
}

func (*MemberModifiersContext) IsMemberModifiersContext() {}

func NewMemberModifiersContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MemberModifiersContext {
	var p = new(MemberModifiersContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PHPParserRULE_memberModifiers

	return p
}

func (s *MemberModifiersContext) GetParser() antlr.Parser { return s.parser }

func (s *MemberModifiersContext) AllMemberModifier() []IMemberModifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IMemberModifierContext); ok {
			len++
		}
	}

	tst := make([]IMemberModifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IMemberModifierContext); ok {
			tst[i] = t.(IMemberModifierContext)
			i++
		}
	}

	return tst
}

func (s *MemberModifiersContext) MemberModifier(i int) IMemberModifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMemberModifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMemberModifierContext)
}

func (s *MemberModifiersContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MemberModifiersContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MemberModifiersContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PHPParserVisitor:
		return t.VisitMemberModifiers(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PHPParser) MemberModifiers() (localctx IMemberModifiersContext) {
	this := p
	_ = this

	localctx = NewMemberModifiersContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 152, PHPParserRULE_memberModifiers)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1142)
	p.GetErrorHandler().Sync(p)
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			{
				p.SetState(1141)
				p.MemberModifier()
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(1144)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 125, p.GetParserRuleContext())
	}

	return localctx
}

// IVariableInitializerContext is an interface to support dynamic dispatch.
type IVariableInitializerContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsVariableInitializerContext differentiates from other interfaces.
	IsVariableInitializerContext()
}

type VariableInitializerContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVariableInitializerContext() *VariableInitializerContext {
	var p = new(VariableInitializerContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PHPParserRULE_variableInitializer
	return p
}

func (*VariableInitializerContext) IsVariableInitializerContext() {}

func NewVariableInitializerContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *VariableInitializerContext {
	var p = new(VariableInitializerContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PHPParserRULE_variableInitializer

	return p
}

func (s *VariableInitializerContext) GetParser() antlr.Parser { return s.parser }

func (s *VariableInitializerContext) VarName() antlr.TerminalNode {
	return s.GetToken(PHPParserVarName, 0)
}

func (s *VariableInitializerContext) Eq() antlr.TerminalNode {
	return s.GetToken(PHPParserEq, 0)
}

func (s *VariableInitializerContext) ConstantInitializer() IConstantInitializerContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConstantInitializerContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConstantInitializerContext)
}

func (s *VariableInitializerContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VariableInitializerContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *VariableInitializerContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PHPParserVisitor:
		return t.VisitVariableInitializer(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PHPParser) VariableInitializer() (localctx IVariableInitializerContext) {
	this := p
	_ = this

	localctx = NewVariableInitializerContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 154, PHPParserRULE_variableInitializer)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1146)
		p.Match(PHPParserVarName)
	}
	p.SetState(1149)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == PHPParserEq {
		{
			p.SetState(1147)
			p.Match(PHPParserEq)
		}
		{
			p.SetState(1148)
			p.ConstantInitializer()
		}

	}

	return localctx
}

// IIdentifierInitializerContext is an interface to support dynamic dispatch.
type IIdentifierInitializerContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsIdentifierInitializerContext differentiates from other interfaces.
	IsIdentifierInitializerContext()
}

type IdentifierInitializerContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIdentifierInitializerContext() *IdentifierInitializerContext {
	var p = new(IdentifierInitializerContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PHPParserRULE_identifierInitializer
	return p
}

func (*IdentifierInitializerContext) IsIdentifierInitializerContext() {}

func NewIdentifierInitializerContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IdentifierInitializerContext {
	var p = new(IdentifierInitializerContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PHPParserRULE_identifierInitializer

	return p
}

func (s *IdentifierInitializerContext) GetParser() antlr.Parser { return s.parser }

func (s *IdentifierInitializerContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *IdentifierInitializerContext) Eq() antlr.TerminalNode {
	return s.GetToken(PHPParserEq, 0)
}

func (s *IdentifierInitializerContext) ConstantInitializer() IConstantInitializerContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConstantInitializerContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConstantInitializerContext)
}

func (s *IdentifierInitializerContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IdentifierInitializerContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IdentifierInitializerContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PHPParserVisitor:
		return t.VisitIdentifierInitializer(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PHPParser) IdentifierInitializer() (localctx IIdentifierInitializerContext) {
	this := p
	_ = this

	localctx = NewIdentifierInitializerContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 156, PHPParserRULE_identifierInitializer)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1151)
		p.Identifier()
	}
	{
		p.SetState(1152)
		p.Match(PHPParserEq)
	}
	{
		p.SetState(1153)
		p.ConstantInitializer()
	}

	return localctx
}

// IGlobalConstantDeclarationContext is an interface to support dynamic dispatch.
type IGlobalConstantDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsGlobalConstantDeclarationContext differentiates from other interfaces.
	IsGlobalConstantDeclarationContext()
}

type GlobalConstantDeclarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGlobalConstantDeclarationContext() *GlobalConstantDeclarationContext {
	var p = new(GlobalConstantDeclarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PHPParserRULE_globalConstantDeclaration
	return p
}

func (*GlobalConstantDeclarationContext) IsGlobalConstantDeclarationContext() {}

func NewGlobalConstantDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GlobalConstantDeclarationContext {
	var p = new(GlobalConstantDeclarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PHPParserRULE_globalConstantDeclaration

	return p
}

func (s *GlobalConstantDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *GlobalConstantDeclarationContext) Const() antlr.TerminalNode {
	return s.GetToken(PHPParserConst, 0)
}

func (s *GlobalConstantDeclarationContext) AllIdentifierInitializer() []IIdentifierInitializerContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierInitializerContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierInitializerContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierInitializerContext); ok {
			tst[i] = t.(IIdentifierInitializerContext)
			i++
		}
	}

	return tst
}

func (s *GlobalConstantDeclarationContext) IdentifierInitializer(i int) IIdentifierInitializerContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierInitializerContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierInitializerContext)
}

func (s *GlobalConstantDeclarationContext) SemiColon() antlr.TerminalNode {
	return s.GetToken(PHPParserSemiColon, 0)
}

func (s *GlobalConstantDeclarationContext) Attributes() IAttributesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAttributesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAttributesContext)
}

func (s *GlobalConstantDeclarationContext) AllComma() []antlr.TerminalNode {
	return s.GetTokens(PHPParserComma)
}

func (s *GlobalConstantDeclarationContext) Comma(i int) antlr.TerminalNode {
	return s.GetToken(PHPParserComma, i)
}

func (s *GlobalConstantDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GlobalConstantDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GlobalConstantDeclarationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PHPParserVisitor:
		return t.VisitGlobalConstantDeclaration(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PHPParser) GlobalConstantDeclaration() (localctx IGlobalConstantDeclarationContext) {
	this := p
	_ = this

	localctx = NewGlobalConstantDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 158, PHPParserRULE_globalConstantDeclaration)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1156)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == PHPParserAttributeStart {
		{
			p.SetState(1155)
			p.Attributes()
		}

	}
	{
		p.SetState(1158)
		p.Match(PHPParserConst)
	}
	{
		p.SetState(1159)
		p.IdentifierInitializer()
	}
	p.SetState(1164)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == PHPParserComma {
		{
			p.SetState(1160)
			p.Match(PHPParserComma)
		}
		{
			p.SetState(1161)
			p.IdentifierInitializer()
		}

		p.SetState(1166)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1167)
		p.Match(PHPParserSemiColon)
	}

	return localctx
}

// IEnumDeclarationContext is an interface to support dynamic dispatch.
type IEnumDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEnumDeclarationContext differentiates from other interfaces.
	IsEnumDeclarationContext()
}

type EnumDeclarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEnumDeclarationContext() *EnumDeclarationContext {
	var p = new(EnumDeclarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PHPParserRULE_enumDeclaration
	return p
}

func (*EnumDeclarationContext) IsEnumDeclarationContext() {}

func NewEnumDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EnumDeclarationContext {
	var p = new(EnumDeclarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PHPParserRULE_enumDeclaration

	return p
}

func (s *EnumDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *EnumDeclarationContext) Enum_() antlr.TerminalNode {
	return s.GetToken(PHPParserEnum_, 0)
}

func (s *EnumDeclarationContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *EnumDeclarationContext) OpenCurlyBracket() antlr.TerminalNode {
	return s.GetToken(PHPParserOpenCurlyBracket, 0)
}

func (s *EnumDeclarationContext) CloseCurlyBracket() antlr.TerminalNode {
	return s.GetToken(PHPParserCloseCurlyBracket, 0)
}

func (s *EnumDeclarationContext) Colon() antlr.TerminalNode {
	return s.GetToken(PHPParserColon, 0)
}

func (s *EnumDeclarationContext) Implements() antlr.TerminalNode {
	return s.GetToken(PHPParserImplements, 0)
}

func (s *EnumDeclarationContext) InterfaceList() IInterfaceListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInterfaceListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInterfaceListContext)
}

func (s *EnumDeclarationContext) AllEnumItem() []IEnumItemContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IEnumItemContext); ok {
			len++
		}
	}

	tst := make([]IEnumItemContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IEnumItemContext); ok {
			tst[i] = t.(IEnumItemContext)
			i++
		}
	}

	return tst
}

func (s *EnumDeclarationContext) EnumItem(i int) IEnumItemContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEnumItemContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEnumItemContext)
}

func (s *EnumDeclarationContext) IntType() antlr.TerminalNode {
	return s.GetToken(PHPParserIntType, 0)
}

func (s *EnumDeclarationContext) StringType() antlr.TerminalNode {
	return s.GetToken(PHPParserStringType, 0)
}

func (s *EnumDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EnumDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EnumDeclarationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PHPParserVisitor:
		return t.VisitEnumDeclaration(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PHPParser) EnumDeclaration() (localctx IEnumDeclarationContext) {
	this := p
	_ = this

	localctx = NewEnumDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 160, PHPParserRULE_enumDeclaration)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1169)
		p.Match(PHPParserEnum_)
	}
	{
		p.SetState(1170)
		p.Identifier()
	}
	p.SetState(1173)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == PHPParserColon {
		{
			p.SetState(1171)
			p.Match(PHPParserColon)
		}
		{
			p.SetState(1172)
			_la = p.GetTokenStream().LA(1)

			if !(_la == PHPParserIntType || _la == PHPParserStringType) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}
	p.SetState(1177)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == PHPParserImplements {
		{
			p.SetState(1175)
			p.Match(PHPParserImplements)
		}
		{
			p.SetState(1176)
			p.InterfaceList()
		}

	}
	{
		p.SetState(1179)
		p.Match(PHPParserOpenCurlyBracket)
	}
	p.SetState(1183)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for (int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&4529987906437120) != 0 || (int64((_la-81)) & ^0x3f) == 0 && ((int64(1)<<(_la-81))&2254127685959713) != 0 {
		{
			p.SetState(1180)
			p.EnumItem()
		}

		p.SetState(1185)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1186)
		p.Match(PHPParserCloseCurlyBracket)
	}

	return localctx
}

// IEnumItemContext is an interface to support dynamic dispatch.
type IEnumItemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEnumItemContext differentiates from other interfaces.
	IsEnumItemContext()
}

type EnumItemContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEnumItemContext() *EnumItemContext {
	var p = new(EnumItemContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PHPParserRULE_enumItem
	return p
}

func (*EnumItemContext) IsEnumItemContext() {}

func NewEnumItemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EnumItemContext {
	var p = new(EnumItemContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PHPParserRULE_enumItem

	return p
}

func (s *EnumItemContext) GetParser() antlr.Parser { return s.parser }

func (s *EnumItemContext) Case() antlr.TerminalNode {
	return s.GetToken(PHPParserCase, 0)
}

func (s *EnumItemContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *EnumItemContext) SemiColon() antlr.TerminalNode {
	return s.GetToken(PHPParserSemiColon, 0)
}

func (s *EnumItemContext) Eq() antlr.TerminalNode {
	return s.GetToken(PHPParserEq, 0)
}

func (s *EnumItemContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *EnumItemContext) FunctionDeclaration() IFunctionDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionDeclarationContext)
}

func (s *EnumItemContext) MemberModifiers() IMemberModifiersContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMemberModifiersContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMemberModifiersContext)
}

func (s *EnumItemContext) Use() antlr.TerminalNode {
	return s.GetToken(PHPParserUse, 0)
}

func (s *EnumItemContext) QualifiedNamespaceNameList() IQualifiedNamespaceNameListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNamespaceNameListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNamespaceNameListContext)
}

func (s *EnumItemContext) TraitAdaptations() ITraitAdaptationsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITraitAdaptationsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITraitAdaptationsContext)
}

func (s *EnumItemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EnumItemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EnumItemContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PHPParserVisitor:
		return t.VisitEnumItem(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PHPParser) EnumItem() (localctx IEnumItemContext) {
	this := p
	_ = this

	localctx = NewEnumItemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 162, PHPParserRULE_enumItem)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1204)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case PHPParserCase:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1188)
			p.Match(PHPParserCase)
		}
		{
			p.SetState(1189)
			p.Identifier()
		}
		p.SetState(1192)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == PHPParserEq {
			{
				p.SetState(1190)
				p.Match(PHPParserEq)
			}
			{
				p.SetState(1191)
				p.expression(0)
			}

		}
		{
			p.SetState(1194)
			p.Match(PHPParserSemiColon)
		}

	case PHPParserAttributeStart, PHPParserAbstract, PHPParserFinal, PHPParserFunction_, PHPParserPrivate, PHPParserProtected, PHPParserPublic, PHPParserReadonly, PHPParserStatic:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(1197)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == PHPParserAbstract || (int64((_la-81)) & ^0x3f) == 0 && ((int64(1)<<(_la-81))&2327872274433) != 0 {
			{
				p.SetState(1196)
				p.MemberModifiers()
			}

		}
		{
			p.SetState(1199)
			p.FunctionDeclaration()
		}

	case PHPParserUse:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1200)
			p.Match(PHPParserUse)
		}
		{
			p.SetState(1201)
			p.QualifiedNamespaceNameList()
		}
		{
			p.SetState(1202)
			p.TraitAdaptations()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IExpressionListContext is an interface to support dynamic dispatch.
type IExpressionListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExpressionListContext differentiates from other interfaces.
	IsExpressionListContext()
}

type ExpressionListContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpressionListContext() *ExpressionListContext {
	var p = new(ExpressionListContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PHPParserRULE_expressionList
	return p
}

func (*ExpressionListContext) IsExpressionListContext() {}

func NewExpressionListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExpressionListContext {
	var p = new(ExpressionListContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PHPParserRULE_expressionList

	return p
}

func (s *ExpressionListContext) GetParser() antlr.Parser { return s.parser }

func (s *ExpressionListContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *ExpressionListContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ExpressionListContext) AllComma() []antlr.TerminalNode {
	return s.GetTokens(PHPParserComma)
}

func (s *ExpressionListContext) Comma(i int) antlr.TerminalNode {
	return s.GetToken(PHPParserComma, i)
}

func (s *ExpressionListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExpressionListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExpressionListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PHPParserVisitor:
		return t.VisitExpressionList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PHPParser) ExpressionList() (localctx IExpressionListContext) {
	this := p
	_ = this

	localctx = NewExpressionListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 164, PHPParserRULE_expressionList)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1206)
		p.expression(0)
	}
	p.SetState(1211)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == PHPParserComma {
		{
			p.SetState(1207)
			p.Match(PHPParserComma)
		}
		{
			p.SetState(1208)
			p.expression(0)
		}

		p.SetState(1213)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IParenthesesContext is an interface to support dynamic dispatch.
type IParenthesesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsParenthesesContext differentiates from other interfaces.
	IsParenthesesContext()
}

type ParenthesesContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyParenthesesContext() *ParenthesesContext {
	var p = new(ParenthesesContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PHPParserRULE_parentheses
	return p
}

func (*ParenthesesContext) IsParenthesesContext() {}

func NewParenthesesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ParenthesesContext {
	var p = new(ParenthesesContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PHPParserRULE_parentheses

	return p
}

func (s *ParenthesesContext) GetParser() antlr.Parser { return s.parser }

func (s *ParenthesesContext) OpenRoundBracket() antlr.TerminalNode {
	return s.GetToken(PHPParserOpenRoundBracket, 0)
}

func (s *ParenthesesContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ParenthesesContext) CloseRoundBracket() antlr.TerminalNode {
	return s.GetToken(PHPParserCloseRoundBracket, 0)
}

func (s *ParenthesesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ParenthesesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ParenthesesContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PHPParserVisitor:
		return t.VisitParentheses(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PHPParser) Parentheses() (localctx IParenthesesContext) {
	this := p
	_ = this

	localctx = NewParenthesesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 166, PHPParserRULE_parentheses)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1214)
		p.Match(PHPParserOpenRoundBracket)
	}
	{
		p.SetState(1215)
		p.expression(0)
	}
	{
		p.SetState(1216)
		p.Match(PHPParserCloseRoundBracket)
	}

	return localctx
}

// IFullyQualifiedNamespaceExprContext is an interface to support dynamic dispatch.
type IFullyQualifiedNamespaceExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFullyQualifiedNamespaceExprContext differentiates from other interfaces.
	IsFullyQualifiedNamespaceExprContext()
}

type FullyQualifiedNamespaceExprContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFullyQualifiedNamespaceExprContext() *FullyQualifiedNamespaceExprContext {
	var p = new(FullyQualifiedNamespaceExprContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PHPParserRULE_fullyQualifiedNamespaceExpr
	return p
}

func (*FullyQualifiedNamespaceExprContext) IsFullyQualifiedNamespaceExprContext() {}

func NewFullyQualifiedNamespaceExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FullyQualifiedNamespaceExprContext {
	var p = new(FullyQualifiedNamespaceExprContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PHPParserRULE_fullyQualifiedNamespaceExpr

	return p
}

func (s *FullyQualifiedNamespaceExprContext) GetParser() antlr.Parser { return s.parser }

func (s *FullyQualifiedNamespaceExprContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *FullyQualifiedNamespaceExprContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *FullyQualifiedNamespaceExprContext) AllNamespaceSeparator() []antlr.TerminalNode {
	return s.GetTokens(PHPParserNamespaceSeparator)
}

func (s *FullyQualifiedNamespaceExprContext) NamespaceSeparator(i int) antlr.TerminalNode {
	return s.GetToken(PHPParserNamespaceSeparator, i)
}

func (s *FullyQualifiedNamespaceExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FullyQualifiedNamespaceExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FullyQualifiedNamespaceExprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PHPParserVisitor:
		return t.VisitFullyQualifiedNamespaceExpr(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PHPParser) FullyQualifiedNamespaceExpr() (localctx IFullyQualifiedNamespaceExprContext) {
	this := p
	_ = this

	localctx = NewFullyQualifiedNamespaceExprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 168, PHPParserRULE_fullyQualifiedNamespaceExpr)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1218)
		p.Identifier()
	}
	{
		p.SetState(1219)
		p.Match(PHPParserNamespaceSeparator)
	}
	p.SetState(1225)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 136, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1220)
				p.Identifier()
			}
			{
				p.SetState(1221)
				p.Match(PHPParserNamespaceSeparator)
			}

		}
		p.SetState(1227)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 136, p.GetParserRuleContext())
	}
	{
		p.SetState(1228)
		p.Identifier()
	}

	return localctx
}

// IStaticClassExprContext is an interface to support dynamic dispatch.
type IStaticClassExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsStaticClassExprContext differentiates from other interfaces.
	IsStaticClassExprContext()
}

type StaticClassExprContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStaticClassExprContext() *StaticClassExprContext {
	var p = new(StaticClassExprContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PHPParserRULE_staticClassExpr
	return p
}

func (*StaticClassExprContext) IsStaticClassExprContext() {}

func NewStaticClassExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StaticClassExprContext {
	var p = new(StaticClassExprContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PHPParserRULE_staticClassExpr

	return p
}

func (s *StaticClassExprContext) GetParser() antlr.Parser { return s.parser }

func (s *StaticClassExprContext) StaticClassExprFunctionMember() IStaticClassExprFunctionMemberContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStaticClassExprFunctionMemberContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStaticClassExprFunctionMemberContext)
}

func (s *StaticClassExprContext) StaticClassExprVariableMember() IStaticClassExprVariableMemberContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStaticClassExprVariableMemberContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStaticClassExprVariableMemberContext)
}

func (s *StaticClassExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StaticClassExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StaticClassExprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PHPParserVisitor:
		return t.VisitStaticClassExpr(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PHPParser) StaticClassExpr() (localctx IStaticClassExprContext) {
	this := p
	_ = this

	localctx = NewStaticClassExprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 170, PHPParserRULE_staticClassExpr)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1232)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 137, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1230)
			p.StaticClassExprFunctionMember()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1231)
			p.StaticClassExprVariableMember()
		}

	}

	return localctx
}

// IStaticClassExprFunctionMemberContext is an interface to support dynamic dispatch.
type IStaticClassExprFunctionMemberContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsStaticClassExprFunctionMemberContext differentiates from other interfaces.
	IsStaticClassExprFunctionMemberContext()
}

type StaticClassExprFunctionMemberContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStaticClassExprFunctionMemberContext() *StaticClassExprFunctionMemberContext {
	var p = new(StaticClassExprFunctionMemberContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PHPParserRULE_staticClassExprFunctionMember
	return p
}

func (*StaticClassExprFunctionMemberContext) IsStaticClassExprFunctionMemberContext() {}

func NewStaticClassExprFunctionMemberContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StaticClassExprFunctionMemberContext {
	var p = new(StaticClassExprFunctionMemberContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PHPParserRULE_staticClassExprFunctionMember

	return p
}

func (s *StaticClassExprFunctionMemberContext) GetParser() antlr.Parser { return s.parser }

func (s *StaticClassExprFunctionMemberContext) CopyFrom(ctx *StaticClassExprFunctionMemberContext) {
	s.BaseParserRuleContext.CopyFrom(ctx.BaseParserRuleContext)
}

func (s *StaticClassExprFunctionMemberContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StaticClassExprFunctionMemberContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type ClassStaticFunctionMemberContext struct {
	*StaticClassExprFunctionMemberContext
}

func NewClassStaticFunctionMemberContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ClassStaticFunctionMemberContext {
	var p = new(ClassStaticFunctionMemberContext)

	p.StaticClassExprFunctionMemberContext = NewEmptyStaticClassExprFunctionMemberContext()
	p.parser = parser
	p.CopyFrom(ctx.(*StaticClassExprFunctionMemberContext))

	return p
}

func (s *ClassStaticFunctionMemberContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ClassStaticFunctionMemberContext) FullyQualifiedNamespaceExpr() IFullyQualifiedNamespaceExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFullyQualifiedNamespaceExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFullyQualifiedNamespaceExprContext)
}

func (s *ClassStaticFunctionMemberContext) DoubleColon() antlr.TerminalNode {
	return s.GetToken(PHPParserDoubleColon, 0)
}

func (s *ClassStaticFunctionMemberContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ClassStaticFunctionMemberContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PHPParserVisitor:
		return t.VisitClassStaticFunctionMember(s)

	default:
		return t.VisitChildren(s)
	}
}

type StringAsIndirectClassStaticFunctionMemberContext struct {
	*StaticClassExprFunctionMemberContext
}

func NewStringAsIndirectClassStaticFunctionMemberContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *StringAsIndirectClassStaticFunctionMemberContext {
	var p = new(StringAsIndirectClassStaticFunctionMemberContext)

	p.StaticClassExprFunctionMemberContext = NewEmptyStaticClassExprFunctionMemberContext()
	p.parser = parser
	p.CopyFrom(ctx.(*StaticClassExprFunctionMemberContext))

	return p
}

func (s *StringAsIndirectClassStaticFunctionMemberContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StringAsIndirectClassStaticFunctionMemberContext) String_() IStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *StringAsIndirectClassStaticFunctionMemberContext) DoubleColon() antlr.TerminalNode {
	return s.GetToken(PHPParserDoubleColon, 0)
}

func (s *StringAsIndirectClassStaticFunctionMemberContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *StringAsIndirectClassStaticFunctionMemberContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PHPParserVisitor:
		return t.VisitStringAsIndirectClassStaticFunctionMember(s)

	default:
		return t.VisitChildren(s)
	}
}

type VariableAsIndirectClassStaticFunctionMemberContext struct {
	*StaticClassExprFunctionMemberContext
}

func NewVariableAsIndirectClassStaticFunctionMemberContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *VariableAsIndirectClassStaticFunctionMemberContext {
	var p = new(VariableAsIndirectClassStaticFunctionMemberContext)

	p.StaticClassExprFunctionMemberContext = NewEmptyStaticClassExprFunctionMemberContext()
	p.parser = parser
	p.CopyFrom(ctx.(*StaticClassExprFunctionMemberContext))

	return p
}

func (s *VariableAsIndirectClassStaticFunctionMemberContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VariableAsIndirectClassStaticFunctionMemberContext) Variable() IVariableContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVariableContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVariableContext)
}

func (s *VariableAsIndirectClassStaticFunctionMemberContext) DoubleColon() antlr.TerminalNode {
	return s.GetToken(PHPParserDoubleColon, 0)
}

func (s *VariableAsIndirectClassStaticFunctionMemberContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *VariableAsIndirectClassStaticFunctionMemberContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PHPParserVisitor:
		return t.VisitVariableAsIndirectClassStaticFunctionMember(s)

	default:
		return t.VisitChildren(s)
	}
}

type ClassDirectFunctionMemberContext struct {
	*StaticClassExprFunctionMemberContext
}

func NewClassDirectFunctionMemberContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ClassDirectFunctionMemberContext {
	var p = new(ClassDirectFunctionMemberContext)

	p.StaticClassExprFunctionMemberContext = NewEmptyStaticClassExprFunctionMemberContext()
	p.parser = parser
	p.CopyFrom(ctx.(*StaticClassExprFunctionMemberContext))

	return p
}

func (s *ClassDirectFunctionMemberContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ClassDirectFunctionMemberContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *ClassDirectFunctionMemberContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ClassDirectFunctionMemberContext) DoubleColon() antlr.TerminalNode {
	return s.GetToken(PHPParserDoubleColon, 0)
}

func (s *ClassDirectFunctionMemberContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PHPParserVisitor:
		return t.VisitClassDirectFunctionMember(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PHPParser) StaticClassExprFunctionMember() (localctx IStaticClassExprFunctionMemberContext) {
	this := p
	_ = this

	localctx = NewStaticClassExprFunctionMemberContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 172, PHPParserRULE_staticClassExprFunctionMember)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1250)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 138, p.GetParserRuleContext()) {
	case 1:
		localctx = NewClassStaticFunctionMemberContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1234)
			p.FullyQualifiedNamespaceExpr()
		}
		{
			p.SetState(1235)
			p.Match(PHPParserDoubleColon)
		}
		{
			p.SetState(1236)
			p.Identifier()
		}

	case 2:
		localctx = NewClassDirectFunctionMemberContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1238)
			p.Identifier()
		}
		{
			p.SetState(1239)
			p.Match(PHPParserDoubleColon)
		}
		{
			p.SetState(1240)
			p.Identifier()
		}

	case 3:
		localctx = NewStringAsIndirectClassStaticFunctionMemberContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1242)
			p.String_()
		}
		{
			p.SetState(1243)
			p.Match(PHPParserDoubleColon)
		}
		{
			p.SetState(1244)
			p.Identifier()
		}

	case 4:
		localctx = NewVariableAsIndirectClassStaticFunctionMemberContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1246)
			p.Variable()
		}
		{
			p.SetState(1247)
			p.Match(PHPParserDoubleColon)
		}
		{
			p.SetState(1248)
			p.Identifier()
		}

	}

	return localctx
}

// IStaticClassExprVariableMemberContext is an interface to support dynamic dispatch.
type IStaticClassExprVariableMemberContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsStaticClassExprVariableMemberContext differentiates from other interfaces.
	IsStaticClassExprVariableMemberContext()
}

type StaticClassExprVariableMemberContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStaticClassExprVariableMemberContext() *StaticClassExprVariableMemberContext {
	var p = new(StaticClassExprVariableMemberContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PHPParserRULE_staticClassExprVariableMember
	return p
}

func (*StaticClassExprVariableMemberContext) IsStaticClassExprVariableMemberContext() {}

func NewStaticClassExprVariableMemberContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StaticClassExprVariableMemberContext {
	var p = new(StaticClassExprVariableMemberContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PHPParserRULE_staticClassExprVariableMember

	return p
}

func (s *StaticClassExprVariableMemberContext) GetParser() antlr.Parser { return s.parser }

func (s *StaticClassExprVariableMemberContext) CopyFrom(ctx *StaticClassExprVariableMemberContext) {
	s.BaseParserRuleContext.CopyFrom(ctx.BaseParserRuleContext)
}

func (s *StaticClassExprVariableMemberContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StaticClassExprVariableMemberContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type StringAsIndirectClassStaticVariableContext struct {
	*StaticClassExprVariableMemberContext
}

func NewStringAsIndirectClassStaticVariableContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *StringAsIndirectClassStaticVariableContext {
	var p = new(StringAsIndirectClassStaticVariableContext)

	p.StaticClassExprVariableMemberContext = NewEmptyStaticClassExprVariableMemberContext()
	p.parser = parser
	p.CopyFrom(ctx.(*StaticClassExprVariableMemberContext))

	return p
}

func (s *StringAsIndirectClassStaticVariableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StringAsIndirectClassStaticVariableContext) String_() IStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *StringAsIndirectClassStaticVariableContext) DoubleColon() antlr.TerminalNode {
	return s.GetToken(PHPParserDoubleColon, 0)
}

func (s *StringAsIndirectClassStaticVariableContext) VarName() antlr.TerminalNode {
	return s.GetToken(PHPParserVarName, 0)
}

func (s *StringAsIndirectClassStaticVariableContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PHPParserVisitor:
		return t.VisitStringAsIndirectClassStaticVariable(s)

	default:
		return t.VisitChildren(s)
	}
}

type VariableAsIndirectClassStaticVariableContext struct {
	*StaticClassExprVariableMemberContext
}

func NewVariableAsIndirectClassStaticVariableContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *VariableAsIndirectClassStaticVariableContext {
	var p = new(VariableAsIndirectClassStaticVariableContext)

	p.StaticClassExprVariableMemberContext = NewEmptyStaticClassExprVariableMemberContext()
	p.parser = parser
	p.CopyFrom(ctx.(*StaticClassExprVariableMemberContext))

	return p
}

func (s *VariableAsIndirectClassStaticVariableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VariableAsIndirectClassStaticVariableContext) Variable() IVariableContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVariableContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVariableContext)
}

func (s *VariableAsIndirectClassStaticVariableContext) DoubleColon() antlr.TerminalNode {
	return s.GetToken(PHPParserDoubleColon, 0)
}

func (s *VariableAsIndirectClassStaticVariableContext) VarName() antlr.TerminalNode {
	return s.GetToken(PHPParserVarName, 0)
}

func (s *VariableAsIndirectClassStaticVariableContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PHPParserVisitor:
		return t.VisitVariableAsIndirectClassStaticVariable(s)

	default:
		return t.VisitChildren(s)
	}
}

type ClassDirectStaticVariableContext struct {
	*StaticClassExprVariableMemberContext
}

func NewClassDirectStaticVariableContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ClassDirectStaticVariableContext {
	var p = new(ClassDirectStaticVariableContext)

	p.StaticClassExprVariableMemberContext = NewEmptyStaticClassExprVariableMemberContext()
	p.parser = parser
	p.CopyFrom(ctx.(*StaticClassExprVariableMemberContext))

	return p
}

func (s *ClassDirectStaticVariableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ClassDirectStaticVariableContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ClassDirectStaticVariableContext) DoubleColon() antlr.TerminalNode {
	return s.GetToken(PHPParserDoubleColon, 0)
}

func (s *ClassDirectStaticVariableContext) VarName() antlr.TerminalNode {
	return s.GetToken(PHPParserVarName, 0)
}

func (s *ClassDirectStaticVariableContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PHPParserVisitor:
		return t.VisitClassDirectStaticVariable(s)

	default:
		return t.VisitChildren(s)
	}
}

type ClassStaticVariableContext struct {
	*StaticClassExprVariableMemberContext
}

func NewClassStaticVariableContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ClassStaticVariableContext {
	var p = new(ClassStaticVariableContext)

	p.StaticClassExprVariableMemberContext = NewEmptyStaticClassExprVariableMemberContext()
	p.parser = parser
	p.CopyFrom(ctx.(*StaticClassExprVariableMemberContext))

	return p
}

func (s *ClassStaticVariableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ClassStaticVariableContext) FullyQualifiedNamespaceExpr() IFullyQualifiedNamespaceExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFullyQualifiedNamespaceExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFullyQualifiedNamespaceExprContext)
}

func (s *ClassStaticVariableContext) DoubleColon() antlr.TerminalNode {
	return s.GetToken(PHPParserDoubleColon, 0)
}

func (s *ClassStaticVariableContext) VarName() antlr.TerminalNode {
	return s.GetToken(PHPParserVarName, 0)
}

func (s *ClassStaticVariableContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PHPParserVisitor:
		return t.VisitClassStaticVariable(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PHPParser) StaticClassExprVariableMember() (localctx IStaticClassExprVariableMemberContext) {
	this := p
	_ = this

	localctx = NewStaticClassExprVariableMemberContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 174, PHPParserRULE_staticClassExprVariableMember)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1268)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 139, p.GetParserRuleContext()) {
	case 1:
		localctx = NewClassStaticVariableContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1252)
			p.FullyQualifiedNamespaceExpr()
		}
		{
			p.SetState(1253)
			p.Match(PHPParserDoubleColon)
		}
		{
			p.SetState(1254)
			p.Match(PHPParserVarName)
		}

	case 2:
		localctx = NewClassDirectStaticVariableContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1256)
			p.Identifier()
		}
		{
			p.SetState(1257)
			p.Match(PHPParserDoubleColon)
		}
		{
			p.SetState(1258)
			p.Match(PHPParserVarName)
		}

	case 3:
		localctx = NewStringAsIndirectClassStaticVariableContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1260)
			p.String_()
		}
		{
			p.SetState(1261)
			p.Match(PHPParserDoubleColon)
		}
		{
			p.SetState(1262)
			p.Match(PHPParserVarName)
		}

	case 4:
		localctx = NewVariableAsIndirectClassStaticVariableContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1264)
			p.Variable()
		}
		{
			p.SetState(1265)
			p.Match(PHPParserDoubleColon)
		}
		{
			p.SetState(1266)
			p.Match(PHPParserVarName)
		}

	}

	return localctx
}

// IMemberCallKeyContext is an interface to support dynamic dispatch.
type IMemberCallKeyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMemberCallKeyContext differentiates from other interfaces.
	IsMemberCallKeyContext()
}

type MemberCallKeyContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMemberCallKeyContext() *MemberCallKeyContext {
	var p = new(MemberCallKeyContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PHPParserRULE_memberCallKey
	return p
}

func (*MemberCallKeyContext) IsMemberCallKeyContext() {}

func NewMemberCallKeyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MemberCallKeyContext {
	var p = new(MemberCallKeyContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PHPParserRULE_memberCallKey

	return p
}

func (s *MemberCallKeyContext) GetParser() antlr.Parser { return s.parser }

func (s *MemberCallKeyContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *MemberCallKeyContext) String_() IStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *MemberCallKeyContext) Variable() IVariableContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVariableContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVariableContext)
}

func (s *MemberCallKeyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MemberCallKeyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MemberCallKeyContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PHPParserVisitor:
		return t.VisitMemberCallKey(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PHPParser) MemberCallKey() (localctx IMemberCallKeyContext) {
	this := p
	_ = this

	localctx = NewMemberCallKeyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 176, PHPParserRULE_memberCallKey)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1273)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case PHPParserAbstract, PHPParserArray, PHPParserAs, PHPParserBinaryCast, PHPParserBoolType, PHPParserBooleanConstant, PHPParserBreak, PHPParserCallable, PHPParserCase, PHPParserCatch, PHPParserClass, PHPParserClone, PHPParserConst, PHPParserContinue, PHPParserDeclare, PHPParserDefault, PHPParserDo, PHPParserDoubleCast, PHPParserDoubleType, PHPParserEcho, PHPParserElse, PHPParserElseIf, PHPParserEmpty, PHPParserEnum_, PHPParserEndDeclare, PHPParserEndFor, PHPParserEndForeach, PHPParserEndIf, PHPParserEndSwitch, PHPParserEndWhile, PHPParserExtends, PHPParserFinal, PHPParserFinally, PHPParserFloatCast, PHPParserFor, PHPParserForeach, PHPParserFunction_, PHPParserGlobal, PHPParserGoto, PHPParserIf, PHPParserImplements, PHPParserImport, PHPParserInstanceOf, PHPParserInsteadOf, PHPParserInt8Cast, PHPParserInt16Cast, PHPParserInt64Type, PHPParserIntType, PHPParserInterface, PHPParserList, PHPParserLogicalAnd, PHPParserLogicalOr, PHPParserLogicalXor, PHPParserMatch_, PHPParserNamespace, PHPParserNew, PHPParserNull, PHPParserObjectType, PHPParserParent_, PHPParserPartial, PHPParserPrint, PHPParserPrivate, PHPParserProtected, PHPParserPublic, PHPParserReadonly, PHPParserResource, PHPParserReturn, PHPParserStatic, PHPParserStringType, PHPParserSwitch, PHPParserTrait, PHPParserTry, PHPParserTypeof, PHPParserUintCast, PHPParserUnicodeCast, PHPParserUse, PHPParserVar, PHPParserWhile, PHPParserYield, PHPParserFrom, PHPParserLambdaFn, PHPParserTicks, PHPParserEncoding, PHPParserStrictTypes, PHPParserGet, PHPParserSet, PHPParserCall, PHPParserCallStatic, PHPParserConstructor, PHPParserDestruct, PHPParserWakeup, PHPParserSleep, PHPParserAutoload, PHPParserIsSet__, PHPParserUnset__, PHPParserToString__, PHPParserInvoke, PHPParserSetState, PHPParserClone__, PHPParserDebugInfo, PHPParserNamespace__, PHPParserClass__, PHPParserTraic__, PHPParserFunction__, PHPParserMethod__, PHPParserLine__, PHPParserFile__, PHPParserDir__, PHPParserNamespaceSeparator, PHPParserLabel:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1270)
			p.Identifier()
		}

	case PHPParserSingleQuoteString, PHPParserDoubleQuote, PHPParserStartNowDoc, PHPParserStartHereDoc:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1271)
			p.String_()
		}

	case PHPParserDollar, PHPParserVarName:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1272)
			p.Variable()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IIndexMemberCallKeyContext is an interface to support dynamic dispatch.
type IIndexMemberCallKeyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsIndexMemberCallKeyContext differentiates from other interfaces.
	IsIndexMemberCallKeyContext()
}

type IndexMemberCallKeyContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIndexMemberCallKeyContext() *IndexMemberCallKeyContext {
	var p = new(IndexMemberCallKeyContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PHPParserRULE_indexMemberCallKey
	return p
}

func (*IndexMemberCallKeyContext) IsIndexMemberCallKeyContext() {}

func NewIndexMemberCallKeyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IndexMemberCallKeyContext {
	var p = new(IndexMemberCallKeyContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PHPParserRULE_indexMemberCallKey

	return p
}

func (s *IndexMemberCallKeyContext) GetParser() antlr.Parser { return s.parser }

func (s *IndexMemberCallKeyContext) MemberCallKey() IMemberCallKeyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMemberCallKeyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMemberCallKeyContext)
}

func (s *IndexMemberCallKeyContext) NumericConstant() INumericConstantContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INumericConstantContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INumericConstantContext)
}

func (s *IndexMemberCallKeyContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *IndexMemberCallKeyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IndexMemberCallKeyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IndexMemberCallKeyContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PHPParserVisitor:
		return t.VisitIndexMemberCallKey(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PHPParser) IndexMemberCallKey() (localctx IIndexMemberCallKeyContext) {
	this := p
	_ = this

	localctx = NewIndexMemberCallKeyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 178, PHPParserRULE_indexMemberCallKey)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1278)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 141, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1275)
			p.MemberCallKey()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1276)
			p.NumericConstant()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1277)
			p.expression(0)
		}

	}

	return localctx
}

// IExpressionContext is an interface to support dynamic dispatch.
type IExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExpressionContext differentiates from other interfaces.
	IsExpressionContext()
}

type ExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpressionContext() *ExpressionContext {
	var p = new(ExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PHPParserRULE_expression
	return p
}

func (*ExpressionContext) IsExpressionContext() {}

func NewExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExpressionContext {
	var p = new(ExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PHPParserRULE_expression

	return p
}

func (s *ExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *ExpressionContext) CopyFrom(ctx *ExpressionContext) {
	s.BaseParserRuleContext.CopyFrom(ctx.BaseParserRuleContext)
}

func (s *ExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type SpecialWordExpressionContext struct {
	*ExpressionContext
}

func NewSpecialWordExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SpecialWordExpressionContext {
	var p = new(SpecialWordExpressionContext)

	p.ExpressionContext = NewEmptyExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ExpressionContext))

	return p
}

func (s *SpecialWordExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SpecialWordExpressionContext) Yield() antlr.TerminalNode {
	return s.GetToken(PHPParserYield, 0)
}

func (s *SpecialWordExpressionContext) List() antlr.TerminalNode {
	return s.GetToken(PHPParserList, 0)
}

func (s *SpecialWordExpressionContext) OpenRoundBracket() antlr.TerminalNode {
	return s.GetToken(PHPParserOpenRoundBracket, 0)
}

func (s *SpecialWordExpressionContext) AssignmentList() IAssignmentListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAssignmentListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAssignmentListContext)
}

func (s *SpecialWordExpressionContext) CloseRoundBracket() antlr.TerminalNode {
	return s.GetToken(PHPParserCloseRoundBracket, 0)
}

func (s *SpecialWordExpressionContext) Eq() antlr.TerminalNode {
	return s.GetToken(PHPParserEq, 0)
}

func (s *SpecialWordExpressionContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *SpecialWordExpressionContext) IsSet() antlr.TerminalNode {
	return s.GetToken(PHPParserIsSet, 0)
}

func (s *SpecialWordExpressionContext) ChainList() IChainListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IChainListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IChainListContext)
}

func (s *SpecialWordExpressionContext) Empty() antlr.TerminalNode {
	return s.GetToken(PHPParserEmpty, 0)
}

func (s *SpecialWordExpressionContext) Chain() IChainContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IChainContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IChainContext)
}

func (s *SpecialWordExpressionContext) Exit() antlr.TerminalNode {
	return s.GetToken(PHPParserExit, 0)
}

func (s *SpecialWordExpressionContext) Die() antlr.TerminalNode {
	return s.GetToken(PHPParserDie, 0)
}

func (s *SpecialWordExpressionContext) Throw() antlr.TerminalNode {
	return s.GetToken(PHPParserThrow, 0)
}

func (s *SpecialWordExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PHPParserVisitor:
		return t.VisitSpecialWordExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

type ShortQualifiedNameExpressionContext struct {
	*ExpressionContext
}

func NewShortQualifiedNameExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShortQualifiedNameExpressionContext {
	var p = new(ShortQualifiedNameExpressionContext)

	p.ExpressionContext = NewEmptyExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ExpressionContext))

	return p
}

func (s *ShortQualifiedNameExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShortQualifiedNameExpressionContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ShortQualifiedNameExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PHPParserVisitor:
		return t.VisitShortQualifiedNameExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

type ArrayCreationExpressionContext struct {
	*ExpressionContext
}

func NewArrayCreationExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ArrayCreationExpressionContext {
	var p = new(ArrayCreationExpressionContext)

	p.ExpressionContext = NewEmptyExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ExpressionContext))

	return p
}

func (s *ArrayCreationExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArrayCreationExpressionContext) ArrayCreation() IArrayCreationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArrayCreationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArrayCreationContext)
}

func (s *ArrayCreationExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PHPParserVisitor:
		return t.VisitArrayCreationExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

type BackQuoteStringExpressionContext struct {
	*ExpressionContext
}

func NewBackQuoteStringExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *BackQuoteStringExpressionContext {
	var p = new(BackQuoteStringExpressionContext)

	p.ExpressionContext = NewEmptyExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ExpressionContext))

	return p
}

func (s *BackQuoteStringExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BackQuoteStringExpressionContext) BackQuoteString() antlr.TerminalNode {
	return s.GetToken(PHPParserBackQuoteString, 0)
}

func (s *BackQuoteStringExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PHPParserVisitor:
		return t.VisitBackQuoteStringExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

type ArrayCreationUnpackExpressionContext struct {
	*ExpressionContext
}

func NewArrayCreationUnpackExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ArrayCreationUnpackExpressionContext {
	var p = new(ArrayCreationUnpackExpressionContext)

	p.ExpressionContext = NewEmptyExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ExpressionContext))

	return p
}

func (s *ArrayCreationUnpackExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArrayCreationUnpackExpressionContext) LeftArrayCreation() ILeftArrayCreationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILeftArrayCreationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILeftArrayCreationContext)
}

func (s *ArrayCreationUnpackExpressionContext) Eq() antlr.TerminalNode {
	return s.GetToken(PHPParserEq, 0)
}

func (s *ArrayCreationUnpackExpressionContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ArrayCreationUnpackExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PHPParserVisitor:
		return t.VisitArrayCreationUnpackExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

type KeywordNewExpressionContext struct {
	*ExpressionContext
}

func NewKeywordNewExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *KeywordNewExpressionContext {
	var p = new(KeywordNewExpressionContext)

	p.ExpressionContext = NewEmptyExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ExpressionContext))

	return p
}

func (s *KeywordNewExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KeywordNewExpressionContext) NewExpr() INewExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INewExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INewExprContext)
}

func (s *KeywordNewExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PHPParserVisitor:
		return t.VisitKeywordNewExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

type MatchExpressionContext struct {
	*ExpressionContext
}

func NewMatchExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *MatchExpressionContext {
	var p = new(MatchExpressionContext)

	p.ExpressionContext = NewEmptyExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ExpressionContext))

	return p
}

func (s *MatchExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MatchExpressionContext) MatchExpr() IMatchExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMatchExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMatchExprContext)
}

func (s *MatchExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PHPParserVisitor:
		return t.VisitMatchExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

type FunctionCallExpressionContext struct {
	*ExpressionContext
}

func NewFunctionCallExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *FunctionCallExpressionContext {
	var p = new(FunctionCallExpressionContext)

	p.ExpressionContext = NewEmptyExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ExpressionContext))

	return p
}

func (s *FunctionCallExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FunctionCallExpressionContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *FunctionCallExpressionContext) Arguments() IArgumentsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArgumentsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArgumentsContext)
}

func (s *FunctionCallExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PHPParserVisitor:
		return t.VisitFunctionCallExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

type LogicalExpressionContext struct {
	*ExpressionContext
	op antlr.Token
}

func NewLogicalExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LogicalExpressionContext {
	var p = new(LogicalExpressionContext)

	p.ExpressionContext = NewEmptyExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ExpressionContext))

	return p
}

func (s *LogicalExpressionContext) GetOp() antlr.Token { return s.op }

func (s *LogicalExpressionContext) SetOp(v antlr.Token) { s.op = v }

func (s *LogicalExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LogicalExpressionContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *LogicalExpressionContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *LogicalExpressionContext) LogicalAnd() antlr.TerminalNode {
	return s.GetToken(PHPParserLogicalAnd, 0)
}

func (s *LogicalExpressionContext) LogicalXor() antlr.TerminalNode {
	return s.GetToken(PHPParserLogicalXor, 0)
}

func (s *LogicalExpressionContext) LogicalOr() antlr.TerminalNode {
	return s.GetToken(PHPParserLogicalOr, 0)
}

func (s *LogicalExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PHPParserVisitor:
		return t.VisitLogicalExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

type PrintExpressionContext struct {
	*ExpressionContext
}

func NewPrintExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *PrintExpressionContext {
	var p = new(PrintExpressionContext)

	p.ExpressionContext = NewEmptyExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ExpressionContext))

	return p
}

func (s *PrintExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrintExpressionContext) Print() antlr.TerminalNode {
	return s.GetToken(PHPParserPrint, 0)
}

func (s *PrintExpressionContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *PrintExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PHPParserVisitor:
		return t.VisitPrintExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

type PostfixIncDecExpressionContext struct {
	*ExpressionContext
}

func NewPostfixIncDecExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *PostfixIncDecExpressionContext {
	var p = new(PostfixIncDecExpressionContext)

	p.ExpressionContext = NewEmptyExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ExpressionContext))

	return p
}

func (s *PostfixIncDecExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PostfixIncDecExpressionContext) FlexiVariable() IFlexiVariableContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFlexiVariableContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFlexiVariableContext)
}

func (s *PostfixIncDecExpressionContext) Inc() antlr.TerminalNode {
	return s.GetToken(PHPParserInc, 0)
}

func (s *PostfixIncDecExpressionContext) Dec() antlr.TerminalNode {
	return s.GetToken(PHPParserDec, 0)
}

func (s *PostfixIncDecExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PHPParserVisitor:
		return t.VisitPostfixIncDecExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

type IncludeExpressionContext struct {
	*ExpressionContext
}

func NewIncludeExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *IncludeExpressionContext {
	var p = new(IncludeExpressionContext)

	p.ExpressionContext = NewEmptyExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ExpressionContext))

	return p
}

func (s *IncludeExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IncludeExpressionContext) Include() IIncludeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIncludeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIncludeContext)
}

func (s *IncludeExpressionContext) Set_Include_Path() antlr.TerminalNode {
	return s.GetToken(PHPParserSet_Include_Path, 0)
}

func (s *IncludeExpressionContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *IncludeExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PHPParserVisitor:
		return t.VisitIncludeExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

type IndexCallExpressionContext struct {
	*ExpressionContext
}

func NewIndexCallExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *IndexCallExpressionContext {
	var p = new(IndexCallExpressionContext)

	p.ExpressionContext = NewEmptyExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ExpressionContext))

	return p
}

func (s *IndexCallExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IndexCallExpressionContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *IndexCallExpressionContext) OpenSquareBracket() antlr.TerminalNode {
	return s.GetToken(PHPParserOpenSquareBracket, 0)
}

func (s *IndexCallExpressionContext) IndexMemberCallKey() IIndexMemberCallKeyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIndexMemberCallKeyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIndexMemberCallKeyContext)
}

func (s *IndexCallExpressionContext) CloseSquareBracket() antlr.TerminalNode {
	return s.GetToken(PHPParserCloseSquareBracket, 0)
}

func (s *IndexCallExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PHPParserVisitor:
		return t.VisitIndexCallExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

type CodeExecExpressionContext struct {
	*ExpressionContext
}

func NewCodeExecExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CodeExecExpressionContext {
	var p = new(CodeExecExpressionContext)

	p.ExpressionContext = NewEmptyExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ExpressionContext))

	return p
}

func (s *CodeExecExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CodeExecExpressionContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *CodeExecExpressionContext) Eval() antlr.TerminalNode {
	return s.GetToken(PHPParserEval, 0)
}

func (s *CodeExecExpressionContext) Assert() antlr.TerminalNode {
	return s.GetToken(PHPParserAssert, 0)
}

func (s *CodeExecExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PHPParserVisitor:
		return t.VisitCodeExecExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

type CloneExpressionContext struct {
	*ExpressionContext
}

func NewCloneExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CloneExpressionContext {
	var p = new(CloneExpressionContext)

	p.ExpressionContext = NewEmptyExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ExpressionContext))

	return p
}

func (s *CloneExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CloneExpressionContext) Clone() antlr.TerminalNode {
	return s.GetToken(PHPParserClone, 0)
}

func (s *CloneExpressionContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *CloneExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PHPParserVisitor:
		return t.VisitCloneExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

type StaticClassMemberCallAssignmentExpressionContext struct {
	*ExpressionContext
}

func NewStaticClassMemberCallAssignmentExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *StaticClassMemberCallAssignmentExpressionContext {
	var p = new(StaticClassMemberCallAssignmentExpressionContext)

	p.ExpressionContext = NewEmptyExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ExpressionContext))

	return p
}

func (s *StaticClassMemberCallAssignmentExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StaticClassMemberCallAssignmentExpressionContext) StaticClassExprVariableMember() IStaticClassExprVariableMemberContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStaticClassExprVariableMemberContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStaticClassExprVariableMemberContext)
}

func (s *StaticClassMemberCallAssignmentExpressionContext) AssignmentOperator() IAssignmentOperatorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAssignmentOperatorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAssignmentOperatorContext)
}

func (s *StaticClassMemberCallAssignmentExpressionContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *StaticClassMemberCallAssignmentExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PHPParserVisitor:
		return t.VisitStaticClassMemberCallAssignmentExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

type UnaryOperatorExpressionContext struct {
	*ExpressionContext
}

func NewUnaryOperatorExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *UnaryOperatorExpressionContext {
	var p = new(UnaryOperatorExpressionContext)

	p.ExpressionContext = NewEmptyExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ExpressionContext))

	return p
}

func (s *UnaryOperatorExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnaryOperatorExpressionContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *UnaryOperatorExpressionContext) Tilde() antlr.TerminalNode {
	return s.GetToken(PHPParserTilde, 0)
}

func (s *UnaryOperatorExpressionContext) SuppressWarnings() antlr.TerminalNode {
	return s.GetToken(PHPParserSuppressWarnings, 0)
}

func (s *UnaryOperatorExpressionContext) Bang() antlr.TerminalNode {
	return s.GetToken(PHPParserBang, 0)
}

func (s *UnaryOperatorExpressionContext) Plus() antlr.TerminalNode {
	return s.GetToken(PHPParserPlus, 0)
}

func (s *UnaryOperatorExpressionContext) Minus() antlr.TerminalNode {
	return s.GetToken(PHPParserMinus, 0)
}

func (s *UnaryOperatorExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PHPParserVisitor:
		return t.VisitUnaryOperatorExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

type ParenthesisExpressionContext struct {
	*ExpressionContext
}

func NewParenthesisExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ParenthesisExpressionContext {
	var p = new(ParenthesisExpressionContext)

	p.ExpressionContext = NewEmptyExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ExpressionContext))

	return p
}

func (s *ParenthesisExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ParenthesisExpressionContext) OpenRoundBracket() antlr.TerminalNode {
	return s.GetToken(PHPParserOpenRoundBracket, 0)
}

func (s *ParenthesisExpressionContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ParenthesisExpressionContext) CloseRoundBracket() antlr.TerminalNode {
	return s.GetToken(PHPParserCloseRoundBracket, 0)
}

func (s *ParenthesisExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PHPParserVisitor:
		return t.VisitParenthesisExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

type SpaceshipExpressionContext struct {
	*ExpressionContext
	op antlr.Token
}

func NewSpaceshipExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SpaceshipExpressionContext {
	var p = new(SpaceshipExpressionContext)

	p.ExpressionContext = NewEmptyExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ExpressionContext))

	return p
}

func (s *SpaceshipExpressionContext) GetOp() antlr.Token { return s.op }

func (s *SpaceshipExpressionContext) SetOp(v antlr.Token) { s.op = v }

func (s *SpaceshipExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SpaceshipExpressionContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *SpaceshipExpressionContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *SpaceshipExpressionContext) Spaceship() antlr.TerminalNode {
	return s.GetToken(PHPParserSpaceship, 0)
}

func (s *SpaceshipExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PHPParserVisitor:
		return t.VisitSpaceshipExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

type ConditionalExpressionContext struct {
	*ExpressionContext
	op antlr.Token
}

func NewConditionalExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ConditionalExpressionContext {
	var p = new(ConditionalExpressionContext)

	p.ExpressionContext = NewEmptyExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ExpressionContext))

	return p
}

func (s *ConditionalExpressionContext) GetOp() antlr.Token { return s.op }

func (s *ConditionalExpressionContext) SetOp(v antlr.Token) { s.op = v }

func (s *ConditionalExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ConditionalExpressionContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *ConditionalExpressionContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ConditionalExpressionContext) Colon() antlr.TerminalNode {
	return s.GetToken(PHPParserColon, 0)
}

func (s *ConditionalExpressionContext) QuestionMark() antlr.TerminalNode {
	return s.GetToken(PHPParserQuestionMark, 0)
}

func (s *ConditionalExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PHPParserVisitor:
		return t.VisitConditionalExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

type VariableExpressionContext struct {
	*ExpressionContext
}

func NewVariableExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *VariableExpressionContext {
	var p = new(VariableExpressionContext)

	p.ExpressionContext = NewEmptyExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ExpressionContext))

	return p
}

func (s *VariableExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VariableExpressionContext) FlexiVariable() IFlexiVariableContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFlexiVariableContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFlexiVariableContext)
}

func (s *VariableExpressionContext) Ampersand() antlr.TerminalNode {
	return s.GetToken(PHPParserAmpersand, 0)
}

func (s *VariableExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PHPParserVisitor:
		return t.VisitVariableExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

type NullCoalescingExpressionContext struct {
	*ExpressionContext
	op antlr.Token
}

func NewNullCoalescingExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *NullCoalescingExpressionContext {
	var p = new(NullCoalescingExpressionContext)

	p.ExpressionContext = NewEmptyExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ExpressionContext))

	return p
}

func (s *NullCoalescingExpressionContext) GetOp() antlr.Token { return s.op }

func (s *NullCoalescingExpressionContext) SetOp(v antlr.Token) { s.op = v }

func (s *NullCoalescingExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NullCoalescingExpressionContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *NullCoalescingExpressionContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *NullCoalescingExpressionContext) NullCoalescing() antlr.TerminalNode {
	return s.GetToken(PHPParserNullCoalescing, 0)
}

func (s *NullCoalescingExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PHPParserVisitor:
		return t.VisitNullCoalescingExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

type DefinedOrScanDefinedExpressionContext struct {
	*ExpressionContext
}

func NewDefinedOrScanDefinedExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DefinedOrScanDefinedExpressionContext {
	var p = new(DefinedOrScanDefinedExpressionContext)

	p.ExpressionContext = NewEmptyExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ExpressionContext))

	return p
}

func (s *DefinedOrScanDefinedExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DefinedOrScanDefinedExpressionContext) DefineExpr() IDefineExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDefineExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDefineExprContext)
}

func (s *DefinedOrScanDefinedExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PHPParserVisitor:
		return t.VisitDefinedOrScanDefinedExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

type ArithmeticExpressionContext struct {
	*ExpressionContext
	op antlr.Token
}

func NewArithmeticExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ArithmeticExpressionContext {
	var p = new(ArithmeticExpressionContext)

	p.ExpressionContext = NewEmptyExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ExpressionContext))

	return p
}

func (s *ArithmeticExpressionContext) GetOp() antlr.Token { return s.op }

func (s *ArithmeticExpressionContext) SetOp(v antlr.Token) { s.op = v }

func (s *ArithmeticExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArithmeticExpressionContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *ArithmeticExpressionContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ArithmeticExpressionContext) Pow() antlr.TerminalNode {
	return s.GetToken(PHPParserPow, 0)
}

func (s *ArithmeticExpressionContext) Asterisk() antlr.TerminalNode {
	return s.GetToken(PHPParserAsterisk, 0)
}

func (s *ArithmeticExpressionContext) Divide() antlr.TerminalNode {
	return s.GetToken(PHPParserDivide, 0)
}

func (s *ArithmeticExpressionContext) Percent() antlr.TerminalNode {
	return s.GetToken(PHPParserPercent, 0)
}

func (s *ArithmeticExpressionContext) Plus() antlr.TerminalNode {
	return s.GetToken(PHPParserPlus, 0)
}

func (s *ArithmeticExpressionContext) Minus() antlr.TerminalNode {
	return s.GetToken(PHPParserMinus, 0)
}

func (s *ArithmeticExpressionContext) Dot() antlr.TerminalNode {
	return s.GetToken(PHPParserDot, 0)
}

func (s *ArithmeticExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PHPParserVisitor:
		return t.VisitArithmeticExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

type ScalarExpressionContext struct {
	*ExpressionContext
}

func NewScalarExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ScalarExpressionContext {
	var p = new(ScalarExpressionContext)

	p.ExpressionContext = NewEmptyExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ExpressionContext))

	return p
}

func (s *ScalarExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ScalarExpressionContext) Constant() IConstantContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConstantContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConstantContext)
}

func (s *ScalarExpressionContext) String_() IStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *ScalarExpressionContext) Label() antlr.TerminalNode {
	return s.GetToken(PHPParserLabel, 0)
}

func (s *ScalarExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PHPParserVisitor:
		return t.VisitScalarExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

type PrefixIncDecExpressionContext struct {
	*ExpressionContext
}

func NewPrefixIncDecExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *PrefixIncDecExpressionContext {
	var p = new(PrefixIncDecExpressionContext)

	p.ExpressionContext = NewEmptyExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ExpressionContext))

	return p
}

func (s *PrefixIncDecExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrefixIncDecExpressionContext) FlexiVariable() IFlexiVariableContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFlexiVariableContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFlexiVariableContext)
}

func (s *PrefixIncDecExpressionContext) Inc() antlr.TerminalNode {
	return s.GetToken(PHPParserInc, 0)
}

func (s *PrefixIncDecExpressionContext) Dec() antlr.TerminalNode {
	return s.GetToken(PHPParserDec, 0)
}

func (s *PrefixIncDecExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PHPParserVisitor:
		return t.VisitPrefixIncDecExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

type ComparisonExpressionContext struct {
	*ExpressionContext
	op antlr.Token
}

func NewComparisonExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ComparisonExpressionContext {
	var p = new(ComparisonExpressionContext)

	p.ExpressionContext = NewEmptyExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ExpressionContext))

	return p
}

func (s *ComparisonExpressionContext) GetOp() antlr.Token { return s.op }

func (s *ComparisonExpressionContext) SetOp(v antlr.Token) { s.op = v }

func (s *ComparisonExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ComparisonExpressionContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *ComparisonExpressionContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ComparisonExpressionContext) ShiftLeft() antlr.TerminalNode {
	return s.GetToken(PHPParserShiftLeft, 0)
}

func (s *ComparisonExpressionContext) ShiftRight() antlr.TerminalNode {
	return s.GetToken(PHPParserShiftRight, 0)
}

func (s *ComparisonExpressionContext) Less() antlr.TerminalNode {
	return s.GetToken(PHPParserLess, 0)
}

func (s *ComparisonExpressionContext) IsSmallerOrEqual() antlr.TerminalNode {
	return s.GetToken(PHPParserIsSmallerOrEqual, 0)
}

func (s *ComparisonExpressionContext) Greater() antlr.TerminalNode {
	return s.GetToken(PHPParserGreater, 0)
}

func (s *ComparisonExpressionContext) IsGreaterOrEqual() antlr.TerminalNode {
	return s.GetToken(PHPParserIsGreaterOrEqual, 0)
}

func (s *ComparisonExpressionContext) IsIdentical() antlr.TerminalNode {
	return s.GetToken(PHPParserIsIdentical, 0)
}

func (s *ComparisonExpressionContext) IsNoidentical() antlr.TerminalNode {
	return s.GetToken(PHPParserIsNoidentical, 0)
}

func (s *ComparisonExpressionContext) IsEqual() antlr.TerminalNode {
	return s.GetToken(PHPParserIsEqual, 0)
}

func (s *ComparisonExpressionContext) IsNotEq() antlr.TerminalNode {
	return s.GetToken(PHPParserIsNotEq, 0)
}

func (s *ComparisonExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PHPParserVisitor:
		return t.VisitComparisonExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

type IndexLegacyCallExpressionContext struct {
	*ExpressionContext
}

func NewIndexLegacyCallExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *IndexLegacyCallExpressionContext {
	var p = new(IndexLegacyCallExpressionContext)

	p.ExpressionContext = NewEmptyExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ExpressionContext))

	return p
}

func (s *IndexLegacyCallExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IndexLegacyCallExpressionContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *IndexLegacyCallExpressionContext) OpenCurlyBracket() antlr.TerminalNode {
	return s.GetToken(PHPParserOpenCurlyBracket, 0)
}

func (s *IndexLegacyCallExpressionContext) IndexMemberCallKey() IIndexMemberCallKeyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIndexMemberCallKeyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIndexMemberCallKeyContext)
}

func (s *IndexLegacyCallExpressionContext) CloseCurlyBracket() antlr.TerminalNode {
	return s.GetToken(PHPParserCloseCurlyBracket, 0)
}

func (s *IndexLegacyCallExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PHPParserVisitor:
		return t.VisitIndexLegacyCallExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

type OrdinaryAssignmentExpressionContext struct {
	*ExpressionContext
}

func NewOrdinaryAssignmentExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *OrdinaryAssignmentExpressionContext {
	var p = new(OrdinaryAssignmentExpressionContext)

	p.ExpressionContext = NewEmptyExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ExpressionContext))

	return p
}

func (s *OrdinaryAssignmentExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OrdinaryAssignmentExpressionContext) FlexiVariable() IFlexiVariableContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFlexiVariableContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFlexiVariableContext)
}

func (s *OrdinaryAssignmentExpressionContext) AssignmentOperator() IAssignmentOperatorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAssignmentOperatorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAssignmentOperatorContext)
}

func (s *OrdinaryAssignmentExpressionContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *OrdinaryAssignmentExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PHPParserVisitor:
		return t.VisitOrdinaryAssignmentExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

type CastExpressionContext struct {
	*ExpressionContext
}

func NewCastExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CastExpressionContext {
	var p = new(CastExpressionContext)

	p.ExpressionContext = NewEmptyExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ExpressionContext))

	return p
}

func (s *CastExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CastExpressionContext) OpenRoundBracket() antlr.TerminalNode {
	return s.GetToken(PHPParserOpenRoundBracket, 0)
}

func (s *CastExpressionContext) CastOperation() ICastOperationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICastOperationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICastOperationContext)
}

func (s *CastExpressionContext) CloseRoundBracket() antlr.TerminalNode {
	return s.GetToken(PHPParserCloseRoundBracket, 0)
}

func (s *CastExpressionContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *CastExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PHPParserVisitor:
		return t.VisitCastExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

type InstanceOfExpressionContext struct {
	*ExpressionContext
}

func NewInstanceOfExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *InstanceOfExpressionContext {
	var p = new(InstanceOfExpressionContext)

	p.ExpressionContext = NewEmptyExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ExpressionContext))

	return p
}

func (s *InstanceOfExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InstanceOfExpressionContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *InstanceOfExpressionContext) InstanceOf() antlr.TerminalNode {
	return s.GetToken(PHPParserInstanceOf, 0)
}

func (s *InstanceOfExpressionContext) TypeRef() ITypeRefContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeRefContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeRefContext)
}

func (s *InstanceOfExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PHPParserVisitor:
		return t.VisitInstanceOfExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

type LambdaFunctionExpressionContext struct {
	*ExpressionContext
}

func NewLambdaFunctionExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LambdaFunctionExpressionContext {
	var p = new(LambdaFunctionExpressionContext)

	p.ExpressionContext = NewEmptyExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ExpressionContext))

	return p
}

func (s *LambdaFunctionExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LambdaFunctionExpressionContext) LambdaFunctionExpr() ILambdaFunctionExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILambdaFunctionExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILambdaFunctionExprContext)
}

func (s *LambdaFunctionExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PHPParserVisitor:
		return t.VisitLambdaFunctionExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

type BitwiseExpressionContext struct {
	*ExpressionContext
	op antlr.Token
}

func NewBitwiseExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *BitwiseExpressionContext {
	var p = new(BitwiseExpressionContext)

	p.ExpressionContext = NewEmptyExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ExpressionContext))

	return p
}

func (s *BitwiseExpressionContext) GetOp() antlr.Token { return s.op }

func (s *BitwiseExpressionContext) SetOp(v antlr.Token) { s.op = v }

func (s *BitwiseExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BitwiseExpressionContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *BitwiseExpressionContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *BitwiseExpressionContext) Ampersand() antlr.TerminalNode {
	return s.GetToken(PHPParserAmpersand, 0)
}

func (s *BitwiseExpressionContext) Caret() antlr.TerminalNode {
	return s.GetToken(PHPParserCaret, 0)
}

func (s *BitwiseExpressionContext) Pipe() antlr.TerminalNode {
	return s.GetToken(PHPParserPipe, 0)
}

func (s *BitwiseExpressionContext) BooleanAnd() antlr.TerminalNode {
	return s.GetToken(PHPParserBooleanAnd, 0)
}

func (s *BitwiseExpressionContext) BooleanOr() antlr.TerminalNode {
	return s.GetToken(PHPParserBooleanOr, 0)
}

func (s *BitwiseExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PHPParserVisitor:
		return t.VisitBitwiseExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

type FullyQualifiedNamespaceExpressionContext struct {
	*ExpressionContext
}

func NewFullyQualifiedNamespaceExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *FullyQualifiedNamespaceExpressionContext {
	var p = new(FullyQualifiedNamespaceExpressionContext)

	p.ExpressionContext = NewEmptyExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ExpressionContext))

	return p
}

func (s *FullyQualifiedNamespaceExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FullyQualifiedNamespaceExpressionContext) FullyQualifiedNamespaceExpr() IFullyQualifiedNamespaceExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFullyQualifiedNamespaceExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFullyQualifiedNamespaceExprContext)
}

func (s *FullyQualifiedNamespaceExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PHPParserVisitor:
		return t.VisitFullyQualifiedNamespaceExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

type StaticClassAccessExpressionContext struct {
	*ExpressionContext
}

func NewStaticClassAccessExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *StaticClassAccessExpressionContext {
	var p = new(StaticClassAccessExpressionContext)

	p.ExpressionContext = NewEmptyExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ExpressionContext))

	return p
}

func (s *StaticClassAccessExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StaticClassAccessExpressionContext) StaticClassExpr() IStaticClassExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStaticClassExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStaticClassExprContext)
}

func (s *StaticClassAccessExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PHPParserVisitor:
		return t.VisitStaticClassAccessExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PHPParser) Expression() (localctx IExpressionContext) {
	return p.expression(0)
}

func (p *PHPParser) expression(_p int) (localctx IExpressionContext) {
	this := p
	_ = this

	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()
	_parentState := p.GetState()
	localctx = NewExpressionContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IExpressionContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 180
	p.EnterRecursionRule(localctx, 180, PHPParserRULE_expression, _p)
	var _la int

	defer func() {
		p.UnrollRecursionContexts(_parentctx)
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1364)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 145, p.GetParserRuleContext()) {
	case 1:
		localctx = NewCloneExpressionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx

		{
			p.SetState(1281)
			p.Match(PHPParserClone)
		}
		{
			p.SetState(1282)
			p.expression(54)
		}

	case 2:
		localctx = NewKeywordNewExpressionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1283)
			p.NewExpr()
		}

	case 3:
		localctx = NewFullyQualifiedNamespaceExpressionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1284)
			p.FullyQualifiedNamespaceExpr()
		}

	case 4:
		localctx = NewShortQualifiedNameExpressionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1285)
			p.Identifier()
		}

	case 5:
		localctx = NewStaticClassAccessExpressionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1286)
			p.StaticClassExpr()
		}

	case 6:
		localctx = NewVariableExpressionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		p.SetState(1288)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == PHPParserAmpersand {
			{
				p.SetState(1287)
				p.Match(PHPParserAmpersand)
			}

		}
		{
			p.SetState(1290)
			p.flexiVariable(0)
		}

	case 7:
		localctx = NewArrayCreationExpressionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1291)
			p.ArrayCreation()
		}

	case 8:
		localctx = NewScalarExpressionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1292)
			p.Constant()
		}

	case 9:
		localctx = NewScalarExpressionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1293)
			p.String_()
		}

	case 10:
		localctx = NewDefinedOrScanDefinedExpressionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1294)
			p.DefineExpr()
		}

	case 11:
		localctx = NewPrintExpressionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1295)
			p.Match(PHPParserPrint)
		}
		{
			p.SetState(1296)
			p.expression(41)
		}

	case 12:
		localctx = NewScalarExpressionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1297)
			p.Match(PHPParserLabel)
		}

	case 13:
		localctx = NewBackQuoteStringExpressionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1298)
			p.Match(PHPParserBackQuoteString)
		}

	case 14:
		localctx = NewParenthesisExpressionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1299)
			p.Match(PHPParserOpenRoundBracket)
		}
		{
			p.SetState(1300)
			p.expression(0)
		}
		{
			p.SetState(1301)
			p.Match(PHPParserCloseRoundBracket)
		}

	case 15:
		localctx = NewIncludeExpressionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1303)
			p.Include()
		}

	case 16:
		localctx = NewIncludeExpressionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1304)
			p.Match(PHPParserSet_Include_Path)
		}
		{
			p.SetState(1305)
			p.expression(36)
		}

	case 17:
		localctx = NewSpecialWordExpressionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1306)
			p.Match(PHPParserYield)
		}

	case 18:
		localctx = NewSpecialWordExpressionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1307)
			p.Match(PHPParserList)
		}
		{
			p.SetState(1308)
			p.Match(PHPParserOpenRoundBracket)
		}
		{
			p.SetState(1309)
			p.AssignmentList()
		}
		{
			p.SetState(1310)
			p.Match(PHPParserCloseRoundBracket)
		}
		{
			p.SetState(1311)
			p.Match(PHPParserEq)
		}
		{
			p.SetState(1312)
			p.expression(34)
		}

	case 19:
		localctx = NewSpecialWordExpressionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1314)
			p.Match(PHPParserIsSet)
		}
		{
			p.SetState(1315)
			p.Match(PHPParserOpenRoundBracket)
		}
		{
			p.SetState(1316)
			p.ChainList()
		}
		{
			p.SetState(1317)
			p.Match(PHPParserCloseRoundBracket)
		}

	case 20:
		localctx = NewSpecialWordExpressionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1319)
			p.Match(PHPParserEmpty)
		}
		{
			p.SetState(1320)
			p.Match(PHPParserOpenRoundBracket)
		}
		{
			p.SetState(1321)
			p.Chain()
		}
		{
			p.SetState(1322)
			p.Match(PHPParserCloseRoundBracket)
		}

	case 21:
		localctx = NewSpecialWordExpressionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1324)
			_la = p.GetTokenStream().LA(1)

			if !(_la == PHPParserDie || _la == PHPParserExit) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		p.SetState(1330)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 144, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1325)
				p.Match(PHPParserOpenRoundBracket)
			}
			p.SetState(1327)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if (int64((_la-44)) & ^0x3f) == 0 && ((int64(1)<<(_la-44))&-1) != 0 || (int64((_la-108)) & ^0x3f) == 0 && ((int64(1)<<(_la-108))&1873497444977737727) != 0 || (int64((_la-196)) & ^0x3f) == 0 && ((int64(1)<<(_la-196))&8795020649297) != 0 {
				{
					p.SetState(1326)
					p.expression(0)
				}

			}
			{
				p.SetState(1329)
				p.Match(PHPParserCloseRoundBracket)
			}

		}

	case 22:
		localctx = NewCodeExecExpressionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1332)
			_la = p.GetTokenStream().LA(1)

			if !(_la == PHPParserEval || _la == PHPParserAssert) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(1333)
			p.expression(30)
		}

	case 23:
		localctx = NewSpecialWordExpressionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1334)
			p.Match(PHPParserThrow)
		}
		{
			p.SetState(1335)
			p.expression(29)
		}

	case 24:
		localctx = NewLambdaFunctionExpressionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1336)
			p.LambdaFunctionExpr()
		}

	case 25:
		localctx = NewMatchExpressionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1337)
			p.MatchExpr()
		}

	case 26:
		localctx = NewCastExpressionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1338)
			p.Match(PHPParserOpenRoundBracket)
		}
		{
			p.SetState(1339)
			p.CastOperation()
		}
		{
			p.SetState(1340)
			p.Match(PHPParserCloseRoundBracket)
		}
		{
			p.SetState(1341)
			p.expression(26)
		}

	case 27:
		localctx = NewUnaryOperatorExpressionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1343)
			_la = p.GetTokenStream().LA(1)

			if !(_la == PHPParserTilde || _la == PHPParserSuppressWarnings) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(1344)
			p.expression(25)
		}

	case 28:
		localctx = NewUnaryOperatorExpressionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1345)
			_la = p.GetTokenStream().LA(1)

			if !((int64((_la-202)) & ^0x3f) == 0 && ((int64(1)<<(_la-202))&13) != 0) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(1346)
			p.expression(24)
		}

	case 29:
		localctx = NewPrefixIncDecExpressionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1347)
			_la = p.GetTokenStream().LA(1)

			if !(_la == PHPParserInc || _la == PHPParserDec) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(1348)
			p.flexiVariable(0)
		}

	case 30:
		localctx = NewPostfixIncDecExpressionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1349)
			p.flexiVariable(0)
		}
		{
			p.SetState(1350)
			_la = p.GetTokenStream().LA(1)

			if !(_la == PHPParserInc || _la == PHPParserDec) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case 31:
		localctx = NewArrayCreationUnpackExpressionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1352)
			p.LeftArrayCreation()
		}
		{
			p.SetState(1353)
			p.Match(PHPParserEq)
		}
		{
			p.SetState(1354)
			p.expression(6)
		}

	case 32:
		localctx = NewStaticClassMemberCallAssignmentExpressionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1356)
			p.StaticClassExprVariableMember()
		}
		{
			p.SetState(1357)
			p.AssignmentOperator()
		}
		{
			p.SetState(1358)
			p.expression(5)
		}

	case 33:
		localctx = NewOrdinaryAssignmentExpressionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1360)
			p.flexiVariable(0)
		}
		{
			p.SetState(1361)
			p.AssignmentOperator()
		}
		{
			p.SetState(1362)
			p.expression(4)
		}

	}
	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(1438)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 148, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			p.SetState(1436)
			p.GetErrorHandler().Sync(p)
			switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 147, p.GetParserRuleContext()) {
			case 1:
				localctx = NewArithmeticExpressionContext(p, NewExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, PHPParserRULE_expression)
				p.SetState(1366)

				if !(p.Precpred(p.GetParserRuleContext(), 21)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 21)", ""))
				}
				{
					p.SetState(1367)

					var _m = p.Match(PHPParserPow)

					localctx.(*ArithmeticExpressionContext).op = _m
				}
				{
					p.SetState(1368)
					p.expression(21)
				}

			case 2:
				localctx = NewArithmeticExpressionContext(p, NewExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, PHPParserRULE_expression)
				p.SetState(1369)

				if !(p.Precpred(p.GetParserRuleContext(), 19)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 19)", ""))
				}
				{
					p.SetState(1370)

					var _lt = p.GetTokenStream().LT(1)

					localctx.(*ArithmeticExpressionContext).op = _lt

					_la = p.GetTokenStream().LA(1)

					if !((int64((_la-206)) & ^0x3f) == 0 && ((int64(1)<<(_la-206))&7) != 0) {
						var _ri = p.GetErrorHandler().RecoverInline(p)

						localctx.(*ArithmeticExpressionContext).op = _ri
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				{
					p.SetState(1371)
					p.expression(20)
				}

			case 3:
				localctx = NewArithmeticExpressionContext(p, NewExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, PHPParserRULE_expression)
				p.SetState(1372)

				if !(p.Precpred(p.GetParserRuleContext(), 18)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 18)", ""))
				}
				{
					p.SetState(1373)

					var _lt = p.GetTokenStream().LT(1)

					localctx.(*ArithmeticExpressionContext).op = _lt

					_la = p.GetTokenStream().LA(1)

					if !((int64((_la-204)) & ^0x3f) == 0 && ((int64(1)<<(_la-204))&259) != 0) {
						var _ri = p.GetErrorHandler().RecoverInline(p)

						localctx.(*ArithmeticExpressionContext).op = _ri
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				{
					p.SetState(1374)
					p.expression(19)
				}

			case 4:
				localctx = NewComparisonExpressionContext(p, NewExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, PHPParserRULE_expression)
				p.SetState(1375)

				if !(p.Precpred(p.GetParserRuleContext(), 17)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 17)", ""))
				}
				{
					p.SetState(1376)

					var _lt = p.GetTokenStream().LT(1)

					localctx.(*ComparisonExpressionContext).op = _lt

					_la = p.GetTokenStream().LA(1)

					if !(_la == PHPParserShiftLeft || _la == PHPParserShiftRight) {
						var _ri = p.GetErrorHandler().RecoverInline(p)

						localctx.(*ComparisonExpressionContext).op = _ri
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				{
					p.SetState(1377)
					p.expression(18)
				}

			case 5:
				localctx = NewComparisonExpressionContext(p, NewExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, PHPParserRULE_expression)
				p.SetState(1378)

				if !(p.Precpred(p.GetParserRuleContext(), 16)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 16)", ""))
				}
				{
					p.SetState(1379)

					var _lt = p.GetTokenStream().LT(1)

					localctx.(*ComparisonExpressionContext).op = _lt

					_la = p.GetTokenStream().LA(1)

					if !((int64((_la-173)) & ^0x3f) == 0 && ((int64(1)<<(_la-173))&100663299) != 0) {
						var _ri = p.GetErrorHandler().RecoverInline(p)

						localctx.(*ComparisonExpressionContext).op = _ri
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				{
					p.SetState(1380)
					p.expression(17)
				}

			case 6:
				localctx = NewComparisonExpressionContext(p, NewExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, PHPParserRULE_expression)
				p.SetState(1381)

				if !(p.Precpred(p.GetParserRuleContext(), 15)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 15)", ""))
				}
				{
					p.SetState(1382)

					var _lt = p.GetTokenStream().LT(1)

					localctx.(*ComparisonExpressionContext).op = _lt

					_la = p.GetTokenStream().LA(1)

					if !((int64((_la-169)) & ^0x3f) == 0 && ((int64(1)<<(_la-169))&15) != 0) {
						var _ri = p.GetErrorHandler().RecoverInline(p)

						localctx.(*ComparisonExpressionContext).op = _ri
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				{
					p.SetState(1383)
					p.expression(16)
				}

			case 7:
				localctx = NewBitwiseExpressionContext(p, NewExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, PHPParserRULE_expression)
				p.SetState(1384)

				if !(p.Precpred(p.GetParserRuleContext(), 14)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 14)", ""))
				}
				{
					p.SetState(1385)

					var _m = p.Match(PHPParserAmpersand)

					localctx.(*BitwiseExpressionContext).op = _m
				}
				{
					p.SetState(1386)
					p.expression(15)
				}

			case 8:
				localctx = NewBitwiseExpressionContext(p, NewExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, PHPParserRULE_expression)
				p.SetState(1387)

				if !(p.Precpred(p.GetParserRuleContext(), 13)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 13)", ""))
				}
				{
					p.SetState(1388)

					var _m = p.Match(PHPParserCaret)

					localctx.(*BitwiseExpressionContext).op = _m
				}
				{
					p.SetState(1389)
					p.expression(14)
				}

			case 9:
				localctx = NewBitwiseExpressionContext(p, NewExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, PHPParserRULE_expression)
				p.SetState(1390)

				if !(p.Precpred(p.GetParserRuleContext(), 12)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 12)", ""))
				}
				{
					p.SetState(1391)

					var _m = p.Match(PHPParserPipe)

					localctx.(*BitwiseExpressionContext).op = _m
				}
				{
					p.SetState(1392)
					p.expression(13)
				}

			case 10:
				localctx = NewBitwiseExpressionContext(p, NewExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, PHPParserRULE_expression)
				p.SetState(1393)

				if !(p.Precpred(p.GetParserRuleContext(), 11)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 11)", ""))
				}
				{
					p.SetState(1394)

					var _m = p.Match(PHPParserBooleanAnd)

					localctx.(*BitwiseExpressionContext).op = _m
				}
				{
					p.SetState(1395)
					p.expression(12)
				}

			case 11:
				localctx = NewBitwiseExpressionContext(p, NewExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, PHPParserRULE_expression)
				p.SetState(1396)

				if !(p.Precpred(p.GetParserRuleContext(), 10)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 10)", ""))
				}
				{
					p.SetState(1397)

					var _m = p.Match(PHPParserBooleanOr)

					localctx.(*BitwiseExpressionContext).op = _m
				}
				{
					p.SetState(1398)
					p.expression(11)
				}

			case 12:
				localctx = NewConditionalExpressionContext(p, NewExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, PHPParserRULE_expression)
				p.SetState(1399)

				if !(p.Precpred(p.GetParserRuleContext(), 9)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 9)", ""))
				}
				{
					p.SetState(1400)

					var _m = p.Match(PHPParserQuestionMark)

					localctx.(*ConditionalExpressionContext).op = _m
				}
				p.SetState(1402)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)

				if (int64((_la-44)) & ^0x3f) == 0 && ((int64(1)<<(_la-44))&-1) != 0 || (int64((_la-108)) & ^0x3f) == 0 && ((int64(1)<<(_la-108))&1873497444977737727) != 0 || (int64((_la-196)) & ^0x3f) == 0 && ((int64(1)<<(_la-196))&8795020649297) != 0 {
					{
						p.SetState(1401)
						p.expression(0)
					}

				}
				{
					p.SetState(1404)
					p.Match(PHPParserColon)
				}
				{
					p.SetState(1405)
					p.expression(10)
				}

			case 13:
				localctx = NewNullCoalescingExpressionContext(p, NewExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, PHPParserRULE_expression)
				p.SetState(1406)

				if !(p.Precpred(p.GetParserRuleContext(), 8)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 8)", ""))
				}
				{
					p.SetState(1407)

					var _m = p.Match(PHPParserNullCoalescing)

					localctx.(*NullCoalescingExpressionContext).op = _m
				}
				{
					p.SetState(1408)
					p.expression(9)
				}

			case 14:
				localctx = NewSpaceshipExpressionContext(p, NewExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, PHPParserRULE_expression)
				p.SetState(1409)

				if !(p.Precpred(p.GetParserRuleContext(), 7)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 7)", ""))
				}
				{
					p.SetState(1410)

					var _m = p.Match(PHPParserSpaceship)

					localctx.(*SpaceshipExpressionContext).op = _m
				}
				{
					p.SetState(1411)
					p.expression(8)
				}

			case 15:
				localctx = NewLogicalExpressionContext(p, NewExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, PHPParserRULE_expression)
				p.SetState(1412)

				if !(p.Precpred(p.GetParserRuleContext(), 3)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 3)", ""))
				}
				{
					p.SetState(1413)

					var _m = p.Match(PHPParserLogicalAnd)

					localctx.(*LogicalExpressionContext).op = _m
				}
				{
					p.SetState(1414)
					p.expression(4)
				}

			case 16:
				localctx = NewLogicalExpressionContext(p, NewExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, PHPParserRULE_expression)
				p.SetState(1415)

				if !(p.Precpred(p.GetParserRuleContext(), 2)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 2)", ""))
				}
				{
					p.SetState(1416)

					var _m = p.Match(PHPParserLogicalXor)

					localctx.(*LogicalExpressionContext).op = _m
				}
				{
					p.SetState(1417)
					p.expression(3)
				}

			case 17:
				localctx = NewLogicalExpressionContext(p, NewExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, PHPParserRULE_expression)
				p.SetState(1418)

				if !(p.Precpred(p.GetParserRuleContext(), 1)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 1)", ""))
				}
				{
					p.SetState(1419)

					var _m = p.Match(PHPParserLogicalOr)

					localctx.(*LogicalExpressionContext).op = _m
				}
				{
					p.SetState(1420)
					p.expression(2)
				}

			case 18:
				localctx = NewIndexCallExpressionContext(p, NewExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, PHPParserRULE_expression)
				p.SetState(1421)

				if !(p.Precpred(p.GetParserRuleContext(), 51)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 51)", ""))
				}
				{
					p.SetState(1422)
					p.Match(PHPParserOpenSquareBracket)
				}
				{
					p.SetState(1423)
					p.IndexMemberCallKey()
				}
				{
					p.SetState(1424)
					p.Match(PHPParserCloseSquareBracket)
				}

			case 19:
				localctx = NewIndexLegacyCallExpressionContext(p, NewExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, PHPParserRULE_expression)
				p.SetState(1426)

				if !(p.Precpred(p.GetParserRuleContext(), 50)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 50)", ""))
				}
				{
					p.SetState(1427)
					p.Match(PHPParserOpenCurlyBracket)
				}
				{
					p.SetState(1428)
					p.IndexMemberCallKey()
				}
				{
					p.SetState(1429)
					p.Match(PHPParserCloseCurlyBracket)
				}

			case 20:
				localctx = NewFunctionCallExpressionContext(p, NewExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, PHPParserRULE_expression)
				p.SetState(1431)

				if !(p.Precpred(p.GetParserRuleContext(), 49)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 49)", ""))
				}
				{
					p.SetState(1432)
					p.Arguments()
				}

			case 21:
				localctx = NewInstanceOfExpressionContext(p, NewExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, PHPParserRULE_expression)
				p.SetState(1433)

				if !(p.Precpred(p.GetParserRuleContext(), 20)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 20)", ""))
				}
				{
					p.SetState(1434)
					p.Match(PHPParserInstanceOf)
				}
				{
					p.SetState(1435)
					p.TypeRef()
				}

			}

		}
		p.SetState(1440)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 148, p.GetParserRuleContext())
	}

	return localctx
}

// IFlexiVariableContext is an interface to support dynamic dispatch.
type IFlexiVariableContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFlexiVariableContext differentiates from other interfaces.
	IsFlexiVariableContext()
}

type FlexiVariableContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFlexiVariableContext() *FlexiVariableContext {
	var p = new(FlexiVariableContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PHPParserRULE_flexiVariable
	return p
}

func (*FlexiVariableContext) IsFlexiVariableContext() {}

func NewFlexiVariableContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FlexiVariableContext {
	var p = new(FlexiVariableContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PHPParserRULE_flexiVariable

	return p
}

func (s *FlexiVariableContext) GetParser() antlr.Parser { return s.parser }

func (s *FlexiVariableContext) CopyFrom(ctx *FlexiVariableContext) {
	s.BaseParserRuleContext.CopyFrom(ctx.BaseParserRuleContext)
}

func (s *FlexiVariableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FlexiVariableContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type IndexLegacyCallVariableContext struct {
	*FlexiVariableContext
}

func NewIndexLegacyCallVariableContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *IndexLegacyCallVariableContext {
	var p = new(IndexLegacyCallVariableContext)

	p.FlexiVariableContext = NewEmptyFlexiVariableContext()
	p.parser = parser
	p.CopyFrom(ctx.(*FlexiVariableContext))

	return p
}

func (s *IndexLegacyCallVariableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IndexLegacyCallVariableContext) FlexiVariable() IFlexiVariableContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFlexiVariableContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFlexiVariableContext)
}

func (s *IndexLegacyCallVariableContext) OpenCurlyBracket() antlr.TerminalNode {
	return s.GetToken(PHPParserOpenCurlyBracket, 0)
}

func (s *IndexLegacyCallVariableContext) CloseCurlyBracket() antlr.TerminalNode {
	return s.GetToken(PHPParserCloseCurlyBracket, 0)
}

func (s *IndexLegacyCallVariableContext) IndexMemberCallKey() IIndexMemberCallKeyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIndexMemberCallKeyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIndexMemberCallKeyContext)
}

func (s *IndexLegacyCallVariableContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PHPParserVisitor:
		return t.VisitIndexLegacyCallVariable(s)

	default:
		return t.VisitChildren(s)
	}
}

type IndexVariableContext struct {
	*FlexiVariableContext
}

func NewIndexVariableContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *IndexVariableContext {
	var p = new(IndexVariableContext)

	p.FlexiVariableContext = NewEmptyFlexiVariableContext()
	p.parser = parser
	p.CopyFrom(ctx.(*FlexiVariableContext))

	return p
}

func (s *IndexVariableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IndexVariableContext) FlexiVariable() IFlexiVariableContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFlexiVariableContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFlexiVariableContext)
}

func (s *IndexVariableContext) OpenSquareBracket() antlr.TerminalNode {
	return s.GetToken(PHPParserOpenSquareBracket, 0)
}

func (s *IndexVariableContext) CloseSquareBracket() antlr.TerminalNode {
	return s.GetToken(PHPParserCloseSquareBracket, 0)
}

func (s *IndexVariableContext) IndexMemberCallKey() IIndexMemberCallKeyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIndexMemberCallKeyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIndexMemberCallKeyContext)
}

func (s *IndexVariableContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PHPParserVisitor:
		return t.VisitIndexVariable(s)

	default:
		return t.VisitChildren(s)
	}
}

type CustomVariableContext struct {
	*FlexiVariableContext
}

func NewCustomVariableContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CustomVariableContext {
	var p = new(CustomVariableContext)

	p.FlexiVariableContext = NewEmptyFlexiVariableContext()
	p.parser = parser
	p.CopyFrom(ctx.(*FlexiVariableContext))

	return p
}

func (s *CustomVariableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CustomVariableContext) Variable() IVariableContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVariableContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVariableContext)
}

func (s *CustomVariableContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PHPParserVisitor:
		return t.VisitCustomVariable(s)

	default:
		return t.VisitChildren(s)
	}
}

type MemberVariableContext struct {
	*FlexiVariableContext
}

func NewMemberVariableContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *MemberVariableContext {
	var p = new(MemberVariableContext)

	p.FlexiVariableContext = NewEmptyFlexiVariableContext()
	p.parser = parser
	p.CopyFrom(ctx.(*FlexiVariableContext))

	return p
}

func (s *MemberVariableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MemberVariableContext) FlexiVariable() IFlexiVariableContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFlexiVariableContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFlexiVariableContext)
}

func (s *MemberVariableContext) ObjectOperator() antlr.TerminalNode {
	return s.GetToken(PHPParserObjectOperator, 0)
}

func (s *MemberVariableContext) MemberCallKey() IMemberCallKeyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMemberCallKeyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMemberCallKeyContext)
}

func (s *MemberVariableContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PHPParserVisitor:
		return t.VisitMemberVariable(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PHPParser) FlexiVariable() (localctx IFlexiVariableContext) {
	return p.flexiVariable(0)
}

func (p *PHPParser) flexiVariable(_p int) (localctx IFlexiVariableContext) {
	this := p
	_ = this

	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()
	_parentState := p.GetState()
	localctx = NewFlexiVariableContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IFlexiVariableContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 182
	p.EnterRecursionRule(localctx, 182, PHPParserRULE_flexiVariable, _p)
	var _la int

	defer func() {
		p.UnrollRecursionContexts(_parentctx)
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	localctx = NewCustomVariableContext(p, localctx)
	p.SetParserRuleContext(localctx)
	_prevctx = localctx

	{
		p.SetState(1442)
		p.Variable()
	}

	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(1461)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 152, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			p.SetState(1459)
			p.GetErrorHandler().Sync(p)
			switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 151, p.GetParserRuleContext()) {
			case 1:
				localctx = NewIndexVariableContext(p, NewFlexiVariableContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, PHPParserRULE_flexiVariable)
				p.SetState(1444)

				if !(p.Precpred(p.GetParserRuleContext(), 3)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 3)", ""))
				}
				{
					p.SetState(1445)
					p.Match(PHPParserOpenSquareBracket)
				}
				p.SetState(1447)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)

				if (int64((_la-44)) & ^0x3f) == 0 && ((int64(1)<<(_la-44))&-1) != 0 || (int64((_la-108)) & ^0x3f) == 0 && ((int64(1)<<(_la-108))&1873497444977737727) != 0 || (int64((_la-196)) & ^0x3f) == 0 && ((int64(1)<<(_la-196))&8795020649297) != 0 {
					{
						p.SetState(1446)
						p.IndexMemberCallKey()
					}

				}
				{
					p.SetState(1449)
					p.Match(PHPParserCloseSquareBracket)
				}

			case 2:
				localctx = NewIndexLegacyCallVariableContext(p, NewFlexiVariableContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, PHPParserRULE_flexiVariable)
				p.SetState(1450)

				if !(p.Precpred(p.GetParserRuleContext(), 2)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 2)", ""))
				}
				{
					p.SetState(1451)
					p.Match(PHPParserOpenCurlyBracket)
				}
				p.SetState(1453)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)

				if (int64((_la-44)) & ^0x3f) == 0 && ((int64(1)<<(_la-44))&-1) != 0 || (int64((_la-108)) & ^0x3f) == 0 && ((int64(1)<<(_la-108))&1873497444977737727) != 0 || (int64((_la-196)) & ^0x3f) == 0 && ((int64(1)<<(_la-196))&8795020649297) != 0 {
					{
						p.SetState(1452)
						p.IndexMemberCallKey()
					}

				}
				{
					p.SetState(1455)
					p.Match(PHPParserCloseCurlyBracket)
				}

			case 3:
				localctx = NewMemberVariableContext(p, NewFlexiVariableContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, PHPParserRULE_flexiVariable)
				p.SetState(1456)

				if !(p.Precpred(p.GetParserRuleContext(), 1)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 1)", ""))
				}
				{
					p.SetState(1457)
					p.Match(PHPParserObjectOperator)
				}
				{
					p.SetState(1458)
					p.MemberCallKey()
				}

			}

		}
		p.SetState(1463)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 152, p.GetParserRuleContext())
	}

	return localctx
}

// IDefineExprContext is an interface to support dynamic dispatch.
type IDefineExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDefineExprContext differentiates from other interfaces.
	IsDefineExprContext()
}

type DefineExprContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDefineExprContext() *DefineExprContext {
	var p = new(DefineExprContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PHPParserRULE_defineExpr
	return p
}

func (*DefineExprContext) IsDefineExprContext() {}

func NewDefineExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DefineExprContext {
	var p = new(DefineExprContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PHPParserRULE_defineExpr

	return p
}

func (s *DefineExprContext) GetParser() antlr.Parser { return s.parser }

func (s *DefineExprContext) Define() antlr.TerminalNode {
	return s.GetToken(PHPParserDefine, 0)
}

func (s *DefineExprContext) OpenRoundBracket() antlr.TerminalNode {
	return s.GetToken(PHPParserOpenRoundBracket, 0)
}

func (s *DefineExprContext) ConstantString() IConstantStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConstantStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConstantStringContext)
}

func (s *DefineExprContext) Comma() antlr.TerminalNode {
	return s.GetToken(PHPParserComma, 0)
}

func (s *DefineExprContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *DefineExprContext) CloseRoundBracket() antlr.TerminalNode {
	return s.GetToken(PHPParserCloseRoundBracket, 0)
}

func (s *DefineExprContext) Defined() antlr.TerminalNode {
	return s.GetToken(PHPParserDefined, 0)
}

func (s *DefineExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DefineExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DefineExprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PHPParserVisitor:
		return t.VisitDefineExpr(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PHPParser) DefineExpr() (localctx IDefineExprContext) {
	this := p
	_ = this

	localctx = NewDefineExprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 184, PHPParserRULE_defineExpr)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1476)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case PHPParserDefine:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1464)
			p.Match(PHPParserDefine)
		}
		{
			p.SetState(1465)
			p.Match(PHPParserOpenRoundBracket)
		}
		{
			p.SetState(1466)
			p.ConstantString()
		}
		{
			p.SetState(1467)
			p.Match(PHPParserComma)
		}
		{
			p.SetState(1468)
			p.expression(0)
		}
		{
			p.SetState(1469)
			p.Match(PHPParserCloseRoundBracket)
		}

	case PHPParserDefined:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1471)
			p.Match(PHPParserDefined)
		}
		{
			p.SetState(1472)
			p.Match(PHPParserOpenRoundBracket)
		}
		{
			p.SetState(1473)
			p.ConstantString()
		}
		{
			p.SetState(1474)
			p.Match(PHPParserCloseRoundBracket)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IVariableContext is an interface to support dynamic dispatch.
type IVariableContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsVariableContext differentiates from other interfaces.
	IsVariableContext()
}

type VariableContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVariableContext() *VariableContext {
	var p = new(VariableContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PHPParserRULE_variable
	return p
}

func (*VariableContext) IsVariableContext() {}

func NewVariableContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *VariableContext {
	var p = new(VariableContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PHPParserRULE_variable

	return p
}

func (s *VariableContext) GetParser() antlr.Parser { return s.parser }

func (s *VariableContext) CopyFrom(ctx *VariableContext) {
	s.BaseParserRuleContext.CopyFrom(ctx.BaseParserRuleContext)
}

func (s *VariableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VariableContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type NormalVariableContext struct {
	*VariableContext
}

func NewNormalVariableContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *NormalVariableContext {
	var p = new(NormalVariableContext)

	p.VariableContext = NewEmptyVariableContext()
	p.parser = parser
	p.CopyFrom(ctx.(*VariableContext))

	return p
}

func (s *NormalVariableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NormalVariableContext) VarName() antlr.TerminalNode {
	return s.GetToken(PHPParserVarName, 0)
}

func (s *NormalVariableContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PHPParserVisitor:
		return t.VisitNormalVariable(s)

	default:
		return t.VisitChildren(s)
	}
}

type DynamicVariableContext struct {
	*VariableContext
}

func NewDynamicVariableContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DynamicVariableContext {
	var p = new(DynamicVariableContext)

	p.VariableContext = NewEmptyVariableContext()
	p.parser = parser
	p.CopyFrom(ctx.(*VariableContext))

	return p
}

func (s *DynamicVariableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DynamicVariableContext) VarName() antlr.TerminalNode {
	return s.GetToken(PHPParserVarName, 0)
}

func (s *DynamicVariableContext) AllDollar() []antlr.TerminalNode {
	return s.GetTokens(PHPParserDollar)
}

func (s *DynamicVariableContext) Dollar(i int) antlr.TerminalNode {
	return s.GetToken(PHPParserDollar, i)
}

func (s *DynamicVariableContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PHPParserVisitor:
		return t.VisitDynamicVariable(s)

	default:
		return t.VisitChildren(s)
	}
}

type MemberCallVariableContext struct {
	*VariableContext
}

func NewMemberCallVariableContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *MemberCallVariableContext {
	var p = new(MemberCallVariableContext)

	p.VariableContext = NewEmptyVariableContext()
	p.parser = parser
	p.CopyFrom(ctx.(*VariableContext))

	return p
}

func (s *MemberCallVariableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MemberCallVariableContext) OpenCurlyBracket() antlr.TerminalNode {
	return s.GetToken(PHPParserOpenCurlyBracket, 0)
}

func (s *MemberCallVariableContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *MemberCallVariableContext) CloseCurlyBracket() antlr.TerminalNode {
	return s.GetToken(PHPParserCloseCurlyBracket, 0)
}

func (s *MemberCallVariableContext) AllDollar() []antlr.TerminalNode {
	return s.GetTokens(PHPParserDollar)
}

func (s *MemberCallVariableContext) Dollar(i int) antlr.TerminalNode {
	return s.GetToken(PHPParserDollar, i)
}

func (s *MemberCallVariableContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PHPParserVisitor:
		return t.VisitMemberCallVariable(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PHPParser) Variable() (localctx IVariableContext) {
	this := p
	_ = this

	localctx = NewVariableContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 186, PHPParserRULE_variable)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1494)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 156, p.GetParserRuleContext()) {
	case 1:
		localctx = NewNormalVariableContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1478)
			p.Match(PHPParserVarName)
		}

	case 2:
		localctx = NewDynamicVariableContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		p.SetState(1480)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for ok := true; ok; ok = _la == PHPParserDollar {
			{
				p.SetState(1479)
				p.Match(PHPParserDollar)
			}

			p.SetState(1482)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1484)
			p.Match(PHPParserVarName)
		}

	case 3:
		localctx = NewMemberCallVariableContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		p.SetState(1486)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for ok := true; ok; ok = _la == PHPParserDollar {
			{
				p.SetState(1485)
				p.Match(PHPParserDollar)
			}

			p.SetState(1488)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1490)
			p.Match(PHPParserOpenCurlyBracket)
		}
		{
			p.SetState(1491)
			p.expression(0)
		}
		{
			p.SetState(1492)
			p.Match(PHPParserCloseCurlyBracket)
		}

	}

	return localctx
}

// IIncludeContext is an interface to support dynamic dispatch.
type IIncludeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsIncludeContext differentiates from other interfaces.
	IsIncludeContext()
}

type IncludeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIncludeContext() *IncludeContext {
	var p = new(IncludeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PHPParserRULE_include
	return p
}

func (*IncludeContext) IsIncludeContext() {}

func NewIncludeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IncludeContext {
	var p = new(IncludeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PHPParserRULE_include

	return p
}

func (s *IncludeContext) GetParser() antlr.Parser { return s.parser }

func (s *IncludeContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *IncludeContext) Include() antlr.TerminalNode {
	return s.GetToken(PHPParserInclude, 0)
}

func (s *IncludeContext) IncludeOnce() antlr.TerminalNode {
	return s.GetToken(PHPParserIncludeOnce, 0)
}

func (s *IncludeContext) Require() antlr.TerminalNode {
	return s.GetToken(PHPParserRequire, 0)
}

func (s *IncludeContext) RequireOnce() antlr.TerminalNode {
	return s.GetToken(PHPParserRequireOnce, 0)
}

func (s *IncludeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IncludeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IncludeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PHPParserVisitor:
		return t.VisitInclude(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PHPParser) Include() (localctx IIncludeContext) {
	this := p
	_ = this

	localctx = NewIncludeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 188, PHPParserRULE_include)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1496)
		_la = p.GetTokenStream().LA(1)

		if !((int64((_la-92)) & ^0x3f) == 0 && ((int64(1)<<(_la-92))&201326595) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(1497)
		p.expression(0)
	}

	return localctx
}

// ILeftArrayCreationContext is an interface to support dynamic dispatch.
type ILeftArrayCreationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLeftArrayCreationContext differentiates from other interfaces.
	IsLeftArrayCreationContext()
}

type LeftArrayCreationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLeftArrayCreationContext() *LeftArrayCreationContext {
	var p = new(LeftArrayCreationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PHPParserRULE_leftArrayCreation
	return p
}

func (*LeftArrayCreationContext) IsLeftArrayCreationContext() {}

func NewLeftArrayCreationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LeftArrayCreationContext {
	var p = new(LeftArrayCreationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PHPParserRULE_leftArrayCreation

	return p
}

func (s *LeftArrayCreationContext) GetParser() antlr.Parser { return s.parser }

func (s *LeftArrayCreationContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *LeftArrayCreationContext) OpenRoundBracket() antlr.TerminalNode {
	return s.GetToken(PHPParserOpenRoundBracket, 0)
}

func (s *LeftArrayCreationContext) CloseRoundBracket() antlr.TerminalNode {
	return s.GetToken(PHPParserCloseRoundBracket, 0)
}

func (s *LeftArrayCreationContext) ArrayItemList() IArrayItemListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArrayItemListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArrayItemListContext)
}

func (s *LeftArrayCreationContext) ArrayDestructuring() IArrayDestructuringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArrayDestructuringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArrayDestructuringContext)
}

func (s *LeftArrayCreationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LeftArrayCreationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LeftArrayCreationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PHPParserVisitor:
		return t.VisitLeftArrayCreation(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PHPParser) LeftArrayCreation() (localctx ILeftArrayCreationContext) {
	this := p
	_ = this

	localctx = NewLeftArrayCreationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 190, PHPParserRULE_leftArrayCreation)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1507)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case PHPParserAbstract, PHPParserArray, PHPParserAs, PHPParserBinaryCast, PHPParserBoolType, PHPParserBooleanConstant, PHPParserBreak, PHPParserCallable, PHPParserCase, PHPParserCatch, PHPParserClass, PHPParserClone, PHPParserConst, PHPParserContinue, PHPParserDeclare, PHPParserDefault, PHPParserDo, PHPParserDoubleCast, PHPParserDoubleType, PHPParserEcho, PHPParserElse, PHPParserElseIf, PHPParserEmpty, PHPParserEnum_, PHPParserEndDeclare, PHPParserEndFor, PHPParserEndForeach, PHPParserEndIf, PHPParserEndSwitch, PHPParserEndWhile, PHPParserExtends, PHPParserFinal, PHPParserFinally, PHPParserFloatCast, PHPParserFor, PHPParserForeach, PHPParserFunction_, PHPParserGlobal, PHPParserGoto, PHPParserIf, PHPParserImplements, PHPParserImport, PHPParserInstanceOf, PHPParserInsteadOf, PHPParserInt8Cast, PHPParserInt16Cast, PHPParserInt64Type, PHPParserIntType, PHPParserInterface, PHPParserList, PHPParserLogicalAnd, PHPParserLogicalOr, PHPParserLogicalXor, PHPParserMatch_, PHPParserNamespace, PHPParserNew, PHPParserNull, PHPParserObjectType, PHPParserParent_, PHPParserPartial, PHPParserPrint, PHPParserPrivate, PHPParserProtected, PHPParserPublic, PHPParserReadonly, PHPParserResource, PHPParserReturn, PHPParserStatic, PHPParserStringType, PHPParserSwitch, PHPParserTrait, PHPParserTry, PHPParserTypeof, PHPParserUintCast, PHPParserUnicodeCast, PHPParserUse, PHPParserVar, PHPParserWhile, PHPParserYield, PHPParserFrom, PHPParserLambdaFn, PHPParserTicks, PHPParserEncoding, PHPParserStrictTypes, PHPParserGet, PHPParserSet, PHPParserCall, PHPParserCallStatic, PHPParserConstructor, PHPParserDestruct, PHPParserWakeup, PHPParserSleep, PHPParserAutoload, PHPParserIsSet__, PHPParserUnset__, PHPParserToString__, PHPParserInvoke, PHPParserSetState, PHPParserClone__, PHPParserDebugInfo, PHPParserNamespace__, PHPParserClass__, PHPParserTraic__, PHPParserFunction__, PHPParserMethod__, PHPParserLine__, PHPParserFile__, PHPParserDir__, PHPParserNamespaceSeparator, PHPParserLabel:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1499)
			p.Identifier()
		}
		{
			p.SetState(1500)
			p.Match(PHPParserOpenRoundBracket)
		}
		p.SetState(1502)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if (int64((_la-44)) & ^0x3f) == 0 && ((int64(1)<<(_la-44))&-1) != 0 || (int64((_la-108)) & ^0x3f) == 0 && ((int64(1)<<(_la-108))&1873497444977737727) != 0 || (int64((_la-196)) & ^0x3f) == 0 && ((int64(1)<<(_la-196))&8795020649297) != 0 {
			{
				p.SetState(1501)
				p.ArrayItemList()
			}

		}
		{
			p.SetState(1504)
			p.Match(PHPParserCloseRoundBracket)
		}

	case PHPParserOpenSquareBracket:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1506)
			p.ArrayDestructuring()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IAssignableContext is an interface to support dynamic dispatch.
type IAssignableContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAssignableContext differentiates from other interfaces.
	IsAssignableContext()
}

type AssignableContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAssignableContext() *AssignableContext {
	var p = new(AssignableContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PHPParserRULE_assignable
	return p
}

func (*AssignableContext) IsAssignableContext() {}

func NewAssignableContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AssignableContext {
	var p = new(AssignableContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PHPParserRULE_assignable

	return p
}

func (s *AssignableContext) GetParser() antlr.Parser { return s.parser }

func (s *AssignableContext) Chain() IChainContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IChainContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IChainContext)
}

func (s *AssignableContext) ArrayCreation() IArrayCreationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArrayCreationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArrayCreationContext)
}

func (s *AssignableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AssignableContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AssignableContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PHPParserVisitor:
		return t.VisitAssignable(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PHPParser) Assignable() (localctx IAssignableContext) {
	this := p
	_ = this

	localctx = NewAssignableContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 192, PHPParserRULE_assignable)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1511)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 159, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1509)
			p.Chain()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1510)
			p.ArrayCreation()
		}

	}

	return localctx
}

// IArrayCreationContext is an interface to support dynamic dispatch.
type IArrayCreationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsArrayCreationContext differentiates from other interfaces.
	IsArrayCreationContext()
}

type ArrayCreationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyArrayCreationContext() *ArrayCreationContext {
	var p = new(ArrayCreationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PHPParserRULE_arrayCreation
	return p
}

func (*ArrayCreationContext) IsArrayCreationContext() {}

func NewArrayCreationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ArrayCreationContext {
	var p = new(ArrayCreationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PHPParserRULE_arrayCreation

	return p
}

func (s *ArrayCreationContext) GetParser() antlr.Parser { return s.parser }

func (s *ArrayCreationContext) Array() antlr.TerminalNode {
	return s.GetToken(PHPParserArray, 0)
}

func (s *ArrayCreationContext) OpenRoundBracket() antlr.TerminalNode {
	return s.GetToken(PHPParserOpenRoundBracket, 0)
}

func (s *ArrayCreationContext) CloseRoundBracket() antlr.TerminalNode {
	return s.GetToken(PHPParserCloseRoundBracket, 0)
}

func (s *ArrayCreationContext) ArrayItemList() IArrayItemListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArrayItemListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArrayItemListContext)
}

func (s *ArrayCreationContext) List() antlr.TerminalNode {
	return s.GetToken(PHPParserList, 0)
}

func (s *ArrayCreationContext) OpenSquareBracket() antlr.TerminalNode {
	return s.GetToken(PHPParserOpenSquareBracket, 0)
}

func (s *ArrayCreationContext) CloseSquareBracket() antlr.TerminalNode {
	return s.GetToken(PHPParserCloseSquareBracket, 0)
}

func (s *ArrayCreationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArrayCreationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ArrayCreationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PHPParserVisitor:
		return t.VisitArrayCreation(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PHPParser) ArrayCreation() (localctx IArrayCreationContext) {
	this := p
	_ = this

	localctx = NewArrayCreationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 194, PHPParserRULE_arrayCreation)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1530)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case PHPParserArray:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1513)
			p.Match(PHPParserArray)
		}
		{
			p.SetState(1514)
			p.Match(PHPParserOpenRoundBracket)
		}
		p.SetState(1516)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if (int64((_la-44)) & ^0x3f) == 0 && ((int64(1)<<(_la-44))&-1) != 0 || (int64((_la-108)) & ^0x3f) == 0 && ((int64(1)<<(_la-108))&1873497444977737727) != 0 || (int64((_la-196)) & ^0x3f) == 0 && ((int64(1)<<(_la-196))&8795020649297) != 0 {
			{
				p.SetState(1515)
				p.ArrayItemList()
			}

		}
		{
			p.SetState(1518)
			p.Match(PHPParserCloseRoundBracket)
		}

	case PHPParserList:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1519)
			p.Match(PHPParserList)
		}
		{
			p.SetState(1520)
			p.Match(PHPParserOpenRoundBracket)
		}
		p.SetState(1522)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if (int64((_la-44)) & ^0x3f) == 0 && ((int64(1)<<(_la-44))&-1) != 0 || (int64((_la-108)) & ^0x3f) == 0 && ((int64(1)<<(_la-108))&1873497444977737727) != 0 || (int64((_la-196)) & ^0x3f) == 0 && ((int64(1)<<(_la-196))&8795020649297) != 0 {
			{
				p.SetState(1521)
				p.ArrayItemList()
			}

		}
		{
			p.SetState(1524)
			p.Match(PHPParserCloseRoundBracket)
		}

	case PHPParserOpenSquareBracket:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1525)
			p.Match(PHPParserOpenSquareBracket)
		}
		p.SetState(1527)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if (int64((_la-44)) & ^0x3f) == 0 && ((int64(1)<<(_la-44))&-1) != 0 || (int64((_la-108)) & ^0x3f) == 0 && ((int64(1)<<(_la-108))&1873497444977737727) != 0 || (int64((_la-196)) & ^0x3f) == 0 && ((int64(1)<<(_la-196))&8795020649297) != 0 {
			{
				p.SetState(1526)
				p.ArrayItemList()
			}

		}
		{
			p.SetState(1529)
			p.Match(PHPParserCloseSquareBracket)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IArrayDestructuringContext is an interface to support dynamic dispatch.
type IArrayDestructuringContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsArrayDestructuringContext differentiates from other interfaces.
	IsArrayDestructuringContext()
}

type ArrayDestructuringContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyArrayDestructuringContext() *ArrayDestructuringContext {
	var p = new(ArrayDestructuringContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PHPParserRULE_arrayDestructuring
	return p
}

func (*ArrayDestructuringContext) IsArrayDestructuringContext() {}

func NewArrayDestructuringContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ArrayDestructuringContext {
	var p = new(ArrayDestructuringContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PHPParserRULE_arrayDestructuring

	return p
}

func (s *ArrayDestructuringContext) GetParser() antlr.Parser { return s.parser }

func (s *ArrayDestructuringContext) OpenSquareBracket() antlr.TerminalNode {
	return s.GetToken(PHPParserOpenSquareBracket, 0)
}

func (s *ArrayDestructuringContext) AllIndexedDestructItem() []IIndexedDestructItemContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIndexedDestructItemContext); ok {
			len++
		}
	}

	tst := make([]IIndexedDestructItemContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIndexedDestructItemContext); ok {
			tst[i] = t.(IIndexedDestructItemContext)
			i++
		}
	}

	return tst
}

func (s *ArrayDestructuringContext) IndexedDestructItem(i int) IIndexedDestructItemContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIndexedDestructItemContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIndexedDestructItemContext)
}

func (s *ArrayDestructuringContext) CloseSquareBracket() antlr.TerminalNode {
	return s.GetToken(PHPParserCloseSquareBracket, 0)
}

func (s *ArrayDestructuringContext) AllComma() []antlr.TerminalNode {
	return s.GetTokens(PHPParserComma)
}

func (s *ArrayDestructuringContext) Comma(i int) antlr.TerminalNode {
	return s.GetToken(PHPParserComma, i)
}

func (s *ArrayDestructuringContext) AllKeyedDestructItem() []IKeyedDestructItemContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IKeyedDestructItemContext); ok {
			len++
		}
	}

	tst := make([]IKeyedDestructItemContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IKeyedDestructItemContext); ok {
			tst[i] = t.(IKeyedDestructItemContext)
			i++
		}
	}

	return tst
}

func (s *ArrayDestructuringContext) KeyedDestructItem(i int) IKeyedDestructItemContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKeyedDestructItemContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKeyedDestructItemContext)
}

func (s *ArrayDestructuringContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArrayDestructuringContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ArrayDestructuringContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PHPParserVisitor:
		return t.VisitArrayDestructuring(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PHPParser) ArrayDestructuring() (localctx IArrayDestructuringContext) {
	this := p
	_ = this

	localctx = NewArrayDestructuringContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 196, PHPParserRULE_arrayDestructuring)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.SetState(1577)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 171, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1532)
			p.Match(PHPParserOpenSquareBracket)
		}
		p.SetState(1536)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == PHPParserComma {
			{
				p.SetState(1533)
				p.Match(PHPParserComma)
			}

			p.SetState(1538)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1539)
			p.IndexedDestructItem()
		}
		p.SetState(1548)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 166, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				p.SetState(1541)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)

				for ok := true; ok; ok = _la == PHPParserComma {
					{
						p.SetState(1540)
						p.Match(PHPParserComma)
					}

					p.SetState(1543)
					p.GetErrorHandler().Sync(p)
					_la = p.GetTokenStream().LA(1)
				}
				{
					p.SetState(1545)
					p.IndexedDestructItem()
				}

			}
			p.SetState(1550)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 166, p.GetParserRuleContext())
		}
		p.SetState(1554)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == PHPParserComma {
			{
				p.SetState(1551)
				p.Match(PHPParserComma)
			}

			p.SetState(1556)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1557)
			p.Match(PHPParserCloseSquareBracket)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1559)
			p.Match(PHPParserOpenSquareBracket)
		}
		{
			p.SetState(1560)
			p.KeyedDestructItem()
		}
		p.SetState(1569)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 169, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				p.SetState(1562)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)

				for ok := true; ok; ok = _la == PHPParserComma {
					{
						p.SetState(1561)
						p.Match(PHPParserComma)
					}

					p.SetState(1564)
					p.GetErrorHandler().Sync(p)
					_la = p.GetTokenStream().LA(1)
				}
				{
					p.SetState(1566)
					p.KeyedDestructItem()
				}

			}
			p.SetState(1571)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 169, p.GetParserRuleContext())
		}
		p.SetState(1573)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == PHPParserComma {
			{
				p.SetState(1572)
				p.Match(PHPParserComma)
			}

		}
		{
			p.SetState(1575)
			p.Match(PHPParserCloseSquareBracket)
		}

	}

	return localctx
}

// IIndexedDestructItemContext is an interface to support dynamic dispatch.
type IIndexedDestructItemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsIndexedDestructItemContext differentiates from other interfaces.
	IsIndexedDestructItemContext()
}

type IndexedDestructItemContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIndexedDestructItemContext() *IndexedDestructItemContext {
	var p = new(IndexedDestructItemContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PHPParserRULE_indexedDestructItem
	return p
}

func (*IndexedDestructItemContext) IsIndexedDestructItemContext() {}

func NewIndexedDestructItemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IndexedDestructItemContext {
	var p = new(IndexedDestructItemContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PHPParserRULE_indexedDestructItem

	return p
}

func (s *IndexedDestructItemContext) GetParser() antlr.Parser { return s.parser }

func (s *IndexedDestructItemContext) Chain() IChainContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IChainContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IChainContext)
}

func (s *IndexedDestructItemContext) Ampersand() antlr.TerminalNode {
	return s.GetToken(PHPParserAmpersand, 0)
}

func (s *IndexedDestructItemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IndexedDestructItemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IndexedDestructItemContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PHPParserVisitor:
		return t.VisitIndexedDestructItem(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PHPParser) IndexedDestructItem() (localctx IIndexedDestructItemContext) {
	this := p
	_ = this

	localctx = NewIndexedDestructItemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 198, PHPParserRULE_indexedDestructItem)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1580)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == PHPParserAmpersand {
		{
			p.SetState(1579)
			p.Match(PHPParserAmpersand)
		}

	}
	{
		p.SetState(1582)
		p.Chain()
	}

	return localctx
}

// IKeyedDestructItemContext is an interface to support dynamic dispatch.
type IKeyedDestructItemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsKeyedDestructItemContext differentiates from other interfaces.
	IsKeyedDestructItemContext()
}

type KeyedDestructItemContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKeyedDestructItemContext() *KeyedDestructItemContext {
	var p = new(KeyedDestructItemContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PHPParserRULE_keyedDestructItem
	return p
}

func (*KeyedDestructItemContext) IsKeyedDestructItemContext() {}

func NewKeyedDestructItemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *KeyedDestructItemContext {
	var p = new(KeyedDestructItemContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PHPParserRULE_keyedDestructItem

	return p
}

func (s *KeyedDestructItemContext) GetParser() antlr.Parser { return s.parser }

func (s *KeyedDestructItemContext) Chain() IChainContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IChainContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IChainContext)
}

func (s *KeyedDestructItemContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *KeyedDestructItemContext) DoubleArrow() antlr.TerminalNode {
	return s.GetToken(PHPParserDoubleArrow, 0)
}

func (s *KeyedDestructItemContext) Ampersand() antlr.TerminalNode {
	return s.GetToken(PHPParserAmpersand, 0)
}

func (s *KeyedDestructItemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KeyedDestructItemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *KeyedDestructItemContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PHPParserVisitor:
		return t.VisitKeyedDestructItem(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PHPParser) KeyedDestructItem() (localctx IKeyedDestructItemContext) {
	this := p
	_ = this

	localctx = NewKeyedDestructItemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 200, PHPParserRULE_keyedDestructItem)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1587)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 173, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1584)
			p.expression(0)
		}
		{
			p.SetState(1585)
			p.Match(PHPParserDoubleArrow)
		}

	}
	p.SetState(1590)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == PHPParserAmpersand {
		{
			p.SetState(1589)
			p.Match(PHPParserAmpersand)
		}

	}
	{
		p.SetState(1592)
		p.Chain()
	}

	return localctx
}

// ILambdaFunctionExprContext is an interface to support dynamic dispatch.
type ILambdaFunctionExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLambdaFunctionExprContext differentiates from other interfaces.
	IsLambdaFunctionExprContext()
}

type LambdaFunctionExprContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLambdaFunctionExprContext() *LambdaFunctionExprContext {
	var p = new(LambdaFunctionExprContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PHPParserRULE_lambdaFunctionExpr
	return p
}

func (*LambdaFunctionExprContext) IsLambdaFunctionExprContext() {}

func NewLambdaFunctionExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LambdaFunctionExprContext {
	var p = new(LambdaFunctionExprContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PHPParserRULE_lambdaFunctionExpr

	return p
}

func (s *LambdaFunctionExprContext) GetParser() antlr.Parser { return s.parser }

func (s *LambdaFunctionExprContext) Function_() antlr.TerminalNode {
	return s.GetToken(PHPParserFunction_, 0)
}

func (s *LambdaFunctionExprContext) OpenRoundBracket() antlr.TerminalNode {
	return s.GetToken(PHPParserOpenRoundBracket, 0)
}

func (s *LambdaFunctionExprContext) FormalParameterList() IFormalParameterListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFormalParameterListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFormalParameterListContext)
}

func (s *LambdaFunctionExprContext) CloseRoundBracket() antlr.TerminalNode {
	return s.GetToken(PHPParserCloseRoundBracket, 0)
}

func (s *LambdaFunctionExprContext) BlockStatement() IBlockStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBlockStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBlockStatementContext)
}

func (s *LambdaFunctionExprContext) Static() antlr.TerminalNode {
	return s.GetToken(PHPParserStatic, 0)
}

func (s *LambdaFunctionExprContext) Ampersand() antlr.TerminalNode {
	return s.GetToken(PHPParserAmpersand, 0)
}

func (s *LambdaFunctionExprContext) LambdaFunctionUseVars() ILambdaFunctionUseVarsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILambdaFunctionUseVarsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILambdaFunctionUseVarsContext)
}

func (s *LambdaFunctionExprContext) Colon() antlr.TerminalNode {
	return s.GetToken(PHPParserColon, 0)
}

func (s *LambdaFunctionExprContext) TypeHint() ITypeHintContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeHintContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeHintContext)
}

func (s *LambdaFunctionExprContext) LambdaFn() antlr.TerminalNode {
	return s.GetToken(PHPParserLambdaFn, 0)
}

func (s *LambdaFunctionExprContext) DoubleArrow() antlr.TerminalNode {
	return s.GetToken(PHPParserDoubleArrow, 0)
}

func (s *LambdaFunctionExprContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *LambdaFunctionExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LambdaFunctionExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LambdaFunctionExprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PHPParserVisitor:
		return t.VisitLambdaFunctionExpr(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PHPParser) LambdaFunctionExpr() (localctx ILambdaFunctionExprContext) {
	this := p
	_ = this

	localctx = NewLambdaFunctionExprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 202, PHPParserRULE_lambdaFunctionExpr)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1620)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case PHPParserFunction_, PHPParserStatic:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(1595)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == PHPParserStatic {
			{
				p.SetState(1594)
				p.Match(PHPParserStatic)
			}

		}
		{
			p.SetState(1597)
			p.Match(PHPParserFunction_)
		}
		p.SetState(1599)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == PHPParserAmpersand {
			{
				p.SetState(1598)
				p.Match(PHPParserAmpersand)
			}

		}
		{
			p.SetState(1601)
			p.Match(PHPParserOpenRoundBracket)
		}
		{
			p.SetState(1602)
			p.FormalParameterList()
		}
		{
			p.SetState(1603)
			p.Match(PHPParserCloseRoundBracket)
		}
		p.SetState(1605)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == PHPParserUse {
			{
				p.SetState(1604)
				p.LambdaFunctionUseVars()
			}

		}
		p.SetState(1609)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == PHPParserColon {
			{
				p.SetState(1607)
				p.Match(PHPParserColon)
			}
			{
				p.SetState(1608)
				p.typeHint(0)
			}

		}
		{
			p.SetState(1611)
			p.BlockStatement()
		}

	case PHPParserLambdaFn:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1613)
			p.Match(PHPParserLambdaFn)
		}
		{
			p.SetState(1614)
			p.Match(PHPParserOpenRoundBracket)
		}
		{
			p.SetState(1615)
			p.FormalParameterList()
		}
		{
			p.SetState(1616)
			p.Match(PHPParserCloseRoundBracket)
		}
		{
			p.SetState(1617)
			p.Match(PHPParserDoubleArrow)
		}
		{
			p.SetState(1618)
			p.expression(0)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IMatchExprContext is an interface to support dynamic dispatch.
type IMatchExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMatchExprContext differentiates from other interfaces.
	IsMatchExprContext()
}

type MatchExprContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMatchExprContext() *MatchExprContext {
	var p = new(MatchExprContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PHPParserRULE_matchExpr
	return p
}

func (*MatchExprContext) IsMatchExprContext() {}

func NewMatchExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MatchExprContext {
	var p = new(MatchExprContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PHPParserRULE_matchExpr

	return p
}

func (s *MatchExprContext) GetParser() antlr.Parser { return s.parser }

func (s *MatchExprContext) Match_() antlr.TerminalNode {
	return s.GetToken(PHPParserMatch_, 0)
}

func (s *MatchExprContext) OpenRoundBracket() antlr.TerminalNode {
	return s.GetToken(PHPParserOpenRoundBracket, 0)
}

func (s *MatchExprContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *MatchExprContext) CloseRoundBracket() antlr.TerminalNode {
	return s.GetToken(PHPParserCloseRoundBracket, 0)
}

func (s *MatchExprContext) OpenCurlyBracket() antlr.TerminalNode {
	return s.GetToken(PHPParserOpenCurlyBracket, 0)
}

func (s *MatchExprContext) AllMatchItem() []IMatchItemContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IMatchItemContext); ok {
			len++
		}
	}

	tst := make([]IMatchItemContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IMatchItemContext); ok {
			tst[i] = t.(IMatchItemContext)
			i++
		}
	}

	return tst
}

func (s *MatchExprContext) MatchItem(i int) IMatchItemContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMatchItemContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMatchItemContext)
}

func (s *MatchExprContext) CloseCurlyBracket() antlr.TerminalNode {
	return s.GetToken(PHPParserCloseCurlyBracket, 0)
}

func (s *MatchExprContext) AllComma() []antlr.TerminalNode {
	return s.GetTokens(PHPParserComma)
}

func (s *MatchExprContext) Comma(i int) antlr.TerminalNode {
	return s.GetToken(PHPParserComma, i)
}

func (s *MatchExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MatchExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MatchExprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PHPParserVisitor:
		return t.VisitMatchExpr(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PHPParser) MatchExpr() (localctx IMatchExprContext) {
	this := p
	_ = this

	localctx = NewMatchExprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 204, PHPParserRULE_matchExpr)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1622)
		p.Match(PHPParserMatch_)
	}
	{
		p.SetState(1623)
		p.Match(PHPParserOpenRoundBracket)
	}
	{
		p.SetState(1624)
		p.expression(0)
	}
	{
		p.SetState(1625)
		p.Match(PHPParserCloseRoundBracket)
	}
	{
		p.SetState(1626)
		p.Match(PHPParserOpenCurlyBracket)
	}
	{
		p.SetState(1627)
		p.MatchItem()
	}
	p.SetState(1632)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 180, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1628)
				p.Match(PHPParserComma)
			}
			{
				p.SetState(1629)
				p.MatchItem()
			}

		}
		p.SetState(1634)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 180, p.GetParserRuleContext())
	}
	p.SetState(1636)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == PHPParserComma {
		{
			p.SetState(1635)
			p.Match(PHPParserComma)
		}

	}
	{
		p.SetState(1638)
		p.Match(PHPParserCloseCurlyBracket)
	}

	return localctx
}

// IMatchItemContext is an interface to support dynamic dispatch.
type IMatchItemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMatchItemContext differentiates from other interfaces.
	IsMatchItemContext()
}

type MatchItemContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMatchItemContext() *MatchItemContext {
	var p = new(MatchItemContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PHPParserRULE_matchItem
	return p
}

func (*MatchItemContext) IsMatchItemContext() {}

func NewMatchItemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MatchItemContext {
	var p = new(MatchItemContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PHPParserRULE_matchItem

	return p
}

func (s *MatchItemContext) GetParser() antlr.Parser { return s.parser }

func (s *MatchItemContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *MatchItemContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *MatchItemContext) DoubleArrow() antlr.TerminalNode {
	return s.GetToken(PHPParserDoubleArrow, 0)
}

func (s *MatchItemContext) AllComma() []antlr.TerminalNode {
	return s.GetTokens(PHPParserComma)
}

func (s *MatchItemContext) Comma(i int) antlr.TerminalNode {
	return s.GetToken(PHPParserComma, i)
}

func (s *MatchItemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MatchItemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MatchItemContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PHPParserVisitor:
		return t.VisitMatchItem(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PHPParser) MatchItem() (localctx IMatchItemContext) {
	this := p
	_ = this

	localctx = NewMatchItemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 206, PHPParserRULE_matchItem)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1640)
		p.expression(0)
	}
	p.SetState(1645)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == PHPParserComma {
		{
			p.SetState(1641)
			p.Match(PHPParserComma)
		}
		{
			p.SetState(1642)
			p.expression(0)
		}

		p.SetState(1647)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1648)
		p.Match(PHPParserDoubleArrow)
	}
	{
		p.SetState(1649)
		p.expression(0)
	}

	return localctx
}

// INewExprContext is an interface to support dynamic dispatch.
type INewExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsNewExprContext differentiates from other interfaces.
	IsNewExprContext()
}

type NewExprContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNewExprContext() *NewExprContext {
	var p = new(NewExprContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PHPParserRULE_newExpr
	return p
}

func (*NewExprContext) IsNewExprContext() {}

func NewNewExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NewExprContext {
	var p = new(NewExprContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PHPParserRULE_newExpr

	return p
}

func (s *NewExprContext) GetParser() antlr.Parser { return s.parser }

func (s *NewExprContext) New() antlr.TerminalNode {
	return s.GetToken(PHPParserNew, 0)
}

func (s *NewExprContext) AnonymousClass() IAnonymousClassContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAnonymousClassContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAnonymousClassContext)
}

func (s *NewExprContext) TypeRef() ITypeRefContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeRefContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeRefContext)
}

func (s *NewExprContext) Arguments() IArgumentsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArgumentsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArgumentsContext)
}

func (s *NewExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NewExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NewExprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PHPParserVisitor:
		return t.VisitNewExpr(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PHPParser) NewExpr() (localctx INewExprContext) {
	this := p
	_ = this

	localctx = NewNewExprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 208, PHPParserRULE_newExpr)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1658)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 184, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1651)
			p.Match(PHPParserNew)
		}
		{
			p.SetState(1652)
			p.AnonymousClass()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1653)
			p.Match(PHPParserNew)
		}
		{
			p.SetState(1654)
			p.TypeRef()
		}
		p.SetState(1656)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 183, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1655)
				p.Arguments()
			}

		}

	}

	return localctx
}

// IAssignmentOperatorContext is an interface to support dynamic dispatch.
type IAssignmentOperatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAssignmentOperatorContext differentiates from other interfaces.
	IsAssignmentOperatorContext()
}

type AssignmentOperatorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAssignmentOperatorContext() *AssignmentOperatorContext {
	var p = new(AssignmentOperatorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PHPParserRULE_assignmentOperator
	return p
}

func (*AssignmentOperatorContext) IsAssignmentOperatorContext() {}

func NewAssignmentOperatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AssignmentOperatorContext {
	var p = new(AssignmentOperatorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PHPParserRULE_assignmentOperator

	return p
}

func (s *AssignmentOperatorContext) GetParser() antlr.Parser { return s.parser }

func (s *AssignmentOperatorContext) Eq() antlr.TerminalNode {
	return s.GetToken(PHPParserEq, 0)
}

func (s *AssignmentOperatorContext) PlusEqual() antlr.TerminalNode {
	return s.GetToken(PHPParserPlusEqual, 0)
}

func (s *AssignmentOperatorContext) MinusEqual() antlr.TerminalNode {
	return s.GetToken(PHPParserMinusEqual, 0)
}

func (s *AssignmentOperatorContext) MulEqual() antlr.TerminalNode {
	return s.GetToken(PHPParserMulEqual, 0)
}

func (s *AssignmentOperatorContext) PowEqual() antlr.TerminalNode {
	return s.GetToken(PHPParserPowEqual, 0)
}

func (s *AssignmentOperatorContext) DivEqual() antlr.TerminalNode {
	return s.GetToken(PHPParserDivEqual, 0)
}

func (s *AssignmentOperatorContext) Concaequal() antlr.TerminalNode {
	return s.GetToken(PHPParserConcaequal, 0)
}

func (s *AssignmentOperatorContext) ModEqual() antlr.TerminalNode {
	return s.GetToken(PHPParserModEqual, 0)
}

func (s *AssignmentOperatorContext) AndEqual() antlr.TerminalNode {
	return s.GetToken(PHPParserAndEqual, 0)
}

func (s *AssignmentOperatorContext) OrEqual() antlr.TerminalNode {
	return s.GetToken(PHPParserOrEqual, 0)
}

func (s *AssignmentOperatorContext) XorEqual() antlr.TerminalNode {
	return s.GetToken(PHPParserXorEqual, 0)
}

func (s *AssignmentOperatorContext) ShiftLeftEqual() antlr.TerminalNode {
	return s.GetToken(PHPParserShiftLeftEqual, 0)
}

func (s *AssignmentOperatorContext) ShiftRightEqual() antlr.TerminalNode {
	return s.GetToken(PHPParserShiftRightEqual, 0)
}

func (s *AssignmentOperatorContext) NullCoalescingEqual() antlr.TerminalNode {
	return s.GetToken(PHPParserNullCoalescingEqual, 0)
}

func (s *AssignmentOperatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AssignmentOperatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AssignmentOperatorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PHPParserVisitor:
		return t.VisitAssignmentOperator(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PHPParser) AssignmentOperator() (localctx IAssignmentOperatorContext) {
	this := p
	_ = this

	localctx = NewAssignmentOperatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 210, PHPParserRULE_assignmentOperator)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1660)
		_la = p.GetTokenStream().LA(1)

		if !((int64((_la-175)) & ^0x3f) == 0 && ((int64(1)<<(_la-175))&281474976784375) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IYieldExpressionContext is an interface to support dynamic dispatch.
type IYieldExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsYieldExpressionContext differentiates from other interfaces.
	IsYieldExpressionContext()
}

type YieldExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyYieldExpressionContext() *YieldExpressionContext {
	var p = new(YieldExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PHPParserRULE_yieldExpression
	return p
}

func (*YieldExpressionContext) IsYieldExpressionContext() {}

func NewYieldExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *YieldExpressionContext {
	var p = new(YieldExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PHPParserRULE_yieldExpression

	return p
}

func (s *YieldExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *YieldExpressionContext) Yield() antlr.TerminalNode {
	return s.GetToken(PHPParserYield, 0)
}

func (s *YieldExpressionContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *YieldExpressionContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *YieldExpressionContext) From() antlr.TerminalNode {
	return s.GetToken(PHPParserFrom, 0)
}

func (s *YieldExpressionContext) DoubleArrow() antlr.TerminalNode {
	return s.GetToken(PHPParserDoubleArrow, 0)
}

func (s *YieldExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *YieldExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *YieldExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PHPParserVisitor:
		return t.VisitYieldExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PHPParser) YieldExpression() (localctx IYieldExpressionContext) {
	this := p
	_ = this

	localctx = NewYieldExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 212, PHPParserRULE_yieldExpression)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1662)
		p.Match(PHPParserYield)
	}
	p.SetState(1670)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 186, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(1663)
			p.expression(0)
		}
		p.SetState(1666)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == PHPParserDoubleArrow {
			{
				p.SetState(1664)
				p.Match(PHPParserDoubleArrow)
			}
			{
				p.SetState(1665)
				p.expression(0)
			}

		}

	case 2:
		{
			p.SetState(1668)
			p.Match(PHPParserFrom)
		}
		{
			p.SetState(1669)
			p.expression(0)
		}

	}

	return localctx
}

// IArrayItemListContext is an interface to support dynamic dispatch.
type IArrayItemListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsArrayItemListContext differentiates from other interfaces.
	IsArrayItemListContext()
}

type ArrayItemListContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyArrayItemListContext() *ArrayItemListContext {
	var p = new(ArrayItemListContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PHPParserRULE_arrayItemList
	return p
}

func (*ArrayItemListContext) IsArrayItemListContext() {}

func NewArrayItemListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ArrayItemListContext {
	var p = new(ArrayItemListContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PHPParserRULE_arrayItemList

	return p
}

func (s *ArrayItemListContext) GetParser() antlr.Parser { return s.parser }

func (s *ArrayItemListContext) AllArrayItem() []IArrayItemContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IArrayItemContext); ok {
			len++
		}
	}

	tst := make([]IArrayItemContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IArrayItemContext); ok {
			tst[i] = t.(IArrayItemContext)
			i++
		}
	}

	return tst
}

func (s *ArrayItemListContext) ArrayItem(i int) IArrayItemContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArrayItemContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArrayItemContext)
}

func (s *ArrayItemListContext) AllComma() []antlr.TerminalNode {
	return s.GetTokens(PHPParserComma)
}

func (s *ArrayItemListContext) Comma(i int) antlr.TerminalNode {
	return s.GetToken(PHPParserComma, i)
}

func (s *ArrayItemListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArrayItemListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ArrayItemListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PHPParserVisitor:
		return t.VisitArrayItemList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PHPParser) ArrayItemList() (localctx IArrayItemListContext) {
	this := p
	_ = this

	localctx = NewArrayItemListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 214, PHPParserRULE_arrayItemList)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1672)
		p.ArrayItem()
	}
	p.SetState(1677)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 187, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1673)
				p.Match(PHPParserComma)
			}
			{
				p.SetState(1674)
				p.ArrayItem()
			}

		}
		p.SetState(1679)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 187, p.GetParserRuleContext())
	}
	p.SetState(1681)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 188, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1680)
			p.Match(PHPParserComma)
		}

	}

	return localctx
}

// IArrayItemContext is an interface to support dynamic dispatch.
type IArrayItemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsArrayItemContext differentiates from other interfaces.
	IsArrayItemContext()
}

type ArrayItemContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyArrayItemContext() *ArrayItemContext {
	var p = new(ArrayItemContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PHPParserRULE_arrayItem
	return p
}

func (*ArrayItemContext) IsArrayItemContext() {}

func NewArrayItemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ArrayItemContext {
	var p = new(ArrayItemContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PHPParserRULE_arrayItem

	return p
}

func (s *ArrayItemContext) GetParser() antlr.Parser { return s.parser }

func (s *ArrayItemContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *ArrayItemContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ArrayItemContext) DoubleArrow() antlr.TerminalNode {
	return s.GetToken(PHPParserDoubleArrow, 0)
}

func (s *ArrayItemContext) Ampersand() antlr.TerminalNode {
	return s.GetToken(PHPParserAmpersand, 0)
}

func (s *ArrayItemContext) Chain() IChainContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IChainContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IChainContext)
}

func (s *ArrayItemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArrayItemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ArrayItemContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PHPParserVisitor:
		return t.VisitArrayItem(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PHPParser) ArrayItem() (localctx IArrayItemContext) {
	this := p
	_ = this

	localctx = NewArrayItemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 216, PHPParserRULE_arrayItem)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1695)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 191, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1683)
			p.expression(0)
		}
		p.SetState(1686)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == PHPParserDoubleArrow {
			{
				p.SetState(1684)
				p.Match(PHPParserDoubleArrow)
			}
			{
				p.SetState(1685)
				p.expression(0)
			}

		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(1691)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 190, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1688)
				p.expression(0)
			}
			{
				p.SetState(1689)
				p.Match(PHPParserDoubleArrow)
			}

		}
		{
			p.SetState(1693)
			p.Match(PHPParserAmpersand)
		}
		{
			p.SetState(1694)
			p.Chain()
		}

	}

	return localctx
}

// ILambdaFunctionUseVarsContext is an interface to support dynamic dispatch.
type ILambdaFunctionUseVarsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLambdaFunctionUseVarsContext differentiates from other interfaces.
	IsLambdaFunctionUseVarsContext()
}

type LambdaFunctionUseVarsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLambdaFunctionUseVarsContext() *LambdaFunctionUseVarsContext {
	var p = new(LambdaFunctionUseVarsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PHPParserRULE_lambdaFunctionUseVars
	return p
}

func (*LambdaFunctionUseVarsContext) IsLambdaFunctionUseVarsContext() {}

func NewLambdaFunctionUseVarsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LambdaFunctionUseVarsContext {
	var p = new(LambdaFunctionUseVarsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PHPParserRULE_lambdaFunctionUseVars

	return p
}

func (s *LambdaFunctionUseVarsContext) GetParser() antlr.Parser { return s.parser }

func (s *LambdaFunctionUseVarsContext) Use() antlr.TerminalNode {
	return s.GetToken(PHPParserUse, 0)
}

func (s *LambdaFunctionUseVarsContext) OpenRoundBracket() antlr.TerminalNode {
	return s.GetToken(PHPParserOpenRoundBracket, 0)
}

func (s *LambdaFunctionUseVarsContext) AllLambdaFunctionUseVar() []ILambdaFunctionUseVarContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ILambdaFunctionUseVarContext); ok {
			len++
		}
	}

	tst := make([]ILambdaFunctionUseVarContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ILambdaFunctionUseVarContext); ok {
			tst[i] = t.(ILambdaFunctionUseVarContext)
			i++
		}
	}

	return tst
}

func (s *LambdaFunctionUseVarsContext) LambdaFunctionUseVar(i int) ILambdaFunctionUseVarContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILambdaFunctionUseVarContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILambdaFunctionUseVarContext)
}

func (s *LambdaFunctionUseVarsContext) CloseRoundBracket() antlr.TerminalNode {
	return s.GetToken(PHPParserCloseRoundBracket, 0)
}

func (s *LambdaFunctionUseVarsContext) AllComma() []antlr.TerminalNode {
	return s.GetTokens(PHPParserComma)
}

func (s *LambdaFunctionUseVarsContext) Comma(i int) antlr.TerminalNode {
	return s.GetToken(PHPParserComma, i)
}

func (s *LambdaFunctionUseVarsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LambdaFunctionUseVarsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LambdaFunctionUseVarsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PHPParserVisitor:
		return t.VisitLambdaFunctionUseVars(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PHPParser) LambdaFunctionUseVars() (localctx ILambdaFunctionUseVarsContext) {
	this := p
	_ = this

	localctx = NewLambdaFunctionUseVarsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 218, PHPParserRULE_lambdaFunctionUseVars)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1697)
		p.Match(PHPParserUse)
	}
	{
		p.SetState(1698)
		p.Match(PHPParserOpenRoundBracket)
	}
	{
		p.SetState(1699)
		p.LambdaFunctionUseVar()
	}
	p.SetState(1704)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == PHPParserComma {
		{
			p.SetState(1700)
			p.Match(PHPParserComma)
		}
		{
			p.SetState(1701)
			p.LambdaFunctionUseVar()
		}

		p.SetState(1706)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1707)
		p.Match(PHPParserCloseRoundBracket)
	}

	return localctx
}

// ILambdaFunctionUseVarContext is an interface to support dynamic dispatch.
type ILambdaFunctionUseVarContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLambdaFunctionUseVarContext differentiates from other interfaces.
	IsLambdaFunctionUseVarContext()
}

type LambdaFunctionUseVarContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLambdaFunctionUseVarContext() *LambdaFunctionUseVarContext {
	var p = new(LambdaFunctionUseVarContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PHPParserRULE_lambdaFunctionUseVar
	return p
}

func (*LambdaFunctionUseVarContext) IsLambdaFunctionUseVarContext() {}

func NewLambdaFunctionUseVarContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LambdaFunctionUseVarContext {
	var p = new(LambdaFunctionUseVarContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PHPParserRULE_lambdaFunctionUseVar

	return p
}

func (s *LambdaFunctionUseVarContext) GetParser() antlr.Parser { return s.parser }

func (s *LambdaFunctionUseVarContext) VarName() antlr.TerminalNode {
	return s.GetToken(PHPParserVarName, 0)
}

func (s *LambdaFunctionUseVarContext) Ampersand() antlr.TerminalNode {
	return s.GetToken(PHPParserAmpersand, 0)
}

func (s *LambdaFunctionUseVarContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LambdaFunctionUseVarContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LambdaFunctionUseVarContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PHPParserVisitor:
		return t.VisitLambdaFunctionUseVar(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PHPParser) LambdaFunctionUseVar() (localctx ILambdaFunctionUseVarContext) {
	this := p
	_ = this

	localctx = NewLambdaFunctionUseVarContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 220, PHPParserRULE_lambdaFunctionUseVar)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1710)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == PHPParserAmpersand {
		{
			p.SetState(1709)
			p.Match(PHPParserAmpersand)
		}

	}
	{
		p.SetState(1712)
		p.Match(PHPParserVarName)
	}

	return localctx
}

// IQualifiedStaticTypeRefContext is an interface to support dynamic dispatch.
type IQualifiedStaticTypeRefContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsQualifiedStaticTypeRefContext differentiates from other interfaces.
	IsQualifiedStaticTypeRefContext()
}

type QualifiedStaticTypeRefContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyQualifiedStaticTypeRefContext() *QualifiedStaticTypeRefContext {
	var p = new(QualifiedStaticTypeRefContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PHPParserRULE_qualifiedStaticTypeRef
	return p
}

func (*QualifiedStaticTypeRefContext) IsQualifiedStaticTypeRefContext() {}

func NewQualifiedStaticTypeRefContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *QualifiedStaticTypeRefContext {
	var p = new(QualifiedStaticTypeRefContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PHPParserRULE_qualifiedStaticTypeRef

	return p
}

func (s *QualifiedStaticTypeRefContext) GetParser() antlr.Parser { return s.parser }

func (s *QualifiedStaticTypeRefContext) QualifiedNamespaceName() IQualifiedNamespaceNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNamespaceNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNamespaceNameContext)
}

func (s *QualifiedStaticTypeRefContext) Static() antlr.TerminalNode {
	return s.GetToken(PHPParserStatic, 0)
}

func (s *QualifiedStaticTypeRefContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QualifiedStaticTypeRefContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *QualifiedStaticTypeRefContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PHPParserVisitor:
		return t.VisitQualifiedStaticTypeRef(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PHPParser) QualifiedStaticTypeRef() (localctx IQualifiedStaticTypeRefContext) {
	this := p
	_ = this

	localctx = NewQualifiedStaticTypeRefContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 222, PHPParserRULE_qualifiedStaticTypeRef)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1716)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 194, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1714)
			p.QualifiedNamespaceName()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1715)
			p.Match(PHPParserStatic)
		}

	}

	return localctx
}

// ITypeRefContext is an interface to support dynamic dispatch.
type ITypeRefContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTypeRefContext differentiates from other interfaces.
	IsTypeRefContext()
}

type TypeRefContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeRefContext() *TypeRefContext {
	var p = new(TypeRefContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PHPParserRULE_typeRef
	return p
}

func (*TypeRefContext) IsTypeRefContext() {}

func NewTypeRefContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeRefContext {
	var p = new(TypeRefContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PHPParserRULE_typeRef

	return p
}

func (s *TypeRefContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeRefContext) QualifiedNamespaceName() IQualifiedNamespaceNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNamespaceNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNamespaceNameContext)
}

func (s *TypeRefContext) IndirectTypeRef() IIndirectTypeRefContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIndirectTypeRefContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIndirectTypeRefContext)
}

func (s *TypeRefContext) PrimitiveType() IPrimitiveTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrimitiveTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrimitiveTypeContext)
}

func (s *TypeRefContext) Static() antlr.TerminalNode {
	return s.GetToken(PHPParserStatic, 0)
}

func (s *TypeRefContext) AnonymousClass() IAnonymousClassContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAnonymousClassContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAnonymousClassContext)
}

func (s *TypeRefContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeRefContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeRefContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PHPParserVisitor:
		return t.VisitTypeRef(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PHPParser) TypeRef() (localctx ITypeRefContext) {
	this := p
	_ = this

	localctx = NewTypeRefContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 224, PHPParserRULE_typeRef)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1725)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 196, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(1720)
		p.GetErrorHandler().Sync(p)
		switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 195, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(1718)
				p.QualifiedNamespaceName()
			}

		case 2:
			{
				p.SetState(1719)
				p.IndirectTypeRef()
			}

		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1722)
			p.PrimitiveType()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1723)
			p.Match(PHPParserStatic)
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1724)
			p.AnonymousClass()
		}

	}

	return localctx
}

// IAnonymousClassContext is an interface to support dynamic dispatch.
type IAnonymousClassContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAnonymousClassContext differentiates from other interfaces.
	IsAnonymousClassContext()
}

type AnonymousClassContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAnonymousClassContext() *AnonymousClassContext {
	var p = new(AnonymousClassContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PHPParserRULE_anonymousClass
	return p
}

func (*AnonymousClassContext) IsAnonymousClassContext() {}

func NewAnonymousClassContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AnonymousClassContext {
	var p = new(AnonymousClassContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PHPParserRULE_anonymousClass

	return p
}

func (s *AnonymousClassContext) GetParser() antlr.Parser { return s.parser }

func (s *AnonymousClassContext) OpenCurlyBracket() antlr.TerminalNode {
	return s.GetToken(PHPParserOpenCurlyBracket, 0)
}

func (s *AnonymousClassContext) CloseCurlyBracket() antlr.TerminalNode {
	return s.GetToken(PHPParserCloseCurlyBracket, 0)
}

func (s *AnonymousClassContext) ClassEntryType() IClassEntryTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClassEntryTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClassEntryTypeContext)
}

func (s *AnonymousClassContext) Interface() antlr.TerminalNode {
	return s.GetToken(PHPParserInterface, 0)
}

func (s *AnonymousClassContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *AnonymousClassContext) Attributes() IAttributesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAttributesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAttributesContext)
}

func (s *AnonymousClassContext) Private() antlr.TerminalNode {
	return s.GetToken(PHPParserPrivate, 0)
}

func (s *AnonymousClassContext) Modifier() IModifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IModifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IModifierContext)
}

func (s *AnonymousClassContext) Partial() antlr.TerminalNode {
	return s.GetToken(PHPParserPartial, 0)
}

func (s *AnonymousClassContext) Arguments() IArgumentsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArgumentsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArgumentsContext)
}

func (s *AnonymousClassContext) AllClassStatement() []IClassStatementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IClassStatementContext); ok {
			len++
		}
	}

	tst := make([]IClassStatementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IClassStatementContext); ok {
			tst[i] = t.(IClassStatementContext)
			i++
		}
	}

	return tst
}

func (s *AnonymousClassContext) ClassStatement(i int) IClassStatementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClassStatementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClassStatementContext)
}

func (s *AnonymousClassContext) Extends() antlr.TerminalNode {
	return s.GetToken(PHPParserExtends, 0)
}

func (s *AnonymousClassContext) QualifiedStaticTypeRef() IQualifiedStaticTypeRefContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedStaticTypeRefContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedStaticTypeRefContext)
}

func (s *AnonymousClassContext) Implements() antlr.TerminalNode {
	return s.GetToken(PHPParserImplements, 0)
}

func (s *AnonymousClassContext) InterfaceList() IInterfaceListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInterfaceListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInterfaceListContext)
}

func (s *AnonymousClassContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AnonymousClassContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AnonymousClassContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PHPParserVisitor:
		return t.VisitAnonymousClass(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PHPParser) AnonymousClass() (localctx IAnonymousClassContext) {
	this := p
	_ = this

	localctx = NewAnonymousClassContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 226, PHPParserRULE_anonymousClass)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1728)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == PHPParserAttributeStart {
		{
			p.SetState(1727)
			p.Attributes()
		}

	}
	p.SetState(1731)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == PHPParserPrivate {
		{
			p.SetState(1730)
			p.Match(PHPParserPrivate)
		}

	}
	p.SetState(1734)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == PHPParserAbstract || _la == PHPParserFinal {
		{
			p.SetState(1733)
			p.Modifier()
		}

	}
	p.SetState(1737)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == PHPParserPartial {
		{
			p.SetState(1736)
			p.Match(PHPParserPartial)
		}

	}
	p.SetState(1754)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case PHPParserClass, PHPParserTrait:
		{
			p.SetState(1739)
			p.ClassEntryType()
		}
		p.SetState(1742)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == PHPParserExtends {
			{
				p.SetState(1740)
				p.Match(PHPParserExtends)
			}
			{
				p.SetState(1741)
				p.QualifiedStaticTypeRef()
			}

		}
		p.SetState(1746)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == PHPParserImplements {
			{
				p.SetState(1744)
				p.Match(PHPParserImplements)
			}
			{
				p.SetState(1745)
				p.InterfaceList()
			}

		}

	case PHPParserInterface:
		{
			p.SetState(1748)
			p.Match(PHPParserInterface)
		}
		{
			p.SetState(1749)
			p.Identifier()
		}
		p.SetState(1752)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == PHPParserExtends {
			{
				p.SetState(1750)
				p.Match(PHPParserExtends)
			}
			{
				p.SetState(1751)
				p.InterfaceList()
			}

		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}
	p.SetState(1757)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == PHPParserOpenRoundBracket {
		{
			p.SetState(1756)
			p.Arguments()
		}

	}
	{
		p.SetState(1759)
		p.Match(PHPParserOpenCurlyBracket)
	}
	p.SetState(1763)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for (int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&72083982316994560) != 0 || (int64((_la-81)) & ^0x3f) == 0 && ((int64(1)<<(_la-81))&6757727313330209) != 0 {
		{
			p.SetState(1760)
			p.ClassStatement()
		}

		p.SetState(1765)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1766)
		p.Match(PHPParserCloseCurlyBracket)
	}

	return localctx
}

// IIndirectTypeRefContext is an interface to support dynamic dispatch.
type IIndirectTypeRefContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsIndirectTypeRefContext differentiates from other interfaces.
	IsIndirectTypeRefContext()
}

type IndirectTypeRefContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIndirectTypeRefContext() *IndirectTypeRefContext {
	var p = new(IndirectTypeRefContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PHPParserRULE_indirectTypeRef
	return p
}

func (*IndirectTypeRefContext) IsIndirectTypeRefContext() {}

func NewIndirectTypeRefContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IndirectTypeRefContext {
	var p = new(IndirectTypeRefContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PHPParserRULE_indirectTypeRef

	return p
}

func (s *IndirectTypeRefContext) GetParser() antlr.Parser { return s.parser }

func (s *IndirectTypeRefContext) ChainBase() IChainBaseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IChainBaseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IChainBaseContext)
}

func (s *IndirectTypeRefContext) AllObjectOperator() []antlr.TerminalNode {
	return s.GetTokens(PHPParserObjectOperator)
}

func (s *IndirectTypeRefContext) ObjectOperator(i int) antlr.TerminalNode {
	return s.GetToken(PHPParserObjectOperator, i)
}

func (s *IndirectTypeRefContext) AllKeyedFieldName() []IKeyedFieldNameContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IKeyedFieldNameContext); ok {
			len++
		}
	}

	tst := make([]IKeyedFieldNameContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IKeyedFieldNameContext); ok {
			tst[i] = t.(IKeyedFieldNameContext)
			i++
		}
	}

	return tst
}

func (s *IndirectTypeRefContext) KeyedFieldName(i int) IKeyedFieldNameContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKeyedFieldNameContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKeyedFieldNameContext)
}

func (s *IndirectTypeRefContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IndirectTypeRefContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IndirectTypeRefContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PHPParserVisitor:
		return t.VisitIndirectTypeRef(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PHPParser) IndirectTypeRef() (localctx IIndirectTypeRefContext) {
	this := p
	_ = this

	localctx = NewIndirectTypeRefContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 228, PHPParserRULE_indirectTypeRef)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1768)
		p.ChainBase()
	}
	p.SetState(1773)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 207, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1769)
				p.Match(PHPParserObjectOperator)
			}
			{
				p.SetState(1770)
				p.KeyedFieldName()
			}

		}
		p.SetState(1775)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 207, p.GetParserRuleContext())
	}

	return localctx
}

// IQualifiedNamespaceNameContext is an interface to support dynamic dispatch.
type IQualifiedNamespaceNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsQualifiedNamespaceNameContext differentiates from other interfaces.
	IsQualifiedNamespaceNameContext()
}

type QualifiedNamespaceNameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyQualifiedNamespaceNameContext() *QualifiedNamespaceNameContext {
	var p = new(QualifiedNamespaceNameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PHPParserRULE_qualifiedNamespaceName
	return p
}

func (*QualifiedNamespaceNameContext) IsQualifiedNamespaceNameContext() {}

func NewQualifiedNamespaceNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *QualifiedNamespaceNameContext {
	var p = new(QualifiedNamespaceNameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PHPParserRULE_qualifiedNamespaceName

	return p
}

func (s *QualifiedNamespaceNameContext) GetParser() antlr.Parser { return s.parser }

func (s *QualifiedNamespaceNameContext) NamespaceNameList() INamespaceNameListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INamespaceNameListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INamespaceNameListContext)
}

func (s *QualifiedNamespaceNameContext) Namespace() antlr.TerminalNode {
	return s.GetToken(PHPParserNamespace, 0)
}

func (s *QualifiedNamespaceNameContext) NamespaceSeparator() antlr.TerminalNode {
	return s.GetToken(PHPParserNamespaceSeparator, 0)
}

func (s *QualifiedNamespaceNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QualifiedNamespaceNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *QualifiedNamespaceNameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PHPParserVisitor:
		return t.VisitQualifiedNamespaceName(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PHPParser) QualifiedNamespaceName() (localctx IQualifiedNamespaceNameContext) {
	this := p
	_ = this

	localctx = NewQualifiedNamespaceNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 230, PHPParserRULE_qualifiedNamespaceName)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1777)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 208, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1776)
			p.Match(PHPParserNamespace)
		}

	}
	p.SetState(1780)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 209, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1779)
			p.Match(PHPParserNamespaceSeparator)
		}

	}
	{
		p.SetState(1782)
		p.NamespaceNameList()
	}

	return localctx
}

// INamespaceNameListContext is an interface to support dynamic dispatch.
type INamespaceNameListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsNamespaceNameListContext differentiates from other interfaces.
	IsNamespaceNameListContext()
}

type NamespaceNameListContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNamespaceNameListContext() *NamespaceNameListContext {
	var p = new(NamespaceNameListContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PHPParserRULE_namespaceNameList
	return p
}

func (*NamespaceNameListContext) IsNamespaceNameListContext() {}

func NewNamespaceNameListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NamespaceNameListContext {
	var p = new(NamespaceNameListContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PHPParserRULE_namespaceNameList

	return p
}

func (s *NamespaceNameListContext) GetParser() antlr.Parser { return s.parser }

func (s *NamespaceNameListContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *NamespaceNameListContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *NamespaceNameListContext) AllNamespaceSeparator() []antlr.TerminalNode {
	return s.GetTokens(PHPParserNamespaceSeparator)
}

func (s *NamespaceNameListContext) NamespaceSeparator(i int) antlr.TerminalNode {
	return s.GetToken(PHPParserNamespaceSeparator, i)
}

func (s *NamespaceNameListContext) NamespaceNameTail() INamespaceNameTailContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INamespaceNameTailContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INamespaceNameTailContext)
}

func (s *NamespaceNameListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NamespaceNameListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NamespaceNameListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PHPParserVisitor:
		return t.VisitNamespaceNameList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PHPParser) NamespaceNameList() (localctx INamespaceNameListContext) {
	this := p
	_ = this

	localctx = NewNamespaceNameListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 232, PHPParserRULE_namespaceNameList)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.SetState(1796)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 212, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1784)
			p.Identifier()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1785)
			p.Identifier()
		}
		p.SetState(1788)
		p.GetErrorHandler().Sync(p)
		_alt = 1
		for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			switch _alt {
			case 1:
				{
					p.SetState(1786)
					p.Match(PHPParserNamespaceSeparator)
				}
				{
					p.SetState(1787)
					p.Identifier()
				}

			default:
				panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			}

			p.SetState(1790)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 210, p.GetParserRuleContext())
		}
		p.SetState(1794)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 211, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1792)
				p.Match(PHPParserNamespaceSeparator)
			}
			{
				p.SetState(1793)
				p.NamespaceNameTail()
			}

		}

	}

	return localctx
}

// INamespaceNameTailContext is an interface to support dynamic dispatch.
type INamespaceNameTailContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsNamespaceNameTailContext differentiates from other interfaces.
	IsNamespaceNameTailContext()
}

type NamespaceNameTailContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNamespaceNameTailContext() *NamespaceNameTailContext {
	var p = new(NamespaceNameTailContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PHPParserRULE_namespaceNameTail
	return p
}

func (*NamespaceNameTailContext) IsNamespaceNameTailContext() {}

func NewNamespaceNameTailContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NamespaceNameTailContext {
	var p = new(NamespaceNameTailContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PHPParserRULE_namespaceNameTail

	return p
}

func (s *NamespaceNameTailContext) GetParser() antlr.Parser { return s.parser }

func (s *NamespaceNameTailContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *NamespaceNameTailContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *NamespaceNameTailContext) As() antlr.TerminalNode {
	return s.GetToken(PHPParserAs, 0)
}

func (s *NamespaceNameTailContext) OpenCurlyBracket() antlr.TerminalNode {
	return s.GetToken(PHPParserOpenCurlyBracket, 0)
}

func (s *NamespaceNameTailContext) AllNamespaceNameTail() []INamespaceNameTailContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(INamespaceNameTailContext); ok {
			len++
		}
	}

	tst := make([]INamespaceNameTailContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(INamespaceNameTailContext); ok {
			tst[i] = t.(INamespaceNameTailContext)
			i++
		}
	}

	return tst
}

func (s *NamespaceNameTailContext) NamespaceNameTail(i int) INamespaceNameTailContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INamespaceNameTailContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(INamespaceNameTailContext)
}

func (s *NamespaceNameTailContext) CloseCurlyBracket() antlr.TerminalNode {
	return s.GetToken(PHPParserCloseCurlyBracket, 0)
}

func (s *NamespaceNameTailContext) AllComma() []antlr.TerminalNode {
	return s.GetTokens(PHPParserComma)
}

func (s *NamespaceNameTailContext) Comma(i int) antlr.TerminalNode {
	return s.GetToken(PHPParserComma, i)
}

func (s *NamespaceNameTailContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NamespaceNameTailContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NamespaceNameTailContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PHPParserVisitor:
		return t.VisitNamespaceNameTail(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PHPParser) NamespaceNameTail() (localctx INamespaceNameTailContext) {
	this := p
	_ = this

	localctx = NewNamespaceNameTailContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 234, PHPParserRULE_namespaceNameTail)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.SetState(1817)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case PHPParserAbstract, PHPParserArray, PHPParserAs, PHPParserBinaryCast, PHPParserBoolType, PHPParserBooleanConstant, PHPParserBreak, PHPParserCallable, PHPParserCase, PHPParserCatch, PHPParserClass, PHPParserClone, PHPParserConst, PHPParserContinue, PHPParserDeclare, PHPParserDefault, PHPParserDo, PHPParserDoubleCast, PHPParserDoubleType, PHPParserEcho, PHPParserElse, PHPParserElseIf, PHPParserEmpty, PHPParserEnum_, PHPParserEndDeclare, PHPParserEndFor, PHPParserEndForeach, PHPParserEndIf, PHPParserEndSwitch, PHPParserEndWhile, PHPParserExtends, PHPParserFinal, PHPParserFinally, PHPParserFloatCast, PHPParserFor, PHPParserForeach, PHPParserFunction_, PHPParserGlobal, PHPParserGoto, PHPParserIf, PHPParserImplements, PHPParserImport, PHPParserInstanceOf, PHPParserInsteadOf, PHPParserInt8Cast, PHPParserInt16Cast, PHPParserInt64Type, PHPParserIntType, PHPParserInterface, PHPParserList, PHPParserLogicalAnd, PHPParserLogicalOr, PHPParserLogicalXor, PHPParserMatch_, PHPParserNamespace, PHPParserNew, PHPParserNull, PHPParserObjectType, PHPParserParent_, PHPParserPartial, PHPParserPrint, PHPParserPrivate, PHPParserProtected, PHPParserPublic, PHPParserReadonly, PHPParserResource, PHPParserReturn, PHPParserStatic, PHPParserStringType, PHPParserSwitch, PHPParserTrait, PHPParserTry, PHPParserTypeof, PHPParserUintCast, PHPParserUnicodeCast, PHPParserUse, PHPParserVar, PHPParserWhile, PHPParserYield, PHPParserFrom, PHPParserLambdaFn, PHPParserTicks, PHPParserEncoding, PHPParserStrictTypes, PHPParserGet, PHPParserSet, PHPParserCall, PHPParserCallStatic, PHPParserConstructor, PHPParserDestruct, PHPParserWakeup, PHPParserSleep, PHPParserAutoload, PHPParserIsSet__, PHPParserUnset__, PHPParserToString__, PHPParserInvoke, PHPParserSetState, PHPParserClone__, PHPParserDebugInfo, PHPParserNamespace__, PHPParserClass__, PHPParserTraic__, PHPParserFunction__, PHPParserMethod__, PHPParserLine__, PHPParserFile__, PHPParserDir__, PHPParserNamespaceSeparator, PHPParserLabel:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1798)
			p.Identifier()
		}
		p.SetState(1801)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 213, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1799)
				p.Match(PHPParserAs)
			}
			{
				p.SetState(1800)
				p.Identifier()
			}

		}

	case PHPParserOpenCurlyBracket:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1803)
			p.Match(PHPParserOpenCurlyBracket)
		}
		{
			p.SetState(1804)
			p.NamespaceNameTail()
		}
		p.SetState(1809)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 214, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(1805)
					p.Match(PHPParserComma)
				}
				{
					p.SetState(1806)
					p.NamespaceNameTail()
				}

			}
			p.SetState(1811)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 214, p.GetParserRuleContext())
		}
		p.SetState(1813)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == PHPParserComma {
			{
				p.SetState(1812)
				p.Match(PHPParserComma)
			}

		}
		{
			p.SetState(1815)
			p.Match(PHPParserCloseCurlyBracket)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IQualifiedNamespaceNameListContext is an interface to support dynamic dispatch.
type IQualifiedNamespaceNameListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsQualifiedNamespaceNameListContext differentiates from other interfaces.
	IsQualifiedNamespaceNameListContext()
}

type QualifiedNamespaceNameListContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyQualifiedNamespaceNameListContext() *QualifiedNamespaceNameListContext {
	var p = new(QualifiedNamespaceNameListContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PHPParserRULE_qualifiedNamespaceNameList
	return p
}

func (*QualifiedNamespaceNameListContext) IsQualifiedNamespaceNameListContext() {}

func NewQualifiedNamespaceNameListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *QualifiedNamespaceNameListContext {
	var p = new(QualifiedNamespaceNameListContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PHPParserRULE_qualifiedNamespaceNameList

	return p
}

func (s *QualifiedNamespaceNameListContext) GetParser() antlr.Parser { return s.parser }

func (s *QualifiedNamespaceNameListContext) AllQualifiedNamespaceName() []IQualifiedNamespaceNameContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IQualifiedNamespaceNameContext); ok {
			len++
		}
	}

	tst := make([]IQualifiedNamespaceNameContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IQualifiedNamespaceNameContext); ok {
			tst[i] = t.(IQualifiedNamespaceNameContext)
			i++
		}
	}

	return tst
}

func (s *QualifiedNamespaceNameListContext) QualifiedNamespaceName(i int) IQualifiedNamespaceNameContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNamespaceNameContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNamespaceNameContext)
}

func (s *QualifiedNamespaceNameListContext) AllComma() []antlr.TerminalNode {
	return s.GetTokens(PHPParserComma)
}

func (s *QualifiedNamespaceNameListContext) Comma(i int) antlr.TerminalNode {
	return s.GetToken(PHPParserComma, i)
}

func (s *QualifiedNamespaceNameListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QualifiedNamespaceNameListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *QualifiedNamespaceNameListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PHPParserVisitor:
		return t.VisitQualifiedNamespaceNameList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PHPParser) QualifiedNamespaceNameList() (localctx IQualifiedNamespaceNameListContext) {
	this := p
	_ = this

	localctx = NewQualifiedNamespaceNameListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 236, PHPParserRULE_qualifiedNamespaceNameList)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1819)
		p.QualifiedNamespaceName()
	}
	p.SetState(1824)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == PHPParserComma {
		{
			p.SetState(1820)
			p.Match(PHPParserComma)
		}
		{
			p.SetState(1821)
			p.QualifiedNamespaceName()
		}

		p.SetState(1826)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IArgumentsContext is an interface to support dynamic dispatch.
type IArgumentsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsArgumentsContext differentiates from other interfaces.
	IsArgumentsContext()
}

type ArgumentsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyArgumentsContext() *ArgumentsContext {
	var p = new(ArgumentsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PHPParserRULE_arguments
	return p
}

func (*ArgumentsContext) IsArgumentsContext() {}

func NewArgumentsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ArgumentsContext {
	var p = new(ArgumentsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PHPParserRULE_arguments

	return p
}

func (s *ArgumentsContext) GetParser() antlr.Parser { return s.parser }

func (s *ArgumentsContext) OpenRoundBracket() antlr.TerminalNode {
	return s.GetToken(PHPParserOpenRoundBracket, 0)
}

func (s *ArgumentsContext) CloseRoundBracket() antlr.TerminalNode {
	return s.GetToken(PHPParserCloseRoundBracket, 0)
}

func (s *ArgumentsContext) AllActualArgument() []IActualArgumentContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IActualArgumentContext); ok {
			len++
		}
	}

	tst := make([]IActualArgumentContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IActualArgumentContext); ok {
			tst[i] = t.(IActualArgumentContext)
			i++
		}
	}

	return tst
}

func (s *ArgumentsContext) ActualArgument(i int) IActualArgumentContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IActualArgumentContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IActualArgumentContext)
}

func (s *ArgumentsContext) AllComma() []antlr.TerminalNode {
	return s.GetTokens(PHPParserComma)
}

func (s *ArgumentsContext) Comma(i int) antlr.TerminalNode {
	return s.GetToken(PHPParserComma, i)
}

func (s *ArgumentsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArgumentsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ArgumentsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PHPParserVisitor:
		return t.VisitArguments(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PHPParser) Arguments() (localctx IArgumentsContext) {
	this := p
	_ = this

	localctx = NewArgumentsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 238, PHPParserRULE_arguments)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1827)
		p.Match(PHPParserOpenRoundBracket)
	}
	p.SetState(1829)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if (int64((_la-44)) & ^0x3f) == 0 && ((int64(1)<<(_la-44))&-1) != 0 || (int64((_la-108)) & ^0x3f) == 0 && ((int64(1)<<(_la-108))&1873497444977737727) != 0 || (int64((_la-196)) & ^0x3f) == 0 && ((int64(1)<<(_la-196))&8795020649299) != 0 {
		{
			p.SetState(1828)
			p.ActualArgument()
		}

	}
	p.SetState(1835)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 219, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1831)
				p.Match(PHPParserComma)
			}
			{
				p.SetState(1832)
				p.ActualArgument()
			}

		}
		p.SetState(1837)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 219, p.GetParserRuleContext())
	}
	p.SetState(1839)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == PHPParserComma {
		{
			p.SetState(1838)
			p.Match(PHPParserComma)
		}

	}
	{
		p.SetState(1841)
		p.Match(PHPParserCloseRoundBracket)
	}

	return localctx
}

// IActualArgumentContext is an interface to support dynamic dispatch.
type IActualArgumentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsActualArgumentContext differentiates from other interfaces.
	IsActualArgumentContext()
}

type ActualArgumentContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyActualArgumentContext() *ActualArgumentContext {
	var p = new(ActualArgumentContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PHPParserRULE_actualArgument
	return p
}

func (*ActualArgumentContext) IsActualArgumentContext() {}

func NewActualArgumentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ActualArgumentContext {
	var p = new(ActualArgumentContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PHPParserRULE_actualArgument

	return p
}

func (s *ActualArgumentContext) GetParser() antlr.Parser { return s.parser }

func (s *ActualArgumentContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ActualArgumentContext) ArgumentName() IArgumentNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArgumentNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArgumentNameContext)
}

func (s *ActualArgumentContext) Ellipsis() antlr.TerminalNode {
	return s.GetToken(PHPParserEllipsis, 0)
}

func (s *ActualArgumentContext) Ampersand() antlr.TerminalNode {
	return s.GetToken(PHPParserAmpersand, 0)
}

func (s *ActualArgumentContext) Chain() IChainContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IChainContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IChainContext)
}

func (s *ActualArgumentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ActualArgumentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ActualArgumentContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PHPParserVisitor:
		return t.VisitActualArgument(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PHPParser) ActualArgument() (localctx IActualArgumentContext) {
	this := p
	_ = this

	localctx = NewActualArgumentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 240, PHPParserRULE_actualArgument)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1852)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 223, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(1844)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 221, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1843)
				p.ArgumentName()
			}

		}
		p.SetState(1847)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == PHPParserEllipsis {
			{
				p.SetState(1846)
				p.Match(PHPParserEllipsis)
			}

		}
		{
			p.SetState(1849)
			p.expression(0)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1850)
			p.Match(PHPParserAmpersand)
		}
		{
			p.SetState(1851)
			p.Chain()
		}

	}

	return localctx
}

// IArgumentNameContext is an interface to support dynamic dispatch.
type IArgumentNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsArgumentNameContext differentiates from other interfaces.
	IsArgumentNameContext()
}

type ArgumentNameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyArgumentNameContext() *ArgumentNameContext {
	var p = new(ArgumentNameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PHPParserRULE_argumentName
	return p
}

func (*ArgumentNameContext) IsArgumentNameContext() {}

func NewArgumentNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ArgumentNameContext {
	var p = new(ArgumentNameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PHPParserRULE_argumentName

	return p
}

func (s *ArgumentNameContext) GetParser() antlr.Parser { return s.parser }

func (s *ArgumentNameContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ArgumentNameContext) Colon() antlr.TerminalNode {
	return s.GetToken(PHPParserColon, 0)
}

func (s *ArgumentNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArgumentNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ArgumentNameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PHPParserVisitor:
		return t.VisitArgumentName(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PHPParser) ArgumentName() (localctx IArgumentNameContext) {
	this := p
	_ = this

	localctx = NewArgumentNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 242, PHPParserRULE_argumentName)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1854)
		p.Identifier()
	}
	{
		p.SetState(1855)
		p.Match(PHPParserColon)
	}

	return localctx
}

// IConstantInitializerContext is an interface to support dynamic dispatch.
type IConstantInitializerContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsConstantInitializerContext differentiates from other interfaces.
	IsConstantInitializerContext()
}

type ConstantInitializerContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConstantInitializerContext() *ConstantInitializerContext {
	var p = new(ConstantInitializerContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PHPParserRULE_constantInitializer
	return p
}

func (*ConstantInitializerContext) IsConstantInitializerContext() {}

func NewConstantInitializerContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ConstantInitializerContext {
	var p = new(ConstantInitializerContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PHPParserRULE_constantInitializer

	return p
}

func (s *ConstantInitializerContext) GetParser() antlr.Parser { return s.parser }

func (s *ConstantInitializerContext) AllConstantString() []IConstantStringContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IConstantStringContext); ok {
			len++
		}
	}

	tst := make([]IConstantStringContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IConstantStringContext); ok {
			tst[i] = t.(IConstantStringContext)
			i++
		}
	}

	return tst
}

func (s *ConstantInitializerContext) ConstantString(i int) IConstantStringContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConstantStringContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConstantStringContext)
}

func (s *ConstantInitializerContext) AllDot() []antlr.TerminalNode {
	return s.GetTokens(PHPParserDot)
}

func (s *ConstantInitializerContext) Dot(i int) antlr.TerminalNode {
	return s.GetToken(PHPParserDot, i)
}

func (s *ConstantInitializerContext) Array() antlr.TerminalNode {
	return s.GetToken(PHPParserArray, 0)
}

func (s *ConstantInitializerContext) OpenRoundBracket() antlr.TerminalNode {
	return s.GetToken(PHPParserOpenRoundBracket, 0)
}

func (s *ConstantInitializerContext) CloseRoundBracket() antlr.TerminalNode {
	return s.GetToken(PHPParserCloseRoundBracket, 0)
}

func (s *ConstantInitializerContext) ArrayItemList() IArrayItemListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArrayItemListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArrayItemListContext)
}

func (s *ConstantInitializerContext) Comma() antlr.TerminalNode {
	return s.GetToken(PHPParserComma, 0)
}

func (s *ConstantInitializerContext) OpenSquareBracket() antlr.TerminalNode {
	return s.GetToken(PHPParserOpenSquareBracket, 0)
}

func (s *ConstantInitializerContext) CloseSquareBracket() antlr.TerminalNode {
	return s.GetToken(PHPParserCloseSquareBracket, 0)
}

func (s *ConstantInitializerContext) ConstantInitializer() IConstantInitializerContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConstantInitializerContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConstantInitializerContext)
}

func (s *ConstantInitializerContext) Plus() antlr.TerminalNode {
	return s.GetToken(PHPParserPlus, 0)
}

func (s *ConstantInitializerContext) Minus() antlr.TerminalNode {
	return s.GetToken(PHPParserMinus, 0)
}

func (s *ConstantInitializerContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ConstantInitializerContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ConstantInitializerContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ConstantInitializerContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PHPParserVisitor:
		return t.VisitConstantInitializer(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PHPParser) ConstantInitializer() (localctx IConstantInitializerContext) {
	this := p
	_ = this

	localctx = NewConstantInitializerContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 244, PHPParserRULE_constantInitializer)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1885)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 229, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1857)
			p.ConstantString()
		}
		p.SetState(1862)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == PHPParserDot {
			{
				p.SetState(1858)
				p.Match(PHPParserDot)
			}
			{
				p.SetState(1859)
				p.ConstantString()
			}

			p.SetState(1864)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1865)
			p.Match(PHPParserArray)
		}
		{
			p.SetState(1866)
			p.Match(PHPParserOpenRoundBracket)
		}
		p.SetState(1871)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if (int64((_la-44)) & ^0x3f) == 0 && ((int64(1)<<(_la-44))&-1) != 0 || (int64((_la-108)) & ^0x3f) == 0 && ((int64(1)<<(_la-108))&1873497444977737727) != 0 || (int64((_la-196)) & ^0x3f) == 0 && ((int64(1)<<(_la-196))&8795020649297) != 0 {
			{
				p.SetState(1867)
				p.ArrayItemList()
			}
			p.SetState(1869)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == PHPParserComma {
				{
					p.SetState(1868)
					p.Match(PHPParserComma)
				}

			}

		}
		{
			p.SetState(1873)
			p.Match(PHPParserCloseRoundBracket)
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1874)
			p.Match(PHPParserOpenSquareBracket)
		}
		p.SetState(1879)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if (int64((_la-44)) & ^0x3f) == 0 && ((int64(1)<<(_la-44))&-1) != 0 || (int64((_la-108)) & ^0x3f) == 0 && ((int64(1)<<(_la-108))&1873497444977737727) != 0 || (int64((_la-196)) & ^0x3f) == 0 && ((int64(1)<<(_la-196))&8795020649297) != 0 {
			{
				p.SetState(1875)
				p.ArrayItemList()
			}
			p.SetState(1877)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == PHPParserComma {
				{
					p.SetState(1876)
					p.Match(PHPParserComma)
				}

			}

		}
		{
			p.SetState(1881)
			p.Match(PHPParserCloseSquareBracket)
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1882)
			_la = p.GetTokenStream().LA(1)

			if !(_la == PHPParserPlus || _la == PHPParserMinus) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(1883)
			p.ConstantInitializer()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1884)
			p.expression(0)
		}

	}

	return localctx
}

// IConstantStringContext is an interface to support dynamic dispatch.
type IConstantStringContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsConstantStringContext differentiates from other interfaces.
	IsConstantStringContext()
}

type ConstantStringContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConstantStringContext() *ConstantStringContext {
	var p = new(ConstantStringContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PHPParserRULE_constantString
	return p
}

func (*ConstantStringContext) IsConstantStringContext() {}

func NewConstantStringContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ConstantStringContext {
	var p = new(ConstantStringContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PHPParserRULE_constantString

	return p
}

func (s *ConstantStringContext) GetParser() antlr.Parser { return s.parser }

func (s *ConstantStringContext) String_() IStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *ConstantStringContext) Constant() IConstantContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConstantContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConstantContext)
}

func (s *ConstantStringContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ConstantStringContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ConstantStringContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PHPParserVisitor:
		return t.VisitConstantString(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PHPParser) ConstantString() (localctx IConstantStringContext) {
	this := p
	_ = this

	localctx = NewConstantStringContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 246, PHPParserRULE_constantString)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1889)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case PHPParserSingleQuoteString, PHPParserDoubleQuote, PHPParserStartNowDoc, PHPParserStartHereDoc:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1887)
			p.String_()
		}

	case PHPParserBooleanConstant, PHPParserNull, PHPParserNamespace__, PHPParserClass__, PHPParserTraic__, PHPParserFunction__, PHPParserMethod__, PHPParserLine__, PHPParserFile__, PHPParserDir__, PHPParserLabel, PHPParserOctal, PHPParserDecimal, PHPParserReal, PHPParserHex, PHPParserBinary:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1888)
			p.Constant()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IConstantContext is an interface to support dynamic dispatch.
type IConstantContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsConstantContext differentiates from other interfaces.
	IsConstantContext()
}

type ConstantContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConstantContext() *ConstantContext {
	var p = new(ConstantContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PHPParserRULE_constant
	return p
}

func (*ConstantContext) IsConstantContext() {}

func NewConstantContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ConstantContext {
	var p = new(ConstantContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PHPParserRULE_constant

	return p
}

func (s *ConstantContext) GetParser() antlr.Parser { return s.parser }

func (s *ConstantContext) Null() antlr.TerminalNode {
	return s.GetToken(PHPParserNull, 0)
}

func (s *ConstantContext) LiteralConstant() ILiteralConstantContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILiteralConstantContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILiteralConstantContext)
}

func (s *ConstantContext) MagicConstant() IMagicConstantContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMagicConstantContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMagicConstantContext)
}

func (s *ConstantContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ConstantContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ConstantContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PHPParserVisitor:
		return t.VisitConstant(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PHPParser) Constant() (localctx IConstantContext) {
	this := p
	_ = this

	localctx = NewConstantContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 248, PHPParserRULE_constant)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1894)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case PHPParserNull:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1891)
			p.Match(PHPParserNull)
		}

	case PHPParserBooleanConstant, PHPParserLabel, PHPParserOctal, PHPParserDecimal, PHPParserReal, PHPParserHex, PHPParserBinary:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1892)
			p.LiteralConstant()
		}

	case PHPParserNamespace__, PHPParserClass__, PHPParserTraic__, PHPParserFunction__, PHPParserMethod__, PHPParserLine__, PHPParserFile__, PHPParserDir__:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1893)
			p.MagicConstant()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ILiteralConstantContext is an interface to support dynamic dispatch.
type ILiteralConstantContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLiteralConstantContext differentiates from other interfaces.
	IsLiteralConstantContext()
}

type LiteralConstantContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLiteralConstantContext() *LiteralConstantContext {
	var p = new(LiteralConstantContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PHPParserRULE_literalConstant
	return p
}

func (*LiteralConstantContext) IsLiteralConstantContext() {}

func NewLiteralConstantContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LiteralConstantContext {
	var p = new(LiteralConstantContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PHPParserRULE_literalConstant

	return p
}

func (s *LiteralConstantContext) GetParser() antlr.Parser { return s.parser }

func (s *LiteralConstantContext) Real() antlr.TerminalNode {
	return s.GetToken(PHPParserReal, 0)
}

func (s *LiteralConstantContext) BooleanConstant() antlr.TerminalNode {
	return s.GetToken(PHPParserBooleanConstant, 0)
}

func (s *LiteralConstantContext) NumericConstant() INumericConstantContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INumericConstantContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INumericConstantContext)
}

func (s *LiteralConstantContext) StringConstant() IStringConstantContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringConstantContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringConstantContext)
}

func (s *LiteralConstantContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LiteralConstantContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LiteralConstantContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PHPParserVisitor:
		return t.VisitLiteralConstant(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PHPParser) LiteralConstant() (localctx ILiteralConstantContext) {
	this := p
	_ = this

	localctx = NewLiteralConstantContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 250, PHPParserRULE_literalConstant)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1900)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case PHPParserReal:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1896)
			p.Match(PHPParserReal)
		}

	case PHPParserBooleanConstant:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1897)
			p.Match(PHPParserBooleanConstant)
		}

	case PHPParserOctal, PHPParserDecimal, PHPParserHex, PHPParserBinary:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1898)
			p.NumericConstant()
		}

	case PHPParserLabel:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1899)
			p.StringConstant()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// INumericConstantContext is an interface to support dynamic dispatch.
type INumericConstantContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsNumericConstantContext differentiates from other interfaces.
	IsNumericConstantContext()
}

type NumericConstantContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNumericConstantContext() *NumericConstantContext {
	var p = new(NumericConstantContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PHPParserRULE_numericConstant
	return p
}

func (*NumericConstantContext) IsNumericConstantContext() {}

func NewNumericConstantContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NumericConstantContext {
	var p = new(NumericConstantContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PHPParserRULE_numericConstant

	return p
}

func (s *NumericConstantContext) GetParser() antlr.Parser { return s.parser }

func (s *NumericConstantContext) Octal() antlr.TerminalNode {
	return s.GetToken(PHPParserOctal, 0)
}

func (s *NumericConstantContext) Decimal() antlr.TerminalNode {
	return s.GetToken(PHPParserDecimal, 0)
}

func (s *NumericConstantContext) Hex() antlr.TerminalNode {
	return s.GetToken(PHPParserHex, 0)
}

func (s *NumericConstantContext) Binary() antlr.TerminalNode {
	return s.GetToken(PHPParserBinary, 0)
}

func (s *NumericConstantContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NumericConstantContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NumericConstantContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PHPParserVisitor:
		return t.VisitNumericConstant(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PHPParser) NumericConstant() (localctx INumericConstantContext) {
	this := p
	_ = this

	localctx = NewNumericConstantContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 252, PHPParserRULE_numericConstant)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1902)
		_la = p.GetTokenStream().LA(1)

		if !((int64((_la-229)) & ^0x3f) == 0 && ((int64(1)<<(_la-229))&27) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IClassConstantContext is an interface to support dynamic dispatch.
type IClassConstantContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsClassConstantContext differentiates from other interfaces.
	IsClassConstantContext()
}

type ClassConstantContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyClassConstantContext() *ClassConstantContext {
	var p = new(ClassConstantContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PHPParserRULE_classConstant
	return p
}

func (*ClassConstantContext) IsClassConstantContext() {}

func NewClassConstantContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ClassConstantContext {
	var p = new(ClassConstantContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PHPParserRULE_classConstant

	return p
}

func (s *ClassConstantContext) GetParser() antlr.Parser { return s.parser }

func (s *ClassConstantContext) DoubleColon() antlr.TerminalNode {
	return s.GetToken(PHPParserDoubleColon, 0)
}

func (s *ClassConstantContext) Class() antlr.TerminalNode {
	return s.GetToken(PHPParserClass, 0)
}

func (s *ClassConstantContext) Parent_() antlr.TerminalNode {
	return s.GetToken(PHPParserParent_, 0)
}

func (s *ClassConstantContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ClassConstantContext) Constructor() antlr.TerminalNode {
	return s.GetToken(PHPParserConstructor, 0)
}

func (s *ClassConstantContext) Get() antlr.TerminalNode {
	return s.GetToken(PHPParserGet, 0)
}

func (s *ClassConstantContext) Set() antlr.TerminalNode {
	return s.GetToken(PHPParserSet, 0)
}

func (s *ClassConstantContext) QualifiedStaticTypeRef() IQualifiedStaticTypeRefContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedStaticTypeRefContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedStaticTypeRefContext)
}

func (s *ClassConstantContext) AllKeyedVariable() []IKeyedVariableContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IKeyedVariableContext); ok {
			len++
		}
	}

	tst := make([]IKeyedVariableContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IKeyedVariableContext); ok {
			tst[i] = t.(IKeyedVariableContext)
			i++
		}
	}

	return tst
}

func (s *ClassConstantContext) KeyedVariable(i int) IKeyedVariableContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKeyedVariableContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKeyedVariableContext)
}

func (s *ClassConstantContext) String_() IStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *ClassConstantContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ClassConstantContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ClassConstantContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PHPParserVisitor:
		return t.VisitClassConstant(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PHPParser) ClassConstant() (localctx IClassConstantContext) {
	this := p
	_ = this

	localctx = NewClassConstantContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 254, PHPParserRULE_classConstant)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1922)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 236, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1904)
			_la = p.GetTokenStream().LA(1)

			if !(_la == PHPParserClass || _la == PHPParserParent_) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(1905)
			p.Match(PHPParserDoubleColon)
		}
		p.SetState(1910)
		p.GetErrorHandler().Sync(p)
		switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 233, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(1906)
				p.Identifier()
			}

		case 2:
			{
				p.SetState(1907)
				p.Match(PHPParserConstructor)
			}

		case 3:
			{
				p.SetState(1908)
				p.Match(PHPParserGet)
			}

		case 4:
			{
				p.SetState(1909)
				p.Match(PHPParserSet)
			}

		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(1915)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case PHPParserAbstract, PHPParserArray, PHPParserAs, PHPParserBinaryCast, PHPParserBoolType, PHPParserBooleanConstant, PHPParserBreak, PHPParserCallable, PHPParserCase, PHPParserCatch, PHPParserClass, PHPParserClone, PHPParserConst, PHPParserContinue, PHPParserDeclare, PHPParserDefault, PHPParserDo, PHPParserDoubleCast, PHPParserDoubleType, PHPParserEcho, PHPParserElse, PHPParserElseIf, PHPParserEmpty, PHPParserEnum_, PHPParserEndDeclare, PHPParserEndFor, PHPParserEndForeach, PHPParserEndIf, PHPParserEndSwitch, PHPParserEndWhile, PHPParserExtends, PHPParserFinal, PHPParserFinally, PHPParserFloatCast, PHPParserFor, PHPParserForeach, PHPParserFunction_, PHPParserGlobal, PHPParserGoto, PHPParserIf, PHPParserImplements, PHPParserImport, PHPParserInstanceOf, PHPParserInsteadOf, PHPParserInt8Cast, PHPParserInt16Cast, PHPParserInt64Type, PHPParserIntType, PHPParserInterface, PHPParserList, PHPParserLogicalAnd, PHPParserLogicalOr, PHPParserLogicalXor, PHPParserMatch_, PHPParserNamespace, PHPParserNew, PHPParserNull, PHPParserObjectType, PHPParserParent_, PHPParserPartial, PHPParserPrint, PHPParserPrivate, PHPParserProtected, PHPParserPublic, PHPParserReadonly, PHPParserResource, PHPParserReturn, PHPParserStatic, PHPParserStringType, PHPParserSwitch, PHPParserTrait, PHPParserTry, PHPParserTypeof, PHPParserUintCast, PHPParserUnicodeCast, PHPParserUse, PHPParserVar, PHPParserWhile, PHPParserYield, PHPParserFrom, PHPParserLambdaFn, PHPParserTicks, PHPParserEncoding, PHPParserStrictTypes, PHPParserGet, PHPParserSet, PHPParserCall, PHPParserCallStatic, PHPParserConstructor, PHPParserDestruct, PHPParserWakeup, PHPParserSleep, PHPParserAutoload, PHPParserIsSet__, PHPParserUnset__, PHPParserToString__, PHPParserInvoke, PHPParserSetState, PHPParserClone__, PHPParserDebugInfo, PHPParserNamespace__, PHPParserClass__, PHPParserTraic__, PHPParserFunction__, PHPParserMethod__, PHPParserLine__, PHPParserFile__, PHPParserDir__, PHPParserNamespaceSeparator, PHPParserLabel:
			{
				p.SetState(1912)
				p.QualifiedStaticTypeRef()
			}

		case PHPParserDollar, PHPParserVarName:
			{
				p.SetState(1913)
				p.KeyedVariable()
			}

		case PHPParserSingleQuoteString, PHPParserDoubleQuote, PHPParserStartNowDoc, PHPParserStartHereDoc:
			{
				p.SetState(1914)
				p.String_()
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}
		{
			p.SetState(1917)
			p.Match(PHPParserDoubleColon)
		}
		p.SetState(1920)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case PHPParserAbstract, PHPParserArray, PHPParserAs, PHPParserBinaryCast, PHPParserBoolType, PHPParserBooleanConstant, PHPParserBreak, PHPParserCallable, PHPParserCase, PHPParserCatch, PHPParserClass, PHPParserClone, PHPParserConst, PHPParserContinue, PHPParserDeclare, PHPParserDefault, PHPParserDo, PHPParserDoubleCast, PHPParserDoubleType, PHPParserEcho, PHPParserElse, PHPParserElseIf, PHPParserEmpty, PHPParserEnum_, PHPParserEndDeclare, PHPParserEndFor, PHPParserEndForeach, PHPParserEndIf, PHPParserEndSwitch, PHPParserEndWhile, PHPParserExtends, PHPParserFinal, PHPParserFinally, PHPParserFloatCast, PHPParserFor, PHPParserForeach, PHPParserFunction_, PHPParserGlobal, PHPParserGoto, PHPParserIf, PHPParserImplements, PHPParserImport, PHPParserInstanceOf, PHPParserInsteadOf, PHPParserInt8Cast, PHPParserInt16Cast, PHPParserInt64Type, PHPParserIntType, PHPParserInterface, PHPParserList, PHPParserLogicalAnd, PHPParserLogicalOr, PHPParserLogicalXor, PHPParserMatch_, PHPParserNamespace, PHPParserNew, PHPParserNull, PHPParserObjectType, PHPParserParent_, PHPParserPartial, PHPParserPrint, PHPParserPrivate, PHPParserProtected, PHPParserPublic, PHPParserReadonly, PHPParserResource, PHPParserReturn, PHPParserStatic, PHPParserStringType, PHPParserSwitch, PHPParserTrait, PHPParserTry, PHPParserTypeof, PHPParserUintCast, PHPParserUnicodeCast, PHPParserUse, PHPParserVar, PHPParserWhile, PHPParserYield, PHPParserFrom, PHPParserLambdaFn, PHPParserTicks, PHPParserEncoding, PHPParserStrictTypes, PHPParserGet, PHPParserSet, PHPParserCall, PHPParserCallStatic, PHPParserConstructor, PHPParserDestruct, PHPParserWakeup, PHPParserSleep, PHPParserAutoload, PHPParserIsSet__, PHPParserUnset__, PHPParserToString__, PHPParserInvoke, PHPParserSetState, PHPParserClone__, PHPParserDebugInfo, PHPParserNamespace__, PHPParserClass__, PHPParserTraic__, PHPParserFunction__, PHPParserMethod__, PHPParserLine__, PHPParserFile__, PHPParserDir__, PHPParserNamespaceSeparator, PHPParserLabel:
			{
				p.SetState(1918)
				p.Identifier()
			}

		case PHPParserDollar, PHPParserVarName:
			{
				p.SetState(1919)
				p.KeyedVariable()
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

	}

	return localctx
}

// IStringConstantContext is an interface to support dynamic dispatch.
type IStringConstantContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsStringConstantContext differentiates from other interfaces.
	IsStringConstantContext()
}

type StringConstantContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStringConstantContext() *StringConstantContext {
	var p = new(StringConstantContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PHPParserRULE_stringConstant
	return p
}

func (*StringConstantContext) IsStringConstantContext() {}

func NewStringConstantContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StringConstantContext {
	var p = new(StringConstantContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PHPParserRULE_stringConstant

	return p
}

func (s *StringConstantContext) GetParser() antlr.Parser { return s.parser }

func (s *StringConstantContext) Label() antlr.TerminalNode {
	return s.GetToken(PHPParserLabel, 0)
}

func (s *StringConstantContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StringConstantContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StringConstantContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PHPParserVisitor:
		return t.VisitStringConstant(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PHPParser) StringConstant() (localctx IStringConstantContext) {
	this := p
	_ = this

	localctx = NewStringConstantContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 256, PHPParserRULE_stringConstant)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1924)
		p.Match(PHPParserLabel)
	}

	return localctx
}

// IStringContext is an interface to support dynamic dispatch.
type IStringContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsStringContext differentiates from other interfaces.
	IsStringContext()
}

type StringContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStringContext() *StringContext {
	var p = new(StringContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PHPParserRULE_string
	return p
}

func (*StringContext) IsStringContext() {}

func NewStringContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StringContext {
	var p = new(StringContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PHPParserRULE_string

	return p
}

func (s *StringContext) GetParser() antlr.Parser { return s.parser }

func (s *StringContext) StartHereDoc() antlr.TerminalNode {
	return s.GetToken(PHPParserStartHereDoc, 0)
}

func (s *StringContext) AllHereDocText() []antlr.TerminalNode {
	return s.GetTokens(PHPParserHereDocText)
}

func (s *StringContext) HereDocText(i int) antlr.TerminalNode {
	return s.GetToken(PHPParserHereDocText, i)
}

func (s *StringContext) StartNowDoc() antlr.TerminalNode {
	return s.GetToken(PHPParserStartNowDoc, 0)
}

func (s *StringContext) SingleQuoteString() antlr.TerminalNode {
	return s.GetToken(PHPParserSingleQuoteString, 0)
}

func (s *StringContext) AllDoubleQuote() []antlr.TerminalNode {
	return s.GetTokens(PHPParserDoubleQuote)
}

func (s *StringContext) DoubleQuote(i int) antlr.TerminalNode {
	return s.GetToken(PHPParserDoubleQuote, i)
}

func (s *StringContext) AllInterpolatedStringPart() []IInterpolatedStringPartContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IInterpolatedStringPartContext); ok {
			len++
		}
	}

	tst := make([]IInterpolatedStringPartContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IInterpolatedStringPartContext); ok {
			tst[i] = t.(IInterpolatedStringPartContext)
			i++
		}
	}

	return tst
}

func (s *StringContext) InterpolatedStringPart(i int) IInterpolatedStringPartContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInterpolatedStringPartContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInterpolatedStringPartContext)
}

func (s *StringContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StringContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StringContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PHPParserVisitor:
		return t.VisitString(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PHPParser) String_() (localctx IStringContext) {
	this := p
	_ = this

	localctx = NewStringContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 258, PHPParserRULE_string)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.SetState(1947)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case PHPParserStartHereDoc:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1926)
			p.Match(PHPParserStartHereDoc)
		}
		p.SetState(1928)
		p.GetErrorHandler().Sync(p)
		_alt = 1
		for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			switch _alt {
			case 1:
				{
					p.SetState(1927)
					p.Match(PHPParserHereDocText)
				}

			default:
				panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			}

			p.SetState(1930)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 237, p.GetParserRuleContext())
		}

	case PHPParserStartNowDoc:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1932)
			p.Match(PHPParserStartNowDoc)
		}
		p.SetState(1934)
		p.GetErrorHandler().Sync(p)
		_alt = 1
		for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			switch _alt {
			case 1:
				{
					p.SetState(1933)
					p.Match(PHPParserHereDocText)
				}

			default:
				panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			}

			p.SetState(1936)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 238, p.GetParserRuleContext())
		}

	case PHPParserSingleQuoteString:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1938)
			p.Match(PHPParserSingleQuoteString)
		}

	case PHPParserDoubleQuote:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1939)
			p.Match(PHPParserDoubleQuote)
		}
		p.SetState(1943)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 239, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(1940)
					p.InterpolatedStringPart()
				}

			}
			p.SetState(1945)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 239, p.GetParserRuleContext())
		}
		{
			p.SetState(1946)
			p.Match(PHPParserDoubleQuote)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IInterpolatedStringPartContext is an interface to support dynamic dispatch.
type IInterpolatedStringPartContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInterpolatedStringPartContext differentiates from other interfaces.
	IsInterpolatedStringPartContext()
}

type InterpolatedStringPartContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInterpolatedStringPartContext() *InterpolatedStringPartContext {
	var p = new(InterpolatedStringPartContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PHPParserRULE_interpolatedStringPart
	return p
}

func (*InterpolatedStringPartContext) IsInterpolatedStringPartContext() {}

func NewInterpolatedStringPartContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InterpolatedStringPartContext {
	var p = new(InterpolatedStringPartContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PHPParserRULE_interpolatedStringPart

	return p
}

func (s *InterpolatedStringPartContext) GetParser() antlr.Parser { return s.parser }

func (s *InterpolatedStringPartContext) StringPart() antlr.TerminalNode {
	return s.GetToken(PHPParserStringPart, 0)
}

func (s *InterpolatedStringPartContext) UnicodeEscape() antlr.TerminalNode {
	return s.GetToken(PHPParserUnicodeEscape, 0)
}

func (s *InterpolatedStringPartContext) Chain() IChainContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IChainContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IChainContext)
}

func (s *InterpolatedStringPartContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InterpolatedStringPartContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InterpolatedStringPartContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PHPParserVisitor:
		return t.VisitInterpolatedStringPart(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PHPParser) InterpolatedStringPart() (localctx IInterpolatedStringPartContext) {
	this := p
	_ = this

	localctx = NewInterpolatedStringPartContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 260, PHPParserRULE_interpolatedStringPart)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1952)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case PHPParserStringPart:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1949)
			p.Match(PHPParserStringPart)
		}

	case PHPParserUnicodeEscape:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1950)
			p.Match(PHPParserUnicodeEscape)
		}

	case PHPParserAbstract, PHPParserArray, PHPParserAs, PHPParserBinaryCast, PHPParserBoolType, PHPParserBooleanConstant, PHPParserBreak, PHPParserCallable, PHPParserCase, PHPParserCatch, PHPParserClass, PHPParserClone, PHPParserConst, PHPParserContinue, PHPParserDeclare, PHPParserDefault, PHPParserDo, PHPParserDoubleCast, PHPParserDoubleType, PHPParserEcho, PHPParserElse, PHPParserElseIf, PHPParserEmpty, PHPParserEnum_, PHPParserEndDeclare, PHPParserEndFor, PHPParserEndForeach, PHPParserEndIf, PHPParserEndSwitch, PHPParserEndWhile, PHPParserExtends, PHPParserFinal, PHPParserFinally, PHPParserFloatCast, PHPParserFor, PHPParserForeach, PHPParserFunction_, PHPParserGlobal, PHPParserGoto, PHPParserIf, PHPParserImplements, PHPParserImport, PHPParserInstanceOf, PHPParserInsteadOf, PHPParserInt8Cast, PHPParserInt16Cast, PHPParserInt64Type, PHPParserIntType, PHPParserInterface, PHPParserList, PHPParserLogicalAnd, PHPParserLogicalOr, PHPParserLogicalXor, PHPParserMatch_, PHPParserNamespace, PHPParserNew, PHPParserNull, PHPParserObjectType, PHPParserParent_, PHPParserPartial, PHPParserPrint, PHPParserPrivate, PHPParserProtected, PHPParserPublic, PHPParserReadonly, PHPParserResource, PHPParserReturn, PHPParserStatic, PHPParserStringType, PHPParserSwitch, PHPParserTrait, PHPParserTry, PHPParserTypeof, PHPParserUintCast, PHPParserUnicodeCast, PHPParserUse, PHPParserVar, PHPParserWhile, PHPParserYield, PHPParserFrom, PHPParserLambdaFn, PHPParserTicks, PHPParserEncoding, PHPParserStrictTypes, PHPParserGet, PHPParserSet, PHPParserCall, PHPParserCallStatic, PHPParserConstructor, PHPParserDestruct, PHPParserWakeup, PHPParserSleep, PHPParserAutoload, PHPParserIsSet__, PHPParserUnset__, PHPParserToString__, PHPParserInvoke, PHPParserSetState, PHPParserClone__, PHPParserDebugInfo, PHPParserNamespace__, PHPParserClass__, PHPParserTraic__, PHPParserFunction__, PHPParserMethod__, PHPParserLine__, PHPParserFile__, PHPParserDir__, PHPParserNamespaceSeparator, PHPParserDollar, PHPParserOpenRoundBracket, PHPParserOpenSquareBracket, PHPParserVarName, PHPParserLabel, PHPParserSingleQuoteString, PHPParserDoubleQuote, PHPParserStartNowDoc, PHPParserStartHereDoc:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1951)
			p.Chain()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IChainListContext is an interface to support dynamic dispatch.
type IChainListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsChainListContext differentiates from other interfaces.
	IsChainListContext()
}

type ChainListContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyChainListContext() *ChainListContext {
	var p = new(ChainListContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PHPParserRULE_chainList
	return p
}

func (*ChainListContext) IsChainListContext() {}

func NewChainListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ChainListContext {
	var p = new(ChainListContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PHPParserRULE_chainList

	return p
}

func (s *ChainListContext) GetParser() antlr.Parser { return s.parser }

func (s *ChainListContext) AllChain() []IChainContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IChainContext); ok {
			len++
		}
	}

	tst := make([]IChainContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IChainContext); ok {
			tst[i] = t.(IChainContext)
			i++
		}
	}

	return tst
}

func (s *ChainListContext) Chain(i int) IChainContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IChainContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IChainContext)
}

func (s *ChainListContext) AllComma() []antlr.TerminalNode {
	return s.GetTokens(PHPParserComma)
}

func (s *ChainListContext) Comma(i int) antlr.TerminalNode {
	return s.GetToken(PHPParserComma, i)
}

func (s *ChainListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ChainListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ChainListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PHPParserVisitor:
		return t.VisitChainList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PHPParser) ChainList() (localctx IChainListContext) {
	this := p
	_ = this

	localctx = NewChainListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 262, PHPParserRULE_chainList)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1954)
		p.Chain()
	}
	p.SetState(1959)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == PHPParserComma {
		{
			p.SetState(1955)
			p.Match(PHPParserComma)
		}
		{
			p.SetState(1956)
			p.Chain()
		}

		p.SetState(1961)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IChainContext is an interface to support dynamic dispatch.
type IChainContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsChainContext differentiates from other interfaces.
	IsChainContext()
}

type ChainContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyChainContext() *ChainContext {
	var p = new(ChainContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PHPParserRULE_chain
	return p
}

func (*ChainContext) IsChainContext() {}

func NewChainContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ChainContext {
	var p = new(ChainContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PHPParserRULE_chain

	return p
}

func (s *ChainContext) GetParser() antlr.Parser { return s.parser }

func (s *ChainContext) ChainOrigin() IChainOriginContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IChainOriginContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IChainOriginContext)
}

func (s *ChainContext) AllMemberAccess() []IMemberAccessContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IMemberAccessContext); ok {
			len++
		}
	}

	tst := make([]IMemberAccessContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IMemberAccessContext); ok {
			tst[i] = t.(IMemberAccessContext)
			i++
		}
	}

	return tst
}

func (s *ChainContext) MemberAccess(i int) IMemberAccessContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMemberAccessContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMemberAccessContext)
}

func (s *ChainContext) ArrayCreation() IArrayCreationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArrayCreationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArrayCreationContext)
}

func (s *ChainContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ChainContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ChainContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PHPParserVisitor:
		return t.VisitChain(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PHPParser) Chain() (localctx IChainContext) {
	this := p
	_ = this

	localctx = NewChainContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 264, PHPParserRULE_chain)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1970)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 244, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1962)
			p.ChainOrigin()
		}
		p.SetState(1966)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == PHPParserObjectOperator {
			{
				p.SetState(1963)
				p.MemberAccess()
			}

			p.SetState(1968)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1969)
			p.ArrayCreation()
		}

	}

	return localctx
}

// IChainOriginContext is an interface to support dynamic dispatch.
type IChainOriginContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsChainOriginContext differentiates from other interfaces.
	IsChainOriginContext()
}

type ChainOriginContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyChainOriginContext() *ChainOriginContext {
	var p = new(ChainOriginContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PHPParserRULE_chainOrigin
	return p
}

func (*ChainOriginContext) IsChainOriginContext() {}

func NewChainOriginContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ChainOriginContext {
	var p = new(ChainOriginContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PHPParserRULE_chainOrigin

	return p
}

func (s *ChainOriginContext) GetParser() antlr.Parser { return s.parser }

func (s *ChainOriginContext) ChainBase() IChainBaseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IChainBaseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IChainBaseContext)
}

func (s *ChainOriginContext) FunctionCall() IFunctionCallContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionCallContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionCallContext)
}

func (s *ChainOriginContext) OpenRoundBracket() antlr.TerminalNode {
	return s.GetToken(PHPParserOpenRoundBracket, 0)
}

func (s *ChainOriginContext) NewExpr() INewExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INewExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INewExprContext)
}

func (s *ChainOriginContext) CloseRoundBracket() antlr.TerminalNode {
	return s.GetToken(PHPParserCloseRoundBracket, 0)
}

func (s *ChainOriginContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ChainOriginContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ChainOriginContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PHPParserVisitor:
		return t.VisitChainOrigin(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PHPParser) ChainOrigin() (localctx IChainOriginContext) {
	this := p
	_ = this

	localctx = NewChainOriginContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 266, PHPParserRULE_chainOrigin)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1978)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 245, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1972)
			p.ChainBase()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1973)
			p.FunctionCall()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1974)
			p.Match(PHPParserOpenRoundBracket)
		}
		{
			p.SetState(1975)
			p.NewExpr()
		}
		{
			p.SetState(1976)
			p.Match(PHPParserCloseRoundBracket)
		}

	}

	return localctx
}

// IMemberAccessContext is an interface to support dynamic dispatch.
type IMemberAccessContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMemberAccessContext differentiates from other interfaces.
	IsMemberAccessContext()
}

type MemberAccessContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMemberAccessContext() *MemberAccessContext {
	var p = new(MemberAccessContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PHPParserRULE_memberAccess
	return p
}

func (*MemberAccessContext) IsMemberAccessContext() {}

func NewMemberAccessContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MemberAccessContext {
	var p = new(MemberAccessContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PHPParserRULE_memberAccess

	return p
}

func (s *MemberAccessContext) GetParser() antlr.Parser { return s.parser }

func (s *MemberAccessContext) ObjectOperator() antlr.TerminalNode {
	return s.GetToken(PHPParserObjectOperator, 0)
}

func (s *MemberAccessContext) KeyedFieldName() IKeyedFieldNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKeyedFieldNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKeyedFieldNameContext)
}

func (s *MemberAccessContext) ActualArguments() IActualArgumentsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IActualArgumentsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IActualArgumentsContext)
}

func (s *MemberAccessContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MemberAccessContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MemberAccessContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PHPParserVisitor:
		return t.VisitMemberAccess(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PHPParser) MemberAccess() (localctx IMemberAccessContext) {
	this := p
	_ = this

	localctx = NewMemberAccessContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 268, PHPParserRULE_memberAccess)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1980)
		p.Match(PHPParserObjectOperator)
	}
	{
		p.SetState(1981)
		p.KeyedFieldName()
	}
	p.SetState(1983)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 246, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1982)
			p.ActualArguments()
		}

	}

	return localctx
}

// IFunctionCallContext is an interface to support dynamic dispatch.
type IFunctionCallContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFunctionCallContext differentiates from other interfaces.
	IsFunctionCallContext()
}

type FunctionCallContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunctionCallContext() *FunctionCallContext {
	var p = new(FunctionCallContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PHPParserRULE_functionCall
	return p
}

func (*FunctionCallContext) IsFunctionCallContext() {}

func NewFunctionCallContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FunctionCallContext {
	var p = new(FunctionCallContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PHPParserRULE_functionCall

	return p
}

func (s *FunctionCallContext) GetParser() antlr.Parser { return s.parser }

func (s *FunctionCallContext) FunctionCallName() IFunctionCallNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionCallNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionCallNameContext)
}

func (s *FunctionCallContext) ActualArguments() IActualArgumentsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IActualArgumentsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IActualArgumentsContext)
}

func (s *FunctionCallContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FunctionCallContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FunctionCallContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PHPParserVisitor:
		return t.VisitFunctionCall(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PHPParser) FunctionCall() (localctx IFunctionCallContext) {
	this := p
	_ = this

	localctx = NewFunctionCallContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 270, PHPParserRULE_functionCall)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1985)
		p.FunctionCallName()
	}
	{
		p.SetState(1986)
		p.ActualArguments()
	}

	return localctx
}

// IFunctionCallNameContext is an interface to support dynamic dispatch.
type IFunctionCallNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFunctionCallNameContext differentiates from other interfaces.
	IsFunctionCallNameContext()
}

type FunctionCallNameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunctionCallNameContext() *FunctionCallNameContext {
	var p = new(FunctionCallNameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PHPParserRULE_functionCallName
	return p
}

func (*FunctionCallNameContext) IsFunctionCallNameContext() {}

func NewFunctionCallNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FunctionCallNameContext {
	var p = new(FunctionCallNameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PHPParserRULE_functionCallName

	return p
}

func (s *FunctionCallNameContext) GetParser() antlr.Parser { return s.parser }

func (s *FunctionCallNameContext) QualifiedNamespaceName() IQualifiedNamespaceNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNamespaceNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNamespaceNameContext)
}

func (s *FunctionCallNameContext) ClassConstant() IClassConstantContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClassConstantContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClassConstantContext)
}

func (s *FunctionCallNameContext) ChainBase() IChainBaseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IChainBaseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IChainBaseContext)
}

func (s *FunctionCallNameContext) Parentheses() IParenthesesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IParenthesesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IParenthesesContext)
}

func (s *FunctionCallNameContext) Label() antlr.TerminalNode {
	return s.GetToken(PHPParserLabel, 0)
}

func (s *FunctionCallNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FunctionCallNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FunctionCallNameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PHPParserVisitor:
		return t.VisitFunctionCallName(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PHPParser) FunctionCallName() (localctx IFunctionCallNameContext) {
	this := p
	_ = this

	localctx = NewFunctionCallNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 272, PHPParserRULE_functionCallName)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1993)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 247, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1988)
			p.QualifiedNamespaceName()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1989)
			p.ClassConstant()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1990)
			p.ChainBase()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1991)
			p.Parentheses()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1992)
			p.Match(PHPParserLabel)
		}

	}

	return localctx
}

// IActualArgumentsContext is an interface to support dynamic dispatch.
type IActualArgumentsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsActualArgumentsContext differentiates from other interfaces.
	IsActualArgumentsContext()
}

type ActualArgumentsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyActualArgumentsContext() *ActualArgumentsContext {
	var p = new(ActualArgumentsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PHPParserRULE_actualArguments
	return p
}

func (*ActualArgumentsContext) IsActualArgumentsContext() {}

func NewActualArgumentsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ActualArgumentsContext {
	var p = new(ActualArgumentsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PHPParserRULE_actualArguments

	return p
}

func (s *ActualArgumentsContext) GetParser() antlr.Parser { return s.parser }

func (s *ActualArgumentsContext) AllArguments() []IArgumentsContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IArgumentsContext); ok {
			len++
		}
	}

	tst := make([]IArgumentsContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IArgumentsContext); ok {
			tst[i] = t.(IArgumentsContext)
			i++
		}
	}

	return tst
}

func (s *ActualArgumentsContext) Arguments(i int) IArgumentsContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArgumentsContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArgumentsContext)
}

func (s *ActualArgumentsContext) AllSquareCurlyExpression() []ISquareCurlyExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISquareCurlyExpressionContext); ok {
			len++
		}
	}

	tst := make([]ISquareCurlyExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISquareCurlyExpressionContext); ok {
			tst[i] = t.(ISquareCurlyExpressionContext)
			i++
		}
	}

	return tst
}

func (s *ActualArgumentsContext) SquareCurlyExpression(i int) ISquareCurlyExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISquareCurlyExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISquareCurlyExpressionContext)
}

func (s *ActualArgumentsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ActualArgumentsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ActualArgumentsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PHPParserVisitor:
		return t.VisitActualArguments(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PHPParser) ActualArguments() (localctx IActualArgumentsContext) {
	this := p
	_ = this

	localctx = NewActualArgumentsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 274, PHPParserRULE_actualArguments)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1996)
	p.GetErrorHandler().Sync(p)
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			{
				p.SetState(1995)
				p.Arguments()
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(1998)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 248, p.GetParserRuleContext())
	}
	p.SetState(2003)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 249, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(2000)
				p.SquareCurlyExpression()
			}

		}
		p.SetState(2005)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 249, p.GetParserRuleContext())
	}

	return localctx
}

// IChainBaseContext is an interface to support dynamic dispatch.
type IChainBaseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsChainBaseContext differentiates from other interfaces.
	IsChainBaseContext()
}

type ChainBaseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyChainBaseContext() *ChainBaseContext {
	var p = new(ChainBaseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PHPParserRULE_chainBase
	return p
}

func (*ChainBaseContext) IsChainBaseContext() {}

func NewChainBaseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ChainBaseContext {
	var p = new(ChainBaseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PHPParserRULE_chainBase

	return p
}

func (s *ChainBaseContext) GetParser() antlr.Parser { return s.parser }

func (s *ChainBaseContext) AllKeyedVariable() []IKeyedVariableContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IKeyedVariableContext); ok {
			len++
		}
	}

	tst := make([]IKeyedVariableContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IKeyedVariableContext); ok {
			tst[i] = t.(IKeyedVariableContext)
			i++
		}
	}

	return tst
}

func (s *ChainBaseContext) KeyedVariable(i int) IKeyedVariableContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKeyedVariableContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKeyedVariableContext)
}

func (s *ChainBaseContext) DoubleColon() antlr.TerminalNode {
	return s.GetToken(PHPParserDoubleColon, 0)
}

func (s *ChainBaseContext) QualifiedStaticTypeRef() IQualifiedStaticTypeRefContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedStaticTypeRefContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedStaticTypeRefContext)
}

func (s *ChainBaseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ChainBaseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ChainBaseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PHPParserVisitor:
		return t.VisitChainBase(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PHPParser) ChainBase() (localctx IChainBaseContext) {
	this := p
	_ = this

	localctx = NewChainBaseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 276, PHPParserRULE_chainBase)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(2015)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case PHPParserDollar, PHPParserVarName:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2006)
			p.KeyedVariable()
		}
		p.SetState(2009)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 250, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(2007)
				p.Match(PHPParserDoubleColon)
			}
			{
				p.SetState(2008)
				p.KeyedVariable()
			}

		}

	case PHPParserAbstract, PHPParserArray, PHPParserAs, PHPParserBinaryCast, PHPParserBoolType, PHPParserBooleanConstant, PHPParserBreak, PHPParserCallable, PHPParserCase, PHPParserCatch, PHPParserClass, PHPParserClone, PHPParserConst, PHPParserContinue, PHPParserDeclare, PHPParserDefault, PHPParserDo, PHPParserDoubleCast, PHPParserDoubleType, PHPParserEcho, PHPParserElse, PHPParserElseIf, PHPParserEmpty, PHPParserEnum_, PHPParserEndDeclare, PHPParserEndFor, PHPParserEndForeach, PHPParserEndIf, PHPParserEndSwitch, PHPParserEndWhile, PHPParserExtends, PHPParserFinal, PHPParserFinally, PHPParserFloatCast, PHPParserFor, PHPParserForeach, PHPParserFunction_, PHPParserGlobal, PHPParserGoto, PHPParserIf, PHPParserImplements, PHPParserImport, PHPParserInstanceOf, PHPParserInsteadOf, PHPParserInt8Cast, PHPParserInt16Cast, PHPParserInt64Type, PHPParserIntType, PHPParserInterface, PHPParserList, PHPParserLogicalAnd, PHPParserLogicalOr, PHPParserLogicalXor, PHPParserMatch_, PHPParserNamespace, PHPParserNew, PHPParserNull, PHPParserObjectType, PHPParserParent_, PHPParserPartial, PHPParserPrint, PHPParserPrivate, PHPParserProtected, PHPParserPublic, PHPParserReadonly, PHPParserResource, PHPParserReturn, PHPParserStatic, PHPParserStringType, PHPParserSwitch, PHPParserTrait, PHPParserTry, PHPParserTypeof, PHPParserUintCast, PHPParserUnicodeCast, PHPParserUse, PHPParserVar, PHPParserWhile, PHPParserYield, PHPParserFrom, PHPParserLambdaFn, PHPParserTicks, PHPParserEncoding, PHPParserStrictTypes, PHPParserGet, PHPParserSet, PHPParserCall, PHPParserCallStatic, PHPParserConstructor, PHPParserDestruct, PHPParserWakeup, PHPParserSleep, PHPParserAutoload, PHPParserIsSet__, PHPParserUnset__, PHPParserToString__, PHPParserInvoke, PHPParserSetState, PHPParserClone__, PHPParserDebugInfo, PHPParserNamespace__, PHPParserClass__, PHPParserTraic__, PHPParserFunction__, PHPParserMethod__, PHPParserLine__, PHPParserFile__, PHPParserDir__, PHPParserNamespaceSeparator, PHPParserLabel:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2011)
			p.QualifiedStaticTypeRef()
		}
		{
			p.SetState(2012)
			p.Match(PHPParserDoubleColon)
		}
		{
			p.SetState(2013)
			p.KeyedVariable()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IKeyedFieldNameContext is an interface to support dynamic dispatch.
type IKeyedFieldNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsKeyedFieldNameContext differentiates from other interfaces.
	IsKeyedFieldNameContext()
}

type KeyedFieldNameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKeyedFieldNameContext() *KeyedFieldNameContext {
	var p = new(KeyedFieldNameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PHPParserRULE_keyedFieldName
	return p
}

func (*KeyedFieldNameContext) IsKeyedFieldNameContext() {}

func NewKeyedFieldNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *KeyedFieldNameContext {
	var p = new(KeyedFieldNameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PHPParserRULE_keyedFieldName

	return p
}

func (s *KeyedFieldNameContext) GetParser() antlr.Parser { return s.parser }

func (s *KeyedFieldNameContext) KeyedSimpleFieldName() IKeyedSimpleFieldNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKeyedSimpleFieldNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKeyedSimpleFieldNameContext)
}

func (s *KeyedFieldNameContext) KeyedVariable() IKeyedVariableContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKeyedVariableContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKeyedVariableContext)
}

func (s *KeyedFieldNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KeyedFieldNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *KeyedFieldNameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PHPParserVisitor:
		return t.VisitKeyedFieldName(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PHPParser) KeyedFieldName() (localctx IKeyedFieldNameContext) {
	this := p
	_ = this

	localctx = NewKeyedFieldNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 278, PHPParserRULE_keyedFieldName)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(2019)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case PHPParserAbstract, PHPParserArray, PHPParserAs, PHPParserBinaryCast, PHPParserBoolType, PHPParserBooleanConstant, PHPParserBreak, PHPParserCallable, PHPParserCase, PHPParserCatch, PHPParserClass, PHPParserClone, PHPParserConst, PHPParserContinue, PHPParserDeclare, PHPParserDefault, PHPParserDo, PHPParserDoubleCast, PHPParserDoubleType, PHPParserEcho, PHPParserElse, PHPParserElseIf, PHPParserEmpty, PHPParserEnum_, PHPParserEndDeclare, PHPParserEndFor, PHPParserEndForeach, PHPParserEndIf, PHPParserEndSwitch, PHPParserEndWhile, PHPParserExtends, PHPParserFinal, PHPParserFinally, PHPParserFloatCast, PHPParserFor, PHPParserForeach, PHPParserFunction_, PHPParserGlobal, PHPParserGoto, PHPParserIf, PHPParserImplements, PHPParserImport, PHPParserInstanceOf, PHPParserInsteadOf, PHPParserInt8Cast, PHPParserInt16Cast, PHPParserInt64Type, PHPParserIntType, PHPParserInterface, PHPParserList, PHPParserLogicalAnd, PHPParserLogicalOr, PHPParserLogicalXor, PHPParserMatch_, PHPParserNamespace, PHPParserNew, PHPParserNull, PHPParserObjectType, PHPParserParent_, PHPParserPartial, PHPParserPrint, PHPParserPrivate, PHPParserProtected, PHPParserPublic, PHPParserReadonly, PHPParserResource, PHPParserReturn, PHPParserStatic, PHPParserStringType, PHPParserSwitch, PHPParserTrait, PHPParserTry, PHPParserTypeof, PHPParserUintCast, PHPParserUnicodeCast, PHPParserUse, PHPParserVar, PHPParserWhile, PHPParserYield, PHPParserFrom, PHPParserLambdaFn, PHPParserTicks, PHPParserEncoding, PHPParserStrictTypes, PHPParserGet, PHPParserSet, PHPParserCall, PHPParserCallStatic, PHPParserConstructor, PHPParserDestruct, PHPParserWakeup, PHPParserSleep, PHPParserAutoload, PHPParserIsSet__, PHPParserUnset__, PHPParserToString__, PHPParserInvoke, PHPParserSetState, PHPParserClone__, PHPParserDebugInfo, PHPParserNamespace__, PHPParserClass__, PHPParserTraic__, PHPParserFunction__, PHPParserMethod__, PHPParserLine__, PHPParserFile__, PHPParserDir__, PHPParserNamespaceSeparator, PHPParserOpenCurlyBracket, PHPParserLabel:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2017)
			p.KeyedSimpleFieldName()
		}

	case PHPParserDollar, PHPParserVarName:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2018)
			p.KeyedVariable()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IKeyedSimpleFieldNameContext is an interface to support dynamic dispatch.
type IKeyedSimpleFieldNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsKeyedSimpleFieldNameContext differentiates from other interfaces.
	IsKeyedSimpleFieldNameContext()
}

type KeyedSimpleFieldNameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKeyedSimpleFieldNameContext() *KeyedSimpleFieldNameContext {
	var p = new(KeyedSimpleFieldNameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PHPParserRULE_keyedSimpleFieldName
	return p
}

func (*KeyedSimpleFieldNameContext) IsKeyedSimpleFieldNameContext() {}

func NewKeyedSimpleFieldNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *KeyedSimpleFieldNameContext {
	var p = new(KeyedSimpleFieldNameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PHPParserRULE_keyedSimpleFieldName

	return p
}

func (s *KeyedSimpleFieldNameContext) GetParser() antlr.Parser { return s.parser }

func (s *KeyedSimpleFieldNameContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *KeyedSimpleFieldNameContext) OpenCurlyBracket() antlr.TerminalNode {
	return s.GetToken(PHPParserOpenCurlyBracket, 0)
}

func (s *KeyedSimpleFieldNameContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *KeyedSimpleFieldNameContext) CloseCurlyBracket() antlr.TerminalNode {
	return s.GetToken(PHPParserCloseCurlyBracket, 0)
}

func (s *KeyedSimpleFieldNameContext) AllSquareCurlyExpression() []ISquareCurlyExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISquareCurlyExpressionContext); ok {
			len++
		}
	}

	tst := make([]ISquareCurlyExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISquareCurlyExpressionContext); ok {
			tst[i] = t.(ISquareCurlyExpressionContext)
			i++
		}
	}

	return tst
}

func (s *KeyedSimpleFieldNameContext) SquareCurlyExpression(i int) ISquareCurlyExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISquareCurlyExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISquareCurlyExpressionContext)
}

func (s *KeyedSimpleFieldNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KeyedSimpleFieldNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *KeyedSimpleFieldNameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PHPParserVisitor:
		return t.VisitKeyedSimpleFieldName(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PHPParser) KeyedSimpleFieldName() (localctx IKeyedSimpleFieldNameContext) {
	this := p
	_ = this

	localctx = NewKeyedSimpleFieldNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 280, PHPParserRULE_keyedSimpleFieldName)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2026)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case PHPParserAbstract, PHPParserArray, PHPParserAs, PHPParserBinaryCast, PHPParserBoolType, PHPParserBooleanConstant, PHPParserBreak, PHPParserCallable, PHPParserCase, PHPParserCatch, PHPParserClass, PHPParserClone, PHPParserConst, PHPParserContinue, PHPParserDeclare, PHPParserDefault, PHPParserDo, PHPParserDoubleCast, PHPParserDoubleType, PHPParserEcho, PHPParserElse, PHPParserElseIf, PHPParserEmpty, PHPParserEnum_, PHPParserEndDeclare, PHPParserEndFor, PHPParserEndForeach, PHPParserEndIf, PHPParserEndSwitch, PHPParserEndWhile, PHPParserExtends, PHPParserFinal, PHPParserFinally, PHPParserFloatCast, PHPParserFor, PHPParserForeach, PHPParserFunction_, PHPParserGlobal, PHPParserGoto, PHPParserIf, PHPParserImplements, PHPParserImport, PHPParserInstanceOf, PHPParserInsteadOf, PHPParserInt8Cast, PHPParserInt16Cast, PHPParserInt64Type, PHPParserIntType, PHPParserInterface, PHPParserList, PHPParserLogicalAnd, PHPParserLogicalOr, PHPParserLogicalXor, PHPParserMatch_, PHPParserNamespace, PHPParserNew, PHPParserNull, PHPParserObjectType, PHPParserParent_, PHPParserPartial, PHPParserPrint, PHPParserPrivate, PHPParserProtected, PHPParserPublic, PHPParserReadonly, PHPParserResource, PHPParserReturn, PHPParserStatic, PHPParserStringType, PHPParserSwitch, PHPParserTrait, PHPParserTry, PHPParserTypeof, PHPParserUintCast, PHPParserUnicodeCast, PHPParserUse, PHPParserVar, PHPParserWhile, PHPParserYield, PHPParserFrom, PHPParserLambdaFn, PHPParserTicks, PHPParserEncoding, PHPParserStrictTypes, PHPParserGet, PHPParserSet, PHPParserCall, PHPParserCallStatic, PHPParserConstructor, PHPParserDestruct, PHPParserWakeup, PHPParserSleep, PHPParserAutoload, PHPParserIsSet__, PHPParserUnset__, PHPParserToString__, PHPParserInvoke, PHPParserSetState, PHPParserClone__, PHPParserDebugInfo, PHPParserNamespace__, PHPParserClass__, PHPParserTraic__, PHPParserFunction__, PHPParserMethod__, PHPParserLine__, PHPParserFile__, PHPParserDir__, PHPParserNamespaceSeparator, PHPParserLabel:
		{
			p.SetState(2021)
			p.Identifier()
		}

	case PHPParserOpenCurlyBracket:
		{
			p.SetState(2022)
			p.Match(PHPParserOpenCurlyBracket)
		}
		{
			p.SetState(2023)
			p.expression(0)
		}
		{
			p.SetState(2024)
			p.Match(PHPParserCloseCurlyBracket)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}
	p.SetState(2031)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 254, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(2028)
				p.SquareCurlyExpression()
			}

		}
		p.SetState(2033)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 254, p.GetParserRuleContext())
	}

	return localctx
}

// IKeyedVariableContext is an interface to support dynamic dispatch.
type IKeyedVariableContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsKeyedVariableContext differentiates from other interfaces.
	IsKeyedVariableContext()
}

type KeyedVariableContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKeyedVariableContext() *KeyedVariableContext {
	var p = new(KeyedVariableContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PHPParserRULE_keyedVariable
	return p
}

func (*KeyedVariableContext) IsKeyedVariableContext() {}

func NewKeyedVariableContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *KeyedVariableContext {
	var p = new(KeyedVariableContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PHPParserRULE_keyedVariable

	return p
}

func (s *KeyedVariableContext) GetParser() antlr.Parser { return s.parser }

func (s *KeyedVariableContext) VarName() antlr.TerminalNode {
	return s.GetToken(PHPParserVarName, 0)
}

func (s *KeyedVariableContext) AllDollar() []antlr.TerminalNode {
	return s.GetTokens(PHPParserDollar)
}

func (s *KeyedVariableContext) Dollar(i int) antlr.TerminalNode {
	return s.GetToken(PHPParserDollar, i)
}

func (s *KeyedVariableContext) OpenCurlyBracket() antlr.TerminalNode {
	return s.GetToken(PHPParserOpenCurlyBracket, 0)
}

func (s *KeyedVariableContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *KeyedVariableContext) CloseCurlyBracket() antlr.TerminalNode {
	return s.GetToken(PHPParserCloseCurlyBracket, 0)
}

func (s *KeyedVariableContext) AllSquareCurlyExpression() []ISquareCurlyExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISquareCurlyExpressionContext); ok {
			len++
		}
	}

	tst := make([]ISquareCurlyExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISquareCurlyExpressionContext); ok {
			tst[i] = t.(ISquareCurlyExpressionContext)
			i++
		}
	}

	return tst
}

func (s *KeyedVariableContext) SquareCurlyExpression(i int) ISquareCurlyExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISquareCurlyExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISquareCurlyExpressionContext)
}

func (s *KeyedVariableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KeyedVariableContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *KeyedVariableContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PHPParserVisitor:
		return t.VisitKeyedVariable(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PHPParser) KeyedVariable() (localctx IKeyedVariableContext) {
	this := p
	_ = this

	localctx = NewKeyedVariableContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 282, PHPParserRULE_keyedVariable)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2037)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 255, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(2034)
				p.Match(PHPParserDollar)
			}

		}
		p.SetState(2039)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 255, p.GetParserRuleContext())
	}
	p.SetState(2046)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case PHPParserVarName:
		{
			p.SetState(2040)
			p.Match(PHPParserVarName)
		}

	case PHPParserDollar:
		{
			p.SetState(2041)
			p.Match(PHPParserDollar)
		}
		{
			p.SetState(2042)
			p.Match(PHPParserOpenCurlyBracket)
		}
		{
			p.SetState(2043)
			p.expression(0)
		}
		{
			p.SetState(2044)
			p.Match(PHPParserCloseCurlyBracket)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}
	p.SetState(2051)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 257, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(2048)
				p.SquareCurlyExpression()
			}

		}
		p.SetState(2053)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 257, p.GetParserRuleContext())
	}

	return localctx
}

// ISquareCurlyExpressionContext is an interface to support dynamic dispatch.
type ISquareCurlyExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSquareCurlyExpressionContext differentiates from other interfaces.
	IsSquareCurlyExpressionContext()
}

type SquareCurlyExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySquareCurlyExpressionContext() *SquareCurlyExpressionContext {
	var p = new(SquareCurlyExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PHPParserRULE_squareCurlyExpression
	return p
}

func (*SquareCurlyExpressionContext) IsSquareCurlyExpressionContext() {}

func NewSquareCurlyExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SquareCurlyExpressionContext {
	var p = new(SquareCurlyExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PHPParserRULE_squareCurlyExpression

	return p
}

func (s *SquareCurlyExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *SquareCurlyExpressionContext) OpenSquareBracket() antlr.TerminalNode {
	return s.GetToken(PHPParserOpenSquareBracket, 0)
}

func (s *SquareCurlyExpressionContext) CloseSquareBracket() antlr.TerminalNode {
	return s.GetToken(PHPParserCloseSquareBracket, 0)
}

func (s *SquareCurlyExpressionContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *SquareCurlyExpressionContext) OpenCurlyBracket() antlr.TerminalNode {
	return s.GetToken(PHPParserOpenCurlyBracket, 0)
}

func (s *SquareCurlyExpressionContext) CloseCurlyBracket() antlr.TerminalNode {
	return s.GetToken(PHPParserCloseCurlyBracket, 0)
}

func (s *SquareCurlyExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SquareCurlyExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SquareCurlyExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PHPParserVisitor:
		return t.VisitSquareCurlyExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PHPParser) SquareCurlyExpression() (localctx ISquareCurlyExpressionContext) {
	this := p
	_ = this

	localctx = NewSquareCurlyExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 284, PHPParserRULE_squareCurlyExpression)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(2063)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case PHPParserOpenSquareBracket:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2054)
			p.Match(PHPParserOpenSquareBracket)
		}
		p.SetState(2056)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if (int64((_la-44)) & ^0x3f) == 0 && ((int64(1)<<(_la-44))&-1) != 0 || (int64((_la-108)) & ^0x3f) == 0 && ((int64(1)<<(_la-108))&1873497444977737727) != 0 || (int64((_la-196)) & ^0x3f) == 0 && ((int64(1)<<(_la-196))&8795020649297) != 0 {
			{
				p.SetState(2055)
				p.expression(0)
			}

		}
		{
			p.SetState(2058)
			p.Match(PHPParserCloseSquareBracket)
		}

	case PHPParserOpenCurlyBracket:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2059)
			p.Match(PHPParserOpenCurlyBracket)
		}
		{
			p.SetState(2060)
			p.expression(0)
		}
		{
			p.SetState(2061)
			p.Match(PHPParserCloseCurlyBracket)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IAssignmentListContext is an interface to support dynamic dispatch.
type IAssignmentListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAssignmentListContext differentiates from other interfaces.
	IsAssignmentListContext()
}

type AssignmentListContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAssignmentListContext() *AssignmentListContext {
	var p = new(AssignmentListContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PHPParserRULE_assignmentList
	return p
}

func (*AssignmentListContext) IsAssignmentListContext() {}

func NewAssignmentListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AssignmentListContext {
	var p = new(AssignmentListContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PHPParserRULE_assignmentList

	return p
}

func (s *AssignmentListContext) GetParser() antlr.Parser { return s.parser }

func (s *AssignmentListContext) AllAssignmentListElement() []IAssignmentListElementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAssignmentListElementContext); ok {
			len++
		}
	}

	tst := make([]IAssignmentListElementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAssignmentListElementContext); ok {
			tst[i] = t.(IAssignmentListElementContext)
			i++
		}
	}

	return tst
}

func (s *AssignmentListContext) AssignmentListElement(i int) IAssignmentListElementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAssignmentListElementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAssignmentListElementContext)
}

func (s *AssignmentListContext) AllComma() []antlr.TerminalNode {
	return s.GetTokens(PHPParserComma)
}

func (s *AssignmentListContext) Comma(i int) antlr.TerminalNode {
	return s.GetToken(PHPParserComma, i)
}

func (s *AssignmentListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AssignmentListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AssignmentListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PHPParserVisitor:
		return t.VisitAssignmentList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PHPParser) AssignmentList() (localctx IAssignmentListContext) {
	this := p
	_ = this

	localctx = NewAssignmentListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 286, PHPParserRULE_assignmentList)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2066)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if (int64((_la-44)) & ^0x3f) == 0 && ((int64(1)<<(_la-44))&-1) != 0 || (int64((_la-108)) & ^0x3f) == 0 && ((int64(1)<<(_la-108))&1873497444977737727) != 0 || (int64((_la-196)) & ^0x3f) == 0 && ((int64(1)<<(_la-196))&8795020649297) != 0 {
		{
			p.SetState(2065)
			p.AssignmentListElement()
		}

	}
	p.SetState(2074)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == PHPParserComma {
		{
			p.SetState(2068)
			p.Match(PHPParserComma)
		}
		p.SetState(2070)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if (int64((_la-44)) & ^0x3f) == 0 && ((int64(1)<<(_la-44))&-1) != 0 || (int64((_la-108)) & ^0x3f) == 0 && ((int64(1)<<(_la-108))&1873497444977737727) != 0 || (int64((_la-196)) & ^0x3f) == 0 && ((int64(1)<<(_la-196))&8795020649297) != 0 {
			{
				p.SetState(2069)
				p.AssignmentListElement()
			}

		}

		p.SetState(2076)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IAssignmentListElementContext is an interface to support dynamic dispatch.
type IAssignmentListElementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAssignmentListElementContext differentiates from other interfaces.
	IsAssignmentListElementContext()
}

type AssignmentListElementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAssignmentListElementContext() *AssignmentListElementContext {
	var p = new(AssignmentListElementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PHPParserRULE_assignmentListElement
	return p
}

func (*AssignmentListElementContext) IsAssignmentListElementContext() {}

func NewAssignmentListElementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AssignmentListElementContext {
	var p = new(AssignmentListElementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PHPParserRULE_assignmentListElement

	return p
}

func (s *AssignmentListElementContext) GetParser() antlr.Parser { return s.parser }

func (s *AssignmentListElementContext) Chain() IChainContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IChainContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IChainContext)
}

func (s *AssignmentListElementContext) List() antlr.TerminalNode {
	return s.GetToken(PHPParserList, 0)
}

func (s *AssignmentListElementContext) OpenRoundBracket() antlr.TerminalNode {
	return s.GetToken(PHPParserOpenRoundBracket, 0)
}

func (s *AssignmentListElementContext) AssignmentList() IAssignmentListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAssignmentListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAssignmentListContext)
}

func (s *AssignmentListElementContext) CloseRoundBracket() antlr.TerminalNode {
	return s.GetToken(PHPParserCloseRoundBracket, 0)
}

func (s *AssignmentListElementContext) ArrayItem() IArrayItemContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArrayItemContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArrayItemContext)
}

func (s *AssignmentListElementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AssignmentListElementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AssignmentListElementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PHPParserVisitor:
		return t.VisitAssignmentListElement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PHPParser) AssignmentListElement() (localctx IAssignmentListElementContext) {
	this := p
	_ = this

	localctx = NewAssignmentListElementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 288, PHPParserRULE_assignmentListElement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(2084)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 263, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2077)
			p.Chain()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2078)
			p.Match(PHPParserList)
		}
		{
			p.SetState(2079)
			p.Match(PHPParserOpenRoundBracket)
		}
		{
			p.SetState(2080)
			p.AssignmentList()
		}
		{
			p.SetState(2081)
			p.Match(PHPParserCloseRoundBracket)
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2083)
			p.ArrayItem()
		}

	}

	return localctx
}

// IModifierContext is an interface to support dynamic dispatch.
type IModifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsModifierContext differentiates from other interfaces.
	IsModifierContext()
}

type ModifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyModifierContext() *ModifierContext {
	var p = new(ModifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PHPParserRULE_modifier
	return p
}

func (*ModifierContext) IsModifierContext() {}

func NewModifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ModifierContext {
	var p = new(ModifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PHPParserRULE_modifier

	return p
}

func (s *ModifierContext) GetParser() antlr.Parser { return s.parser }

func (s *ModifierContext) Abstract() antlr.TerminalNode {
	return s.GetToken(PHPParserAbstract, 0)
}

func (s *ModifierContext) Final() antlr.TerminalNode {
	return s.GetToken(PHPParserFinal, 0)
}

func (s *ModifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ModifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ModifierContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PHPParserVisitor:
		return t.VisitModifier(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PHPParser) Modifier() (localctx IModifierContext) {
	this := p
	_ = this

	localctx = NewModifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 290, PHPParserRULE_modifier)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2086)
		_la = p.GetTokenStream().LA(1)

		if !(_la == PHPParserAbstract || _la == PHPParserFinal) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IIdentifierContext is an interface to support dynamic dispatch.
type IIdentifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsIdentifierContext differentiates from other interfaces.
	IsIdentifierContext()
}

type IdentifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIdentifierContext() *IdentifierContext {
	var p = new(IdentifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PHPParserRULE_identifier
	return p
}

func (*IdentifierContext) IsIdentifierContext() {}

func NewIdentifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IdentifierContext {
	var p = new(IdentifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PHPParserRULE_identifier

	return p
}

func (s *IdentifierContext) GetParser() antlr.Parser { return s.parser }

func (s *IdentifierContext) Label() antlr.TerminalNode {
	return s.GetToken(PHPParserLabel, 0)
}

func (s *IdentifierContext) Key() IKeyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKeyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKeyContext)
}

func (s *IdentifierContext) NamespaceSeparator() antlr.TerminalNode {
	return s.GetToken(PHPParserNamespaceSeparator, 0)
}

func (s *IdentifierContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *IdentifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IdentifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IdentifierContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PHPParserVisitor:
		return t.VisitIdentifier(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PHPParser) Identifier() (localctx IIdentifierContext) {
	this := p
	_ = this

	localctx = NewIdentifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 292, PHPParserRULE_identifier)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(2092)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case PHPParserLabel:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2088)
			p.Match(PHPParserLabel)
		}

	case PHPParserAbstract, PHPParserArray, PHPParserAs, PHPParserBinaryCast, PHPParserBoolType, PHPParserBooleanConstant, PHPParserBreak, PHPParserCallable, PHPParserCase, PHPParserCatch, PHPParserClass, PHPParserClone, PHPParserConst, PHPParserContinue, PHPParserDeclare, PHPParserDefault, PHPParserDo, PHPParserDoubleCast, PHPParserDoubleType, PHPParserEcho, PHPParserElse, PHPParserElseIf, PHPParserEmpty, PHPParserEnum_, PHPParserEndDeclare, PHPParserEndFor, PHPParserEndForeach, PHPParserEndIf, PHPParserEndSwitch, PHPParserEndWhile, PHPParserExtends, PHPParserFinal, PHPParserFinally, PHPParserFloatCast, PHPParserFor, PHPParserForeach, PHPParserFunction_, PHPParserGlobal, PHPParserGoto, PHPParserIf, PHPParserImplements, PHPParserImport, PHPParserInstanceOf, PHPParserInsteadOf, PHPParserInt8Cast, PHPParserInt16Cast, PHPParserInt64Type, PHPParserIntType, PHPParserInterface, PHPParserList, PHPParserLogicalAnd, PHPParserLogicalOr, PHPParserLogicalXor, PHPParserMatch_, PHPParserNamespace, PHPParserNew, PHPParserNull, PHPParserObjectType, PHPParserParent_, PHPParserPartial, PHPParserPrint, PHPParserPrivate, PHPParserProtected, PHPParserPublic, PHPParserReadonly, PHPParserResource, PHPParserReturn, PHPParserStatic, PHPParserStringType, PHPParserSwitch, PHPParserTrait, PHPParserTry, PHPParserTypeof, PHPParserUintCast, PHPParserUnicodeCast, PHPParserUse, PHPParserVar, PHPParserWhile, PHPParserYield, PHPParserFrom, PHPParserLambdaFn, PHPParserTicks, PHPParserEncoding, PHPParserStrictTypes, PHPParserGet, PHPParserSet, PHPParserCall, PHPParserCallStatic, PHPParserConstructor, PHPParserDestruct, PHPParserWakeup, PHPParserSleep, PHPParserAutoload, PHPParserIsSet__, PHPParserUnset__, PHPParserToString__, PHPParserInvoke, PHPParserSetState, PHPParserClone__, PHPParserDebugInfo, PHPParserNamespace__, PHPParserClass__, PHPParserTraic__, PHPParserFunction__, PHPParserMethod__, PHPParserLine__, PHPParserFile__, PHPParserDir__:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2089)
			p.Key()
		}

	case PHPParserNamespaceSeparator:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2090)
			p.Match(PHPParserNamespaceSeparator)
		}
		{
			p.SetState(2091)
			p.Identifier()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IKeyContext is an interface to support dynamic dispatch.
type IKeyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsKeyContext differentiates from other interfaces.
	IsKeyContext()
}

type KeyContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKeyContext() *KeyContext {
	var p = new(KeyContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PHPParserRULE_key
	return p
}

func (*KeyContext) IsKeyContext() {}

func NewKeyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *KeyContext {
	var p = new(KeyContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PHPParserRULE_key

	return p
}

func (s *KeyContext) GetParser() antlr.Parser { return s.parser }

func (s *KeyContext) Abstract() antlr.TerminalNode {
	return s.GetToken(PHPParserAbstract, 0)
}

func (s *KeyContext) Array() antlr.TerminalNode {
	return s.GetToken(PHPParserArray, 0)
}

func (s *KeyContext) As() antlr.TerminalNode {
	return s.GetToken(PHPParserAs, 0)
}

func (s *KeyContext) BinaryCast() antlr.TerminalNode {
	return s.GetToken(PHPParserBinaryCast, 0)
}

func (s *KeyContext) BoolType() antlr.TerminalNode {
	return s.GetToken(PHPParserBoolType, 0)
}

func (s *KeyContext) BooleanConstant() antlr.TerminalNode {
	return s.GetToken(PHPParserBooleanConstant, 0)
}

func (s *KeyContext) Break() antlr.TerminalNode {
	return s.GetToken(PHPParserBreak, 0)
}

func (s *KeyContext) Callable() antlr.TerminalNode {
	return s.GetToken(PHPParserCallable, 0)
}

func (s *KeyContext) Case() antlr.TerminalNode {
	return s.GetToken(PHPParserCase, 0)
}

func (s *KeyContext) Catch() antlr.TerminalNode {
	return s.GetToken(PHPParserCatch, 0)
}

func (s *KeyContext) Class() antlr.TerminalNode {
	return s.GetToken(PHPParserClass, 0)
}

func (s *KeyContext) Clone() antlr.TerminalNode {
	return s.GetToken(PHPParserClone, 0)
}

func (s *KeyContext) Const() antlr.TerminalNode {
	return s.GetToken(PHPParserConst, 0)
}

func (s *KeyContext) Continue() antlr.TerminalNode {
	return s.GetToken(PHPParserContinue, 0)
}

func (s *KeyContext) Declare() antlr.TerminalNode {
	return s.GetToken(PHPParserDeclare, 0)
}

func (s *KeyContext) Default() antlr.TerminalNode {
	return s.GetToken(PHPParserDefault, 0)
}

func (s *KeyContext) Do() antlr.TerminalNode {
	return s.GetToken(PHPParserDo, 0)
}

func (s *KeyContext) DoubleCast() antlr.TerminalNode {
	return s.GetToken(PHPParserDoubleCast, 0)
}

func (s *KeyContext) DoubleType() antlr.TerminalNode {
	return s.GetToken(PHPParserDoubleType, 0)
}

func (s *KeyContext) Echo() antlr.TerminalNode {
	return s.GetToken(PHPParserEcho, 0)
}

func (s *KeyContext) Else() antlr.TerminalNode {
	return s.GetToken(PHPParserElse, 0)
}

func (s *KeyContext) ElseIf() antlr.TerminalNode {
	return s.GetToken(PHPParserElseIf, 0)
}

func (s *KeyContext) Empty() antlr.TerminalNode {
	return s.GetToken(PHPParserEmpty, 0)
}

func (s *KeyContext) EndDeclare() antlr.TerminalNode {
	return s.GetToken(PHPParserEndDeclare, 0)
}

func (s *KeyContext) EndFor() antlr.TerminalNode {
	return s.GetToken(PHPParserEndFor, 0)
}

func (s *KeyContext) EndForeach() antlr.TerminalNode {
	return s.GetToken(PHPParserEndForeach, 0)
}

func (s *KeyContext) EndIf() antlr.TerminalNode {
	return s.GetToken(PHPParserEndIf, 0)
}

func (s *KeyContext) EndSwitch() antlr.TerminalNode {
	return s.GetToken(PHPParserEndSwitch, 0)
}

func (s *KeyContext) EndWhile() antlr.TerminalNode {
	return s.GetToken(PHPParserEndWhile, 0)
}

func (s *KeyContext) Extends() antlr.TerminalNode {
	return s.GetToken(PHPParserExtends, 0)
}

func (s *KeyContext) Final() antlr.TerminalNode {
	return s.GetToken(PHPParserFinal, 0)
}

func (s *KeyContext) Finally() antlr.TerminalNode {
	return s.GetToken(PHPParserFinally, 0)
}

func (s *KeyContext) FloatCast() antlr.TerminalNode {
	return s.GetToken(PHPParserFloatCast, 0)
}

func (s *KeyContext) For() antlr.TerminalNode {
	return s.GetToken(PHPParserFor, 0)
}

func (s *KeyContext) Foreach() antlr.TerminalNode {
	return s.GetToken(PHPParserForeach, 0)
}

func (s *KeyContext) Function_() antlr.TerminalNode {
	return s.GetToken(PHPParserFunction_, 0)
}

func (s *KeyContext) Global() antlr.TerminalNode {
	return s.GetToken(PHPParserGlobal, 0)
}

func (s *KeyContext) Goto() antlr.TerminalNode {
	return s.GetToken(PHPParserGoto, 0)
}

func (s *KeyContext) If() antlr.TerminalNode {
	return s.GetToken(PHPParserIf, 0)
}

func (s *KeyContext) Implements() antlr.TerminalNode {
	return s.GetToken(PHPParserImplements, 0)
}

func (s *KeyContext) Import() antlr.TerminalNode {
	return s.GetToken(PHPParserImport, 0)
}

func (s *KeyContext) InstanceOf() antlr.TerminalNode {
	return s.GetToken(PHPParserInstanceOf, 0)
}

func (s *KeyContext) InsteadOf() antlr.TerminalNode {
	return s.GetToken(PHPParserInsteadOf, 0)
}

func (s *KeyContext) Int16Cast() antlr.TerminalNode {
	return s.GetToken(PHPParserInt16Cast, 0)
}

func (s *KeyContext) Int64Type() antlr.TerminalNode {
	return s.GetToken(PHPParserInt64Type, 0)
}

func (s *KeyContext) Int8Cast() antlr.TerminalNode {
	return s.GetToken(PHPParserInt8Cast, 0)
}

func (s *KeyContext) Interface() antlr.TerminalNode {
	return s.GetToken(PHPParserInterface, 0)
}

func (s *KeyContext) IntType() antlr.TerminalNode {
	return s.GetToken(PHPParserIntType, 0)
}

func (s *KeyContext) LambdaFn() antlr.TerminalNode {
	return s.GetToken(PHPParserLambdaFn, 0)
}

func (s *KeyContext) List() antlr.TerminalNode {
	return s.GetToken(PHPParserList, 0)
}

func (s *KeyContext) LogicalAnd() antlr.TerminalNode {
	return s.GetToken(PHPParserLogicalAnd, 0)
}

func (s *KeyContext) LogicalOr() antlr.TerminalNode {
	return s.GetToken(PHPParserLogicalOr, 0)
}

func (s *KeyContext) LogicalXor() antlr.TerminalNode {
	return s.GetToken(PHPParserLogicalXor, 0)
}

func (s *KeyContext) Namespace() antlr.TerminalNode {
	return s.GetToken(PHPParserNamespace, 0)
}

func (s *KeyContext) New() antlr.TerminalNode {
	return s.GetToken(PHPParserNew, 0)
}

func (s *KeyContext) Null() antlr.TerminalNode {
	return s.GetToken(PHPParserNull, 0)
}

func (s *KeyContext) ObjectType() antlr.TerminalNode {
	return s.GetToken(PHPParserObjectType, 0)
}

func (s *KeyContext) Parent_() antlr.TerminalNode {
	return s.GetToken(PHPParserParent_, 0)
}

func (s *KeyContext) Partial() antlr.TerminalNode {
	return s.GetToken(PHPParserPartial, 0)
}

func (s *KeyContext) Print() antlr.TerminalNode {
	return s.GetToken(PHPParserPrint, 0)
}

func (s *KeyContext) Private() antlr.TerminalNode {
	return s.GetToken(PHPParserPrivate, 0)
}

func (s *KeyContext) Protected() antlr.TerminalNode {
	return s.GetToken(PHPParserProtected, 0)
}

func (s *KeyContext) Public() antlr.TerminalNode {
	return s.GetToken(PHPParserPublic, 0)
}

func (s *KeyContext) Readonly() antlr.TerminalNode {
	return s.GetToken(PHPParserReadonly, 0)
}

func (s *KeyContext) Resource() antlr.TerminalNode {
	return s.GetToken(PHPParserResource, 0)
}

func (s *KeyContext) Return() antlr.TerminalNode {
	return s.GetToken(PHPParserReturn, 0)
}

func (s *KeyContext) Static() antlr.TerminalNode {
	return s.GetToken(PHPParserStatic, 0)
}

func (s *KeyContext) StringType() antlr.TerminalNode {
	return s.GetToken(PHPParserStringType, 0)
}

func (s *KeyContext) Switch() antlr.TerminalNode {
	return s.GetToken(PHPParserSwitch, 0)
}

func (s *KeyContext) Trait() antlr.TerminalNode {
	return s.GetToken(PHPParserTrait, 0)
}

func (s *KeyContext) Try() antlr.TerminalNode {
	return s.GetToken(PHPParserTry, 0)
}

func (s *KeyContext) Typeof() antlr.TerminalNode {
	return s.GetToken(PHPParserTypeof, 0)
}

func (s *KeyContext) UintCast() antlr.TerminalNode {
	return s.GetToken(PHPParserUintCast, 0)
}

func (s *KeyContext) UnicodeCast() antlr.TerminalNode {
	return s.GetToken(PHPParserUnicodeCast, 0)
}

func (s *KeyContext) Use() antlr.TerminalNode {
	return s.GetToken(PHPParserUse, 0)
}

func (s *KeyContext) Var() antlr.TerminalNode {
	return s.GetToken(PHPParserVar, 0)
}

func (s *KeyContext) While() antlr.TerminalNode {
	return s.GetToken(PHPParserWhile, 0)
}

func (s *KeyContext) Yield() antlr.TerminalNode {
	return s.GetToken(PHPParserYield, 0)
}

func (s *KeyContext) From() antlr.TerminalNode {
	return s.GetToken(PHPParserFrom, 0)
}

func (s *KeyContext) Enum_() antlr.TerminalNode {
	return s.GetToken(PHPParserEnum_, 0)
}

func (s *KeyContext) Match_() antlr.TerminalNode {
	return s.GetToken(PHPParserMatch_, 0)
}

func (s *KeyContext) Ticks() antlr.TerminalNode {
	return s.GetToken(PHPParserTicks, 0)
}

func (s *KeyContext) Encoding() antlr.TerminalNode {
	return s.GetToken(PHPParserEncoding, 0)
}

func (s *KeyContext) StrictTypes() antlr.TerminalNode {
	return s.GetToken(PHPParserStrictTypes, 0)
}

func (s *KeyContext) Get() antlr.TerminalNode {
	return s.GetToken(PHPParserGet, 0)
}

func (s *KeyContext) Set() antlr.TerminalNode {
	return s.GetToken(PHPParserSet, 0)
}

func (s *KeyContext) Call() antlr.TerminalNode {
	return s.GetToken(PHPParserCall, 0)
}

func (s *KeyContext) CallStatic() antlr.TerminalNode {
	return s.GetToken(PHPParserCallStatic, 0)
}

func (s *KeyContext) Constructor() antlr.TerminalNode {
	return s.GetToken(PHPParserConstructor, 0)
}

func (s *KeyContext) Destruct() antlr.TerminalNode {
	return s.GetToken(PHPParserDestruct, 0)
}

func (s *KeyContext) Wakeup() antlr.TerminalNode {
	return s.GetToken(PHPParserWakeup, 0)
}

func (s *KeyContext) Sleep() antlr.TerminalNode {
	return s.GetToken(PHPParserSleep, 0)
}

func (s *KeyContext) Autoload() antlr.TerminalNode {
	return s.GetToken(PHPParserAutoload, 0)
}

func (s *KeyContext) IsSet__() antlr.TerminalNode {
	return s.GetToken(PHPParserIsSet__, 0)
}

func (s *KeyContext) Unset__() antlr.TerminalNode {
	return s.GetToken(PHPParserUnset__, 0)
}

func (s *KeyContext) ToString__() antlr.TerminalNode {
	return s.GetToken(PHPParserToString__, 0)
}

func (s *KeyContext) Invoke() antlr.TerminalNode {
	return s.GetToken(PHPParserInvoke, 0)
}

func (s *KeyContext) SetState() antlr.TerminalNode {
	return s.GetToken(PHPParserSetState, 0)
}

func (s *KeyContext) Clone__() antlr.TerminalNode {
	return s.GetToken(PHPParserClone__, 0)
}

func (s *KeyContext) DebugInfo() antlr.TerminalNode {
	return s.GetToken(PHPParserDebugInfo, 0)
}

func (s *KeyContext) Namespace__() antlr.TerminalNode {
	return s.GetToken(PHPParserNamespace__, 0)
}

func (s *KeyContext) Class__() antlr.TerminalNode {
	return s.GetToken(PHPParserClass__, 0)
}

func (s *KeyContext) Traic__() antlr.TerminalNode {
	return s.GetToken(PHPParserTraic__, 0)
}

func (s *KeyContext) Function__() antlr.TerminalNode {
	return s.GetToken(PHPParserFunction__, 0)
}

func (s *KeyContext) Method__() antlr.TerminalNode {
	return s.GetToken(PHPParserMethod__, 0)
}

func (s *KeyContext) Line__() antlr.TerminalNode {
	return s.GetToken(PHPParserLine__, 0)
}

func (s *KeyContext) File__() antlr.TerminalNode {
	return s.GetToken(PHPParserFile__, 0)
}

func (s *KeyContext) Dir__() antlr.TerminalNode {
	return s.GetToken(PHPParserDir__, 0)
}

func (s *KeyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KeyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *KeyContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PHPParserVisitor:
		return t.VisitKey(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PHPParser) Key() (localctx IKeyContext) {
	this := p
	_ = this

	localctx = NewKeyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 294, PHPParserRULE_key)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2094)
		_la = p.GetTokenStream().LA(1)

		if !((int64((_la-44)) & ^0x3f) == 0 && ((int64(1)<<(_la-44))&-144959677430546433) != 0 || (int64((_la-108)) & ^0x3f) == 0 && ((int64(1)<<(_la-108))&144115188067333119) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IMemberModifierContext is an interface to support dynamic dispatch.
type IMemberModifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMemberModifierContext differentiates from other interfaces.
	IsMemberModifierContext()
}

type MemberModifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMemberModifierContext() *MemberModifierContext {
	var p = new(MemberModifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PHPParserRULE_memberModifier
	return p
}

func (*MemberModifierContext) IsMemberModifierContext() {}

func NewMemberModifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MemberModifierContext {
	var p = new(MemberModifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PHPParserRULE_memberModifier

	return p
}

func (s *MemberModifierContext) GetParser() antlr.Parser { return s.parser }

func (s *MemberModifierContext) Public() antlr.TerminalNode {
	return s.GetToken(PHPParserPublic, 0)
}

func (s *MemberModifierContext) Protected() antlr.TerminalNode {
	return s.GetToken(PHPParserProtected, 0)
}

func (s *MemberModifierContext) Private() antlr.TerminalNode {
	return s.GetToken(PHPParserPrivate, 0)
}

func (s *MemberModifierContext) Static() antlr.TerminalNode {
	return s.GetToken(PHPParserStatic, 0)
}

func (s *MemberModifierContext) Abstract() antlr.TerminalNode {
	return s.GetToken(PHPParserAbstract, 0)
}

func (s *MemberModifierContext) Final() antlr.TerminalNode {
	return s.GetToken(PHPParserFinal, 0)
}

func (s *MemberModifierContext) Readonly() antlr.TerminalNode {
	return s.GetToken(PHPParserReadonly, 0)
}

func (s *MemberModifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MemberModifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MemberModifierContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PHPParserVisitor:
		return t.VisitMemberModifier(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PHPParser) MemberModifier() (localctx IMemberModifierContext) {
	this := p
	_ = this

	localctx = NewMemberModifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 296, PHPParserRULE_memberModifier)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2096)
		_la = p.GetTokenStream().LA(1)

		if !(_la == PHPParserAbstract || (int64((_la-81)) & ^0x3f) == 0 && ((int64(1)<<(_la-81))&2327872274433) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IMagicConstantContext is an interface to support dynamic dispatch.
type IMagicConstantContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMagicConstantContext differentiates from other interfaces.
	IsMagicConstantContext()
}

type MagicConstantContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMagicConstantContext() *MagicConstantContext {
	var p = new(MagicConstantContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PHPParserRULE_magicConstant
	return p
}

func (*MagicConstantContext) IsMagicConstantContext() {}

func NewMagicConstantContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MagicConstantContext {
	var p = new(MagicConstantContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PHPParserRULE_magicConstant

	return p
}

func (s *MagicConstantContext) GetParser() antlr.Parser { return s.parser }

func (s *MagicConstantContext) Namespace__() antlr.TerminalNode {
	return s.GetToken(PHPParserNamespace__, 0)
}

func (s *MagicConstantContext) Class__() antlr.TerminalNode {
	return s.GetToken(PHPParserClass__, 0)
}

func (s *MagicConstantContext) Traic__() antlr.TerminalNode {
	return s.GetToken(PHPParserTraic__, 0)
}

func (s *MagicConstantContext) Function__() antlr.TerminalNode {
	return s.GetToken(PHPParserFunction__, 0)
}

func (s *MagicConstantContext) Method__() antlr.TerminalNode {
	return s.GetToken(PHPParserMethod__, 0)
}

func (s *MagicConstantContext) Line__() antlr.TerminalNode {
	return s.GetToken(PHPParserLine__, 0)
}

func (s *MagicConstantContext) File__() antlr.TerminalNode {
	return s.GetToken(PHPParserFile__, 0)
}

func (s *MagicConstantContext) Dir__() antlr.TerminalNode {
	return s.GetToken(PHPParserDir__, 0)
}

func (s *MagicConstantContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MagicConstantContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MagicConstantContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PHPParserVisitor:
		return t.VisitMagicConstant(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PHPParser) MagicConstant() (localctx IMagicConstantContext) {
	this := p
	_ = this

	localctx = NewMagicConstantContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 298, PHPParserRULE_magicConstant)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2098)
		_la = p.GetTokenStream().LA(1)

		if !((int64((_la-157)) & ^0x3f) == 0 && ((int64(1)<<(_la-157))&255) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IMagicMethodContext is an interface to support dynamic dispatch.
type IMagicMethodContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMagicMethodContext differentiates from other interfaces.
	IsMagicMethodContext()
}

type MagicMethodContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMagicMethodContext() *MagicMethodContext {
	var p = new(MagicMethodContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PHPParserRULE_magicMethod
	return p
}

func (*MagicMethodContext) IsMagicMethodContext() {}

func NewMagicMethodContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MagicMethodContext {
	var p = new(MagicMethodContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PHPParserRULE_magicMethod

	return p
}

func (s *MagicMethodContext) GetParser() antlr.Parser { return s.parser }

func (s *MagicMethodContext) Get() antlr.TerminalNode {
	return s.GetToken(PHPParserGet, 0)
}

func (s *MagicMethodContext) Set() antlr.TerminalNode {
	return s.GetToken(PHPParserSet, 0)
}

func (s *MagicMethodContext) Call() antlr.TerminalNode {
	return s.GetToken(PHPParserCall, 0)
}

func (s *MagicMethodContext) CallStatic() antlr.TerminalNode {
	return s.GetToken(PHPParserCallStatic, 0)
}

func (s *MagicMethodContext) Constructor() antlr.TerminalNode {
	return s.GetToken(PHPParserConstructor, 0)
}

func (s *MagicMethodContext) Destruct() antlr.TerminalNode {
	return s.GetToken(PHPParserDestruct, 0)
}

func (s *MagicMethodContext) Wakeup() antlr.TerminalNode {
	return s.GetToken(PHPParserWakeup, 0)
}

func (s *MagicMethodContext) Sleep() antlr.TerminalNode {
	return s.GetToken(PHPParserSleep, 0)
}

func (s *MagicMethodContext) Autoload() antlr.TerminalNode {
	return s.GetToken(PHPParserAutoload, 0)
}

func (s *MagicMethodContext) IsSet__() antlr.TerminalNode {
	return s.GetToken(PHPParserIsSet__, 0)
}

func (s *MagicMethodContext) Unset__() antlr.TerminalNode {
	return s.GetToken(PHPParserUnset__, 0)
}

func (s *MagicMethodContext) ToString__() antlr.TerminalNode {
	return s.GetToken(PHPParserToString__, 0)
}

func (s *MagicMethodContext) Invoke() antlr.TerminalNode {
	return s.GetToken(PHPParserInvoke, 0)
}

func (s *MagicMethodContext) SetState() antlr.TerminalNode {
	return s.GetToken(PHPParserSetState, 0)
}

func (s *MagicMethodContext) Clone__() antlr.TerminalNode {
	return s.GetToken(PHPParserClone__, 0)
}

func (s *MagicMethodContext) DebugInfo() antlr.TerminalNode {
	return s.GetToken(PHPParserDebugInfo, 0)
}

func (s *MagicMethodContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MagicMethodContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MagicMethodContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PHPParserVisitor:
		return t.VisitMagicMethod(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PHPParser) MagicMethod() (localctx IMagicMethodContext) {
	this := p
	_ = this

	localctx = NewMagicMethodContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 300, PHPParserRULE_magicMethod)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2100)
		_la = p.GetTokenStream().LA(1)

		if !((int64((_la-141)) & ^0x3f) == 0 && ((int64(1)<<(_la-141))&65535) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IPrimitiveTypeContext is an interface to support dynamic dispatch.
type IPrimitiveTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPrimitiveTypeContext differentiates from other interfaces.
	IsPrimitiveTypeContext()
}

type PrimitiveTypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPrimitiveTypeContext() *PrimitiveTypeContext {
	var p = new(PrimitiveTypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PHPParserRULE_primitiveType
	return p
}

func (*PrimitiveTypeContext) IsPrimitiveTypeContext() {}

func NewPrimitiveTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PrimitiveTypeContext {
	var p = new(PrimitiveTypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PHPParserRULE_primitiveType

	return p
}

func (s *PrimitiveTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *PrimitiveTypeContext) BoolType() antlr.TerminalNode {
	return s.GetToken(PHPParserBoolType, 0)
}

func (s *PrimitiveTypeContext) IntType() antlr.TerminalNode {
	return s.GetToken(PHPParserIntType, 0)
}

func (s *PrimitiveTypeContext) Int64Type() antlr.TerminalNode {
	return s.GetToken(PHPParserInt64Type, 0)
}

func (s *PrimitiveTypeContext) DoubleType() antlr.TerminalNode {
	return s.GetToken(PHPParserDoubleType, 0)
}

func (s *PrimitiveTypeContext) StringType() antlr.TerminalNode {
	return s.GetToken(PHPParserStringType, 0)
}

func (s *PrimitiveTypeContext) Resource() antlr.TerminalNode {
	return s.GetToken(PHPParserResource, 0)
}

func (s *PrimitiveTypeContext) ObjectType() antlr.TerminalNode {
	return s.GetToken(PHPParserObjectType, 0)
}

func (s *PrimitiveTypeContext) Array() antlr.TerminalNode {
	return s.GetToken(PHPParserArray, 0)
}

func (s *PrimitiveTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrimitiveTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PrimitiveTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PHPParserVisitor:
		return t.VisitPrimitiveType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PHPParser) PrimitiveType() (localctx IPrimitiveTypeContext) {
	this := p
	_ = this

	localctx = NewPrimitiveTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 302, PHPParserRULE_primitiveType)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2102)
		_la = p.GetTokenStream().LA(1)

		if !(_la == PHPParserArray || _la == PHPParserBoolType || (int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&648588766625136641) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// ICastOperationContext is an interface to support dynamic dispatch.
type ICastOperationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCastOperationContext differentiates from other interfaces.
	IsCastOperationContext()
}

type CastOperationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCastOperationContext() *CastOperationContext {
	var p = new(CastOperationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PHPParserRULE_castOperation
	return p
}

func (*CastOperationContext) IsCastOperationContext() {}

func NewCastOperationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CastOperationContext {
	var p = new(CastOperationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PHPParserRULE_castOperation

	return p
}

func (s *CastOperationContext) GetParser() antlr.Parser { return s.parser }

func (s *CastOperationContext) BoolType() antlr.TerminalNode {
	return s.GetToken(PHPParserBoolType, 0)
}

func (s *CastOperationContext) Int8Cast() antlr.TerminalNode {
	return s.GetToken(PHPParserInt8Cast, 0)
}

func (s *CastOperationContext) Int16Cast() antlr.TerminalNode {
	return s.GetToken(PHPParserInt16Cast, 0)
}

func (s *CastOperationContext) IntType() antlr.TerminalNode {
	return s.GetToken(PHPParserIntType, 0)
}

func (s *CastOperationContext) Int64Type() antlr.TerminalNode {
	return s.GetToken(PHPParserInt64Type, 0)
}

func (s *CastOperationContext) UintCast() antlr.TerminalNode {
	return s.GetToken(PHPParserUintCast, 0)
}

func (s *CastOperationContext) DoubleCast() antlr.TerminalNode {
	return s.GetToken(PHPParserDoubleCast, 0)
}

func (s *CastOperationContext) DoubleType() antlr.TerminalNode {
	return s.GetToken(PHPParserDoubleType, 0)
}

func (s *CastOperationContext) FloatCast() antlr.TerminalNode {
	return s.GetToken(PHPParserFloatCast, 0)
}

func (s *CastOperationContext) StringType() antlr.TerminalNode {
	return s.GetToken(PHPParserStringType, 0)
}

func (s *CastOperationContext) BinaryCast() antlr.TerminalNode {
	return s.GetToken(PHPParserBinaryCast, 0)
}

func (s *CastOperationContext) UnicodeCast() antlr.TerminalNode {
	return s.GetToken(PHPParserUnicodeCast, 0)
}

func (s *CastOperationContext) Array() antlr.TerminalNode {
	return s.GetToken(PHPParserArray, 0)
}

func (s *CastOperationContext) ObjectType() antlr.TerminalNode {
	return s.GetToken(PHPParserObjectType, 0)
}

func (s *CastOperationContext) Resource() antlr.TerminalNode {
	return s.GetToken(PHPParserResource, 0)
}

func (s *CastOperationContext) Unset() antlr.TerminalNode {
	return s.GetToken(PHPParserUnset, 0)
}

func (s *CastOperationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CastOperationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CastOperationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PHPParserVisitor:
		return t.VisitCastOperation(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PHPParser) CastOperation() (localctx ICastOperationContext) {
	this := p
	_ = this

	localctx = NewCastOperationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 304, PHPParserRULE_castOperation)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2104)
		_la = p.GetTokenStream().LA(1)

		if !((int64((_la-45)) & ^0x3f) == 0 && ((int64(1)<<(_la-45))&33777272083972109) != 0 || (int64((_la-110)) & ^0x3f) == 0 && ((int64(1)<<(_la-110))&3679233) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

func (p *PHPParser) Sempred(localctx antlr.RuleContext, ruleIndex, predIndex int) bool {
	switch ruleIndex {
	case 61:
		var t *TypeHintContext = nil
		if localctx != nil {
			t = localctx.(*TypeHintContext)
		}
		return p.TypeHint_Sempred(t, predIndex)

	case 90:
		var t *ExpressionContext = nil
		if localctx != nil {
			t = localctx.(*ExpressionContext)
		}
		return p.Expression_Sempred(t, predIndex)

	case 91:
		var t *FlexiVariableContext = nil
		if localctx != nil {
			t = localctx.(*FlexiVariableContext)
		}
		return p.FlexiVariable_Sempred(t, predIndex)

	default:
		panic("No predicate with index: " + fmt.Sprint(ruleIndex))
	}
}

func (p *PHPParser) TypeHint_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	this := p
	_ = this

	switch predIndex {
	case 0:
		return p.Precpred(p.GetParserRuleContext(), 1)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *PHPParser) Expression_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	this := p
	_ = this

	switch predIndex {
	case 1:
		return p.Precpred(p.GetParserRuleContext(), 21)

	case 2:
		return p.Precpred(p.GetParserRuleContext(), 19)

	case 3:
		return p.Precpred(p.GetParserRuleContext(), 18)

	case 4:
		return p.Precpred(p.GetParserRuleContext(), 17)

	case 5:
		return p.Precpred(p.GetParserRuleContext(), 16)

	case 6:
		return p.Precpred(p.GetParserRuleContext(), 15)

	case 7:
		return p.Precpred(p.GetParserRuleContext(), 14)

	case 8:
		return p.Precpred(p.GetParserRuleContext(), 13)

	case 9:
		return p.Precpred(p.GetParserRuleContext(), 12)

	case 10:
		return p.Precpred(p.GetParserRuleContext(), 11)

	case 11:
		return p.Precpred(p.GetParserRuleContext(), 10)

	case 12:
		return p.Precpred(p.GetParserRuleContext(), 9)

	case 13:
		return p.Precpred(p.GetParserRuleContext(), 8)

	case 14:
		return p.Precpred(p.GetParserRuleContext(), 7)

	case 15:
		return p.Precpred(p.GetParserRuleContext(), 3)

	case 16:
		return p.Precpred(p.GetParserRuleContext(), 2)

	case 17:
		return p.Precpred(p.GetParserRuleContext(), 1)

	case 18:
		return p.Precpred(p.GetParserRuleContext(), 51)

	case 19:
		return p.Precpred(p.GetParserRuleContext(), 50)

	case 20:
		return p.Precpred(p.GetParserRuleContext(), 49)

	case 21:
		return p.Precpred(p.GetParserRuleContext(), 20)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *PHPParser) FlexiVariable_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	this := p
	_ = this

	switch predIndex {
	case 22:
		return p.Precpred(p.GetParserRuleContext(), 3)

	case 23:
		return p.Precpred(p.GetParserRuleContext(), 2)

	case 24:
		return p.Precpred(p.GetParserRuleContext(), 1)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}
