// Code generated from java-escape by ANTLR 4.11.1. DO NOT EDIT.

package phpparser // PHPParser
import (
	"fmt"
	"strconv"
	"sync"

	"github.com/antlr/antlr4/runtime/Go/antlr/v4"
)

// Suppress unused import errors
var _ = fmt.Printf
var _ = strconv.Itoa
var _ = sync.Once{}

type PHPParser struct {
	*antlr.BaseParser
}

var phpparserParserStaticData struct {
	once                   sync.Once
	serializedATN          []int32
	literalNames           []string
	symbolicNames          []string
	ruleNames              []string
	predictionContextCache *antlr.PredictionContextCache
	atn                    *antlr.ATN
	decisionToDFA          []*antlr.DFA
}

func phpparserParserInit() {
	staticData := &phpparserParserStaticData
	staticData.literalNames = []string{
		"", "", "", "'<?xml'", "", "", "", "", "", "", "", "", "", "'?>'", "",
		"", "'/>'", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "'#['", "'abstract'",
		"'array'", "'as'", "'binary'", "", "", "'break'", "'callable'", "'case'",
		"'catch'", "'class'", "'clone'", "'const'", "'continue'", "'declare'",
		"'default'", "'do'", "'real'", "'double'", "'echo'", "'else'", "'elseif'",
		"'empty'", "'enum'", "'enddeclare'", "'endfor'", "'endforeach'", "'endif'",
		"'endswitch'", "'endwhile'", "'eval'", "'die'", "'extends'", "'final'",
		"'finally'", "'float'", "'for'", "'foreach'", "'function'", "'global'",
		"'goto'", "'if'", "'implements'", "'import'", "'include'", "'include_once'",
		"'instanceof'", "'insteadof'", "'int8'", "'int16'", "'int64'", "", "'interface'",
		"'isset'", "'list'", "'and'", "'or'", "'xor'", "'match'", "'namespace'",
		"'new'", "'null'", "'object'", "'parent'", "'partial'", "'print'", "'private'",
		"'protected'", "'public'", "'readonly'", "'require'", "'require_once'",
		"'resource'", "'return'", "'static'", "'string'", "'switch'", "'throw'",
		"'trait'", "'try'", "'clrtypeof'", "", "'unicode'", "'unset'", "'use'",
		"'var'", "'while'", "'yield'", "'from'", "'fn'", "'ticks'", "'encoding'",
		"'strict_types'", "'__get'", "'__set'", "'__call'", "'__callstatic'",
		"'__construct'", "'__destruct'", "'__wakeup'", "'__sleep'", "'__autoload'",
		"'__isset'", "'__unset'", "'__tostring'", "'__invoke'", "'__set_state'",
		"'__clone'", "'__debuginfo'", "'__namespace__'", "'__class__'", "'__trait__'",
		"'__function__'", "'__method__'", "'__line__'", "'__file__'", "'__dir__'",
		"'<=>'", "'<:'", "':>'", "'=>'", "'++'", "'--'", "'==='", "'!=='", "'=='",
		"", "'<='", "'>='", "'+='", "'-='", "'*='", "'**'", "'**='", "'/='",
		"'.='", "'%='", "'<<='", "'>>='", "'&='", "'|='", "'^='", "'||'", "'&&'",
		"'??'", "'??='", "'<<'", "'>>'", "'::'", "'->'", "'\\'", "'...'", "",
		"", "'&'", "'|'", "'!'", "'^'", "'+'", "'-'", "'*'", "'%'", "", "'~'",
		"'@'", "", "'.'", "", "'('", "')'", "'['", "']'", "", "'}'", "','",
		"':'", "';'", "", "'''", "'`'",
	}
	staticData.symbolicNames = []string{
		"", "SeaWhitespace", "HtmlText", "XmlStart", "PHPStart", "HtmlScriptOpen",
		"HtmlStyleOpen", "HtmlComment", "HtmlDtd", "HtmlOpen", "Shebang", "Error",
		"XmlText", "XmlClose", "PHPStartInside", "HtmlClose", "HtmlSlashClose",
		"HtmlSlash", "HtmlEquals", "HtmlStartQuoteString", "HtmlStartDoubleQuoteString",
		"HtmlHex", "HtmlDecimal", "HtmlSpace", "HtmlName", "ErrorInside", "PHPStartInsideQuoteString",
		"HtmlEndQuoteString", "HtmlQuoteString", "ErrorHtmlQuote", "PHPStartDoubleQuoteString",
		"HtmlEndDoubleQuoteString", "HtmlDoubleQuoteString", "ErrorHtmlDoubleQuote",
		"ScriptText", "HtmlScriptClose", "PHPStartInsideScript", "StyleBody",
		"PHPEnd", "Whitespace", "MultiLineComment", "SingleLineComment", "ShellStyleComment",
		"AttributeStart", "Abstract", "Array", "As", "BinaryCast", "BoolType",
		"BooleanConstant", "Break", "Callable", "Case", "Catch", "Class", "Clone",
		"Const", "Continue", "Declare", "Default", "Do", "DoubleCast", "DoubleType",
		"Echo", "Else", "ElseIf", "Empty", "Enum_", "EndDeclare", "EndFor",
		"EndForeach", "EndIf", "EndSwitch", "EndWhile", "Eval", "Exit", "Extends",
		"Final", "Finally", "FloatCast", "For", "Foreach", "Function_", "Global",
		"Goto", "If", "Implements", "Import", "Include", "IncludeOnce", "InstanceOf",
		"InsteadOf", "Int8Cast", "Int16Cast", "Int64Type", "IntType", "Interface",
		"IsSet", "List", "LogicalAnd", "LogicalOr", "LogicalXor", "Match_",
		"Namespace", "New", "Null", "ObjectType", "Parent_", "Partial", "Print",
		"Private", "Protected", "Public", "Readonly", "Require", "RequireOnce",
		"Resource", "Return", "Static", "StringType", "Switch", "Throw", "Trait",
		"Try", "Typeof", "UintCast", "UnicodeCast", "Unset", "Use", "Var", "While",
		"Yield", "From", "LambdaFn", "Ticks", "Encoding", "StrictTypes", "Get",
		"Set", "Call", "CallStatic", "Constructor", "Destruct", "Wakeup", "Sleep",
		"Autoload", "IsSet__", "Unset__", "ToString__", "Invoke", "SetState",
		"Clone__", "DebugInfo", "Namespace__", "Class__", "Traic__", "Function__",
		"Method__", "Line__", "File__", "Dir__", "Spaceship", "Lgeneric", "Rgeneric",
		"DoubleArrow", "Inc", "Dec", "IsIdentical", "IsNoidentical", "IsEqual",
		"IsNotEq", "IsSmallerOrEqual", "IsGreaterOrEqual", "PlusEqual", "MinusEqual",
		"MulEqual", "Pow", "PowEqual", "DivEqual", "Concaequal", "ModEqual",
		"ShiftLeftEqual", "ShiftRightEqual", "AndEqual", "OrEqual", "XorEqual",
		"BooleanOr", "BooleanAnd", "NullCoalescing", "NullCoalescingEqual",
		"ShiftLeft", "ShiftRight", "DoubleColon", "ObjectOperator", "NamespaceSeparator",
		"Ellipsis", "Less", "Greater", "Ampersand", "Pipe", "Bang", "Caret",
		"Plus", "Minus", "Asterisk", "Percent", "Divide", "Tilde", "SuppressWarnings",
		"Dollar", "Dot", "QuestionMark", "OpenRoundBracket", "CloseRoundBracket",
		"OpenSquareBracket", "CloseSquareBracket", "OpenCurlyBracket", "CloseCurlyBracket",
		"Comma", "Colon", "SemiColon", "Eq", "Quote", "BackQuote", "VarName",
		"Label", "Octal", "Decimal", "Real", "Hex", "Binary", "BackQuoteString",
		"SingleQuoteString", "DoubleQuote", "StartNowDoc", "StartHereDoc", "ErrorPhp",
		"CurlyDollar", "UnicodeEscape", "StringPart", "Comment", "PHPEndSingleLineComment",
		"CommentEnd", "HereDocText", "XmlText2",
	}
	staticData.ruleNames = []string{
		"htmlDocument", "htmlDocumentElement", "inlineHtml", "htmlElement",
		"scriptText", "phpBlock", "importStatement", "topStatement", "useDeclaration",
		"useDeclarationContentList", "useDeclarationContent", "namespaceDeclaration",
		"namespaceStatement", "functionDeclaration", "classDeclaration", "classEntryType",
		"interfaceList", "typeParameterListInBrackets", "typeParameterList",
		"typeParameterWithDefaultsList", "typeParameterDecl", "typeParameterWithDefaultDecl",
		"genericDynamicArgs", "attributes", "attributeGroup", "attribute", "innerStatementList",
		"innerStatement", "statement", "emptyStatement_", "blockStatement",
		"ifStatement", "elseIfStatement", "elseIfColonStatement", "elseStatement",
		"elseColonStatement", "whileStatement", "doWhileStatement", "forStatement",
		"forInit", "forUpdate", "switchStatement", "switchBlock", "breakStatement",
		"continueStatement", "returnStatement", "expressionStatement", "unsetStatement",
		"foreachStatement", "tryCatchFinally", "catchClause", "finallyStatement",
		"throwStatement", "gotoStatement", "declareStatement", "inlineHtmlStatement",
		"declareList", "directive", "formalParameterList", "formalParameter",
		"typeHint", "globalStatement", "globalVar", "echoStatement", "staticVariableStatement",
		"classStatement", "traitAdaptations", "traitAdaptationStatement", "traitPrecedence",
		"traitAlias", "traitMethodReference", "baseCtorCall", "returnTypeDecl",
		"methodBody", "propertyModifiers", "memberModifiers", "variableInitializer",
		"identifierInitializer", "globalConstantDeclaration", "enumDeclaration",
		"enumItem", "expressionList", "parentheses", "expression", "assignable",
		"arrayCreation", "arrayDestructuring", "indexedDestructItem", "keyedDestructItem",
		"lambdaFunctionExpr", "matchExpr", "matchItem", "newExpr", "assignmentOperator",
		"yieldExpression", "arrayItemList", "arrayItem", "lambdaFunctionUseVars",
		"lambdaFunctionUseVar", "qualifiedStaticTypeRef", "typeRef", "anonymousClass",
		"indirectTypeRef", "qualifiedNamespaceName", "namespaceNameList", "namespaceNameTail",
		"qualifiedNamespaceNameList", "arguments", "actualArgument", "argumentName",
		"constantInitializer", "constant", "literalConstant", "numericConstant",
		"classConstant", "stringConstant", "string", "interpolatedStringPart",
		"chainList", "chain", "chainOrigin", "memberAccess", "functionCall",
		"functionCallName", "actualArguments", "chainBase", "keyedFieldName",
		"keyedSimpleFieldName", "keyedVariable", "squareCurlyExpression", "assignmentList",
		"assignmentListElement", "modifier", "identifier", "memberModifier",
		"magicConstant", "magicMethod", "primitiveType", "castOperation",
	}
	staticData.predictionContextCache = antlr.NewPredictionContextCache()
	staticData.serializedATN = []int32{
		4, 1, 244, 1952, 2, 0, 7, 0, 2, 1, 7, 1, 2, 2, 7, 2, 2, 3, 7, 3, 2, 4,
		7, 4, 2, 5, 7, 5, 2, 6, 7, 6, 2, 7, 7, 7, 2, 8, 7, 8, 2, 9, 7, 9, 2, 10,
		7, 10, 2, 11, 7, 11, 2, 12, 7, 12, 2, 13, 7, 13, 2, 14, 7, 14, 2, 15, 7,
		15, 2, 16, 7, 16, 2, 17, 7, 17, 2, 18, 7, 18, 2, 19, 7, 19, 2, 20, 7, 20,
		2, 21, 7, 21, 2, 22, 7, 22, 2, 23, 7, 23, 2, 24, 7, 24, 2, 25, 7, 25, 2,
		26, 7, 26, 2, 27, 7, 27, 2, 28, 7, 28, 2, 29, 7, 29, 2, 30, 7, 30, 2, 31,
		7, 31, 2, 32, 7, 32, 2, 33, 7, 33, 2, 34, 7, 34, 2, 35, 7, 35, 2, 36, 7,
		36, 2, 37, 7, 37, 2, 38, 7, 38, 2, 39, 7, 39, 2, 40, 7, 40, 2, 41, 7, 41,
		2, 42, 7, 42, 2, 43, 7, 43, 2, 44, 7, 44, 2, 45, 7, 45, 2, 46, 7, 46, 2,
		47, 7, 47, 2, 48, 7, 48, 2, 49, 7, 49, 2, 50, 7, 50, 2, 51, 7, 51, 2, 52,
		7, 52, 2, 53, 7, 53, 2, 54, 7, 54, 2, 55, 7, 55, 2, 56, 7, 56, 2, 57, 7,
		57, 2, 58, 7, 58, 2, 59, 7, 59, 2, 60, 7, 60, 2, 61, 7, 61, 2, 62, 7, 62,
		2, 63, 7, 63, 2, 64, 7, 64, 2, 65, 7, 65, 2, 66, 7, 66, 2, 67, 7, 67, 2,
		68, 7, 68, 2, 69, 7, 69, 2, 70, 7, 70, 2, 71, 7, 71, 2, 72, 7, 72, 2, 73,
		7, 73, 2, 74, 7, 74, 2, 75, 7, 75, 2, 76, 7, 76, 2, 77, 7, 77, 2, 78, 7,
		78, 2, 79, 7, 79, 2, 80, 7, 80, 2, 81, 7, 81, 2, 82, 7, 82, 2, 83, 7, 83,
		2, 84, 7, 84, 2, 85, 7, 85, 2, 86, 7, 86, 2, 87, 7, 87, 2, 88, 7, 88, 2,
		89, 7, 89, 2, 90, 7, 90, 2, 91, 7, 91, 2, 92, 7, 92, 2, 93, 7, 93, 2, 94,
		7, 94, 2, 95, 7, 95, 2, 96, 7, 96, 2, 97, 7, 97, 2, 98, 7, 98, 2, 99, 7,
		99, 2, 100, 7, 100, 2, 101, 7, 101, 2, 102, 7, 102, 2, 103, 7, 103, 2,
		104, 7, 104, 2, 105, 7, 105, 2, 106, 7, 106, 2, 107, 7, 107, 2, 108, 7,
		108, 2, 109, 7, 109, 2, 110, 7, 110, 2, 111, 7, 111, 2, 112, 7, 112, 2,
		113, 7, 113, 2, 114, 7, 114, 2, 115, 7, 115, 2, 116, 7, 116, 2, 117, 7,
		117, 2, 118, 7, 118, 2, 119, 7, 119, 2, 120, 7, 120, 2, 121, 7, 121, 2,
		122, 7, 122, 2, 123, 7, 123, 2, 124, 7, 124, 2, 125, 7, 125, 2, 126, 7,
		126, 2, 127, 7, 127, 2, 128, 7, 128, 2, 129, 7, 129, 2, 130, 7, 130, 2,
		131, 7, 131, 2, 132, 7, 132, 2, 133, 7, 133, 2, 134, 7, 134, 2, 135, 7,
		135, 2, 136, 7, 136, 2, 137, 7, 137, 2, 138, 7, 138, 1, 0, 3, 0, 280, 8,
		0, 1, 0, 5, 0, 283, 8, 0, 10, 0, 12, 0, 286, 9, 0, 1, 0, 1, 0, 1, 1, 1,
		1, 3, 1, 292, 8, 1, 1, 2, 4, 2, 295, 8, 2, 11, 2, 12, 2, 296, 1, 2, 3,
		2, 300, 8, 2, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1,
		3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1,
		3, 5, 3, 324, 8, 3, 10, 3, 12, 3, 327, 9, 3, 1, 3, 3, 3, 330, 8, 3, 1,
		4, 4, 4, 333, 8, 4, 11, 4, 12, 4, 334, 1, 5, 5, 5, 338, 8, 5, 10, 5, 12,
		5, 341, 9, 5, 1, 5, 4, 5, 344, 8, 5, 11, 5, 12, 5, 345, 1, 6, 1, 6, 1,
		6, 1, 6, 1, 6, 1, 7, 1, 7, 1, 7, 1, 7, 1, 7, 1, 7, 1, 7, 3, 7, 360, 8,
		7, 1, 8, 1, 8, 3, 8, 364, 8, 8, 1, 8, 1, 8, 1, 8, 1, 9, 3, 9, 370, 8, 9,
		1, 9, 1, 9, 1, 9, 3, 9, 375, 8, 9, 1, 9, 5, 9, 378, 8, 9, 10, 9, 12, 9,
		381, 9, 9, 1, 10, 1, 10, 1, 11, 1, 11, 3, 11, 387, 8, 11, 1, 11, 1, 11,
		5, 11, 391, 8, 11, 10, 11, 12, 11, 394, 9, 11, 1, 11, 1, 11, 1, 11, 1,
		11, 3, 11, 400, 8, 11, 1, 12, 1, 12, 1, 12, 1, 12, 1, 12, 3, 12, 407, 8,
		12, 1, 13, 3, 13, 410, 8, 13, 1, 13, 1, 13, 3, 13, 414, 8, 13, 1, 13, 1,
		13, 3, 13, 418, 8, 13, 1, 13, 1, 13, 1, 13, 1, 13, 1, 13, 3, 13, 425, 8,
		13, 1, 13, 3, 13, 428, 8, 13, 1, 13, 1, 13, 1, 14, 3, 14, 433, 8, 14, 1,
		14, 3, 14, 436, 8, 14, 1, 14, 3, 14, 439, 8, 14, 1, 14, 3, 14, 442, 8,
		14, 1, 14, 1, 14, 1, 14, 3, 14, 447, 8, 14, 1, 14, 1, 14, 3, 14, 451, 8,
		14, 1, 14, 1, 14, 3, 14, 455, 8, 14, 1, 14, 1, 14, 1, 14, 3, 14, 460, 8,
		14, 1, 14, 1, 14, 3, 14, 464, 8, 14, 3, 14, 466, 8, 14, 1, 14, 1, 14, 5,
		14, 470, 8, 14, 10, 14, 12, 14, 473, 9, 14, 1, 14, 1, 14, 1, 15, 1, 15,
		1, 16, 1, 16, 1, 16, 5, 16, 482, 8, 16, 10, 16, 12, 16, 485, 9, 16, 1,
		17, 1, 17, 1, 17, 1, 17, 1, 17, 1, 17, 1, 17, 1, 17, 1, 17, 1, 17, 1, 17,
		1, 17, 1, 17, 1, 17, 3, 17, 501, 8, 17, 1, 18, 1, 18, 1, 18, 5, 18, 506,
		8, 18, 10, 18, 12, 18, 509, 9, 18, 1, 19, 1, 19, 1, 19, 5, 19, 514, 8,
		19, 10, 19, 12, 19, 517, 9, 19, 1, 20, 3, 20, 520, 8, 20, 1, 20, 1, 20,
		1, 21, 3, 21, 525, 8, 21, 1, 21, 1, 21, 1, 21, 1, 21, 3, 21, 531, 8, 21,
		1, 22, 1, 22, 1, 22, 1, 22, 5, 22, 537, 8, 22, 10, 22, 12, 22, 540, 9,
		22, 1, 22, 1, 22, 1, 23, 4, 23, 545, 8, 23, 11, 23, 12, 23, 546, 1, 24,
		1, 24, 1, 24, 1, 24, 3, 24, 553, 8, 24, 1, 24, 1, 24, 1, 24, 5, 24, 558,
		8, 24, 10, 24, 12, 24, 561, 9, 24, 1, 24, 1, 24, 1, 25, 1, 25, 3, 25, 567,
		8, 25, 1, 26, 5, 26, 570, 8, 26, 10, 26, 12, 26, 573, 9, 26, 1, 27, 1,
		27, 1, 27, 3, 27, 578, 8, 27, 1, 28, 1, 28, 1, 28, 1, 28, 1, 28, 1, 28,
		1, 28, 1, 28, 1, 28, 1, 28, 1, 28, 1, 28, 1, 28, 1, 28, 1, 28, 1, 28, 1,
		28, 1, 28, 1, 28, 1, 28, 1, 28, 1, 28, 1, 28, 1, 28, 1, 28, 1, 28, 1, 28,
		3, 28, 607, 8, 28, 1, 29, 1, 29, 1, 30, 1, 30, 1, 30, 1, 30, 1, 31, 1,
		31, 1, 31, 1, 31, 5, 31, 619, 8, 31, 10, 31, 12, 31, 622, 9, 31, 1, 31,
		3, 31, 625, 8, 31, 1, 31, 1, 31, 1, 31, 1, 31, 1, 31, 5, 31, 632, 8, 31,
		10, 31, 12, 31, 635, 9, 31, 1, 31, 3, 31, 638, 8, 31, 1, 31, 1, 31, 1,
		31, 3, 31, 643, 8, 31, 1, 32, 1, 32, 1, 32, 1, 32, 1, 33, 1, 33, 1, 33,
		1, 33, 1, 33, 1, 34, 1, 34, 1, 34, 1, 35, 1, 35, 1, 35, 1, 35, 1, 36, 1,
		36, 1, 36, 1, 36, 1, 36, 1, 36, 1, 36, 1, 36, 3, 36, 669, 8, 36, 1, 37,
		1, 37, 1, 37, 1, 37, 1, 37, 1, 37, 1, 38, 1, 38, 1, 38, 3, 38, 680, 8,
		38, 1, 38, 1, 38, 3, 38, 684, 8, 38, 1, 38, 1, 38, 3, 38, 688, 8, 38, 1,
		38, 1, 38, 1, 38, 1, 38, 1, 38, 1, 38, 1, 38, 3, 38, 697, 8, 38, 1, 39,
		1, 39, 1, 40, 1, 40, 1, 41, 1, 41, 1, 41, 1, 41, 3, 41, 707, 8, 41, 1,
		41, 5, 41, 710, 8, 41, 10, 41, 12, 41, 713, 9, 41, 1, 41, 1, 41, 1, 41,
		3, 41, 718, 8, 41, 1, 41, 5, 41, 721, 8, 41, 10, 41, 12, 41, 724, 9, 41,
		1, 41, 1, 41, 3, 41, 728, 8, 41, 1, 42, 1, 42, 1, 42, 3, 42, 733, 8, 42,
		1, 42, 4, 42, 736, 8, 42, 11, 42, 12, 42, 737, 1, 42, 1, 42, 1, 43, 1,
		43, 3, 43, 744, 8, 43, 1, 43, 1, 43, 1, 44, 1, 44, 3, 44, 750, 8, 44, 1,
		44, 1, 44, 1, 45, 1, 45, 3, 45, 756, 8, 45, 1, 45, 1, 45, 1, 46, 1, 46,
		1, 46, 1, 47, 1, 47, 1, 47, 1, 47, 1, 47, 1, 47, 1, 48, 1, 48, 1, 48, 1,
		48, 1, 48, 1, 48, 1, 48, 1, 48, 1, 48, 1, 48, 1, 48, 3, 48, 780, 8, 48,
		1, 48, 1, 48, 1, 48, 3, 48, 785, 8, 48, 1, 48, 3, 48, 788, 8, 48, 1, 48,
		1, 48, 1, 48, 1, 48, 1, 48, 1, 48, 1, 48, 1, 48, 3, 48, 798, 8, 48, 1,
		48, 3, 48, 801, 8, 48, 1, 48, 1, 48, 1, 48, 1, 48, 1, 48, 1, 48, 1, 48,
		1, 48, 1, 48, 1, 48, 1, 48, 3, 48, 814, 8, 48, 1, 48, 1, 48, 1, 48, 1,
		48, 1, 48, 1, 48, 3, 48, 822, 8, 48, 1, 49, 1, 49, 1, 49, 4, 49, 827, 8,
		49, 11, 49, 12, 49, 828, 1, 49, 3, 49, 832, 8, 49, 1, 49, 5, 49, 835, 8,
		49, 10, 49, 12, 49, 838, 9, 49, 1, 49, 3, 49, 841, 8, 49, 1, 50, 1, 50,
		1, 50, 1, 50, 1, 50, 5, 50, 848, 8, 50, 10, 50, 12, 50, 851, 9, 50, 1,
		50, 3, 50, 854, 8, 50, 1, 50, 1, 50, 1, 50, 1, 51, 1, 51, 1, 51, 1, 52,
		1, 52, 1, 52, 1, 52, 1, 53, 1, 53, 1, 53, 1, 53, 1, 54, 1, 54, 1, 54, 1,
		54, 1, 54, 1, 54, 1, 54, 1, 54, 1, 54, 1, 54, 3, 54, 880, 8, 54, 1, 55,
		4, 55, 883, 8, 55, 11, 55, 12, 55, 884, 1, 56, 1, 56, 1, 56, 5, 56, 890,
		8, 56, 10, 56, 12, 56, 893, 9, 56, 1, 57, 1, 57, 1, 57, 1, 57, 3, 57, 899,
		8, 57, 1, 57, 1, 57, 1, 57, 1, 57, 1, 57, 1, 57, 3, 57, 907, 8, 57, 1,
		58, 3, 58, 910, 8, 58, 1, 58, 1, 58, 5, 58, 914, 8, 58, 10, 58, 12, 58,
		917, 9, 58, 1, 58, 3, 58, 920, 8, 58, 1, 59, 3, 59, 923, 8, 59, 1, 59,
		5, 59, 926, 8, 59, 10, 59, 12, 59, 929, 9, 59, 1, 59, 3, 59, 932, 8, 59,
		1, 59, 3, 59, 935, 8, 59, 1, 59, 3, 59, 938, 8, 59, 1, 59, 3, 59, 941,
		8, 59, 1, 59, 1, 59, 1, 60, 1, 60, 1, 60, 1, 60, 3, 60, 949, 8, 60, 1,
		60, 1, 60, 1, 60, 5, 60, 954, 8, 60, 10, 60, 12, 60, 957, 9, 60, 1, 61,
		1, 61, 1, 61, 1, 61, 5, 61, 963, 8, 61, 10, 61, 12, 61, 966, 9, 61, 1,
		61, 1, 61, 1, 62, 1, 62, 1, 62, 1, 62, 1, 62, 1, 62, 1, 62, 1, 62, 3, 62,
		978, 8, 62, 1, 63, 1, 63, 1, 63, 1, 63, 1, 64, 1, 64, 1, 64, 1, 64, 5,
		64, 988, 8, 64, 10, 64, 12, 64, 991, 9, 64, 1, 64, 1, 64, 1, 65, 3, 65,
		996, 8, 65, 1, 65, 1, 65, 3, 65, 1000, 8, 65, 1, 65, 1, 65, 1, 65, 5, 65,
		1005, 8, 65, 10, 65, 12, 65, 1008, 9, 65, 1, 65, 1, 65, 1, 65, 3, 65, 1013,
		8, 65, 1, 65, 1, 65, 3, 65, 1017, 8, 65, 1, 65, 1, 65, 1, 65, 5, 65, 1022,
		8, 65, 10, 65, 12, 65, 1025, 9, 65, 1, 65, 1, 65, 1, 65, 1, 65, 3, 65,
		1031, 8, 65, 1, 65, 1, 65, 3, 65, 1035, 8, 65, 1, 65, 1, 65, 1, 65, 1,
		65, 1, 65, 3, 65, 1042, 8, 65, 1, 65, 1, 65, 3, 65, 1046, 8, 65, 3, 65,
		1048, 8, 65, 1, 65, 1, 65, 1, 65, 1, 65, 3, 65, 1054, 8, 65, 1, 66, 1,
		66, 1, 66, 5, 66, 1059, 8, 66, 10, 66, 12, 66, 1062, 9, 66, 1, 66, 3, 66,
		1065, 8, 66, 1, 67, 1, 67, 3, 67, 1069, 8, 67, 1, 68, 1, 68, 1, 68, 1,
		68, 1, 68, 1, 68, 1, 68, 1, 69, 1, 69, 1, 69, 1, 69, 3, 69, 1082, 8, 69,
		1, 69, 3, 69, 1085, 8, 69, 1, 69, 1, 69, 1, 70, 1, 70, 1, 70, 3, 70, 1092,
		8, 70, 1, 70, 1, 70, 1, 71, 1, 71, 1, 71, 3, 71, 1099, 8, 71, 1, 72, 1,
		72, 3, 72, 1103, 8, 72, 1, 72, 1, 72, 1, 73, 1, 73, 3, 73, 1109, 8, 73,
		1, 74, 1, 74, 3, 74, 1113, 8, 74, 1, 75, 4, 75, 1116, 8, 75, 11, 75, 12,
		75, 1117, 1, 76, 1, 76, 1, 76, 3, 76, 1123, 8, 76, 1, 77, 1, 77, 1, 77,
		1, 77, 1, 78, 3, 78, 1130, 8, 78, 1, 78, 1, 78, 1, 78, 1, 78, 5, 78, 1136,
		8, 78, 10, 78, 12, 78, 1139, 9, 78, 1, 78, 1, 78, 1, 79, 1, 79, 1, 79,
		1, 79, 3, 79, 1147, 8, 79, 1, 79, 1, 79, 3, 79, 1151, 8, 79, 1, 79, 1,
		79, 5, 79, 1155, 8, 79, 10, 79, 12, 79, 1158, 9, 79, 1, 79, 1, 79, 1, 80,
		1, 80, 1, 80, 1, 80, 3, 80, 1166, 8, 80, 1, 80, 1, 80, 1, 80, 3, 80, 1171,
		8, 80, 1, 80, 1, 80, 1, 80, 1, 80, 1, 80, 3, 80, 1178, 8, 80, 1, 81, 1,
		81, 1, 81, 5, 81, 1183, 8, 81, 10, 81, 12, 81, 1186, 9, 81, 1, 82, 1, 82,
		1, 82, 3, 82, 1191, 8, 82, 1, 82, 1, 82, 1, 83, 1, 83, 1, 83, 1, 83, 1,
		83, 1, 83, 1, 83, 1, 83, 1, 83, 1, 83, 1, 83, 1, 83, 1, 83, 1, 83, 1, 83,
		1, 83, 1, 83, 1, 83, 1, 83, 1, 83, 1, 83, 1, 83, 1, 83, 1, 83, 1, 83, 1,
		83, 1, 83, 1, 83, 1, 83, 1, 83, 1, 83, 1, 83, 1, 83, 1, 83, 1, 83, 1, 83,
		1, 83, 1, 83, 1, 83, 1, 83, 1, 83, 1, 83, 1, 83, 1, 83, 1, 83, 1, 83, 1,
		83, 1, 83, 1, 83, 1, 83, 1, 83, 1, 83, 1, 83, 1, 83, 1, 83, 1, 83, 1, 83,
		1, 83, 1, 83, 3, 83, 1254, 8, 83, 1, 83, 1, 83, 1, 83, 1, 83, 1, 83, 1,
		83, 1, 83, 1, 83, 1, 83, 1, 83, 1, 83, 1, 83, 1, 83, 1, 83, 1, 83, 3, 83,
		1271, 8, 83, 1, 83, 1, 83, 1, 83, 1, 83, 1, 83, 3, 83, 1278, 8, 83, 1,
		83, 1, 83, 1, 83, 3, 83, 1283, 8, 83, 3, 83, 1285, 8, 83, 1, 83, 1, 83,
		1, 83, 1, 83, 1, 83, 1, 83, 1, 83, 1, 83, 1, 83, 1, 83, 1, 83, 1, 83, 1,
		83, 1, 83, 1, 83, 1, 83, 1, 83, 1, 83, 1, 83, 1, 83, 1, 83, 1, 83, 1, 83,
		1, 83, 1, 83, 1, 83, 1, 83, 1, 83, 1, 83, 1, 83, 1, 83, 1, 83, 1, 83, 1,
		83, 1, 83, 1, 83, 3, 83, 1323, 8, 83, 1, 83, 1, 83, 1, 83, 1, 83, 1, 83,
		1, 83, 1, 83, 1, 83, 1, 83, 1, 83, 1, 83, 1, 83, 1, 83, 1, 83, 1, 83, 1,
		83, 1, 83, 1, 83, 1, 83, 1, 83, 5, 83, 1345, 8, 83, 10, 83, 12, 83, 1348,
		9, 83, 1, 84, 1, 84, 3, 84, 1352, 8, 84, 1, 85, 1, 85, 1, 85, 3, 85, 1357,
		8, 85, 1, 85, 1, 85, 1, 85, 3, 85, 1362, 8, 85, 1, 85, 3, 85, 1365, 8,
		85, 1, 85, 1, 85, 1, 85, 1, 85, 3, 85, 1371, 8, 85, 1, 86, 1, 86, 5, 86,
		1375, 8, 86, 10, 86, 12, 86, 1378, 9, 86, 1, 86, 1, 86, 4, 86, 1382, 8,
		86, 11, 86, 12, 86, 1383, 1, 86, 5, 86, 1387, 8, 86, 10, 86, 12, 86, 1390,
		9, 86, 1, 86, 5, 86, 1393, 8, 86, 10, 86, 12, 86, 1396, 9, 86, 1, 86, 1,
		86, 1, 86, 1, 86, 1, 86, 4, 86, 1403, 8, 86, 11, 86, 12, 86, 1404, 1, 86,
		5, 86, 1408, 8, 86, 10, 86, 12, 86, 1411, 9, 86, 1, 86, 3, 86, 1414, 8,
		86, 1, 86, 1, 86, 3, 86, 1418, 8, 86, 1, 87, 3, 87, 1421, 8, 87, 1, 87,
		1, 87, 1, 88, 1, 88, 1, 88, 3, 88, 1428, 8, 88, 1, 88, 3, 88, 1431, 8,
		88, 1, 88, 1, 88, 1, 89, 3, 89, 1436, 8, 89, 1, 89, 1, 89, 3, 89, 1440,
		8, 89, 1, 89, 1, 89, 1, 89, 1, 89, 3, 89, 1446, 8, 89, 1, 89, 1, 89, 3,
		89, 1450, 8, 89, 1, 89, 1, 89, 1, 89, 1, 89, 1, 89, 1, 89, 1, 89, 1, 89,
		1, 89, 3, 89, 1461, 8, 89, 1, 90, 1, 90, 1, 90, 1, 90, 1, 90, 1, 90, 1,
		90, 1, 90, 5, 90, 1471, 8, 90, 10, 90, 12, 90, 1474, 9, 90, 1, 90, 3, 90,
		1477, 8, 90, 1, 90, 1, 90, 1, 91, 1, 91, 1, 91, 5, 91, 1484, 8, 91, 10,
		91, 12, 91, 1487, 9, 91, 1, 91, 1, 91, 1, 91, 1, 92, 1, 92, 1, 92, 3, 92,
		1495, 8, 92, 1, 93, 1, 93, 1, 94, 1, 94, 1, 94, 1, 94, 3, 94, 1503, 8,
		94, 1, 94, 1, 94, 3, 94, 1507, 8, 94, 1, 95, 1, 95, 1, 95, 5, 95, 1512,
		8, 95, 10, 95, 12, 95, 1515, 9, 95, 1, 95, 3, 95, 1518, 8, 95, 1, 96, 1,
		96, 1, 96, 3, 96, 1523, 8, 96, 1, 96, 1, 96, 1, 96, 3, 96, 1528, 8, 96,
		1, 96, 1, 96, 3, 96, 1532, 8, 96, 1, 97, 1, 97, 1, 97, 1, 97, 1, 97, 5,
		97, 1539, 8, 97, 10, 97, 12, 97, 1542, 9, 97, 1, 97, 1, 97, 1, 98, 3, 98,
		1547, 8, 98, 1, 98, 1, 98, 1, 99, 1, 99, 3, 99, 1553, 8, 99, 1, 99, 3,
		99, 1556, 8, 99, 1, 100, 1, 100, 3, 100, 1560, 8, 100, 1, 100, 3, 100,
		1563, 8, 100, 1, 100, 1, 100, 1, 100, 3, 100, 1568, 8, 100, 1, 101, 3,
		101, 1571, 8, 101, 1, 101, 3, 101, 1574, 8, 101, 1, 101, 3, 101, 1577,
		8, 101, 1, 101, 3, 101, 1580, 8, 101, 1, 101, 1, 101, 3, 101, 1584, 8,
		101, 1, 101, 1, 101, 3, 101, 1588, 8, 101, 1, 101, 1, 101, 3, 101, 1592,
		8, 101, 1, 101, 1, 101, 1, 101, 3, 101, 1597, 8, 101, 1, 101, 1, 101, 3,
		101, 1601, 8, 101, 3, 101, 1603, 8, 101, 1, 101, 1, 101, 5, 101, 1607,
		8, 101, 10, 101, 12, 101, 1610, 9, 101, 1, 101, 1, 101, 1, 102, 1, 102,
		1, 102, 5, 102, 1617, 8, 102, 10, 102, 12, 102, 1620, 9, 102, 1, 103, 3,
		103, 1623, 8, 103, 1, 103, 3, 103, 1626, 8, 103, 1, 103, 1, 103, 1, 104,
		1, 104, 1, 104, 1, 104, 5, 104, 1634, 8, 104, 10, 104, 12, 104, 1637, 9,
		104, 1, 104, 1, 104, 3, 104, 1641, 8, 104, 3, 104, 1643, 8, 104, 1, 105,
		1, 105, 1, 105, 3, 105, 1648, 8, 105, 1, 105, 1, 105, 1, 105, 1, 105, 5,
		105, 1654, 8, 105, 10, 105, 12, 105, 1657, 9, 105, 1, 105, 3, 105, 1660,
		8, 105, 1, 105, 1, 105, 3, 105, 1664, 8, 105, 1, 106, 1, 106, 1, 106, 5,
		106, 1669, 8, 106, 10, 106, 12, 106, 1672, 9, 106, 1, 107, 1, 107, 1, 107,
		1, 107, 5, 107, 1678, 8, 107, 10, 107, 12, 107, 1681, 9, 107, 1, 107, 3,
		107, 1684, 8, 107, 1, 107, 3, 107, 1687, 8, 107, 1, 107, 1, 107, 1, 108,
		3, 108, 1692, 8, 108, 1, 108, 3, 108, 1695, 8, 108, 1, 108, 1, 108, 1,
		108, 3, 108, 1700, 8, 108, 1, 109, 1, 109, 1, 109, 1, 110, 1, 110, 1, 110,
		1, 110, 1, 110, 1, 110, 3, 110, 1711, 8, 110, 3, 110, 1713, 8, 110, 1,
		110, 1, 110, 1, 110, 1, 110, 3, 110, 1719, 8, 110, 3, 110, 1721, 8, 110,
		1, 110, 1, 110, 1, 110, 1, 110, 1, 110, 3, 110, 1728, 8, 110, 1, 110, 1,
		110, 1, 110, 3, 110, 1733, 8, 110, 5, 110, 1735, 8, 110, 10, 110, 12, 110,
		1738, 9, 110, 3, 110, 1740, 8, 110, 1, 111, 1, 111, 1, 111, 1, 111, 1,
		111, 3, 111, 1747, 8, 111, 1, 112, 1, 112, 1, 112, 1, 112, 3, 112, 1753,
		8, 112, 1, 113, 1, 113, 1, 114, 1, 114, 1, 114, 1, 114, 1, 114, 1, 114,
		3, 114, 1763, 8, 114, 1, 114, 1, 114, 1, 114, 3, 114, 1768, 8, 114, 1,
		114, 1, 114, 1, 114, 3, 114, 1773, 8, 114, 3, 114, 1775, 8, 114, 1, 115,
		1, 115, 1, 116, 1, 116, 4, 116, 1781, 8, 116, 11, 116, 12, 116, 1782, 1,
		116, 1, 116, 4, 116, 1787, 8, 116, 11, 116, 12, 116, 1788, 1, 116, 1, 116,
		1, 116, 5, 116, 1794, 8, 116, 10, 116, 12, 116, 1797, 9, 116, 1, 116, 3,
		116, 1800, 8, 116, 1, 117, 1, 117, 1, 117, 3, 117, 1805, 8, 117, 1, 118,
		1, 118, 1, 118, 5, 118, 1810, 8, 118, 10, 118, 12, 118, 1813, 9, 118, 1,
		119, 1, 119, 5, 119, 1817, 8, 119, 10, 119, 12, 119, 1820, 9, 119, 1, 120,
		1, 120, 1, 120, 1, 120, 1, 120, 1, 120, 3, 120, 1828, 8, 120, 1, 121, 1,
		121, 1, 121, 3, 121, 1833, 8, 121, 1, 122, 1, 122, 1, 122, 1, 123, 1, 123,
		1, 123, 1, 123, 3, 123, 1842, 8, 123, 1, 124, 3, 124, 1845, 8, 124, 1,
		124, 4, 124, 1848, 8, 124, 11, 124, 12, 124, 1849, 1, 124, 5, 124, 1853,
		8, 124, 10, 124, 12, 124, 1856, 9, 124, 1, 125, 1, 125, 1, 125, 3, 125,
		1861, 8, 125, 1, 125, 1, 125, 1, 125, 1, 125, 3, 125, 1867, 8, 125, 1,
		126, 1, 126, 3, 126, 1871, 8, 126, 1, 127, 1, 127, 1, 127, 1, 127, 1, 127,
		3, 127, 1878, 8, 127, 1, 127, 5, 127, 1881, 8, 127, 10, 127, 12, 127, 1884,
		9, 127, 1, 128, 5, 128, 1887, 8, 128, 10, 128, 12, 128, 1890, 9, 128, 1,
		128, 1, 128, 1, 128, 1, 128, 1, 128, 1, 128, 3, 128, 1898, 8, 128, 1, 128,
		5, 128, 1901, 8, 128, 10, 128, 12, 128, 1904, 9, 128, 1, 129, 1, 129, 3,
		129, 1908, 8, 129, 1, 129, 1, 129, 1, 129, 1, 129, 1, 129, 3, 129, 1915,
		8, 129, 1, 130, 3, 130, 1918, 8, 130, 1, 130, 1, 130, 3, 130, 1922, 8,
		130, 5, 130, 1924, 8, 130, 10, 130, 12, 130, 1927, 9, 130, 1, 131, 1, 131,
		1, 131, 1, 131, 1, 131, 1, 131, 1, 131, 3, 131, 1936, 8, 131, 1, 132, 1,
		132, 1, 133, 1, 133, 1, 134, 1, 134, 1, 135, 1, 135, 1, 136, 1, 136, 1,
		137, 1, 137, 1, 138, 1, 138, 1, 138, 0, 2, 120, 166, 139, 0, 2, 4, 6, 8,
		10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30, 32, 34, 36, 38, 40, 42, 44,
		46, 48, 50, 52, 54, 56, 58, 60, 62, 64, 66, 68, 70, 72, 74, 76, 78, 80,
		82, 84, 86, 88, 90, 92, 94, 96, 98, 100, 102, 104, 106, 108, 110, 112,
		114, 116, 118, 120, 122, 124, 126, 128, 130, 132, 134, 136, 138, 140, 142,
		144, 146, 148, 150, 152, 154, 156, 158, 160, 162, 164, 166, 168, 170, 172,
		174, 176, 178, 180, 182, 184, 186, 188, 190, 192, 194, 196, 198, 200, 202,
		204, 206, 208, 210, 212, 214, 216, 218, 220, 222, 224, 226, 228, 230, 232,
		234, 236, 238, 240, 242, 244, 246, 248, 250, 252, 254, 256, 258, 260, 262,
		264, 266, 268, 270, 272, 274, 276, 0, 25, 2, 0, 56, 56, 82, 82, 2, 0, 54,
		54, 122, 122, 1, 0, 219, 220, 2, 0, 95, 95, 119, 119, 1, 0, 207, 208, 2,
		0, 200, 200, 202, 203, 1, 0, 165, 166, 1, 0, 88, 89, 1, 0, 114, 115, 1,
		0, 204, 206, 2, 0, 202, 203, 210, 210, 1, 0, 190, 191, 2, 0, 171, 172,
		196, 197, 1, 0, 167, 170, 4, 0, 173, 175, 177, 185, 189, 189, 221, 221,
		1, 0, 202, 203, 2, 0, 226, 227, 229, 230, 2, 0, 54, 54, 107, 107, 2, 0,
		44, 44, 77, 77, 2, 0, 44, 160, 225, 225, 4, 0, 44, 44, 77, 77, 110, 113,
		118, 118, 1, 0, 153, 160, 1, 0, 137, 152, 7, 0, 45, 45, 48, 48, 62, 62,
		94, 95, 106, 106, 116, 116, 119, 119, 9, 0, 45, 45, 47, 48, 61, 62, 79,
		79, 92, 95, 106, 106, 116, 116, 119, 119, 125, 127, 2188, 0, 279, 1, 0,
		0, 0, 2, 291, 1, 0, 0, 0, 4, 299, 1, 0, 0, 0, 6, 329, 1, 0, 0, 0, 8, 332,
		1, 0, 0, 0, 10, 339, 1, 0, 0, 0, 12, 347, 1, 0, 0, 0, 14, 359, 1, 0, 0,
		0, 16, 361, 1, 0, 0, 0, 18, 369, 1, 0, 0, 0, 20, 382, 1, 0, 0, 0, 22, 384,
		1, 0, 0, 0, 24, 406, 1, 0, 0, 0, 26, 409, 1, 0, 0, 0, 28, 432, 1, 0, 0,
		0, 30, 476, 1, 0, 0, 0, 32, 478, 1, 0, 0, 0, 34, 500, 1, 0, 0, 0, 36, 502,
		1, 0, 0, 0, 38, 510, 1, 0, 0, 0, 40, 519, 1, 0, 0, 0, 42, 524, 1, 0, 0,
		0, 44, 532, 1, 0, 0, 0, 46, 544, 1, 0, 0, 0, 48, 548, 1, 0, 0, 0, 50, 564,
		1, 0, 0, 0, 52, 571, 1, 0, 0, 0, 54, 577, 1, 0, 0, 0, 56, 606, 1, 0, 0,
		0, 58, 608, 1, 0, 0, 0, 60, 610, 1, 0, 0, 0, 62, 642, 1, 0, 0, 0, 64, 644,
		1, 0, 0, 0, 66, 648, 1, 0, 0, 0, 68, 653, 1, 0, 0, 0, 70, 656, 1, 0, 0,
		0, 72, 660, 1, 0, 0, 0, 74, 670, 1, 0, 0, 0, 76, 676, 1, 0, 0, 0, 78, 698,
		1, 0, 0, 0, 80, 700, 1, 0, 0, 0, 82, 702, 1, 0, 0, 0, 84, 735, 1, 0, 0,
		0, 86, 741, 1, 0, 0, 0, 88, 747, 1, 0, 0, 0, 90, 753, 1, 0, 0, 0, 92, 759,
		1, 0, 0, 0, 94, 762, 1, 0, 0, 0, 96, 768, 1, 0, 0, 0, 98, 823, 1, 0, 0,
		0, 100, 842, 1, 0, 0, 0, 102, 858, 1, 0, 0, 0, 104, 861, 1, 0, 0, 0, 106,
		865, 1, 0, 0, 0, 108, 869, 1, 0, 0, 0, 110, 882, 1, 0, 0, 0, 112, 886,
		1, 0, 0, 0, 114, 906, 1, 0, 0, 0, 116, 909, 1, 0, 0, 0, 118, 922, 1, 0,
		0, 0, 120, 948, 1, 0, 0, 0, 122, 958, 1, 0, 0, 0, 124, 977, 1, 0, 0, 0,
		126, 979, 1, 0, 0, 0, 128, 983, 1, 0, 0, 0, 130, 1053, 1, 0, 0, 0, 132,
		1064, 1, 0, 0, 0, 134, 1068, 1, 0, 0, 0, 136, 1070, 1, 0, 0, 0, 138, 1077,
		1, 0, 0, 0, 140, 1091, 1, 0, 0, 0, 142, 1095, 1, 0, 0, 0, 144, 1100, 1,
		0, 0, 0, 146, 1108, 1, 0, 0, 0, 148, 1112, 1, 0, 0, 0, 150, 1115, 1, 0,
		0, 0, 152, 1119, 1, 0, 0, 0, 154, 1124, 1, 0, 0, 0, 156, 1129, 1, 0, 0,
		0, 158, 1142, 1, 0, 0, 0, 160, 1177, 1, 0, 0, 0, 162, 1179, 1, 0, 0, 0,
		164, 1187, 1, 0, 0, 0, 166, 1284, 1, 0, 0, 0, 168, 1351, 1, 0, 0, 0, 170,
		1364, 1, 0, 0, 0, 172, 1417, 1, 0, 0, 0, 174, 1420, 1, 0, 0, 0, 176, 1427,
		1, 0, 0, 0, 178, 1460, 1, 0, 0, 0, 180, 1462, 1, 0, 0, 0, 182, 1480, 1,
		0, 0, 0, 184, 1491, 1, 0, 0, 0, 186, 1496, 1, 0, 0, 0, 188, 1498, 1, 0,
		0, 0, 190, 1508, 1, 0, 0, 0, 192, 1531, 1, 0, 0, 0, 194, 1533, 1, 0, 0,
		0, 196, 1546, 1, 0, 0, 0, 198, 1555, 1, 0, 0, 0, 200, 1567, 1, 0, 0, 0,
		202, 1570, 1, 0, 0, 0, 204, 1613, 1, 0, 0, 0, 206, 1622, 1, 0, 0, 0, 208,
		1642, 1, 0, 0, 0, 210, 1663, 1, 0, 0, 0, 212, 1665, 1, 0, 0, 0, 214, 1673,
		1, 0, 0, 0, 216, 1699, 1, 0, 0, 0, 218, 1701, 1, 0, 0, 0, 220, 1739, 1,
		0, 0, 0, 222, 1746, 1, 0, 0, 0, 224, 1752, 1, 0, 0, 0, 226, 1754, 1, 0,
		0, 0, 228, 1774, 1, 0, 0, 0, 230, 1776, 1, 0, 0, 0, 232, 1799, 1, 0, 0,
		0, 234, 1804, 1, 0, 0, 0, 236, 1806, 1, 0, 0, 0, 238, 1814, 1, 0, 0, 0,
		240, 1827, 1, 0, 0, 0, 242, 1829, 1, 0, 0, 0, 244, 1834, 1, 0, 0, 0, 246,
		1841, 1, 0, 0, 0, 248, 1844, 1, 0, 0, 0, 250, 1866, 1, 0, 0, 0, 252, 1870,
		1, 0, 0, 0, 254, 1877, 1, 0, 0, 0, 256, 1888, 1, 0, 0, 0, 258, 1914, 1,
		0, 0, 0, 260, 1917, 1, 0, 0, 0, 262, 1935, 1, 0, 0, 0, 264, 1937, 1, 0,
		0, 0, 266, 1939, 1, 0, 0, 0, 268, 1941, 1, 0, 0, 0, 270, 1943, 1, 0, 0,
		0, 272, 1945, 1, 0, 0, 0, 274, 1947, 1, 0, 0, 0, 276, 1949, 1, 0, 0, 0,
		278, 280, 5, 10, 0, 0, 279, 278, 1, 0, 0, 0, 279, 280, 1, 0, 0, 0, 280,
		284, 1, 0, 0, 0, 281, 283, 3, 2, 1, 0, 282, 281, 1, 0, 0, 0, 283, 286,
		1, 0, 0, 0, 284, 282, 1, 0, 0, 0, 284, 285, 1, 0, 0, 0, 285, 287, 1, 0,
		0, 0, 286, 284, 1, 0, 0, 0, 287, 288, 5, 0, 0, 1, 288, 1, 1, 0, 0, 0, 289,
		292, 3, 4, 2, 0, 290, 292, 3, 10, 5, 0, 291, 289, 1, 0, 0, 0, 291, 290,
		1, 0, 0, 0, 292, 3, 1, 0, 0, 0, 293, 295, 3, 6, 3, 0, 294, 293, 1, 0, 0,
		0, 295, 296, 1, 0, 0, 0, 296, 294, 1, 0, 0, 0, 296, 297, 1, 0, 0, 0, 297,
		300, 1, 0, 0, 0, 298, 300, 3, 8, 4, 0, 299, 294, 1, 0, 0, 0, 299, 298,
		1, 0, 0, 0, 300, 5, 1, 0, 0, 0, 301, 330, 5, 8, 0, 0, 302, 330, 5, 15,
		0, 0, 303, 330, 5, 6, 0, 0, 304, 330, 5, 9, 0, 0, 305, 330, 5, 24, 0, 0,
		306, 330, 5, 16, 0, 0, 307, 330, 5, 17, 0, 0, 308, 330, 5, 2, 0, 0, 309,
		330, 5, 18, 0, 0, 310, 330, 5, 19, 0, 0, 311, 330, 5, 27, 0, 0, 312, 330,
		5, 20, 0, 0, 313, 330, 5, 31, 0, 0, 314, 330, 5, 21, 0, 0, 315, 330, 5,
		22, 0, 0, 316, 330, 5, 28, 0, 0, 317, 330, 5, 32, 0, 0, 318, 330, 5, 37,
		0, 0, 319, 330, 5, 5, 0, 0, 320, 330, 5, 35, 0, 0, 321, 325, 5, 3, 0, 0,
		322, 324, 5, 12, 0, 0, 323, 322, 1, 0, 0, 0, 324, 327, 1, 0, 0, 0, 325,
		323, 1, 0, 0, 0, 325, 326, 1, 0, 0, 0, 326, 328, 1, 0, 0, 0, 327, 325,
		1, 0, 0, 0, 328, 330, 5, 13, 0, 0, 329, 301, 1, 0, 0, 0, 329, 302, 1, 0,
		0, 0, 329, 303, 1, 0, 0, 0, 329, 304, 1, 0, 0, 0, 329, 305, 1, 0, 0, 0,
		329, 306, 1, 0, 0, 0, 329, 307, 1, 0, 0, 0, 329, 308, 1, 0, 0, 0, 329,
		309, 1, 0, 0, 0, 329, 310, 1, 0, 0, 0, 329, 311, 1, 0, 0, 0, 329, 312,
		1, 0, 0, 0, 329, 313, 1, 0, 0, 0, 329, 314, 1, 0, 0, 0, 329, 315, 1, 0,
		0, 0, 329, 316, 1, 0, 0, 0, 329, 317, 1, 0, 0, 0, 329, 318, 1, 0, 0, 0,
		329, 319, 1, 0, 0, 0, 329, 320, 1, 0, 0, 0, 329, 321, 1, 0, 0, 0, 330,
		7, 1, 0, 0, 0, 331, 333, 5, 34, 0, 0, 332, 331, 1, 0, 0, 0, 333, 334, 1,
		0, 0, 0, 334, 332, 1, 0, 0, 0, 334, 335, 1, 0, 0, 0, 335, 9, 1, 0, 0, 0,
		336, 338, 3, 12, 6, 0, 337, 336, 1, 0, 0, 0, 338, 341, 1, 0, 0, 0, 339,
		337, 1, 0, 0, 0, 339, 340, 1, 0, 0, 0, 340, 343, 1, 0, 0, 0, 341, 339,
		1, 0, 0, 0, 342, 344, 3, 14, 7, 0, 343, 342, 1, 0, 0, 0, 344, 345, 1, 0,
		0, 0, 345, 343, 1, 0, 0, 0, 345, 346, 1, 0, 0, 0, 346, 11, 1, 0, 0, 0,
		347, 348, 5, 87, 0, 0, 348, 349, 5, 103, 0, 0, 349, 350, 3, 208, 104, 0,
		350, 351, 5, 220, 0, 0, 351, 13, 1, 0, 0, 0, 352, 360, 3, 56, 28, 0, 353,
		360, 3, 16, 8, 0, 354, 360, 3, 22, 11, 0, 355, 360, 3, 26, 13, 0, 356,
		360, 3, 28, 14, 0, 357, 360, 3, 156, 78, 0, 358, 360, 3, 158, 79, 0, 359,
		352, 1, 0, 0, 0, 359, 353, 1, 0, 0, 0, 359, 354, 1, 0, 0, 0, 359, 355,
		1, 0, 0, 0, 359, 356, 1, 0, 0, 0, 359, 357, 1, 0, 0, 0, 359, 358, 1, 0,
		0, 0, 360, 15, 1, 0, 0, 0, 361, 363, 5, 128, 0, 0, 362, 364, 7, 0, 0, 0,
		363, 362, 1, 0, 0, 0, 363, 364, 1, 0, 0, 0, 364, 365, 1, 0, 0, 0, 365,
		366, 3, 18, 9, 0, 366, 367, 5, 220, 0, 0, 367, 17, 1, 0, 0, 0, 368, 370,
		5, 194, 0, 0, 369, 368, 1, 0, 0, 0, 369, 370, 1, 0, 0, 0, 370, 371, 1,
		0, 0, 0, 371, 379, 3, 20, 10, 0, 372, 374, 5, 218, 0, 0, 373, 375, 5, 194,
		0, 0, 374, 373, 1, 0, 0, 0, 374, 375, 1, 0, 0, 0, 375, 376, 1, 0, 0, 0,
		376, 378, 3, 20, 10, 0, 377, 372, 1, 0, 0, 0, 378, 381, 1, 0, 0, 0, 379,
		377, 1, 0, 0, 0, 379, 380, 1, 0, 0, 0, 380, 19, 1, 0, 0, 0, 381, 379, 1,
		0, 0, 0, 382, 383, 3, 208, 104, 0, 383, 21, 1, 0, 0, 0, 384, 399, 5, 103,
		0, 0, 385, 387, 3, 208, 104, 0, 386, 385, 1, 0, 0, 0, 386, 387, 1, 0, 0,
		0, 387, 388, 1, 0, 0, 0, 388, 392, 5, 216, 0, 0, 389, 391, 3, 24, 12, 0,
		390, 389, 1, 0, 0, 0, 391, 394, 1, 0, 0, 0, 392, 390, 1, 0, 0, 0, 392,
		393, 1, 0, 0, 0, 393, 395, 1, 0, 0, 0, 394, 392, 1, 0, 0, 0, 395, 400,
		5, 217, 0, 0, 396, 397, 3, 208, 104, 0, 397, 398, 5, 220, 0, 0, 398, 400,
		1, 0, 0, 0, 399, 386, 1, 0, 0, 0, 399, 396, 1, 0, 0, 0, 400, 23, 1, 0,
		0, 0, 401, 407, 3, 56, 28, 0, 402, 407, 3, 16, 8, 0, 403, 407, 3, 26, 13,
		0, 404, 407, 3, 28, 14, 0, 405, 407, 3, 156, 78, 0, 406, 401, 1, 0, 0,
		0, 406, 402, 1, 0, 0, 0, 406, 403, 1, 0, 0, 0, 406, 404, 1, 0, 0, 0, 406,
		405, 1, 0, 0, 0, 407, 25, 1, 0, 0, 0, 408, 410, 3, 46, 23, 0, 409, 408,
		1, 0, 0, 0, 409, 410, 1, 0, 0, 0, 410, 411, 1, 0, 0, 0, 411, 413, 5, 82,
		0, 0, 412, 414, 5, 198, 0, 0, 413, 412, 1, 0, 0, 0, 413, 414, 1, 0, 0,
		0, 414, 415, 1, 0, 0, 0, 415, 417, 3, 266, 133, 0, 416, 418, 3, 34, 17,
		0, 417, 416, 1, 0, 0, 0, 417, 418, 1, 0, 0, 0, 418, 419, 1, 0, 0, 0, 419,
		420, 5, 212, 0, 0, 420, 421, 3, 116, 58, 0, 421, 427, 5, 213, 0, 0, 422,
		424, 5, 219, 0, 0, 423, 425, 5, 211, 0, 0, 424, 423, 1, 0, 0, 0, 424, 425,
		1, 0, 0, 0, 425, 426, 1, 0, 0, 0, 426, 428, 3, 120, 60, 0, 427, 422, 1,
		0, 0, 0, 427, 428, 1, 0, 0, 0, 428, 429, 1, 0, 0, 0, 429, 430, 3, 60, 30,
		0, 430, 27, 1, 0, 0, 0, 431, 433, 3, 46, 23, 0, 432, 431, 1, 0, 0, 0, 432,
		433, 1, 0, 0, 0, 433, 435, 1, 0, 0, 0, 434, 436, 5, 110, 0, 0, 435, 434,
		1, 0, 0, 0, 435, 436, 1, 0, 0, 0, 436, 438, 1, 0, 0, 0, 437, 439, 3, 264,
		132, 0, 438, 437, 1, 0, 0, 0, 438, 439, 1, 0, 0, 0, 439, 441, 1, 0, 0,
		0, 440, 442, 5, 108, 0, 0, 441, 440, 1, 0, 0, 0, 441, 442, 1, 0, 0, 0,
		442, 465, 1, 0, 0, 0, 443, 444, 3, 30, 15, 0, 444, 446, 3, 266, 133, 0,
		445, 447, 3, 34, 17, 0, 446, 445, 1, 0, 0, 0, 446, 447, 1, 0, 0, 0, 447,
		450, 1, 0, 0, 0, 448, 449, 5, 76, 0, 0, 449, 451, 3, 198, 99, 0, 450, 448,
		1, 0, 0, 0, 450, 451, 1, 0, 0, 0, 451, 454, 1, 0, 0, 0, 452, 453, 5, 86,
		0, 0, 453, 455, 3, 32, 16, 0, 454, 452, 1, 0, 0, 0, 454, 455, 1, 0, 0,
		0, 455, 466, 1, 0, 0, 0, 456, 457, 5, 96, 0, 0, 457, 459, 3, 266, 133,
		0, 458, 460, 3, 34, 17, 0, 459, 458, 1, 0, 0, 0, 459, 460, 1, 0, 0, 0,
		460, 463, 1, 0, 0, 0, 461, 462, 5, 76, 0, 0, 462, 464, 3, 32, 16, 0, 463,
		461, 1, 0, 0, 0, 463, 464, 1, 0, 0, 0, 464, 466, 1, 0, 0, 0, 465, 443,
		1, 0, 0, 0, 465, 456, 1, 0, 0, 0, 466, 467, 1, 0, 0, 0, 467, 471, 5, 216,
		0, 0, 468, 470, 3, 130, 65, 0, 469, 468, 1, 0, 0, 0, 470, 473, 1, 0, 0,
		0, 471, 469, 1, 0, 0, 0, 471, 472, 1, 0, 0, 0, 472, 474, 1, 0, 0, 0, 473,
		471, 1, 0, 0, 0, 474, 475, 5, 217, 0, 0, 475, 29, 1, 0, 0, 0, 476, 477,
		7, 1, 0, 0, 477, 31, 1, 0, 0, 0, 478, 483, 3, 198, 99, 0, 479, 480, 5,
		218, 0, 0, 480, 482, 3, 198, 99, 0, 481, 479, 1, 0, 0, 0, 482, 485, 1,
		0, 0, 0, 483, 481, 1, 0, 0, 0, 483, 484, 1, 0, 0, 0, 484, 33, 1, 0, 0,
		0, 485, 483, 1, 0, 0, 0, 486, 487, 5, 162, 0, 0, 487, 488, 3, 36, 18, 0,
		488, 489, 5, 163, 0, 0, 489, 501, 1, 0, 0, 0, 490, 491, 5, 162, 0, 0, 491,
		492, 3, 38, 19, 0, 492, 493, 5, 163, 0, 0, 493, 501, 1, 0, 0, 0, 494, 495,
		5, 162, 0, 0, 495, 496, 3, 36, 18, 0, 496, 497, 5, 218, 0, 0, 497, 498,
		3, 38, 19, 0, 498, 499, 5, 163, 0, 0, 499, 501, 1, 0, 0, 0, 500, 486, 1,
		0, 0, 0, 500, 490, 1, 0, 0, 0, 500, 494, 1, 0, 0, 0, 501, 35, 1, 0, 0,
		0, 502, 507, 3, 40, 20, 0, 503, 504, 5, 218, 0, 0, 504, 506, 3, 40, 20,
		0, 505, 503, 1, 0, 0, 0, 506, 509, 1, 0, 0, 0, 507, 505, 1, 0, 0, 0, 507,
		508, 1, 0, 0, 0, 508, 37, 1, 0, 0, 0, 509, 507, 1, 0, 0, 0, 510, 515, 3,
		42, 21, 0, 511, 512, 5, 218, 0, 0, 512, 514, 3, 42, 21, 0, 513, 511, 1,
		0, 0, 0, 514, 517, 1, 0, 0, 0, 515, 513, 1, 0, 0, 0, 515, 516, 1, 0, 0,
		0, 516, 39, 1, 0, 0, 0, 517, 515, 1, 0, 0, 0, 518, 520, 3, 46, 23, 0, 519,
		518, 1, 0, 0, 0, 519, 520, 1, 0, 0, 0, 520, 521, 1, 0, 0, 0, 521, 522,
		3, 266, 133, 0, 522, 41, 1, 0, 0, 0, 523, 525, 3, 46, 23, 0, 524, 523,
		1, 0, 0, 0, 524, 525, 1, 0, 0, 0, 525, 526, 1, 0, 0, 0, 526, 527, 3, 266,
		133, 0, 527, 530, 5, 221, 0, 0, 528, 531, 3, 198, 99, 0, 529, 531, 3, 274,
		137, 0, 530, 528, 1, 0, 0, 0, 530, 529, 1, 0, 0, 0, 531, 43, 1, 0, 0, 0,
		532, 533, 5, 162, 0, 0, 533, 538, 3, 200, 100, 0, 534, 535, 5, 218, 0,
		0, 535, 537, 3, 200, 100, 0, 536, 534, 1, 0, 0, 0, 537, 540, 1, 0, 0, 0,
		538, 536, 1, 0, 0, 0, 538, 539, 1, 0, 0, 0, 539, 541, 1, 0, 0, 0, 540,
		538, 1, 0, 0, 0, 541, 542, 5, 163, 0, 0, 542, 45, 1, 0, 0, 0, 543, 545,
		3, 48, 24, 0, 544, 543, 1, 0, 0, 0, 545, 546, 1, 0, 0, 0, 546, 544, 1,
		0, 0, 0, 546, 547, 1, 0, 0, 0, 547, 47, 1, 0, 0, 0, 548, 552, 5, 43, 0,
		0, 549, 550, 3, 266, 133, 0, 550, 551, 5, 219, 0, 0, 551, 553, 1, 0, 0,
		0, 552, 549, 1, 0, 0, 0, 552, 553, 1, 0, 0, 0, 553, 554, 1, 0, 0, 0, 554,
		559, 3, 50, 25, 0, 555, 556, 5, 218, 0, 0, 556, 558, 3, 50, 25, 0, 557,
		555, 1, 0, 0, 0, 558, 561, 1, 0, 0, 0, 559, 557, 1, 0, 0, 0, 559, 560,
		1, 0, 0, 0, 560, 562, 1, 0, 0, 0, 561, 559, 1, 0, 0, 0, 562, 563, 5, 215,
		0, 0, 563, 49, 1, 0, 0, 0, 564, 566, 3, 206, 103, 0, 565, 567, 3, 214,
		107, 0, 566, 565, 1, 0, 0, 0, 566, 567, 1, 0, 0, 0, 567, 51, 1, 0, 0, 0,
		568, 570, 3, 54, 27, 0, 569, 568, 1, 0, 0, 0, 570, 573, 1, 0, 0, 0, 571,
		569, 1, 0, 0, 0, 571, 572, 1, 0, 0, 0, 572, 53, 1, 0, 0, 0, 573, 571, 1,
		0, 0, 0, 574, 578, 3, 56, 28, 0, 575, 578, 3, 26, 13, 0, 576, 578, 3, 28,
		14, 0, 577, 574, 1, 0, 0, 0, 577, 575, 1, 0, 0, 0, 577, 576, 1, 0, 0, 0,
		578, 55, 1, 0, 0, 0, 579, 580, 3, 266, 133, 0, 580, 581, 5, 219, 0, 0,
		581, 607, 1, 0, 0, 0, 582, 607, 3, 60, 30, 0, 583, 607, 3, 62, 31, 0, 584,
		607, 3, 72, 36, 0, 585, 607, 3, 74, 37, 0, 586, 607, 3, 76, 38, 0, 587,
		607, 3, 82, 41, 0, 588, 607, 3, 86, 43, 0, 589, 607, 3, 88, 44, 0, 590,
		607, 3, 90, 45, 0, 591, 592, 3, 188, 94, 0, 592, 593, 5, 220, 0, 0, 593,
		607, 1, 0, 0, 0, 594, 607, 3, 122, 61, 0, 595, 607, 3, 128, 64, 0, 596,
		607, 3, 126, 63, 0, 597, 607, 3, 92, 46, 0, 598, 607, 3, 94, 47, 0, 599,
		607, 3, 96, 48, 0, 600, 607, 3, 98, 49, 0, 601, 607, 3, 104, 52, 0, 602,
		607, 3, 106, 53, 0, 603, 607, 3, 108, 54, 0, 604, 607, 3, 58, 29, 0, 605,
		607, 3, 110, 55, 0, 606, 579, 1, 0, 0, 0, 606, 582, 1, 0, 0, 0, 606, 583,
		1, 0, 0, 0, 606, 584, 1, 0, 0, 0, 606, 585, 1, 0, 0, 0, 606, 586, 1, 0,
		0, 0, 606, 587, 1, 0, 0, 0, 606, 588, 1, 0, 0, 0, 606, 589, 1, 0, 0, 0,
		606, 590, 1, 0, 0, 0, 606, 591, 1, 0, 0, 0, 606, 594, 1, 0, 0, 0, 606,
		595, 1, 0, 0, 0, 606, 596, 1, 0, 0, 0, 606, 597, 1, 0, 0, 0, 606, 598,
		1, 0, 0, 0, 606, 599, 1, 0, 0, 0, 606, 600, 1, 0, 0, 0, 606, 601, 1, 0,
		0, 0, 606, 602, 1, 0, 0, 0, 606, 603, 1, 0, 0, 0, 606, 604, 1, 0, 0, 0,
		606, 605, 1, 0, 0, 0, 607, 57, 1, 0, 0, 0, 608, 609, 5, 220, 0, 0, 609,
		59, 1, 0, 0, 0, 610, 611, 5, 216, 0, 0, 611, 612, 3, 52, 26, 0, 612, 613,
		5, 217, 0, 0, 613, 61, 1, 0, 0, 0, 614, 615, 5, 85, 0, 0, 615, 616, 3,
		164, 82, 0, 616, 620, 3, 56, 28, 0, 617, 619, 3, 64, 32, 0, 618, 617, 1,
		0, 0, 0, 619, 622, 1, 0, 0, 0, 620, 618, 1, 0, 0, 0, 620, 621, 1, 0, 0,
		0, 621, 624, 1, 0, 0, 0, 622, 620, 1, 0, 0, 0, 623, 625, 3, 68, 34, 0,
		624, 623, 1, 0, 0, 0, 624, 625, 1, 0, 0, 0, 625, 643, 1, 0, 0, 0, 626,
		627, 5, 85, 0, 0, 627, 628, 3, 164, 82, 0, 628, 629, 5, 219, 0, 0, 629,
		633, 3, 52, 26, 0, 630, 632, 3, 66, 33, 0, 631, 630, 1, 0, 0, 0, 632, 635,
		1, 0, 0, 0, 633, 631, 1, 0, 0, 0, 633, 634, 1, 0, 0, 0, 634, 637, 1, 0,
		0, 0, 635, 633, 1, 0, 0, 0, 636, 638, 3, 70, 35, 0, 637, 636, 1, 0, 0,
		0, 637, 638, 1, 0, 0, 0, 638, 639, 1, 0, 0, 0, 639, 640, 5, 71, 0, 0, 640,
		641, 5, 220, 0, 0, 641, 643, 1, 0, 0, 0, 642, 614, 1, 0, 0, 0, 642, 626,
		1, 0, 0, 0, 643, 63, 1, 0, 0, 0, 644, 645, 5, 65, 0, 0, 645, 646, 3, 164,
		82, 0, 646, 647, 3, 56, 28, 0, 647, 65, 1, 0, 0, 0, 648, 649, 5, 65, 0,
		0, 649, 650, 3, 164, 82, 0, 650, 651, 5, 219, 0, 0, 651, 652, 3, 52, 26,
		0, 652, 67, 1, 0, 0, 0, 653, 654, 5, 64, 0, 0, 654, 655, 3, 56, 28, 0,
		655, 69, 1, 0, 0, 0, 656, 657, 5, 64, 0, 0, 657, 658, 5, 219, 0, 0, 658,
		659, 3, 52, 26, 0, 659, 71, 1, 0, 0, 0, 660, 661, 5, 130, 0, 0, 661, 668,
		3, 164, 82, 0, 662, 669, 3, 56, 28, 0, 663, 664, 5, 219, 0, 0, 664, 665,
		3, 52, 26, 0, 665, 666, 5, 73, 0, 0, 666, 667, 5, 220, 0, 0, 667, 669,
		1, 0, 0, 0, 668, 662, 1, 0, 0, 0, 668, 663, 1, 0, 0, 0, 669, 73, 1, 0,
		0, 0, 670, 671, 5, 60, 0, 0, 671, 672, 3, 56, 28, 0, 672, 673, 5, 130,
		0, 0, 673, 674, 3, 164, 82, 0, 674, 675, 5, 220, 0, 0, 675, 75, 1, 0, 0,
		0, 676, 677, 5, 80, 0, 0, 677, 679, 5, 212, 0, 0, 678, 680, 3, 78, 39,
		0, 679, 678, 1, 0, 0, 0, 679, 680, 1, 0, 0, 0, 680, 681, 1, 0, 0, 0, 681,
		683, 5, 220, 0, 0, 682, 684, 3, 162, 81, 0, 683, 682, 1, 0, 0, 0, 683,
		684, 1, 0, 0, 0, 684, 685, 1, 0, 0, 0, 685, 687, 5, 220, 0, 0, 686, 688,
		3, 80, 40, 0, 687, 686, 1, 0, 0, 0, 687, 688, 1, 0, 0, 0, 688, 689, 1,
		0, 0, 0, 689, 696, 5, 213, 0, 0, 690, 697, 3, 56, 28, 0, 691, 692, 5, 219,
		0, 0, 692, 693, 3, 52, 26, 0, 693, 694, 5, 69, 0, 0, 694, 695, 5, 220,
		0, 0, 695, 697, 1, 0, 0, 0, 696, 690, 1, 0, 0, 0, 696, 691, 1, 0, 0, 0,
		697, 77, 1, 0, 0, 0, 698, 699, 3, 162, 81, 0, 699, 79, 1, 0, 0, 0, 700,
		701, 3, 162, 81, 0, 701, 81, 1, 0, 0, 0, 702, 703, 5, 120, 0, 0, 703, 727,
		3, 164, 82, 0, 704, 706, 5, 216, 0, 0, 705, 707, 5, 220, 0, 0, 706, 705,
		1, 0, 0, 0, 706, 707, 1, 0, 0, 0, 707, 711, 1, 0, 0, 0, 708, 710, 3, 84,
		42, 0, 709, 708, 1, 0, 0, 0, 710, 713, 1, 0, 0, 0, 711, 709, 1, 0, 0, 0,
		711, 712, 1, 0, 0, 0, 712, 714, 1, 0, 0, 0, 713, 711, 1, 0, 0, 0, 714,
		728, 5, 217, 0, 0, 715, 717, 5, 219, 0, 0, 716, 718, 5, 220, 0, 0, 717,
		716, 1, 0, 0, 0, 717, 718, 1, 0, 0, 0, 718, 722, 1, 0, 0, 0, 719, 721,
		3, 84, 42, 0, 720, 719, 1, 0, 0, 0, 721, 724, 1, 0, 0, 0, 722, 720, 1,
		0, 0, 0, 722, 723, 1, 0, 0, 0, 723, 725, 1, 0, 0, 0, 724, 722, 1, 0, 0,
		0, 725, 726, 5, 72, 0, 0, 726, 728, 5, 220, 0, 0, 727, 704, 1, 0, 0, 0,
		727, 715, 1, 0, 0, 0, 728, 83, 1, 0, 0, 0, 729, 730, 5, 52, 0, 0, 730,
		733, 3, 166, 83, 0, 731, 733, 5, 59, 0, 0, 732, 729, 1, 0, 0, 0, 732, 731,
		1, 0, 0, 0, 733, 734, 1, 0, 0, 0, 734, 736, 7, 2, 0, 0, 735, 732, 1, 0,
		0, 0, 736, 737, 1, 0, 0, 0, 737, 735, 1, 0, 0, 0, 737, 738, 1, 0, 0, 0,
		738, 739, 1, 0, 0, 0, 739, 740, 3, 52, 26, 0, 740, 85, 1, 0, 0, 0, 741,
		743, 5, 50, 0, 0, 742, 744, 3, 166, 83, 0, 743, 742, 1, 0, 0, 0, 743, 744,
		1, 0, 0, 0, 744, 745, 1, 0, 0, 0, 745, 746, 5, 220, 0, 0, 746, 87, 1, 0,
		0, 0, 747, 749, 5, 57, 0, 0, 748, 750, 3, 166, 83, 0, 749, 748, 1, 0, 0,
		0, 749, 750, 1, 0, 0, 0, 750, 751, 1, 0, 0, 0, 751, 752, 5, 220, 0, 0,
		752, 89, 1, 0, 0, 0, 753, 755, 5, 117, 0, 0, 754, 756, 3, 166, 83, 0, 755,
		754, 1, 0, 0, 0, 755, 756, 1, 0, 0, 0, 756, 757, 1, 0, 0, 0, 757, 758,
		5, 220, 0, 0, 758, 91, 1, 0, 0, 0, 759, 760, 3, 166, 83, 0, 760, 761, 5,
		220, 0, 0, 761, 93, 1, 0, 0, 0, 762, 763, 5, 127, 0, 0, 763, 764, 5, 212,
		0, 0, 764, 765, 3, 236, 118, 0, 765, 766, 5, 213, 0, 0, 766, 767, 5, 220,
		0, 0, 767, 95, 1, 0, 0, 0, 768, 813, 5, 81, 0, 0, 769, 770, 5, 212, 0,
		0, 770, 771, 3, 166, 83, 0, 771, 772, 5, 46, 0, 0, 772, 773, 3, 172, 86,
		0, 773, 774, 5, 213, 0, 0, 774, 814, 1, 0, 0, 0, 775, 776, 5, 212, 0, 0,
		776, 777, 3, 238, 119, 0, 777, 779, 5, 46, 0, 0, 778, 780, 5, 198, 0, 0,
		779, 778, 1, 0, 0, 0, 779, 780, 1, 0, 0, 0, 780, 781, 1, 0, 0, 0, 781,
		787, 3, 168, 84, 0, 782, 784, 5, 164, 0, 0, 783, 785, 5, 198, 0, 0, 784,
		783, 1, 0, 0, 0, 784, 785, 1, 0, 0, 0, 785, 786, 1, 0, 0, 0, 786, 788,
		3, 238, 119, 0, 787, 782, 1, 0, 0, 0, 787, 788, 1, 0, 0, 0, 788, 789, 1,
		0, 0, 0, 789, 790, 5, 213, 0, 0, 790, 814, 1, 0, 0, 0, 791, 792, 5, 212,
		0, 0, 792, 793, 3, 166, 83, 0, 793, 794, 5, 46, 0, 0, 794, 800, 3, 168,
		84, 0, 795, 797, 5, 164, 0, 0, 796, 798, 5, 198, 0, 0, 797, 796, 1, 0,
		0, 0, 797, 798, 1, 0, 0, 0, 798, 799, 1, 0, 0, 0, 799, 801, 3, 238, 119,
		0, 800, 795, 1, 0, 0, 0, 800, 801, 1, 0, 0, 0, 801, 802, 1, 0, 0, 0, 802,
		803, 5, 213, 0, 0, 803, 814, 1, 0, 0, 0, 804, 805, 5, 212, 0, 0, 805, 806,
		3, 238, 119, 0, 806, 807, 5, 46, 0, 0, 807, 808, 5, 98, 0, 0, 808, 809,
		5, 212, 0, 0, 809, 810, 3, 260, 130, 0, 810, 811, 5, 213, 0, 0, 811, 812,
		5, 213, 0, 0, 812, 814, 1, 0, 0, 0, 813, 769, 1, 0, 0, 0, 813, 775, 1,
		0, 0, 0, 813, 791, 1, 0, 0, 0, 813, 804, 1, 0, 0, 0, 814, 821, 1, 0, 0,
		0, 815, 822, 3, 56, 28, 0, 816, 817, 5, 219, 0, 0, 817, 818, 3, 52, 26,
		0, 818, 819, 5, 70, 0, 0, 819, 820, 5, 220, 0, 0, 820, 822, 1, 0, 0, 0,
		821, 815, 1, 0, 0, 0, 821, 816, 1, 0, 0, 0, 822, 97, 1, 0, 0, 0, 823, 824,
		5, 123, 0, 0, 824, 840, 3, 60, 30, 0, 825, 827, 3, 100, 50, 0, 826, 825,
		1, 0, 0, 0, 827, 828, 1, 0, 0, 0, 828, 826, 1, 0, 0, 0, 828, 829, 1, 0,
		0, 0, 829, 831, 1, 0, 0, 0, 830, 832, 3, 102, 51, 0, 831, 830, 1, 0, 0,
		0, 831, 832, 1, 0, 0, 0, 832, 841, 1, 0, 0, 0, 833, 835, 3, 100, 50, 0,
		834, 833, 1, 0, 0, 0, 835, 838, 1, 0, 0, 0, 836, 834, 1, 0, 0, 0, 836,
		837, 1, 0, 0, 0, 837, 839, 1, 0, 0, 0, 838, 836, 1, 0, 0, 0, 839, 841,
		3, 102, 51, 0, 840, 826, 1, 0, 0, 0, 840, 836, 1, 0, 0, 0, 841, 99, 1,
		0, 0, 0, 842, 843, 5, 53, 0, 0, 843, 844, 5, 212, 0, 0, 844, 849, 3, 198,
		99, 0, 845, 846, 5, 199, 0, 0, 846, 848, 3, 198, 99, 0, 847, 845, 1, 0,
		0, 0, 848, 851, 1, 0, 0, 0, 849, 847, 1, 0, 0, 0, 849, 850, 1, 0, 0, 0,
		850, 853, 1, 0, 0, 0, 851, 849, 1, 0, 0, 0, 852, 854, 5, 224, 0, 0, 853,
		852, 1, 0, 0, 0, 853, 854, 1, 0, 0, 0, 854, 855, 1, 0, 0, 0, 855, 856,
		5, 213, 0, 0, 856, 857, 3, 60, 30, 0, 857, 101, 1, 0, 0, 0, 858, 859, 5,
		78, 0, 0, 859, 860, 3, 60, 30, 0, 860, 103, 1, 0, 0, 0, 861, 862, 5, 121,
		0, 0, 862, 863, 3, 166, 83, 0, 863, 864, 5, 220, 0, 0, 864, 105, 1, 0,
		0, 0, 865, 866, 5, 84, 0, 0, 866, 867, 3, 266, 133, 0, 867, 868, 5, 220,
		0, 0, 868, 107, 1, 0, 0, 0, 869, 870, 5, 58, 0, 0, 870, 871, 5, 212, 0,
		0, 871, 872, 3, 112, 56, 0, 872, 879, 5, 213, 0, 0, 873, 880, 3, 56, 28,
		0, 874, 875, 5, 219, 0, 0, 875, 876, 3, 52, 26, 0, 876, 877, 5, 68, 0,
		0, 877, 878, 5, 220, 0, 0, 878, 880, 1, 0, 0, 0, 879, 873, 1, 0, 0, 0,
		879, 874, 1, 0, 0, 0, 880, 109, 1, 0, 0, 0, 881, 883, 3, 4, 2, 0, 882,
		881, 1, 0, 0, 0, 883, 884, 1, 0, 0, 0, 884, 882, 1, 0, 0, 0, 884, 885,
		1, 0, 0, 0, 885, 111, 1, 0, 0, 0, 886, 891, 3, 114, 57, 0, 887, 888, 5,
		218, 0, 0, 888, 890, 3, 114, 57, 0, 889, 887, 1, 0, 0, 0, 890, 893, 1,
		0, 0, 0, 891, 889, 1, 0, 0, 0, 891, 892, 1, 0, 0, 0, 892, 113, 1, 0, 0,
		0, 893, 891, 1, 0, 0, 0, 894, 895, 5, 134, 0, 0, 895, 898, 5, 221, 0, 0,
		896, 899, 3, 226, 113, 0, 897, 899, 5, 228, 0, 0, 898, 896, 1, 0, 0, 0,
		898, 897, 1, 0, 0, 0, 899, 907, 1, 0, 0, 0, 900, 901, 5, 135, 0, 0, 901,
		902, 5, 221, 0, 0, 902, 907, 5, 232, 0, 0, 903, 904, 5, 136, 0, 0, 904,
		905, 5, 221, 0, 0, 905, 907, 3, 226, 113, 0, 906, 894, 1, 0, 0, 0, 906,
		900, 1, 0, 0, 0, 906, 903, 1, 0, 0, 0, 907, 115, 1, 0, 0, 0, 908, 910,
		3, 118, 59, 0, 909, 908, 1, 0, 0, 0, 909, 910, 1, 0, 0, 0, 910, 915, 1,
		0, 0, 0, 911, 912, 5, 218, 0, 0, 912, 914, 3, 118, 59, 0, 913, 911, 1,
		0, 0, 0, 914, 917, 1, 0, 0, 0, 915, 913, 1, 0, 0, 0, 915, 916, 1, 0, 0,
		0, 916, 919, 1, 0, 0, 0, 917, 915, 1, 0, 0, 0, 918, 920, 5, 218, 0, 0,
		919, 918, 1, 0, 0, 0, 919, 920, 1, 0, 0, 0, 920, 117, 1, 0, 0, 0, 921,
		923, 3, 46, 23, 0, 922, 921, 1, 0, 0, 0, 922, 923, 1, 0, 0, 0, 923, 927,
		1, 0, 0, 0, 924, 926, 3, 268, 134, 0, 925, 924, 1, 0, 0, 0, 926, 929, 1,
		0, 0, 0, 927, 925, 1, 0, 0, 0, 927, 928, 1, 0, 0, 0, 928, 931, 1, 0, 0,
		0, 929, 927, 1, 0, 0, 0, 930, 932, 5, 211, 0, 0, 931, 930, 1, 0, 0, 0,
		931, 932, 1, 0, 0, 0, 932, 934, 1, 0, 0, 0, 933, 935, 3, 120, 60, 0, 934,
		933, 1, 0, 0, 0, 934, 935, 1, 0, 0, 0, 935, 937, 1, 0, 0, 0, 936, 938,
		5, 198, 0, 0, 937, 936, 1, 0, 0, 0, 937, 938, 1, 0, 0, 0, 938, 940, 1,
		0, 0, 0, 939, 941, 5, 195, 0, 0, 940, 939, 1, 0, 0, 0, 940, 941, 1, 0,
		0, 0, 941, 942, 1, 0, 0, 0, 942, 943, 3, 152, 76, 0, 943, 119, 1, 0, 0,
		0, 944, 945, 6, 60, -1, 0, 945, 949, 3, 198, 99, 0, 946, 949, 5, 51, 0,
		0, 947, 949, 3, 274, 137, 0, 948, 944, 1, 0, 0, 0, 948, 946, 1, 0, 0, 0,
		948, 947, 1, 0, 0, 0, 949, 955, 1, 0, 0, 0, 950, 951, 10, 1, 0, 0, 951,
		952, 5, 199, 0, 0, 952, 954, 3, 120, 60, 2, 953, 950, 1, 0, 0, 0, 954,
		957, 1, 0, 0, 0, 955, 953, 1, 0, 0, 0, 955, 956, 1, 0, 0, 0, 956, 121,
		1, 0, 0, 0, 957, 955, 1, 0, 0, 0, 958, 959, 5, 83, 0, 0, 959, 964, 3, 124,
		62, 0, 960, 961, 5, 218, 0, 0, 961, 963, 3, 124, 62, 0, 962, 960, 1, 0,
		0, 0, 963, 966, 1, 0, 0, 0, 964, 962, 1, 0, 0, 0, 964, 965, 1, 0, 0, 0,
		965, 967, 1, 0, 0, 0, 966, 964, 1, 0, 0, 0, 967, 968, 5, 220, 0, 0, 968,
		123, 1, 0, 0, 0, 969, 978, 5, 224, 0, 0, 970, 971, 5, 209, 0, 0, 971, 978,
		3, 238, 119, 0, 972, 973, 5, 209, 0, 0, 973, 974, 5, 216, 0, 0, 974, 975,
		3, 166, 83, 0, 975, 976, 5, 217, 0, 0, 976, 978, 1, 0, 0, 0, 977, 969,
		1, 0, 0, 0, 977, 970, 1, 0, 0, 0, 977, 972, 1, 0, 0, 0, 978, 125, 1, 0,
		0, 0, 979, 980, 5, 63, 0, 0, 980, 981, 3, 162, 81, 0, 981, 982, 5, 220,
		0, 0, 982, 127, 1, 0, 0, 0, 983, 984, 5, 118, 0, 0, 984, 989, 3, 152, 76,
		0, 985, 986, 5, 218, 0, 0, 986, 988, 3, 152, 76, 0, 987, 985, 1, 0, 0,
		0, 988, 991, 1, 0, 0, 0, 989, 987, 1, 0, 0, 0, 989, 990, 1, 0, 0, 0, 990,
		992, 1, 0, 0, 0, 991, 989, 1, 0, 0, 0, 992, 993, 5, 220, 0, 0, 993, 129,
		1, 0, 0, 0, 994, 996, 3, 46, 23, 0, 995, 994, 1, 0, 0, 0, 995, 996, 1,
		0, 0, 0, 996, 1047, 1, 0, 0, 0, 997, 999, 3, 148, 74, 0, 998, 1000, 3,
		120, 60, 0, 999, 998, 1, 0, 0, 0, 999, 1000, 1, 0, 0, 0, 1000, 1001, 1,
		0, 0, 0, 1001, 1006, 3, 152, 76, 0, 1002, 1003, 5, 218, 0, 0, 1003, 1005,
		3, 152, 76, 0, 1004, 1002, 1, 0, 0, 0, 1005, 1008, 1, 0, 0, 0, 1006, 1004,
		1, 0, 0, 0, 1006, 1007, 1, 0, 0, 0, 1007, 1009, 1, 0, 0, 0, 1008, 1006,
		1, 0, 0, 0, 1009, 1010, 5, 220, 0, 0, 1010, 1048, 1, 0, 0, 0, 1011, 1013,
		3, 150, 75, 0, 1012, 1011, 1, 0, 0, 0, 1012, 1013, 1, 0, 0, 0, 1013, 1045,
		1, 0, 0, 0, 1014, 1016, 5, 56, 0, 0, 1015, 1017, 3, 120, 60, 0, 1016, 1015,
		1, 0, 0, 0, 1016, 1017, 1, 0, 0, 0, 1017, 1018, 1, 0, 0, 0, 1018, 1023,
		3, 154, 77, 0, 1019, 1020, 5, 218, 0, 0, 1020, 1022, 3, 154, 77, 0, 1021,
		1019, 1, 0, 0, 0, 1022, 1025, 1, 0, 0, 0, 1023, 1021, 1, 0, 0, 0, 1023,
		1024, 1, 0, 0, 0, 1024, 1026, 1, 0, 0, 0, 1025, 1023, 1, 0, 0, 0, 1026,
		1027, 5, 220, 0, 0, 1027, 1046, 1, 0, 0, 0, 1028, 1030, 5, 82, 0, 0, 1029,
		1031, 5, 198, 0, 0, 1030, 1029, 1, 0, 0, 0, 1030, 1031, 1, 0, 0, 0, 1031,
		1032, 1, 0, 0, 0, 1032, 1034, 3, 266, 133, 0, 1033, 1035, 3, 34, 17, 0,
		1034, 1033, 1, 0, 0, 0, 1034, 1035, 1, 0, 0, 0, 1035, 1036, 1, 0, 0, 0,
		1036, 1037, 5, 212, 0, 0, 1037, 1038, 3, 116, 58, 0, 1038, 1041, 5, 213,
		0, 0, 1039, 1042, 3, 142, 71, 0, 1040, 1042, 3, 144, 72, 0, 1041, 1039,
		1, 0, 0, 0, 1041, 1040, 1, 0, 0, 0, 1041, 1042, 1, 0, 0, 0, 1042, 1043,
		1, 0, 0, 0, 1043, 1044, 3, 146, 73, 0, 1044, 1046, 1, 0, 0, 0, 1045, 1014,
		1, 0, 0, 0, 1045, 1028, 1, 0, 0, 0, 1046, 1048, 1, 0, 0, 0, 1047, 997,
		1, 0, 0, 0, 1047, 1012, 1, 0, 0, 0, 1048, 1054, 1, 0, 0, 0, 1049, 1050,
		5, 128, 0, 0, 1050, 1051, 3, 212, 106, 0, 1051, 1052, 3, 132, 66, 0, 1052,
		1054, 1, 0, 0, 0, 1053, 995, 1, 0, 0, 0, 1053, 1049, 1, 0, 0, 0, 1054,
		131, 1, 0, 0, 0, 1055, 1065, 5, 220, 0, 0, 1056, 1060, 5, 216, 0, 0, 1057,
		1059, 3, 134, 67, 0, 1058, 1057, 1, 0, 0, 0, 1059, 1062, 1, 0, 0, 0, 1060,
		1058, 1, 0, 0, 0, 1060, 1061, 1, 0, 0, 0, 1061, 1063, 1, 0, 0, 0, 1062,
		1060, 1, 0, 0, 0, 1063, 1065, 5, 217, 0, 0, 1064, 1055, 1, 0, 0, 0, 1064,
		1056, 1, 0, 0, 0, 1065, 133, 1, 0, 0, 0, 1066, 1069, 3, 136, 68, 0, 1067,
		1069, 3, 138, 69, 0, 1068, 1066, 1, 0, 0, 0, 1068, 1067, 1, 0, 0, 0, 1069,
		135, 1, 0, 0, 0, 1070, 1071, 3, 206, 103, 0, 1071, 1072, 5, 192, 0, 0,
		1072, 1073, 3, 266, 133, 0, 1073, 1074, 5, 91, 0, 0, 1074, 1075, 3, 212,
		106, 0, 1075, 1076, 5, 220, 0, 0, 1076, 137, 1, 0, 0, 0, 1077, 1078, 3,
		140, 70, 0, 1078, 1084, 5, 46, 0, 0, 1079, 1085, 3, 268, 134, 0, 1080,
		1082, 3, 268, 134, 0, 1081, 1080, 1, 0, 0, 0, 1081, 1082, 1, 0, 0, 0, 1082,
		1083, 1, 0, 0, 0, 1083, 1085, 3, 266, 133, 0, 1084, 1079, 1, 0, 0, 0, 1084,
		1081, 1, 0, 0, 0, 1085, 1086, 1, 0, 0, 0, 1086, 1087, 5, 220, 0, 0, 1087,
		139, 1, 0, 0, 0, 1088, 1089, 3, 206, 103, 0, 1089, 1090, 5, 192, 0, 0,
		1090, 1092, 1, 0, 0, 0, 1091, 1088, 1, 0, 0, 0, 1091, 1092, 1, 0, 0, 0,
		1092, 1093, 1, 0, 0, 0, 1093, 1094, 3, 266, 133, 0, 1094, 141, 1, 0, 0,
		0, 1095, 1096, 5, 219, 0, 0, 1096, 1098, 3, 266, 133, 0, 1097, 1099, 3,
		214, 107, 0, 1098, 1097, 1, 0, 0, 0, 1098, 1099, 1, 0, 0, 0, 1099, 143,
		1, 0, 0, 0, 1100, 1102, 5, 219, 0, 0, 1101, 1103, 5, 211, 0, 0, 1102, 1101,
		1, 0, 0, 0, 1102, 1103, 1, 0, 0, 0, 1103, 1104, 1, 0, 0, 0, 1104, 1105,
		3, 120, 60, 0, 1105, 145, 1, 0, 0, 0, 1106, 1109, 5, 220, 0, 0, 1107, 1109,
		3, 60, 30, 0, 1108, 1106, 1, 0, 0, 0, 1108, 1107, 1, 0, 0, 0, 1109, 147,
		1, 0, 0, 0, 1110, 1113, 3, 150, 75, 0, 1111, 1113, 5, 129, 0, 0, 1112,
		1110, 1, 0, 0, 0, 1112, 1111, 1, 0, 0, 0, 1113, 149, 1, 0, 0, 0, 1114,
		1116, 3, 268, 134, 0, 1115, 1114, 1, 0, 0, 0, 1116, 1117, 1, 0, 0, 0, 1117,
		1115, 1, 0, 0, 0, 1117, 1118, 1, 0, 0, 0, 1118, 151, 1, 0, 0, 0, 1119,
		1122, 5, 224, 0, 0, 1120, 1121, 5, 221, 0, 0, 1121, 1123, 3, 220, 110,
		0, 1122, 1120, 1, 0, 0, 0, 1122, 1123, 1, 0, 0, 0, 1123, 153, 1, 0, 0,
		0, 1124, 1125, 3, 266, 133, 0, 1125, 1126, 5, 221, 0, 0, 1126, 1127, 3,
		220, 110, 0, 1127, 155, 1, 0, 0, 0, 1128, 1130, 3, 46, 23, 0, 1129, 1128,
		1, 0, 0, 0, 1129, 1130, 1, 0, 0, 0, 1130, 1131, 1, 0, 0, 0, 1131, 1132,
		5, 56, 0, 0, 1132, 1137, 3, 154, 77, 0, 1133, 1134, 5, 218, 0, 0, 1134,
		1136, 3, 154, 77, 0, 1135, 1133, 1, 0, 0, 0, 1136, 1139, 1, 0, 0, 0, 1137,
		1135, 1, 0, 0, 0, 1137, 1138, 1, 0, 0, 0, 1138, 1140, 1, 0, 0, 0, 1139,
		1137, 1, 0, 0, 0, 1140, 1141, 5, 220, 0, 0, 1141, 157, 1, 0, 0, 0, 1142,
		1143, 5, 67, 0, 0, 1143, 1146, 3, 266, 133, 0, 1144, 1145, 5, 219, 0, 0,
		1145, 1147, 7, 3, 0, 0, 1146, 1144, 1, 0, 0, 0, 1146, 1147, 1, 0, 0, 0,
		1147, 1150, 1, 0, 0, 0, 1148, 1149, 5, 86, 0, 0, 1149, 1151, 3, 32, 16,
		0, 1150, 1148, 1, 0, 0, 0, 1150, 1151, 1, 0, 0, 0, 1151, 1152, 1, 0, 0,
		0, 1152, 1156, 5, 216, 0, 0, 1153, 1155, 3, 160, 80, 0, 1154, 1153, 1,
		0, 0, 0, 1155, 1158, 1, 0, 0, 0, 1156, 1154, 1, 0, 0, 0, 1156, 1157, 1,
		0, 0, 0, 1157, 1159, 1, 0, 0, 0, 1158, 1156, 1, 0, 0, 0, 1159, 1160, 5,
		217, 0, 0, 1160, 159, 1, 0, 0, 0, 1161, 1162, 5, 52, 0, 0, 1162, 1165,
		3, 266, 133, 0, 1163, 1164, 5, 221, 0, 0, 1164, 1166, 3, 166, 83, 0, 1165,
		1163, 1, 0, 0, 0, 1165, 1166, 1, 0, 0, 0, 1166, 1167, 1, 0, 0, 0, 1167,
		1168, 5, 220, 0, 0, 1168, 1178, 1, 0, 0, 0, 1169, 1171, 3, 150, 75, 0,
		1170, 1169, 1, 0, 0, 0, 1170, 1171, 1, 0, 0, 0, 1171, 1172, 1, 0, 0, 0,
		1172, 1178, 3, 26, 13, 0, 1173, 1174, 5, 128, 0, 0, 1174, 1175, 3, 212,
		106, 0, 1175, 1176, 3, 132, 66, 0, 1176, 1178, 1, 0, 0, 0, 1177, 1161,
		1, 0, 0, 0, 1177, 1170, 1, 0, 0, 0, 1177, 1173, 1, 0, 0, 0, 1178, 161,
		1, 0, 0, 0, 1179, 1184, 3, 166, 83, 0, 1180, 1181, 5, 218, 0, 0, 1181,
		1183, 3, 166, 83, 0, 1182, 1180, 1, 0, 0, 0, 1183, 1186, 1, 0, 0, 0, 1184,
		1182, 1, 0, 0, 0, 1184, 1185, 1, 0, 0, 0, 1185, 163, 1, 0, 0, 0, 1186,
		1184, 1, 0, 0, 0, 1187, 1190, 5, 212, 0, 0, 1188, 1191, 3, 166, 83, 0,
		1189, 1191, 3, 188, 94, 0, 1190, 1188, 1, 0, 0, 0, 1190, 1189, 1, 0, 0,
		0, 1191, 1192, 1, 0, 0, 0, 1192, 1193, 5, 213, 0, 0, 1193, 165, 1, 0, 0,
		0, 1194, 1195, 6, 83, -1, 0, 1195, 1196, 5, 55, 0, 0, 1196, 1285, 3, 166,
		83, 48, 1197, 1285, 3, 184, 92, 0, 1198, 1199, 3, 230, 115, 0, 1199, 1200,
		5, 214, 0, 0, 1200, 1201, 3, 166, 83, 0, 1201, 1202, 5, 215, 0, 0, 1202,
		1285, 1, 0, 0, 0, 1203, 1204, 5, 212, 0, 0, 1204, 1205, 3, 276, 138, 0,
		1205, 1206, 5, 213, 0, 0, 1206, 1207, 3, 166, 83, 45, 1207, 1285, 1, 0,
		0, 0, 1208, 1209, 7, 4, 0, 0, 1209, 1285, 3, 166, 83, 44, 1210, 1211, 7,
		5, 0, 0, 1211, 1285, 3, 166, 83, 43, 1212, 1213, 7, 6, 0, 0, 1213, 1285,
		3, 238, 119, 0, 1214, 1215, 3, 238, 119, 0, 1215, 1216, 7, 6, 0, 0, 1216,
		1285, 1, 0, 0, 0, 1217, 1218, 5, 109, 0, 0, 1218, 1285, 3, 166, 83, 40,
		1219, 1285, 3, 170, 85, 0, 1220, 1285, 3, 238, 119, 0, 1221, 1285, 3, 222,
		111, 0, 1222, 1285, 3, 232, 116, 0, 1223, 1285, 5, 225, 0, 0, 1224, 1285,
		5, 231, 0, 0, 1225, 1285, 3, 164, 82, 0, 1226, 1285, 5, 131, 0, 0, 1227,
		1228, 5, 98, 0, 0, 1228, 1229, 5, 212, 0, 0, 1229, 1230, 3, 260, 130, 0,
		1230, 1231, 5, 213, 0, 0, 1231, 1232, 5, 221, 0, 0, 1232, 1233, 3, 166,
		83, 31, 1233, 1285, 1, 0, 0, 0, 1234, 1235, 5, 97, 0, 0, 1235, 1236, 5,
		212, 0, 0, 1236, 1237, 3, 236, 118, 0, 1237, 1238, 5, 213, 0, 0, 1238,
		1285, 1, 0, 0, 0, 1239, 1240, 5, 66, 0, 0, 1240, 1241, 5, 212, 0, 0, 1241,
		1242, 3, 238, 119, 0, 1242, 1243, 5, 213, 0, 0, 1243, 1285, 1, 0, 0, 0,
		1244, 1245, 5, 74, 0, 0, 1245, 1246, 5, 212, 0, 0, 1246, 1247, 3, 166,
		83, 0, 1247, 1248, 5, 213, 0, 0, 1248, 1285, 1, 0, 0, 0, 1249, 1253, 5,
		75, 0, 0, 1250, 1251, 5, 212, 0, 0, 1251, 1254, 5, 213, 0, 0, 1252, 1254,
		3, 164, 82, 0, 1253, 1250, 1, 0, 0, 0, 1253, 1252, 1, 0, 0, 0, 1253, 1254,
		1, 0, 0, 0, 1254, 1285, 1, 0, 0, 0, 1255, 1256, 7, 7, 0, 0, 1256, 1285,
		3, 166, 83, 26, 1257, 1258, 7, 8, 0, 0, 1258, 1285, 3, 166, 83, 25, 1259,
		1285, 3, 178, 89, 0, 1260, 1285, 3, 180, 90, 0, 1261, 1262, 5, 121, 0,
		0, 1262, 1285, 3, 166, 83, 7, 1263, 1264, 3, 172, 86, 0, 1264, 1265, 5,
		221, 0, 0, 1265, 1266, 3, 166, 83, 6, 1266, 1285, 1, 0, 0, 0, 1267, 1268,
		3, 168, 84, 0, 1268, 1270, 3, 186, 93, 0, 1269, 1271, 3, 46, 23, 0, 1270,
		1269, 1, 0, 0, 0, 1270, 1271, 1, 0, 0, 0, 1271, 1272, 1, 0, 0, 0, 1272,
		1273, 3, 166, 83, 5, 1273, 1285, 1, 0, 0, 0, 1274, 1275, 3, 168, 84, 0,
		1275, 1277, 5, 221, 0, 0, 1276, 1278, 3, 46, 23, 0, 1277, 1276, 1, 0, 0,
		0, 1277, 1278, 1, 0, 0, 0, 1278, 1279, 1, 0, 0, 0, 1279, 1282, 5, 198,
		0, 0, 1280, 1283, 3, 238, 119, 0, 1281, 1283, 3, 184, 92, 0, 1282, 1280,
		1, 0, 0, 0, 1282, 1281, 1, 0, 0, 0, 1283, 1285, 1, 0, 0, 0, 1284, 1194,
		1, 0, 0, 0, 1284, 1197, 1, 0, 0, 0, 1284, 1198, 1, 0, 0, 0, 1284, 1203,
		1, 0, 0, 0, 1284, 1208, 1, 0, 0, 0, 1284, 1210, 1, 0, 0, 0, 1284, 1212,
		1, 0, 0, 0, 1284, 1214, 1, 0, 0, 0, 1284, 1217, 1, 0, 0, 0, 1284, 1219,
		1, 0, 0, 0, 1284, 1220, 1, 0, 0, 0, 1284, 1221, 1, 0, 0, 0, 1284, 1222,
		1, 0, 0, 0, 1284, 1223, 1, 0, 0, 0, 1284, 1224, 1, 0, 0, 0, 1284, 1225,
		1, 0, 0, 0, 1284, 1226, 1, 0, 0, 0, 1284, 1227, 1, 0, 0, 0, 1284, 1234,
		1, 0, 0, 0, 1284, 1239, 1, 0, 0, 0, 1284, 1244, 1, 0, 0, 0, 1284, 1249,
		1, 0, 0, 0, 1284, 1255, 1, 0, 0, 0, 1284, 1257, 1, 0, 0, 0, 1284, 1259,
		1, 0, 0, 0, 1284, 1260, 1, 0, 0, 0, 1284, 1261, 1, 0, 0, 0, 1284, 1263,
		1, 0, 0, 0, 1284, 1267, 1, 0, 0, 0, 1284, 1274, 1, 0, 0, 0, 1285, 1346,
		1, 0, 0, 0, 1286, 1287, 10, 22, 0, 0, 1287, 1288, 5, 176, 0, 0, 1288, 1345,
		3, 166, 83, 22, 1289, 1290, 10, 20, 0, 0, 1290, 1291, 7, 9, 0, 0, 1291,
		1345, 3, 166, 83, 21, 1292, 1293, 10, 19, 0, 0, 1293, 1294, 7, 10, 0, 0,
		1294, 1345, 3, 166, 83, 20, 1295, 1296, 10, 18, 0, 0, 1296, 1297, 7, 11,
		0, 0, 1297, 1345, 3, 166, 83, 19, 1298, 1299, 10, 17, 0, 0, 1299, 1300,
		7, 12, 0, 0, 1300, 1345, 3, 166, 83, 18, 1301, 1302, 10, 16, 0, 0, 1302,
		1303, 7, 13, 0, 0, 1303, 1345, 3, 166, 83, 17, 1304, 1305, 10, 15, 0, 0,
		1305, 1306, 5, 198, 0, 0, 1306, 1345, 3, 166, 83, 16, 1307, 1308, 10, 14,
		0, 0, 1308, 1309, 5, 201, 0, 0, 1309, 1345, 3, 166, 83, 15, 1310, 1311,
		10, 13, 0, 0, 1311, 1312, 5, 199, 0, 0, 1312, 1345, 3, 166, 83, 14, 1313,
		1314, 10, 12, 0, 0, 1314, 1315, 5, 187, 0, 0, 1315, 1345, 3, 166, 83, 13,
		1316, 1317, 10, 11, 0, 0, 1317, 1318, 5, 186, 0, 0, 1318, 1345, 3, 166,
		83, 12, 1319, 1320, 10, 10, 0, 0, 1320, 1322, 5, 211, 0, 0, 1321, 1323,
		3, 166, 83, 0, 1322, 1321, 1, 0, 0, 0, 1322, 1323, 1, 0, 0, 0, 1323, 1324,
		1, 0, 0, 0, 1324, 1325, 5, 219, 0, 0, 1325, 1345, 3, 166, 83, 11, 1326,
		1327, 10, 9, 0, 0, 1327, 1328, 5, 188, 0, 0, 1328, 1345, 3, 166, 83, 10,
		1329, 1330, 10, 8, 0, 0, 1330, 1331, 5, 161, 0, 0, 1331, 1345, 3, 166,
		83, 9, 1332, 1333, 10, 3, 0, 0, 1333, 1334, 5, 99, 0, 0, 1334, 1345, 3,
		166, 83, 4, 1335, 1336, 10, 2, 0, 0, 1336, 1337, 5, 101, 0, 0, 1337, 1345,
		3, 166, 83, 3, 1338, 1339, 10, 1, 0, 0, 1339, 1340, 5, 100, 0, 0, 1340,
		1345, 3, 166, 83, 2, 1341, 1342, 10, 21, 0, 0, 1342, 1343, 5, 90, 0, 0,
		1343, 1345, 3, 200, 100, 0, 1344, 1286, 1, 0, 0, 0, 1344, 1289, 1, 0, 0,
		0, 1344, 1292, 1, 0, 0, 0, 1344, 1295, 1, 0, 0, 0, 1344, 1298, 1, 0, 0,
		0, 1344, 1301, 1, 0, 0, 0, 1344, 1304, 1, 0, 0, 0, 1344, 1307, 1, 0, 0,
		0, 1344, 1310, 1, 0, 0, 0, 1344, 1313, 1, 0, 0, 0, 1344, 1316, 1, 0, 0,
		0, 1344, 1319, 1, 0, 0, 0, 1344, 1326, 1, 0, 0, 0, 1344, 1329, 1, 0, 0,
		0, 1344, 1332, 1, 0, 0, 0, 1344, 1335, 1, 0, 0, 0, 1344, 1338, 1, 0, 0,
		0, 1344, 1341, 1, 0, 0, 0, 1345, 1348, 1, 0, 0, 0, 1346, 1344, 1, 0, 0,
		0, 1346, 1347, 1, 0, 0, 0, 1347, 167, 1, 0, 0, 0, 1348, 1346, 1, 0, 0,
		0, 1349, 1352, 3, 238, 119, 0, 1350, 1352, 3, 170, 85, 0, 1351, 1349, 1,
		0, 0, 0, 1351, 1350, 1, 0, 0, 0, 1352, 169, 1, 0, 0, 0, 1353, 1354, 5,
		45, 0, 0, 1354, 1356, 5, 212, 0, 0, 1355, 1357, 3, 190, 95, 0, 1356, 1355,
		1, 0, 0, 0, 1356, 1357, 1, 0, 0, 0, 1357, 1358, 1, 0, 0, 0, 1358, 1365,
		5, 213, 0, 0, 1359, 1361, 5, 214, 0, 0, 1360, 1362, 3, 190, 95, 0, 1361,
		1360, 1, 0, 0, 0, 1361, 1362, 1, 0, 0, 0, 1362, 1363, 1, 0, 0, 0, 1363,
		1365, 5, 215, 0, 0, 1364, 1353, 1, 0, 0, 0, 1364, 1359, 1, 0, 0, 0, 1365,
		1370, 1, 0, 0, 0, 1366, 1367, 5, 214, 0, 0, 1367, 1368, 3, 166, 83, 0,
		1368, 1369, 5, 215, 0, 0, 1369, 1371, 1, 0, 0, 0, 1370, 1366, 1, 0, 0,
		0, 1370, 1371, 1, 0, 0, 0, 1371, 171, 1, 0, 0, 0, 1372, 1376, 5, 214, 0,
		0, 1373, 1375, 5, 218, 0, 0, 1374, 1373, 1, 0, 0, 0, 1375, 1378, 1, 0,
		0, 0, 1376, 1374, 1, 0, 0, 0, 1376, 1377, 1, 0, 0, 0, 1377, 1379, 1, 0,
		0, 0, 1378, 1376, 1, 0, 0, 0, 1379, 1388, 3, 174, 87, 0, 1380, 1382, 5,
		218, 0, 0, 1381, 1380, 1, 0, 0, 0, 1382, 1383, 1, 0, 0, 0, 1383, 1381,
		1, 0, 0, 0, 1383, 1384, 1, 0, 0, 0, 1384, 1385, 1, 0, 0, 0, 1385, 1387,
		3, 174, 87, 0, 1386, 1381, 1, 0, 0, 0, 1387, 1390, 1, 0, 0, 0, 1388, 1386,
		1, 0, 0, 0, 1388, 1389, 1, 0, 0, 0, 1389, 1394, 1, 0, 0, 0, 1390, 1388,
		1, 0, 0, 0, 1391, 1393, 5, 218, 0, 0, 1392, 1391, 1, 0, 0, 0, 1393, 1396,
		1, 0, 0, 0, 1394, 1392, 1, 0, 0, 0, 1394, 1395, 1, 0, 0, 0, 1395, 1397,
		1, 0, 0, 0, 1396, 1394, 1, 0, 0, 0, 1397, 1398, 5, 215, 0, 0, 1398, 1418,
		1, 0, 0, 0, 1399, 1400, 5, 214, 0, 0, 1400, 1409, 3, 176, 88, 0, 1401,
		1403, 5, 218, 0, 0, 1402, 1401, 1, 0, 0, 0, 1403, 1404, 1, 0, 0, 0, 1404,
		1402, 1, 0, 0, 0, 1404, 1405, 1, 0, 0, 0, 1405, 1406, 1, 0, 0, 0, 1406,
		1408, 3, 176, 88, 0, 1407, 1402, 1, 0, 0, 0, 1408, 1411, 1, 0, 0, 0, 1409,
		1407, 1, 0, 0, 0, 1409, 1410, 1, 0, 0, 0, 1410, 1413, 1, 0, 0, 0, 1411,
		1409, 1, 0, 0, 0, 1412, 1414, 5, 218, 0, 0, 1413, 1412, 1, 0, 0, 0, 1413,
		1414, 1, 0, 0, 0, 1414, 1415, 1, 0, 0, 0, 1415, 1416, 5, 215, 0, 0, 1416,
		1418, 1, 0, 0, 0, 1417, 1372, 1, 0, 0, 0, 1417, 1399, 1, 0, 0, 0, 1418,
		173, 1, 0, 0, 0, 1419, 1421, 5, 198, 0, 0, 1420, 1419, 1, 0, 0, 0, 1420,
		1421, 1, 0, 0, 0, 1421, 1422, 1, 0, 0, 0, 1422, 1423, 3, 238, 119, 0, 1423,
		175, 1, 0, 0, 0, 1424, 1425, 3, 166, 83, 0, 1425, 1426, 5, 164, 0, 0, 1426,
		1428, 1, 0, 0, 0, 1427, 1424, 1, 0, 0, 0, 1427, 1428, 1, 0, 0, 0, 1428,
		1430, 1, 0, 0, 0, 1429, 1431, 5, 198, 0, 0, 1430, 1429, 1, 0, 0, 0, 1430,
		1431, 1, 0, 0, 0, 1431, 1432, 1, 0, 0, 0, 1432, 1433, 3, 238, 119, 0, 1433,
		177, 1, 0, 0, 0, 1434, 1436, 5, 118, 0, 0, 1435, 1434, 1, 0, 0, 0, 1435,
		1436, 1, 0, 0, 0, 1436, 1437, 1, 0, 0, 0, 1437, 1439, 5, 82, 0, 0, 1438,
		1440, 5, 198, 0, 0, 1439, 1438, 1, 0, 0, 0, 1439, 1440, 1, 0, 0, 0, 1440,
		1441, 1, 0, 0, 0, 1441, 1442, 5, 212, 0, 0, 1442, 1443, 3, 116, 58, 0,
		1443, 1445, 5, 213, 0, 0, 1444, 1446, 3, 194, 97, 0, 1445, 1444, 1, 0,
		0, 0, 1445, 1446, 1, 0, 0, 0, 1446, 1449, 1, 0, 0, 0, 1447, 1448, 5, 219,
		0, 0, 1448, 1450, 3, 120, 60, 0, 1449, 1447, 1, 0, 0, 0, 1449, 1450, 1,
		0, 0, 0, 1450, 1451, 1, 0, 0, 0, 1451, 1452, 3, 60, 30, 0, 1452, 1461,
		1, 0, 0, 0, 1453, 1454, 5, 133, 0, 0, 1454, 1455, 5, 212, 0, 0, 1455, 1456,
		3, 116, 58, 0, 1456, 1457, 5, 213, 0, 0, 1457, 1458, 5, 164, 0, 0, 1458,
		1459, 3, 166, 83, 0, 1459, 1461, 1, 0, 0, 0, 1460, 1435, 1, 0, 0, 0, 1460,
		1453, 1, 0, 0, 0, 1461, 179, 1, 0, 0, 0, 1462, 1463, 5, 102, 0, 0, 1463,
		1464, 5, 212, 0, 0, 1464, 1465, 3, 166, 83, 0, 1465, 1466, 5, 213, 0, 0,
		1466, 1467, 5, 216, 0, 0, 1467, 1472, 3, 182, 91, 0, 1468, 1469, 5, 218,
		0, 0, 1469, 1471, 3, 182, 91, 0, 1470, 1468, 1, 0, 0, 0, 1471, 1474, 1,
		0, 0, 0, 1472, 1470, 1, 0, 0, 0, 1472, 1473, 1, 0, 0, 0, 1473, 1476, 1,
		0, 0, 0, 1474, 1472, 1, 0, 0, 0, 1475, 1477, 5, 218, 0, 0, 1476, 1475,
		1, 0, 0, 0, 1476, 1477, 1, 0, 0, 0, 1477, 1478, 1, 0, 0, 0, 1478, 1479,
		5, 217, 0, 0, 1479, 181, 1, 0, 0, 0, 1480, 1485, 3, 166, 83, 0, 1481, 1482,
		5, 218, 0, 0, 1482, 1484, 3, 166, 83, 0, 1483, 1481, 1, 0, 0, 0, 1484,
		1487, 1, 0, 0, 0, 1485, 1483, 1, 0, 0, 0, 1485, 1486, 1, 0, 0, 0, 1486,
		1488, 1, 0, 0, 0, 1487, 1485, 1, 0, 0, 0, 1488, 1489, 5, 164, 0, 0, 1489,
		1490, 3, 166, 83, 0, 1490, 183, 1, 0, 0, 0, 1491, 1492, 5, 104, 0, 0, 1492,
		1494, 3, 200, 100, 0, 1493, 1495, 3, 214, 107, 0, 1494, 1493, 1, 0, 0,
		0, 1494, 1495, 1, 0, 0, 0, 1495, 185, 1, 0, 0, 0, 1496, 1497, 7, 14, 0,
		0, 1497, 187, 1, 0, 0, 0, 1498, 1506, 5, 131, 0, 0, 1499, 1502, 3, 166,
		83, 0, 1500, 1501, 5, 164, 0, 0, 1501, 1503, 3, 166, 83, 0, 1502, 1500,
		1, 0, 0, 0, 1502, 1503, 1, 0, 0, 0, 1503, 1507, 1, 0, 0, 0, 1504, 1505,
		5, 132, 0, 0, 1505, 1507, 3, 166, 83, 0, 1506, 1499, 1, 0, 0, 0, 1506,
		1504, 1, 0, 0, 0, 1507, 189, 1, 0, 0, 0, 1508, 1513, 3, 192, 96, 0, 1509,
		1510, 5, 218, 0, 0, 1510, 1512, 3, 192, 96, 0, 1511, 1509, 1, 0, 0, 0,
		1512, 1515, 1, 0, 0, 0, 1513, 1511, 1, 0, 0, 0, 1513, 1514, 1, 0, 0, 0,
		1514, 1517, 1, 0, 0, 0, 1515, 1513, 1, 0, 0, 0, 1516, 1518, 5, 218, 0,
		0, 1517, 1516, 1, 0, 0, 0, 1517, 1518, 1, 0, 0, 0, 1518, 191, 1, 0, 0,
		0, 1519, 1522, 3, 166, 83, 0, 1520, 1521, 5, 164, 0, 0, 1521, 1523, 3,
		166, 83, 0, 1522, 1520, 1, 0, 0, 0, 1522, 1523, 1, 0, 0, 0, 1523, 1532,
		1, 0, 0, 0, 1524, 1525, 3, 166, 83, 0, 1525, 1526, 5, 164, 0, 0, 1526,
		1528, 1, 0, 0, 0, 1527, 1524, 1, 0, 0, 0, 1527, 1528, 1, 0, 0, 0, 1528,
		1529, 1, 0, 0, 0, 1529, 1530, 5, 198, 0, 0, 1530, 1532, 3, 238, 119, 0,
		1531, 1519, 1, 0, 0, 0, 1531, 1527, 1, 0, 0, 0, 1532, 193, 1, 0, 0, 0,
		1533, 1534, 5, 128, 0, 0, 1534, 1535, 5, 212, 0, 0, 1535, 1540, 3, 196,
		98, 0, 1536, 1537, 5, 218, 0, 0, 1537, 1539, 3, 196, 98, 0, 1538, 1536,
		1, 0, 0, 0, 1539, 1542, 1, 0, 0, 0, 1540, 1538, 1, 0, 0, 0, 1540, 1541,
		1, 0, 0, 0, 1541, 1543, 1, 0, 0, 0, 1542, 1540, 1, 0, 0, 0, 1543, 1544,
		5, 213, 0, 0, 1544, 195, 1, 0, 0, 0, 1545, 1547, 5, 198, 0, 0, 1546, 1545,
		1, 0, 0, 0, 1546, 1547, 1, 0, 0, 0, 1547, 1548, 1, 0, 0, 0, 1548, 1549,
		5, 224, 0, 0, 1549, 197, 1, 0, 0, 0, 1550, 1552, 3, 206, 103, 0, 1551,
		1553, 3, 44, 22, 0, 1552, 1551, 1, 0, 0, 0, 1552, 1553, 1, 0, 0, 0, 1553,
		1556, 1, 0, 0, 0, 1554, 1556, 5, 118, 0, 0, 1555, 1550, 1, 0, 0, 0, 1555,
		1554, 1, 0, 0, 0, 1556, 199, 1, 0, 0, 0, 1557, 1560, 3, 206, 103, 0, 1558,
		1560, 3, 204, 102, 0, 1559, 1557, 1, 0, 0, 0, 1559, 1558, 1, 0, 0, 0, 1560,
		1562, 1, 0, 0, 0, 1561, 1563, 3, 44, 22, 0, 1562, 1561, 1, 0, 0, 0, 1562,
		1563, 1, 0, 0, 0, 1563, 1568, 1, 0, 0, 0, 1564, 1568, 3, 274, 137, 0, 1565,
		1568, 5, 118, 0, 0, 1566, 1568, 3, 202, 101, 0, 1567, 1559, 1, 0, 0, 0,
		1567, 1564, 1, 0, 0, 0, 1567, 1565, 1, 0, 0, 0, 1567, 1566, 1, 0, 0, 0,
		1568, 201, 1, 0, 0, 0, 1569, 1571, 3, 46, 23, 0, 1570, 1569, 1, 0, 0, 0,
		1570, 1571, 1, 0, 0, 0, 1571, 1573, 1, 0, 0, 0, 1572, 1574, 5, 110, 0,
		0, 1573, 1572, 1, 0, 0, 0, 1573, 1574, 1, 0, 0, 0, 1574, 1576, 1, 0, 0,
		0, 1575, 1577, 3, 264, 132, 0, 1576, 1575, 1, 0, 0, 0, 1576, 1577, 1, 0,
		0, 0, 1577, 1579, 1, 0, 0, 0, 1578, 1580, 5, 108, 0, 0, 1579, 1578, 1,
		0, 0, 0, 1579, 1580, 1, 0, 0, 0, 1580, 1602, 1, 0, 0, 0, 1581, 1583, 3,
		30, 15, 0, 1582, 1584, 3, 34, 17, 0, 1583, 1582, 1, 0, 0, 0, 1583, 1584,
		1, 0, 0, 0, 1584, 1587, 1, 0, 0, 0, 1585, 1586, 5, 76, 0, 0, 1586, 1588,
		3, 198, 99, 0, 1587, 1585, 1, 0, 0, 0, 1587, 1588, 1, 0, 0, 0, 1588, 1591,
		1, 0, 0, 0, 1589, 1590, 5, 86, 0, 0, 1590, 1592, 3, 32, 16, 0, 1591, 1589,
		1, 0, 0, 0, 1591, 1592, 1, 0, 0, 0, 1592, 1603, 1, 0, 0, 0, 1593, 1594,
		5, 96, 0, 0, 1594, 1596, 3, 266, 133, 0, 1595, 1597, 3, 34, 17, 0, 1596,
		1595, 1, 0, 0, 0, 1596, 1597, 1, 0, 0, 0, 1597, 1600, 1, 0, 0, 0, 1598,
		1599, 5, 76, 0, 0, 1599, 1601, 3, 32, 16, 0, 1600, 1598, 1, 0, 0, 0, 1600,
		1601, 1, 0, 0, 0, 1601, 1603, 1, 0, 0, 0, 1602, 1581, 1, 0, 0, 0, 1602,
		1593, 1, 0, 0, 0, 1603, 1604, 1, 0, 0, 0, 1604, 1608, 5, 216, 0, 0, 1605,
		1607, 3, 130, 65, 0, 1606, 1605, 1, 0, 0, 0, 1607, 1610, 1, 0, 0, 0, 1608,
		1606, 1, 0, 0, 0, 1608, 1609, 1, 0, 0, 0, 1609, 1611, 1, 0, 0, 0, 1610,
		1608, 1, 0, 0, 0, 1611, 1612, 5, 217, 0, 0, 1612, 203, 1, 0, 0, 0, 1613,
		1618, 3, 250, 125, 0, 1614, 1615, 5, 193, 0, 0, 1615, 1617, 3, 252, 126,
		0, 1616, 1614, 1, 0, 0, 0, 1617, 1620, 1, 0, 0, 0, 1618, 1616, 1, 0, 0,
		0, 1618, 1619, 1, 0, 0, 0, 1619, 205, 1, 0, 0, 0, 1620, 1618, 1, 0, 0,
		0, 1621, 1623, 5, 103, 0, 0, 1622, 1621, 1, 0, 0, 0, 1622, 1623, 1, 0,
		0, 0, 1623, 1625, 1, 0, 0, 0, 1624, 1626, 5, 194, 0, 0, 1625, 1624, 1,
		0, 0, 0, 1625, 1626, 1, 0, 0, 0, 1626, 1627, 1, 0, 0, 0, 1627, 1628, 3,
		208, 104, 0, 1628, 207, 1, 0, 0, 0, 1629, 1643, 3, 266, 133, 0, 1630, 1635,
		3, 266, 133, 0, 1631, 1632, 5, 194, 0, 0, 1632, 1634, 3, 266, 133, 0, 1633,
		1631, 1, 0, 0, 0, 1634, 1637, 1, 0, 0, 0, 1635, 1633, 1, 0, 0, 0, 1635,
		1636, 1, 0, 0, 0, 1636, 1640, 1, 0, 0, 0, 1637, 1635, 1, 0, 0, 0, 1638,
		1639, 5, 194, 0, 0, 1639, 1641, 3, 210, 105, 0, 1640, 1638, 1, 0, 0, 0,
		1640, 1641, 1, 0, 0, 0, 1641, 1643, 1, 0, 0, 0, 1642, 1629, 1, 0, 0, 0,
		1642, 1630, 1, 0, 0, 0, 1643, 209, 1, 0, 0, 0, 1644, 1647, 3, 266, 133,
		0, 1645, 1646, 5, 46, 0, 0, 1646, 1648, 3, 266, 133, 0, 1647, 1645, 1,
		0, 0, 0, 1647, 1648, 1, 0, 0, 0, 1648, 1664, 1, 0, 0, 0, 1649, 1650, 5,
		216, 0, 0, 1650, 1655, 3, 210, 105, 0, 1651, 1652, 5, 218, 0, 0, 1652,
		1654, 3, 210, 105, 0, 1653, 1651, 1, 0, 0, 0, 1654, 1657, 1, 0, 0, 0, 1655,
		1653, 1, 0, 0, 0, 1655, 1656, 1, 0, 0, 0, 1656, 1659, 1, 0, 0, 0, 1657,
		1655, 1, 0, 0, 0, 1658, 1660, 5, 218, 0, 0, 1659, 1658, 1, 0, 0, 0, 1659,
		1660, 1, 0, 0, 0, 1660, 1661, 1, 0, 0, 0, 1661, 1662, 5, 217, 0, 0, 1662,
		1664, 1, 0, 0, 0, 1663, 1644, 1, 0, 0, 0, 1663, 1649, 1, 0, 0, 0, 1664,
		211, 1, 0, 0, 0, 1665, 1670, 3, 206, 103, 0, 1666, 1667, 5, 218, 0, 0,
		1667, 1669, 3, 206, 103, 0, 1668, 1666, 1, 0, 0, 0, 1669, 1672, 1, 0, 0,
		0, 1670, 1668, 1, 0, 0, 0, 1670, 1671, 1, 0, 0, 0, 1671, 213, 1, 0, 0,
		0, 1672, 1670, 1, 0, 0, 0, 1673, 1683, 5, 212, 0, 0, 1674, 1679, 3, 216,
		108, 0, 1675, 1676, 5, 218, 0, 0, 1676, 1678, 3, 216, 108, 0, 1677, 1675,
		1, 0, 0, 0, 1678, 1681, 1, 0, 0, 0, 1679, 1677, 1, 0, 0, 0, 1679, 1680,
		1, 0, 0, 0, 1680, 1684, 1, 0, 0, 0, 1681, 1679, 1, 0, 0, 0, 1682, 1684,
		3, 188, 94, 0, 1683, 1674, 1, 0, 0, 0, 1683, 1682, 1, 0, 0, 0, 1683, 1684,
		1, 0, 0, 0, 1684, 1686, 1, 0, 0, 0, 1685, 1687, 5, 218, 0, 0, 1686, 1685,
		1, 0, 0, 0, 1686, 1687, 1, 0, 0, 0, 1687, 1688, 1, 0, 0, 0, 1688, 1689,
		5, 213, 0, 0, 1689, 215, 1, 0, 0, 0, 1690, 1692, 3, 218, 109, 0, 1691,
		1690, 1, 0, 0, 0, 1691, 1692, 1, 0, 0, 0, 1692, 1694, 1, 0, 0, 0, 1693,
		1695, 5, 195, 0, 0, 1694, 1693, 1, 0, 0, 0, 1694, 1695, 1, 0, 0, 0, 1695,
		1696, 1, 0, 0, 0, 1696, 1700, 3, 166, 83, 0, 1697, 1698, 5, 198, 0, 0,
		1698, 1700, 3, 238, 119, 0, 1699, 1691, 1, 0, 0, 0, 1699, 1697, 1, 0, 0,
		0, 1700, 217, 1, 0, 0, 0, 1701, 1702, 3, 266, 133, 0, 1702, 1703, 5, 219,
		0, 0, 1703, 219, 1, 0, 0, 0, 1704, 1740, 3, 222, 111, 0, 1705, 1740, 3,
		232, 116, 0, 1706, 1707, 5, 45, 0, 0, 1707, 1712, 5, 212, 0, 0, 1708, 1710,
		3, 190, 95, 0, 1709, 1711, 5, 218, 0, 0, 1710, 1709, 1, 0, 0, 0, 1710,
		1711, 1, 0, 0, 0, 1711, 1713, 1, 0, 0, 0, 1712, 1708, 1, 0, 0, 0, 1712,
		1713, 1, 0, 0, 0, 1713, 1714, 1, 0, 0, 0, 1714, 1740, 5, 213, 0, 0, 1715,
		1720, 5, 214, 0, 0, 1716, 1718, 3, 190, 95, 0, 1717, 1719, 5, 218, 0, 0,
		1718, 1717, 1, 0, 0, 0, 1718, 1719, 1, 0, 0, 0, 1719, 1721, 1, 0, 0, 0,
		1720, 1716, 1, 0, 0, 0, 1720, 1721, 1, 0, 0, 0, 1721, 1722, 1, 0, 0, 0,
		1722, 1740, 5, 215, 0, 0, 1723, 1724, 7, 15, 0, 0, 1724, 1740, 3, 220,
		110, 0, 1725, 1728, 3, 232, 116, 0, 1726, 1728, 3, 222, 111, 0, 1727, 1725,
		1, 0, 0, 0, 1727, 1726, 1, 0, 0, 0, 1728, 1736, 1, 0, 0, 0, 1729, 1732,
		5, 210, 0, 0, 1730, 1733, 3, 232, 116, 0, 1731, 1733, 3, 222, 111, 0, 1732,
		1730, 1, 0, 0, 0, 1732, 1731, 1, 0, 0, 0, 1733, 1735, 1, 0, 0, 0, 1734,
		1729, 1, 0, 0, 0, 1735, 1738, 1, 0, 0, 0, 1736, 1734, 1, 0, 0, 0, 1736,
		1737, 1, 0, 0, 0, 1737, 1740, 1, 0, 0, 0, 1738, 1736, 1, 0, 0, 0, 1739,
		1704, 1, 0, 0, 0, 1739, 1705, 1, 0, 0, 0, 1739, 1706, 1, 0, 0, 0, 1739,
		1715, 1, 0, 0, 0, 1739, 1723, 1, 0, 0, 0, 1739, 1727, 1, 0, 0, 0, 1740,
		221, 1, 0, 0, 0, 1741, 1747, 5, 105, 0, 0, 1742, 1747, 3, 224, 112, 0,
		1743, 1747, 3, 270, 135, 0, 1744, 1747, 3, 228, 114, 0, 1745, 1747, 3,
		206, 103, 0, 1746, 1741, 1, 0, 0, 0, 1746, 1742, 1, 0, 0, 0, 1746, 1743,
		1, 0, 0, 0, 1746, 1744, 1, 0, 0, 0, 1746, 1745, 1, 0, 0, 0, 1747, 223,
		1, 0, 0, 0, 1748, 1753, 5, 228, 0, 0, 1749, 1753, 5, 49, 0, 0, 1750, 1753,
		3, 226, 113, 0, 1751, 1753, 3, 230, 115, 0, 1752, 1748, 1, 0, 0, 0, 1752,
		1749, 1, 0, 0, 0, 1752, 1750, 1, 0, 0, 0, 1752, 1751, 1, 0, 0, 0, 1753,
		225, 1, 0, 0, 0, 1754, 1755, 7, 16, 0, 0, 1755, 227, 1, 0, 0, 0, 1756,
		1757, 7, 17, 0, 0, 1757, 1762, 5, 192, 0, 0, 1758, 1763, 3, 266, 133, 0,
		1759, 1763, 5, 141, 0, 0, 1760, 1763, 5, 137, 0, 0, 1761, 1763, 5, 138,
		0, 0, 1762, 1758, 1, 0, 0, 0, 1762, 1759, 1, 0, 0, 0, 1762, 1760, 1, 0,
		0, 0, 1762, 1761, 1, 0, 0, 0, 1763, 1775, 1, 0, 0, 0, 1764, 1768, 3, 198,
		99, 0, 1765, 1768, 3, 256, 128, 0, 1766, 1768, 3, 232, 116, 0, 1767, 1764,
		1, 0, 0, 0, 1767, 1765, 1, 0, 0, 0, 1767, 1766, 1, 0, 0, 0, 1768, 1769,
		1, 0, 0, 0, 1769, 1772, 5, 192, 0, 0, 1770, 1773, 3, 266, 133, 0, 1771,
		1773, 3, 256, 128, 0, 1772, 1770, 1, 0, 0, 0, 1772, 1771, 1, 0, 0, 0, 1773,
		1775, 1, 0, 0, 0, 1774, 1756, 1, 0, 0, 0, 1774, 1767, 1, 0, 0, 0, 1775,
		229, 1, 0, 0, 0, 1776, 1777, 5, 225, 0, 0, 1777, 231, 1, 0, 0, 0, 1778,
		1780, 5, 235, 0, 0, 1779, 1781, 5, 243, 0, 0, 1780, 1779, 1, 0, 0, 0, 1781,
		1782, 1, 0, 0, 0, 1782, 1780, 1, 0, 0, 0, 1782, 1783, 1, 0, 0, 0, 1783,
		1800, 1, 0, 0, 0, 1784, 1786, 5, 234, 0, 0, 1785, 1787, 5, 243, 0, 0, 1786,
		1785, 1, 0, 0, 0, 1787, 1788, 1, 0, 0, 0, 1788, 1786, 1, 0, 0, 0, 1788,
		1789, 1, 0, 0, 0, 1789, 1800, 1, 0, 0, 0, 1790, 1800, 5, 232, 0, 0, 1791,
		1795, 5, 233, 0, 0, 1792, 1794, 3, 234, 117, 0, 1793, 1792, 1, 0, 0, 0,
		1794, 1797, 1, 0, 0, 0, 1795, 1793, 1, 0, 0, 0, 1795, 1796, 1, 0, 0, 0,
		1796, 1798, 1, 0, 0, 0, 1797, 1795, 1, 0, 0, 0, 1798, 1800, 5, 233, 0,
		0, 1799, 1778, 1, 0, 0, 0, 1799, 1784, 1, 0, 0, 0, 1799, 1790, 1, 0, 0,
		0, 1799, 1791, 1, 0, 0, 0, 1800, 233, 1, 0, 0, 0, 1801, 1805, 5, 239, 0,
		0, 1802, 1805, 5, 238, 0, 0, 1803, 1805, 3, 238, 119, 0, 1804, 1801, 1,
		0, 0, 0, 1804, 1802, 1, 0, 0, 0, 1804, 1803, 1, 0, 0, 0, 1805, 235, 1,
		0, 0, 0, 1806, 1811, 3, 238, 119, 0, 1807, 1808, 5, 218, 0, 0, 1808, 1810,
		3, 238, 119, 0, 1809, 1807, 1, 0, 0, 0, 1810, 1813, 1, 0, 0, 0, 1811, 1809,
		1, 0, 0, 0, 1811, 1812, 1, 0, 0, 0, 1812, 237, 1, 0, 0, 0, 1813, 1811,
		1, 0, 0, 0, 1814, 1818, 3, 240, 120, 0, 1815, 1817, 3, 242, 121, 0, 1816,
		1815, 1, 0, 0, 0, 1817, 1820, 1, 0, 0, 0, 1818, 1816, 1, 0, 0, 0, 1818,
		1819, 1, 0, 0, 0, 1819, 239, 1, 0, 0, 0, 1820, 1818, 1, 0, 0, 0, 1821,
		1828, 3, 250, 125, 0, 1822, 1828, 3, 244, 122, 0, 1823, 1824, 5, 212, 0,
		0, 1824, 1825, 3, 184, 92, 0, 1825, 1826, 5, 213, 0, 0, 1826, 1828, 1,
		0, 0, 0, 1827, 1821, 1, 0, 0, 0, 1827, 1822, 1, 0, 0, 0, 1827, 1823, 1,
		0, 0, 0, 1828, 241, 1, 0, 0, 0, 1829, 1830, 5, 193, 0, 0, 1830, 1832, 3,
		252, 126, 0, 1831, 1833, 3, 248, 124, 0, 1832, 1831, 1, 0, 0, 0, 1832,
		1833, 1, 0, 0, 0, 1833, 243, 1, 0, 0, 0, 1834, 1835, 3, 246, 123, 0, 1835,
		1836, 3, 248, 124, 0, 1836, 245, 1, 0, 0, 0, 1837, 1842, 3, 206, 103, 0,
		1838, 1842, 3, 228, 114, 0, 1839, 1842, 3, 250, 125, 0, 1840, 1842, 3,
		164, 82, 0, 1841, 1837, 1, 0, 0, 0, 1841, 1838, 1, 0, 0, 0, 1841, 1839,
		1, 0, 0, 0, 1841, 1840, 1, 0, 0, 0, 1842, 247, 1, 0, 0, 0, 1843, 1845,
		3, 44, 22, 0, 1844, 1843, 1, 0, 0, 0, 1844, 1845, 1, 0, 0, 0, 1845, 1847,
		1, 0, 0, 0, 1846, 1848, 3, 214, 107, 0, 1847, 1846, 1, 0, 0, 0, 1848, 1849,
		1, 0, 0, 0, 1849, 1847, 1, 0, 0, 0, 1849, 1850, 1, 0, 0, 0, 1850, 1854,
		1, 0, 0, 0, 1851, 1853, 3, 258, 129, 0, 1852, 1851, 1, 0, 0, 0, 1853, 1856,
		1, 0, 0, 0, 1854, 1852, 1, 0, 0, 0, 1854, 1855, 1, 0, 0, 0, 1855, 249,
		1, 0, 0, 0, 1856, 1854, 1, 0, 0, 0, 1857, 1860, 3, 256, 128, 0, 1858, 1859,
		5, 192, 0, 0, 1859, 1861, 3, 256, 128, 0, 1860, 1858, 1, 0, 0, 0, 1860,
		1861, 1, 0, 0, 0, 1861, 1867, 1, 0, 0, 0, 1862, 1863, 3, 198, 99, 0, 1863,
		1864, 5, 192, 0, 0, 1864, 1865, 3, 256, 128, 0, 1865, 1867, 1, 0, 0, 0,
		1866, 1857, 1, 0, 0, 0, 1866, 1862, 1, 0, 0, 0, 1867, 251, 1, 0, 0, 0,
		1868, 1871, 3, 254, 127, 0, 1869, 1871, 3, 256, 128, 0, 1870, 1868, 1,
		0, 0, 0, 1870, 1869, 1, 0, 0, 0, 1871, 253, 1, 0, 0, 0, 1872, 1878, 3,
		266, 133, 0, 1873, 1874, 5, 216, 0, 0, 1874, 1875, 3, 166, 83, 0, 1875,
		1876, 5, 217, 0, 0, 1876, 1878, 1, 0, 0, 0, 1877, 1872, 1, 0, 0, 0, 1877,
		1873, 1, 0, 0, 0, 1878, 1882, 1, 0, 0, 0, 1879, 1881, 3, 258, 129, 0, 1880,
		1879, 1, 0, 0, 0, 1881, 1884, 1, 0, 0, 0, 1882, 1880, 1, 0, 0, 0, 1882,
		1883, 1, 0, 0, 0, 1883, 255, 1, 0, 0, 0, 1884, 1882, 1, 0, 0, 0, 1885,
		1887, 5, 209, 0, 0, 1886, 1885, 1, 0, 0, 0, 1887, 1890, 1, 0, 0, 0, 1888,
		1886, 1, 0, 0, 0, 1888, 1889, 1, 0, 0, 0, 1889, 1897, 1, 0, 0, 0, 1890,
		1888, 1, 0, 0, 0, 1891, 1898, 5, 224, 0, 0, 1892, 1893, 5, 209, 0, 0, 1893,
		1894, 5, 216, 0, 0, 1894, 1895, 3, 166, 83, 0, 1895, 1896, 5, 217, 0, 0,
		1896, 1898, 1, 0, 0, 0, 1897, 1891, 1, 0, 0, 0, 1897, 1892, 1, 0, 0, 0,
		1898, 1902, 1, 0, 0, 0, 1899, 1901, 3, 258, 129, 0, 1900, 1899, 1, 0, 0,
		0, 1901, 1904, 1, 0, 0, 0, 1902, 1900, 1, 0, 0, 0, 1902, 1903, 1, 0, 0,
		0, 1903, 257, 1, 0, 0, 0, 1904, 1902, 1, 0, 0, 0, 1905, 1907, 5, 214, 0,
		0, 1906, 1908, 3, 166, 83, 0, 1907, 1906, 1, 0, 0, 0, 1907, 1908, 1, 0,
		0, 0, 1908, 1909, 1, 0, 0, 0, 1909, 1915, 5, 215, 0, 0, 1910, 1911, 5,
		216, 0, 0, 1911, 1912, 3, 166, 83, 0, 1912, 1913, 5, 217, 0, 0, 1913, 1915,
		1, 0, 0, 0, 1914, 1905, 1, 0, 0, 0, 1914, 1910, 1, 0, 0, 0, 1915, 259,
		1, 0, 0, 0, 1916, 1918, 3, 262, 131, 0, 1917, 1916, 1, 0, 0, 0, 1917, 1918,
		1, 0, 0, 0, 1918, 1925, 1, 0, 0, 0, 1919, 1921, 5, 218, 0, 0, 1920, 1922,
		3, 262, 131, 0, 1921, 1920, 1, 0, 0, 0, 1921, 1922, 1, 0, 0, 0, 1922, 1924,
		1, 0, 0, 0, 1923, 1919, 1, 0, 0, 0, 1924, 1927, 1, 0, 0, 0, 1925, 1923,
		1, 0, 0, 0, 1925, 1926, 1, 0, 0, 0, 1926, 261, 1, 0, 0, 0, 1927, 1925,
		1, 0, 0, 0, 1928, 1936, 3, 238, 119, 0, 1929, 1930, 5, 98, 0, 0, 1930,
		1931, 5, 212, 0, 0, 1931, 1932, 3, 260, 130, 0, 1932, 1933, 5, 213, 0,
		0, 1933, 1936, 1, 0, 0, 0, 1934, 1936, 3, 192, 96, 0, 1935, 1928, 1, 0,
		0, 0, 1935, 1929, 1, 0, 0, 0, 1935, 1934, 1, 0, 0, 0, 1936, 263, 1, 0,
		0, 0, 1937, 1938, 7, 18, 0, 0, 1938, 265, 1, 0, 0, 0, 1939, 1940, 7, 19,
		0, 0, 1940, 267, 1, 0, 0, 0, 1941, 1942, 7, 20, 0, 0, 1942, 269, 1, 0,
		0, 0, 1943, 1944, 7, 21, 0, 0, 1944, 271, 1, 0, 0, 0, 1945, 1946, 7, 22,
		0, 0, 1946, 273, 1, 0, 0, 0, 1947, 1948, 7, 23, 0, 0, 1948, 275, 1, 0,
		0, 0, 1949, 1950, 7, 24, 0, 0, 1950, 277, 1, 0, 0, 0, 252, 279, 284, 291,
		296, 299, 325, 329, 334, 339, 345, 359, 363, 369, 374, 379, 386, 392, 399,
		406, 409, 413, 417, 424, 427, 432, 435, 438, 441, 446, 450, 454, 459, 463,
		465, 471, 483, 500, 507, 515, 519, 524, 530, 538, 546, 552, 559, 566, 571,
		577, 606, 620, 624, 633, 637, 642, 668, 679, 683, 687, 696, 706, 711, 717,
		722, 727, 732, 737, 743, 749, 755, 779, 784, 787, 797, 800, 813, 821, 828,
		831, 836, 840, 849, 853, 879, 884, 891, 898, 906, 909, 915, 919, 922, 927,
		931, 934, 937, 940, 948, 955, 964, 977, 989, 995, 999, 1006, 1012, 1016,
		1023, 1030, 1034, 1041, 1045, 1047, 1053, 1060, 1064, 1068, 1081, 1084,
		1091, 1098, 1102, 1108, 1112, 1117, 1122, 1129, 1137, 1146, 1150, 1156,
		1165, 1170, 1177, 1184, 1190, 1253, 1270, 1277, 1282, 1284, 1322, 1344,
		1346, 1351, 1356, 1361, 1364, 1370, 1376, 1383, 1388, 1394, 1404, 1409,
		1413, 1417, 1420, 1427, 1430, 1435, 1439, 1445, 1449, 1460, 1472, 1476,
		1485, 1494, 1502, 1506, 1513, 1517, 1522, 1527, 1531, 1540, 1546, 1552,
		1555, 1559, 1562, 1567, 1570, 1573, 1576, 1579, 1583, 1587, 1591, 1596,
		1600, 1602, 1608, 1618, 1622, 1625, 1635, 1640, 1642, 1647, 1655, 1659,
		1663, 1670, 1679, 1683, 1686, 1691, 1694, 1699, 1710, 1712, 1718, 1720,
		1727, 1732, 1736, 1739, 1746, 1752, 1762, 1767, 1772, 1774, 1782, 1788,
		1795, 1799, 1804, 1811, 1818, 1827, 1832, 1841, 1844, 1849, 1854, 1860,
		1866, 1870, 1877, 1882, 1888, 1897, 1902, 1907, 1914, 1917, 1921, 1925,
		1935,
	}
	deserializer := antlr.NewATNDeserializer(nil)
	staticData.atn = deserializer.Deserialize(staticData.serializedATN)
	atn := staticData.atn
	staticData.decisionToDFA = make([]*antlr.DFA, len(atn.DecisionToState))
	decisionToDFA := staticData.decisionToDFA
	for index, state := range atn.DecisionToState {
		decisionToDFA[index] = antlr.NewDFA(state, index)
	}
}

// PHPParserInit initializes any static state used to implement PHPParser. By default the
// static state used to implement the parser is lazily initialized during the first call to
// NewPHPParser(). You can call this function if you wish to initialize the static state ahead
// of time.
func PHPParserInit() {
	staticData := &phpparserParserStaticData
	staticData.once.Do(phpparserParserInit)
}

// NewPHPParser produces a new parser instance for the optional input antlr.TokenStream.
func NewPHPParser(input antlr.TokenStream) *PHPParser {
	PHPParserInit()
	this := new(PHPParser)
	this.BaseParser = antlr.NewBaseParser(input)
	staticData := &phpparserParserStaticData
	this.Interpreter = antlr.NewParserATNSimulator(this, staticData.atn, staticData.decisionToDFA, staticData.predictionContextCache)
	this.RuleNames = staticData.ruleNames
	this.LiteralNames = staticData.literalNames
	this.SymbolicNames = staticData.symbolicNames
	this.GrammarFileName = "java-escape"

	return this
}

// PHPParser tokens.
const (
	PHPParserEOF                        = antlr.TokenEOF
	PHPParserSeaWhitespace              = 1
	PHPParserHtmlText                   = 2
	PHPParserXmlStart                   = 3
	PHPParserPHPStart                   = 4
	PHPParserHtmlScriptOpen             = 5
	PHPParserHtmlStyleOpen              = 6
	PHPParserHtmlComment                = 7
	PHPParserHtmlDtd                    = 8
	PHPParserHtmlOpen                   = 9
	PHPParserShebang                    = 10
	PHPParserError                      = 11
	PHPParserXmlText                    = 12
	PHPParserXmlClose                   = 13
	PHPParserPHPStartInside             = 14
	PHPParserHtmlClose                  = 15
	PHPParserHtmlSlashClose             = 16
	PHPParserHtmlSlash                  = 17
	PHPParserHtmlEquals                 = 18
	PHPParserHtmlStartQuoteString       = 19
	PHPParserHtmlStartDoubleQuoteString = 20
	PHPParserHtmlHex                    = 21
	PHPParserHtmlDecimal                = 22
	PHPParserHtmlSpace                  = 23
	PHPParserHtmlName                   = 24
	PHPParserErrorInside                = 25
	PHPParserPHPStartInsideQuoteString  = 26
	PHPParserHtmlEndQuoteString         = 27
	PHPParserHtmlQuoteString            = 28
	PHPParserErrorHtmlQuote             = 29
	PHPParserPHPStartDoubleQuoteString  = 30
	PHPParserHtmlEndDoubleQuoteString   = 31
	PHPParserHtmlDoubleQuoteString      = 32
	PHPParserErrorHtmlDoubleQuote       = 33
	PHPParserScriptText                 = 34
	PHPParserHtmlScriptClose            = 35
	PHPParserPHPStartInsideScript       = 36
	PHPParserStyleBody                  = 37
	PHPParserPHPEnd                     = 38
	PHPParserWhitespace                 = 39
	PHPParserMultiLineComment           = 40
	PHPParserSingleLineComment          = 41
	PHPParserShellStyleComment          = 42
	PHPParserAttributeStart             = 43
	PHPParserAbstract                   = 44
	PHPParserArray                      = 45
	PHPParserAs                         = 46
	PHPParserBinaryCast                 = 47
	PHPParserBoolType                   = 48
	PHPParserBooleanConstant            = 49
	PHPParserBreak                      = 50
	PHPParserCallable                   = 51
	PHPParserCase                       = 52
	PHPParserCatch                      = 53
	PHPParserClass                      = 54
	PHPParserClone                      = 55
	PHPParserConst                      = 56
	PHPParserContinue                   = 57
	PHPParserDeclare                    = 58
	PHPParserDefault                    = 59
	PHPParserDo                         = 60
	PHPParserDoubleCast                 = 61
	PHPParserDoubleType                 = 62
	PHPParserEcho                       = 63
	PHPParserElse                       = 64
	PHPParserElseIf                     = 65
	PHPParserEmpty                      = 66
	PHPParserEnum_                      = 67
	PHPParserEndDeclare                 = 68
	PHPParserEndFor                     = 69
	PHPParserEndForeach                 = 70
	PHPParserEndIf                      = 71
	PHPParserEndSwitch                  = 72
	PHPParserEndWhile                   = 73
	PHPParserEval                       = 74
	PHPParserExit                       = 75
	PHPParserExtends                    = 76
	PHPParserFinal                      = 77
	PHPParserFinally                    = 78
	PHPParserFloatCast                  = 79
	PHPParserFor                        = 80
	PHPParserForeach                    = 81
	PHPParserFunction_                  = 82
	PHPParserGlobal                     = 83
	PHPParserGoto                       = 84
	PHPParserIf                         = 85
	PHPParserImplements                 = 86
	PHPParserImport                     = 87
	PHPParserInclude                    = 88
	PHPParserIncludeOnce                = 89
	PHPParserInstanceOf                 = 90
	PHPParserInsteadOf                  = 91
	PHPParserInt8Cast                   = 92
	PHPParserInt16Cast                  = 93
	PHPParserInt64Type                  = 94
	PHPParserIntType                    = 95
	PHPParserInterface                  = 96
	PHPParserIsSet                      = 97
	PHPParserList                       = 98
	PHPParserLogicalAnd                 = 99
	PHPParserLogicalOr                  = 100
	PHPParserLogicalXor                 = 101
	PHPParserMatch_                     = 102
	PHPParserNamespace                  = 103
	PHPParserNew                        = 104
	PHPParserNull                       = 105
	PHPParserObjectType                 = 106
	PHPParserParent_                    = 107
	PHPParserPartial                    = 108
	PHPParserPrint                      = 109
	PHPParserPrivate                    = 110
	PHPParserProtected                  = 111
	PHPParserPublic                     = 112
	PHPParserReadonly                   = 113
	PHPParserRequire                    = 114
	PHPParserRequireOnce                = 115
	PHPParserResource                   = 116
	PHPParserReturn                     = 117
	PHPParserStatic                     = 118
	PHPParserStringType                 = 119
	PHPParserSwitch                     = 120
	PHPParserThrow                      = 121
	PHPParserTrait                      = 122
	PHPParserTry                        = 123
	PHPParserTypeof                     = 124
	PHPParserUintCast                   = 125
	PHPParserUnicodeCast                = 126
	PHPParserUnset                      = 127
	PHPParserUse                        = 128
	PHPParserVar                        = 129
	PHPParserWhile                      = 130
	PHPParserYield                      = 131
	PHPParserFrom                       = 132
	PHPParserLambdaFn                   = 133
	PHPParserTicks                      = 134
	PHPParserEncoding                   = 135
	PHPParserStrictTypes                = 136
	PHPParserGet                        = 137
	PHPParserSet                        = 138
	PHPParserCall                       = 139
	PHPParserCallStatic                 = 140
	PHPParserConstructor                = 141
	PHPParserDestruct                   = 142
	PHPParserWakeup                     = 143
	PHPParserSleep                      = 144
	PHPParserAutoload                   = 145
	PHPParserIsSet__                    = 146
	PHPParserUnset__                    = 147
	PHPParserToString__                 = 148
	PHPParserInvoke                     = 149
	PHPParserSetState                   = 150
	PHPParserClone__                    = 151
	PHPParserDebugInfo                  = 152
	PHPParserNamespace__                = 153
	PHPParserClass__                    = 154
	PHPParserTraic__                    = 155
	PHPParserFunction__                 = 156
	PHPParserMethod__                   = 157
	PHPParserLine__                     = 158
	PHPParserFile__                     = 159
	PHPParserDir__                      = 160
	PHPParserSpaceship                  = 161
	PHPParserLgeneric                   = 162
	PHPParserRgeneric                   = 163
	PHPParserDoubleArrow                = 164
	PHPParserInc                        = 165
	PHPParserDec                        = 166
	PHPParserIsIdentical                = 167
	PHPParserIsNoidentical              = 168
	PHPParserIsEqual                    = 169
	PHPParserIsNotEq                    = 170
	PHPParserIsSmallerOrEqual           = 171
	PHPParserIsGreaterOrEqual           = 172
	PHPParserPlusEqual                  = 173
	PHPParserMinusEqual                 = 174
	PHPParserMulEqual                   = 175
	PHPParserPow                        = 176
	PHPParserPowEqual                   = 177
	PHPParserDivEqual                   = 178
	PHPParserConcaequal                 = 179
	PHPParserModEqual                   = 180
	PHPParserShiftLeftEqual             = 181
	PHPParserShiftRightEqual            = 182
	PHPParserAndEqual                   = 183
	PHPParserOrEqual                    = 184
	PHPParserXorEqual                   = 185
	PHPParserBooleanOr                  = 186
	PHPParserBooleanAnd                 = 187
	PHPParserNullCoalescing             = 188
	PHPParserNullCoalescingEqual        = 189
	PHPParserShiftLeft                  = 190
	PHPParserShiftRight                 = 191
	PHPParserDoubleColon                = 192
	PHPParserObjectOperator             = 193
	PHPParserNamespaceSeparator         = 194
	PHPParserEllipsis                   = 195
	PHPParserLess                       = 196
	PHPParserGreater                    = 197
	PHPParserAmpersand                  = 198
	PHPParserPipe                       = 199
	PHPParserBang                       = 200
	PHPParserCaret                      = 201
	PHPParserPlus                       = 202
	PHPParserMinus                      = 203
	PHPParserAsterisk                   = 204
	PHPParserPercent                    = 205
	PHPParserDivide                     = 206
	PHPParserTilde                      = 207
	PHPParserSuppressWarnings           = 208
	PHPParserDollar                     = 209
	PHPParserDot                        = 210
	PHPParserQuestionMark               = 211
	PHPParserOpenRoundBracket           = 212
	PHPParserCloseRoundBracket          = 213
	PHPParserOpenSquareBracket          = 214
	PHPParserCloseSquareBracket         = 215
	PHPParserOpenCurlyBracket           = 216
	PHPParserCloseCurlyBracket          = 217
	PHPParserComma                      = 218
	PHPParserColon                      = 219
	PHPParserSemiColon                  = 220
	PHPParserEq                         = 221
	PHPParserQuote                      = 222
	PHPParserBackQuote                  = 223
	PHPParserVarName                    = 224
	PHPParserLabel                      = 225
	PHPParserOctal                      = 226
	PHPParserDecimal                    = 227
	PHPParserReal                       = 228
	PHPParserHex                        = 229
	PHPParserBinary                     = 230
	PHPParserBackQuoteString            = 231
	PHPParserSingleQuoteString          = 232
	PHPParserDoubleQuote                = 233
	PHPParserStartNowDoc                = 234
	PHPParserStartHereDoc               = 235
	PHPParserErrorPhp                   = 236
	PHPParserCurlyDollar                = 237
	PHPParserUnicodeEscape              = 238
	PHPParserStringPart                 = 239
	PHPParserComment                    = 240
	PHPParserPHPEndSingleLineComment    = 241
	PHPParserCommentEnd                 = 242
	PHPParserHereDocText                = 243
	PHPParserXmlText2                   = 244
)

// PHPParser rules.
const (
	PHPParserRULE_htmlDocument                  = 0
	PHPParserRULE_htmlDocumentElement           = 1
	PHPParserRULE_inlineHtml                    = 2
	PHPParserRULE_htmlElement                   = 3
	PHPParserRULE_scriptText                    = 4
	PHPParserRULE_phpBlock                      = 5
	PHPParserRULE_importStatement               = 6
	PHPParserRULE_topStatement                  = 7
	PHPParserRULE_useDeclaration                = 8
	PHPParserRULE_useDeclarationContentList     = 9
	PHPParserRULE_useDeclarationContent         = 10
	PHPParserRULE_namespaceDeclaration          = 11
	PHPParserRULE_namespaceStatement            = 12
	PHPParserRULE_functionDeclaration           = 13
	PHPParserRULE_classDeclaration              = 14
	PHPParserRULE_classEntryType                = 15
	PHPParserRULE_interfaceList                 = 16
	PHPParserRULE_typeParameterListInBrackets   = 17
	PHPParserRULE_typeParameterList             = 18
	PHPParserRULE_typeParameterWithDefaultsList = 19
	PHPParserRULE_typeParameterDecl             = 20
	PHPParserRULE_typeParameterWithDefaultDecl  = 21
	PHPParserRULE_genericDynamicArgs            = 22
	PHPParserRULE_attributes                    = 23
	PHPParserRULE_attributeGroup                = 24
	PHPParserRULE_attribute                     = 25
	PHPParserRULE_innerStatementList            = 26
	PHPParserRULE_innerStatement                = 27
	PHPParserRULE_statement                     = 28
	PHPParserRULE_emptyStatement_               = 29
	PHPParserRULE_blockStatement                = 30
	PHPParserRULE_ifStatement                   = 31
	PHPParserRULE_elseIfStatement               = 32
	PHPParserRULE_elseIfColonStatement          = 33
	PHPParserRULE_elseStatement                 = 34
	PHPParserRULE_elseColonStatement            = 35
	PHPParserRULE_whileStatement                = 36
	PHPParserRULE_doWhileStatement              = 37
	PHPParserRULE_forStatement                  = 38
	PHPParserRULE_forInit                       = 39
	PHPParserRULE_forUpdate                     = 40
	PHPParserRULE_switchStatement               = 41
	PHPParserRULE_switchBlock                   = 42
	PHPParserRULE_breakStatement                = 43
	PHPParserRULE_continueStatement             = 44
	PHPParserRULE_returnStatement               = 45
	PHPParserRULE_expressionStatement           = 46
	PHPParserRULE_unsetStatement                = 47
	PHPParserRULE_foreachStatement              = 48
	PHPParserRULE_tryCatchFinally               = 49
	PHPParserRULE_catchClause                   = 50
	PHPParserRULE_finallyStatement              = 51
	PHPParserRULE_throwStatement                = 52
	PHPParserRULE_gotoStatement                 = 53
	PHPParserRULE_declareStatement              = 54
	PHPParserRULE_inlineHtmlStatement           = 55
	PHPParserRULE_declareList                   = 56
	PHPParserRULE_directive                     = 57
	PHPParserRULE_formalParameterList           = 58
	PHPParserRULE_formalParameter               = 59
	PHPParserRULE_typeHint                      = 60
	PHPParserRULE_globalStatement               = 61
	PHPParserRULE_globalVar                     = 62
	PHPParserRULE_echoStatement                 = 63
	PHPParserRULE_staticVariableStatement       = 64
	PHPParserRULE_classStatement                = 65
	PHPParserRULE_traitAdaptations              = 66
	PHPParserRULE_traitAdaptationStatement      = 67
	PHPParserRULE_traitPrecedence               = 68
	PHPParserRULE_traitAlias                    = 69
	PHPParserRULE_traitMethodReference          = 70
	PHPParserRULE_baseCtorCall                  = 71
	PHPParserRULE_returnTypeDecl                = 72
	PHPParserRULE_methodBody                    = 73
	PHPParserRULE_propertyModifiers             = 74
	PHPParserRULE_memberModifiers               = 75
	PHPParserRULE_variableInitializer           = 76
	PHPParserRULE_identifierInitializer         = 77
	PHPParserRULE_globalConstantDeclaration     = 78
	PHPParserRULE_enumDeclaration               = 79
	PHPParserRULE_enumItem                      = 80
	PHPParserRULE_expressionList                = 81
	PHPParserRULE_parentheses                   = 82
	PHPParserRULE_expression                    = 83
	PHPParserRULE_assignable                    = 84
	PHPParserRULE_arrayCreation                 = 85
	PHPParserRULE_arrayDestructuring            = 86
	PHPParserRULE_indexedDestructItem           = 87
	PHPParserRULE_keyedDestructItem             = 88
	PHPParserRULE_lambdaFunctionExpr            = 89
	PHPParserRULE_matchExpr                     = 90
	PHPParserRULE_matchItem                     = 91
	PHPParserRULE_newExpr                       = 92
	PHPParserRULE_assignmentOperator            = 93
	PHPParserRULE_yieldExpression               = 94
	PHPParserRULE_arrayItemList                 = 95
	PHPParserRULE_arrayItem                     = 96
	PHPParserRULE_lambdaFunctionUseVars         = 97
	PHPParserRULE_lambdaFunctionUseVar          = 98
	PHPParserRULE_qualifiedStaticTypeRef        = 99
	PHPParserRULE_typeRef                       = 100
	PHPParserRULE_anonymousClass                = 101
	PHPParserRULE_indirectTypeRef               = 102
	PHPParserRULE_qualifiedNamespaceName        = 103
	PHPParserRULE_namespaceNameList             = 104
	PHPParserRULE_namespaceNameTail             = 105
	PHPParserRULE_qualifiedNamespaceNameList    = 106
	PHPParserRULE_arguments                     = 107
	PHPParserRULE_actualArgument                = 108
	PHPParserRULE_argumentName                  = 109
	PHPParserRULE_constantInitializer           = 110
	PHPParserRULE_constant                      = 111
	PHPParserRULE_literalConstant               = 112
	PHPParserRULE_numericConstant               = 113
	PHPParserRULE_classConstant                 = 114
	PHPParserRULE_stringConstant                = 115
	PHPParserRULE_string                        = 116
	PHPParserRULE_interpolatedStringPart        = 117
	PHPParserRULE_chainList                     = 118
	PHPParserRULE_chain                         = 119
	PHPParserRULE_chainOrigin                   = 120
	PHPParserRULE_memberAccess                  = 121
	PHPParserRULE_functionCall                  = 122
	PHPParserRULE_functionCallName              = 123
	PHPParserRULE_actualArguments               = 124
	PHPParserRULE_chainBase                     = 125
	PHPParserRULE_keyedFieldName                = 126
	PHPParserRULE_keyedSimpleFieldName          = 127
	PHPParserRULE_keyedVariable                 = 128
	PHPParserRULE_squareCurlyExpression         = 129
	PHPParserRULE_assignmentList                = 130
	PHPParserRULE_assignmentListElement         = 131
	PHPParserRULE_modifier                      = 132
	PHPParserRULE_identifier                    = 133
	PHPParserRULE_memberModifier                = 134
	PHPParserRULE_magicConstant                 = 135
	PHPParserRULE_magicMethod                   = 136
	PHPParserRULE_primitiveType                 = 137
	PHPParserRULE_castOperation                 = 138
)

// IHtmlDocumentContext is an interface to support dynamic dispatch.
type IHtmlDocumentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsHtmlDocumentContext differentiates from other interfaces.
	IsHtmlDocumentContext()
}

type HtmlDocumentContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyHtmlDocumentContext() *HtmlDocumentContext {
	var p = new(HtmlDocumentContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PHPParserRULE_htmlDocument
	return p
}

func (*HtmlDocumentContext) IsHtmlDocumentContext() {}

func NewHtmlDocumentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *HtmlDocumentContext {
	var p = new(HtmlDocumentContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PHPParserRULE_htmlDocument

	return p
}

func (s *HtmlDocumentContext) GetParser() antlr.Parser { return s.parser }

func (s *HtmlDocumentContext) EOF() antlr.TerminalNode {
	return s.GetToken(PHPParserEOF, 0)
}

func (s *HtmlDocumentContext) Shebang() antlr.TerminalNode {
	return s.GetToken(PHPParserShebang, 0)
}

func (s *HtmlDocumentContext) AllHtmlDocumentElement() []IHtmlDocumentElementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IHtmlDocumentElementContext); ok {
			len++
		}
	}

	tst := make([]IHtmlDocumentElementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IHtmlDocumentElementContext); ok {
			tst[i] = t.(IHtmlDocumentElementContext)
			i++
		}
	}

	return tst
}

func (s *HtmlDocumentContext) HtmlDocumentElement(i int) IHtmlDocumentElementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IHtmlDocumentElementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IHtmlDocumentElementContext)
}

func (s *HtmlDocumentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *HtmlDocumentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *HtmlDocumentContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PHPParserVisitor:
		return t.VisitHtmlDocument(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PHPParser) HtmlDocument() (localctx IHtmlDocumentContext) {
	this := p
	_ = this

	localctx = NewHtmlDocumentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 0, PHPParserRULE_htmlDocument)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(279)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == PHPParserShebang {
		{
			p.SetState(278)
			p.Match(PHPParserShebang)
		}

	}
	p.SetState(284)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for (int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-8600244223124) != 0 || (int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&-1) != 0 || (int64((_la-128)) & ^0x3f) == 0 && ((int64(1)<<(_la-128))&420906795007) != 0 || (int64((_la-194)) & ^0x3f) == 0 && ((int64(1)<<(_la-194))&4397045441345) != 0 {
		{
			p.SetState(281)
			p.HtmlDocumentElement()
		}

		p.SetState(286)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(287)
		p.Match(PHPParserEOF)
	}

	return localctx
}

// IHtmlDocumentElementContext is an interface to support dynamic dispatch.
type IHtmlDocumentElementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsHtmlDocumentElementContext differentiates from other interfaces.
	IsHtmlDocumentElementContext()
}

type HtmlDocumentElementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyHtmlDocumentElementContext() *HtmlDocumentElementContext {
	var p = new(HtmlDocumentElementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PHPParserRULE_htmlDocumentElement
	return p
}

func (*HtmlDocumentElementContext) IsHtmlDocumentElementContext() {}

func NewHtmlDocumentElementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *HtmlDocumentElementContext {
	var p = new(HtmlDocumentElementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PHPParserRULE_htmlDocumentElement

	return p
}

func (s *HtmlDocumentElementContext) GetParser() antlr.Parser { return s.parser }

func (s *HtmlDocumentElementContext) InlineHtml() IInlineHtmlContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInlineHtmlContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInlineHtmlContext)
}

func (s *HtmlDocumentElementContext) PhpBlock() IPhpBlockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPhpBlockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPhpBlockContext)
}

func (s *HtmlDocumentElementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *HtmlDocumentElementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *HtmlDocumentElementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PHPParserVisitor:
		return t.VisitHtmlDocumentElement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PHPParser) HtmlDocumentElement() (localctx IHtmlDocumentElementContext) {
	this := p
	_ = this

	localctx = NewHtmlDocumentElementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 2, PHPParserRULE_htmlDocumentElement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(291)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 2, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(289)
			p.InlineHtml()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(290)
			p.PhpBlock()
		}

	}

	return localctx
}

// IInlineHtmlContext is an interface to support dynamic dispatch.
type IInlineHtmlContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInlineHtmlContext differentiates from other interfaces.
	IsInlineHtmlContext()
}

type InlineHtmlContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInlineHtmlContext() *InlineHtmlContext {
	var p = new(InlineHtmlContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PHPParserRULE_inlineHtml
	return p
}

func (*InlineHtmlContext) IsInlineHtmlContext() {}

func NewInlineHtmlContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InlineHtmlContext {
	var p = new(InlineHtmlContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PHPParserRULE_inlineHtml

	return p
}

func (s *InlineHtmlContext) GetParser() antlr.Parser { return s.parser }

func (s *InlineHtmlContext) AllHtmlElement() []IHtmlElementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IHtmlElementContext); ok {
			len++
		}
	}

	tst := make([]IHtmlElementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IHtmlElementContext); ok {
			tst[i] = t.(IHtmlElementContext)
			i++
		}
	}

	return tst
}

func (s *InlineHtmlContext) HtmlElement(i int) IHtmlElementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IHtmlElementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IHtmlElementContext)
}

func (s *InlineHtmlContext) ScriptText() IScriptTextContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IScriptTextContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IScriptTextContext)
}

func (s *InlineHtmlContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InlineHtmlContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InlineHtmlContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PHPParserVisitor:
		return t.VisitInlineHtml(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PHPParser) InlineHtml() (localctx IInlineHtmlContext) {
	this := p
	_ = this

	localctx = NewInlineHtmlContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 4, PHPParserRULE_inlineHtml)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.SetState(299)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case PHPParserHtmlText, PHPParserXmlStart, PHPParserHtmlScriptOpen, PHPParserHtmlStyleOpen, PHPParserHtmlDtd, PHPParserHtmlOpen, PHPParserHtmlClose, PHPParserHtmlSlashClose, PHPParserHtmlSlash, PHPParserHtmlEquals, PHPParserHtmlStartQuoteString, PHPParserHtmlStartDoubleQuoteString, PHPParserHtmlHex, PHPParserHtmlDecimal, PHPParserHtmlName, PHPParserHtmlEndQuoteString, PHPParserHtmlQuoteString, PHPParserHtmlEndDoubleQuoteString, PHPParserHtmlDoubleQuoteString, PHPParserHtmlScriptClose, PHPParserStyleBody:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(294)
		p.GetErrorHandler().Sync(p)
		_alt = 1
		for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			switch _alt {
			case 1:
				{
					p.SetState(293)
					p.HtmlElement()
				}

			default:
				panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			}

			p.SetState(296)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 3, p.GetParserRuleContext())
		}

	case PHPParserScriptText:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(298)
			p.ScriptText()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IHtmlElementContext is an interface to support dynamic dispatch.
type IHtmlElementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsHtmlElementContext differentiates from other interfaces.
	IsHtmlElementContext()
}

type HtmlElementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyHtmlElementContext() *HtmlElementContext {
	var p = new(HtmlElementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PHPParserRULE_htmlElement
	return p
}

func (*HtmlElementContext) IsHtmlElementContext() {}

func NewHtmlElementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *HtmlElementContext {
	var p = new(HtmlElementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PHPParserRULE_htmlElement

	return p
}

func (s *HtmlElementContext) GetParser() antlr.Parser { return s.parser }

func (s *HtmlElementContext) HtmlDtd() antlr.TerminalNode {
	return s.GetToken(PHPParserHtmlDtd, 0)
}

func (s *HtmlElementContext) HtmlClose() antlr.TerminalNode {
	return s.GetToken(PHPParserHtmlClose, 0)
}

func (s *HtmlElementContext) HtmlStyleOpen() antlr.TerminalNode {
	return s.GetToken(PHPParserHtmlStyleOpen, 0)
}

func (s *HtmlElementContext) HtmlOpen() antlr.TerminalNode {
	return s.GetToken(PHPParserHtmlOpen, 0)
}

func (s *HtmlElementContext) HtmlName() antlr.TerminalNode {
	return s.GetToken(PHPParserHtmlName, 0)
}

func (s *HtmlElementContext) HtmlSlashClose() antlr.TerminalNode {
	return s.GetToken(PHPParserHtmlSlashClose, 0)
}

func (s *HtmlElementContext) HtmlSlash() antlr.TerminalNode {
	return s.GetToken(PHPParserHtmlSlash, 0)
}

func (s *HtmlElementContext) HtmlText() antlr.TerminalNode {
	return s.GetToken(PHPParserHtmlText, 0)
}

func (s *HtmlElementContext) HtmlEquals() antlr.TerminalNode {
	return s.GetToken(PHPParserHtmlEquals, 0)
}

func (s *HtmlElementContext) HtmlStartQuoteString() antlr.TerminalNode {
	return s.GetToken(PHPParserHtmlStartQuoteString, 0)
}

func (s *HtmlElementContext) HtmlEndQuoteString() antlr.TerminalNode {
	return s.GetToken(PHPParserHtmlEndQuoteString, 0)
}

func (s *HtmlElementContext) HtmlStartDoubleQuoteString() antlr.TerminalNode {
	return s.GetToken(PHPParserHtmlStartDoubleQuoteString, 0)
}

func (s *HtmlElementContext) HtmlEndDoubleQuoteString() antlr.TerminalNode {
	return s.GetToken(PHPParserHtmlEndDoubleQuoteString, 0)
}

func (s *HtmlElementContext) HtmlHex() antlr.TerminalNode {
	return s.GetToken(PHPParserHtmlHex, 0)
}

func (s *HtmlElementContext) HtmlDecimal() antlr.TerminalNode {
	return s.GetToken(PHPParserHtmlDecimal, 0)
}

func (s *HtmlElementContext) HtmlQuoteString() antlr.TerminalNode {
	return s.GetToken(PHPParserHtmlQuoteString, 0)
}

func (s *HtmlElementContext) HtmlDoubleQuoteString() antlr.TerminalNode {
	return s.GetToken(PHPParserHtmlDoubleQuoteString, 0)
}

func (s *HtmlElementContext) StyleBody() antlr.TerminalNode {
	return s.GetToken(PHPParserStyleBody, 0)
}

func (s *HtmlElementContext) HtmlScriptOpen() antlr.TerminalNode {
	return s.GetToken(PHPParserHtmlScriptOpen, 0)
}

func (s *HtmlElementContext) HtmlScriptClose() antlr.TerminalNode {
	return s.GetToken(PHPParserHtmlScriptClose, 0)
}

func (s *HtmlElementContext) XmlStart() antlr.TerminalNode {
	return s.GetToken(PHPParserXmlStart, 0)
}

func (s *HtmlElementContext) XmlClose() antlr.TerminalNode {
	return s.GetToken(PHPParserXmlClose, 0)
}

func (s *HtmlElementContext) AllXmlText() []antlr.TerminalNode {
	return s.GetTokens(PHPParserXmlText)
}

func (s *HtmlElementContext) XmlText(i int) antlr.TerminalNode {
	return s.GetToken(PHPParserXmlText, i)
}

func (s *HtmlElementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *HtmlElementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *HtmlElementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PHPParserVisitor:
		return t.VisitHtmlElement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PHPParser) HtmlElement() (localctx IHtmlElementContext) {
	this := p
	_ = this

	localctx = NewHtmlElementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 6, PHPParserRULE_htmlElement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(329)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case PHPParserHtmlDtd:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(301)
			p.Match(PHPParserHtmlDtd)
		}

	case PHPParserHtmlClose:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(302)
			p.Match(PHPParserHtmlClose)
		}

	case PHPParserHtmlStyleOpen:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(303)
			p.Match(PHPParserHtmlStyleOpen)
		}

	case PHPParserHtmlOpen:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(304)
			p.Match(PHPParserHtmlOpen)
		}

	case PHPParserHtmlName:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(305)
			p.Match(PHPParserHtmlName)
		}

	case PHPParserHtmlSlashClose:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(306)
			p.Match(PHPParserHtmlSlashClose)
		}

	case PHPParserHtmlSlash:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(307)
			p.Match(PHPParserHtmlSlash)
		}

	case PHPParserHtmlText:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(308)
			p.Match(PHPParserHtmlText)
		}

	case PHPParserHtmlEquals:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(309)
			p.Match(PHPParserHtmlEquals)
		}

	case PHPParserHtmlStartQuoteString:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(310)
			p.Match(PHPParserHtmlStartQuoteString)
		}

	case PHPParserHtmlEndQuoteString:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(311)
			p.Match(PHPParserHtmlEndQuoteString)
		}

	case PHPParserHtmlStartDoubleQuoteString:
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(312)
			p.Match(PHPParserHtmlStartDoubleQuoteString)
		}

	case PHPParserHtmlEndDoubleQuoteString:
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(313)
			p.Match(PHPParserHtmlEndDoubleQuoteString)
		}

	case PHPParserHtmlHex:
		p.EnterOuterAlt(localctx, 14)
		{
			p.SetState(314)
			p.Match(PHPParserHtmlHex)
		}

	case PHPParserHtmlDecimal:
		p.EnterOuterAlt(localctx, 15)
		{
			p.SetState(315)
			p.Match(PHPParserHtmlDecimal)
		}

	case PHPParserHtmlQuoteString:
		p.EnterOuterAlt(localctx, 16)
		{
			p.SetState(316)
			p.Match(PHPParserHtmlQuoteString)
		}

	case PHPParserHtmlDoubleQuoteString:
		p.EnterOuterAlt(localctx, 17)
		{
			p.SetState(317)
			p.Match(PHPParserHtmlDoubleQuoteString)
		}

	case PHPParserStyleBody:
		p.EnterOuterAlt(localctx, 18)
		{
			p.SetState(318)
			p.Match(PHPParserStyleBody)
		}

	case PHPParserHtmlScriptOpen:
		p.EnterOuterAlt(localctx, 19)
		{
			p.SetState(319)
			p.Match(PHPParserHtmlScriptOpen)
		}

	case PHPParserHtmlScriptClose:
		p.EnterOuterAlt(localctx, 20)
		{
			p.SetState(320)
			p.Match(PHPParserHtmlScriptClose)
		}

	case PHPParserXmlStart:
		p.EnterOuterAlt(localctx, 21)
		{
			p.SetState(321)
			p.Match(PHPParserXmlStart)
		}
		p.SetState(325)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == PHPParserXmlText {
			{
				p.SetState(322)
				p.Match(PHPParserXmlText)
			}

			p.SetState(327)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(328)
			p.Match(PHPParserXmlClose)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IScriptTextContext is an interface to support dynamic dispatch.
type IScriptTextContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsScriptTextContext differentiates from other interfaces.
	IsScriptTextContext()
}

type ScriptTextContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyScriptTextContext() *ScriptTextContext {
	var p = new(ScriptTextContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PHPParserRULE_scriptText
	return p
}

func (*ScriptTextContext) IsScriptTextContext() {}

func NewScriptTextContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ScriptTextContext {
	var p = new(ScriptTextContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PHPParserRULE_scriptText

	return p
}

func (s *ScriptTextContext) GetParser() antlr.Parser { return s.parser }

func (s *ScriptTextContext) AllScriptText() []antlr.TerminalNode {
	return s.GetTokens(PHPParserScriptText)
}

func (s *ScriptTextContext) ScriptText(i int) antlr.TerminalNode {
	return s.GetToken(PHPParserScriptText, i)
}

func (s *ScriptTextContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ScriptTextContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ScriptTextContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PHPParserVisitor:
		return t.VisitScriptText(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PHPParser) ScriptText() (localctx IScriptTextContext) {
	this := p
	_ = this

	localctx = NewScriptTextContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 8, PHPParserRULE_scriptText)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(332)
	p.GetErrorHandler().Sync(p)
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			{
				p.SetState(331)
				p.Match(PHPParserScriptText)
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(334)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 7, p.GetParserRuleContext())
	}

	return localctx
}

// IPhpBlockContext is an interface to support dynamic dispatch.
type IPhpBlockContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPhpBlockContext differentiates from other interfaces.
	IsPhpBlockContext()
}

type PhpBlockContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPhpBlockContext() *PhpBlockContext {
	var p = new(PhpBlockContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PHPParserRULE_phpBlock
	return p
}

func (*PhpBlockContext) IsPhpBlockContext() {}

func NewPhpBlockContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PhpBlockContext {
	var p = new(PhpBlockContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PHPParserRULE_phpBlock

	return p
}

func (s *PhpBlockContext) GetParser() antlr.Parser { return s.parser }

func (s *PhpBlockContext) AllImportStatement() []IImportStatementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IImportStatementContext); ok {
			len++
		}
	}

	tst := make([]IImportStatementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IImportStatementContext); ok {
			tst[i] = t.(IImportStatementContext)
			i++
		}
	}

	return tst
}

func (s *PhpBlockContext) ImportStatement(i int) IImportStatementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IImportStatementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IImportStatementContext)
}

func (s *PhpBlockContext) AllTopStatement() []ITopStatementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITopStatementContext); ok {
			len++
		}
	}

	tst := make([]ITopStatementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITopStatementContext); ok {
			tst[i] = t.(ITopStatementContext)
			i++
		}
	}

	return tst
}

func (s *PhpBlockContext) TopStatement(i int) ITopStatementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITopStatementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITopStatementContext)
}

func (s *PhpBlockContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PhpBlockContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PhpBlockContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PHPParserVisitor:
		return t.VisitPhpBlock(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PHPParser) PhpBlock() (localctx IPhpBlockContext) {
	this := p
	_ = this

	localctx = NewPhpBlockContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 10, PHPParserRULE_phpBlock)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(339)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 8, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(336)
				p.ImportStatement()
			}

		}
		p.SetState(341)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 8, p.GetParserRuleContext())
	}
	p.SetState(343)
	p.GetErrorHandler().Sync(p)
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			{
				p.SetState(342)
				p.TopStatement()
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(345)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 9, p.GetParserRuleContext())
	}

	return localctx
}

// IImportStatementContext is an interface to support dynamic dispatch.
type IImportStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsImportStatementContext differentiates from other interfaces.
	IsImportStatementContext()
}

type ImportStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyImportStatementContext() *ImportStatementContext {
	var p = new(ImportStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PHPParserRULE_importStatement
	return p
}

func (*ImportStatementContext) IsImportStatementContext() {}

func NewImportStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ImportStatementContext {
	var p = new(ImportStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PHPParserRULE_importStatement

	return p
}

func (s *ImportStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ImportStatementContext) Import() antlr.TerminalNode {
	return s.GetToken(PHPParserImport, 0)
}

func (s *ImportStatementContext) Namespace() antlr.TerminalNode {
	return s.GetToken(PHPParserNamespace, 0)
}

func (s *ImportStatementContext) NamespaceNameList() INamespaceNameListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INamespaceNameListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INamespaceNameListContext)
}

func (s *ImportStatementContext) SemiColon() antlr.TerminalNode {
	return s.GetToken(PHPParserSemiColon, 0)
}

func (s *ImportStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ImportStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ImportStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PHPParserVisitor:
		return t.VisitImportStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PHPParser) ImportStatement() (localctx IImportStatementContext) {
	this := p
	_ = this

	localctx = NewImportStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 12, PHPParserRULE_importStatement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(347)
		p.Match(PHPParserImport)
	}
	{
		p.SetState(348)
		p.Match(PHPParserNamespace)
	}
	{
		p.SetState(349)
		p.NamespaceNameList()
	}
	{
		p.SetState(350)
		p.Match(PHPParserSemiColon)
	}

	return localctx
}

// ITopStatementContext is an interface to support dynamic dispatch.
type ITopStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTopStatementContext differentiates from other interfaces.
	IsTopStatementContext()
}

type TopStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTopStatementContext() *TopStatementContext {
	var p = new(TopStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PHPParserRULE_topStatement
	return p
}

func (*TopStatementContext) IsTopStatementContext() {}

func NewTopStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TopStatementContext {
	var p = new(TopStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PHPParserRULE_topStatement

	return p
}

func (s *TopStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *TopStatementContext) Statement() IStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *TopStatementContext) UseDeclaration() IUseDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUseDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUseDeclarationContext)
}

func (s *TopStatementContext) NamespaceDeclaration() INamespaceDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INamespaceDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INamespaceDeclarationContext)
}

func (s *TopStatementContext) FunctionDeclaration() IFunctionDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionDeclarationContext)
}

func (s *TopStatementContext) ClassDeclaration() IClassDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClassDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClassDeclarationContext)
}

func (s *TopStatementContext) GlobalConstantDeclaration() IGlobalConstantDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGlobalConstantDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGlobalConstantDeclarationContext)
}

func (s *TopStatementContext) EnumDeclaration() IEnumDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEnumDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEnumDeclarationContext)
}

func (s *TopStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TopStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TopStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PHPParserVisitor:
		return t.VisitTopStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PHPParser) TopStatement() (localctx ITopStatementContext) {
	this := p
	_ = this

	localctx = NewTopStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 14, PHPParserRULE_topStatement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(359)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 10, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(352)
			p.Statement()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(353)
			p.UseDeclaration()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(354)
			p.NamespaceDeclaration()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(355)
			p.FunctionDeclaration()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(356)
			p.ClassDeclaration()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(357)
			p.GlobalConstantDeclaration()
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(358)
			p.EnumDeclaration()
		}

	}

	return localctx
}

// IUseDeclarationContext is an interface to support dynamic dispatch.
type IUseDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsUseDeclarationContext differentiates from other interfaces.
	IsUseDeclarationContext()
}

type UseDeclarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUseDeclarationContext() *UseDeclarationContext {
	var p = new(UseDeclarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PHPParserRULE_useDeclaration
	return p
}

func (*UseDeclarationContext) IsUseDeclarationContext() {}

func NewUseDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UseDeclarationContext {
	var p = new(UseDeclarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PHPParserRULE_useDeclaration

	return p
}

func (s *UseDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *UseDeclarationContext) Use() antlr.TerminalNode {
	return s.GetToken(PHPParserUse, 0)
}

func (s *UseDeclarationContext) UseDeclarationContentList() IUseDeclarationContentListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUseDeclarationContentListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUseDeclarationContentListContext)
}

func (s *UseDeclarationContext) SemiColon() antlr.TerminalNode {
	return s.GetToken(PHPParserSemiColon, 0)
}

func (s *UseDeclarationContext) Function_() antlr.TerminalNode {
	return s.GetToken(PHPParserFunction_, 0)
}

func (s *UseDeclarationContext) Const() antlr.TerminalNode {
	return s.GetToken(PHPParserConst, 0)
}

func (s *UseDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UseDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UseDeclarationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PHPParserVisitor:
		return t.VisitUseDeclaration(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PHPParser) UseDeclaration() (localctx IUseDeclarationContext) {
	this := p
	_ = this

	localctx = NewUseDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 16, PHPParserRULE_useDeclaration)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(361)
		p.Match(PHPParserUse)
	}
	p.SetState(363)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 11, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(362)
			_la = p.GetTokenStream().LA(1)

			if !(_la == PHPParserConst || _la == PHPParserFunction_) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}
	{
		p.SetState(365)
		p.UseDeclarationContentList()
	}
	{
		p.SetState(366)
		p.Match(PHPParserSemiColon)
	}

	return localctx
}

// IUseDeclarationContentListContext is an interface to support dynamic dispatch.
type IUseDeclarationContentListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsUseDeclarationContentListContext differentiates from other interfaces.
	IsUseDeclarationContentListContext()
}

type UseDeclarationContentListContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUseDeclarationContentListContext() *UseDeclarationContentListContext {
	var p = new(UseDeclarationContentListContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PHPParserRULE_useDeclarationContentList
	return p
}

func (*UseDeclarationContentListContext) IsUseDeclarationContentListContext() {}

func NewUseDeclarationContentListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UseDeclarationContentListContext {
	var p = new(UseDeclarationContentListContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PHPParserRULE_useDeclarationContentList

	return p
}

func (s *UseDeclarationContentListContext) GetParser() antlr.Parser { return s.parser }

func (s *UseDeclarationContentListContext) AllUseDeclarationContent() []IUseDeclarationContentContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IUseDeclarationContentContext); ok {
			len++
		}
	}

	tst := make([]IUseDeclarationContentContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IUseDeclarationContentContext); ok {
			tst[i] = t.(IUseDeclarationContentContext)
			i++
		}
	}

	return tst
}

func (s *UseDeclarationContentListContext) UseDeclarationContent(i int) IUseDeclarationContentContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUseDeclarationContentContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUseDeclarationContentContext)
}

func (s *UseDeclarationContentListContext) AllNamespaceSeparator() []antlr.TerminalNode {
	return s.GetTokens(PHPParserNamespaceSeparator)
}

func (s *UseDeclarationContentListContext) NamespaceSeparator(i int) antlr.TerminalNode {
	return s.GetToken(PHPParserNamespaceSeparator, i)
}

func (s *UseDeclarationContentListContext) AllComma() []antlr.TerminalNode {
	return s.GetTokens(PHPParserComma)
}

func (s *UseDeclarationContentListContext) Comma(i int) antlr.TerminalNode {
	return s.GetToken(PHPParserComma, i)
}

func (s *UseDeclarationContentListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UseDeclarationContentListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UseDeclarationContentListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PHPParserVisitor:
		return t.VisitUseDeclarationContentList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PHPParser) UseDeclarationContentList() (localctx IUseDeclarationContentListContext) {
	this := p
	_ = this

	localctx = NewUseDeclarationContentListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 18, PHPParserRULE_useDeclarationContentList)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(369)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == PHPParserNamespaceSeparator {
		{
			p.SetState(368)
			p.Match(PHPParserNamespaceSeparator)
		}

	}
	{
		p.SetState(371)
		p.UseDeclarationContent()
	}
	p.SetState(379)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == PHPParserComma {
		{
			p.SetState(372)
			p.Match(PHPParserComma)
		}
		p.SetState(374)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == PHPParserNamespaceSeparator {
			{
				p.SetState(373)
				p.Match(PHPParserNamespaceSeparator)
			}

		}
		{
			p.SetState(376)
			p.UseDeclarationContent()
		}

		p.SetState(381)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IUseDeclarationContentContext is an interface to support dynamic dispatch.
type IUseDeclarationContentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsUseDeclarationContentContext differentiates from other interfaces.
	IsUseDeclarationContentContext()
}

type UseDeclarationContentContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUseDeclarationContentContext() *UseDeclarationContentContext {
	var p = new(UseDeclarationContentContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PHPParserRULE_useDeclarationContent
	return p
}

func (*UseDeclarationContentContext) IsUseDeclarationContentContext() {}

func NewUseDeclarationContentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UseDeclarationContentContext {
	var p = new(UseDeclarationContentContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PHPParserRULE_useDeclarationContent

	return p
}

func (s *UseDeclarationContentContext) GetParser() antlr.Parser { return s.parser }

func (s *UseDeclarationContentContext) NamespaceNameList() INamespaceNameListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INamespaceNameListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INamespaceNameListContext)
}

func (s *UseDeclarationContentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UseDeclarationContentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UseDeclarationContentContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PHPParserVisitor:
		return t.VisitUseDeclarationContent(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PHPParser) UseDeclarationContent() (localctx IUseDeclarationContentContext) {
	this := p
	_ = this

	localctx = NewUseDeclarationContentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 20, PHPParserRULE_useDeclarationContent)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(382)
		p.NamespaceNameList()
	}

	return localctx
}

// INamespaceDeclarationContext is an interface to support dynamic dispatch.
type INamespaceDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsNamespaceDeclarationContext differentiates from other interfaces.
	IsNamespaceDeclarationContext()
}

type NamespaceDeclarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNamespaceDeclarationContext() *NamespaceDeclarationContext {
	var p = new(NamespaceDeclarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PHPParserRULE_namespaceDeclaration
	return p
}

func (*NamespaceDeclarationContext) IsNamespaceDeclarationContext() {}

func NewNamespaceDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NamespaceDeclarationContext {
	var p = new(NamespaceDeclarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PHPParserRULE_namespaceDeclaration

	return p
}

func (s *NamespaceDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *NamespaceDeclarationContext) Namespace() antlr.TerminalNode {
	return s.GetToken(PHPParserNamespace, 0)
}

func (s *NamespaceDeclarationContext) OpenCurlyBracket() antlr.TerminalNode {
	return s.GetToken(PHPParserOpenCurlyBracket, 0)
}

func (s *NamespaceDeclarationContext) CloseCurlyBracket() antlr.TerminalNode {
	return s.GetToken(PHPParserCloseCurlyBracket, 0)
}

func (s *NamespaceDeclarationContext) NamespaceNameList() INamespaceNameListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INamespaceNameListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INamespaceNameListContext)
}

func (s *NamespaceDeclarationContext) SemiColon() antlr.TerminalNode {
	return s.GetToken(PHPParserSemiColon, 0)
}

func (s *NamespaceDeclarationContext) AllNamespaceStatement() []INamespaceStatementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(INamespaceStatementContext); ok {
			len++
		}
	}

	tst := make([]INamespaceStatementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(INamespaceStatementContext); ok {
			tst[i] = t.(INamespaceStatementContext)
			i++
		}
	}

	return tst
}

func (s *NamespaceDeclarationContext) NamespaceStatement(i int) INamespaceStatementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INamespaceStatementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(INamespaceStatementContext)
}

func (s *NamespaceDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NamespaceDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NamespaceDeclarationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PHPParserVisitor:
		return t.VisitNamespaceDeclaration(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PHPParser) NamespaceDeclaration() (localctx INamespaceDeclarationContext) {
	this := p
	_ = this

	localctx = NewNamespaceDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 22, PHPParserRULE_namespaceDeclaration)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(384)
		p.Match(PHPParserNamespace)
	}
	p.SetState(399)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 17, p.GetParserRuleContext()) {
	case 1:
		p.SetState(386)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if (int64((_la-44)) & ^0x3f) == 0 && ((int64(1)<<(_la-44))&-1) != 0 || (int64((_la-108)) & ^0x3f) == 0 && ((int64(1)<<(_la-108))&9007199254740991) != 0 || _la == PHPParserLabel {
			{
				p.SetState(385)
				p.NamespaceNameList()
			}

		}
		{
			p.SetState(388)
			p.Match(PHPParserOpenCurlyBracket)
		}
		p.SetState(392)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for (int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-8600244223124) != 0 || (int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&-1) != 0 || (int64((_la-128)) & ^0x3f) == 0 && ((int64(1)<<(_la-128))&420906795007) != 0 || (int64((_la-194)) & ^0x3f) == 0 && ((int64(1)<<(_la-194))&4397045441345) != 0 {
			{
				p.SetState(389)
				p.NamespaceStatement()
			}

			p.SetState(394)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(395)
			p.Match(PHPParserCloseCurlyBracket)
		}

	case 2:
		{
			p.SetState(396)
			p.NamespaceNameList()
		}
		{
			p.SetState(397)
			p.Match(PHPParserSemiColon)
		}

	}

	return localctx
}

// INamespaceStatementContext is an interface to support dynamic dispatch.
type INamespaceStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsNamespaceStatementContext differentiates from other interfaces.
	IsNamespaceStatementContext()
}

type NamespaceStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNamespaceStatementContext() *NamespaceStatementContext {
	var p = new(NamespaceStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PHPParserRULE_namespaceStatement
	return p
}

func (*NamespaceStatementContext) IsNamespaceStatementContext() {}

func NewNamespaceStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NamespaceStatementContext {
	var p = new(NamespaceStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PHPParserRULE_namespaceStatement

	return p
}

func (s *NamespaceStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *NamespaceStatementContext) Statement() IStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *NamespaceStatementContext) UseDeclaration() IUseDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUseDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUseDeclarationContext)
}

func (s *NamespaceStatementContext) FunctionDeclaration() IFunctionDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionDeclarationContext)
}

func (s *NamespaceStatementContext) ClassDeclaration() IClassDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClassDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClassDeclarationContext)
}

func (s *NamespaceStatementContext) GlobalConstantDeclaration() IGlobalConstantDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGlobalConstantDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGlobalConstantDeclarationContext)
}

func (s *NamespaceStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NamespaceStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NamespaceStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PHPParserVisitor:
		return t.VisitNamespaceStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PHPParser) NamespaceStatement() (localctx INamespaceStatementContext) {
	this := p
	_ = this

	localctx = NewNamespaceStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 24, PHPParserRULE_namespaceStatement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(406)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 18, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(401)
			p.Statement()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(402)
			p.UseDeclaration()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(403)
			p.FunctionDeclaration()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(404)
			p.ClassDeclaration()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(405)
			p.GlobalConstantDeclaration()
		}

	}

	return localctx
}

// IFunctionDeclarationContext is an interface to support dynamic dispatch.
type IFunctionDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFunctionDeclarationContext differentiates from other interfaces.
	IsFunctionDeclarationContext()
}

type FunctionDeclarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunctionDeclarationContext() *FunctionDeclarationContext {
	var p = new(FunctionDeclarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PHPParserRULE_functionDeclaration
	return p
}

func (*FunctionDeclarationContext) IsFunctionDeclarationContext() {}

func NewFunctionDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FunctionDeclarationContext {
	var p = new(FunctionDeclarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PHPParserRULE_functionDeclaration

	return p
}

func (s *FunctionDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *FunctionDeclarationContext) Function_() antlr.TerminalNode {
	return s.GetToken(PHPParserFunction_, 0)
}

func (s *FunctionDeclarationContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *FunctionDeclarationContext) OpenRoundBracket() antlr.TerminalNode {
	return s.GetToken(PHPParserOpenRoundBracket, 0)
}

func (s *FunctionDeclarationContext) FormalParameterList() IFormalParameterListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFormalParameterListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFormalParameterListContext)
}

func (s *FunctionDeclarationContext) CloseRoundBracket() antlr.TerminalNode {
	return s.GetToken(PHPParserCloseRoundBracket, 0)
}

func (s *FunctionDeclarationContext) BlockStatement() IBlockStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBlockStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBlockStatementContext)
}

func (s *FunctionDeclarationContext) Attributes() IAttributesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAttributesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAttributesContext)
}

func (s *FunctionDeclarationContext) Ampersand() antlr.TerminalNode {
	return s.GetToken(PHPParserAmpersand, 0)
}

func (s *FunctionDeclarationContext) TypeParameterListInBrackets() ITypeParameterListInBracketsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeParameterListInBracketsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeParameterListInBracketsContext)
}

func (s *FunctionDeclarationContext) Colon() antlr.TerminalNode {
	return s.GetToken(PHPParserColon, 0)
}

func (s *FunctionDeclarationContext) TypeHint() ITypeHintContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeHintContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeHintContext)
}

func (s *FunctionDeclarationContext) QuestionMark() antlr.TerminalNode {
	return s.GetToken(PHPParserQuestionMark, 0)
}

func (s *FunctionDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FunctionDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FunctionDeclarationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PHPParserVisitor:
		return t.VisitFunctionDeclaration(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PHPParser) FunctionDeclaration() (localctx IFunctionDeclarationContext) {
	this := p
	_ = this

	localctx = NewFunctionDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 26, PHPParserRULE_functionDeclaration)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(409)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == PHPParserAttributeStart {
		{
			p.SetState(408)
			p.Attributes()
		}

	}
	{
		p.SetState(411)
		p.Match(PHPParserFunction_)
	}
	p.SetState(413)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == PHPParserAmpersand {
		{
			p.SetState(412)
			p.Match(PHPParserAmpersand)
		}

	}
	{
		p.SetState(415)
		p.Identifier()
	}
	p.SetState(417)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == PHPParserLgeneric {
		{
			p.SetState(416)
			p.TypeParameterListInBrackets()
		}

	}
	{
		p.SetState(419)
		p.Match(PHPParserOpenRoundBracket)
	}
	{
		p.SetState(420)
		p.FormalParameterList()
	}
	{
		p.SetState(421)
		p.Match(PHPParserCloseRoundBracket)
	}
	p.SetState(427)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == PHPParserColon {
		{
			p.SetState(422)
			p.Match(PHPParserColon)
		}
		p.SetState(424)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == PHPParserQuestionMark {
			{
				p.SetState(423)
				p.Match(PHPParserQuestionMark)
			}

		}
		{
			p.SetState(426)
			p.typeHint(0)
		}

	}
	{
		p.SetState(429)
		p.BlockStatement()
	}

	return localctx
}

// IClassDeclarationContext is an interface to support dynamic dispatch.
type IClassDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsClassDeclarationContext differentiates from other interfaces.
	IsClassDeclarationContext()
}

type ClassDeclarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyClassDeclarationContext() *ClassDeclarationContext {
	var p = new(ClassDeclarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PHPParserRULE_classDeclaration
	return p
}

func (*ClassDeclarationContext) IsClassDeclarationContext() {}

func NewClassDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ClassDeclarationContext {
	var p = new(ClassDeclarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PHPParserRULE_classDeclaration

	return p
}

func (s *ClassDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *ClassDeclarationContext) OpenCurlyBracket() antlr.TerminalNode {
	return s.GetToken(PHPParserOpenCurlyBracket, 0)
}

func (s *ClassDeclarationContext) CloseCurlyBracket() antlr.TerminalNode {
	return s.GetToken(PHPParserCloseCurlyBracket, 0)
}

func (s *ClassDeclarationContext) ClassEntryType() IClassEntryTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClassEntryTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClassEntryTypeContext)
}

func (s *ClassDeclarationContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ClassDeclarationContext) Interface() antlr.TerminalNode {
	return s.GetToken(PHPParserInterface, 0)
}

func (s *ClassDeclarationContext) Attributes() IAttributesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAttributesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAttributesContext)
}

func (s *ClassDeclarationContext) Private() antlr.TerminalNode {
	return s.GetToken(PHPParserPrivate, 0)
}

func (s *ClassDeclarationContext) Modifier() IModifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IModifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IModifierContext)
}

func (s *ClassDeclarationContext) Partial() antlr.TerminalNode {
	return s.GetToken(PHPParserPartial, 0)
}

func (s *ClassDeclarationContext) AllClassStatement() []IClassStatementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IClassStatementContext); ok {
			len++
		}
	}

	tst := make([]IClassStatementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IClassStatementContext); ok {
			tst[i] = t.(IClassStatementContext)
			i++
		}
	}

	return tst
}

func (s *ClassDeclarationContext) ClassStatement(i int) IClassStatementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClassStatementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClassStatementContext)
}

func (s *ClassDeclarationContext) TypeParameterListInBrackets() ITypeParameterListInBracketsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeParameterListInBracketsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeParameterListInBracketsContext)
}

func (s *ClassDeclarationContext) Extends() antlr.TerminalNode {
	return s.GetToken(PHPParserExtends, 0)
}

func (s *ClassDeclarationContext) QualifiedStaticTypeRef() IQualifiedStaticTypeRefContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedStaticTypeRefContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedStaticTypeRefContext)
}

func (s *ClassDeclarationContext) Implements() antlr.TerminalNode {
	return s.GetToken(PHPParserImplements, 0)
}

func (s *ClassDeclarationContext) InterfaceList() IInterfaceListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInterfaceListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInterfaceListContext)
}

func (s *ClassDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ClassDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ClassDeclarationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PHPParserVisitor:
		return t.VisitClassDeclaration(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PHPParser) ClassDeclaration() (localctx IClassDeclarationContext) {
	this := p
	_ = this

	localctx = NewClassDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 28, PHPParserRULE_classDeclaration)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(432)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == PHPParserAttributeStart {
		{
			p.SetState(431)
			p.Attributes()
		}

	}
	p.SetState(435)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == PHPParserPrivate {
		{
			p.SetState(434)
			p.Match(PHPParserPrivate)
		}

	}
	p.SetState(438)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == PHPParserAbstract || _la == PHPParserFinal {
		{
			p.SetState(437)
			p.Modifier()
		}

	}
	p.SetState(441)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == PHPParserPartial {
		{
			p.SetState(440)
			p.Match(PHPParserPartial)
		}

	}
	p.SetState(465)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case PHPParserClass, PHPParserTrait:
		{
			p.SetState(443)
			p.ClassEntryType()
		}
		{
			p.SetState(444)
			p.Identifier()
		}
		p.SetState(446)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == PHPParserLgeneric {
			{
				p.SetState(445)
				p.TypeParameterListInBrackets()
			}

		}
		p.SetState(450)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == PHPParserExtends {
			{
				p.SetState(448)
				p.Match(PHPParserExtends)
			}
			{
				p.SetState(449)
				p.QualifiedStaticTypeRef()
			}

		}
		p.SetState(454)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == PHPParserImplements {
			{
				p.SetState(452)
				p.Match(PHPParserImplements)
			}
			{
				p.SetState(453)
				p.InterfaceList()
			}

		}

	case PHPParserInterface:
		{
			p.SetState(456)
			p.Match(PHPParserInterface)
		}
		{
			p.SetState(457)
			p.Identifier()
		}
		p.SetState(459)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == PHPParserLgeneric {
			{
				p.SetState(458)
				p.TypeParameterListInBrackets()
			}

		}
		p.SetState(463)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == PHPParserExtends {
			{
				p.SetState(461)
				p.Match(PHPParserExtends)
			}
			{
				p.SetState(462)
				p.InterfaceList()
			}

		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}
	{
		p.SetState(467)
		p.Match(PHPParserOpenCurlyBracket)
	}
	p.SetState(471)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for (int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&72083982316994560) != 0 || (int64((_la-77)) & ^0x3f) == 0 && ((int64(1)<<(_la-77))&6757727313330209) != 0 {
		{
			p.SetState(468)
			p.ClassStatement()
		}

		p.SetState(473)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(474)
		p.Match(PHPParserCloseCurlyBracket)
	}

	return localctx
}

// IClassEntryTypeContext is an interface to support dynamic dispatch.
type IClassEntryTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsClassEntryTypeContext differentiates from other interfaces.
	IsClassEntryTypeContext()
}

type ClassEntryTypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyClassEntryTypeContext() *ClassEntryTypeContext {
	var p = new(ClassEntryTypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PHPParserRULE_classEntryType
	return p
}

func (*ClassEntryTypeContext) IsClassEntryTypeContext() {}

func NewClassEntryTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ClassEntryTypeContext {
	var p = new(ClassEntryTypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PHPParserRULE_classEntryType

	return p
}

func (s *ClassEntryTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *ClassEntryTypeContext) Class() antlr.TerminalNode {
	return s.GetToken(PHPParserClass, 0)
}

func (s *ClassEntryTypeContext) Trait() antlr.TerminalNode {
	return s.GetToken(PHPParserTrait, 0)
}

func (s *ClassEntryTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ClassEntryTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ClassEntryTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PHPParserVisitor:
		return t.VisitClassEntryType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PHPParser) ClassEntryType() (localctx IClassEntryTypeContext) {
	this := p
	_ = this

	localctx = NewClassEntryTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 30, PHPParserRULE_classEntryType)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(476)
		_la = p.GetTokenStream().LA(1)

		if !(_la == PHPParserClass || _la == PHPParserTrait) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IInterfaceListContext is an interface to support dynamic dispatch.
type IInterfaceListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInterfaceListContext differentiates from other interfaces.
	IsInterfaceListContext()
}

type InterfaceListContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInterfaceListContext() *InterfaceListContext {
	var p = new(InterfaceListContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PHPParserRULE_interfaceList
	return p
}

func (*InterfaceListContext) IsInterfaceListContext() {}

func NewInterfaceListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InterfaceListContext {
	var p = new(InterfaceListContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PHPParserRULE_interfaceList

	return p
}

func (s *InterfaceListContext) GetParser() antlr.Parser { return s.parser }

func (s *InterfaceListContext) AllQualifiedStaticTypeRef() []IQualifiedStaticTypeRefContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IQualifiedStaticTypeRefContext); ok {
			len++
		}
	}

	tst := make([]IQualifiedStaticTypeRefContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IQualifiedStaticTypeRefContext); ok {
			tst[i] = t.(IQualifiedStaticTypeRefContext)
			i++
		}
	}

	return tst
}

func (s *InterfaceListContext) QualifiedStaticTypeRef(i int) IQualifiedStaticTypeRefContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedStaticTypeRefContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedStaticTypeRefContext)
}

func (s *InterfaceListContext) AllComma() []antlr.TerminalNode {
	return s.GetTokens(PHPParserComma)
}

func (s *InterfaceListContext) Comma(i int) antlr.TerminalNode {
	return s.GetToken(PHPParserComma, i)
}

func (s *InterfaceListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InterfaceListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InterfaceListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PHPParserVisitor:
		return t.VisitInterfaceList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PHPParser) InterfaceList() (localctx IInterfaceListContext) {
	this := p
	_ = this

	localctx = NewInterfaceListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 32, PHPParserRULE_interfaceList)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(478)
		p.QualifiedStaticTypeRef()
	}
	p.SetState(483)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == PHPParserComma {
		{
			p.SetState(479)
			p.Match(PHPParserComma)
		}
		{
			p.SetState(480)
			p.QualifiedStaticTypeRef()
		}

		p.SetState(485)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// ITypeParameterListInBracketsContext is an interface to support dynamic dispatch.
type ITypeParameterListInBracketsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTypeParameterListInBracketsContext differentiates from other interfaces.
	IsTypeParameterListInBracketsContext()
}

type TypeParameterListInBracketsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeParameterListInBracketsContext() *TypeParameterListInBracketsContext {
	var p = new(TypeParameterListInBracketsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PHPParserRULE_typeParameterListInBrackets
	return p
}

func (*TypeParameterListInBracketsContext) IsTypeParameterListInBracketsContext() {}

func NewTypeParameterListInBracketsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeParameterListInBracketsContext {
	var p = new(TypeParameterListInBracketsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PHPParserRULE_typeParameterListInBrackets

	return p
}

func (s *TypeParameterListInBracketsContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeParameterListInBracketsContext) Lgeneric() antlr.TerminalNode {
	return s.GetToken(PHPParserLgeneric, 0)
}

func (s *TypeParameterListInBracketsContext) TypeParameterList() ITypeParameterListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeParameterListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeParameterListContext)
}

func (s *TypeParameterListInBracketsContext) Rgeneric() antlr.TerminalNode {
	return s.GetToken(PHPParserRgeneric, 0)
}

func (s *TypeParameterListInBracketsContext) TypeParameterWithDefaultsList() ITypeParameterWithDefaultsListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeParameterWithDefaultsListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeParameterWithDefaultsListContext)
}

func (s *TypeParameterListInBracketsContext) Comma() antlr.TerminalNode {
	return s.GetToken(PHPParserComma, 0)
}

func (s *TypeParameterListInBracketsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeParameterListInBracketsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeParameterListInBracketsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PHPParserVisitor:
		return t.VisitTypeParameterListInBrackets(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PHPParser) TypeParameterListInBrackets() (localctx ITypeParameterListInBracketsContext) {
	this := p
	_ = this

	localctx = NewTypeParameterListInBracketsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 34, PHPParserRULE_typeParameterListInBrackets)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(500)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 36, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(486)
			p.Match(PHPParserLgeneric)
		}
		{
			p.SetState(487)
			p.TypeParameterList()
		}
		{
			p.SetState(488)
			p.Match(PHPParserRgeneric)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(490)
			p.Match(PHPParserLgeneric)
		}
		{
			p.SetState(491)
			p.TypeParameterWithDefaultsList()
		}
		{
			p.SetState(492)
			p.Match(PHPParserRgeneric)
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(494)
			p.Match(PHPParserLgeneric)
		}
		{
			p.SetState(495)
			p.TypeParameterList()
		}
		{
			p.SetState(496)
			p.Match(PHPParserComma)
		}
		{
			p.SetState(497)
			p.TypeParameterWithDefaultsList()
		}
		{
			p.SetState(498)
			p.Match(PHPParserRgeneric)
		}

	}

	return localctx
}

// ITypeParameterListContext is an interface to support dynamic dispatch.
type ITypeParameterListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTypeParameterListContext differentiates from other interfaces.
	IsTypeParameterListContext()
}

type TypeParameterListContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeParameterListContext() *TypeParameterListContext {
	var p = new(TypeParameterListContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PHPParserRULE_typeParameterList
	return p
}

func (*TypeParameterListContext) IsTypeParameterListContext() {}

func NewTypeParameterListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeParameterListContext {
	var p = new(TypeParameterListContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PHPParserRULE_typeParameterList

	return p
}

func (s *TypeParameterListContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeParameterListContext) AllTypeParameterDecl() []ITypeParameterDeclContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITypeParameterDeclContext); ok {
			len++
		}
	}

	tst := make([]ITypeParameterDeclContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITypeParameterDeclContext); ok {
			tst[i] = t.(ITypeParameterDeclContext)
			i++
		}
	}

	return tst
}

func (s *TypeParameterListContext) TypeParameterDecl(i int) ITypeParameterDeclContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeParameterDeclContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeParameterDeclContext)
}

func (s *TypeParameterListContext) AllComma() []antlr.TerminalNode {
	return s.GetTokens(PHPParserComma)
}

func (s *TypeParameterListContext) Comma(i int) antlr.TerminalNode {
	return s.GetToken(PHPParserComma, i)
}

func (s *TypeParameterListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeParameterListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeParameterListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PHPParserVisitor:
		return t.VisitTypeParameterList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PHPParser) TypeParameterList() (localctx ITypeParameterListContext) {
	this := p
	_ = this

	localctx = NewTypeParameterListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 36, PHPParserRULE_typeParameterList)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(502)
		p.TypeParameterDecl()
	}
	p.SetState(507)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 37, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(503)
				p.Match(PHPParserComma)
			}
			{
				p.SetState(504)
				p.TypeParameterDecl()
			}

		}
		p.SetState(509)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 37, p.GetParserRuleContext())
	}

	return localctx
}

// ITypeParameterWithDefaultsListContext is an interface to support dynamic dispatch.
type ITypeParameterWithDefaultsListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTypeParameterWithDefaultsListContext differentiates from other interfaces.
	IsTypeParameterWithDefaultsListContext()
}

type TypeParameterWithDefaultsListContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeParameterWithDefaultsListContext() *TypeParameterWithDefaultsListContext {
	var p = new(TypeParameterWithDefaultsListContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PHPParserRULE_typeParameterWithDefaultsList
	return p
}

func (*TypeParameterWithDefaultsListContext) IsTypeParameterWithDefaultsListContext() {}

func NewTypeParameterWithDefaultsListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeParameterWithDefaultsListContext {
	var p = new(TypeParameterWithDefaultsListContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PHPParserRULE_typeParameterWithDefaultsList

	return p
}

func (s *TypeParameterWithDefaultsListContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeParameterWithDefaultsListContext) AllTypeParameterWithDefaultDecl() []ITypeParameterWithDefaultDeclContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITypeParameterWithDefaultDeclContext); ok {
			len++
		}
	}

	tst := make([]ITypeParameterWithDefaultDeclContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITypeParameterWithDefaultDeclContext); ok {
			tst[i] = t.(ITypeParameterWithDefaultDeclContext)
			i++
		}
	}

	return tst
}

func (s *TypeParameterWithDefaultsListContext) TypeParameterWithDefaultDecl(i int) ITypeParameterWithDefaultDeclContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeParameterWithDefaultDeclContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeParameterWithDefaultDeclContext)
}

func (s *TypeParameterWithDefaultsListContext) AllComma() []antlr.TerminalNode {
	return s.GetTokens(PHPParserComma)
}

func (s *TypeParameterWithDefaultsListContext) Comma(i int) antlr.TerminalNode {
	return s.GetToken(PHPParserComma, i)
}

func (s *TypeParameterWithDefaultsListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeParameterWithDefaultsListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeParameterWithDefaultsListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PHPParserVisitor:
		return t.VisitTypeParameterWithDefaultsList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PHPParser) TypeParameterWithDefaultsList() (localctx ITypeParameterWithDefaultsListContext) {
	this := p
	_ = this

	localctx = NewTypeParameterWithDefaultsListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 38, PHPParserRULE_typeParameterWithDefaultsList)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(510)
		p.TypeParameterWithDefaultDecl()
	}
	p.SetState(515)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == PHPParserComma {
		{
			p.SetState(511)
			p.Match(PHPParserComma)
		}
		{
			p.SetState(512)
			p.TypeParameterWithDefaultDecl()
		}

		p.SetState(517)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// ITypeParameterDeclContext is an interface to support dynamic dispatch.
type ITypeParameterDeclContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTypeParameterDeclContext differentiates from other interfaces.
	IsTypeParameterDeclContext()
}

type TypeParameterDeclContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeParameterDeclContext() *TypeParameterDeclContext {
	var p = new(TypeParameterDeclContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PHPParserRULE_typeParameterDecl
	return p
}

func (*TypeParameterDeclContext) IsTypeParameterDeclContext() {}

func NewTypeParameterDeclContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeParameterDeclContext {
	var p = new(TypeParameterDeclContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PHPParserRULE_typeParameterDecl

	return p
}

func (s *TypeParameterDeclContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeParameterDeclContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *TypeParameterDeclContext) Attributes() IAttributesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAttributesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAttributesContext)
}

func (s *TypeParameterDeclContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeParameterDeclContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeParameterDeclContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PHPParserVisitor:
		return t.VisitTypeParameterDecl(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PHPParser) TypeParameterDecl() (localctx ITypeParameterDeclContext) {
	this := p
	_ = this

	localctx = NewTypeParameterDeclContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 40, PHPParserRULE_typeParameterDecl)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(519)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == PHPParserAttributeStart {
		{
			p.SetState(518)
			p.Attributes()
		}

	}
	{
		p.SetState(521)
		p.Identifier()
	}

	return localctx
}

// ITypeParameterWithDefaultDeclContext is an interface to support dynamic dispatch.
type ITypeParameterWithDefaultDeclContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTypeParameterWithDefaultDeclContext differentiates from other interfaces.
	IsTypeParameterWithDefaultDeclContext()
}

type TypeParameterWithDefaultDeclContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeParameterWithDefaultDeclContext() *TypeParameterWithDefaultDeclContext {
	var p = new(TypeParameterWithDefaultDeclContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PHPParserRULE_typeParameterWithDefaultDecl
	return p
}

func (*TypeParameterWithDefaultDeclContext) IsTypeParameterWithDefaultDeclContext() {}

func NewTypeParameterWithDefaultDeclContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeParameterWithDefaultDeclContext {
	var p = new(TypeParameterWithDefaultDeclContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PHPParserRULE_typeParameterWithDefaultDecl

	return p
}

func (s *TypeParameterWithDefaultDeclContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeParameterWithDefaultDeclContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *TypeParameterWithDefaultDeclContext) Eq() antlr.TerminalNode {
	return s.GetToken(PHPParserEq, 0)
}

func (s *TypeParameterWithDefaultDeclContext) QualifiedStaticTypeRef() IQualifiedStaticTypeRefContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedStaticTypeRefContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedStaticTypeRefContext)
}

func (s *TypeParameterWithDefaultDeclContext) PrimitiveType() IPrimitiveTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrimitiveTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrimitiveTypeContext)
}

func (s *TypeParameterWithDefaultDeclContext) Attributes() IAttributesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAttributesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAttributesContext)
}

func (s *TypeParameterWithDefaultDeclContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeParameterWithDefaultDeclContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeParameterWithDefaultDeclContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PHPParserVisitor:
		return t.VisitTypeParameterWithDefaultDecl(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PHPParser) TypeParameterWithDefaultDecl() (localctx ITypeParameterWithDefaultDeclContext) {
	this := p
	_ = this

	localctx = NewTypeParameterWithDefaultDeclContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 42, PHPParserRULE_typeParameterWithDefaultDecl)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(524)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == PHPParserAttributeStart {
		{
			p.SetState(523)
			p.Attributes()
		}

	}
	{
		p.SetState(526)
		p.Identifier()
	}
	{
		p.SetState(527)
		p.Match(PHPParserEq)
	}
	p.SetState(530)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 41, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(528)
			p.QualifiedStaticTypeRef()
		}

	case 2:
		{
			p.SetState(529)
			p.PrimitiveType()
		}

	}

	return localctx
}

// IGenericDynamicArgsContext is an interface to support dynamic dispatch.
type IGenericDynamicArgsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsGenericDynamicArgsContext differentiates from other interfaces.
	IsGenericDynamicArgsContext()
}

type GenericDynamicArgsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGenericDynamicArgsContext() *GenericDynamicArgsContext {
	var p = new(GenericDynamicArgsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PHPParserRULE_genericDynamicArgs
	return p
}

func (*GenericDynamicArgsContext) IsGenericDynamicArgsContext() {}

func NewGenericDynamicArgsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GenericDynamicArgsContext {
	var p = new(GenericDynamicArgsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PHPParserRULE_genericDynamicArgs

	return p
}

func (s *GenericDynamicArgsContext) GetParser() antlr.Parser { return s.parser }

func (s *GenericDynamicArgsContext) Lgeneric() antlr.TerminalNode {
	return s.GetToken(PHPParserLgeneric, 0)
}

func (s *GenericDynamicArgsContext) AllTypeRef() []ITypeRefContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITypeRefContext); ok {
			len++
		}
	}

	tst := make([]ITypeRefContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITypeRefContext); ok {
			tst[i] = t.(ITypeRefContext)
			i++
		}
	}

	return tst
}

func (s *GenericDynamicArgsContext) TypeRef(i int) ITypeRefContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeRefContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeRefContext)
}

func (s *GenericDynamicArgsContext) Rgeneric() antlr.TerminalNode {
	return s.GetToken(PHPParserRgeneric, 0)
}

func (s *GenericDynamicArgsContext) AllComma() []antlr.TerminalNode {
	return s.GetTokens(PHPParserComma)
}

func (s *GenericDynamicArgsContext) Comma(i int) antlr.TerminalNode {
	return s.GetToken(PHPParserComma, i)
}

func (s *GenericDynamicArgsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GenericDynamicArgsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GenericDynamicArgsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PHPParserVisitor:
		return t.VisitGenericDynamicArgs(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PHPParser) GenericDynamicArgs() (localctx IGenericDynamicArgsContext) {
	this := p
	_ = this

	localctx = NewGenericDynamicArgsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 44, PHPParserRULE_genericDynamicArgs)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(532)
		p.Match(PHPParserLgeneric)
	}
	{
		p.SetState(533)
		p.TypeRef()
	}
	p.SetState(538)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == PHPParserComma {
		{
			p.SetState(534)
			p.Match(PHPParserComma)
		}
		{
			p.SetState(535)
			p.TypeRef()
		}

		p.SetState(540)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(541)
		p.Match(PHPParserRgeneric)
	}

	return localctx
}

// IAttributesContext is an interface to support dynamic dispatch.
type IAttributesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAttributesContext differentiates from other interfaces.
	IsAttributesContext()
}

type AttributesContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAttributesContext() *AttributesContext {
	var p = new(AttributesContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PHPParserRULE_attributes
	return p
}

func (*AttributesContext) IsAttributesContext() {}

func NewAttributesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AttributesContext {
	var p = new(AttributesContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PHPParserRULE_attributes

	return p
}

func (s *AttributesContext) GetParser() antlr.Parser { return s.parser }

func (s *AttributesContext) AllAttributeGroup() []IAttributeGroupContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAttributeGroupContext); ok {
			len++
		}
	}

	tst := make([]IAttributeGroupContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAttributeGroupContext); ok {
			tst[i] = t.(IAttributeGroupContext)
			i++
		}
	}

	return tst
}

func (s *AttributesContext) AttributeGroup(i int) IAttributeGroupContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAttributeGroupContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAttributeGroupContext)
}

func (s *AttributesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AttributesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AttributesContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PHPParserVisitor:
		return t.VisitAttributes(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PHPParser) Attributes() (localctx IAttributesContext) {
	this := p
	_ = this

	localctx = NewAttributesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 46, PHPParserRULE_attributes)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(544)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = _la == PHPParserAttributeStart {
		{
			p.SetState(543)
			p.AttributeGroup()
		}

		p.SetState(546)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IAttributeGroupContext is an interface to support dynamic dispatch.
type IAttributeGroupContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAttributeGroupContext differentiates from other interfaces.
	IsAttributeGroupContext()
}

type AttributeGroupContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAttributeGroupContext() *AttributeGroupContext {
	var p = new(AttributeGroupContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PHPParserRULE_attributeGroup
	return p
}

func (*AttributeGroupContext) IsAttributeGroupContext() {}

func NewAttributeGroupContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AttributeGroupContext {
	var p = new(AttributeGroupContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PHPParserRULE_attributeGroup

	return p
}

func (s *AttributeGroupContext) GetParser() antlr.Parser { return s.parser }

func (s *AttributeGroupContext) AttributeStart() antlr.TerminalNode {
	return s.GetToken(PHPParserAttributeStart, 0)
}

func (s *AttributeGroupContext) AllAttribute() []IAttributeContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAttributeContext); ok {
			len++
		}
	}

	tst := make([]IAttributeContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAttributeContext); ok {
			tst[i] = t.(IAttributeContext)
			i++
		}
	}

	return tst
}

func (s *AttributeGroupContext) Attribute(i int) IAttributeContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAttributeContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAttributeContext)
}

func (s *AttributeGroupContext) CloseSquareBracket() antlr.TerminalNode {
	return s.GetToken(PHPParserCloseSquareBracket, 0)
}

func (s *AttributeGroupContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *AttributeGroupContext) Colon() antlr.TerminalNode {
	return s.GetToken(PHPParserColon, 0)
}

func (s *AttributeGroupContext) AllComma() []antlr.TerminalNode {
	return s.GetTokens(PHPParserComma)
}

func (s *AttributeGroupContext) Comma(i int) antlr.TerminalNode {
	return s.GetToken(PHPParserComma, i)
}

func (s *AttributeGroupContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AttributeGroupContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AttributeGroupContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PHPParserVisitor:
		return t.VisitAttributeGroup(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PHPParser) AttributeGroup() (localctx IAttributeGroupContext) {
	this := p
	_ = this

	localctx = NewAttributeGroupContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 48, PHPParserRULE_attributeGroup)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(548)
		p.Match(PHPParserAttributeStart)
	}
	p.SetState(552)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 44, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(549)
			p.Identifier()
		}
		{
			p.SetState(550)
			p.Match(PHPParserColon)
		}

	}
	{
		p.SetState(554)
		p.Attribute()
	}
	p.SetState(559)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == PHPParserComma {
		{
			p.SetState(555)
			p.Match(PHPParserComma)
		}
		{
			p.SetState(556)
			p.Attribute()
		}

		p.SetState(561)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(562)
		p.Match(PHPParserCloseSquareBracket)
	}

	return localctx
}

// IAttributeContext is an interface to support dynamic dispatch.
type IAttributeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAttributeContext differentiates from other interfaces.
	IsAttributeContext()
}

type AttributeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAttributeContext() *AttributeContext {
	var p = new(AttributeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PHPParserRULE_attribute
	return p
}

func (*AttributeContext) IsAttributeContext() {}

func NewAttributeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AttributeContext {
	var p = new(AttributeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PHPParserRULE_attribute

	return p
}

func (s *AttributeContext) GetParser() antlr.Parser { return s.parser }

func (s *AttributeContext) QualifiedNamespaceName() IQualifiedNamespaceNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNamespaceNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNamespaceNameContext)
}

func (s *AttributeContext) Arguments() IArgumentsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArgumentsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArgumentsContext)
}

func (s *AttributeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AttributeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AttributeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PHPParserVisitor:
		return t.VisitAttribute(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PHPParser) Attribute() (localctx IAttributeContext) {
	this := p
	_ = this

	localctx = NewAttributeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 50, PHPParserRULE_attribute)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(564)
		p.QualifiedNamespaceName()
	}
	p.SetState(566)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == PHPParserOpenRoundBracket {
		{
			p.SetState(565)
			p.Arguments()
		}

	}

	return localctx
}

// IInnerStatementListContext is an interface to support dynamic dispatch.
type IInnerStatementListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInnerStatementListContext differentiates from other interfaces.
	IsInnerStatementListContext()
}

type InnerStatementListContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInnerStatementListContext() *InnerStatementListContext {
	var p = new(InnerStatementListContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PHPParserRULE_innerStatementList
	return p
}

func (*InnerStatementListContext) IsInnerStatementListContext() {}

func NewInnerStatementListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InnerStatementListContext {
	var p = new(InnerStatementListContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PHPParserRULE_innerStatementList

	return p
}

func (s *InnerStatementListContext) GetParser() antlr.Parser { return s.parser }

func (s *InnerStatementListContext) AllInnerStatement() []IInnerStatementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IInnerStatementContext); ok {
			len++
		}
	}

	tst := make([]IInnerStatementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IInnerStatementContext); ok {
			tst[i] = t.(IInnerStatementContext)
			i++
		}
	}

	return tst
}

func (s *InnerStatementListContext) InnerStatement(i int) IInnerStatementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInnerStatementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInnerStatementContext)
}

func (s *InnerStatementListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InnerStatementListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InnerStatementListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PHPParserVisitor:
		return t.VisitInnerStatementList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PHPParser) InnerStatementList() (localctx IInnerStatementListContext) {
	this := p
	_ = this

	localctx = NewInnerStatementListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 52, PHPParserRULE_innerStatementList)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(571)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 47, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(568)
				p.InnerStatement()
			}

		}
		p.SetState(573)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 47, p.GetParserRuleContext())
	}

	return localctx
}

// IInnerStatementContext is an interface to support dynamic dispatch.
type IInnerStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInnerStatementContext differentiates from other interfaces.
	IsInnerStatementContext()
}

type InnerStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInnerStatementContext() *InnerStatementContext {
	var p = new(InnerStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PHPParserRULE_innerStatement
	return p
}

func (*InnerStatementContext) IsInnerStatementContext() {}

func NewInnerStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InnerStatementContext {
	var p = new(InnerStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PHPParserRULE_innerStatement

	return p
}

func (s *InnerStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *InnerStatementContext) Statement() IStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *InnerStatementContext) FunctionDeclaration() IFunctionDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionDeclarationContext)
}

func (s *InnerStatementContext) ClassDeclaration() IClassDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClassDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClassDeclarationContext)
}

func (s *InnerStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InnerStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InnerStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PHPParserVisitor:
		return t.VisitInnerStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PHPParser) InnerStatement() (localctx IInnerStatementContext) {
	this := p
	_ = this

	localctx = NewInnerStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 54, PHPParserRULE_innerStatement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(577)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 48, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(574)
			p.Statement()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(575)
			p.FunctionDeclaration()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(576)
			p.ClassDeclaration()
		}

	}

	return localctx
}

// IStatementContext is an interface to support dynamic dispatch.
type IStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsStatementContext differentiates from other interfaces.
	IsStatementContext()
}

type StatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStatementContext() *StatementContext {
	var p = new(StatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PHPParserRULE_statement
	return p
}

func (*StatementContext) IsStatementContext() {}

func NewStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StatementContext {
	var p = new(StatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PHPParserRULE_statement

	return p
}

func (s *StatementContext) GetParser() antlr.Parser { return s.parser }

func (s *StatementContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *StatementContext) Colon() antlr.TerminalNode {
	return s.GetToken(PHPParserColon, 0)
}

func (s *StatementContext) BlockStatement() IBlockStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBlockStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBlockStatementContext)
}

func (s *StatementContext) IfStatement() IIfStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIfStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIfStatementContext)
}

func (s *StatementContext) WhileStatement() IWhileStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWhileStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWhileStatementContext)
}

func (s *StatementContext) DoWhileStatement() IDoWhileStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDoWhileStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDoWhileStatementContext)
}

func (s *StatementContext) ForStatement() IForStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IForStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IForStatementContext)
}

func (s *StatementContext) SwitchStatement() ISwitchStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISwitchStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISwitchStatementContext)
}

func (s *StatementContext) BreakStatement() IBreakStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBreakStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBreakStatementContext)
}

func (s *StatementContext) ContinueStatement() IContinueStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IContinueStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IContinueStatementContext)
}

func (s *StatementContext) ReturnStatement() IReturnStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReturnStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReturnStatementContext)
}

func (s *StatementContext) YieldExpression() IYieldExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IYieldExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IYieldExpressionContext)
}

func (s *StatementContext) SemiColon() antlr.TerminalNode {
	return s.GetToken(PHPParserSemiColon, 0)
}

func (s *StatementContext) GlobalStatement() IGlobalStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGlobalStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGlobalStatementContext)
}

func (s *StatementContext) StaticVariableStatement() IStaticVariableStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStaticVariableStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStaticVariableStatementContext)
}

func (s *StatementContext) EchoStatement() IEchoStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEchoStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEchoStatementContext)
}

func (s *StatementContext) ExpressionStatement() IExpressionStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionStatementContext)
}

func (s *StatementContext) UnsetStatement() IUnsetStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnsetStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnsetStatementContext)
}

func (s *StatementContext) ForeachStatement() IForeachStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IForeachStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IForeachStatementContext)
}

func (s *StatementContext) TryCatchFinally() ITryCatchFinallyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITryCatchFinallyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITryCatchFinallyContext)
}

func (s *StatementContext) ThrowStatement() IThrowStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IThrowStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IThrowStatementContext)
}

func (s *StatementContext) GotoStatement() IGotoStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGotoStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGotoStatementContext)
}

func (s *StatementContext) DeclareStatement() IDeclareStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDeclareStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDeclareStatementContext)
}

func (s *StatementContext) EmptyStatement_() IEmptyStatement_Context {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEmptyStatement_Context); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEmptyStatement_Context)
}

func (s *StatementContext) InlineHtmlStatement() IInlineHtmlStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInlineHtmlStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInlineHtmlStatementContext)
}

func (s *StatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PHPParserVisitor:
		return t.VisitStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PHPParser) Statement() (localctx IStatementContext) {
	this := p
	_ = this

	localctx = NewStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 56, PHPParserRULE_statement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(606)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 49, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(579)
			p.Identifier()
		}
		{
			p.SetState(580)
			p.Match(PHPParserColon)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(582)
			p.BlockStatement()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(583)
			p.IfStatement()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(584)
			p.WhileStatement()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(585)
			p.DoWhileStatement()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(586)
			p.ForStatement()
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(587)
			p.SwitchStatement()
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(588)
			p.BreakStatement()
		}

	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(589)
			p.ContinueStatement()
		}

	case 10:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(590)
			p.ReturnStatement()
		}

	case 11:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(591)
			p.YieldExpression()
		}
		{
			p.SetState(592)
			p.Match(PHPParserSemiColon)
		}

	case 12:
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(594)
			p.GlobalStatement()
		}

	case 13:
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(595)
			p.StaticVariableStatement()
		}

	case 14:
		p.EnterOuterAlt(localctx, 14)
		{
			p.SetState(596)
			p.EchoStatement()
		}

	case 15:
		p.EnterOuterAlt(localctx, 15)
		{
			p.SetState(597)
			p.ExpressionStatement()
		}

	case 16:
		p.EnterOuterAlt(localctx, 16)
		{
			p.SetState(598)
			p.UnsetStatement()
		}

	case 17:
		p.EnterOuterAlt(localctx, 17)
		{
			p.SetState(599)
			p.ForeachStatement()
		}

	case 18:
		p.EnterOuterAlt(localctx, 18)
		{
			p.SetState(600)
			p.TryCatchFinally()
		}

	case 19:
		p.EnterOuterAlt(localctx, 19)
		{
			p.SetState(601)
			p.ThrowStatement()
		}

	case 20:
		p.EnterOuterAlt(localctx, 20)
		{
			p.SetState(602)
			p.GotoStatement()
		}

	case 21:
		p.EnterOuterAlt(localctx, 21)
		{
			p.SetState(603)
			p.DeclareStatement()
		}

	case 22:
		p.EnterOuterAlt(localctx, 22)
		{
			p.SetState(604)
			p.EmptyStatement_()
		}

	case 23:
		p.EnterOuterAlt(localctx, 23)
		{
			p.SetState(605)
			p.InlineHtmlStatement()
		}

	}

	return localctx
}

// IEmptyStatement_Context is an interface to support dynamic dispatch.
type IEmptyStatement_Context interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEmptyStatement_Context differentiates from other interfaces.
	IsEmptyStatement_Context()
}

type EmptyStatement_Context struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEmptyStatement_Context() *EmptyStatement_Context {
	var p = new(EmptyStatement_Context)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PHPParserRULE_emptyStatement_
	return p
}

func (*EmptyStatement_Context) IsEmptyStatement_Context() {}

func NewEmptyStatement_Context(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EmptyStatement_Context {
	var p = new(EmptyStatement_Context)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PHPParserRULE_emptyStatement_

	return p
}

func (s *EmptyStatement_Context) GetParser() antlr.Parser { return s.parser }

func (s *EmptyStatement_Context) SemiColon() antlr.TerminalNode {
	return s.GetToken(PHPParserSemiColon, 0)
}

func (s *EmptyStatement_Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EmptyStatement_Context) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EmptyStatement_Context) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PHPParserVisitor:
		return t.VisitEmptyStatement_(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PHPParser) EmptyStatement_() (localctx IEmptyStatement_Context) {
	this := p
	_ = this

	localctx = NewEmptyStatement_Context(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 58, PHPParserRULE_emptyStatement_)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(608)
		p.Match(PHPParserSemiColon)
	}

	return localctx
}

// IBlockStatementContext is an interface to support dynamic dispatch.
type IBlockStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsBlockStatementContext differentiates from other interfaces.
	IsBlockStatementContext()
}

type BlockStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBlockStatementContext() *BlockStatementContext {
	var p = new(BlockStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PHPParserRULE_blockStatement
	return p
}

func (*BlockStatementContext) IsBlockStatementContext() {}

func NewBlockStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BlockStatementContext {
	var p = new(BlockStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PHPParserRULE_blockStatement

	return p
}

func (s *BlockStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *BlockStatementContext) OpenCurlyBracket() antlr.TerminalNode {
	return s.GetToken(PHPParserOpenCurlyBracket, 0)
}

func (s *BlockStatementContext) InnerStatementList() IInnerStatementListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInnerStatementListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInnerStatementListContext)
}

func (s *BlockStatementContext) CloseCurlyBracket() antlr.TerminalNode {
	return s.GetToken(PHPParserCloseCurlyBracket, 0)
}

func (s *BlockStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BlockStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BlockStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PHPParserVisitor:
		return t.VisitBlockStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PHPParser) BlockStatement() (localctx IBlockStatementContext) {
	this := p
	_ = this

	localctx = NewBlockStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 60, PHPParserRULE_blockStatement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(610)
		p.Match(PHPParserOpenCurlyBracket)
	}
	{
		p.SetState(611)
		p.InnerStatementList()
	}
	{
		p.SetState(612)
		p.Match(PHPParserCloseCurlyBracket)
	}

	return localctx
}

// IIfStatementContext is an interface to support dynamic dispatch.
type IIfStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsIfStatementContext differentiates from other interfaces.
	IsIfStatementContext()
}

type IfStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIfStatementContext() *IfStatementContext {
	var p = new(IfStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PHPParserRULE_ifStatement
	return p
}

func (*IfStatementContext) IsIfStatementContext() {}

func NewIfStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IfStatementContext {
	var p = new(IfStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PHPParserRULE_ifStatement

	return p
}

func (s *IfStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *IfStatementContext) If() antlr.TerminalNode {
	return s.GetToken(PHPParserIf, 0)
}

func (s *IfStatementContext) Parentheses() IParenthesesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IParenthesesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IParenthesesContext)
}

func (s *IfStatementContext) Statement() IStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *IfStatementContext) AllElseIfStatement() []IElseIfStatementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IElseIfStatementContext); ok {
			len++
		}
	}

	tst := make([]IElseIfStatementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IElseIfStatementContext); ok {
			tst[i] = t.(IElseIfStatementContext)
			i++
		}
	}

	return tst
}

func (s *IfStatementContext) ElseIfStatement(i int) IElseIfStatementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IElseIfStatementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IElseIfStatementContext)
}

func (s *IfStatementContext) ElseStatement() IElseStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IElseStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IElseStatementContext)
}

func (s *IfStatementContext) Colon() antlr.TerminalNode {
	return s.GetToken(PHPParserColon, 0)
}

func (s *IfStatementContext) InnerStatementList() IInnerStatementListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInnerStatementListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInnerStatementListContext)
}

func (s *IfStatementContext) EndIf() antlr.TerminalNode {
	return s.GetToken(PHPParserEndIf, 0)
}

func (s *IfStatementContext) SemiColon() antlr.TerminalNode {
	return s.GetToken(PHPParserSemiColon, 0)
}

func (s *IfStatementContext) AllElseIfColonStatement() []IElseIfColonStatementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IElseIfColonStatementContext); ok {
			len++
		}
	}

	tst := make([]IElseIfColonStatementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IElseIfColonStatementContext); ok {
			tst[i] = t.(IElseIfColonStatementContext)
			i++
		}
	}

	return tst
}

func (s *IfStatementContext) ElseIfColonStatement(i int) IElseIfColonStatementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IElseIfColonStatementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IElseIfColonStatementContext)
}

func (s *IfStatementContext) ElseColonStatement() IElseColonStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IElseColonStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IElseColonStatementContext)
}

func (s *IfStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IfStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IfStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PHPParserVisitor:
		return t.VisitIfStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PHPParser) IfStatement() (localctx IIfStatementContext) {
	this := p
	_ = this

	localctx = NewIfStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 62, PHPParserRULE_ifStatement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.SetState(642)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 54, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(614)
			p.Match(PHPParserIf)
		}
		{
			p.SetState(615)
			p.Parentheses()
		}
		{
			p.SetState(616)
			p.Statement()
		}
		p.SetState(620)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 50, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(617)
					p.ElseIfStatement()
				}

			}
			p.SetState(622)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 50, p.GetParserRuleContext())
		}
		p.SetState(624)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 51, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(623)
				p.ElseStatement()
			}

		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(626)
			p.Match(PHPParserIf)
		}
		{
			p.SetState(627)
			p.Parentheses()
		}
		{
			p.SetState(628)
			p.Match(PHPParserColon)
		}
		{
			p.SetState(629)
			p.InnerStatementList()
		}
		p.SetState(633)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == PHPParserElseIf {
			{
				p.SetState(630)
				p.ElseIfColonStatement()
			}

			p.SetState(635)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		p.SetState(637)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == PHPParserElse {
			{
				p.SetState(636)
				p.ElseColonStatement()
			}

		}
		{
			p.SetState(639)
			p.Match(PHPParserEndIf)
		}
		{
			p.SetState(640)
			p.Match(PHPParserSemiColon)
		}

	}

	return localctx
}

// IElseIfStatementContext is an interface to support dynamic dispatch.
type IElseIfStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsElseIfStatementContext differentiates from other interfaces.
	IsElseIfStatementContext()
}

type ElseIfStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyElseIfStatementContext() *ElseIfStatementContext {
	var p = new(ElseIfStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PHPParserRULE_elseIfStatement
	return p
}

func (*ElseIfStatementContext) IsElseIfStatementContext() {}

func NewElseIfStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ElseIfStatementContext {
	var p = new(ElseIfStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PHPParserRULE_elseIfStatement

	return p
}

func (s *ElseIfStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ElseIfStatementContext) ElseIf() antlr.TerminalNode {
	return s.GetToken(PHPParserElseIf, 0)
}

func (s *ElseIfStatementContext) Parentheses() IParenthesesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IParenthesesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IParenthesesContext)
}

func (s *ElseIfStatementContext) Statement() IStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *ElseIfStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ElseIfStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ElseIfStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PHPParserVisitor:
		return t.VisitElseIfStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PHPParser) ElseIfStatement() (localctx IElseIfStatementContext) {
	this := p
	_ = this

	localctx = NewElseIfStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 64, PHPParserRULE_elseIfStatement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(644)
		p.Match(PHPParserElseIf)
	}
	{
		p.SetState(645)
		p.Parentheses()
	}
	{
		p.SetState(646)
		p.Statement()
	}

	return localctx
}

// IElseIfColonStatementContext is an interface to support dynamic dispatch.
type IElseIfColonStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsElseIfColonStatementContext differentiates from other interfaces.
	IsElseIfColonStatementContext()
}

type ElseIfColonStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyElseIfColonStatementContext() *ElseIfColonStatementContext {
	var p = new(ElseIfColonStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PHPParserRULE_elseIfColonStatement
	return p
}

func (*ElseIfColonStatementContext) IsElseIfColonStatementContext() {}

func NewElseIfColonStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ElseIfColonStatementContext {
	var p = new(ElseIfColonStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PHPParserRULE_elseIfColonStatement

	return p
}

func (s *ElseIfColonStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ElseIfColonStatementContext) ElseIf() antlr.TerminalNode {
	return s.GetToken(PHPParserElseIf, 0)
}

func (s *ElseIfColonStatementContext) Parentheses() IParenthesesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IParenthesesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IParenthesesContext)
}

func (s *ElseIfColonStatementContext) Colon() antlr.TerminalNode {
	return s.GetToken(PHPParserColon, 0)
}

func (s *ElseIfColonStatementContext) InnerStatementList() IInnerStatementListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInnerStatementListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInnerStatementListContext)
}

func (s *ElseIfColonStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ElseIfColonStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ElseIfColonStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PHPParserVisitor:
		return t.VisitElseIfColonStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PHPParser) ElseIfColonStatement() (localctx IElseIfColonStatementContext) {
	this := p
	_ = this

	localctx = NewElseIfColonStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 66, PHPParserRULE_elseIfColonStatement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(648)
		p.Match(PHPParserElseIf)
	}
	{
		p.SetState(649)
		p.Parentheses()
	}
	{
		p.SetState(650)
		p.Match(PHPParserColon)
	}
	{
		p.SetState(651)
		p.InnerStatementList()
	}

	return localctx
}

// IElseStatementContext is an interface to support dynamic dispatch.
type IElseStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsElseStatementContext differentiates from other interfaces.
	IsElseStatementContext()
}

type ElseStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyElseStatementContext() *ElseStatementContext {
	var p = new(ElseStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PHPParserRULE_elseStatement
	return p
}

func (*ElseStatementContext) IsElseStatementContext() {}

func NewElseStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ElseStatementContext {
	var p = new(ElseStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PHPParserRULE_elseStatement

	return p
}

func (s *ElseStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ElseStatementContext) Else() antlr.TerminalNode {
	return s.GetToken(PHPParserElse, 0)
}

func (s *ElseStatementContext) Statement() IStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *ElseStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ElseStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ElseStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PHPParserVisitor:
		return t.VisitElseStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PHPParser) ElseStatement() (localctx IElseStatementContext) {
	this := p
	_ = this

	localctx = NewElseStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 68, PHPParserRULE_elseStatement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(653)
		p.Match(PHPParserElse)
	}
	{
		p.SetState(654)
		p.Statement()
	}

	return localctx
}

// IElseColonStatementContext is an interface to support dynamic dispatch.
type IElseColonStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsElseColonStatementContext differentiates from other interfaces.
	IsElseColonStatementContext()
}

type ElseColonStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyElseColonStatementContext() *ElseColonStatementContext {
	var p = new(ElseColonStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PHPParserRULE_elseColonStatement
	return p
}

func (*ElseColonStatementContext) IsElseColonStatementContext() {}

func NewElseColonStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ElseColonStatementContext {
	var p = new(ElseColonStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PHPParserRULE_elseColonStatement

	return p
}

func (s *ElseColonStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ElseColonStatementContext) Else() antlr.TerminalNode {
	return s.GetToken(PHPParserElse, 0)
}

func (s *ElseColonStatementContext) Colon() antlr.TerminalNode {
	return s.GetToken(PHPParserColon, 0)
}

func (s *ElseColonStatementContext) InnerStatementList() IInnerStatementListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInnerStatementListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInnerStatementListContext)
}

func (s *ElseColonStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ElseColonStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ElseColonStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PHPParserVisitor:
		return t.VisitElseColonStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PHPParser) ElseColonStatement() (localctx IElseColonStatementContext) {
	this := p
	_ = this

	localctx = NewElseColonStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 70, PHPParserRULE_elseColonStatement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(656)
		p.Match(PHPParserElse)
	}
	{
		p.SetState(657)
		p.Match(PHPParserColon)
	}
	{
		p.SetState(658)
		p.InnerStatementList()
	}

	return localctx
}

// IWhileStatementContext is an interface to support dynamic dispatch.
type IWhileStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsWhileStatementContext differentiates from other interfaces.
	IsWhileStatementContext()
}

type WhileStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWhileStatementContext() *WhileStatementContext {
	var p = new(WhileStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PHPParserRULE_whileStatement
	return p
}

func (*WhileStatementContext) IsWhileStatementContext() {}

func NewWhileStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WhileStatementContext {
	var p = new(WhileStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PHPParserRULE_whileStatement

	return p
}

func (s *WhileStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *WhileStatementContext) While() antlr.TerminalNode {
	return s.GetToken(PHPParserWhile, 0)
}

func (s *WhileStatementContext) Parentheses() IParenthesesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IParenthesesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IParenthesesContext)
}

func (s *WhileStatementContext) Statement() IStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *WhileStatementContext) Colon() antlr.TerminalNode {
	return s.GetToken(PHPParserColon, 0)
}

func (s *WhileStatementContext) InnerStatementList() IInnerStatementListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInnerStatementListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInnerStatementListContext)
}

func (s *WhileStatementContext) EndWhile() antlr.TerminalNode {
	return s.GetToken(PHPParserEndWhile, 0)
}

func (s *WhileStatementContext) SemiColon() antlr.TerminalNode {
	return s.GetToken(PHPParserSemiColon, 0)
}

func (s *WhileStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WhileStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WhileStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PHPParserVisitor:
		return t.VisitWhileStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PHPParser) WhileStatement() (localctx IWhileStatementContext) {
	this := p
	_ = this

	localctx = NewWhileStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 72, PHPParserRULE_whileStatement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(660)
		p.Match(PHPParserWhile)
	}
	{
		p.SetState(661)
		p.Parentheses()
	}
	p.SetState(668)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case PHPParserHtmlText, PHPParserXmlStart, PHPParserHtmlScriptOpen, PHPParserHtmlStyleOpen, PHPParserHtmlDtd, PHPParserHtmlOpen, PHPParserHtmlClose, PHPParserHtmlSlashClose, PHPParserHtmlSlash, PHPParserHtmlEquals, PHPParserHtmlStartQuoteString, PHPParserHtmlStartDoubleQuoteString, PHPParserHtmlHex, PHPParserHtmlDecimal, PHPParserHtmlName, PHPParserHtmlEndQuoteString, PHPParserHtmlQuoteString, PHPParserHtmlEndDoubleQuoteString, PHPParserHtmlDoubleQuoteString, PHPParserScriptText, PHPParserHtmlScriptClose, PHPParserStyleBody, PHPParserAbstract, PHPParserArray, PHPParserAs, PHPParserBinaryCast, PHPParserBoolType, PHPParserBooleanConstant, PHPParserBreak, PHPParserCallable, PHPParserCase, PHPParserCatch, PHPParserClass, PHPParserClone, PHPParserConst, PHPParserContinue, PHPParserDeclare, PHPParserDefault, PHPParserDo, PHPParserDoubleCast, PHPParserDoubleType, PHPParserEcho, PHPParserElse, PHPParserElseIf, PHPParserEmpty, PHPParserEnum_, PHPParserEndDeclare, PHPParserEndFor, PHPParserEndForeach, PHPParserEndIf, PHPParserEndSwitch, PHPParserEndWhile, PHPParserEval, PHPParserExit, PHPParserExtends, PHPParserFinal, PHPParserFinally, PHPParserFloatCast, PHPParserFor, PHPParserForeach, PHPParserFunction_, PHPParserGlobal, PHPParserGoto, PHPParserIf, PHPParserImplements, PHPParserImport, PHPParserInclude, PHPParserIncludeOnce, PHPParserInstanceOf, PHPParserInsteadOf, PHPParserInt8Cast, PHPParserInt16Cast, PHPParserInt64Type, PHPParserIntType, PHPParserInterface, PHPParserIsSet, PHPParserList, PHPParserLogicalAnd, PHPParserLogicalOr, PHPParserLogicalXor, PHPParserMatch_, PHPParserNamespace, PHPParserNew, PHPParserNull, PHPParserObjectType, PHPParserParent_, PHPParserPartial, PHPParserPrint, PHPParserPrivate, PHPParserProtected, PHPParserPublic, PHPParserReadonly, PHPParserRequire, PHPParserRequireOnce, PHPParserResource, PHPParserReturn, PHPParserStatic, PHPParserStringType, PHPParserSwitch, PHPParserThrow, PHPParserTrait, PHPParserTry, PHPParserTypeof, PHPParserUintCast, PHPParserUnicodeCast, PHPParserUnset, PHPParserUse, PHPParserVar, PHPParserWhile, PHPParserYield, PHPParserFrom, PHPParserLambdaFn, PHPParserTicks, PHPParserEncoding, PHPParserStrictTypes, PHPParserGet, PHPParserSet, PHPParserCall, PHPParserCallStatic, PHPParserConstructor, PHPParserDestruct, PHPParserWakeup, PHPParserSleep, PHPParserAutoload, PHPParserIsSet__, PHPParserUnset__, PHPParserToString__, PHPParserInvoke, PHPParserSetState, PHPParserClone__, PHPParserDebugInfo, PHPParserNamespace__, PHPParserClass__, PHPParserTraic__, PHPParserFunction__, PHPParserMethod__, PHPParserLine__, PHPParserFile__, PHPParserDir__, PHPParserInc, PHPParserDec, PHPParserNamespaceSeparator, PHPParserBang, PHPParserPlus, PHPParserMinus, PHPParserTilde, PHPParserSuppressWarnings, PHPParserDollar, PHPParserOpenRoundBracket, PHPParserOpenSquareBracket, PHPParserOpenCurlyBracket, PHPParserSemiColon, PHPParserVarName, PHPParserLabel, PHPParserOctal, PHPParserDecimal, PHPParserReal, PHPParserHex, PHPParserBinary, PHPParserBackQuoteString, PHPParserSingleQuoteString, PHPParserDoubleQuote, PHPParserStartNowDoc, PHPParserStartHereDoc:
		{
			p.SetState(662)
			p.Statement()
		}

	case PHPParserColon:
		{
			p.SetState(663)
			p.Match(PHPParserColon)
		}
		{
			p.SetState(664)
			p.InnerStatementList()
		}
		{
			p.SetState(665)
			p.Match(PHPParserEndWhile)
		}
		{
			p.SetState(666)
			p.Match(PHPParserSemiColon)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IDoWhileStatementContext is an interface to support dynamic dispatch.
type IDoWhileStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDoWhileStatementContext differentiates from other interfaces.
	IsDoWhileStatementContext()
}

type DoWhileStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDoWhileStatementContext() *DoWhileStatementContext {
	var p = new(DoWhileStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PHPParserRULE_doWhileStatement
	return p
}

func (*DoWhileStatementContext) IsDoWhileStatementContext() {}

func NewDoWhileStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DoWhileStatementContext {
	var p = new(DoWhileStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PHPParserRULE_doWhileStatement

	return p
}

func (s *DoWhileStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *DoWhileStatementContext) Do() antlr.TerminalNode {
	return s.GetToken(PHPParserDo, 0)
}

func (s *DoWhileStatementContext) Statement() IStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *DoWhileStatementContext) While() antlr.TerminalNode {
	return s.GetToken(PHPParserWhile, 0)
}

func (s *DoWhileStatementContext) Parentheses() IParenthesesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IParenthesesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IParenthesesContext)
}

func (s *DoWhileStatementContext) SemiColon() antlr.TerminalNode {
	return s.GetToken(PHPParserSemiColon, 0)
}

func (s *DoWhileStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DoWhileStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DoWhileStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PHPParserVisitor:
		return t.VisitDoWhileStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PHPParser) DoWhileStatement() (localctx IDoWhileStatementContext) {
	this := p
	_ = this

	localctx = NewDoWhileStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 74, PHPParserRULE_doWhileStatement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(670)
		p.Match(PHPParserDo)
	}
	{
		p.SetState(671)
		p.Statement()
	}
	{
		p.SetState(672)
		p.Match(PHPParserWhile)
	}
	{
		p.SetState(673)
		p.Parentheses()
	}
	{
		p.SetState(674)
		p.Match(PHPParserSemiColon)
	}

	return localctx
}

// IForStatementContext is an interface to support dynamic dispatch.
type IForStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsForStatementContext differentiates from other interfaces.
	IsForStatementContext()
}

type ForStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyForStatementContext() *ForStatementContext {
	var p = new(ForStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PHPParserRULE_forStatement
	return p
}

func (*ForStatementContext) IsForStatementContext() {}

func NewForStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ForStatementContext {
	var p = new(ForStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PHPParserRULE_forStatement

	return p
}

func (s *ForStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ForStatementContext) For() antlr.TerminalNode {
	return s.GetToken(PHPParserFor, 0)
}

func (s *ForStatementContext) OpenRoundBracket() antlr.TerminalNode {
	return s.GetToken(PHPParserOpenRoundBracket, 0)
}

func (s *ForStatementContext) AllSemiColon() []antlr.TerminalNode {
	return s.GetTokens(PHPParserSemiColon)
}

func (s *ForStatementContext) SemiColon(i int) antlr.TerminalNode {
	return s.GetToken(PHPParserSemiColon, i)
}

func (s *ForStatementContext) CloseRoundBracket() antlr.TerminalNode {
	return s.GetToken(PHPParserCloseRoundBracket, 0)
}

func (s *ForStatementContext) Statement() IStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *ForStatementContext) Colon() antlr.TerminalNode {
	return s.GetToken(PHPParserColon, 0)
}

func (s *ForStatementContext) InnerStatementList() IInnerStatementListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInnerStatementListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInnerStatementListContext)
}

func (s *ForStatementContext) EndFor() antlr.TerminalNode {
	return s.GetToken(PHPParserEndFor, 0)
}

func (s *ForStatementContext) ForInit() IForInitContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IForInitContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IForInitContext)
}

func (s *ForStatementContext) ExpressionList() IExpressionListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionListContext)
}

func (s *ForStatementContext) ForUpdate() IForUpdateContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IForUpdateContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IForUpdateContext)
}

func (s *ForStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ForStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ForStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PHPParserVisitor:
		return t.VisitForStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PHPParser) ForStatement() (localctx IForStatementContext) {
	this := p
	_ = this

	localctx = NewForStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 76, PHPParserRULE_forStatement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(676)
		p.Match(PHPParserFor)
	}
	{
		p.SetState(677)
		p.Match(PHPParserOpenRoundBracket)
	}
	p.SetState(679)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if (int64((_la-44)) & ^0x3f) == 0 && ((int64(1)<<(_la-44))&-1) != 0 || (int64((_la-108)) & ^0x3f) == 0 && ((int64(1)<<(_la-108))&441352763482308607) != 0 || (int64((_la-194)) & ^0x3f) == 0 && ((int64(1)<<(_la-194))&4396974138177) != 0 {
		{
			p.SetState(678)
			p.ForInit()
		}

	}
	{
		p.SetState(681)
		p.Match(PHPParserSemiColon)
	}
	p.SetState(683)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if (int64((_la-44)) & ^0x3f) == 0 && ((int64(1)<<(_la-44))&-1) != 0 || (int64((_la-108)) & ^0x3f) == 0 && ((int64(1)<<(_la-108))&441352763482308607) != 0 || (int64((_la-194)) & ^0x3f) == 0 && ((int64(1)<<(_la-194))&4396974138177) != 0 {
		{
			p.SetState(682)
			p.ExpressionList()
		}

	}
	{
		p.SetState(685)
		p.Match(PHPParserSemiColon)
	}
	p.SetState(687)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if (int64((_la-44)) & ^0x3f) == 0 && ((int64(1)<<(_la-44))&-1) != 0 || (int64((_la-108)) & ^0x3f) == 0 && ((int64(1)<<(_la-108))&441352763482308607) != 0 || (int64((_la-194)) & ^0x3f) == 0 && ((int64(1)<<(_la-194))&4396974138177) != 0 {
		{
			p.SetState(686)
			p.ForUpdate()
		}

	}
	{
		p.SetState(689)
		p.Match(PHPParserCloseRoundBracket)
	}
	p.SetState(696)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case PHPParserHtmlText, PHPParserXmlStart, PHPParserHtmlScriptOpen, PHPParserHtmlStyleOpen, PHPParserHtmlDtd, PHPParserHtmlOpen, PHPParserHtmlClose, PHPParserHtmlSlashClose, PHPParserHtmlSlash, PHPParserHtmlEquals, PHPParserHtmlStartQuoteString, PHPParserHtmlStartDoubleQuoteString, PHPParserHtmlHex, PHPParserHtmlDecimal, PHPParserHtmlName, PHPParserHtmlEndQuoteString, PHPParserHtmlQuoteString, PHPParserHtmlEndDoubleQuoteString, PHPParserHtmlDoubleQuoteString, PHPParserScriptText, PHPParserHtmlScriptClose, PHPParserStyleBody, PHPParserAbstract, PHPParserArray, PHPParserAs, PHPParserBinaryCast, PHPParserBoolType, PHPParserBooleanConstant, PHPParserBreak, PHPParserCallable, PHPParserCase, PHPParserCatch, PHPParserClass, PHPParserClone, PHPParserConst, PHPParserContinue, PHPParserDeclare, PHPParserDefault, PHPParserDo, PHPParserDoubleCast, PHPParserDoubleType, PHPParserEcho, PHPParserElse, PHPParserElseIf, PHPParserEmpty, PHPParserEnum_, PHPParserEndDeclare, PHPParserEndFor, PHPParserEndForeach, PHPParserEndIf, PHPParserEndSwitch, PHPParserEndWhile, PHPParserEval, PHPParserExit, PHPParserExtends, PHPParserFinal, PHPParserFinally, PHPParserFloatCast, PHPParserFor, PHPParserForeach, PHPParserFunction_, PHPParserGlobal, PHPParserGoto, PHPParserIf, PHPParserImplements, PHPParserImport, PHPParserInclude, PHPParserIncludeOnce, PHPParserInstanceOf, PHPParserInsteadOf, PHPParserInt8Cast, PHPParserInt16Cast, PHPParserInt64Type, PHPParserIntType, PHPParserInterface, PHPParserIsSet, PHPParserList, PHPParserLogicalAnd, PHPParserLogicalOr, PHPParserLogicalXor, PHPParserMatch_, PHPParserNamespace, PHPParserNew, PHPParserNull, PHPParserObjectType, PHPParserParent_, PHPParserPartial, PHPParserPrint, PHPParserPrivate, PHPParserProtected, PHPParserPublic, PHPParserReadonly, PHPParserRequire, PHPParserRequireOnce, PHPParserResource, PHPParserReturn, PHPParserStatic, PHPParserStringType, PHPParserSwitch, PHPParserThrow, PHPParserTrait, PHPParserTry, PHPParserTypeof, PHPParserUintCast, PHPParserUnicodeCast, PHPParserUnset, PHPParserUse, PHPParserVar, PHPParserWhile, PHPParserYield, PHPParserFrom, PHPParserLambdaFn, PHPParserTicks, PHPParserEncoding, PHPParserStrictTypes, PHPParserGet, PHPParserSet, PHPParserCall, PHPParserCallStatic, PHPParserConstructor, PHPParserDestruct, PHPParserWakeup, PHPParserSleep, PHPParserAutoload, PHPParserIsSet__, PHPParserUnset__, PHPParserToString__, PHPParserInvoke, PHPParserSetState, PHPParserClone__, PHPParserDebugInfo, PHPParserNamespace__, PHPParserClass__, PHPParserTraic__, PHPParserFunction__, PHPParserMethod__, PHPParserLine__, PHPParserFile__, PHPParserDir__, PHPParserInc, PHPParserDec, PHPParserNamespaceSeparator, PHPParserBang, PHPParserPlus, PHPParserMinus, PHPParserTilde, PHPParserSuppressWarnings, PHPParserDollar, PHPParserOpenRoundBracket, PHPParserOpenSquareBracket, PHPParserOpenCurlyBracket, PHPParserSemiColon, PHPParserVarName, PHPParserLabel, PHPParserOctal, PHPParserDecimal, PHPParserReal, PHPParserHex, PHPParserBinary, PHPParserBackQuoteString, PHPParserSingleQuoteString, PHPParserDoubleQuote, PHPParserStartNowDoc, PHPParserStartHereDoc:
		{
			p.SetState(690)
			p.Statement()
		}

	case PHPParserColon:
		{
			p.SetState(691)
			p.Match(PHPParserColon)
		}
		{
			p.SetState(692)
			p.InnerStatementList()
		}
		{
			p.SetState(693)
			p.Match(PHPParserEndFor)
		}
		{
			p.SetState(694)
			p.Match(PHPParserSemiColon)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IForInitContext is an interface to support dynamic dispatch.
type IForInitContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsForInitContext differentiates from other interfaces.
	IsForInitContext()
}

type ForInitContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyForInitContext() *ForInitContext {
	var p = new(ForInitContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PHPParserRULE_forInit
	return p
}

func (*ForInitContext) IsForInitContext() {}

func NewForInitContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ForInitContext {
	var p = new(ForInitContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PHPParserRULE_forInit

	return p
}

func (s *ForInitContext) GetParser() antlr.Parser { return s.parser }

func (s *ForInitContext) ExpressionList() IExpressionListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionListContext)
}

func (s *ForInitContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ForInitContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ForInitContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PHPParserVisitor:
		return t.VisitForInit(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PHPParser) ForInit() (localctx IForInitContext) {
	this := p
	_ = this

	localctx = NewForInitContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 78, PHPParserRULE_forInit)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(698)
		p.ExpressionList()
	}

	return localctx
}

// IForUpdateContext is an interface to support dynamic dispatch.
type IForUpdateContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsForUpdateContext differentiates from other interfaces.
	IsForUpdateContext()
}

type ForUpdateContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyForUpdateContext() *ForUpdateContext {
	var p = new(ForUpdateContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PHPParserRULE_forUpdate
	return p
}

func (*ForUpdateContext) IsForUpdateContext() {}

func NewForUpdateContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ForUpdateContext {
	var p = new(ForUpdateContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PHPParserRULE_forUpdate

	return p
}

func (s *ForUpdateContext) GetParser() antlr.Parser { return s.parser }

func (s *ForUpdateContext) ExpressionList() IExpressionListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionListContext)
}

func (s *ForUpdateContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ForUpdateContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ForUpdateContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PHPParserVisitor:
		return t.VisitForUpdate(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PHPParser) ForUpdate() (localctx IForUpdateContext) {
	this := p
	_ = this

	localctx = NewForUpdateContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 80, PHPParserRULE_forUpdate)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(700)
		p.ExpressionList()
	}

	return localctx
}

// ISwitchStatementContext is an interface to support dynamic dispatch.
type ISwitchStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSwitchStatementContext differentiates from other interfaces.
	IsSwitchStatementContext()
}

type SwitchStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySwitchStatementContext() *SwitchStatementContext {
	var p = new(SwitchStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PHPParserRULE_switchStatement
	return p
}

func (*SwitchStatementContext) IsSwitchStatementContext() {}

func NewSwitchStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SwitchStatementContext {
	var p = new(SwitchStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PHPParserRULE_switchStatement

	return p
}

func (s *SwitchStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *SwitchStatementContext) Switch() antlr.TerminalNode {
	return s.GetToken(PHPParserSwitch, 0)
}

func (s *SwitchStatementContext) Parentheses() IParenthesesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IParenthesesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IParenthesesContext)
}

func (s *SwitchStatementContext) OpenCurlyBracket() antlr.TerminalNode {
	return s.GetToken(PHPParserOpenCurlyBracket, 0)
}

func (s *SwitchStatementContext) CloseCurlyBracket() antlr.TerminalNode {
	return s.GetToken(PHPParserCloseCurlyBracket, 0)
}

func (s *SwitchStatementContext) Colon() antlr.TerminalNode {
	return s.GetToken(PHPParserColon, 0)
}

func (s *SwitchStatementContext) EndSwitch() antlr.TerminalNode {
	return s.GetToken(PHPParserEndSwitch, 0)
}

func (s *SwitchStatementContext) AllSemiColon() []antlr.TerminalNode {
	return s.GetTokens(PHPParserSemiColon)
}

func (s *SwitchStatementContext) SemiColon(i int) antlr.TerminalNode {
	return s.GetToken(PHPParserSemiColon, i)
}

func (s *SwitchStatementContext) AllSwitchBlock() []ISwitchBlockContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISwitchBlockContext); ok {
			len++
		}
	}

	tst := make([]ISwitchBlockContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISwitchBlockContext); ok {
			tst[i] = t.(ISwitchBlockContext)
			i++
		}
	}

	return tst
}

func (s *SwitchStatementContext) SwitchBlock(i int) ISwitchBlockContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISwitchBlockContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISwitchBlockContext)
}

func (s *SwitchStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SwitchStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SwitchStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PHPParserVisitor:
		return t.VisitSwitchStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PHPParser) SwitchStatement() (localctx ISwitchStatementContext) {
	this := p
	_ = this

	localctx = NewSwitchStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 82, PHPParserRULE_switchStatement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(702)
		p.Match(PHPParserSwitch)
	}
	{
		p.SetState(703)
		p.Parentheses()
	}
	p.SetState(727)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case PHPParserOpenCurlyBracket:
		{
			p.SetState(704)
			p.Match(PHPParserOpenCurlyBracket)
		}
		p.SetState(706)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == PHPParserSemiColon {
			{
				p.SetState(705)
				p.Match(PHPParserSemiColon)
			}

		}
		p.SetState(711)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == PHPParserCase || _la == PHPParserDefault {
			{
				p.SetState(708)
				p.SwitchBlock()
			}

			p.SetState(713)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(714)
			p.Match(PHPParserCloseCurlyBracket)
		}

	case PHPParserColon:
		{
			p.SetState(715)
			p.Match(PHPParserColon)
		}
		p.SetState(717)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == PHPParserSemiColon {
			{
				p.SetState(716)
				p.Match(PHPParserSemiColon)
			}

		}
		p.SetState(722)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == PHPParserCase || _la == PHPParserDefault {
			{
				p.SetState(719)
				p.SwitchBlock()
			}

			p.SetState(724)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(725)
			p.Match(PHPParserEndSwitch)
		}
		{
			p.SetState(726)
			p.Match(PHPParserSemiColon)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ISwitchBlockContext is an interface to support dynamic dispatch.
type ISwitchBlockContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSwitchBlockContext differentiates from other interfaces.
	IsSwitchBlockContext()
}

type SwitchBlockContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySwitchBlockContext() *SwitchBlockContext {
	var p = new(SwitchBlockContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PHPParserRULE_switchBlock
	return p
}

func (*SwitchBlockContext) IsSwitchBlockContext() {}

func NewSwitchBlockContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SwitchBlockContext {
	var p = new(SwitchBlockContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PHPParserRULE_switchBlock

	return p
}

func (s *SwitchBlockContext) GetParser() antlr.Parser { return s.parser }

func (s *SwitchBlockContext) InnerStatementList() IInnerStatementListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInnerStatementListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInnerStatementListContext)
}

func (s *SwitchBlockContext) AllColon() []antlr.TerminalNode {
	return s.GetTokens(PHPParserColon)
}

func (s *SwitchBlockContext) Colon(i int) antlr.TerminalNode {
	return s.GetToken(PHPParserColon, i)
}

func (s *SwitchBlockContext) AllSemiColon() []antlr.TerminalNode {
	return s.GetTokens(PHPParserSemiColon)
}

func (s *SwitchBlockContext) SemiColon(i int) antlr.TerminalNode {
	return s.GetToken(PHPParserSemiColon, i)
}

func (s *SwitchBlockContext) AllCase() []antlr.TerminalNode {
	return s.GetTokens(PHPParserCase)
}

func (s *SwitchBlockContext) Case(i int) antlr.TerminalNode {
	return s.GetToken(PHPParserCase, i)
}

func (s *SwitchBlockContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *SwitchBlockContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *SwitchBlockContext) AllDefault() []antlr.TerminalNode {
	return s.GetTokens(PHPParserDefault)
}

func (s *SwitchBlockContext) Default(i int) antlr.TerminalNode {
	return s.GetToken(PHPParserDefault, i)
}

func (s *SwitchBlockContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SwitchBlockContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SwitchBlockContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PHPParserVisitor:
		return t.VisitSwitchBlock(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PHPParser) SwitchBlock() (localctx ISwitchBlockContext) {
	this := p
	_ = this

	localctx = NewSwitchBlockContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 84, PHPParserRULE_switchBlock)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(735)
	p.GetErrorHandler().Sync(p)
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			p.SetState(732)
			p.GetErrorHandler().Sync(p)

			switch p.GetTokenStream().LA(1) {
			case PHPParserCase:
				{
					p.SetState(729)
					p.Match(PHPParserCase)
				}
				{
					p.SetState(730)
					p.expression(0)
				}

			case PHPParserDefault:
				{
					p.SetState(731)
					p.Match(PHPParserDefault)
				}

			default:
				panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			}
			{
				p.SetState(734)
				_la = p.GetTokenStream().LA(1)

				if !(_la == PHPParserColon || _la == PHPParserSemiColon) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(737)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 66, p.GetParserRuleContext())
	}
	{
		p.SetState(739)
		p.InnerStatementList()
	}

	return localctx
}

// IBreakStatementContext is an interface to support dynamic dispatch.
type IBreakStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsBreakStatementContext differentiates from other interfaces.
	IsBreakStatementContext()
}

type BreakStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBreakStatementContext() *BreakStatementContext {
	var p = new(BreakStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PHPParserRULE_breakStatement
	return p
}

func (*BreakStatementContext) IsBreakStatementContext() {}

func NewBreakStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BreakStatementContext {
	var p = new(BreakStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PHPParserRULE_breakStatement

	return p
}

func (s *BreakStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *BreakStatementContext) Break() antlr.TerminalNode {
	return s.GetToken(PHPParserBreak, 0)
}

func (s *BreakStatementContext) SemiColon() antlr.TerminalNode {
	return s.GetToken(PHPParserSemiColon, 0)
}

func (s *BreakStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *BreakStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BreakStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BreakStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PHPParserVisitor:
		return t.VisitBreakStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PHPParser) BreakStatement() (localctx IBreakStatementContext) {
	this := p
	_ = this

	localctx = NewBreakStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 86, PHPParserRULE_breakStatement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(741)
		p.Match(PHPParserBreak)
	}
	p.SetState(743)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if (int64((_la-44)) & ^0x3f) == 0 && ((int64(1)<<(_la-44))&-1) != 0 || (int64((_la-108)) & ^0x3f) == 0 && ((int64(1)<<(_la-108))&441352763482308607) != 0 || (int64((_la-194)) & ^0x3f) == 0 && ((int64(1)<<(_la-194))&4396974138177) != 0 {
		{
			p.SetState(742)
			p.expression(0)
		}

	}
	{
		p.SetState(745)
		p.Match(PHPParserSemiColon)
	}

	return localctx
}

// IContinueStatementContext is an interface to support dynamic dispatch.
type IContinueStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsContinueStatementContext differentiates from other interfaces.
	IsContinueStatementContext()
}

type ContinueStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyContinueStatementContext() *ContinueStatementContext {
	var p = new(ContinueStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PHPParserRULE_continueStatement
	return p
}

func (*ContinueStatementContext) IsContinueStatementContext() {}

func NewContinueStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ContinueStatementContext {
	var p = new(ContinueStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PHPParserRULE_continueStatement

	return p
}

func (s *ContinueStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ContinueStatementContext) Continue() antlr.TerminalNode {
	return s.GetToken(PHPParserContinue, 0)
}

func (s *ContinueStatementContext) SemiColon() antlr.TerminalNode {
	return s.GetToken(PHPParserSemiColon, 0)
}

func (s *ContinueStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ContinueStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ContinueStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ContinueStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PHPParserVisitor:
		return t.VisitContinueStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PHPParser) ContinueStatement() (localctx IContinueStatementContext) {
	this := p
	_ = this

	localctx = NewContinueStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 88, PHPParserRULE_continueStatement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(747)
		p.Match(PHPParserContinue)
	}
	p.SetState(749)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if (int64((_la-44)) & ^0x3f) == 0 && ((int64(1)<<(_la-44))&-1) != 0 || (int64((_la-108)) & ^0x3f) == 0 && ((int64(1)<<(_la-108))&441352763482308607) != 0 || (int64((_la-194)) & ^0x3f) == 0 && ((int64(1)<<(_la-194))&4396974138177) != 0 {
		{
			p.SetState(748)
			p.expression(0)
		}

	}
	{
		p.SetState(751)
		p.Match(PHPParserSemiColon)
	}

	return localctx
}

// IReturnStatementContext is an interface to support dynamic dispatch.
type IReturnStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsReturnStatementContext differentiates from other interfaces.
	IsReturnStatementContext()
}

type ReturnStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReturnStatementContext() *ReturnStatementContext {
	var p = new(ReturnStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PHPParserRULE_returnStatement
	return p
}

func (*ReturnStatementContext) IsReturnStatementContext() {}

func NewReturnStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReturnStatementContext {
	var p = new(ReturnStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PHPParserRULE_returnStatement

	return p
}

func (s *ReturnStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ReturnStatementContext) Return() antlr.TerminalNode {
	return s.GetToken(PHPParserReturn, 0)
}

func (s *ReturnStatementContext) SemiColon() antlr.TerminalNode {
	return s.GetToken(PHPParserSemiColon, 0)
}

func (s *ReturnStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ReturnStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReturnStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReturnStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PHPParserVisitor:
		return t.VisitReturnStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PHPParser) ReturnStatement() (localctx IReturnStatementContext) {
	this := p
	_ = this

	localctx = NewReturnStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 90, PHPParserRULE_returnStatement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(753)
		p.Match(PHPParserReturn)
	}
	p.SetState(755)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if (int64((_la-44)) & ^0x3f) == 0 && ((int64(1)<<(_la-44))&-1) != 0 || (int64((_la-108)) & ^0x3f) == 0 && ((int64(1)<<(_la-108))&441352763482308607) != 0 || (int64((_la-194)) & ^0x3f) == 0 && ((int64(1)<<(_la-194))&4396974138177) != 0 {
		{
			p.SetState(754)
			p.expression(0)
		}

	}
	{
		p.SetState(757)
		p.Match(PHPParserSemiColon)
	}

	return localctx
}

// IExpressionStatementContext is an interface to support dynamic dispatch.
type IExpressionStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExpressionStatementContext differentiates from other interfaces.
	IsExpressionStatementContext()
}

type ExpressionStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpressionStatementContext() *ExpressionStatementContext {
	var p = new(ExpressionStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PHPParserRULE_expressionStatement
	return p
}

func (*ExpressionStatementContext) IsExpressionStatementContext() {}

func NewExpressionStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExpressionStatementContext {
	var p = new(ExpressionStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PHPParserRULE_expressionStatement

	return p
}

func (s *ExpressionStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ExpressionStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ExpressionStatementContext) SemiColon() antlr.TerminalNode {
	return s.GetToken(PHPParserSemiColon, 0)
}

func (s *ExpressionStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExpressionStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExpressionStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PHPParserVisitor:
		return t.VisitExpressionStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PHPParser) ExpressionStatement() (localctx IExpressionStatementContext) {
	this := p
	_ = this

	localctx = NewExpressionStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 92, PHPParserRULE_expressionStatement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(759)
		p.expression(0)
	}
	{
		p.SetState(760)
		p.Match(PHPParserSemiColon)
	}

	return localctx
}

// IUnsetStatementContext is an interface to support dynamic dispatch.
type IUnsetStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsUnsetStatementContext differentiates from other interfaces.
	IsUnsetStatementContext()
}

type UnsetStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnsetStatementContext() *UnsetStatementContext {
	var p = new(UnsetStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PHPParserRULE_unsetStatement
	return p
}

func (*UnsetStatementContext) IsUnsetStatementContext() {}

func NewUnsetStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UnsetStatementContext {
	var p = new(UnsetStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PHPParserRULE_unsetStatement

	return p
}

func (s *UnsetStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *UnsetStatementContext) Unset() antlr.TerminalNode {
	return s.GetToken(PHPParserUnset, 0)
}

func (s *UnsetStatementContext) OpenRoundBracket() antlr.TerminalNode {
	return s.GetToken(PHPParserOpenRoundBracket, 0)
}

func (s *UnsetStatementContext) ChainList() IChainListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IChainListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IChainListContext)
}

func (s *UnsetStatementContext) CloseRoundBracket() antlr.TerminalNode {
	return s.GetToken(PHPParserCloseRoundBracket, 0)
}

func (s *UnsetStatementContext) SemiColon() antlr.TerminalNode {
	return s.GetToken(PHPParserSemiColon, 0)
}

func (s *UnsetStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnsetStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UnsetStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PHPParserVisitor:
		return t.VisitUnsetStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PHPParser) UnsetStatement() (localctx IUnsetStatementContext) {
	this := p
	_ = this

	localctx = NewUnsetStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 94, PHPParserRULE_unsetStatement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(762)
		p.Match(PHPParserUnset)
	}
	{
		p.SetState(763)
		p.Match(PHPParserOpenRoundBracket)
	}
	{
		p.SetState(764)
		p.ChainList()
	}
	{
		p.SetState(765)
		p.Match(PHPParserCloseRoundBracket)
	}
	{
		p.SetState(766)
		p.Match(PHPParserSemiColon)
	}

	return localctx
}

// IForeachStatementContext is an interface to support dynamic dispatch.
type IForeachStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsForeachStatementContext differentiates from other interfaces.
	IsForeachStatementContext()
}

type ForeachStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyForeachStatementContext() *ForeachStatementContext {
	var p = new(ForeachStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PHPParserRULE_foreachStatement
	return p
}

func (*ForeachStatementContext) IsForeachStatementContext() {}

func NewForeachStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ForeachStatementContext {
	var p = new(ForeachStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PHPParserRULE_foreachStatement

	return p
}

func (s *ForeachStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ForeachStatementContext) Foreach() antlr.TerminalNode {
	return s.GetToken(PHPParserForeach, 0)
}

func (s *ForeachStatementContext) AllOpenRoundBracket() []antlr.TerminalNode {
	return s.GetTokens(PHPParserOpenRoundBracket)
}

func (s *ForeachStatementContext) OpenRoundBracket(i int) antlr.TerminalNode {
	return s.GetToken(PHPParserOpenRoundBracket, i)
}

func (s *ForeachStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ForeachStatementContext) As() antlr.TerminalNode {
	return s.GetToken(PHPParserAs, 0)
}

func (s *ForeachStatementContext) ArrayDestructuring() IArrayDestructuringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArrayDestructuringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArrayDestructuringContext)
}

func (s *ForeachStatementContext) AllCloseRoundBracket() []antlr.TerminalNode {
	return s.GetTokens(PHPParserCloseRoundBracket)
}

func (s *ForeachStatementContext) CloseRoundBracket(i int) antlr.TerminalNode {
	return s.GetToken(PHPParserCloseRoundBracket, i)
}

func (s *ForeachStatementContext) AllChain() []IChainContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IChainContext); ok {
			len++
		}
	}

	tst := make([]IChainContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IChainContext); ok {
			tst[i] = t.(IChainContext)
			i++
		}
	}

	return tst
}

func (s *ForeachStatementContext) Chain(i int) IChainContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IChainContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IChainContext)
}

func (s *ForeachStatementContext) Assignable() IAssignableContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAssignableContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAssignableContext)
}

func (s *ForeachStatementContext) List() antlr.TerminalNode {
	return s.GetToken(PHPParserList, 0)
}

func (s *ForeachStatementContext) AssignmentList() IAssignmentListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAssignmentListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAssignmentListContext)
}

func (s *ForeachStatementContext) Statement() IStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *ForeachStatementContext) Colon() antlr.TerminalNode {
	return s.GetToken(PHPParserColon, 0)
}

func (s *ForeachStatementContext) InnerStatementList() IInnerStatementListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInnerStatementListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInnerStatementListContext)
}

func (s *ForeachStatementContext) EndForeach() antlr.TerminalNode {
	return s.GetToken(PHPParserEndForeach, 0)
}

func (s *ForeachStatementContext) SemiColon() antlr.TerminalNode {
	return s.GetToken(PHPParserSemiColon, 0)
}

func (s *ForeachStatementContext) AllAmpersand() []antlr.TerminalNode {
	return s.GetTokens(PHPParserAmpersand)
}

func (s *ForeachStatementContext) Ampersand(i int) antlr.TerminalNode {
	return s.GetToken(PHPParserAmpersand, i)
}

func (s *ForeachStatementContext) DoubleArrow() antlr.TerminalNode {
	return s.GetToken(PHPParserDoubleArrow, 0)
}

func (s *ForeachStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ForeachStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ForeachStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PHPParserVisitor:
		return t.VisitForeachStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PHPParser) ForeachStatement() (localctx IForeachStatementContext) {
	this := p
	_ = this

	localctx = NewForeachStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 96, PHPParserRULE_foreachStatement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(768)
		p.Match(PHPParserForeach)
	}
	p.SetState(813)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 75, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(769)
			p.Match(PHPParserOpenRoundBracket)
		}
		{
			p.SetState(770)
			p.expression(0)
		}
		{
			p.SetState(771)
			p.Match(PHPParserAs)
		}
		{
			p.SetState(772)
			p.ArrayDestructuring()
		}
		{
			p.SetState(773)
			p.Match(PHPParserCloseRoundBracket)
		}

	case 2:
		{
			p.SetState(775)
			p.Match(PHPParserOpenRoundBracket)
		}
		{
			p.SetState(776)
			p.Chain()
		}
		{
			p.SetState(777)
			p.Match(PHPParserAs)
		}
		p.SetState(779)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == PHPParserAmpersand {
			{
				p.SetState(778)
				p.Match(PHPParserAmpersand)
			}

		}
		{
			p.SetState(781)
			p.Assignable()
		}
		p.SetState(787)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == PHPParserDoubleArrow {
			{
				p.SetState(782)
				p.Match(PHPParserDoubleArrow)
			}
			p.SetState(784)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == PHPParserAmpersand {
				{
					p.SetState(783)
					p.Match(PHPParserAmpersand)
				}

			}
			{
				p.SetState(786)
				p.Chain()
			}

		}
		{
			p.SetState(789)
			p.Match(PHPParserCloseRoundBracket)
		}

	case 3:
		{
			p.SetState(791)
			p.Match(PHPParserOpenRoundBracket)
		}
		{
			p.SetState(792)
			p.expression(0)
		}
		{
			p.SetState(793)
			p.Match(PHPParserAs)
		}
		{
			p.SetState(794)
			p.Assignable()
		}
		p.SetState(800)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == PHPParserDoubleArrow {
			{
				p.SetState(795)
				p.Match(PHPParserDoubleArrow)
			}
			p.SetState(797)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == PHPParserAmpersand {
				{
					p.SetState(796)
					p.Match(PHPParserAmpersand)
				}

			}
			{
				p.SetState(799)
				p.Chain()
			}

		}
		{
			p.SetState(802)
			p.Match(PHPParserCloseRoundBracket)
		}

	case 4:
		{
			p.SetState(804)
			p.Match(PHPParserOpenRoundBracket)
		}
		{
			p.SetState(805)
			p.Chain()
		}
		{
			p.SetState(806)
			p.Match(PHPParserAs)
		}
		{
			p.SetState(807)
			p.Match(PHPParserList)
		}
		{
			p.SetState(808)
			p.Match(PHPParserOpenRoundBracket)
		}
		{
			p.SetState(809)
			p.AssignmentList()
		}
		{
			p.SetState(810)
			p.Match(PHPParserCloseRoundBracket)
		}
		{
			p.SetState(811)
			p.Match(PHPParserCloseRoundBracket)
		}

	}
	p.SetState(821)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case PHPParserHtmlText, PHPParserXmlStart, PHPParserHtmlScriptOpen, PHPParserHtmlStyleOpen, PHPParserHtmlDtd, PHPParserHtmlOpen, PHPParserHtmlClose, PHPParserHtmlSlashClose, PHPParserHtmlSlash, PHPParserHtmlEquals, PHPParserHtmlStartQuoteString, PHPParserHtmlStartDoubleQuoteString, PHPParserHtmlHex, PHPParserHtmlDecimal, PHPParserHtmlName, PHPParserHtmlEndQuoteString, PHPParserHtmlQuoteString, PHPParserHtmlEndDoubleQuoteString, PHPParserHtmlDoubleQuoteString, PHPParserScriptText, PHPParserHtmlScriptClose, PHPParserStyleBody, PHPParserAbstract, PHPParserArray, PHPParserAs, PHPParserBinaryCast, PHPParserBoolType, PHPParserBooleanConstant, PHPParserBreak, PHPParserCallable, PHPParserCase, PHPParserCatch, PHPParserClass, PHPParserClone, PHPParserConst, PHPParserContinue, PHPParserDeclare, PHPParserDefault, PHPParserDo, PHPParserDoubleCast, PHPParserDoubleType, PHPParserEcho, PHPParserElse, PHPParserElseIf, PHPParserEmpty, PHPParserEnum_, PHPParserEndDeclare, PHPParserEndFor, PHPParserEndForeach, PHPParserEndIf, PHPParserEndSwitch, PHPParserEndWhile, PHPParserEval, PHPParserExit, PHPParserExtends, PHPParserFinal, PHPParserFinally, PHPParserFloatCast, PHPParserFor, PHPParserForeach, PHPParserFunction_, PHPParserGlobal, PHPParserGoto, PHPParserIf, PHPParserImplements, PHPParserImport, PHPParserInclude, PHPParserIncludeOnce, PHPParserInstanceOf, PHPParserInsteadOf, PHPParserInt8Cast, PHPParserInt16Cast, PHPParserInt64Type, PHPParserIntType, PHPParserInterface, PHPParserIsSet, PHPParserList, PHPParserLogicalAnd, PHPParserLogicalOr, PHPParserLogicalXor, PHPParserMatch_, PHPParserNamespace, PHPParserNew, PHPParserNull, PHPParserObjectType, PHPParserParent_, PHPParserPartial, PHPParserPrint, PHPParserPrivate, PHPParserProtected, PHPParserPublic, PHPParserReadonly, PHPParserRequire, PHPParserRequireOnce, PHPParserResource, PHPParserReturn, PHPParserStatic, PHPParserStringType, PHPParserSwitch, PHPParserThrow, PHPParserTrait, PHPParserTry, PHPParserTypeof, PHPParserUintCast, PHPParserUnicodeCast, PHPParserUnset, PHPParserUse, PHPParserVar, PHPParserWhile, PHPParserYield, PHPParserFrom, PHPParserLambdaFn, PHPParserTicks, PHPParserEncoding, PHPParserStrictTypes, PHPParserGet, PHPParserSet, PHPParserCall, PHPParserCallStatic, PHPParserConstructor, PHPParserDestruct, PHPParserWakeup, PHPParserSleep, PHPParserAutoload, PHPParserIsSet__, PHPParserUnset__, PHPParserToString__, PHPParserInvoke, PHPParserSetState, PHPParserClone__, PHPParserDebugInfo, PHPParserNamespace__, PHPParserClass__, PHPParserTraic__, PHPParserFunction__, PHPParserMethod__, PHPParserLine__, PHPParserFile__, PHPParserDir__, PHPParserInc, PHPParserDec, PHPParserNamespaceSeparator, PHPParserBang, PHPParserPlus, PHPParserMinus, PHPParserTilde, PHPParserSuppressWarnings, PHPParserDollar, PHPParserOpenRoundBracket, PHPParserOpenSquareBracket, PHPParserOpenCurlyBracket, PHPParserSemiColon, PHPParserVarName, PHPParserLabel, PHPParserOctal, PHPParserDecimal, PHPParserReal, PHPParserHex, PHPParserBinary, PHPParserBackQuoteString, PHPParserSingleQuoteString, PHPParserDoubleQuote, PHPParserStartNowDoc, PHPParserStartHereDoc:
		{
			p.SetState(815)
			p.Statement()
		}

	case PHPParserColon:
		{
			p.SetState(816)
			p.Match(PHPParserColon)
		}
		{
			p.SetState(817)
			p.InnerStatementList()
		}
		{
			p.SetState(818)
			p.Match(PHPParserEndForeach)
		}
		{
			p.SetState(819)
			p.Match(PHPParserSemiColon)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ITryCatchFinallyContext is an interface to support dynamic dispatch.
type ITryCatchFinallyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTryCatchFinallyContext differentiates from other interfaces.
	IsTryCatchFinallyContext()
}

type TryCatchFinallyContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTryCatchFinallyContext() *TryCatchFinallyContext {
	var p = new(TryCatchFinallyContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PHPParserRULE_tryCatchFinally
	return p
}

func (*TryCatchFinallyContext) IsTryCatchFinallyContext() {}

func NewTryCatchFinallyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TryCatchFinallyContext {
	var p = new(TryCatchFinallyContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PHPParserRULE_tryCatchFinally

	return p
}

func (s *TryCatchFinallyContext) GetParser() antlr.Parser { return s.parser }

func (s *TryCatchFinallyContext) Try() antlr.TerminalNode {
	return s.GetToken(PHPParserTry, 0)
}

func (s *TryCatchFinallyContext) BlockStatement() IBlockStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBlockStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBlockStatementContext)
}

func (s *TryCatchFinallyContext) FinallyStatement() IFinallyStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFinallyStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFinallyStatementContext)
}

func (s *TryCatchFinallyContext) AllCatchClause() []ICatchClauseContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ICatchClauseContext); ok {
			len++
		}
	}

	tst := make([]ICatchClauseContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ICatchClauseContext); ok {
			tst[i] = t.(ICatchClauseContext)
			i++
		}
	}

	return tst
}

func (s *TryCatchFinallyContext) CatchClause(i int) ICatchClauseContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICatchClauseContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICatchClauseContext)
}

func (s *TryCatchFinallyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TryCatchFinallyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TryCatchFinallyContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PHPParserVisitor:
		return t.VisitTryCatchFinally(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PHPParser) TryCatchFinally() (localctx ITryCatchFinallyContext) {
	this := p
	_ = this

	localctx = NewTryCatchFinallyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 98, PHPParserRULE_tryCatchFinally)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(823)
		p.Match(PHPParserTry)
	}
	{
		p.SetState(824)
		p.BlockStatement()
	}
	p.SetState(840)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 80, p.GetParserRuleContext()) {
	case 1:
		p.SetState(826)
		p.GetErrorHandler().Sync(p)
		_alt = 1
		for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			switch _alt {
			case 1:
				{
					p.SetState(825)
					p.CatchClause()
				}

			default:
				panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			}

			p.SetState(828)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 77, p.GetParserRuleContext())
		}
		p.SetState(831)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 78, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(830)
				p.FinallyStatement()
			}

		}

	case 2:
		p.SetState(836)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == PHPParserCatch {
			{
				p.SetState(833)
				p.CatchClause()
			}

			p.SetState(838)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(839)
			p.FinallyStatement()
		}

	}

	return localctx
}

// ICatchClauseContext is an interface to support dynamic dispatch.
type ICatchClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCatchClauseContext differentiates from other interfaces.
	IsCatchClauseContext()
}

type CatchClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCatchClauseContext() *CatchClauseContext {
	var p = new(CatchClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PHPParserRULE_catchClause
	return p
}

func (*CatchClauseContext) IsCatchClauseContext() {}

func NewCatchClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CatchClauseContext {
	var p = new(CatchClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PHPParserRULE_catchClause

	return p
}

func (s *CatchClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *CatchClauseContext) Catch() antlr.TerminalNode {
	return s.GetToken(PHPParserCatch, 0)
}

func (s *CatchClauseContext) OpenRoundBracket() antlr.TerminalNode {
	return s.GetToken(PHPParserOpenRoundBracket, 0)
}

func (s *CatchClauseContext) AllQualifiedStaticTypeRef() []IQualifiedStaticTypeRefContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IQualifiedStaticTypeRefContext); ok {
			len++
		}
	}

	tst := make([]IQualifiedStaticTypeRefContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IQualifiedStaticTypeRefContext); ok {
			tst[i] = t.(IQualifiedStaticTypeRefContext)
			i++
		}
	}

	return tst
}

func (s *CatchClauseContext) QualifiedStaticTypeRef(i int) IQualifiedStaticTypeRefContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedStaticTypeRefContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedStaticTypeRefContext)
}

func (s *CatchClauseContext) CloseRoundBracket() antlr.TerminalNode {
	return s.GetToken(PHPParserCloseRoundBracket, 0)
}

func (s *CatchClauseContext) BlockStatement() IBlockStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBlockStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBlockStatementContext)
}

func (s *CatchClauseContext) AllPipe() []antlr.TerminalNode {
	return s.GetTokens(PHPParserPipe)
}

func (s *CatchClauseContext) Pipe(i int) antlr.TerminalNode {
	return s.GetToken(PHPParserPipe, i)
}

func (s *CatchClauseContext) VarName() antlr.TerminalNode {
	return s.GetToken(PHPParserVarName, 0)
}

func (s *CatchClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CatchClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CatchClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PHPParserVisitor:
		return t.VisitCatchClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PHPParser) CatchClause() (localctx ICatchClauseContext) {
	this := p
	_ = this

	localctx = NewCatchClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 100, PHPParserRULE_catchClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(842)
		p.Match(PHPParserCatch)
	}
	{
		p.SetState(843)
		p.Match(PHPParserOpenRoundBracket)
	}
	{
		p.SetState(844)
		p.QualifiedStaticTypeRef()
	}
	p.SetState(849)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == PHPParserPipe {
		{
			p.SetState(845)
			p.Match(PHPParserPipe)
		}
		{
			p.SetState(846)
			p.QualifiedStaticTypeRef()
		}

		p.SetState(851)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(853)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == PHPParserVarName {
		{
			p.SetState(852)
			p.Match(PHPParserVarName)
		}

	}
	{
		p.SetState(855)
		p.Match(PHPParserCloseRoundBracket)
	}
	{
		p.SetState(856)
		p.BlockStatement()
	}

	return localctx
}

// IFinallyStatementContext is an interface to support dynamic dispatch.
type IFinallyStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFinallyStatementContext differentiates from other interfaces.
	IsFinallyStatementContext()
}

type FinallyStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFinallyStatementContext() *FinallyStatementContext {
	var p = new(FinallyStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PHPParserRULE_finallyStatement
	return p
}

func (*FinallyStatementContext) IsFinallyStatementContext() {}

func NewFinallyStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FinallyStatementContext {
	var p = new(FinallyStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PHPParserRULE_finallyStatement

	return p
}

func (s *FinallyStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *FinallyStatementContext) Finally() antlr.TerminalNode {
	return s.GetToken(PHPParserFinally, 0)
}

func (s *FinallyStatementContext) BlockStatement() IBlockStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBlockStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBlockStatementContext)
}

func (s *FinallyStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FinallyStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FinallyStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PHPParserVisitor:
		return t.VisitFinallyStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PHPParser) FinallyStatement() (localctx IFinallyStatementContext) {
	this := p
	_ = this

	localctx = NewFinallyStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 102, PHPParserRULE_finallyStatement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(858)
		p.Match(PHPParserFinally)
	}
	{
		p.SetState(859)
		p.BlockStatement()
	}

	return localctx
}

// IThrowStatementContext is an interface to support dynamic dispatch.
type IThrowStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsThrowStatementContext differentiates from other interfaces.
	IsThrowStatementContext()
}

type ThrowStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyThrowStatementContext() *ThrowStatementContext {
	var p = new(ThrowStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PHPParserRULE_throwStatement
	return p
}

func (*ThrowStatementContext) IsThrowStatementContext() {}

func NewThrowStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ThrowStatementContext {
	var p = new(ThrowStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PHPParserRULE_throwStatement

	return p
}

func (s *ThrowStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ThrowStatementContext) Throw() antlr.TerminalNode {
	return s.GetToken(PHPParserThrow, 0)
}

func (s *ThrowStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ThrowStatementContext) SemiColon() antlr.TerminalNode {
	return s.GetToken(PHPParserSemiColon, 0)
}

func (s *ThrowStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ThrowStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ThrowStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PHPParserVisitor:
		return t.VisitThrowStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PHPParser) ThrowStatement() (localctx IThrowStatementContext) {
	this := p
	_ = this

	localctx = NewThrowStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 104, PHPParserRULE_throwStatement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(861)
		p.Match(PHPParserThrow)
	}
	{
		p.SetState(862)
		p.expression(0)
	}
	{
		p.SetState(863)
		p.Match(PHPParserSemiColon)
	}

	return localctx
}

// IGotoStatementContext is an interface to support dynamic dispatch.
type IGotoStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsGotoStatementContext differentiates from other interfaces.
	IsGotoStatementContext()
}

type GotoStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGotoStatementContext() *GotoStatementContext {
	var p = new(GotoStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PHPParserRULE_gotoStatement
	return p
}

func (*GotoStatementContext) IsGotoStatementContext() {}

func NewGotoStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GotoStatementContext {
	var p = new(GotoStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PHPParserRULE_gotoStatement

	return p
}

func (s *GotoStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *GotoStatementContext) Goto() antlr.TerminalNode {
	return s.GetToken(PHPParserGoto, 0)
}

func (s *GotoStatementContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *GotoStatementContext) SemiColon() antlr.TerminalNode {
	return s.GetToken(PHPParserSemiColon, 0)
}

func (s *GotoStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GotoStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GotoStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PHPParserVisitor:
		return t.VisitGotoStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PHPParser) GotoStatement() (localctx IGotoStatementContext) {
	this := p
	_ = this

	localctx = NewGotoStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 106, PHPParserRULE_gotoStatement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(865)
		p.Match(PHPParserGoto)
	}
	{
		p.SetState(866)
		p.Identifier()
	}
	{
		p.SetState(867)
		p.Match(PHPParserSemiColon)
	}

	return localctx
}

// IDeclareStatementContext is an interface to support dynamic dispatch.
type IDeclareStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDeclareStatementContext differentiates from other interfaces.
	IsDeclareStatementContext()
}

type DeclareStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDeclareStatementContext() *DeclareStatementContext {
	var p = new(DeclareStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PHPParserRULE_declareStatement
	return p
}

func (*DeclareStatementContext) IsDeclareStatementContext() {}

func NewDeclareStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DeclareStatementContext {
	var p = new(DeclareStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PHPParserRULE_declareStatement

	return p
}

func (s *DeclareStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *DeclareStatementContext) Declare() antlr.TerminalNode {
	return s.GetToken(PHPParserDeclare, 0)
}

func (s *DeclareStatementContext) OpenRoundBracket() antlr.TerminalNode {
	return s.GetToken(PHPParserOpenRoundBracket, 0)
}

func (s *DeclareStatementContext) DeclareList() IDeclareListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDeclareListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDeclareListContext)
}

func (s *DeclareStatementContext) CloseRoundBracket() antlr.TerminalNode {
	return s.GetToken(PHPParserCloseRoundBracket, 0)
}

func (s *DeclareStatementContext) Statement() IStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *DeclareStatementContext) Colon() antlr.TerminalNode {
	return s.GetToken(PHPParserColon, 0)
}

func (s *DeclareStatementContext) InnerStatementList() IInnerStatementListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInnerStatementListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInnerStatementListContext)
}

func (s *DeclareStatementContext) EndDeclare() antlr.TerminalNode {
	return s.GetToken(PHPParserEndDeclare, 0)
}

func (s *DeclareStatementContext) SemiColon() antlr.TerminalNode {
	return s.GetToken(PHPParserSemiColon, 0)
}

func (s *DeclareStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DeclareStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DeclareStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PHPParserVisitor:
		return t.VisitDeclareStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PHPParser) DeclareStatement() (localctx IDeclareStatementContext) {
	this := p
	_ = this

	localctx = NewDeclareStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 108, PHPParserRULE_declareStatement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(869)
		p.Match(PHPParserDeclare)
	}
	{
		p.SetState(870)
		p.Match(PHPParserOpenRoundBracket)
	}
	{
		p.SetState(871)
		p.DeclareList()
	}
	{
		p.SetState(872)
		p.Match(PHPParserCloseRoundBracket)
	}
	p.SetState(879)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case PHPParserHtmlText, PHPParserXmlStart, PHPParserHtmlScriptOpen, PHPParserHtmlStyleOpen, PHPParserHtmlDtd, PHPParserHtmlOpen, PHPParserHtmlClose, PHPParserHtmlSlashClose, PHPParserHtmlSlash, PHPParserHtmlEquals, PHPParserHtmlStartQuoteString, PHPParserHtmlStartDoubleQuoteString, PHPParserHtmlHex, PHPParserHtmlDecimal, PHPParserHtmlName, PHPParserHtmlEndQuoteString, PHPParserHtmlQuoteString, PHPParserHtmlEndDoubleQuoteString, PHPParserHtmlDoubleQuoteString, PHPParserScriptText, PHPParserHtmlScriptClose, PHPParserStyleBody, PHPParserAbstract, PHPParserArray, PHPParserAs, PHPParserBinaryCast, PHPParserBoolType, PHPParserBooleanConstant, PHPParserBreak, PHPParserCallable, PHPParserCase, PHPParserCatch, PHPParserClass, PHPParserClone, PHPParserConst, PHPParserContinue, PHPParserDeclare, PHPParserDefault, PHPParserDo, PHPParserDoubleCast, PHPParserDoubleType, PHPParserEcho, PHPParserElse, PHPParserElseIf, PHPParserEmpty, PHPParserEnum_, PHPParserEndDeclare, PHPParserEndFor, PHPParserEndForeach, PHPParserEndIf, PHPParserEndSwitch, PHPParserEndWhile, PHPParserEval, PHPParserExit, PHPParserExtends, PHPParserFinal, PHPParserFinally, PHPParserFloatCast, PHPParserFor, PHPParserForeach, PHPParserFunction_, PHPParserGlobal, PHPParserGoto, PHPParserIf, PHPParserImplements, PHPParserImport, PHPParserInclude, PHPParserIncludeOnce, PHPParserInstanceOf, PHPParserInsteadOf, PHPParserInt8Cast, PHPParserInt16Cast, PHPParserInt64Type, PHPParserIntType, PHPParserInterface, PHPParserIsSet, PHPParserList, PHPParserLogicalAnd, PHPParserLogicalOr, PHPParserLogicalXor, PHPParserMatch_, PHPParserNamespace, PHPParserNew, PHPParserNull, PHPParserObjectType, PHPParserParent_, PHPParserPartial, PHPParserPrint, PHPParserPrivate, PHPParserProtected, PHPParserPublic, PHPParserReadonly, PHPParserRequire, PHPParserRequireOnce, PHPParserResource, PHPParserReturn, PHPParserStatic, PHPParserStringType, PHPParserSwitch, PHPParserThrow, PHPParserTrait, PHPParserTry, PHPParserTypeof, PHPParserUintCast, PHPParserUnicodeCast, PHPParserUnset, PHPParserUse, PHPParserVar, PHPParserWhile, PHPParserYield, PHPParserFrom, PHPParserLambdaFn, PHPParserTicks, PHPParserEncoding, PHPParserStrictTypes, PHPParserGet, PHPParserSet, PHPParserCall, PHPParserCallStatic, PHPParserConstructor, PHPParserDestruct, PHPParserWakeup, PHPParserSleep, PHPParserAutoload, PHPParserIsSet__, PHPParserUnset__, PHPParserToString__, PHPParserInvoke, PHPParserSetState, PHPParserClone__, PHPParserDebugInfo, PHPParserNamespace__, PHPParserClass__, PHPParserTraic__, PHPParserFunction__, PHPParserMethod__, PHPParserLine__, PHPParserFile__, PHPParserDir__, PHPParserInc, PHPParserDec, PHPParserNamespaceSeparator, PHPParserBang, PHPParserPlus, PHPParserMinus, PHPParserTilde, PHPParserSuppressWarnings, PHPParserDollar, PHPParserOpenRoundBracket, PHPParserOpenSquareBracket, PHPParserOpenCurlyBracket, PHPParserSemiColon, PHPParserVarName, PHPParserLabel, PHPParserOctal, PHPParserDecimal, PHPParserReal, PHPParserHex, PHPParserBinary, PHPParserBackQuoteString, PHPParserSingleQuoteString, PHPParserDoubleQuote, PHPParserStartNowDoc, PHPParserStartHereDoc:
		{
			p.SetState(873)
			p.Statement()
		}

	case PHPParserColon:
		{
			p.SetState(874)
			p.Match(PHPParserColon)
		}
		{
			p.SetState(875)
			p.InnerStatementList()
		}
		{
			p.SetState(876)
			p.Match(PHPParserEndDeclare)
		}
		{
			p.SetState(877)
			p.Match(PHPParserSemiColon)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IInlineHtmlStatementContext is an interface to support dynamic dispatch.
type IInlineHtmlStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInlineHtmlStatementContext differentiates from other interfaces.
	IsInlineHtmlStatementContext()
}

type InlineHtmlStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInlineHtmlStatementContext() *InlineHtmlStatementContext {
	var p = new(InlineHtmlStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PHPParserRULE_inlineHtmlStatement
	return p
}

func (*InlineHtmlStatementContext) IsInlineHtmlStatementContext() {}

func NewInlineHtmlStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InlineHtmlStatementContext {
	var p = new(InlineHtmlStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PHPParserRULE_inlineHtmlStatement

	return p
}

func (s *InlineHtmlStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *InlineHtmlStatementContext) AllInlineHtml() []IInlineHtmlContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IInlineHtmlContext); ok {
			len++
		}
	}

	tst := make([]IInlineHtmlContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IInlineHtmlContext); ok {
			tst[i] = t.(IInlineHtmlContext)
			i++
		}
	}

	return tst
}

func (s *InlineHtmlStatementContext) InlineHtml(i int) IInlineHtmlContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInlineHtmlContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInlineHtmlContext)
}

func (s *InlineHtmlStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InlineHtmlStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InlineHtmlStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PHPParserVisitor:
		return t.VisitInlineHtmlStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PHPParser) InlineHtmlStatement() (localctx IInlineHtmlStatementContext) {
	this := p
	_ = this

	localctx = NewInlineHtmlStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 110, PHPParserRULE_inlineHtmlStatement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(882)
	p.GetErrorHandler().Sync(p)
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			{
				p.SetState(881)
				p.InlineHtml()
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(884)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 84, p.GetParserRuleContext())
	}

	return localctx
}

// IDeclareListContext is an interface to support dynamic dispatch.
type IDeclareListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDeclareListContext differentiates from other interfaces.
	IsDeclareListContext()
}

type DeclareListContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDeclareListContext() *DeclareListContext {
	var p = new(DeclareListContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PHPParserRULE_declareList
	return p
}

func (*DeclareListContext) IsDeclareListContext() {}

func NewDeclareListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DeclareListContext {
	var p = new(DeclareListContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PHPParserRULE_declareList

	return p
}

func (s *DeclareListContext) GetParser() antlr.Parser { return s.parser }

func (s *DeclareListContext) AllDirective() []IDirectiveContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IDirectiveContext); ok {
			len++
		}
	}

	tst := make([]IDirectiveContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IDirectiveContext); ok {
			tst[i] = t.(IDirectiveContext)
			i++
		}
	}

	return tst
}

func (s *DeclareListContext) Directive(i int) IDirectiveContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDirectiveContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDirectiveContext)
}

func (s *DeclareListContext) AllComma() []antlr.TerminalNode {
	return s.GetTokens(PHPParserComma)
}

func (s *DeclareListContext) Comma(i int) antlr.TerminalNode {
	return s.GetToken(PHPParserComma, i)
}

func (s *DeclareListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DeclareListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DeclareListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PHPParserVisitor:
		return t.VisitDeclareList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PHPParser) DeclareList() (localctx IDeclareListContext) {
	this := p
	_ = this

	localctx = NewDeclareListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 112, PHPParserRULE_declareList)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(886)
		p.Directive()
	}
	p.SetState(891)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == PHPParserComma {
		{
			p.SetState(887)
			p.Match(PHPParserComma)
		}
		{
			p.SetState(888)
			p.Directive()
		}

		p.SetState(893)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IDirectiveContext is an interface to support dynamic dispatch.
type IDirectiveContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDirectiveContext differentiates from other interfaces.
	IsDirectiveContext()
}

type DirectiveContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDirectiveContext() *DirectiveContext {
	var p = new(DirectiveContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PHPParserRULE_directive
	return p
}

func (*DirectiveContext) IsDirectiveContext() {}

func NewDirectiveContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DirectiveContext {
	var p = new(DirectiveContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PHPParserRULE_directive

	return p
}

func (s *DirectiveContext) GetParser() antlr.Parser { return s.parser }

func (s *DirectiveContext) Ticks() antlr.TerminalNode {
	return s.GetToken(PHPParserTicks, 0)
}

func (s *DirectiveContext) Eq() antlr.TerminalNode {
	return s.GetToken(PHPParserEq, 0)
}

func (s *DirectiveContext) NumericConstant() INumericConstantContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INumericConstantContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INumericConstantContext)
}

func (s *DirectiveContext) Real() antlr.TerminalNode {
	return s.GetToken(PHPParserReal, 0)
}

func (s *DirectiveContext) Encoding() antlr.TerminalNode {
	return s.GetToken(PHPParserEncoding, 0)
}

func (s *DirectiveContext) SingleQuoteString() antlr.TerminalNode {
	return s.GetToken(PHPParserSingleQuoteString, 0)
}

func (s *DirectiveContext) StrictTypes() antlr.TerminalNode {
	return s.GetToken(PHPParserStrictTypes, 0)
}

func (s *DirectiveContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DirectiveContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DirectiveContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PHPParserVisitor:
		return t.VisitDirective(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PHPParser) Directive() (localctx IDirectiveContext) {
	this := p
	_ = this

	localctx = NewDirectiveContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 114, PHPParserRULE_directive)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(906)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case PHPParserTicks:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(894)
			p.Match(PHPParserTicks)
		}
		{
			p.SetState(895)
			p.Match(PHPParserEq)
		}
		p.SetState(898)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case PHPParserOctal, PHPParserDecimal, PHPParserHex, PHPParserBinary:
			{
				p.SetState(896)
				p.NumericConstant()
			}

		case PHPParserReal:
			{
				p.SetState(897)
				p.Match(PHPParserReal)
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

	case PHPParserEncoding:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(900)
			p.Match(PHPParserEncoding)
		}
		{
			p.SetState(901)
			p.Match(PHPParserEq)
		}
		{
			p.SetState(902)
			p.Match(PHPParserSingleQuoteString)
		}

	case PHPParserStrictTypes:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(903)
			p.Match(PHPParserStrictTypes)
		}
		{
			p.SetState(904)
			p.Match(PHPParserEq)
		}
		{
			p.SetState(905)
			p.NumericConstant()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IFormalParameterListContext is an interface to support dynamic dispatch.
type IFormalParameterListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFormalParameterListContext differentiates from other interfaces.
	IsFormalParameterListContext()
}

type FormalParameterListContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFormalParameterListContext() *FormalParameterListContext {
	var p = new(FormalParameterListContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PHPParserRULE_formalParameterList
	return p
}

func (*FormalParameterListContext) IsFormalParameterListContext() {}

func NewFormalParameterListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FormalParameterListContext {
	var p = new(FormalParameterListContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PHPParserRULE_formalParameterList

	return p
}

func (s *FormalParameterListContext) GetParser() antlr.Parser { return s.parser }

func (s *FormalParameterListContext) AllFormalParameter() []IFormalParameterContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IFormalParameterContext); ok {
			len++
		}
	}

	tst := make([]IFormalParameterContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IFormalParameterContext); ok {
			tst[i] = t.(IFormalParameterContext)
			i++
		}
	}

	return tst
}

func (s *FormalParameterListContext) FormalParameter(i int) IFormalParameterContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFormalParameterContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFormalParameterContext)
}

func (s *FormalParameterListContext) AllComma() []antlr.TerminalNode {
	return s.GetTokens(PHPParserComma)
}

func (s *FormalParameterListContext) Comma(i int) antlr.TerminalNode {
	return s.GetToken(PHPParserComma, i)
}

func (s *FormalParameterListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FormalParameterListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FormalParameterListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PHPParserVisitor:
		return t.VisitFormalParameterList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PHPParser) FormalParameterList() (localctx IFormalParameterListContext) {
	this := p
	_ = this

	localctx = NewFormalParameterListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 116, PHPParserRULE_formalParameterList)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(909)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if (int64((_la-43)) & ^0x3f) == 0 && ((int64(1)<<(_la-43))&-1) != 0 || (int64((_la-107)) & ^0x3f) == 0 && ((int64(1)<<(_la-107))&18014398509481983) != 0 || (int64((_la-194)) & ^0x3f) == 0 && ((int64(1)<<(_la-194))&3221356563) != 0 {
		{
			p.SetState(908)
			p.FormalParameter()
		}

	}
	p.SetState(915)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 89, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(911)
				p.Match(PHPParserComma)
			}
			{
				p.SetState(912)
				p.FormalParameter()
			}

		}
		p.SetState(917)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 89, p.GetParserRuleContext())
	}
	p.SetState(919)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == PHPParserComma {
		{
			p.SetState(918)
			p.Match(PHPParserComma)
		}

	}

	return localctx
}

// IFormalParameterContext is an interface to support dynamic dispatch.
type IFormalParameterContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFormalParameterContext differentiates from other interfaces.
	IsFormalParameterContext()
}

type FormalParameterContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFormalParameterContext() *FormalParameterContext {
	var p = new(FormalParameterContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PHPParserRULE_formalParameter
	return p
}

func (*FormalParameterContext) IsFormalParameterContext() {}

func NewFormalParameterContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FormalParameterContext {
	var p = new(FormalParameterContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PHPParserRULE_formalParameter

	return p
}

func (s *FormalParameterContext) GetParser() antlr.Parser { return s.parser }

func (s *FormalParameterContext) VariableInitializer() IVariableInitializerContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVariableInitializerContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVariableInitializerContext)
}

func (s *FormalParameterContext) Attributes() IAttributesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAttributesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAttributesContext)
}

func (s *FormalParameterContext) AllMemberModifier() []IMemberModifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IMemberModifierContext); ok {
			len++
		}
	}

	tst := make([]IMemberModifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IMemberModifierContext); ok {
			tst[i] = t.(IMemberModifierContext)
			i++
		}
	}

	return tst
}

func (s *FormalParameterContext) MemberModifier(i int) IMemberModifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMemberModifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMemberModifierContext)
}

func (s *FormalParameterContext) QuestionMark() antlr.TerminalNode {
	return s.GetToken(PHPParserQuestionMark, 0)
}

func (s *FormalParameterContext) TypeHint() ITypeHintContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeHintContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeHintContext)
}

func (s *FormalParameterContext) Ampersand() antlr.TerminalNode {
	return s.GetToken(PHPParserAmpersand, 0)
}

func (s *FormalParameterContext) Ellipsis() antlr.TerminalNode {
	return s.GetToken(PHPParserEllipsis, 0)
}

func (s *FormalParameterContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FormalParameterContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FormalParameterContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PHPParserVisitor:
		return t.VisitFormalParameter(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PHPParser) FormalParameter() (localctx IFormalParameterContext) {
	this := p
	_ = this

	localctx = NewFormalParameterContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 118, PHPParserRULE_formalParameter)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(922)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == PHPParserAttributeStart {
		{
			p.SetState(921)
			p.Attributes()
		}

	}
	p.SetState(927)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 92, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(924)
				p.MemberModifier()
			}

		}
		p.SetState(929)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 92, p.GetParserRuleContext())
	}
	p.SetState(931)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == PHPParserQuestionMark {
		{
			p.SetState(930)
			p.Match(PHPParserQuestionMark)
		}

	}
	p.SetState(934)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if (int64((_la-44)) & ^0x3f) == 0 && ((int64(1)<<(_la-44))&-1) != 0 || (int64((_la-108)) & ^0x3f) == 0 && ((int64(1)<<(_la-108))&9007199254740991) != 0 || _la == PHPParserNamespaceSeparator || _la == PHPParserLabel {
		{
			p.SetState(933)
			p.typeHint(0)
		}

	}
	p.SetState(937)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == PHPParserAmpersand {
		{
			p.SetState(936)
			p.Match(PHPParserAmpersand)
		}

	}
	p.SetState(940)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == PHPParserEllipsis {
		{
			p.SetState(939)
			p.Match(PHPParserEllipsis)
		}

	}
	{
		p.SetState(942)
		p.VariableInitializer()
	}

	return localctx
}

// ITypeHintContext is an interface to support dynamic dispatch.
type ITypeHintContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTypeHintContext differentiates from other interfaces.
	IsTypeHintContext()
}

type TypeHintContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeHintContext() *TypeHintContext {
	var p = new(TypeHintContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PHPParserRULE_typeHint
	return p
}

func (*TypeHintContext) IsTypeHintContext() {}

func NewTypeHintContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeHintContext {
	var p = new(TypeHintContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PHPParserRULE_typeHint

	return p
}

func (s *TypeHintContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeHintContext) QualifiedStaticTypeRef() IQualifiedStaticTypeRefContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedStaticTypeRefContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedStaticTypeRefContext)
}

func (s *TypeHintContext) Callable() antlr.TerminalNode {
	return s.GetToken(PHPParserCallable, 0)
}

func (s *TypeHintContext) PrimitiveType() IPrimitiveTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrimitiveTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrimitiveTypeContext)
}

func (s *TypeHintContext) AllTypeHint() []ITypeHintContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITypeHintContext); ok {
			len++
		}
	}

	tst := make([]ITypeHintContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITypeHintContext); ok {
			tst[i] = t.(ITypeHintContext)
			i++
		}
	}

	return tst
}

func (s *TypeHintContext) TypeHint(i int) ITypeHintContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeHintContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeHintContext)
}

func (s *TypeHintContext) Pipe() antlr.TerminalNode {
	return s.GetToken(PHPParserPipe, 0)
}

func (s *TypeHintContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeHintContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeHintContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PHPParserVisitor:
		return t.VisitTypeHint(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PHPParser) TypeHint() (localctx ITypeHintContext) {
	return p.typeHint(0)
}

func (p *PHPParser) typeHint(_p int) (localctx ITypeHintContext) {
	this := p
	_ = this

	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()
	_parentState := p.GetState()
	localctx = NewTypeHintContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx ITypeHintContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 120
	p.EnterRecursionRule(localctx, 120, PHPParserRULE_typeHint, _p)

	defer func() {
		p.UnrollRecursionContexts(_parentctx)
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(948)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 97, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(945)
			p.QualifiedStaticTypeRef()
		}

	case 2:
		{
			p.SetState(946)
			p.Match(PHPParserCallable)
		}

	case 3:
		{
			p.SetState(947)
			p.PrimitiveType()
		}

	}
	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(955)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 98, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			localctx = NewTypeHintContext(p, _parentctx, _parentState)
			p.PushNewRecursionContext(localctx, _startState, PHPParserRULE_typeHint)
			p.SetState(950)

			if !(p.Precpred(p.GetParserRuleContext(), 1)) {
				panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 1)", ""))
			}
			{
				p.SetState(951)
				p.Match(PHPParserPipe)
			}
			{
				p.SetState(952)
				p.typeHint(2)
			}

		}
		p.SetState(957)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 98, p.GetParserRuleContext())
	}

	return localctx
}

// IGlobalStatementContext is an interface to support dynamic dispatch.
type IGlobalStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsGlobalStatementContext differentiates from other interfaces.
	IsGlobalStatementContext()
}

type GlobalStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGlobalStatementContext() *GlobalStatementContext {
	var p = new(GlobalStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PHPParserRULE_globalStatement
	return p
}

func (*GlobalStatementContext) IsGlobalStatementContext() {}

func NewGlobalStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GlobalStatementContext {
	var p = new(GlobalStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PHPParserRULE_globalStatement

	return p
}

func (s *GlobalStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *GlobalStatementContext) Global() antlr.TerminalNode {
	return s.GetToken(PHPParserGlobal, 0)
}

func (s *GlobalStatementContext) AllGlobalVar() []IGlobalVarContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IGlobalVarContext); ok {
			len++
		}
	}

	tst := make([]IGlobalVarContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IGlobalVarContext); ok {
			tst[i] = t.(IGlobalVarContext)
			i++
		}
	}

	return tst
}

func (s *GlobalStatementContext) GlobalVar(i int) IGlobalVarContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGlobalVarContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGlobalVarContext)
}

func (s *GlobalStatementContext) SemiColon() antlr.TerminalNode {
	return s.GetToken(PHPParserSemiColon, 0)
}

func (s *GlobalStatementContext) AllComma() []antlr.TerminalNode {
	return s.GetTokens(PHPParserComma)
}

func (s *GlobalStatementContext) Comma(i int) antlr.TerminalNode {
	return s.GetToken(PHPParserComma, i)
}

func (s *GlobalStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GlobalStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GlobalStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PHPParserVisitor:
		return t.VisitGlobalStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PHPParser) GlobalStatement() (localctx IGlobalStatementContext) {
	this := p
	_ = this

	localctx = NewGlobalStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 122, PHPParserRULE_globalStatement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(958)
		p.Match(PHPParserGlobal)
	}
	{
		p.SetState(959)
		p.GlobalVar()
	}
	p.SetState(964)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == PHPParserComma {
		{
			p.SetState(960)
			p.Match(PHPParserComma)
		}
		{
			p.SetState(961)
			p.GlobalVar()
		}

		p.SetState(966)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(967)
		p.Match(PHPParserSemiColon)
	}

	return localctx
}

// IGlobalVarContext is an interface to support dynamic dispatch.
type IGlobalVarContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsGlobalVarContext differentiates from other interfaces.
	IsGlobalVarContext()
}

type GlobalVarContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGlobalVarContext() *GlobalVarContext {
	var p = new(GlobalVarContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PHPParserRULE_globalVar
	return p
}

func (*GlobalVarContext) IsGlobalVarContext() {}

func NewGlobalVarContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GlobalVarContext {
	var p = new(GlobalVarContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PHPParserRULE_globalVar

	return p
}

func (s *GlobalVarContext) GetParser() antlr.Parser { return s.parser }

func (s *GlobalVarContext) VarName() antlr.TerminalNode {
	return s.GetToken(PHPParserVarName, 0)
}

func (s *GlobalVarContext) Dollar() antlr.TerminalNode {
	return s.GetToken(PHPParserDollar, 0)
}

func (s *GlobalVarContext) Chain() IChainContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IChainContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IChainContext)
}

func (s *GlobalVarContext) OpenCurlyBracket() antlr.TerminalNode {
	return s.GetToken(PHPParserOpenCurlyBracket, 0)
}

func (s *GlobalVarContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *GlobalVarContext) CloseCurlyBracket() antlr.TerminalNode {
	return s.GetToken(PHPParserCloseCurlyBracket, 0)
}

func (s *GlobalVarContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GlobalVarContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GlobalVarContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PHPParserVisitor:
		return t.VisitGlobalVar(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PHPParser) GlobalVar() (localctx IGlobalVarContext) {
	this := p
	_ = this

	localctx = NewGlobalVarContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 124, PHPParserRULE_globalVar)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(977)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 100, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(969)
			p.Match(PHPParserVarName)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(970)
			p.Match(PHPParserDollar)
		}
		{
			p.SetState(971)
			p.Chain()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(972)
			p.Match(PHPParserDollar)
		}
		{
			p.SetState(973)
			p.Match(PHPParserOpenCurlyBracket)
		}
		{
			p.SetState(974)
			p.expression(0)
		}
		{
			p.SetState(975)
			p.Match(PHPParserCloseCurlyBracket)
		}

	}

	return localctx
}

// IEchoStatementContext is an interface to support dynamic dispatch.
type IEchoStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEchoStatementContext differentiates from other interfaces.
	IsEchoStatementContext()
}

type EchoStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEchoStatementContext() *EchoStatementContext {
	var p = new(EchoStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PHPParserRULE_echoStatement
	return p
}

func (*EchoStatementContext) IsEchoStatementContext() {}

func NewEchoStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EchoStatementContext {
	var p = new(EchoStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PHPParserRULE_echoStatement

	return p
}

func (s *EchoStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *EchoStatementContext) Echo() antlr.TerminalNode {
	return s.GetToken(PHPParserEcho, 0)
}

func (s *EchoStatementContext) ExpressionList() IExpressionListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionListContext)
}

func (s *EchoStatementContext) SemiColon() antlr.TerminalNode {
	return s.GetToken(PHPParserSemiColon, 0)
}

func (s *EchoStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EchoStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EchoStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PHPParserVisitor:
		return t.VisitEchoStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PHPParser) EchoStatement() (localctx IEchoStatementContext) {
	this := p
	_ = this

	localctx = NewEchoStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 126, PHPParserRULE_echoStatement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(979)
		p.Match(PHPParserEcho)
	}
	{
		p.SetState(980)
		p.ExpressionList()
	}
	{
		p.SetState(981)
		p.Match(PHPParserSemiColon)
	}

	return localctx
}

// IStaticVariableStatementContext is an interface to support dynamic dispatch.
type IStaticVariableStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsStaticVariableStatementContext differentiates from other interfaces.
	IsStaticVariableStatementContext()
}

type StaticVariableStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStaticVariableStatementContext() *StaticVariableStatementContext {
	var p = new(StaticVariableStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PHPParserRULE_staticVariableStatement
	return p
}

func (*StaticVariableStatementContext) IsStaticVariableStatementContext() {}

func NewStaticVariableStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StaticVariableStatementContext {
	var p = new(StaticVariableStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PHPParserRULE_staticVariableStatement

	return p
}

func (s *StaticVariableStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *StaticVariableStatementContext) Static() antlr.TerminalNode {
	return s.GetToken(PHPParserStatic, 0)
}

func (s *StaticVariableStatementContext) AllVariableInitializer() []IVariableInitializerContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IVariableInitializerContext); ok {
			len++
		}
	}

	tst := make([]IVariableInitializerContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IVariableInitializerContext); ok {
			tst[i] = t.(IVariableInitializerContext)
			i++
		}
	}

	return tst
}

func (s *StaticVariableStatementContext) VariableInitializer(i int) IVariableInitializerContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVariableInitializerContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVariableInitializerContext)
}

func (s *StaticVariableStatementContext) SemiColon() antlr.TerminalNode {
	return s.GetToken(PHPParserSemiColon, 0)
}

func (s *StaticVariableStatementContext) AllComma() []antlr.TerminalNode {
	return s.GetTokens(PHPParserComma)
}

func (s *StaticVariableStatementContext) Comma(i int) antlr.TerminalNode {
	return s.GetToken(PHPParserComma, i)
}

func (s *StaticVariableStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StaticVariableStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StaticVariableStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PHPParserVisitor:
		return t.VisitStaticVariableStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PHPParser) StaticVariableStatement() (localctx IStaticVariableStatementContext) {
	this := p
	_ = this

	localctx = NewStaticVariableStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 128, PHPParserRULE_staticVariableStatement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(983)
		p.Match(PHPParserStatic)
	}
	{
		p.SetState(984)
		p.VariableInitializer()
	}
	p.SetState(989)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == PHPParserComma {
		{
			p.SetState(985)
			p.Match(PHPParserComma)
		}
		{
			p.SetState(986)
			p.VariableInitializer()
		}

		p.SetState(991)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(992)
		p.Match(PHPParserSemiColon)
	}

	return localctx
}

// IClassStatementContext is an interface to support dynamic dispatch.
type IClassStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsClassStatementContext differentiates from other interfaces.
	IsClassStatementContext()
}

type ClassStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyClassStatementContext() *ClassStatementContext {
	var p = new(ClassStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PHPParserRULE_classStatement
	return p
}

func (*ClassStatementContext) IsClassStatementContext() {}

func NewClassStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ClassStatementContext {
	var p = new(ClassStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PHPParserRULE_classStatement

	return p
}

func (s *ClassStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ClassStatementContext) PropertyModifiers() IPropertyModifiersContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyModifiersContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyModifiersContext)
}

func (s *ClassStatementContext) AllVariableInitializer() []IVariableInitializerContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IVariableInitializerContext); ok {
			len++
		}
	}

	tst := make([]IVariableInitializerContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IVariableInitializerContext); ok {
			tst[i] = t.(IVariableInitializerContext)
			i++
		}
	}

	return tst
}

func (s *ClassStatementContext) VariableInitializer(i int) IVariableInitializerContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVariableInitializerContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVariableInitializerContext)
}

func (s *ClassStatementContext) SemiColon() antlr.TerminalNode {
	return s.GetToken(PHPParserSemiColon, 0)
}

func (s *ClassStatementContext) Attributes() IAttributesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAttributesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAttributesContext)
}

func (s *ClassStatementContext) Const() antlr.TerminalNode {
	return s.GetToken(PHPParserConst, 0)
}

func (s *ClassStatementContext) AllIdentifierInitializer() []IIdentifierInitializerContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierInitializerContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierInitializerContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierInitializerContext); ok {
			tst[i] = t.(IIdentifierInitializerContext)
			i++
		}
	}

	return tst
}

func (s *ClassStatementContext) IdentifierInitializer(i int) IIdentifierInitializerContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierInitializerContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierInitializerContext)
}

func (s *ClassStatementContext) Function_() antlr.TerminalNode {
	return s.GetToken(PHPParserFunction_, 0)
}

func (s *ClassStatementContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ClassStatementContext) OpenRoundBracket() antlr.TerminalNode {
	return s.GetToken(PHPParserOpenRoundBracket, 0)
}

func (s *ClassStatementContext) FormalParameterList() IFormalParameterListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFormalParameterListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFormalParameterListContext)
}

func (s *ClassStatementContext) CloseRoundBracket() antlr.TerminalNode {
	return s.GetToken(PHPParserCloseRoundBracket, 0)
}

func (s *ClassStatementContext) MethodBody() IMethodBodyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMethodBodyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMethodBodyContext)
}

func (s *ClassStatementContext) TypeHint() ITypeHintContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeHintContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeHintContext)
}

func (s *ClassStatementContext) AllComma() []antlr.TerminalNode {
	return s.GetTokens(PHPParserComma)
}

func (s *ClassStatementContext) Comma(i int) antlr.TerminalNode {
	return s.GetToken(PHPParserComma, i)
}

func (s *ClassStatementContext) MemberModifiers() IMemberModifiersContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMemberModifiersContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMemberModifiersContext)
}

func (s *ClassStatementContext) Ampersand() antlr.TerminalNode {
	return s.GetToken(PHPParserAmpersand, 0)
}

func (s *ClassStatementContext) TypeParameterListInBrackets() ITypeParameterListInBracketsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeParameterListInBracketsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeParameterListInBracketsContext)
}

func (s *ClassStatementContext) BaseCtorCall() IBaseCtorCallContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBaseCtorCallContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBaseCtorCallContext)
}

func (s *ClassStatementContext) ReturnTypeDecl() IReturnTypeDeclContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReturnTypeDeclContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReturnTypeDeclContext)
}

func (s *ClassStatementContext) Use() antlr.TerminalNode {
	return s.GetToken(PHPParserUse, 0)
}

func (s *ClassStatementContext) QualifiedNamespaceNameList() IQualifiedNamespaceNameListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNamespaceNameListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNamespaceNameListContext)
}

func (s *ClassStatementContext) TraitAdaptations() ITraitAdaptationsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITraitAdaptationsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITraitAdaptationsContext)
}

func (s *ClassStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ClassStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ClassStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PHPParserVisitor:
		return t.VisitClassStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PHPParser) ClassStatement() (localctx IClassStatementContext) {
	this := p
	_ = this

	localctx = NewClassStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 130, PHPParserRULE_classStatement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1053)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case PHPParserAttributeStart, PHPParserAbstract, PHPParserConst, PHPParserFinal, PHPParserFunction_, PHPParserPrivate, PHPParserProtected, PHPParserPublic, PHPParserReadonly, PHPParserStatic, PHPParserVar:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(995)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == PHPParserAttributeStart {
			{
				p.SetState(994)
				p.Attributes()
			}

		}
		p.SetState(1047)
		p.GetErrorHandler().Sync(p)
		switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 112, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(997)
				p.PropertyModifiers()
			}
			p.SetState(999)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if (int64((_la-44)) & ^0x3f) == 0 && ((int64(1)<<(_la-44))&-1) != 0 || (int64((_la-108)) & ^0x3f) == 0 && ((int64(1)<<(_la-108))&9007199254740991) != 0 || _la == PHPParserNamespaceSeparator || _la == PHPParserLabel {
				{
					p.SetState(998)
					p.typeHint(0)
				}

			}
			{
				p.SetState(1001)
				p.VariableInitializer()
			}
			p.SetState(1006)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			for _la == PHPParserComma {
				{
					p.SetState(1002)
					p.Match(PHPParserComma)
				}
				{
					p.SetState(1003)
					p.VariableInitializer()
				}

				p.SetState(1008)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(1009)
				p.Match(PHPParserSemiColon)
			}

		case 2:
			p.SetState(1012)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == PHPParserAbstract || (int64((_la-77)) & ^0x3f) == 0 && ((int64(1)<<(_la-77))&2327872274433) != 0 {
				{
					p.SetState(1011)
					p.MemberModifiers()
				}

			}
			p.SetState(1045)
			p.GetErrorHandler().Sync(p)

			switch p.GetTokenStream().LA(1) {
			case PHPParserConst:
				{
					p.SetState(1014)
					p.Match(PHPParserConst)
				}
				p.SetState(1016)
				p.GetErrorHandler().Sync(p)

				if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 106, p.GetParserRuleContext()) == 1 {
					{
						p.SetState(1015)
						p.typeHint(0)
					}

				}
				{
					p.SetState(1018)
					p.IdentifierInitializer()
				}
				p.SetState(1023)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)

				for _la == PHPParserComma {
					{
						p.SetState(1019)
						p.Match(PHPParserComma)
					}
					{
						p.SetState(1020)
						p.IdentifierInitializer()
					}

					p.SetState(1025)
					p.GetErrorHandler().Sync(p)
					_la = p.GetTokenStream().LA(1)
				}
				{
					p.SetState(1026)
					p.Match(PHPParserSemiColon)
				}

			case PHPParserFunction_:
				{
					p.SetState(1028)
					p.Match(PHPParserFunction_)
				}
				p.SetState(1030)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)

				if _la == PHPParserAmpersand {
					{
						p.SetState(1029)
						p.Match(PHPParserAmpersand)
					}

				}
				{
					p.SetState(1032)
					p.Identifier()
				}
				p.SetState(1034)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)

				if _la == PHPParserLgeneric {
					{
						p.SetState(1033)
						p.TypeParameterListInBrackets()
					}

				}
				{
					p.SetState(1036)
					p.Match(PHPParserOpenRoundBracket)
				}
				{
					p.SetState(1037)
					p.FormalParameterList()
				}
				{
					p.SetState(1038)
					p.Match(PHPParserCloseRoundBracket)
				}
				p.SetState(1041)
				p.GetErrorHandler().Sync(p)

				if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 110, p.GetParserRuleContext()) == 1 {
					{
						p.SetState(1039)
						p.BaseCtorCall()
					}

				} else if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 110, p.GetParserRuleContext()) == 2 {
					{
						p.SetState(1040)
						p.ReturnTypeDecl()
					}

				}
				{
					p.SetState(1043)
					p.MethodBody()
				}

			default:
				panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			}

		}

	case PHPParserUse:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1049)
			p.Match(PHPParserUse)
		}
		{
			p.SetState(1050)
			p.QualifiedNamespaceNameList()
		}
		{
			p.SetState(1051)
			p.TraitAdaptations()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ITraitAdaptationsContext is an interface to support dynamic dispatch.
type ITraitAdaptationsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTraitAdaptationsContext differentiates from other interfaces.
	IsTraitAdaptationsContext()
}

type TraitAdaptationsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTraitAdaptationsContext() *TraitAdaptationsContext {
	var p = new(TraitAdaptationsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PHPParserRULE_traitAdaptations
	return p
}

func (*TraitAdaptationsContext) IsTraitAdaptationsContext() {}

func NewTraitAdaptationsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TraitAdaptationsContext {
	var p = new(TraitAdaptationsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PHPParserRULE_traitAdaptations

	return p
}

func (s *TraitAdaptationsContext) GetParser() antlr.Parser { return s.parser }

func (s *TraitAdaptationsContext) SemiColon() antlr.TerminalNode {
	return s.GetToken(PHPParserSemiColon, 0)
}

func (s *TraitAdaptationsContext) OpenCurlyBracket() antlr.TerminalNode {
	return s.GetToken(PHPParserOpenCurlyBracket, 0)
}

func (s *TraitAdaptationsContext) CloseCurlyBracket() antlr.TerminalNode {
	return s.GetToken(PHPParserCloseCurlyBracket, 0)
}

func (s *TraitAdaptationsContext) AllTraitAdaptationStatement() []ITraitAdaptationStatementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITraitAdaptationStatementContext); ok {
			len++
		}
	}

	tst := make([]ITraitAdaptationStatementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITraitAdaptationStatementContext); ok {
			tst[i] = t.(ITraitAdaptationStatementContext)
			i++
		}
	}

	return tst
}

func (s *TraitAdaptationsContext) TraitAdaptationStatement(i int) ITraitAdaptationStatementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITraitAdaptationStatementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITraitAdaptationStatementContext)
}

func (s *TraitAdaptationsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TraitAdaptationsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TraitAdaptationsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PHPParserVisitor:
		return t.VisitTraitAdaptations(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PHPParser) TraitAdaptations() (localctx ITraitAdaptationsContext) {
	this := p
	_ = this

	localctx = NewTraitAdaptationsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 132, PHPParserRULE_traitAdaptations)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1064)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case PHPParserSemiColon:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1055)
			p.Match(PHPParserSemiColon)
		}

	case PHPParserOpenCurlyBracket:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1056)
			p.Match(PHPParserOpenCurlyBracket)
		}
		p.SetState(1060)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for (int64((_la-44)) & ^0x3f) == 0 && ((int64(1)<<(_la-44))&-1) != 0 || (int64((_la-108)) & ^0x3f) == 0 && ((int64(1)<<(_la-108))&9007199254740991) != 0 || _la == PHPParserNamespaceSeparator || _la == PHPParserLabel {
			{
				p.SetState(1057)
				p.TraitAdaptationStatement()
			}

			p.SetState(1062)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1063)
			p.Match(PHPParserCloseCurlyBracket)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ITraitAdaptationStatementContext is an interface to support dynamic dispatch.
type ITraitAdaptationStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTraitAdaptationStatementContext differentiates from other interfaces.
	IsTraitAdaptationStatementContext()
}

type TraitAdaptationStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTraitAdaptationStatementContext() *TraitAdaptationStatementContext {
	var p = new(TraitAdaptationStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PHPParserRULE_traitAdaptationStatement
	return p
}

func (*TraitAdaptationStatementContext) IsTraitAdaptationStatementContext() {}

func NewTraitAdaptationStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TraitAdaptationStatementContext {
	var p = new(TraitAdaptationStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PHPParserRULE_traitAdaptationStatement

	return p
}

func (s *TraitAdaptationStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *TraitAdaptationStatementContext) TraitPrecedence() ITraitPrecedenceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITraitPrecedenceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITraitPrecedenceContext)
}

func (s *TraitAdaptationStatementContext) TraitAlias() ITraitAliasContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITraitAliasContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITraitAliasContext)
}

func (s *TraitAdaptationStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TraitAdaptationStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TraitAdaptationStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PHPParserVisitor:
		return t.VisitTraitAdaptationStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PHPParser) TraitAdaptationStatement() (localctx ITraitAdaptationStatementContext) {
	this := p
	_ = this

	localctx = NewTraitAdaptationStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 134, PHPParserRULE_traitAdaptationStatement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1068)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 116, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1066)
			p.TraitPrecedence()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1067)
			p.TraitAlias()
		}

	}

	return localctx
}

// ITraitPrecedenceContext is an interface to support dynamic dispatch.
type ITraitPrecedenceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTraitPrecedenceContext differentiates from other interfaces.
	IsTraitPrecedenceContext()
}

type TraitPrecedenceContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTraitPrecedenceContext() *TraitPrecedenceContext {
	var p = new(TraitPrecedenceContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PHPParserRULE_traitPrecedence
	return p
}

func (*TraitPrecedenceContext) IsTraitPrecedenceContext() {}

func NewTraitPrecedenceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TraitPrecedenceContext {
	var p = new(TraitPrecedenceContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PHPParserRULE_traitPrecedence

	return p
}

func (s *TraitPrecedenceContext) GetParser() antlr.Parser { return s.parser }

func (s *TraitPrecedenceContext) QualifiedNamespaceName() IQualifiedNamespaceNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNamespaceNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNamespaceNameContext)
}

func (s *TraitPrecedenceContext) DoubleColon() antlr.TerminalNode {
	return s.GetToken(PHPParserDoubleColon, 0)
}

func (s *TraitPrecedenceContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *TraitPrecedenceContext) InsteadOf() antlr.TerminalNode {
	return s.GetToken(PHPParserInsteadOf, 0)
}

func (s *TraitPrecedenceContext) QualifiedNamespaceNameList() IQualifiedNamespaceNameListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNamespaceNameListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNamespaceNameListContext)
}

func (s *TraitPrecedenceContext) SemiColon() antlr.TerminalNode {
	return s.GetToken(PHPParserSemiColon, 0)
}

func (s *TraitPrecedenceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TraitPrecedenceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TraitPrecedenceContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PHPParserVisitor:
		return t.VisitTraitPrecedence(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PHPParser) TraitPrecedence() (localctx ITraitPrecedenceContext) {
	this := p
	_ = this

	localctx = NewTraitPrecedenceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 136, PHPParserRULE_traitPrecedence)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1070)
		p.QualifiedNamespaceName()
	}
	{
		p.SetState(1071)
		p.Match(PHPParserDoubleColon)
	}
	{
		p.SetState(1072)
		p.Identifier()
	}
	{
		p.SetState(1073)
		p.Match(PHPParserInsteadOf)
	}
	{
		p.SetState(1074)
		p.QualifiedNamespaceNameList()
	}
	{
		p.SetState(1075)
		p.Match(PHPParserSemiColon)
	}

	return localctx
}

// ITraitAliasContext is an interface to support dynamic dispatch.
type ITraitAliasContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTraitAliasContext differentiates from other interfaces.
	IsTraitAliasContext()
}

type TraitAliasContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTraitAliasContext() *TraitAliasContext {
	var p = new(TraitAliasContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PHPParserRULE_traitAlias
	return p
}

func (*TraitAliasContext) IsTraitAliasContext() {}

func NewTraitAliasContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TraitAliasContext {
	var p = new(TraitAliasContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PHPParserRULE_traitAlias

	return p
}

func (s *TraitAliasContext) GetParser() antlr.Parser { return s.parser }

func (s *TraitAliasContext) TraitMethodReference() ITraitMethodReferenceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITraitMethodReferenceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITraitMethodReferenceContext)
}

func (s *TraitAliasContext) As() antlr.TerminalNode {
	return s.GetToken(PHPParserAs, 0)
}

func (s *TraitAliasContext) SemiColon() antlr.TerminalNode {
	return s.GetToken(PHPParserSemiColon, 0)
}

func (s *TraitAliasContext) MemberModifier() IMemberModifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMemberModifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMemberModifierContext)
}

func (s *TraitAliasContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *TraitAliasContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TraitAliasContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TraitAliasContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PHPParserVisitor:
		return t.VisitTraitAlias(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PHPParser) TraitAlias() (localctx ITraitAliasContext) {
	this := p
	_ = this

	localctx = NewTraitAliasContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 138, PHPParserRULE_traitAlias)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1077)
		p.TraitMethodReference()
	}
	{
		p.SetState(1078)
		p.Match(PHPParserAs)
	}
	p.SetState(1084)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 118, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(1079)
			p.MemberModifier()
		}

	case 2:
		p.SetState(1081)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 117, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1080)
				p.MemberModifier()
			}

		}
		{
			p.SetState(1083)
			p.Identifier()
		}

	}
	{
		p.SetState(1086)
		p.Match(PHPParserSemiColon)
	}

	return localctx
}

// ITraitMethodReferenceContext is an interface to support dynamic dispatch.
type ITraitMethodReferenceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTraitMethodReferenceContext differentiates from other interfaces.
	IsTraitMethodReferenceContext()
}

type TraitMethodReferenceContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTraitMethodReferenceContext() *TraitMethodReferenceContext {
	var p = new(TraitMethodReferenceContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PHPParserRULE_traitMethodReference
	return p
}

func (*TraitMethodReferenceContext) IsTraitMethodReferenceContext() {}

func NewTraitMethodReferenceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TraitMethodReferenceContext {
	var p = new(TraitMethodReferenceContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PHPParserRULE_traitMethodReference

	return p
}

func (s *TraitMethodReferenceContext) GetParser() antlr.Parser { return s.parser }

func (s *TraitMethodReferenceContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *TraitMethodReferenceContext) QualifiedNamespaceName() IQualifiedNamespaceNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNamespaceNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNamespaceNameContext)
}

func (s *TraitMethodReferenceContext) DoubleColon() antlr.TerminalNode {
	return s.GetToken(PHPParserDoubleColon, 0)
}

func (s *TraitMethodReferenceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TraitMethodReferenceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TraitMethodReferenceContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PHPParserVisitor:
		return t.VisitTraitMethodReference(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PHPParser) TraitMethodReference() (localctx ITraitMethodReferenceContext) {
	this := p
	_ = this

	localctx = NewTraitMethodReferenceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 140, PHPParserRULE_traitMethodReference)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1091)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 119, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1088)
			p.QualifiedNamespaceName()
		}
		{
			p.SetState(1089)
			p.Match(PHPParserDoubleColon)
		}

	}
	{
		p.SetState(1093)
		p.Identifier()
	}

	return localctx
}

// IBaseCtorCallContext is an interface to support dynamic dispatch.
type IBaseCtorCallContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsBaseCtorCallContext differentiates from other interfaces.
	IsBaseCtorCallContext()
}

type BaseCtorCallContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBaseCtorCallContext() *BaseCtorCallContext {
	var p = new(BaseCtorCallContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PHPParserRULE_baseCtorCall
	return p
}

func (*BaseCtorCallContext) IsBaseCtorCallContext() {}

func NewBaseCtorCallContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BaseCtorCallContext {
	var p = new(BaseCtorCallContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PHPParserRULE_baseCtorCall

	return p
}

func (s *BaseCtorCallContext) GetParser() antlr.Parser { return s.parser }

func (s *BaseCtorCallContext) Colon() antlr.TerminalNode {
	return s.GetToken(PHPParserColon, 0)
}

func (s *BaseCtorCallContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *BaseCtorCallContext) Arguments() IArgumentsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArgumentsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArgumentsContext)
}

func (s *BaseCtorCallContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BaseCtorCallContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BaseCtorCallContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PHPParserVisitor:
		return t.VisitBaseCtorCall(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PHPParser) BaseCtorCall() (localctx IBaseCtorCallContext) {
	this := p
	_ = this

	localctx = NewBaseCtorCallContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 142, PHPParserRULE_baseCtorCall)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1095)
		p.Match(PHPParserColon)
	}
	{
		p.SetState(1096)
		p.Identifier()
	}
	p.SetState(1098)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == PHPParserOpenRoundBracket {
		{
			p.SetState(1097)
			p.Arguments()
		}

	}

	return localctx
}

// IReturnTypeDeclContext is an interface to support dynamic dispatch.
type IReturnTypeDeclContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsReturnTypeDeclContext differentiates from other interfaces.
	IsReturnTypeDeclContext()
}

type ReturnTypeDeclContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReturnTypeDeclContext() *ReturnTypeDeclContext {
	var p = new(ReturnTypeDeclContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PHPParserRULE_returnTypeDecl
	return p
}

func (*ReturnTypeDeclContext) IsReturnTypeDeclContext() {}

func NewReturnTypeDeclContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReturnTypeDeclContext {
	var p = new(ReturnTypeDeclContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PHPParserRULE_returnTypeDecl

	return p
}

func (s *ReturnTypeDeclContext) GetParser() antlr.Parser { return s.parser }

func (s *ReturnTypeDeclContext) Colon() antlr.TerminalNode {
	return s.GetToken(PHPParserColon, 0)
}

func (s *ReturnTypeDeclContext) TypeHint() ITypeHintContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeHintContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeHintContext)
}

func (s *ReturnTypeDeclContext) QuestionMark() antlr.TerminalNode {
	return s.GetToken(PHPParserQuestionMark, 0)
}

func (s *ReturnTypeDeclContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReturnTypeDeclContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReturnTypeDeclContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PHPParserVisitor:
		return t.VisitReturnTypeDecl(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PHPParser) ReturnTypeDecl() (localctx IReturnTypeDeclContext) {
	this := p
	_ = this

	localctx = NewReturnTypeDeclContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 144, PHPParserRULE_returnTypeDecl)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1100)
		p.Match(PHPParserColon)
	}
	p.SetState(1102)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == PHPParserQuestionMark {
		{
			p.SetState(1101)
			p.Match(PHPParserQuestionMark)
		}

	}
	{
		p.SetState(1104)
		p.typeHint(0)
	}

	return localctx
}

// IMethodBodyContext is an interface to support dynamic dispatch.
type IMethodBodyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMethodBodyContext differentiates from other interfaces.
	IsMethodBodyContext()
}

type MethodBodyContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMethodBodyContext() *MethodBodyContext {
	var p = new(MethodBodyContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PHPParserRULE_methodBody
	return p
}

func (*MethodBodyContext) IsMethodBodyContext() {}

func NewMethodBodyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MethodBodyContext {
	var p = new(MethodBodyContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PHPParserRULE_methodBody

	return p
}

func (s *MethodBodyContext) GetParser() antlr.Parser { return s.parser }

func (s *MethodBodyContext) SemiColon() antlr.TerminalNode {
	return s.GetToken(PHPParserSemiColon, 0)
}

func (s *MethodBodyContext) BlockStatement() IBlockStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBlockStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBlockStatementContext)
}

func (s *MethodBodyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MethodBodyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MethodBodyContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PHPParserVisitor:
		return t.VisitMethodBody(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PHPParser) MethodBody() (localctx IMethodBodyContext) {
	this := p
	_ = this

	localctx = NewMethodBodyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 146, PHPParserRULE_methodBody)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1108)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case PHPParserSemiColon:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1106)
			p.Match(PHPParserSemiColon)
		}

	case PHPParserOpenCurlyBracket:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1107)
			p.BlockStatement()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IPropertyModifiersContext is an interface to support dynamic dispatch.
type IPropertyModifiersContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPropertyModifiersContext differentiates from other interfaces.
	IsPropertyModifiersContext()
}

type PropertyModifiersContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPropertyModifiersContext() *PropertyModifiersContext {
	var p = new(PropertyModifiersContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PHPParserRULE_propertyModifiers
	return p
}

func (*PropertyModifiersContext) IsPropertyModifiersContext() {}

func NewPropertyModifiersContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PropertyModifiersContext {
	var p = new(PropertyModifiersContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PHPParserRULE_propertyModifiers

	return p
}

func (s *PropertyModifiersContext) GetParser() antlr.Parser { return s.parser }

func (s *PropertyModifiersContext) MemberModifiers() IMemberModifiersContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMemberModifiersContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMemberModifiersContext)
}

func (s *PropertyModifiersContext) Var() antlr.TerminalNode {
	return s.GetToken(PHPParserVar, 0)
}

func (s *PropertyModifiersContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PropertyModifiersContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PropertyModifiersContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PHPParserVisitor:
		return t.VisitPropertyModifiers(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PHPParser) PropertyModifiers() (localctx IPropertyModifiersContext) {
	this := p
	_ = this

	localctx = NewPropertyModifiersContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 148, PHPParserRULE_propertyModifiers)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1112)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case PHPParserAbstract, PHPParserFinal, PHPParserPrivate, PHPParserProtected, PHPParserPublic, PHPParserReadonly, PHPParserStatic:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1110)
			p.MemberModifiers()
		}

	case PHPParserVar:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1111)
			p.Match(PHPParserVar)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IMemberModifiersContext is an interface to support dynamic dispatch.
type IMemberModifiersContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMemberModifiersContext differentiates from other interfaces.
	IsMemberModifiersContext()
}

type MemberModifiersContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMemberModifiersContext() *MemberModifiersContext {
	var p = new(MemberModifiersContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PHPParserRULE_memberModifiers
	return p
}

func (*MemberModifiersContext) IsMemberModifiersContext() {}

func NewMemberModifiersContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MemberModifiersContext {
	var p = new(MemberModifiersContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PHPParserRULE_memberModifiers

	return p
}

func (s *MemberModifiersContext) GetParser() antlr.Parser { return s.parser }

func (s *MemberModifiersContext) AllMemberModifier() []IMemberModifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IMemberModifierContext); ok {
			len++
		}
	}

	tst := make([]IMemberModifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IMemberModifierContext); ok {
			tst[i] = t.(IMemberModifierContext)
			i++
		}
	}

	return tst
}

func (s *MemberModifiersContext) MemberModifier(i int) IMemberModifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMemberModifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMemberModifierContext)
}

func (s *MemberModifiersContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MemberModifiersContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MemberModifiersContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PHPParserVisitor:
		return t.VisitMemberModifiers(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PHPParser) MemberModifiers() (localctx IMemberModifiersContext) {
	this := p
	_ = this

	localctx = NewMemberModifiersContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 150, PHPParserRULE_memberModifiers)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1115)
	p.GetErrorHandler().Sync(p)
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			{
				p.SetState(1114)
				p.MemberModifier()
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(1117)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 124, p.GetParserRuleContext())
	}

	return localctx
}

// IVariableInitializerContext is an interface to support dynamic dispatch.
type IVariableInitializerContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsVariableInitializerContext differentiates from other interfaces.
	IsVariableInitializerContext()
}

type VariableInitializerContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVariableInitializerContext() *VariableInitializerContext {
	var p = new(VariableInitializerContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PHPParserRULE_variableInitializer
	return p
}

func (*VariableInitializerContext) IsVariableInitializerContext() {}

func NewVariableInitializerContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *VariableInitializerContext {
	var p = new(VariableInitializerContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PHPParserRULE_variableInitializer

	return p
}

func (s *VariableInitializerContext) GetParser() antlr.Parser { return s.parser }

func (s *VariableInitializerContext) VarName() antlr.TerminalNode {
	return s.GetToken(PHPParserVarName, 0)
}

func (s *VariableInitializerContext) Eq() antlr.TerminalNode {
	return s.GetToken(PHPParserEq, 0)
}

func (s *VariableInitializerContext) ConstantInitializer() IConstantInitializerContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConstantInitializerContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConstantInitializerContext)
}

func (s *VariableInitializerContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VariableInitializerContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *VariableInitializerContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PHPParserVisitor:
		return t.VisitVariableInitializer(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PHPParser) VariableInitializer() (localctx IVariableInitializerContext) {
	this := p
	_ = this

	localctx = NewVariableInitializerContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 152, PHPParserRULE_variableInitializer)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1119)
		p.Match(PHPParserVarName)
	}
	p.SetState(1122)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == PHPParserEq {
		{
			p.SetState(1120)
			p.Match(PHPParserEq)
		}
		{
			p.SetState(1121)
			p.ConstantInitializer()
		}

	}

	return localctx
}

// IIdentifierInitializerContext is an interface to support dynamic dispatch.
type IIdentifierInitializerContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsIdentifierInitializerContext differentiates from other interfaces.
	IsIdentifierInitializerContext()
}

type IdentifierInitializerContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIdentifierInitializerContext() *IdentifierInitializerContext {
	var p = new(IdentifierInitializerContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PHPParserRULE_identifierInitializer
	return p
}

func (*IdentifierInitializerContext) IsIdentifierInitializerContext() {}

func NewIdentifierInitializerContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IdentifierInitializerContext {
	var p = new(IdentifierInitializerContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PHPParserRULE_identifierInitializer

	return p
}

func (s *IdentifierInitializerContext) GetParser() antlr.Parser { return s.parser }

func (s *IdentifierInitializerContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *IdentifierInitializerContext) Eq() antlr.TerminalNode {
	return s.GetToken(PHPParserEq, 0)
}

func (s *IdentifierInitializerContext) ConstantInitializer() IConstantInitializerContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConstantInitializerContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConstantInitializerContext)
}

func (s *IdentifierInitializerContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IdentifierInitializerContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IdentifierInitializerContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PHPParserVisitor:
		return t.VisitIdentifierInitializer(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PHPParser) IdentifierInitializer() (localctx IIdentifierInitializerContext) {
	this := p
	_ = this

	localctx = NewIdentifierInitializerContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 154, PHPParserRULE_identifierInitializer)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1124)
		p.Identifier()
	}
	{
		p.SetState(1125)
		p.Match(PHPParserEq)
	}
	{
		p.SetState(1126)
		p.ConstantInitializer()
	}

	return localctx
}

// IGlobalConstantDeclarationContext is an interface to support dynamic dispatch.
type IGlobalConstantDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsGlobalConstantDeclarationContext differentiates from other interfaces.
	IsGlobalConstantDeclarationContext()
}

type GlobalConstantDeclarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGlobalConstantDeclarationContext() *GlobalConstantDeclarationContext {
	var p = new(GlobalConstantDeclarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PHPParserRULE_globalConstantDeclaration
	return p
}

func (*GlobalConstantDeclarationContext) IsGlobalConstantDeclarationContext() {}

func NewGlobalConstantDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GlobalConstantDeclarationContext {
	var p = new(GlobalConstantDeclarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PHPParserRULE_globalConstantDeclaration

	return p
}

func (s *GlobalConstantDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *GlobalConstantDeclarationContext) Const() antlr.TerminalNode {
	return s.GetToken(PHPParserConst, 0)
}

func (s *GlobalConstantDeclarationContext) AllIdentifierInitializer() []IIdentifierInitializerContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierInitializerContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierInitializerContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierInitializerContext); ok {
			tst[i] = t.(IIdentifierInitializerContext)
			i++
		}
	}

	return tst
}

func (s *GlobalConstantDeclarationContext) IdentifierInitializer(i int) IIdentifierInitializerContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierInitializerContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierInitializerContext)
}

func (s *GlobalConstantDeclarationContext) SemiColon() antlr.TerminalNode {
	return s.GetToken(PHPParserSemiColon, 0)
}

func (s *GlobalConstantDeclarationContext) Attributes() IAttributesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAttributesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAttributesContext)
}

func (s *GlobalConstantDeclarationContext) AllComma() []antlr.TerminalNode {
	return s.GetTokens(PHPParserComma)
}

func (s *GlobalConstantDeclarationContext) Comma(i int) antlr.TerminalNode {
	return s.GetToken(PHPParserComma, i)
}

func (s *GlobalConstantDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GlobalConstantDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GlobalConstantDeclarationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PHPParserVisitor:
		return t.VisitGlobalConstantDeclaration(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PHPParser) GlobalConstantDeclaration() (localctx IGlobalConstantDeclarationContext) {
	this := p
	_ = this

	localctx = NewGlobalConstantDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 156, PHPParserRULE_globalConstantDeclaration)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1129)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == PHPParserAttributeStart {
		{
			p.SetState(1128)
			p.Attributes()
		}

	}
	{
		p.SetState(1131)
		p.Match(PHPParserConst)
	}
	{
		p.SetState(1132)
		p.IdentifierInitializer()
	}
	p.SetState(1137)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == PHPParserComma {
		{
			p.SetState(1133)
			p.Match(PHPParserComma)
		}
		{
			p.SetState(1134)
			p.IdentifierInitializer()
		}

		p.SetState(1139)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1140)
		p.Match(PHPParserSemiColon)
	}

	return localctx
}

// IEnumDeclarationContext is an interface to support dynamic dispatch.
type IEnumDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEnumDeclarationContext differentiates from other interfaces.
	IsEnumDeclarationContext()
}

type EnumDeclarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEnumDeclarationContext() *EnumDeclarationContext {
	var p = new(EnumDeclarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PHPParserRULE_enumDeclaration
	return p
}

func (*EnumDeclarationContext) IsEnumDeclarationContext() {}

func NewEnumDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EnumDeclarationContext {
	var p = new(EnumDeclarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PHPParserRULE_enumDeclaration

	return p
}

func (s *EnumDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *EnumDeclarationContext) Enum_() antlr.TerminalNode {
	return s.GetToken(PHPParserEnum_, 0)
}

func (s *EnumDeclarationContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *EnumDeclarationContext) OpenCurlyBracket() antlr.TerminalNode {
	return s.GetToken(PHPParserOpenCurlyBracket, 0)
}

func (s *EnumDeclarationContext) CloseCurlyBracket() antlr.TerminalNode {
	return s.GetToken(PHPParserCloseCurlyBracket, 0)
}

func (s *EnumDeclarationContext) Colon() antlr.TerminalNode {
	return s.GetToken(PHPParserColon, 0)
}

func (s *EnumDeclarationContext) Implements() antlr.TerminalNode {
	return s.GetToken(PHPParserImplements, 0)
}

func (s *EnumDeclarationContext) InterfaceList() IInterfaceListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInterfaceListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInterfaceListContext)
}

func (s *EnumDeclarationContext) AllEnumItem() []IEnumItemContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IEnumItemContext); ok {
			len++
		}
	}

	tst := make([]IEnumItemContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IEnumItemContext); ok {
			tst[i] = t.(IEnumItemContext)
			i++
		}
	}

	return tst
}

func (s *EnumDeclarationContext) EnumItem(i int) IEnumItemContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEnumItemContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEnumItemContext)
}

func (s *EnumDeclarationContext) IntType() antlr.TerminalNode {
	return s.GetToken(PHPParserIntType, 0)
}

func (s *EnumDeclarationContext) StringType() antlr.TerminalNode {
	return s.GetToken(PHPParserStringType, 0)
}

func (s *EnumDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EnumDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EnumDeclarationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PHPParserVisitor:
		return t.VisitEnumDeclaration(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PHPParser) EnumDeclaration() (localctx IEnumDeclarationContext) {
	this := p
	_ = this

	localctx = NewEnumDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 158, PHPParserRULE_enumDeclaration)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1142)
		p.Match(PHPParserEnum_)
	}
	{
		p.SetState(1143)
		p.Identifier()
	}
	p.SetState(1146)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == PHPParserColon {
		{
			p.SetState(1144)
			p.Match(PHPParserColon)
		}
		{
			p.SetState(1145)
			_la = p.GetTokenStream().LA(1)

			if !(_la == PHPParserIntType || _la == PHPParserStringType) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}
	p.SetState(1150)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == PHPParserImplements {
		{
			p.SetState(1148)
			p.Match(PHPParserImplements)
		}
		{
			p.SetState(1149)
			p.InterfaceList()
		}

	}
	{
		p.SetState(1152)
		p.Match(PHPParserOpenCurlyBracket)
	}
	p.SetState(1156)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for (int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&4529987906437120) != 0 || (int64((_la-77)) & ^0x3f) == 0 && ((int64(1)<<(_la-77))&2254127685959713) != 0 {
		{
			p.SetState(1153)
			p.EnumItem()
		}

		p.SetState(1158)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1159)
		p.Match(PHPParserCloseCurlyBracket)
	}

	return localctx
}

// IEnumItemContext is an interface to support dynamic dispatch.
type IEnumItemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEnumItemContext differentiates from other interfaces.
	IsEnumItemContext()
}

type EnumItemContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEnumItemContext() *EnumItemContext {
	var p = new(EnumItemContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PHPParserRULE_enumItem
	return p
}

func (*EnumItemContext) IsEnumItemContext() {}

func NewEnumItemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EnumItemContext {
	var p = new(EnumItemContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PHPParserRULE_enumItem

	return p
}

func (s *EnumItemContext) GetParser() antlr.Parser { return s.parser }

func (s *EnumItemContext) Case() antlr.TerminalNode {
	return s.GetToken(PHPParserCase, 0)
}

func (s *EnumItemContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *EnumItemContext) SemiColon() antlr.TerminalNode {
	return s.GetToken(PHPParserSemiColon, 0)
}

func (s *EnumItemContext) Eq() antlr.TerminalNode {
	return s.GetToken(PHPParserEq, 0)
}

func (s *EnumItemContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *EnumItemContext) FunctionDeclaration() IFunctionDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionDeclarationContext)
}

func (s *EnumItemContext) MemberModifiers() IMemberModifiersContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMemberModifiersContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMemberModifiersContext)
}

func (s *EnumItemContext) Use() antlr.TerminalNode {
	return s.GetToken(PHPParserUse, 0)
}

func (s *EnumItemContext) QualifiedNamespaceNameList() IQualifiedNamespaceNameListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNamespaceNameListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNamespaceNameListContext)
}

func (s *EnumItemContext) TraitAdaptations() ITraitAdaptationsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITraitAdaptationsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITraitAdaptationsContext)
}

func (s *EnumItemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EnumItemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EnumItemContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PHPParserVisitor:
		return t.VisitEnumItem(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PHPParser) EnumItem() (localctx IEnumItemContext) {
	this := p
	_ = this

	localctx = NewEnumItemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 160, PHPParserRULE_enumItem)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1177)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case PHPParserCase:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1161)
			p.Match(PHPParserCase)
		}
		{
			p.SetState(1162)
			p.Identifier()
		}
		p.SetState(1165)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == PHPParserEq {
			{
				p.SetState(1163)
				p.Match(PHPParserEq)
			}
			{
				p.SetState(1164)
				p.expression(0)
			}

		}
		{
			p.SetState(1167)
			p.Match(PHPParserSemiColon)
		}

	case PHPParserAttributeStart, PHPParserAbstract, PHPParserFinal, PHPParserFunction_, PHPParserPrivate, PHPParserProtected, PHPParserPublic, PHPParserReadonly, PHPParserStatic:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(1170)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == PHPParserAbstract || (int64((_la-77)) & ^0x3f) == 0 && ((int64(1)<<(_la-77))&2327872274433) != 0 {
			{
				p.SetState(1169)
				p.MemberModifiers()
			}

		}
		{
			p.SetState(1172)
			p.FunctionDeclaration()
		}

	case PHPParserUse:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1173)
			p.Match(PHPParserUse)
		}
		{
			p.SetState(1174)
			p.QualifiedNamespaceNameList()
		}
		{
			p.SetState(1175)
			p.TraitAdaptations()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IExpressionListContext is an interface to support dynamic dispatch.
type IExpressionListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExpressionListContext differentiates from other interfaces.
	IsExpressionListContext()
}

type ExpressionListContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpressionListContext() *ExpressionListContext {
	var p = new(ExpressionListContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PHPParserRULE_expressionList
	return p
}

func (*ExpressionListContext) IsExpressionListContext() {}

func NewExpressionListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExpressionListContext {
	var p = new(ExpressionListContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PHPParserRULE_expressionList

	return p
}

func (s *ExpressionListContext) GetParser() antlr.Parser { return s.parser }

func (s *ExpressionListContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *ExpressionListContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ExpressionListContext) AllComma() []antlr.TerminalNode {
	return s.GetTokens(PHPParserComma)
}

func (s *ExpressionListContext) Comma(i int) antlr.TerminalNode {
	return s.GetToken(PHPParserComma, i)
}

func (s *ExpressionListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExpressionListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExpressionListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PHPParserVisitor:
		return t.VisitExpressionList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PHPParser) ExpressionList() (localctx IExpressionListContext) {
	this := p
	_ = this

	localctx = NewExpressionListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 162, PHPParserRULE_expressionList)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1179)
		p.expression(0)
	}
	p.SetState(1184)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == PHPParserComma {
		{
			p.SetState(1180)
			p.Match(PHPParserComma)
		}
		{
			p.SetState(1181)
			p.expression(0)
		}

		p.SetState(1186)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IParenthesesContext is an interface to support dynamic dispatch.
type IParenthesesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsParenthesesContext differentiates from other interfaces.
	IsParenthesesContext()
}

type ParenthesesContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyParenthesesContext() *ParenthesesContext {
	var p = new(ParenthesesContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PHPParserRULE_parentheses
	return p
}

func (*ParenthesesContext) IsParenthesesContext() {}

func NewParenthesesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ParenthesesContext {
	var p = new(ParenthesesContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PHPParserRULE_parentheses

	return p
}

func (s *ParenthesesContext) GetParser() antlr.Parser { return s.parser }

func (s *ParenthesesContext) OpenRoundBracket() antlr.TerminalNode {
	return s.GetToken(PHPParserOpenRoundBracket, 0)
}

func (s *ParenthesesContext) CloseRoundBracket() antlr.TerminalNode {
	return s.GetToken(PHPParserCloseRoundBracket, 0)
}

func (s *ParenthesesContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ParenthesesContext) YieldExpression() IYieldExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IYieldExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IYieldExpressionContext)
}

func (s *ParenthesesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ParenthesesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ParenthesesContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PHPParserVisitor:
		return t.VisitParentheses(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PHPParser) Parentheses() (localctx IParenthesesContext) {
	this := p
	_ = this

	localctx = NewParenthesesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 164, PHPParserRULE_parentheses)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1187)
		p.Match(PHPParserOpenRoundBracket)
	}
	p.SetState(1190)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 135, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(1188)
			p.expression(0)
		}

	case 2:
		{
			p.SetState(1189)
			p.YieldExpression()
		}

	}
	{
		p.SetState(1192)
		p.Match(PHPParserCloseRoundBracket)
	}

	return localctx
}

// IExpressionContext is an interface to support dynamic dispatch.
type IExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExpressionContext differentiates from other interfaces.
	IsExpressionContext()
}

type ExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpressionContext() *ExpressionContext {
	var p = new(ExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PHPParserRULE_expression
	return p
}

func (*ExpressionContext) IsExpressionContext() {}

func NewExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExpressionContext {
	var p = new(ExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PHPParserRULE_expression

	return p
}

func (s *ExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *ExpressionContext) CopyFrom(ctx *ExpressionContext) {
	s.BaseParserRuleContext.CopyFrom(ctx.BaseParserRuleContext)
}

func (s *ExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type ChainExpressionContext struct {
	*ExpressionContext
}

func NewChainExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ChainExpressionContext {
	var p = new(ChainExpressionContext)

	p.ExpressionContext = NewEmptyExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ExpressionContext))

	return p
}

func (s *ChainExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ChainExpressionContext) Chain() IChainContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IChainContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IChainContext)
}

func (s *ChainExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PHPParserVisitor:
		return t.VisitChainExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

type SpecialWordExpressionContext struct {
	*ExpressionContext
}

func NewSpecialWordExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SpecialWordExpressionContext {
	var p = new(SpecialWordExpressionContext)

	p.ExpressionContext = NewEmptyExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ExpressionContext))

	return p
}

func (s *SpecialWordExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SpecialWordExpressionContext) Yield() antlr.TerminalNode {
	return s.GetToken(PHPParserYield, 0)
}

func (s *SpecialWordExpressionContext) List() antlr.TerminalNode {
	return s.GetToken(PHPParserList, 0)
}

func (s *SpecialWordExpressionContext) OpenRoundBracket() antlr.TerminalNode {
	return s.GetToken(PHPParserOpenRoundBracket, 0)
}

func (s *SpecialWordExpressionContext) AssignmentList() IAssignmentListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAssignmentListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAssignmentListContext)
}

func (s *SpecialWordExpressionContext) CloseRoundBracket() antlr.TerminalNode {
	return s.GetToken(PHPParserCloseRoundBracket, 0)
}

func (s *SpecialWordExpressionContext) Eq() antlr.TerminalNode {
	return s.GetToken(PHPParserEq, 0)
}

func (s *SpecialWordExpressionContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *SpecialWordExpressionContext) IsSet() antlr.TerminalNode {
	return s.GetToken(PHPParserIsSet, 0)
}

func (s *SpecialWordExpressionContext) ChainList() IChainListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IChainListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IChainListContext)
}

func (s *SpecialWordExpressionContext) Empty() antlr.TerminalNode {
	return s.GetToken(PHPParserEmpty, 0)
}

func (s *SpecialWordExpressionContext) Chain() IChainContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IChainContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IChainContext)
}

func (s *SpecialWordExpressionContext) Eval() antlr.TerminalNode {
	return s.GetToken(PHPParserEval, 0)
}

func (s *SpecialWordExpressionContext) Exit() antlr.TerminalNode {
	return s.GetToken(PHPParserExit, 0)
}

func (s *SpecialWordExpressionContext) Parentheses() IParenthesesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IParenthesesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IParenthesesContext)
}

func (s *SpecialWordExpressionContext) Include() antlr.TerminalNode {
	return s.GetToken(PHPParserInclude, 0)
}

func (s *SpecialWordExpressionContext) IncludeOnce() antlr.TerminalNode {
	return s.GetToken(PHPParserIncludeOnce, 0)
}

func (s *SpecialWordExpressionContext) Require() antlr.TerminalNode {
	return s.GetToken(PHPParserRequire, 0)
}

func (s *SpecialWordExpressionContext) RequireOnce() antlr.TerminalNode {
	return s.GetToken(PHPParserRequireOnce, 0)
}

func (s *SpecialWordExpressionContext) Throw() antlr.TerminalNode {
	return s.GetToken(PHPParserThrow, 0)
}

func (s *SpecialWordExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PHPParserVisitor:
		return t.VisitSpecialWordExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

type ArrayCreationExpressionContext struct {
	*ExpressionContext
}

func NewArrayCreationExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ArrayCreationExpressionContext {
	var p = new(ArrayCreationExpressionContext)

	p.ExpressionContext = NewEmptyExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ExpressionContext))

	return p
}

func (s *ArrayCreationExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArrayCreationExpressionContext) ArrayCreation() IArrayCreationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArrayCreationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArrayCreationContext)
}

func (s *ArrayCreationExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PHPParserVisitor:
		return t.VisitArrayCreationExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

type BackQuoteStringExpressionContext struct {
	*ExpressionContext
}

func NewBackQuoteStringExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *BackQuoteStringExpressionContext {
	var p = new(BackQuoteStringExpressionContext)

	p.ExpressionContext = NewEmptyExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ExpressionContext))

	return p
}

func (s *BackQuoteStringExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BackQuoteStringExpressionContext) BackQuoteString() antlr.TerminalNode {
	return s.GetToken(PHPParserBackQuoteString, 0)
}

func (s *BackQuoteStringExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PHPParserVisitor:
		return t.VisitBackQuoteStringExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

type KeywordNewExpressionContext struct {
	*ExpressionContext
}

func NewKeywordNewExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *KeywordNewExpressionContext {
	var p = new(KeywordNewExpressionContext)

	p.ExpressionContext = NewEmptyExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ExpressionContext))

	return p
}

func (s *KeywordNewExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KeywordNewExpressionContext) NewExpr() INewExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INewExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INewExprContext)
}

func (s *KeywordNewExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PHPParserVisitor:
		return t.VisitKeywordNewExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

type MatchExpressionContext struct {
	*ExpressionContext
}

func NewMatchExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *MatchExpressionContext {
	var p = new(MatchExpressionContext)

	p.ExpressionContext = NewEmptyExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ExpressionContext))

	return p
}

func (s *MatchExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MatchExpressionContext) MatchExpr() IMatchExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMatchExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMatchExprContext)
}

func (s *MatchExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PHPParserVisitor:
		return t.VisitMatchExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

type LogicalExpressionContext struct {
	*ExpressionContext
	op antlr.Token
}

func NewLogicalExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LogicalExpressionContext {
	var p = new(LogicalExpressionContext)

	p.ExpressionContext = NewEmptyExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ExpressionContext))

	return p
}

func (s *LogicalExpressionContext) GetOp() antlr.Token { return s.op }

func (s *LogicalExpressionContext) SetOp(v antlr.Token) { s.op = v }

func (s *LogicalExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LogicalExpressionContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *LogicalExpressionContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *LogicalExpressionContext) LogicalAnd() antlr.TerminalNode {
	return s.GetToken(PHPParserLogicalAnd, 0)
}

func (s *LogicalExpressionContext) LogicalXor() antlr.TerminalNode {
	return s.GetToken(PHPParserLogicalXor, 0)
}

func (s *LogicalExpressionContext) LogicalOr() antlr.TerminalNode {
	return s.GetToken(PHPParserLogicalOr, 0)
}

func (s *LogicalExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PHPParserVisitor:
		return t.VisitLogicalExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

type PrintExpressionContext struct {
	*ExpressionContext
}

func NewPrintExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *PrintExpressionContext {
	var p = new(PrintExpressionContext)

	p.ExpressionContext = NewEmptyExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ExpressionContext))

	return p
}

func (s *PrintExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrintExpressionContext) Print() antlr.TerminalNode {
	return s.GetToken(PHPParserPrint, 0)
}

func (s *PrintExpressionContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *PrintExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PHPParserVisitor:
		return t.VisitPrintExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

type AssignmentExpressionContext struct {
	*ExpressionContext
}

func NewAssignmentExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AssignmentExpressionContext {
	var p = new(AssignmentExpressionContext)

	p.ExpressionContext = NewEmptyExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ExpressionContext))

	return p
}

func (s *AssignmentExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AssignmentExpressionContext) Assignable() IAssignableContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAssignableContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAssignableContext)
}

func (s *AssignmentExpressionContext) AssignmentOperator() IAssignmentOperatorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAssignmentOperatorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAssignmentOperatorContext)
}

func (s *AssignmentExpressionContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *AssignmentExpressionContext) Attributes() IAttributesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAttributesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAttributesContext)
}

func (s *AssignmentExpressionContext) Eq() antlr.TerminalNode {
	return s.GetToken(PHPParserEq, 0)
}

func (s *AssignmentExpressionContext) Ampersand() antlr.TerminalNode {
	return s.GetToken(PHPParserAmpersand, 0)
}

func (s *AssignmentExpressionContext) Chain() IChainContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IChainContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IChainContext)
}

func (s *AssignmentExpressionContext) NewExpr() INewExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INewExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INewExprContext)
}

func (s *AssignmentExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PHPParserVisitor:
		return t.VisitAssignmentExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

type PostfixIncDecExpressionContext struct {
	*ExpressionContext
}

func NewPostfixIncDecExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *PostfixIncDecExpressionContext {
	var p = new(PostfixIncDecExpressionContext)

	p.ExpressionContext = NewEmptyExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ExpressionContext))

	return p
}

func (s *PostfixIncDecExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PostfixIncDecExpressionContext) Chain() IChainContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IChainContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IChainContext)
}

func (s *PostfixIncDecExpressionContext) Inc() antlr.TerminalNode {
	return s.GetToken(PHPParserInc, 0)
}

func (s *PostfixIncDecExpressionContext) Dec() antlr.TerminalNode {
	return s.GetToken(PHPParserDec, 0)
}

func (s *PostfixIncDecExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PHPParserVisitor:
		return t.VisitPostfixIncDecExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

type CloneExpressionContext struct {
	*ExpressionContext
}

func NewCloneExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CloneExpressionContext {
	var p = new(CloneExpressionContext)

	p.ExpressionContext = NewEmptyExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ExpressionContext))

	return p
}

func (s *CloneExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CloneExpressionContext) Clone() antlr.TerminalNode {
	return s.GetToken(PHPParserClone, 0)
}

func (s *CloneExpressionContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *CloneExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PHPParserVisitor:
		return t.VisitCloneExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

type UnaryOperatorExpressionContext struct {
	*ExpressionContext
}

func NewUnaryOperatorExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *UnaryOperatorExpressionContext {
	var p = new(UnaryOperatorExpressionContext)

	p.ExpressionContext = NewEmptyExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ExpressionContext))

	return p
}

func (s *UnaryOperatorExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnaryOperatorExpressionContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *UnaryOperatorExpressionContext) Tilde() antlr.TerminalNode {
	return s.GetToken(PHPParserTilde, 0)
}

func (s *UnaryOperatorExpressionContext) SuppressWarnings() antlr.TerminalNode {
	return s.GetToken(PHPParserSuppressWarnings, 0)
}

func (s *UnaryOperatorExpressionContext) Bang() antlr.TerminalNode {
	return s.GetToken(PHPParserBang, 0)
}

func (s *UnaryOperatorExpressionContext) Plus() antlr.TerminalNode {
	return s.GetToken(PHPParserPlus, 0)
}

func (s *UnaryOperatorExpressionContext) Minus() antlr.TerminalNode {
	return s.GetToken(PHPParserMinus, 0)
}

func (s *UnaryOperatorExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PHPParserVisitor:
		return t.VisitUnaryOperatorExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

type ParenthesisExpressionContext struct {
	*ExpressionContext
}

func NewParenthesisExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ParenthesisExpressionContext {
	var p = new(ParenthesisExpressionContext)

	p.ExpressionContext = NewEmptyExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ExpressionContext))

	return p
}

func (s *ParenthesisExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ParenthesisExpressionContext) Parentheses() IParenthesesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IParenthesesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IParenthesesContext)
}

func (s *ParenthesisExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PHPParserVisitor:
		return t.VisitParenthesisExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

type SpaceshipExpressionContext struct {
	*ExpressionContext
	op antlr.Token
}

func NewSpaceshipExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SpaceshipExpressionContext {
	var p = new(SpaceshipExpressionContext)

	p.ExpressionContext = NewEmptyExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ExpressionContext))

	return p
}

func (s *SpaceshipExpressionContext) GetOp() antlr.Token { return s.op }

func (s *SpaceshipExpressionContext) SetOp(v antlr.Token) { s.op = v }

func (s *SpaceshipExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SpaceshipExpressionContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *SpaceshipExpressionContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *SpaceshipExpressionContext) Spaceship() antlr.TerminalNode {
	return s.GetToken(PHPParserSpaceship, 0)
}

func (s *SpaceshipExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PHPParserVisitor:
		return t.VisitSpaceshipExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

type ConditionalExpressionContext struct {
	*ExpressionContext
	op antlr.Token
}

func NewConditionalExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ConditionalExpressionContext {
	var p = new(ConditionalExpressionContext)

	p.ExpressionContext = NewEmptyExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ExpressionContext))

	return p
}

func (s *ConditionalExpressionContext) GetOp() antlr.Token { return s.op }

func (s *ConditionalExpressionContext) SetOp(v antlr.Token) { s.op = v }

func (s *ConditionalExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ConditionalExpressionContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *ConditionalExpressionContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ConditionalExpressionContext) Colon() antlr.TerminalNode {
	return s.GetToken(PHPParserColon, 0)
}

func (s *ConditionalExpressionContext) QuestionMark() antlr.TerminalNode {
	return s.GetToken(PHPParserQuestionMark, 0)
}

func (s *ConditionalExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PHPParserVisitor:
		return t.VisitConditionalExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

type NullCoalescingExpressionContext struct {
	*ExpressionContext
	op antlr.Token
}

func NewNullCoalescingExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *NullCoalescingExpressionContext {
	var p = new(NullCoalescingExpressionContext)

	p.ExpressionContext = NewEmptyExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ExpressionContext))

	return p
}

func (s *NullCoalescingExpressionContext) GetOp() antlr.Token { return s.op }

func (s *NullCoalescingExpressionContext) SetOp(v antlr.Token) { s.op = v }

func (s *NullCoalescingExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NullCoalescingExpressionContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *NullCoalescingExpressionContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *NullCoalescingExpressionContext) NullCoalescing() antlr.TerminalNode {
	return s.GetToken(PHPParserNullCoalescing, 0)
}

func (s *NullCoalescingExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PHPParserVisitor:
		return t.VisitNullCoalescingExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

type ArithmeticExpressionContext struct {
	*ExpressionContext
	op antlr.Token
}

func NewArithmeticExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ArithmeticExpressionContext {
	var p = new(ArithmeticExpressionContext)

	p.ExpressionContext = NewEmptyExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ExpressionContext))

	return p
}

func (s *ArithmeticExpressionContext) GetOp() antlr.Token { return s.op }

func (s *ArithmeticExpressionContext) SetOp(v antlr.Token) { s.op = v }

func (s *ArithmeticExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArithmeticExpressionContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *ArithmeticExpressionContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ArithmeticExpressionContext) Pow() antlr.TerminalNode {
	return s.GetToken(PHPParserPow, 0)
}

func (s *ArithmeticExpressionContext) Asterisk() antlr.TerminalNode {
	return s.GetToken(PHPParserAsterisk, 0)
}

func (s *ArithmeticExpressionContext) Divide() antlr.TerminalNode {
	return s.GetToken(PHPParserDivide, 0)
}

func (s *ArithmeticExpressionContext) Percent() antlr.TerminalNode {
	return s.GetToken(PHPParserPercent, 0)
}

func (s *ArithmeticExpressionContext) Plus() antlr.TerminalNode {
	return s.GetToken(PHPParserPlus, 0)
}

func (s *ArithmeticExpressionContext) Minus() antlr.TerminalNode {
	return s.GetToken(PHPParserMinus, 0)
}

func (s *ArithmeticExpressionContext) Dot() antlr.TerminalNode {
	return s.GetToken(PHPParserDot, 0)
}

func (s *ArithmeticExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PHPParserVisitor:
		return t.VisitArithmeticExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

type IndexerExpressionContext struct {
	*ExpressionContext
}

func NewIndexerExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *IndexerExpressionContext {
	var p = new(IndexerExpressionContext)

	p.ExpressionContext = NewEmptyExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ExpressionContext))

	return p
}

func (s *IndexerExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IndexerExpressionContext) StringConstant() IStringConstantContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringConstantContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringConstantContext)
}

func (s *IndexerExpressionContext) OpenSquareBracket() antlr.TerminalNode {
	return s.GetToken(PHPParserOpenSquareBracket, 0)
}

func (s *IndexerExpressionContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *IndexerExpressionContext) CloseSquareBracket() antlr.TerminalNode {
	return s.GetToken(PHPParserCloseSquareBracket, 0)
}

func (s *IndexerExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PHPParserVisitor:
		return t.VisitIndexerExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

type ScalarExpressionContext struct {
	*ExpressionContext
}

func NewScalarExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ScalarExpressionContext {
	var p = new(ScalarExpressionContext)

	p.ExpressionContext = NewEmptyExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ExpressionContext))

	return p
}

func (s *ScalarExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ScalarExpressionContext) Constant() IConstantContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConstantContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConstantContext)
}

func (s *ScalarExpressionContext) String_() IStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *ScalarExpressionContext) Label() antlr.TerminalNode {
	return s.GetToken(PHPParserLabel, 0)
}

func (s *ScalarExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PHPParserVisitor:
		return t.VisitScalarExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

type PrefixIncDecExpressionContext struct {
	*ExpressionContext
}

func NewPrefixIncDecExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *PrefixIncDecExpressionContext {
	var p = new(PrefixIncDecExpressionContext)

	p.ExpressionContext = NewEmptyExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ExpressionContext))

	return p
}

func (s *PrefixIncDecExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrefixIncDecExpressionContext) Chain() IChainContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IChainContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IChainContext)
}

func (s *PrefixIncDecExpressionContext) Inc() antlr.TerminalNode {
	return s.GetToken(PHPParserInc, 0)
}

func (s *PrefixIncDecExpressionContext) Dec() antlr.TerminalNode {
	return s.GetToken(PHPParserDec, 0)
}

func (s *PrefixIncDecExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PHPParserVisitor:
		return t.VisitPrefixIncDecExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

type ComparisonExpressionContext struct {
	*ExpressionContext
	op antlr.Token
}

func NewComparisonExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ComparisonExpressionContext {
	var p = new(ComparisonExpressionContext)

	p.ExpressionContext = NewEmptyExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ExpressionContext))

	return p
}

func (s *ComparisonExpressionContext) GetOp() antlr.Token { return s.op }

func (s *ComparisonExpressionContext) SetOp(v antlr.Token) { s.op = v }

func (s *ComparisonExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ComparisonExpressionContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *ComparisonExpressionContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ComparisonExpressionContext) ShiftLeft() antlr.TerminalNode {
	return s.GetToken(PHPParserShiftLeft, 0)
}

func (s *ComparisonExpressionContext) ShiftRight() antlr.TerminalNode {
	return s.GetToken(PHPParserShiftRight, 0)
}

func (s *ComparisonExpressionContext) Less() antlr.TerminalNode {
	return s.GetToken(PHPParserLess, 0)
}

func (s *ComparisonExpressionContext) IsSmallerOrEqual() antlr.TerminalNode {
	return s.GetToken(PHPParserIsSmallerOrEqual, 0)
}

func (s *ComparisonExpressionContext) Greater() antlr.TerminalNode {
	return s.GetToken(PHPParserGreater, 0)
}

func (s *ComparisonExpressionContext) IsGreaterOrEqual() antlr.TerminalNode {
	return s.GetToken(PHPParserIsGreaterOrEqual, 0)
}

func (s *ComparisonExpressionContext) IsIdentical() antlr.TerminalNode {
	return s.GetToken(PHPParserIsIdentical, 0)
}

func (s *ComparisonExpressionContext) IsNoidentical() antlr.TerminalNode {
	return s.GetToken(PHPParserIsNoidentical, 0)
}

func (s *ComparisonExpressionContext) IsEqual() antlr.TerminalNode {
	return s.GetToken(PHPParserIsEqual, 0)
}

func (s *ComparisonExpressionContext) IsNotEq() antlr.TerminalNode {
	return s.GetToken(PHPParserIsNotEq, 0)
}

func (s *ComparisonExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PHPParserVisitor:
		return t.VisitComparisonExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

type CastExpressionContext struct {
	*ExpressionContext
}

func NewCastExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CastExpressionContext {
	var p = new(CastExpressionContext)

	p.ExpressionContext = NewEmptyExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ExpressionContext))

	return p
}

func (s *CastExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CastExpressionContext) OpenRoundBracket() antlr.TerminalNode {
	return s.GetToken(PHPParserOpenRoundBracket, 0)
}

func (s *CastExpressionContext) CastOperation() ICastOperationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICastOperationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICastOperationContext)
}

func (s *CastExpressionContext) CloseRoundBracket() antlr.TerminalNode {
	return s.GetToken(PHPParserCloseRoundBracket, 0)
}

func (s *CastExpressionContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *CastExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PHPParserVisitor:
		return t.VisitCastExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

type InstanceOfExpressionContext struct {
	*ExpressionContext
}

func NewInstanceOfExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *InstanceOfExpressionContext {
	var p = new(InstanceOfExpressionContext)

	p.ExpressionContext = NewEmptyExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ExpressionContext))

	return p
}

func (s *InstanceOfExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InstanceOfExpressionContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *InstanceOfExpressionContext) InstanceOf() antlr.TerminalNode {
	return s.GetToken(PHPParserInstanceOf, 0)
}

func (s *InstanceOfExpressionContext) TypeRef() ITypeRefContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeRefContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeRefContext)
}

func (s *InstanceOfExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PHPParserVisitor:
		return t.VisitInstanceOfExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

type ArrayDestructExpressionContext struct {
	*ExpressionContext
}

func NewArrayDestructExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ArrayDestructExpressionContext {
	var p = new(ArrayDestructExpressionContext)

	p.ExpressionContext = NewEmptyExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ExpressionContext))

	return p
}

func (s *ArrayDestructExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArrayDestructExpressionContext) ArrayDestructuring() IArrayDestructuringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArrayDestructuringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArrayDestructuringContext)
}

func (s *ArrayDestructExpressionContext) Eq() antlr.TerminalNode {
	return s.GetToken(PHPParserEq, 0)
}

func (s *ArrayDestructExpressionContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ArrayDestructExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PHPParserVisitor:
		return t.VisitArrayDestructExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

type LambdaFunctionExpressionContext struct {
	*ExpressionContext
}

func NewLambdaFunctionExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LambdaFunctionExpressionContext {
	var p = new(LambdaFunctionExpressionContext)

	p.ExpressionContext = NewEmptyExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ExpressionContext))

	return p
}

func (s *LambdaFunctionExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LambdaFunctionExpressionContext) LambdaFunctionExpr() ILambdaFunctionExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILambdaFunctionExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILambdaFunctionExprContext)
}

func (s *LambdaFunctionExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PHPParserVisitor:
		return t.VisitLambdaFunctionExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

type BitwiseExpressionContext struct {
	*ExpressionContext
	op antlr.Token
}

func NewBitwiseExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *BitwiseExpressionContext {
	var p = new(BitwiseExpressionContext)

	p.ExpressionContext = NewEmptyExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ExpressionContext))

	return p
}

func (s *BitwiseExpressionContext) GetOp() antlr.Token { return s.op }

func (s *BitwiseExpressionContext) SetOp(v antlr.Token) { s.op = v }

func (s *BitwiseExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BitwiseExpressionContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *BitwiseExpressionContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *BitwiseExpressionContext) Ampersand() antlr.TerminalNode {
	return s.GetToken(PHPParserAmpersand, 0)
}

func (s *BitwiseExpressionContext) Caret() antlr.TerminalNode {
	return s.GetToken(PHPParserCaret, 0)
}

func (s *BitwiseExpressionContext) Pipe() antlr.TerminalNode {
	return s.GetToken(PHPParserPipe, 0)
}

func (s *BitwiseExpressionContext) BooleanAnd() antlr.TerminalNode {
	return s.GetToken(PHPParserBooleanAnd, 0)
}

func (s *BitwiseExpressionContext) BooleanOr() antlr.TerminalNode {
	return s.GetToken(PHPParserBooleanOr, 0)
}

func (s *BitwiseExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PHPParserVisitor:
		return t.VisitBitwiseExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PHPParser) Expression() (localctx IExpressionContext) {
	return p.expression(0)
}

func (p *PHPParser) expression(_p int) (localctx IExpressionContext) {
	this := p
	_ = this

	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()
	_parentState := p.GetState()
	localctx = NewExpressionContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IExpressionContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 166
	p.EnterRecursionRule(localctx, 166, PHPParserRULE_expression, _p)
	var _la int

	defer func() {
		p.UnrollRecursionContexts(_parentctx)
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1284)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 140, p.GetParserRuleContext()) {
	case 1:
		localctx = NewCloneExpressionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx

		{
			p.SetState(1195)
			p.Match(PHPParserClone)
		}
		{
			p.SetState(1196)
			p.expression(48)
		}

	case 2:
		localctx = NewKeywordNewExpressionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1197)
			p.NewExpr()
		}

	case 3:
		localctx = NewIndexerExpressionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1198)
			p.StringConstant()
		}
		{
			p.SetState(1199)
			p.Match(PHPParserOpenSquareBracket)
		}
		{
			p.SetState(1200)
			p.expression(0)
		}
		{
			p.SetState(1201)
			p.Match(PHPParserCloseSquareBracket)
		}

	case 4:
		localctx = NewCastExpressionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1203)
			p.Match(PHPParserOpenRoundBracket)
		}
		{
			p.SetState(1204)
			p.CastOperation()
		}
		{
			p.SetState(1205)
			p.Match(PHPParserCloseRoundBracket)
		}
		{
			p.SetState(1206)
			p.expression(45)
		}

	case 5:
		localctx = NewUnaryOperatorExpressionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1208)
			_la = p.GetTokenStream().LA(1)

			if !(_la == PHPParserTilde || _la == PHPParserSuppressWarnings) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(1209)
			p.expression(44)
		}

	case 6:
		localctx = NewUnaryOperatorExpressionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1210)
			_la = p.GetTokenStream().LA(1)

			if !((int64((_la-200)) & ^0x3f) == 0 && ((int64(1)<<(_la-200))&13) != 0) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(1211)
			p.expression(43)
		}

	case 7:
		localctx = NewPrefixIncDecExpressionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1212)
			_la = p.GetTokenStream().LA(1)

			if !(_la == PHPParserInc || _la == PHPParserDec) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(1213)
			p.Chain()
		}

	case 8:
		localctx = NewPostfixIncDecExpressionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1214)
			p.Chain()
		}
		{
			p.SetState(1215)
			_la = p.GetTokenStream().LA(1)

			if !(_la == PHPParserInc || _la == PHPParserDec) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case 9:
		localctx = NewPrintExpressionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1217)
			p.Match(PHPParserPrint)
		}
		{
			p.SetState(1218)
			p.expression(40)
		}

	case 10:
		localctx = NewArrayCreationExpressionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1219)
			p.ArrayCreation()
		}

	case 11:
		localctx = NewChainExpressionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1220)
			p.Chain()
		}

	case 12:
		localctx = NewScalarExpressionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1221)
			p.Constant()
		}

	case 13:
		localctx = NewScalarExpressionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1222)
			p.String_()
		}

	case 14:
		localctx = NewScalarExpressionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1223)
			p.Match(PHPParserLabel)
		}

	case 15:
		localctx = NewBackQuoteStringExpressionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1224)
			p.Match(PHPParserBackQuoteString)
		}

	case 16:
		localctx = NewParenthesisExpressionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1225)
			p.Parentheses()
		}

	case 17:
		localctx = NewSpecialWordExpressionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1226)
			p.Match(PHPParserYield)
		}

	case 18:
		localctx = NewSpecialWordExpressionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1227)
			p.Match(PHPParserList)
		}
		{
			p.SetState(1228)
			p.Match(PHPParserOpenRoundBracket)
		}
		{
			p.SetState(1229)
			p.AssignmentList()
		}
		{
			p.SetState(1230)
			p.Match(PHPParserCloseRoundBracket)
		}
		{
			p.SetState(1231)
			p.Match(PHPParserEq)
		}
		{
			p.SetState(1232)
			p.expression(31)
		}

	case 19:
		localctx = NewSpecialWordExpressionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1234)
			p.Match(PHPParserIsSet)
		}
		{
			p.SetState(1235)
			p.Match(PHPParserOpenRoundBracket)
		}
		{
			p.SetState(1236)
			p.ChainList()
		}
		{
			p.SetState(1237)
			p.Match(PHPParserCloseRoundBracket)
		}

	case 20:
		localctx = NewSpecialWordExpressionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1239)
			p.Match(PHPParserEmpty)
		}
		{
			p.SetState(1240)
			p.Match(PHPParserOpenRoundBracket)
		}
		{
			p.SetState(1241)
			p.Chain()
		}
		{
			p.SetState(1242)
			p.Match(PHPParserCloseRoundBracket)
		}

	case 21:
		localctx = NewSpecialWordExpressionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1244)
			p.Match(PHPParserEval)
		}
		{
			p.SetState(1245)
			p.Match(PHPParserOpenRoundBracket)
		}
		{
			p.SetState(1246)
			p.expression(0)
		}
		{
			p.SetState(1247)
			p.Match(PHPParserCloseRoundBracket)
		}

	case 22:
		localctx = NewSpecialWordExpressionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1249)
			p.Match(PHPParserExit)
		}
		p.SetState(1253)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 136, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1250)
				p.Match(PHPParserOpenRoundBracket)
			}
			{
				p.SetState(1251)
				p.Match(PHPParserCloseRoundBracket)
			}

		} else if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 136, p.GetParserRuleContext()) == 2 {
			{
				p.SetState(1252)
				p.Parentheses()
			}

		}

	case 23:
		localctx = NewSpecialWordExpressionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1255)
			_la = p.GetTokenStream().LA(1)

			if !(_la == PHPParserInclude || _la == PHPParserIncludeOnce) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(1256)
			p.expression(26)
		}

	case 24:
		localctx = NewSpecialWordExpressionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1257)
			_la = p.GetTokenStream().LA(1)

			if !(_la == PHPParserRequire || _la == PHPParserRequireOnce) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(1258)
			p.expression(25)
		}

	case 25:
		localctx = NewLambdaFunctionExpressionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1259)
			p.LambdaFunctionExpr()
		}

	case 26:
		localctx = NewMatchExpressionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1260)
			p.MatchExpr()
		}

	case 27:
		localctx = NewSpecialWordExpressionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1261)
			p.Match(PHPParserThrow)
		}
		{
			p.SetState(1262)
			p.expression(7)
		}

	case 28:
		localctx = NewArrayDestructExpressionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1263)
			p.ArrayDestructuring()
		}
		{
			p.SetState(1264)
			p.Match(PHPParserEq)
		}
		{
			p.SetState(1265)
			p.expression(6)
		}

	case 29:
		localctx = NewAssignmentExpressionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1267)
			p.Assignable()
		}
		{
			p.SetState(1268)
			p.AssignmentOperator()
		}
		p.SetState(1270)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == PHPParserAttributeStart {
			{
				p.SetState(1269)
				p.Attributes()
			}

		}
		{
			p.SetState(1272)
			p.expression(5)
		}

	case 30:
		localctx = NewAssignmentExpressionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1274)
			p.Assignable()
		}
		{
			p.SetState(1275)
			p.Match(PHPParserEq)
		}
		p.SetState(1277)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == PHPParserAttributeStart {
			{
				p.SetState(1276)
				p.Attributes()
			}

		}
		{
			p.SetState(1279)
			p.Match(PHPParserAmpersand)
		}
		p.SetState(1282)
		p.GetErrorHandler().Sync(p)
		switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 139, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(1280)
				p.Chain()
			}

		case 2:
			{
				p.SetState(1281)
				p.NewExpr()
			}

		}

	}
	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(1346)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 143, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			p.SetState(1344)
			p.GetErrorHandler().Sync(p)
			switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 142, p.GetParserRuleContext()) {
			case 1:
				localctx = NewArithmeticExpressionContext(p, NewExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, PHPParserRULE_expression)
				p.SetState(1286)

				if !(p.Precpred(p.GetParserRuleContext(), 22)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 22)", ""))
				}
				{
					p.SetState(1287)

					var _m = p.Match(PHPParserPow)

					localctx.(*ArithmeticExpressionContext).op = _m
				}
				{
					p.SetState(1288)
					p.expression(22)
				}

			case 2:
				localctx = NewArithmeticExpressionContext(p, NewExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, PHPParserRULE_expression)
				p.SetState(1289)

				if !(p.Precpred(p.GetParserRuleContext(), 20)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 20)", ""))
				}
				{
					p.SetState(1290)

					var _lt = p.GetTokenStream().LT(1)

					localctx.(*ArithmeticExpressionContext).op = _lt

					_la = p.GetTokenStream().LA(1)

					if !((int64((_la-204)) & ^0x3f) == 0 && ((int64(1)<<(_la-204))&7) != 0) {
						var _ri = p.GetErrorHandler().RecoverInline(p)

						localctx.(*ArithmeticExpressionContext).op = _ri
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				{
					p.SetState(1291)
					p.expression(21)
				}

			case 3:
				localctx = NewArithmeticExpressionContext(p, NewExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, PHPParserRULE_expression)
				p.SetState(1292)

				if !(p.Precpred(p.GetParserRuleContext(), 19)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 19)", ""))
				}
				{
					p.SetState(1293)

					var _lt = p.GetTokenStream().LT(1)

					localctx.(*ArithmeticExpressionContext).op = _lt

					_la = p.GetTokenStream().LA(1)

					if !((int64((_la-202)) & ^0x3f) == 0 && ((int64(1)<<(_la-202))&259) != 0) {
						var _ri = p.GetErrorHandler().RecoverInline(p)

						localctx.(*ArithmeticExpressionContext).op = _ri
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				{
					p.SetState(1294)
					p.expression(20)
				}

			case 4:
				localctx = NewComparisonExpressionContext(p, NewExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, PHPParserRULE_expression)
				p.SetState(1295)

				if !(p.Precpred(p.GetParserRuleContext(), 18)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 18)", ""))
				}
				{
					p.SetState(1296)

					var _lt = p.GetTokenStream().LT(1)

					localctx.(*ComparisonExpressionContext).op = _lt

					_la = p.GetTokenStream().LA(1)

					if !(_la == PHPParserShiftLeft || _la == PHPParserShiftRight) {
						var _ri = p.GetErrorHandler().RecoverInline(p)

						localctx.(*ComparisonExpressionContext).op = _ri
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				{
					p.SetState(1297)
					p.expression(19)
				}

			case 5:
				localctx = NewComparisonExpressionContext(p, NewExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, PHPParserRULE_expression)
				p.SetState(1298)

				if !(p.Precpred(p.GetParserRuleContext(), 17)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 17)", ""))
				}
				{
					p.SetState(1299)

					var _lt = p.GetTokenStream().LT(1)

					localctx.(*ComparisonExpressionContext).op = _lt

					_la = p.GetTokenStream().LA(1)

					if !((int64((_la-171)) & ^0x3f) == 0 && ((int64(1)<<(_la-171))&100663299) != 0) {
						var _ri = p.GetErrorHandler().RecoverInline(p)

						localctx.(*ComparisonExpressionContext).op = _ri
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				{
					p.SetState(1300)
					p.expression(18)
				}

			case 6:
				localctx = NewComparisonExpressionContext(p, NewExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, PHPParserRULE_expression)
				p.SetState(1301)

				if !(p.Precpred(p.GetParserRuleContext(), 16)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 16)", ""))
				}
				{
					p.SetState(1302)

					var _lt = p.GetTokenStream().LT(1)

					localctx.(*ComparisonExpressionContext).op = _lt

					_la = p.GetTokenStream().LA(1)

					if !((int64((_la-167)) & ^0x3f) == 0 && ((int64(1)<<(_la-167))&15) != 0) {
						var _ri = p.GetErrorHandler().RecoverInline(p)

						localctx.(*ComparisonExpressionContext).op = _ri
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				{
					p.SetState(1303)
					p.expression(17)
				}

			case 7:
				localctx = NewBitwiseExpressionContext(p, NewExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, PHPParserRULE_expression)
				p.SetState(1304)

				if !(p.Precpred(p.GetParserRuleContext(), 15)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 15)", ""))
				}
				{
					p.SetState(1305)

					var _m = p.Match(PHPParserAmpersand)

					localctx.(*BitwiseExpressionContext).op = _m
				}
				{
					p.SetState(1306)
					p.expression(16)
				}

			case 8:
				localctx = NewBitwiseExpressionContext(p, NewExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, PHPParserRULE_expression)
				p.SetState(1307)

				if !(p.Precpred(p.GetParserRuleContext(), 14)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 14)", ""))
				}
				{
					p.SetState(1308)

					var _m = p.Match(PHPParserCaret)

					localctx.(*BitwiseExpressionContext).op = _m
				}
				{
					p.SetState(1309)
					p.expression(15)
				}

			case 9:
				localctx = NewBitwiseExpressionContext(p, NewExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, PHPParserRULE_expression)
				p.SetState(1310)

				if !(p.Precpred(p.GetParserRuleContext(), 13)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 13)", ""))
				}
				{
					p.SetState(1311)

					var _m = p.Match(PHPParserPipe)

					localctx.(*BitwiseExpressionContext).op = _m
				}
				{
					p.SetState(1312)
					p.expression(14)
				}

			case 10:
				localctx = NewBitwiseExpressionContext(p, NewExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, PHPParserRULE_expression)
				p.SetState(1313)

				if !(p.Precpred(p.GetParserRuleContext(), 12)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 12)", ""))
				}
				{
					p.SetState(1314)

					var _m = p.Match(PHPParserBooleanAnd)

					localctx.(*BitwiseExpressionContext).op = _m
				}
				{
					p.SetState(1315)
					p.expression(13)
				}

			case 11:
				localctx = NewBitwiseExpressionContext(p, NewExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, PHPParserRULE_expression)
				p.SetState(1316)

				if !(p.Precpred(p.GetParserRuleContext(), 11)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 11)", ""))
				}
				{
					p.SetState(1317)

					var _m = p.Match(PHPParserBooleanOr)

					localctx.(*BitwiseExpressionContext).op = _m
				}
				{
					p.SetState(1318)
					p.expression(12)
				}

			case 12:
				localctx = NewConditionalExpressionContext(p, NewExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, PHPParserRULE_expression)
				p.SetState(1319)

				if !(p.Precpred(p.GetParserRuleContext(), 10)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 10)", ""))
				}
				{
					p.SetState(1320)

					var _m = p.Match(PHPParserQuestionMark)

					localctx.(*ConditionalExpressionContext).op = _m
				}
				p.SetState(1322)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)

				if (int64((_la-44)) & ^0x3f) == 0 && ((int64(1)<<(_la-44))&-1) != 0 || (int64((_la-108)) & ^0x3f) == 0 && ((int64(1)<<(_la-108))&441352763482308607) != 0 || (int64((_la-194)) & ^0x3f) == 0 && ((int64(1)<<(_la-194))&4396974138177) != 0 {
					{
						p.SetState(1321)
						p.expression(0)
					}

				}
				{
					p.SetState(1324)
					p.Match(PHPParserColon)
				}
				{
					p.SetState(1325)
					p.expression(11)
				}

			case 13:
				localctx = NewNullCoalescingExpressionContext(p, NewExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, PHPParserRULE_expression)
				p.SetState(1326)

				if !(p.Precpred(p.GetParserRuleContext(), 9)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 9)", ""))
				}
				{
					p.SetState(1327)

					var _m = p.Match(PHPParserNullCoalescing)

					localctx.(*NullCoalescingExpressionContext).op = _m
				}
				{
					p.SetState(1328)
					p.expression(10)
				}

			case 14:
				localctx = NewSpaceshipExpressionContext(p, NewExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, PHPParserRULE_expression)
				p.SetState(1329)

				if !(p.Precpred(p.GetParserRuleContext(), 8)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 8)", ""))
				}
				{
					p.SetState(1330)

					var _m = p.Match(PHPParserSpaceship)

					localctx.(*SpaceshipExpressionContext).op = _m
				}
				{
					p.SetState(1331)
					p.expression(9)
				}

			case 15:
				localctx = NewLogicalExpressionContext(p, NewExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, PHPParserRULE_expression)
				p.SetState(1332)

				if !(p.Precpred(p.GetParserRuleContext(), 3)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 3)", ""))
				}
				{
					p.SetState(1333)

					var _m = p.Match(PHPParserLogicalAnd)

					localctx.(*LogicalExpressionContext).op = _m
				}
				{
					p.SetState(1334)
					p.expression(4)
				}

			case 16:
				localctx = NewLogicalExpressionContext(p, NewExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, PHPParserRULE_expression)
				p.SetState(1335)

				if !(p.Precpred(p.GetParserRuleContext(), 2)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 2)", ""))
				}
				{
					p.SetState(1336)

					var _m = p.Match(PHPParserLogicalXor)

					localctx.(*LogicalExpressionContext).op = _m
				}
				{
					p.SetState(1337)
					p.expression(3)
				}

			case 17:
				localctx = NewLogicalExpressionContext(p, NewExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, PHPParserRULE_expression)
				p.SetState(1338)

				if !(p.Precpred(p.GetParserRuleContext(), 1)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 1)", ""))
				}
				{
					p.SetState(1339)

					var _m = p.Match(PHPParserLogicalOr)

					localctx.(*LogicalExpressionContext).op = _m
				}
				{
					p.SetState(1340)
					p.expression(2)
				}

			case 18:
				localctx = NewInstanceOfExpressionContext(p, NewExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, PHPParserRULE_expression)
				p.SetState(1341)

				if !(p.Precpred(p.GetParserRuleContext(), 21)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 21)", ""))
				}
				{
					p.SetState(1342)
					p.Match(PHPParserInstanceOf)
				}
				{
					p.SetState(1343)
					p.TypeRef()
				}

			}

		}
		p.SetState(1348)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 143, p.GetParserRuleContext())
	}

	return localctx
}

// IAssignableContext is an interface to support dynamic dispatch.
type IAssignableContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAssignableContext differentiates from other interfaces.
	IsAssignableContext()
}

type AssignableContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAssignableContext() *AssignableContext {
	var p = new(AssignableContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PHPParserRULE_assignable
	return p
}

func (*AssignableContext) IsAssignableContext() {}

func NewAssignableContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AssignableContext {
	var p = new(AssignableContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PHPParserRULE_assignable

	return p
}

func (s *AssignableContext) GetParser() antlr.Parser { return s.parser }

func (s *AssignableContext) Chain() IChainContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IChainContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IChainContext)
}

func (s *AssignableContext) ArrayCreation() IArrayCreationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArrayCreationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArrayCreationContext)
}

func (s *AssignableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AssignableContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AssignableContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PHPParserVisitor:
		return t.VisitAssignable(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PHPParser) Assignable() (localctx IAssignableContext) {
	this := p
	_ = this

	localctx = NewAssignableContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 168, PHPParserRULE_assignable)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1351)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 144, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1349)
			p.Chain()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1350)
			p.ArrayCreation()
		}

	}

	return localctx
}

// IArrayCreationContext is an interface to support dynamic dispatch.
type IArrayCreationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsArrayCreationContext differentiates from other interfaces.
	IsArrayCreationContext()
}

type ArrayCreationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyArrayCreationContext() *ArrayCreationContext {
	var p = new(ArrayCreationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PHPParserRULE_arrayCreation
	return p
}

func (*ArrayCreationContext) IsArrayCreationContext() {}

func NewArrayCreationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ArrayCreationContext {
	var p = new(ArrayCreationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PHPParserRULE_arrayCreation

	return p
}

func (s *ArrayCreationContext) GetParser() antlr.Parser { return s.parser }

func (s *ArrayCreationContext) Array() antlr.TerminalNode {
	return s.GetToken(PHPParserArray, 0)
}

func (s *ArrayCreationContext) OpenRoundBracket() antlr.TerminalNode {
	return s.GetToken(PHPParserOpenRoundBracket, 0)
}

func (s *ArrayCreationContext) CloseRoundBracket() antlr.TerminalNode {
	return s.GetToken(PHPParserCloseRoundBracket, 0)
}

func (s *ArrayCreationContext) AllOpenSquareBracket() []antlr.TerminalNode {
	return s.GetTokens(PHPParserOpenSquareBracket)
}

func (s *ArrayCreationContext) OpenSquareBracket(i int) antlr.TerminalNode {
	return s.GetToken(PHPParserOpenSquareBracket, i)
}

func (s *ArrayCreationContext) AllCloseSquareBracket() []antlr.TerminalNode {
	return s.GetTokens(PHPParserCloseSquareBracket)
}

func (s *ArrayCreationContext) CloseSquareBracket(i int) antlr.TerminalNode {
	return s.GetToken(PHPParserCloseSquareBracket, i)
}

func (s *ArrayCreationContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ArrayCreationContext) ArrayItemList() IArrayItemListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArrayItemListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArrayItemListContext)
}

func (s *ArrayCreationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArrayCreationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ArrayCreationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PHPParserVisitor:
		return t.VisitArrayCreation(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PHPParser) ArrayCreation() (localctx IArrayCreationContext) {
	this := p
	_ = this

	localctx = NewArrayCreationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 170, PHPParserRULE_arrayCreation)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1364)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case PHPParserArray:
		{
			p.SetState(1353)
			p.Match(PHPParserArray)
		}
		{
			p.SetState(1354)
			p.Match(PHPParserOpenRoundBracket)
		}
		p.SetState(1356)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if (int64((_la-44)) & ^0x3f) == 0 && ((int64(1)<<(_la-44))&-1) != 0 || (int64((_la-108)) & ^0x3f) == 0 && ((int64(1)<<(_la-108))&441352763482308607) != 0 || (int64((_la-194)) & ^0x3f) == 0 && ((int64(1)<<(_la-194))&4396974138193) != 0 {
			{
				p.SetState(1355)
				p.ArrayItemList()
			}

		}
		{
			p.SetState(1358)
			p.Match(PHPParserCloseRoundBracket)
		}

	case PHPParserOpenSquareBracket:
		{
			p.SetState(1359)
			p.Match(PHPParserOpenSquareBracket)
		}
		p.SetState(1361)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if (int64((_la-44)) & ^0x3f) == 0 && ((int64(1)<<(_la-44))&-1) != 0 || (int64((_la-108)) & ^0x3f) == 0 && ((int64(1)<<(_la-108))&441352763482308607) != 0 || (int64((_la-194)) & ^0x3f) == 0 && ((int64(1)<<(_la-194))&4396974138193) != 0 {
			{
				p.SetState(1360)
				p.ArrayItemList()
			}

		}
		{
			p.SetState(1363)
			p.Match(PHPParserCloseSquareBracket)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}
	p.SetState(1370)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 148, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1366)
			p.Match(PHPParserOpenSquareBracket)
		}
		{
			p.SetState(1367)
			p.expression(0)
		}
		{
			p.SetState(1368)
			p.Match(PHPParserCloseSquareBracket)
		}

	}

	return localctx
}

// IArrayDestructuringContext is an interface to support dynamic dispatch.
type IArrayDestructuringContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsArrayDestructuringContext differentiates from other interfaces.
	IsArrayDestructuringContext()
}

type ArrayDestructuringContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyArrayDestructuringContext() *ArrayDestructuringContext {
	var p = new(ArrayDestructuringContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PHPParserRULE_arrayDestructuring
	return p
}

func (*ArrayDestructuringContext) IsArrayDestructuringContext() {}

func NewArrayDestructuringContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ArrayDestructuringContext {
	var p = new(ArrayDestructuringContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PHPParserRULE_arrayDestructuring

	return p
}

func (s *ArrayDestructuringContext) GetParser() antlr.Parser { return s.parser }

func (s *ArrayDestructuringContext) OpenSquareBracket() antlr.TerminalNode {
	return s.GetToken(PHPParserOpenSquareBracket, 0)
}

func (s *ArrayDestructuringContext) AllIndexedDestructItem() []IIndexedDestructItemContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIndexedDestructItemContext); ok {
			len++
		}
	}

	tst := make([]IIndexedDestructItemContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIndexedDestructItemContext); ok {
			tst[i] = t.(IIndexedDestructItemContext)
			i++
		}
	}

	return tst
}

func (s *ArrayDestructuringContext) IndexedDestructItem(i int) IIndexedDestructItemContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIndexedDestructItemContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIndexedDestructItemContext)
}

func (s *ArrayDestructuringContext) CloseSquareBracket() antlr.TerminalNode {
	return s.GetToken(PHPParserCloseSquareBracket, 0)
}

func (s *ArrayDestructuringContext) AllComma() []antlr.TerminalNode {
	return s.GetTokens(PHPParserComma)
}

func (s *ArrayDestructuringContext) Comma(i int) antlr.TerminalNode {
	return s.GetToken(PHPParserComma, i)
}

func (s *ArrayDestructuringContext) AllKeyedDestructItem() []IKeyedDestructItemContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IKeyedDestructItemContext); ok {
			len++
		}
	}

	tst := make([]IKeyedDestructItemContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IKeyedDestructItemContext); ok {
			tst[i] = t.(IKeyedDestructItemContext)
			i++
		}
	}

	return tst
}

func (s *ArrayDestructuringContext) KeyedDestructItem(i int) IKeyedDestructItemContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKeyedDestructItemContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKeyedDestructItemContext)
}

func (s *ArrayDestructuringContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArrayDestructuringContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ArrayDestructuringContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PHPParserVisitor:
		return t.VisitArrayDestructuring(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PHPParser) ArrayDestructuring() (localctx IArrayDestructuringContext) {
	this := p
	_ = this

	localctx = NewArrayDestructuringContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 172, PHPParserRULE_arrayDestructuring)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.SetState(1417)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 156, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1372)
			p.Match(PHPParserOpenSquareBracket)
		}
		p.SetState(1376)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == PHPParserComma {
			{
				p.SetState(1373)
				p.Match(PHPParserComma)
			}

			p.SetState(1378)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1379)
			p.IndexedDestructItem()
		}
		p.SetState(1388)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 151, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				p.SetState(1381)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)

				for ok := true; ok; ok = _la == PHPParserComma {
					{
						p.SetState(1380)
						p.Match(PHPParserComma)
					}

					p.SetState(1383)
					p.GetErrorHandler().Sync(p)
					_la = p.GetTokenStream().LA(1)
				}
				{
					p.SetState(1385)
					p.IndexedDestructItem()
				}

			}
			p.SetState(1390)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 151, p.GetParserRuleContext())
		}
		p.SetState(1394)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == PHPParserComma {
			{
				p.SetState(1391)
				p.Match(PHPParserComma)
			}

			p.SetState(1396)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1397)
			p.Match(PHPParserCloseSquareBracket)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1399)
			p.Match(PHPParserOpenSquareBracket)
		}
		{
			p.SetState(1400)
			p.KeyedDestructItem()
		}
		p.SetState(1409)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 154, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				p.SetState(1402)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)

				for ok := true; ok; ok = _la == PHPParserComma {
					{
						p.SetState(1401)
						p.Match(PHPParserComma)
					}

					p.SetState(1404)
					p.GetErrorHandler().Sync(p)
					_la = p.GetTokenStream().LA(1)
				}
				{
					p.SetState(1406)
					p.KeyedDestructItem()
				}

			}
			p.SetState(1411)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 154, p.GetParserRuleContext())
		}
		p.SetState(1413)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == PHPParserComma {
			{
				p.SetState(1412)
				p.Match(PHPParserComma)
			}

		}
		{
			p.SetState(1415)
			p.Match(PHPParserCloseSquareBracket)
		}

	}

	return localctx
}

// IIndexedDestructItemContext is an interface to support dynamic dispatch.
type IIndexedDestructItemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsIndexedDestructItemContext differentiates from other interfaces.
	IsIndexedDestructItemContext()
}

type IndexedDestructItemContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIndexedDestructItemContext() *IndexedDestructItemContext {
	var p = new(IndexedDestructItemContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PHPParserRULE_indexedDestructItem
	return p
}

func (*IndexedDestructItemContext) IsIndexedDestructItemContext() {}

func NewIndexedDestructItemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IndexedDestructItemContext {
	var p = new(IndexedDestructItemContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PHPParserRULE_indexedDestructItem

	return p
}

func (s *IndexedDestructItemContext) GetParser() antlr.Parser { return s.parser }

func (s *IndexedDestructItemContext) Chain() IChainContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IChainContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IChainContext)
}

func (s *IndexedDestructItemContext) Ampersand() antlr.TerminalNode {
	return s.GetToken(PHPParserAmpersand, 0)
}

func (s *IndexedDestructItemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IndexedDestructItemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IndexedDestructItemContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PHPParserVisitor:
		return t.VisitIndexedDestructItem(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PHPParser) IndexedDestructItem() (localctx IIndexedDestructItemContext) {
	this := p
	_ = this

	localctx = NewIndexedDestructItemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 174, PHPParserRULE_indexedDestructItem)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1420)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == PHPParserAmpersand {
		{
			p.SetState(1419)
			p.Match(PHPParserAmpersand)
		}

	}
	{
		p.SetState(1422)
		p.Chain()
	}

	return localctx
}

// IKeyedDestructItemContext is an interface to support dynamic dispatch.
type IKeyedDestructItemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsKeyedDestructItemContext differentiates from other interfaces.
	IsKeyedDestructItemContext()
}

type KeyedDestructItemContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKeyedDestructItemContext() *KeyedDestructItemContext {
	var p = new(KeyedDestructItemContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PHPParserRULE_keyedDestructItem
	return p
}

func (*KeyedDestructItemContext) IsKeyedDestructItemContext() {}

func NewKeyedDestructItemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *KeyedDestructItemContext {
	var p = new(KeyedDestructItemContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PHPParserRULE_keyedDestructItem

	return p
}

func (s *KeyedDestructItemContext) GetParser() antlr.Parser { return s.parser }

func (s *KeyedDestructItemContext) Chain() IChainContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IChainContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IChainContext)
}

func (s *KeyedDestructItemContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *KeyedDestructItemContext) DoubleArrow() antlr.TerminalNode {
	return s.GetToken(PHPParserDoubleArrow, 0)
}

func (s *KeyedDestructItemContext) Ampersand() antlr.TerminalNode {
	return s.GetToken(PHPParserAmpersand, 0)
}

func (s *KeyedDestructItemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KeyedDestructItemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *KeyedDestructItemContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PHPParserVisitor:
		return t.VisitKeyedDestructItem(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PHPParser) KeyedDestructItem() (localctx IKeyedDestructItemContext) {
	this := p
	_ = this

	localctx = NewKeyedDestructItemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 176, PHPParserRULE_keyedDestructItem)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1427)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 158, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1424)
			p.expression(0)
		}
		{
			p.SetState(1425)
			p.Match(PHPParserDoubleArrow)
		}

	}
	p.SetState(1430)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == PHPParserAmpersand {
		{
			p.SetState(1429)
			p.Match(PHPParserAmpersand)
		}

	}
	{
		p.SetState(1432)
		p.Chain()
	}

	return localctx
}

// ILambdaFunctionExprContext is an interface to support dynamic dispatch.
type ILambdaFunctionExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLambdaFunctionExprContext differentiates from other interfaces.
	IsLambdaFunctionExprContext()
}

type LambdaFunctionExprContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLambdaFunctionExprContext() *LambdaFunctionExprContext {
	var p = new(LambdaFunctionExprContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PHPParserRULE_lambdaFunctionExpr
	return p
}

func (*LambdaFunctionExprContext) IsLambdaFunctionExprContext() {}

func NewLambdaFunctionExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LambdaFunctionExprContext {
	var p = new(LambdaFunctionExprContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PHPParserRULE_lambdaFunctionExpr

	return p
}

func (s *LambdaFunctionExprContext) GetParser() antlr.Parser { return s.parser }

func (s *LambdaFunctionExprContext) Function_() antlr.TerminalNode {
	return s.GetToken(PHPParserFunction_, 0)
}

func (s *LambdaFunctionExprContext) OpenRoundBracket() antlr.TerminalNode {
	return s.GetToken(PHPParserOpenRoundBracket, 0)
}

func (s *LambdaFunctionExprContext) FormalParameterList() IFormalParameterListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFormalParameterListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFormalParameterListContext)
}

func (s *LambdaFunctionExprContext) CloseRoundBracket() antlr.TerminalNode {
	return s.GetToken(PHPParserCloseRoundBracket, 0)
}

func (s *LambdaFunctionExprContext) BlockStatement() IBlockStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBlockStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBlockStatementContext)
}

func (s *LambdaFunctionExprContext) Static() antlr.TerminalNode {
	return s.GetToken(PHPParserStatic, 0)
}

func (s *LambdaFunctionExprContext) Ampersand() antlr.TerminalNode {
	return s.GetToken(PHPParserAmpersand, 0)
}

func (s *LambdaFunctionExprContext) LambdaFunctionUseVars() ILambdaFunctionUseVarsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILambdaFunctionUseVarsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILambdaFunctionUseVarsContext)
}

func (s *LambdaFunctionExprContext) Colon() antlr.TerminalNode {
	return s.GetToken(PHPParserColon, 0)
}

func (s *LambdaFunctionExprContext) TypeHint() ITypeHintContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeHintContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeHintContext)
}

func (s *LambdaFunctionExprContext) LambdaFn() antlr.TerminalNode {
	return s.GetToken(PHPParserLambdaFn, 0)
}

func (s *LambdaFunctionExprContext) DoubleArrow() antlr.TerminalNode {
	return s.GetToken(PHPParserDoubleArrow, 0)
}

func (s *LambdaFunctionExprContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *LambdaFunctionExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LambdaFunctionExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LambdaFunctionExprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PHPParserVisitor:
		return t.VisitLambdaFunctionExpr(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PHPParser) LambdaFunctionExpr() (localctx ILambdaFunctionExprContext) {
	this := p
	_ = this

	localctx = NewLambdaFunctionExprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 178, PHPParserRULE_lambdaFunctionExpr)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1460)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case PHPParserFunction_, PHPParserStatic:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(1435)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == PHPParserStatic {
			{
				p.SetState(1434)
				p.Match(PHPParserStatic)
			}

		}
		{
			p.SetState(1437)
			p.Match(PHPParserFunction_)
		}
		p.SetState(1439)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == PHPParserAmpersand {
			{
				p.SetState(1438)
				p.Match(PHPParserAmpersand)
			}

		}
		{
			p.SetState(1441)
			p.Match(PHPParserOpenRoundBracket)
		}
		{
			p.SetState(1442)
			p.FormalParameterList()
		}
		{
			p.SetState(1443)
			p.Match(PHPParserCloseRoundBracket)
		}
		p.SetState(1445)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == PHPParserUse {
			{
				p.SetState(1444)
				p.LambdaFunctionUseVars()
			}

		}
		p.SetState(1449)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == PHPParserColon {
			{
				p.SetState(1447)
				p.Match(PHPParserColon)
			}
			{
				p.SetState(1448)
				p.typeHint(0)
			}

		}
		{
			p.SetState(1451)
			p.BlockStatement()
		}

	case PHPParserLambdaFn:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1453)
			p.Match(PHPParserLambdaFn)
		}
		{
			p.SetState(1454)
			p.Match(PHPParserOpenRoundBracket)
		}
		{
			p.SetState(1455)
			p.FormalParameterList()
		}
		{
			p.SetState(1456)
			p.Match(PHPParserCloseRoundBracket)
		}
		{
			p.SetState(1457)
			p.Match(PHPParserDoubleArrow)
		}
		{
			p.SetState(1458)
			p.expression(0)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IMatchExprContext is an interface to support dynamic dispatch.
type IMatchExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMatchExprContext differentiates from other interfaces.
	IsMatchExprContext()
}

type MatchExprContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMatchExprContext() *MatchExprContext {
	var p = new(MatchExprContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PHPParserRULE_matchExpr
	return p
}

func (*MatchExprContext) IsMatchExprContext() {}

func NewMatchExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MatchExprContext {
	var p = new(MatchExprContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PHPParserRULE_matchExpr

	return p
}

func (s *MatchExprContext) GetParser() antlr.Parser { return s.parser }

func (s *MatchExprContext) Match_() antlr.TerminalNode {
	return s.GetToken(PHPParserMatch_, 0)
}

func (s *MatchExprContext) OpenRoundBracket() antlr.TerminalNode {
	return s.GetToken(PHPParserOpenRoundBracket, 0)
}

func (s *MatchExprContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *MatchExprContext) CloseRoundBracket() antlr.TerminalNode {
	return s.GetToken(PHPParserCloseRoundBracket, 0)
}

func (s *MatchExprContext) OpenCurlyBracket() antlr.TerminalNode {
	return s.GetToken(PHPParserOpenCurlyBracket, 0)
}

func (s *MatchExprContext) AllMatchItem() []IMatchItemContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IMatchItemContext); ok {
			len++
		}
	}

	tst := make([]IMatchItemContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IMatchItemContext); ok {
			tst[i] = t.(IMatchItemContext)
			i++
		}
	}

	return tst
}

func (s *MatchExprContext) MatchItem(i int) IMatchItemContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMatchItemContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMatchItemContext)
}

func (s *MatchExprContext) CloseCurlyBracket() antlr.TerminalNode {
	return s.GetToken(PHPParserCloseCurlyBracket, 0)
}

func (s *MatchExprContext) AllComma() []antlr.TerminalNode {
	return s.GetTokens(PHPParserComma)
}

func (s *MatchExprContext) Comma(i int) antlr.TerminalNode {
	return s.GetToken(PHPParserComma, i)
}

func (s *MatchExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MatchExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MatchExprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PHPParserVisitor:
		return t.VisitMatchExpr(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PHPParser) MatchExpr() (localctx IMatchExprContext) {
	this := p
	_ = this

	localctx = NewMatchExprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 180, PHPParserRULE_matchExpr)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1462)
		p.Match(PHPParserMatch_)
	}
	{
		p.SetState(1463)
		p.Match(PHPParserOpenRoundBracket)
	}
	{
		p.SetState(1464)
		p.expression(0)
	}
	{
		p.SetState(1465)
		p.Match(PHPParserCloseRoundBracket)
	}
	{
		p.SetState(1466)
		p.Match(PHPParserOpenCurlyBracket)
	}
	{
		p.SetState(1467)
		p.MatchItem()
	}
	p.SetState(1472)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 165, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1468)
				p.Match(PHPParserComma)
			}
			{
				p.SetState(1469)
				p.MatchItem()
			}

		}
		p.SetState(1474)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 165, p.GetParserRuleContext())
	}
	p.SetState(1476)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == PHPParserComma {
		{
			p.SetState(1475)
			p.Match(PHPParserComma)
		}

	}
	{
		p.SetState(1478)
		p.Match(PHPParserCloseCurlyBracket)
	}

	return localctx
}

// IMatchItemContext is an interface to support dynamic dispatch.
type IMatchItemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMatchItemContext differentiates from other interfaces.
	IsMatchItemContext()
}

type MatchItemContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMatchItemContext() *MatchItemContext {
	var p = new(MatchItemContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PHPParserRULE_matchItem
	return p
}

func (*MatchItemContext) IsMatchItemContext() {}

func NewMatchItemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MatchItemContext {
	var p = new(MatchItemContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PHPParserRULE_matchItem

	return p
}

func (s *MatchItemContext) GetParser() antlr.Parser { return s.parser }

func (s *MatchItemContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *MatchItemContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *MatchItemContext) DoubleArrow() antlr.TerminalNode {
	return s.GetToken(PHPParserDoubleArrow, 0)
}

func (s *MatchItemContext) AllComma() []antlr.TerminalNode {
	return s.GetTokens(PHPParserComma)
}

func (s *MatchItemContext) Comma(i int) antlr.TerminalNode {
	return s.GetToken(PHPParserComma, i)
}

func (s *MatchItemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MatchItemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MatchItemContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PHPParserVisitor:
		return t.VisitMatchItem(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PHPParser) MatchItem() (localctx IMatchItemContext) {
	this := p
	_ = this

	localctx = NewMatchItemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 182, PHPParserRULE_matchItem)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1480)
		p.expression(0)
	}
	p.SetState(1485)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == PHPParserComma {
		{
			p.SetState(1481)
			p.Match(PHPParserComma)
		}
		{
			p.SetState(1482)
			p.expression(0)
		}

		p.SetState(1487)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1488)
		p.Match(PHPParserDoubleArrow)
	}
	{
		p.SetState(1489)
		p.expression(0)
	}

	return localctx
}

// INewExprContext is an interface to support dynamic dispatch.
type INewExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsNewExprContext differentiates from other interfaces.
	IsNewExprContext()
}

type NewExprContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNewExprContext() *NewExprContext {
	var p = new(NewExprContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PHPParserRULE_newExpr
	return p
}

func (*NewExprContext) IsNewExprContext() {}

func NewNewExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NewExprContext {
	var p = new(NewExprContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PHPParserRULE_newExpr

	return p
}

func (s *NewExprContext) GetParser() antlr.Parser { return s.parser }

func (s *NewExprContext) New() antlr.TerminalNode {
	return s.GetToken(PHPParserNew, 0)
}

func (s *NewExprContext) TypeRef() ITypeRefContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeRefContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeRefContext)
}

func (s *NewExprContext) Arguments() IArgumentsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArgumentsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArgumentsContext)
}

func (s *NewExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NewExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NewExprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PHPParserVisitor:
		return t.VisitNewExpr(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PHPParser) NewExpr() (localctx INewExprContext) {
	this := p
	_ = this

	localctx = NewNewExprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 184, PHPParserRULE_newExpr)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1491)
		p.Match(PHPParserNew)
	}
	{
		p.SetState(1492)
		p.TypeRef()
	}
	p.SetState(1494)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 168, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1493)
			p.Arguments()
		}

	}

	return localctx
}

// IAssignmentOperatorContext is an interface to support dynamic dispatch.
type IAssignmentOperatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAssignmentOperatorContext differentiates from other interfaces.
	IsAssignmentOperatorContext()
}

type AssignmentOperatorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAssignmentOperatorContext() *AssignmentOperatorContext {
	var p = new(AssignmentOperatorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PHPParserRULE_assignmentOperator
	return p
}

func (*AssignmentOperatorContext) IsAssignmentOperatorContext() {}

func NewAssignmentOperatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AssignmentOperatorContext {
	var p = new(AssignmentOperatorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PHPParserRULE_assignmentOperator

	return p
}

func (s *AssignmentOperatorContext) GetParser() antlr.Parser { return s.parser }

func (s *AssignmentOperatorContext) Eq() antlr.TerminalNode {
	return s.GetToken(PHPParserEq, 0)
}

func (s *AssignmentOperatorContext) PlusEqual() antlr.TerminalNode {
	return s.GetToken(PHPParserPlusEqual, 0)
}

func (s *AssignmentOperatorContext) MinusEqual() antlr.TerminalNode {
	return s.GetToken(PHPParserMinusEqual, 0)
}

func (s *AssignmentOperatorContext) MulEqual() antlr.TerminalNode {
	return s.GetToken(PHPParserMulEqual, 0)
}

func (s *AssignmentOperatorContext) PowEqual() antlr.TerminalNode {
	return s.GetToken(PHPParserPowEqual, 0)
}

func (s *AssignmentOperatorContext) DivEqual() antlr.TerminalNode {
	return s.GetToken(PHPParserDivEqual, 0)
}

func (s *AssignmentOperatorContext) Concaequal() antlr.TerminalNode {
	return s.GetToken(PHPParserConcaequal, 0)
}

func (s *AssignmentOperatorContext) ModEqual() antlr.TerminalNode {
	return s.GetToken(PHPParserModEqual, 0)
}

func (s *AssignmentOperatorContext) AndEqual() antlr.TerminalNode {
	return s.GetToken(PHPParserAndEqual, 0)
}

func (s *AssignmentOperatorContext) OrEqual() antlr.TerminalNode {
	return s.GetToken(PHPParserOrEqual, 0)
}

func (s *AssignmentOperatorContext) XorEqual() antlr.TerminalNode {
	return s.GetToken(PHPParserXorEqual, 0)
}

func (s *AssignmentOperatorContext) ShiftLeftEqual() antlr.TerminalNode {
	return s.GetToken(PHPParserShiftLeftEqual, 0)
}

func (s *AssignmentOperatorContext) ShiftRightEqual() antlr.TerminalNode {
	return s.GetToken(PHPParserShiftRightEqual, 0)
}

func (s *AssignmentOperatorContext) NullCoalescingEqual() antlr.TerminalNode {
	return s.GetToken(PHPParserNullCoalescingEqual, 0)
}

func (s *AssignmentOperatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AssignmentOperatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AssignmentOperatorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PHPParserVisitor:
		return t.VisitAssignmentOperator(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PHPParser) AssignmentOperator() (localctx IAssignmentOperatorContext) {
	this := p
	_ = this

	localctx = NewAssignmentOperatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 186, PHPParserRULE_assignmentOperator)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1496)
		_la = p.GetTokenStream().LA(1)

		if !((int64((_la-173)) & ^0x3f) == 0 && ((int64(1)<<(_la-173))&281474976784375) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IYieldExpressionContext is an interface to support dynamic dispatch.
type IYieldExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsYieldExpressionContext differentiates from other interfaces.
	IsYieldExpressionContext()
}

type YieldExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyYieldExpressionContext() *YieldExpressionContext {
	var p = new(YieldExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PHPParserRULE_yieldExpression
	return p
}

func (*YieldExpressionContext) IsYieldExpressionContext() {}

func NewYieldExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *YieldExpressionContext {
	var p = new(YieldExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PHPParserRULE_yieldExpression

	return p
}

func (s *YieldExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *YieldExpressionContext) Yield() antlr.TerminalNode {
	return s.GetToken(PHPParserYield, 0)
}

func (s *YieldExpressionContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *YieldExpressionContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *YieldExpressionContext) From() antlr.TerminalNode {
	return s.GetToken(PHPParserFrom, 0)
}

func (s *YieldExpressionContext) DoubleArrow() antlr.TerminalNode {
	return s.GetToken(PHPParserDoubleArrow, 0)
}

func (s *YieldExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *YieldExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *YieldExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PHPParserVisitor:
		return t.VisitYieldExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PHPParser) YieldExpression() (localctx IYieldExpressionContext) {
	this := p
	_ = this

	localctx = NewYieldExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 188, PHPParserRULE_yieldExpression)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1498)
		p.Match(PHPParserYield)
	}
	p.SetState(1506)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 170, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(1499)
			p.expression(0)
		}
		p.SetState(1502)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == PHPParserDoubleArrow {
			{
				p.SetState(1500)
				p.Match(PHPParserDoubleArrow)
			}
			{
				p.SetState(1501)
				p.expression(0)
			}

		}

	case 2:
		{
			p.SetState(1504)
			p.Match(PHPParserFrom)
		}
		{
			p.SetState(1505)
			p.expression(0)
		}

	}

	return localctx
}

// IArrayItemListContext is an interface to support dynamic dispatch.
type IArrayItemListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsArrayItemListContext differentiates from other interfaces.
	IsArrayItemListContext()
}

type ArrayItemListContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyArrayItemListContext() *ArrayItemListContext {
	var p = new(ArrayItemListContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PHPParserRULE_arrayItemList
	return p
}

func (*ArrayItemListContext) IsArrayItemListContext() {}

func NewArrayItemListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ArrayItemListContext {
	var p = new(ArrayItemListContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PHPParserRULE_arrayItemList

	return p
}

func (s *ArrayItemListContext) GetParser() antlr.Parser { return s.parser }

func (s *ArrayItemListContext) AllArrayItem() []IArrayItemContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IArrayItemContext); ok {
			len++
		}
	}

	tst := make([]IArrayItemContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IArrayItemContext); ok {
			tst[i] = t.(IArrayItemContext)
			i++
		}
	}

	return tst
}

func (s *ArrayItemListContext) ArrayItem(i int) IArrayItemContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArrayItemContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArrayItemContext)
}

func (s *ArrayItemListContext) AllComma() []antlr.TerminalNode {
	return s.GetTokens(PHPParserComma)
}

func (s *ArrayItemListContext) Comma(i int) antlr.TerminalNode {
	return s.GetToken(PHPParserComma, i)
}

func (s *ArrayItemListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArrayItemListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ArrayItemListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PHPParserVisitor:
		return t.VisitArrayItemList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PHPParser) ArrayItemList() (localctx IArrayItemListContext) {
	this := p
	_ = this

	localctx = NewArrayItemListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 190, PHPParserRULE_arrayItemList)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1508)
		p.ArrayItem()
	}
	p.SetState(1513)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 171, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1509)
				p.Match(PHPParserComma)
			}
			{
				p.SetState(1510)
				p.ArrayItem()
			}

		}
		p.SetState(1515)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 171, p.GetParserRuleContext())
	}
	p.SetState(1517)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 172, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1516)
			p.Match(PHPParserComma)
		}

	}

	return localctx
}

// IArrayItemContext is an interface to support dynamic dispatch.
type IArrayItemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsArrayItemContext differentiates from other interfaces.
	IsArrayItemContext()
}

type ArrayItemContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyArrayItemContext() *ArrayItemContext {
	var p = new(ArrayItemContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PHPParserRULE_arrayItem
	return p
}

func (*ArrayItemContext) IsArrayItemContext() {}

func NewArrayItemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ArrayItemContext {
	var p = new(ArrayItemContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PHPParserRULE_arrayItem

	return p
}

func (s *ArrayItemContext) GetParser() antlr.Parser { return s.parser }

func (s *ArrayItemContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *ArrayItemContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ArrayItemContext) DoubleArrow() antlr.TerminalNode {
	return s.GetToken(PHPParserDoubleArrow, 0)
}

func (s *ArrayItemContext) Ampersand() antlr.TerminalNode {
	return s.GetToken(PHPParserAmpersand, 0)
}

func (s *ArrayItemContext) Chain() IChainContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IChainContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IChainContext)
}

func (s *ArrayItemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArrayItemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ArrayItemContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PHPParserVisitor:
		return t.VisitArrayItem(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PHPParser) ArrayItem() (localctx IArrayItemContext) {
	this := p
	_ = this

	localctx = NewArrayItemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 192, PHPParserRULE_arrayItem)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1531)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 175, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1519)
			p.expression(0)
		}
		p.SetState(1522)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == PHPParserDoubleArrow {
			{
				p.SetState(1520)
				p.Match(PHPParserDoubleArrow)
			}
			{
				p.SetState(1521)
				p.expression(0)
			}

		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(1527)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if (int64((_la-44)) & ^0x3f) == 0 && ((int64(1)<<(_la-44))&-1) != 0 || (int64((_la-108)) & ^0x3f) == 0 && ((int64(1)<<(_la-108))&441352763482308607) != 0 || (int64((_la-194)) & ^0x3f) == 0 && ((int64(1)<<(_la-194))&4396974138177) != 0 {
			{
				p.SetState(1524)
				p.expression(0)
			}
			{
				p.SetState(1525)
				p.Match(PHPParserDoubleArrow)
			}

		}
		{
			p.SetState(1529)
			p.Match(PHPParserAmpersand)
		}
		{
			p.SetState(1530)
			p.Chain()
		}

	}

	return localctx
}

// ILambdaFunctionUseVarsContext is an interface to support dynamic dispatch.
type ILambdaFunctionUseVarsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLambdaFunctionUseVarsContext differentiates from other interfaces.
	IsLambdaFunctionUseVarsContext()
}

type LambdaFunctionUseVarsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLambdaFunctionUseVarsContext() *LambdaFunctionUseVarsContext {
	var p = new(LambdaFunctionUseVarsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PHPParserRULE_lambdaFunctionUseVars
	return p
}

func (*LambdaFunctionUseVarsContext) IsLambdaFunctionUseVarsContext() {}

func NewLambdaFunctionUseVarsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LambdaFunctionUseVarsContext {
	var p = new(LambdaFunctionUseVarsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PHPParserRULE_lambdaFunctionUseVars

	return p
}

func (s *LambdaFunctionUseVarsContext) GetParser() antlr.Parser { return s.parser }

func (s *LambdaFunctionUseVarsContext) Use() antlr.TerminalNode {
	return s.GetToken(PHPParserUse, 0)
}

func (s *LambdaFunctionUseVarsContext) OpenRoundBracket() antlr.TerminalNode {
	return s.GetToken(PHPParserOpenRoundBracket, 0)
}

func (s *LambdaFunctionUseVarsContext) AllLambdaFunctionUseVar() []ILambdaFunctionUseVarContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ILambdaFunctionUseVarContext); ok {
			len++
		}
	}

	tst := make([]ILambdaFunctionUseVarContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ILambdaFunctionUseVarContext); ok {
			tst[i] = t.(ILambdaFunctionUseVarContext)
			i++
		}
	}

	return tst
}

func (s *LambdaFunctionUseVarsContext) LambdaFunctionUseVar(i int) ILambdaFunctionUseVarContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILambdaFunctionUseVarContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILambdaFunctionUseVarContext)
}

func (s *LambdaFunctionUseVarsContext) CloseRoundBracket() antlr.TerminalNode {
	return s.GetToken(PHPParserCloseRoundBracket, 0)
}

func (s *LambdaFunctionUseVarsContext) AllComma() []antlr.TerminalNode {
	return s.GetTokens(PHPParserComma)
}

func (s *LambdaFunctionUseVarsContext) Comma(i int) antlr.TerminalNode {
	return s.GetToken(PHPParserComma, i)
}

func (s *LambdaFunctionUseVarsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LambdaFunctionUseVarsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LambdaFunctionUseVarsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PHPParserVisitor:
		return t.VisitLambdaFunctionUseVars(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PHPParser) LambdaFunctionUseVars() (localctx ILambdaFunctionUseVarsContext) {
	this := p
	_ = this

	localctx = NewLambdaFunctionUseVarsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 194, PHPParserRULE_lambdaFunctionUseVars)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1533)
		p.Match(PHPParserUse)
	}
	{
		p.SetState(1534)
		p.Match(PHPParserOpenRoundBracket)
	}
	{
		p.SetState(1535)
		p.LambdaFunctionUseVar()
	}
	p.SetState(1540)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == PHPParserComma {
		{
			p.SetState(1536)
			p.Match(PHPParserComma)
		}
		{
			p.SetState(1537)
			p.LambdaFunctionUseVar()
		}

		p.SetState(1542)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1543)
		p.Match(PHPParserCloseRoundBracket)
	}

	return localctx
}

// ILambdaFunctionUseVarContext is an interface to support dynamic dispatch.
type ILambdaFunctionUseVarContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLambdaFunctionUseVarContext differentiates from other interfaces.
	IsLambdaFunctionUseVarContext()
}

type LambdaFunctionUseVarContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLambdaFunctionUseVarContext() *LambdaFunctionUseVarContext {
	var p = new(LambdaFunctionUseVarContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PHPParserRULE_lambdaFunctionUseVar
	return p
}

func (*LambdaFunctionUseVarContext) IsLambdaFunctionUseVarContext() {}

func NewLambdaFunctionUseVarContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LambdaFunctionUseVarContext {
	var p = new(LambdaFunctionUseVarContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PHPParserRULE_lambdaFunctionUseVar

	return p
}

func (s *LambdaFunctionUseVarContext) GetParser() antlr.Parser { return s.parser }

func (s *LambdaFunctionUseVarContext) VarName() antlr.TerminalNode {
	return s.GetToken(PHPParserVarName, 0)
}

func (s *LambdaFunctionUseVarContext) Ampersand() antlr.TerminalNode {
	return s.GetToken(PHPParserAmpersand, 0)
}

func (s *LambdaFunctionUseVarContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LambdaFunctionUseVarContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LambdaFunctionUseVarContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PHPParserVisitor:
		return t.VisitLambdaFunctionUseVar(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PHPParser) LambdaFunctionUseVar() (localctx ILambdaFunctionUseVarContext) {
	this := p
	_ = this

	localctx = NewLambdaFunctionUseVarContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 196, PHPParserRULE_lambdaFunctionUseVar)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1546)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == PHPParserAmpersand {
		{
			p.SetState(1545)
			p.Match(PHPParserAmpersand)
		}

	}
	{
		p.SetState(1548)
		p.Match(PHPParserVarName)
	}

	return localctx
}

// IQualifiedStaticTypeRefContext is an interface to support dynamic dispatch.
type IQualifiedStaticTypeRefContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsQualifiedStaticTypeRefContext differentiates from other interfaces.
	IsQualifiedStaticTypeRefContext()
}

type QualifiedStaticTypeRefContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyQualifiedStaticTypeRefContext() *QualifiedStaticTypeRefContext {
	var p = new(QualifiedStaticTypeRefContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PHPParserRULE_qualifiedStaticTypeRef
	return p
}

func (*QualifiedStaticTypeRefContext) IsQualifiedStaticTypeRefContext() {}

func NewQualifiedStaticTypeRefContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *QualifiedStaticTypeRefContext {
	var p = new(QualifiedStaticTypeRefContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PHPParserRULE_qualifiedStaticTypeRef

	return p
}

func (s *QualifiedStaticTypeRefContext) GetParser() antlr.Parser { return s.parser }

func (s *QualifiedStaticTypeRefContext) QualifiedNamespaceName() IQualifiedNamespaceNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNamespaceNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNamespaceNameContext)
}

func (s *QualifiedStaticTypeRefContext) GenericDynamicArgs() IGenericDynamicArgsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGenericDynamicArgsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGenericDynamicArgsContext)
}

func (s *QualifiedStaticTypeRefContext) Static() antlr.TerminalNode {
	return s.GetToken(PHPParserStatic, 0)
}

func (s *QualifiedStaticTypeRefContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QualifiedStaticTypeRefContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *QualifiedStaticTypeRefContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PHPParserVisitor:
		return t.VisitQualifiedStaticTypeRef(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PHPParser) QualifiedStaticTypeRef() (localctx IQualifiedStaticTypeRefContext) {
	this := p
	_ = this

	localctx = NewQualifiedStaticTypeRefContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 198, PHPParserRULE_qualifiedStaticTypeRef)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1555)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 179, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1550)
			p.QualifiedNamespaceName()
		}
		p.SetState(1552)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 178, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1551)
				p.GenericDynamicArgs()
			}

		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1554)
			p.Match(PHPParserStatic)
		}

	}

	return localctx
}

// ITypeRefContext is an interface to support dynamic dispatch.
type ITypeRefContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTypeRefContext differentiates from other interfaces.
	IsTypeRefContext()
}

type TypeRefContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeRefContext() *TypeRefContext {
	var p = new(TypeRefContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PHPParserRULE_typeRef
	return p
}

func (*TypeRefContext) IsTypeRefContext() {}

func NewTypeRefContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeRefContext {
	var p = new(TypeRefContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PHPParserRULE_typeRef

	return p
}

func (s *TypeRefContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeRefContext) QualifiedNamespaceName() IQualifiedNamespaceNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNamespaceNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNamespaceNameContext)
}

func (s *TypeRefContext) IndirectTypeRef() IIndirectTypeRefContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIndirectTypeRefContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIndirectTypeRefContext)
}

func (s *TypeRefContext) GenericDynamicArgs() IGenericDynamicArgsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGenericDynamicArgsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGenericDynamicArgsContext)
}

func (s *TypeRefContext) PrimitiveType() IPrimitiveTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrimitiveTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrimitiveTypeContext)
}

func (s *TypeRefContext) Static() antlr.TerminalNode {
	return s.GetToken(PHPParserStatic, 0)
}

func (s *TypeRefContext) AnonymousClass() IAnonymousClassContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAnonymousClassContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAnonymousClassContext)
}

func (s *TypeRefContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeRefContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeRefContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PHPParserVisitor:
		return t.VisitTypeRef(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PHPParser) TypeRef() (localctx ITypeRefContext) {
	this := p
	_ = this

	localctx = NewTypeRefContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 200, PHPParserRULE_typeRef)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1567)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 182, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(1559)
		p.GetErrorHandler().Sync(p)
		switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 180, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(1557)
				p.QualifiedNamespaceName()
			}

		case 2:
			{
				p.SetState(1558)
				p.IndirectTypeRef()
			}

		}
		p.SetState(1562)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 181, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1561)
				p.GenericDynamicArgs()
			}

		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1564)
			p.PrimitiveType()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1565)
			p.Match(PHPParserStatic)
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1566)
			p.AnonymousClass()
		}

	}

	return localctx
}

// IAnonymousClassContext is an interface to support dynamic dispatch.
type IAnonymousClassContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAnonymousClassContext differentiates from other interfaces.
	IsAnonymousClassContext()
}

type AnonymousClassContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAnonymousClassContext() *AnonymousClassContext {
	var p = new(AnonymousClassContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PHPParserRULE_anonymousClass
	return p
}

func (*AnonymousClassContext) IsAnonymousClassContext() {}

func NewAnonymousClassContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AnonymousClassContext {
	var p = new(AnonymousClassContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PHPParserRULE_anonymousClass

	return p
}

func (s *AnonymousClassContext) GetParser() antlr.Parser { return s.parser }

func (s *AnonymousClassContext) OpenCurlyBracket() antlr.TerminalNode {
	return s.GetToken(PHPParserOpenCurlyBracket, 0)
}

func (s *AnonymousClassContext) CloseCurlyBracket() antlr.TerminalNode {
	return s.GetToken(PHPParserCloseCurlyBracket, 0)
}

func (s *AnonymousClassContext) ClassEntryType() IClassEntryTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClassEntryTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClassEntryTypeContext)
}

func (s *AnonymousClassContext) Interface() antlr.TerminalNode {
	return s.GetToken(PHPParserInterface, 0)
}

func (s *AnonymousClassContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *AnonymousClassContext) Attributes() IAttributesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAttributesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAttributesContext)
}

func (s *AnonymousClassContext) Private() antlr.TerminalNode {
	return s.GetToken(PHPParserPrivate, 0)
}

func (s *AnonymousClassContext) Modifier() IModifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IModifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IModifierContext)
}

func (s *AnonymousClassContext) Partial() antlr.TerminalNode {
	return s.GetToken(PHPParserPartial, 0)
}

func (s *AnonymousClassContext) AllClassStatement() []IClassStatementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IClassStatementContext); ok {
			len++
		}
	}

	tst := make([]IClassStatementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IClassStatementContext); ok {
			tst[i] = t.(IClassStatementContext)
			i++
		}
	}

	return tst
}

func (s *AnonymousClassContext) ClassStatement(i int) IClassStatementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClassStatementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClassStatementContext)
}

func (s *AnonymousClassContext) TypeParameterListInBrackets() ITypeParameterListInBracketsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeParameterListInBracketsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeParameterListInBracketsContext)
}

func (s *AnonymousClassContext) Extends() antlr.TerminalNode {
	return s.GetToken(PHPParserExtends, 0)
}

func (s *AnonymousClassContext) QualifiedStaticTypeRef() IQualifiedStaticTypeRefContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedStaticTypeRefContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedStaticTypeRefContext)
}

func (s *AnonymousClassContext) Implements() antlr.TerminalNode {
	return s.GetToken(PHPParserImplements, 0)
}

func (s *AnonymousClassContext) InterfaceList() IInterfaceListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInterfaceListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInterfaceListContext)
}

func (s *AnonymousClassContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AnonymousClassContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AnonymousClassContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PHPParserVisitor:
		return t.VisitAnonymousClass(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PHPParser) AnonymousClass() (localctx IAnonymousClassContext) {
	this := p
	_ = this

	localctx = NewAnonymousClassContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 202, PHPParserRULE_anonymousClass)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1570)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == PHPParserAttributeStart {
		{
			p.SetState(1569)
			p.Attributes()
		}

	}
	p.SetState(1573)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == PHPParserPrivate {
		{
			p.SetState(1572)
			p.Match(PHPParserPrivate)
		}

	}
	p.SetState(1576)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == PHPParserAbstract || _la == PHPParserFinal {
		{
			p.SetState(1575)
			p.Modifier()
		}

	}
	p.SetState(1579)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == PHPParserPartial {
		{
			p.SetState(1578)
			p.Match(PHPParserPartial)
		}

	}
	p.SetState(1602)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case PHPParserClass, PHPParserTrait:
		{
			p.SetState(1581)
			p.ClassEntryType()
		}
		p.SetState(1583)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == PHPParserLgeneric {
			{
				p.SetState(1582)
				p.TypeParameterListInBrackets()
			}

		}
		p.SetState(1587)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == PHPParserExtends {
			{
				p.SetState(1585)
				p.Match(PHPParserExtends)
			}
			{
				p.SetState(1586)
				p.QualifiedStaticTypeRef()
			}

		}
		p.SetState(1591)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == PHPParserImplements {
			{
				p.SetState(1589)
				p.Match(PHPParserImplements)
			}
			{
				p.SetState(1590)
				p.InterfaceList()
			}

		}

	case PHPParserInterface:
		{
			p.SetState(1593)
			p.Match(PHPParserInterface)
		}
		{
			p.SetState(1594)
			p.Identifier()
		}
		p.SetState(1596)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == PHPParserLgeneric {
			{
				p.SetState(1595)
				p.TypeParameterListInBrackets()
			}

		}
		p.SetState(1600)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == PHPParserExtends {
			{
				p.SetState(1598)
				p.Match(PHPParserExtends)
			}
			{
				p.SetState(1599)
				p.InterfaceList()
			}

		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}
	{
		p.SetState(1604)
		p.Match(PHPParserOpenCurlyBracket)
	}
	p.SetState(1608)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for (int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&72083982316994560) != 0 || (int64((_la-77)) & ^0x3f) == 0 && ((int64(1)<<(_la-77))&6757727313330209) != 0 {
		{
			p.SetState(1605)
			p.ClassStatement()
		}

		p.SetState(1610)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1611)
		p.Match(PHPParserCloseCurlyBracket)
	}

	return localctx
}

// IIndirectTypeRefContext is an interface to support dynamic dispatch.
type IIndirectTypeRefContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsIndirectTypeRefContext differentiates from other interfaces.
	IsIndirectTypeRefContext()
}

type IndirectTypeRefContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIndirectTypeRefContext() *IndirectTypeRefContext {
	var p = new(IndirectTypeRefContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PHPParserRULE_indirectTypeRef
	return p
}

func (*IndirectTypeRefContext) IsIndirectTypeRefContext() {}

func NewIndirectTypeRefContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IndirectTypeRefContext {
	var p = new(IndirectTypeRefContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PHPParserRULE_indirectTypeRef

	return p
}

func (s *IndirectTypeRefContext) GetParser() antlr.Parser { return s.parser }

func (s *IndirectTypeRefContext) ChainBase() IChainBaseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IChainBaseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IChainBaseContext)
}

func (s *IndirectTypeRefContext) AllObjectOperator() []antlr.TerminalNode {
	return s.GetTokens(PHPParserObjectOperator)
}

func (s *IndirectTypeRefContext) ObjectOperator(i int) antlr.TerminalNode {
	return s.GetToken(PHPParserObjectOperator, i)
}

func (s *IndirectTypeRefContext) AllKeyedFieldName() []IKeyedFieldNameContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IKeyedFieldNameContext); ok {
			len++
		}
	}

	tst := make([]IKeyedFieldNameContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IKeyedFieldNameContext); ok {
			tst[i] = t.(IKeyedFieldNameContext)
			i++
		}
	}

	return tst
}

func (s *IndirectTypeRefContext) KeyedFieldName(i int) IKeyedFieldNameContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKeyedFieldNameContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKeyedFieldNameContext)
}

func (s *IndirectTypeRefContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IndirectTypeRefContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IndirectTypeRefContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PHPParserVisitor:
		return t.VisitIndirectTypeRef(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PHPParser) IndirectTypeRef() (localctx IIndirectTypeRefContext) {
	this := p
	_ = this

	localctx = NewIndirectTypeRefContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 204, PHPParserRULE_indirectTypeRef)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1613)
		p.ChainBase()
	}
	p.SetState(1618)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 194, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1614)
				p.Match(PHPParserObjectOperator)
			}
			{
				p.SetState(1615)
				p.KeyedFieldName()
			}

		}
		p.SetState(1620)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 194, p.GetParserRuleContext())
	}

	return localctx
}

// IQualifiedNamespaceNameContext is an interface to support dynamic dispatch.
type IQualifiedNamespaceNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsQualifiedNamespaceNameContext differentiates from other interfaces.
	IsQualifiedNamespaceNameContext()
}

type QualifiedNamespaceNameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyQualifiedNamespaceNameContext() *QualifiedNamespaceNameContext {
	var p = new(QualifiedNamespaceNameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PHPParserRULE_qualifiedNamespaceName
	return p
}

func (*QualifiedNamespaceNameContext) IsQualifiedNamespaceNameContext() {}

func NewQualifiedNamespaceNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *QualifiedNamespaceNameContext {
	var p = new(QualifiedNamespaceNameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PHPParserRULE_qualifiedNamespaceName

	return p
}

func (s *QualifiedNamespaceNameContext) GetParser() antlr.Parser { return s.parser }

func (s *QualifiedNamespaceNameContext) NamespaceNameList() INamespaceNameListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INamespaceNameListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INamespaceNameListContext)
}

func (s *QualifiedNamespaceNameContext) Namespace() antlr.TerminalNode {
	return s.GetToken(PHPParserNamespace, 0)
}

func (s *QualifiedNamespaceNameContext) NamespaceSeparator() antlr.TerminalNode {
	return s.GetToken(PHPParserNamespaceSeparator, 0)
}

func (s *QualifiedNamespaceNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QualifiedNamespaceNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *QualifiedNamespaceNameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PHPParserVisitor:
		return t.VisitQualifiedNamespaceName(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PHPParser) QualifiedNamespaceName() (localctx IQualifiedNamespaceNameContext) {
	this := p
	_ = this

	localctx = NewQualifiedNamespaceNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 206, PHPParserRULE_qualifiedNamespaceName)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1622)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 195, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1621)
			p.Match(PHPParserNamespace)
		}

	}
	p.SetState(1625)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == PHPParserNamespaceSeparator {
		{
			p.SetState(1624)
			p.Match(PHPParserNamespaceSeparator)
		}

	}
	{
		p.SetState(1627)
		p.NamespaceNameList()
	}

	return localctx
}

// INamespaceNameListContext is an interface to support dynamic dispatch.
type INamespaceNameListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsNamespaceNameListContext differentiates from other interfaces.
	IsNamespaceNameListContext()
}

type NamespaceNameListContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNamespaceNameListContext() *NamespaceNameListContext {
	var p = new(NamespaceNameListContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PHPParserRULE_namespaceNameList
	return p
}

func (*NamespaceNameListContext) IsNamespaceNameListContext() {}

func NewNamespaceNameListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NamespaceNameListContext {
	var p = new(NamespaceNameListContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PHPParserRULE_namespaceNameList

	return p
}

func (s *NamespaceNameListContext) GetParser() antlr.Parser { return s.parser }

func (s *NamespaceNameListContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *NamespaceNameListContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *NamespaceNameListContext) AllNamespaceSeparator() []antlr.TerminalNode {
	return s.GetTokens(PHPParserNamespaceSeparator)
}

func (s *NamespaceNameListContext) NamespaceSeparator(i int) antlr.TerminalNode {
	return s.GetToken(PHPParserNamespaceSeparator, i)
}

func (s *NamespaceNameListContext) NamespaceNameTail() INamespaceNameTailContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INamespaceNameTailContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INamespaceNameTailContext)
}

func (s *NamespaceNameListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NamespaceNameListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NamespaceNameListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PHPParserVisitor:
		return t.VisitNamespaceNameList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PHPParser) NamespaceNameList() (localctx INamespaceNameListContext) {
	this := p
	_ = this

	localctx = NewNamespaceNameListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 208, PHPParserRULE_namespaceNameList)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.SetState(1642)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 199, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1629)
			p.Identifier()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1630)
			p.Identifier()
		}
		p.SetState(1635)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 197, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(1631)
					p.Match(PHPParserNamespaceSeparator)
				}
				{
					p.SetState(1632)
					p.Identifier()
				}

			}
			p.SetState(1637)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 197, p.GetParserRuleContext())
		}
		p.SetState(1640)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 198, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1638)
				p.Match(PHPParserNamespaceSeparator)
			}
			{
				p.SetState(1639)
				p.NamespaceNameTail()
			}

		}

	}

	return localctx
}

// INamespaceNameTailContext is an interface to support dynamic dispatch.
type INamespaceNameTailContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsNamespaceNameTailContext differentiates from other interfaces.
	IsNamespaceNameTailContext()
}

type NamespaceNameTailContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNamespaceNameTailContext() *NamespaceNameTailContext {
	var p = new(NamespaceNameTailContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PHPParserRULE_namespaceNameTail
	return p
}

func (*NamespaceNameTailContext) IsNamespaceNameTailContext() {}

func NewNamespaceNameTailContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NamespaceNameTailContext {
	var p = new(NamespaceNameTailContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PHPParserRULE_namespaceNameTail

	return p
}

func (s *NamespaceNameTailContext) GetParser() antlr.Parser { return s.parser }

func (s *NamespaceNameTailContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *NamespaceNameTailContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *NamespaceNameTailContext) As() antlr.TerminalNode {
	return s.GetToken(PHPParserAs, 0)
}

func (s *NamespaceNameTailContext) OpenCurlyBracket() antlr.TerminalNode {
	return s.GetToken(PHPParserOpenCurlyBracket, 0)
}

func (s *NamespaceNameTailContext) AllNamespaceNameTail() []INamespaceNameTailContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(INamespaceNameTailContext); ok {
			len++
		}
	}

	tst := make([]INamespaceNameTailContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(INamespaceNameTailContext); ok {
			tst[i] = t.(INamespaceNameTailContext)
			i++
		}
	}

	return tst
}

func (s *NamespaceNameTailContext) NamespaceNameTail(i int) INamespaceNameTailContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INamespaceNameTailContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(INamespaceNameTailContext)
}

func (s *NamespaceNameTailContext) CloseCurlyBracket() antlr.TerminalNode {
	return s.GetToken(PHPParserCloseCurlyBracket, 0)
}

func (s *NamespaceNameTailContext) AllComma() []antlr.TerminalNode {
	return s.GetTokens(PHPParserComma)
}

func (s *NamespaceNameTailContext) Comma(i int) antlr.TerminalNode {
	return s.GetToken(PHPParserComma, i)
}

func (s *NamespaceNameTailContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NamespaceNameTailContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NamespaceNameTailContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PHPParserVisitor:
		return t.VisitNamespaceNameTail(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PHPParser) NamespaceNameTail() (localctx INamespaceNameTailContext) {
	this := p
	_ = this

	localctx = NewNamespaceNameTailContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 210, PHPParserRULE_namespaceNameTail)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.SetState(1663)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case PHPParserAbstract, PHPParserArray, PHPParserAs, PHPParserBinaryCast, PHPParserBoolType, PHPParserBooleanConstant, PHPParserBreak, PHPParserCallable, PHPParserCase, PHPParserCatch, PHPParserClass, PHPParserClone, PHPParserConst, PHPParserContinue, PHPParserDeclare, PHPParserDefault, PHPParserDo, PHPParserDoubleCast, PHPParserDoubleType, PHPParserEcho, PHPParserElse, PHPParserElseIf, PHPParserEmpty, PHPParserEnum_, PHPParserEndDeclare, PHPParserEndFor, PHPParserEndForeach, PHPParserEndIf, PHPParserEndSwitch, PHPParserEndWhile, PHPParserEval, PHPParserExit, PHPParserExtends, PHPParserFinal, PHPParserFinally, PHPParserFloatCast, PHPParserFor, PHPParserForeach, PHPParserFunction_, PHPParserGlobal, PHPParserGoto, PHPParserIf, PHPParserImplements, PHPParserImport, PHPParserInclude, PHPParserIncludeOnce, PHPParserInstanceOf, PHPParserInsteadOf, PHPParserInt8Cast, PHPParserInt16Cast, PHPParserInt64Type, PHPParserIntType, PHPParserInterface, PHPParserIsSet, PHPParserList, PHPParserLogicalAnd, PHPParserLogicalOr, PHPParserLogicalXor, PHPParserMatch_, PHPParserNamespace, PHPParserNew, PHPParserNull, PHPParserObjectType, PHPParserParent_, PHPParserPartial, PHPParserPrint, PHPParserPrivate, PHPParserProtected, PHPParserPublic, PHPParserReadonly, PHPParserRequire, PHPParserRequireOnce, PHPParserResource, PHPParserReturn, PHPParserStatic, PHPParserStringType, PHPParserSwitch, PHPParserThrow, PHPParserTrait, PHPParserTry, PHPParserTypeof, PHPParserUintCast, PHPParserUnicodeCast, PHPParserUnset, PHPParserUse, PHPParserVar, PHPParserWhile, PHPParserYield, PHPParserFrom, PHPParserLambdaFn, PHPParserTicks, PHPParserEncoding, PHPParserStrictTypes, PHPParserGet, PHPParserSet, PHPParserCall, PHPParserCallStatic, PHPParserConstructor, PHPParserDestruct, PHPParserWakeup, PHPParserSleep, PHPParserAutoload, PHPParserIsSet__, PHPParserUnset__, PHPParserToString__, PHPParserInvoke, PHPParserSetState, PHPParserClone__, PHPParserDebugInfo, PHPParserNamespace__, PHPParserClass__, PHPParserTraic__, PHPParserFunction__, PHPParserMethod__, PHPParserLine__, PHPParserFile__, PHPParserDir__, PHPParserLabel:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1644)
			p.Identifier()
		}
		p.SetState(1647)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 200, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1645)
				p.Match(PHPParserAs)
			}
			{
				p.SetState(1646)
				p.Identifier()
			}

		}

	case PHPParserOpenCurlyBracket:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1649)
			p.Match(PHPParserOpenCurlyBracket)
		}
		{
			p.SetState(1650)
			p.NamespaceNameTail()
		}
		p.SetState(1655)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 201, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(1651)
					p.Match(PHPParserComma)
				}
				{
					p.SetState(1652)
					p.NamespaceNameTail()
				}

			}
			p.SetState(1657)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 201, p.GetParserRuleContext())
		}
		p.SetState(1659)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == PHPParserComma {
			{
				p.SetState(1658)
				p.Match(PHPParserComma)
			}

		}
		{
			p.SetState(1661)
			p.Match(PHPParserCloseCurlyBracket)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IQualifiedNamespaceNameListContext is an interface to support dynamic dispatch.
type IQualifiedNamespaceNameListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsQualifiedNamespaceNameListContext differentiates from other interfaces.
	IsQualifiedNamespaceNameListContext()
}

type QualifiedNamespaceNameListContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyQualifiedNamespaceNameListContext() *QualifiedNamespaceNameListContext {
	var p = new(QualifiedNamespaceNameListContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PHPParserRULE_qualifiedNamespaceNameList
	return p
}

func (*QualifiedNamespaceNameListContext) IsQualifiedNamespaceNameListContext() {}

func NewQualifiedNamespaceNameListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *QualifiedNamespaceNameListContext {
	var p = new(QualifiedNamespaceNameListContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PHPParserRULE_qualifiedNamespaceNameList

	return p
}

func (s *QualifiedNamespaceNameListContext) GetParser() antlr.Parser { return s.parser }

func (s *QualifiedNamespaceNameListContext) AllQualifiedNamespaceName() []IQualifiedNamespaceNameContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IQualifiedNamespaceNameContext); ok {
			len++
		}
	}

	tst := make([]IQualifiedNamespaceNameContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IQualifiedNamespaceNameContext); ok {
			tst[i] = t.(IQualifiedNamespaceNameContext)
			i++
		}
	}

	return tst
}

func (s *QualifiedNamespaceNameListContext) QualifiedNamespaceName(i int) IQualifiedNamespaceNameContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNamespaceNameContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNamespaceNameContext)
}

func (s *QualifiedNamespaceNameListContext) AllComma() []antlr.TerminalNode {
	return s.GetTokens(PHPParserComma)
}

func (s *QualifiedNamespaceNameListContext) Comma(i int) antlr.TerminalNode {
	return s.GetToken(PHPParserComma, i)
}

func (s *QualifiedNamespaceNameListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QualifiedNamespaceNameListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *QualifiedNamespaceNameListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PHPParserVisitor:
		return t.VisitQualifiedNamespaceNameList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PHPParser) QualifiedNamespaceNameList() (localctx IQualifiedNamespaceNameListContext) {
	this := p
	_ = this

	localctx = NewQualifiedNamespaceNameListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 212, PHPParserRULE_qualifiedNamespaceNameList)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1665)
		p.QualifiedNamespaceName()
	}
	p.SetState(1670)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == PHPParserComma {
		{
			p.SetState(1666)
			p.Match(PHPParserComma)
		}
		{
			p.SetState(1667)
			p.QualifiedNamespaceName()
		}

		p.SetState(1672)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IArgumentsContext is an interface to support dynamic dispatch.
type IArgumentsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsArgumentsContext differentiates from other interfaces.
	IsArgumentsContext()
}

type ArgumentsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyArgumentsContext() *ArgumentsContext {
	var p = new(ArgumentsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PHPParserRULE_arguments
	return p
}

func (*ArgumentsContext) IsArgumentsContext() {}

func NewArgumentsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ArgumentsContext {
	var p = new(ArgumentsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PHPParserRULE_arguments

	return p
}

func (s *ArgumentsContext) GetParser() antlr.Parser { return s.parser }

func (s *ArgumentsContext) OpenRoundBracket() antlr.TerminalNode {
	return s.GetToken(PHPParserOpenRoundBracket, 0)
}

func (s *ArgumentsContext) CloseRoundBracket() antlr.TerminalNode {
	return s.GetToken(PHPParserCloseRoundBracket, 0)
}

func (s *ArgumentsContext) AllActualArgument() []IActualArgumentContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IActualArgumentContext); ok {
			len++
		}
	}

	tst := make([]IActualArgumentContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IActualArgumentContext); ok {
			tst[i] = t.(IActualArgumentContext)
			i++
		}
	}

	return tst
}

func (s *ArgumentsContext) ActualArgument(i int) IActualArgumentContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IActualArgumentContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IActualArgumentContext)
}

func (s *ArgumentsContext) YieldExpression() IYieldExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IYieldExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IYieldExpressionContext)
}

func (s *ArgumentsContext) AllComma() []antlr.TerminalNode {
	return s.GetTokens(PHPParserComma)
}

func (s *ArgumentsContext) Comma(i int) antlr.TerminalNode {
	return s.GetToken(PHPParserComma, i)
}

func (s *ArgumentsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArgumentsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ArgumentsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PHPParserVisitor:
		return t.VisitArguments(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PHPParser) Arguments() (localctx IArgumentsContext) {
	this := p
	_ = this

	localctx = NewArgumentsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 214, PHPParserRULE_arguments)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1673)
		p.Match(PHPParserOpenRoundBracket)
	}
	p.SetState(1683)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 206, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1674)
			p.ActualArgument()
		}
		p.SetState(1679)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 205, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(1675)
					p.Match(PHPParserComma)
				}
				{
					p.SetState(1676)
					p.ActualArgument()
				}

			}
			p.SetState(1681)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 205, p.GetParserRuleContext())
		}

	} else if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 206, p.GetParserRuleContext()) == 2 {
		{
			p.SetState(1682)
			p.YieldExpression()
		}

	}
	p.SetState(1686)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == PHPParserComma {
		{
			p.SetState(1685)
			p.Match(PHPParserComma)
		}

	}
	{
		p.SetState(1688)
		p.Match(PHPParserCloseRoundBracket)
	}

	return localctx
}

// IActualArgumentContext is an interface to support dynamic dispatch.
type IActualArgumentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsActualArgumentContext differentiates from other interfaces.
	IsActualArgumentContext()
}

type ActualArgumentContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyActualArgumentContext() *ActualArgumentContext {
	var p = new(ActualArgumentContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PHPParserRULE_actualArgument
	return p
}

func (*ActualArgumentContext) IsActualArgumentContext() {}

func NewActualArgumentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ActualArgumentContext {
	var p = new(ActualArgumentContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PHPParserRULE_actualArgument

	return p
}

func (s *ActualArgumentContext) GetParser() antlr.Parser { return s.parser }

func (s *ActualArgumentContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ActualArgumentContext) ArgumentName() IArgumentNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArgumentNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArgumentNameContext)
}

func (s *ActualArgumentContext) Ellipsis() antlr.TerminalNode {
	return s.GetToken(PHPParserEllipsis, 0)
}

func (s *ActualArgumentContext) Ampersand() antlr.TerminalNode {
	return s.GetToken(PHPParserAmpersand, 0)
}

func (s *ActualArgumentContext) Chain() IChainContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IChainContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IChainContext)
}

func (s *ActualArgumentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ActualArgumentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ActualArgumentContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PHPParserVisitor:
		return t.VisitActualArgument(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PHPParser) ActualArgument() (localctx IActualArgumentContext) {
	this := p
	_ = this

	localctx = NewActualArgumentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 216, PHPParserRULE_actualArgument)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1699)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case PHPParserAbstract, PHPParserArray, PHPParserAs, PHPParserBinaryCast, PHPParserBoolType, PHPParserBooleanConstant, PHPParserBreak, PHPParserCallable, PHPParserCase, PHPParserCatch, PHPParserClass, PHPParserClone, PHPParserConst, PHPParserContinue, PHPParserDeclare, PHPParserDefault, PHPParserDo, PHPParserDoubleCast, PHPParserDoubleType, PHPParserEcho, PHPParserElse, PHPParserElseIf, PHPParserEmpty, PHPParserEnum_, PHPParserEndDeclare, PHPParserEndFor, PHPParserEndForeach, PHPParserEndIf, PHPParserEndSwitch, PHPParserEndWhile, PHPParserEval, PHPParserExit, PHPParserExtends, PHPParserFinal, PHPParserFinally, PHPParserFloatCast, PHPParserFor, PHPParserForeach, PHPParserFunction_, PHPParserGlobal, PHPParserGoto, PHPParserIf, PHPParserImplements, PHPParserImport, PHPParserInclude, PHPParserIncludeOnce, PHPParserInstanceOf, PHPParserInsteadOf, PHPParserInt8Cast, PHPParserInt16Cast, PHPParserInt64Type, PHPParserIntType, PHPParserInterface, PHPParserIsSet, PHPParserList, PHPParserLogicalAnd, PHPParserLogicalOr, PHPParserLogicalXor, PHPParserMatch_, PHPParserNamespace, PHPParserNew, PHPParserNull, PHPParserObjectType, PHPParserParent_, PHPParserPartial, PHPParserPrint, PHPParserPrivate, PHPParserProtected, PHPParserPublic, PHPParserReadonly, PHPParserRequire, PHPParserRequireOnce, PHPParserResource, PHPParserReturn, PHPParserStatic, PHPParserStringType, PHPParserSwitch, PHPParserThrow, PHPParserTrait, PHPParserTry, PHPParserTypeof, PHPParserUintCast, PHPParserUnicodeCast, PHPParserUnset, PHPParserUse, PHPParserVar, PHPParserWhile, PHPParserYield, PHPParserFrom, PHPParserLambdaFn, PHPParserTicks, PHPParserEncoding, PHPParserStrictTypes, PHPParserGet, PHPParserSet, PHPParserCall, PHPParserCallStatic, PHPParserConstructor, PHPParserDestruct, PHPParserWakeup, PHPParserSleep, PHPParserAutoload, PHPParserIsSet__, PHPParserUnset__, PHPParserToString__, PHPParserInvoke, PHPParserSetState, PHPParserClone__, PHPParserDebugInfo, PHPParserNamespace__, PHPParserClass__, PHPParserTraic__, PHPParserFunction__, PHPParserMethod__, PHPParserLine__, PHPParserFile__, PHPParserDir__, PHPParserInc, PHPParserDec, PHPParserNamespaceSeparator, PHPParserEllipsis, PHPParserBang, PHPParserPlus, PHPParserMinus, PHPParserTilde, PHPParserSuppressWarnings, PHPParserDollar, PHPParserOpenRoundBracket, PHPParserOpenSquareBracket, PHPParserVarName, PHPParserLabel, PHPParserOctal, PHPParserDecimal, PHPParserReal, PHPParserHex, PHPParserBinary, PHPParserBackQuoteString, PHPParserSingleQuoteString, PHPParserDoubleQuote, PHPParserStartNowDoc, PHPParserStartHereDoc:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(1691)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 208, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1690)
				p.ArgumentName()
			}

		}
		p.SetState(1694)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == PHPParserEllipsis {
			{
				p.SetState(1693)
				p.Match(PHPParserEllipsis)
			}

		}
		{
			p.SetState(1696)
			p.expression(0)
		}

	case PHPParserAmpersand:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1697)
			p.Match(PHPParserAmpersand)
		}
		{
			p.SetState(1698)
			p.Chain()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IArgumentNameContext is an interface to support dynamic dispatch.
type IArgumentNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsArgumentNameContext differentiates from other interfaces.
	IsArgumentNameContext()
}

type ArgumentNameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyArgumentNameContext() *ArgumentNameContext {
	var p = new(ArgumentNameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PHPParserRULE_argumentName
	return p
}

func (*ArgumentNameContext) IsArgumentNameContext() {}

func NewArgumentNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ArgumentNameContext {
	var p = new(ArgumentNameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PHPParserRULE_argumentName

	return p
}

func (s *ArgumentNameContext) GetParser() antlr.Parser { return s.parser }

func (s *ArgumentNameContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ArgumentNameContext) Colon() antlr.TerminalNode {
	return s.GetToken(PHPParserColon, 0)
}

func (s *ArgumentNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArgumentNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ArgumentNameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PHPParserVisitor:
		return t.VisitArgumentName(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PHPParser) ArgumentName() (localctx IArgumentNameContext) {
	this := p
	_ = this

	localctx = NewArgumentNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 218, PHPParserRULE_argumentName)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1701)
		p.Identifier()
	}
	{
		p.SetState(1702)
		p.Match(PHPParserColon)
	}

	return localctx
}

// IConstantInitializerContext is an interface to support dynamic dispatch.
type IConstantInitializerContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsConstantInitializerContext differentiates from other interfaces.
	IsConstantInitializerContext()
}

type ConstantInitializerContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConstantInitializerContext() *ConstantInitializerContext {
	var p = new(ConstantInitializerContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PHPParserRULE_constantInitializer
	return p
}

func (*ConstantInitializerContext) IsConstantInitializerContext() {}

func NewConstantInitializerContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ConstantInitializerContext {
	var p = new(ConstantInitializerContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PHPParserRULE_constantInitializer

	return p
}

func (s *ConstantInitializerContext) GetParser() antlr.Parser { return s.parser }

func (s *ConstantInitializerContext) AllConstant() []IConstantContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IConstantContext); ok {
			len++
		}
	}

	tst := make([]IConstantContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IConstantContext); ok {
			tst[i] = t.(IConstantContext)
			i++
		}
	}

	return tst
}

func (s *ConstantInitializerContext) Constant(i int) IConstantContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConstantContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConstantContext)
}

func (s *ConstantInitializerContext) AllString_() []IStringContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStringContext); ok {
			len++
		}
	}

	tst := make([]IStringContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStringContext); ok {
			tst[i] = t.(IStringContext)
			i++
		}
	}

	return tst
}

func (s *ConstantInitializerContext) String_(i int) IStringContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *ConstantInitializerContext) Array() antlr.TerminalNode {
	return s.GetToken(PHPParserArray, 0)
}

func (s *ConstantInitializerContext) OpenRoundBracket() antlr.TerminalNode {
	return s.GetToken(PHPParserOpenRoundBracket, 0)
}

func (s *ConstantInitializerContext) CloseRoundBracket() antlr.TerminalNode {
	return s.GetToken(PHPParserCloseRoundBracket, 0)
}

func (s *ConstantInitializerContext) ArrayItemList() IArrayItemListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArrayItemListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArrayItemListContext)
}

func (s *ConstantInitializerContext) Comma() antlr.TerminalNode {
	return s.GetToken(PHPParserComma, 0)
}

func (s *ConstantInitializerContext) OpenSquareBracket() antlr.TerminalNode {
	return s.GetToken(PHPParserOpenSquareBracket, 0)
}

func (s *ConstantInitializerContext) CloseSquareBracket() antlr.TerminalNode {
	return s.GetToken(PHPParserCloseSquareBracket, 0)
}

func (s *ConstantInitializerContext) ConstantInitializer() IConstantInitializerContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConstantInitializerContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConstantInitializerContext)
}

func (s *ConstantInitializerContext) Plus() antlr.TerminalNode {
	return s.GetToken(PHPParserPlus, 0)
}

func (s *ConstantInitializerContext) Minus() antlr.TerminalNode {
	return s.GetToken(PHPParserMinus, 0)
}

func (s *ConstantInitializerContext) AllDot() []antlr.TerminalNode {
	return s.GetTokens(PHPParserDot)
}

func (s *ConstantInitializerContext) Dot(i int) antlr.TerminalNode {
	return s.GetToken(PHPParserDot, i)
}

func (s *ConstantInitializerContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ConstantInitializerContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ConstantInitializerContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PHPParserVisitor:
		return t.VisitConstantInitializer(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PHPParser) ConstantInitializer() (localctx IConstantInitializerContext) {
	this := p
	_ = this

	localctx = NewConstantInitializerContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 220, PHPParserRULE_constantInitializer)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1739)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 218, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1704)
			p.Constant()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1705)
			p.String_()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1706)
			p.Match(PHPParserArray)
		}
		{
			p.SetState(1707)
			p.Match(PHPParserOpenRoundBracket)
		}
		p.SetState(1712)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if (int64((_la-44)) & ^0x3f) == 0 && ((int64(1)<<(_la-44))&-1) != 0 || (int64((_la-108)) & ^0x3f) == 0 && ((int64(1)<<(_la-108))&441352763482308607) != 0 || (int64((_la-194)) & ^0x3f) == 0 && ((int64(1)<<(_la-194))&4396974138193) != 0 {
			{
				p.SetState(1708)
				p.ArrayItemList()
			}
			p.SetState(1710)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == PHPParserComma {
				{
					p.SetState(1709)
					p.Match(PHPParserComma)
				}

			}

		}
		{
			p.SetState(1714)
			p.Match(PHPParserCloseRoundBracket)
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1715)
			p.Match(PHPParserOpenSquareBracket)
		}
		p.SetState(1720)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if (int64((_la-44)) & ^0x3f) == 0 && ((int64(1)<<(_la-44))&-1) != 0 || (int64((_la-108)) & ^0x3f) == 0 && ((int64(1)<<(_la-108))&441352763482308607) != 0 || (int64((_la-194)) & ^0x3f) == 0 && ((int64(1)<<(_la-194))&4396974138193) != 0 {
			{
				p.SetState(1716)
				p.ArrayItemList()
			}
			p.SetState(1718)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == PHPParserComma {
				{
					p.SetState(1717)
					p.Match(PHPParserComma)
				}

			}

		}
		{
			p.SetState(1722)
			p.Match(PHPParserCloseSquareBracket)
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1723)
			_la = p.GetTokenStream().LA(1)

			if !(_la == PHPParserPlus || _la == PHPParserMinus) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(1724)
			p.ConstantInitializer()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		p.SetState(1727)
		p.GetErrorHandler().Sync(p)
		switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 215, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(1725)
				p.String_()
			}

		case 2:
			{
				p.SetState(1726)
				p.Constant()
			}

		}
		p.SetState(1736)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == PHPParserDot {
			{
				p.SetState(1729)
				p.Match(PHPParserDot)
			}
			p.SetState(1732)
			p.GetErrorHandler().Sync(p)
			switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 216, p.GetParserRuleContext()) {
			case 1:
				{
					p.SetState(1730)
					p.String_()
				}

			case 2:
				{
					p.SetState(1731)
					p.Constant()
				}

			}

			p.SetState(1738)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	}

	return localctx
}

// IConstantContext is an interface to support dynamic dispatch.
type IConstantContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsConstantContext differentiates from other interfaces.
	IsConstantContext()
}

type ConstantContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConstantContext() *ConstantContext {
	var p = new(ConstantContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PHPParserRULE_constant
	return p
}

func (*ConstantContext) IsConstantContext() {}

func NewConstantContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ConstantContext {
	var p = new(ConstantContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PHPParserRULE_constant

	return p
}

func (s *ConstantContext) GetParser() antlr.Parser { return s.parser }

func (s *ConstantContext) Null() antlr.TerminalNode {
	return s.GetToken(PHPParserNull, 0)
}

func (s *ConstantContext) LiteralConstant() ILiteralConstantContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILiteralConstantContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILiteralConstantContext)
}

func (s *ConstantContext) MagicConstant() IMagicConstantContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMagicConstantContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMagicConstantContext)
}

func (s *ConstantContext) ClassConstant() IClassConstantContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClassConstantContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClassConstantContext)
}

func (s *ConstantContext) QualifiedNamespaceName() IQualifiedNamespaceNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNamespaceNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNamespaceNameContext)
}

func (s *ConstantContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ConstantContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ConstantContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PHPParserVisitor:
		return t.VisitConstant(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PHPParser) Constant() (localctx IConstantContext) {
	this := p
	_ = this

	localctx = NewConstantContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 222, PHPParserRULE_constant)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1746)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 219, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1741)
			p.Match(PHPParserNull)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1742)
			p.LiteralConstant()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1743)
			p.MagicConstant()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1744)
			p.ClassConstant()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1745)
			p.QualifiedNamespaceName()
		}

	}

	return localctx
}

// ILiteralConstantContext is an interface to support dynamic dispatch.
type ILiteralConstantContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLiteralConstantContext differentiates from other interfaces.
	IsLiteralConstantContext()
}

type LiteralConstantContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLiteralConstantContext() *LiteralConstantContext {
	var p = new(LiteralConstantContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PHPParserRULE_literalConstant
	return p
}

func (*LiteralConstantContext) IsLiteralConstantContext() {}

func NewLiteralConstantContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LiteralConstantContext {
	var p = new(LiteralConstantContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PHPParserRULE_literalConstant

	return p
}

func (s *LiteralConstantContext) GetParser() antlr.Parser { return s.parser }

func (s *LiteralConstantContext) Real() antlr.TerminalNode {
	return s.GetToken(PHPParserReal, 0)
}

func (s *LiteralConstantContext) BooleanConstant() antlr.TerminalNode {
	return s.GetToken(PHPParserBooleanConstant, 0)
}

func (s *LiteralConstantContext) NumericConstant() INumericConstantContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INumericConstantContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INumericConstantContext)
}

func (s *LiteralConstantContext) StringConstant() IStringConstantContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringConstantContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringConstantContext)
}

func (s *LiteralConstantContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LiteralConstantContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LiteralConstantContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PHPParserVisitor:
		return t.VisitLiteralConstant(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PHPParser) LiteralConstant() (localctx ILiteralConstantContext) {
	this := p
	_ = this

	localctx = NewLiteralConstantContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 224, PHPParserRULE_literalConstant)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1752)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case PHPParserReal:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1748)
			p.Match(PHPParserReal)
		}

	case PHPParserBooleanConstant:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1749)
			p.Match(PHPParserBooleanConstant)
		}

	case PHPParserOctal, PHPParserDecimal, PHPParserHex, PHPParserBinary:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1750)
			p.NumericConstant()
		}

	case PHPParserLabel:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1751)
			p.StringConstant()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// INumericConstantContext is an interface to support dynamic dispatch.
type INumericConstantContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsNumericConstantContext differentiates from other interfaces.
	IsNumericConstantContext()
}

type NumericConstantContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNumericConstantContext() *NumericConstantContext {
	var p = new(NumericConstantContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PHPParserRULE_numericConstant
	return p
}

func (*NumericConstantContext) IsNumericConstantContext() {}

func NewNumericConstantContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NumericConstantContext {
	var p = new(NumericConstantContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PHPParserRULE_numericConstant

	return p
}

func (s *NumericConstantContext) GetParser() antlr.Parser { return s.parser }

func (s *NumericConstantContext) Octal() antlr.TerminalNode {
	return s.GetToken(PHPParserOctal, 0)
}

func (s *NumericConstantContext) Decimal() antlr.TerminalNode {
	return s.GetToken(PHPParserDecimal, 0)
}

func (s *NumericConstantContext) Hex() antlr.TerminalNode {
	return s.GetToken(PHPParserHex, 0)
}

func (s *NumericConstantContext) Binary() antlr.TerminalNode {
	return s.GetToken(PHPParserBinary, 0)
}

func (s *NumericConstantContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NumericConstantContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NumericConstantContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PHPParserVisitor:
		return t.VisitNumericConstant(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PHPParser) NumericConstant() (localctx INumericConstantContext) {
	this := p
	_ = this

	localctx = NewNumericConstantContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 226, PHPParserRULE_numericConstant)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1754)
		_la = p.GetTokenStream().LA(1)

		if !((int64((_la-226)) & ^0x3f) == 0 && ((int64(1)<<(_la-226))&27) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IClassConstantContext is an interface to support dynamic dispatch.
type IClassConstantContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsClassConstantContext differentiates from other interfaces.
	IsClassConstantContext()
}

type ClassConstantContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyClassConstantContext() *ClassConstantContext {
	var p = new(ClassConstantContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PHPParserRULE_classConstant
	return p
}

func (*ClassConstantContext) IsClassConstantContext() {}

func NewClassConstantContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ClassConstantContext {
	var p = new(ClassConstantContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PHPParserRULE_classConstant

	return p
}

func (s *ClassConstantContext) GetParser() antlr.Parser { return s.parser }

func (s *ClassConstantContext) DoubleColon() antlr.TerminalNode {
	return s.GetToken(PHPParserDoubleColon, 0)
}

func (s *ClassConstantContext) Class() antlr.TerminalNode {
	return s.GetToken(PHPParserClass, 0)
}

func (s *ClassConstantContext) Parent_() antlr.TerminalNode {
	return s.GetToken(PHPParserParent_, 0)
}

func (s *ClassConstantContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ClassConstantContext) Constructor() antlr.TerminalNode {
	return s.GetToken(PHPParserConstructor, 0)
}

func (s *ClassConstantContext) Get() antlr.TerminalNode {
	return s.GetToken(PHPParserGet, 0)
}

func (s *ClassConstantContext) Set() antlr.TerminalNode {
	return s.GetToken(PHPParserSet, 0)
}

func (s *ClassConstantContext) QualifiedStaticTypeRef() IQualifiedStaticTypeRefContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedStaticTypeRefContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedStaticTypeRefContext)
}

func (s *ClassConstantContext) AllKeyedVariable() []IKeyedVariableContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IKeyedVariableContext); ok {
			len++
		}
	}

	tst := make([]IKeyedVariableContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IKeyedVariableContext); ok {
			tst[i] = t.(IKeyedVariableContext)
			i++
		}
	}

	return tst
}

func (s *ClassConstantContext) KeyedVariable(i int) IKeyedVariableContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKeyedVariableContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKeyedVariableContext)
}

func (s *ClassConstantContext) String_() IStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *ClassConstantContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ClassConstantContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ClassConstantContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PHPParserVisitor:
		return t.VisitClassConstant(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PHPParser) ClassConstant() (localctx IClassConstantContext) {
	this := p
	_ = this

	localctx = NewClassConstantContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 228, PHPParserRULE_classConstant)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1774)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 224, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1756)
			_la = p.GetTokenStream().LA(1)

			if !(_la == PHPParserClass || _la == PHPParserParent_) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(1757)
			p.Match(PHPParserDoubleColon)
		}
		p.SetState(1762)
		p.GetErrorHandler().Sync(p)
		switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 221, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(1758)
				p.Identifier()
			}

		case 2:
			{
				p.SetState(1759)
				p.Match(PHPParserConstructor)
			}

		case 3:
			{
				p.SetState(1760)
				p.Match(PHPParserGet)
			}

		case 4:
			{
				p.SetState(1761)
				p.Match(PHPParserSet)
			}

		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(1767)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case PHPParserAbstract, PHPParserArray, PHPParserAs, PHPParserBinaryCast, PHPParserBoolType, PHPParserBooleanConstant, PHPParserBreak, PHPParserCallable, PHPParserCase, PHPParserCatch, PHPParserClass, PHPParserClone, PHPParserConst, PHPParserContinue, PHPParserDeclare, PHPParserDefault, PHPParserDo, PHPParserDoubleCast, PHPParserDoubleType, PHPParserEcho, PHPParserElse, PHPParserElseIf, PHPParserEmpty, PHPParserEnum_, PHPParserEndDeclare, PHPParserEndFor, PHPParserEndForeach, PHPParserEndIf, PHPParserEndSwitch, PHPParserEndWhile, PHPParserEval, PHPParserExit, PHPParserExtends, PHPParserFinal, PHPParserFinally, PHPParserFloatCast, PHPParserFor, PHPParserForeach, PHPParserFunction_, PHPParserGlobal, PHPParserGoto, PHPParserIf, PHPParserImplements, PHPParserImport, PHPParserInclude, PHPParserIncludeOnce, PHPParserInstanceOf, PHPParserInsteadOf, PHPParserInt8Cast, PHPParserInt16Cast, PHPParserInt64Type, PHPParserIntType, PHPParserInterface, PHPParserIsSet, PHPParserList, PHPParserLogicalAnd, PHPParserLogicalOr, PHPParserLogicalXor, PHPParserMatch_, PHPParserNamespace, PHPParserNew, PHPParserNull, PHPParserObjectType, PHPParserParent_, PHPParserPartial, PHPParserPrint, PHPParserPrivate, PHPParserProtected, PHPParserPublic, PHPParserReadonly, PHPParserRequire, PHPParserRequireOnce, PHPParserResource, PHPParserReturn, PHPParserStatic, PHPParserStringType, PHPParserSwitch, PHPParserThrow, PHPParserTrait, PHPParserTry, PHPParserTypeof, PHPParserUintCast, PHPParserUnicodeCast, PHPParserUnset, PHPParserUse, PHPParserVar, PHPParserWhile, PHPParserYield, PHPParserFrom, PHPParserLambdaFn, PHPParserTicks, PHPParserEncoding, PHPParserStrictTypes, PHPParserGet, PHPParserSet, PHPParserCall, PHPParserCallStatic, PHPParserConstructor, PHPParserDestruct, PHPParserWakeup, PHPParserSleep, PHPParserAutoload, PHPParserIsSet__, PHPParserUnset__, PHPParserToString__, PHPParserInvoke, PHPParserSetState, PHPParserClone__, PHPParserDebugInfo, PHPParserNamespace__, PHPParserClass__, PHPParserTraic__, PHPParserFunction__, PHPParserMethod__, PHPParserLine__, PHPParserFile__, PHPParserDir__, PHPParserNamespaceSeparator, PHPParserLabel:
			{
				p.SetState(1764)
				p.QualifiedStaticTypeRef()
			}

		case PHPParserDollar, PHPParserVarName:
			{
				p.SetState(1765)
				p.KeyedVariable()
			}

		case PHPParserSingleQuoteString, PHPParserDoubleQuote, PHPParserStartNowDoc, PHPParserStartHereDoc:
			{
				p.SetState(1766)
				p.String_()
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}
		{
			p.SetState(1769)
			p.Match(PHPParserDoubleColon)
		}
		p.SetState(1772)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case PHPParserAbstract, PHPParserArray, PHPParserAs, PHPParserBinaryCast, PHPParserBoolType, PHPParserBooleanConstant, PHPParserBreak, PHPParserCallable, PHPParserCase, PHPParserCatch, PHPParserClass, PHPParserClone, PHPParserConst, PHPParserContinue, PHPParserDeclare, PHPParserDefault, PHPParserDo, PHPParserDoubleCast, PHPParserDoubleType, PHPParserEcho, PHPParserElse, PHPParserElseIf, PHPParserEmpty, PHPParserEnum_, PHPParserEndDeclare, PHPParserEndFor, PHPParserEndForeach, PHPParserEndIf, PHPParserEndSwitch, PHPParserEndWhile, PHPParserEval, PHPParserExit, PHPParserExtends, PHPParserFinal, PHPParserFinally, PHPParserFloatCast, PHPParserFor, PHPParserForeach, PHPParserFunction_, PHPParserGlobal, PHPParserGoto, PHPParserIf, PHPParserImplements, PHPParserImport, PHPParserInclude, PHPParserIncludeOnce, PHPParserInstanceOf, PHPParserInsteadOf, PHPParserInt8Cast, PHPParserInt16Cast, PHPParserInt64Type, PHPParserIntType, PHPParserInterface, PHPParserIsSet, PHPParserList, PHPParserLogicalAnd, PHPParserLogicalOr, PHPParserLogicalXor, PHPParserMatch_, PHPParserNamespace, PHPParserNew, PHPParserNull, PHPParserObjectType, PHPParserParent_, PHPParserPartial, PHPParserPrint, PHPParserPrivate, PHPParserProtected, PHPParserPublic, PHPParserReadonly, PHPParserRequire, PHPParserRequireOnce, PHPParserResource, PHPParserReturn, PHPParserStatic, PHPParserStringType, PHPParserSwitch, PHPParserThrow, PHPParserTrait, PHPParserTry, PHPParserTypeof, PHPParserUintCast, PHPParserUnicodeCast, PHPParserUnset, PHPParserUse, PHPParserVar, PHPParserWhile, PHPParserYield, PHPParserFrom, PHPParserLambdaFn, PHPParserTicks, PHPParserEncoding, PHPParserStrictTypes, PHPParserGet, PHPParserSet, PHPParserCall, PHPParserCallStatic, PHPParserConstructor, PHPParserDestruct, PHPParserWakeup, PHPParserSleep, PHPParserAutoload, PHPParserIsSet__, PHPParserUnset__, PHPParserToString__, PHPParserInvoke, PHPParserSetState, PHPParserClone__, PHPParserDebugInfo, PHPParserNamespace__, PHPParserClass__, PHPParserTraic__, PHPParserFunction__, PHPParserMethod__, PHPParserLine__, PHPParserFile__, PHPParserDir__, PHPParserLabel:
			{
				p.SetState(1770)
				p.Identifier()
			}

		case PHPParserDollar, PHPParserVarName:
			{
				p.SetState(1771)
				p.KeyedVariable()
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

	}

	return localctx
}

// IStringConstantContext is an interface to support dynamic dispatch.
type IStringConstantContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsStringConstantContext differentiates from other interfaces.
	IsStringConstantContext()
}

type StringConstantContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStringConstantContext() *StringConstantContext {
	var p = new(StringConstantContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PHPParserRULE_stringConstant
	return p
}

func (*StringConstantContext) IsStringConstantContext() {}

func NewStringConstantContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StringConstantContext {
	var p = new(StringConstantContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PHPParserRULE_stringConstant

	return p
}

func (s *StringConstantContext) GetParser() antlr.Parser { return s.parser }

func (s *StringConstantContext) Label() antlr.TerminalNode {
	return s.GetToken(PHPParserLabel, 0)
}

func (s *StringConstantContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StringConstantContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StringConstantContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PHPParserVisitor:
		return t.VisitStringConstant(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PHPParser) StringConstant() (localctx IStringConstantContext) {
	this := p
	_ = this

	localctx = NewStringConstantContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 230, PHPParserRULE_stringConstant)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1776)
		p.Match(PHPParserLabel)
	}

	return localctx
}

// IStringContext is an interface to support dynamic dispatch.
type IStringContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsStringContext differentiates from other interfaces.
	IsStringContext()
}

type StringContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStringContext() *StringContext {
	var p = new(StringContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PHPParserRULE_string
	return p
}

func (*StringContext) IsStringContext() {}

func NewStringContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StringContext {
	var p = new(StringContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PHPParserRULE_string

	return p
}

func (s *StringContext) GetParser() antlr.Parser { return s.parser }

func (s *StringContext) StartHereDoc() antlr.TerminalNode {
	return s.GetToken(PHPParserStartHereDoc, 0)
}

func (s *StringContext) AllHereDocText() []antlr.TerminalNode {
	return s.GetTokens(PHPParserHereDocText)
}

func (s *StringContext) HereDocText(i int) antlr.TerminalNode {
	return s.GetToken(PHPParserHereDocText, i)
}

func (s *StringContext) StartNowDoc() antlr.TerminalNode {
	return s.GetToken(PHPParserStartNowDoc, 0)
}

func (s *StringContext) SingleQuoteString() antlr.TerminalNode {
	return s.GetToken(PHPParserSingleQuoteString, 0)
}

func (s *StringContext) AllDoubleQuote() []antlr.TerminalNode {
	return s.GetTokens(PHPParserDoubleQuote)
}

func (s *StringContext) DoubleQuote(i int) antlr.TerminalNode {
	return s.GetToken(PHPParserDoubleQuote, i)
}

func (s *StringContext) AllInterpolatedStringPart() []IInterpolatedStringPartContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IInterpolatedStringPartContext); ok {
			len++
		}
	}

	tst := make([]IInterpolatedStringPartContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IInterpolatedStringPartContext); ok {
			tst[i] = t.(IInterpolatedStringPartContext)
			i++
		}
	}

	return tst
}

func (s *StringContext) InterpolatedStringPart(i int) IInterpolatedStringPartContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInterpolatedStringPartContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInterpolatedStringPartContext)
}

func (s *StringContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StringContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StringContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PHPParserVisitor:
		return t.VisitString(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PHPParser) String_() (localctx IStringContext) {
	this := p
	_ = this

	localctx = NewStringContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 232, PHPParserRULE_string)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.SetState(1799)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case PHPParserStartHereDoc:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1778)
			p.Match(PHPParserStartHereDoc)
		}
		p.SetState(1780)
		p.GetErrorHandler().Sync(p)
		_alt = 1
		for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			switch _alt {
			case 1:
				{
					p.SetState(1779)
					p.Match(PHPParserHereDocText)
				}

			default:
				panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			}

			p.SetState(1782)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 225, p.GetParserRuleContext())
		}

	case PHPParserStartNowDoc:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1784)
			p.Match(PHPParserStartNowDoc)
		}
		p.SetState(1786)
		p.GetErrorHandler().Sync(p)
		_alt = 1
		for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			switch _alt {
			case 1:
				{
					p.SetState(1785)
					p.Match(PHPParserHereDocText)
				}

			default:
				panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			}

			p.SetState(1788)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 226, p.GetParserRuleContext())
		}

	case PHPParserSingleQuoteString:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1790)
			p.Match(PHPParserSingleQuoteString)
		}

	case PHPParserDoubleQuote:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1791)
			p.Match(PHPParserDoubleQuote)
		}
		p.SetState(1795)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 227, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(1792)
					p.InterpolatedStringPart()
				}

			}
			p.SetState(1797)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 227, p.GetParserRuleContext())
		}
		{
			p.SetState(1798)
			p.Match(PHPParserDoubleQuote)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IInterpolatedStringPartContext is an interface to support dynamic dispatch.
type IInterpolatedStringPartContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInterpolatedStringPartContext differentiates from other interfaces.
	IsInterpolatedStringPartContext()
}

type InterpolatedStringPartContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInterpolatedStringPartContext() *InterpolatedStringPartContext {
	var p = new(InterpolatedStringPartContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PHPParserRULE_interpolatedStringPart
	return p
}

func (*InterpolatedStringPartContext) IsInterpolatedStringPartContext() {}

func NewInterpolatedStringPartContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InterpolatedStringPartContext {
	var p = new(InterpolatedStringPartContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PHPParserRULE_interpolatedStringPart

	return p
}

func (s *InterpolatedStringPartContext) GetParser() antlr.Parser { return s.parser }

func (s *InterpolatedStringPartContext) StringPart() antlr.TerminalNode {
	return s.GetToken(PHPParserStringPart, 0)
}

func (s *InterpolatedStringPartContext) UnicodeEscape() antlr.TerminalNode {
	return s.GetToken(PHPParserUnicodeEscape, 0)
}

func (s *InterpolatedStringPartContext) Chain() IChainContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IChainContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IChainContext)
}

func (s *InterpolatedStringPartContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InterpolatedStringPartContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InterpolatedStringPartContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PHPParserVisitor:
		return t.VisitInterpolatedStringPart(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PHPParser) InterpolatedStringPart() (localctx IInterpolatedStringPartContext) {
	this := p
	_ = this

	localctx = NewInterpolatedStringPartContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 234, PHPParserRULE_interpolatedStringPart)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1804)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case PHPParserStringPart:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1801)
			p.Match(PHPParserStringPart)
		}

	case PHPParserUnicodeEscape:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1802)
			p.Match(PHPParserUnicodeEscape)
		}

	case PHPParserAbstract, PHPParserArray, PHPParserAs, PHPParserBinaryCast, PHPParserBoolType, PHPParserBooleanConstant, PHPParserBreak, PHPParserCallable, PHPParserCase, PHPParserCatch, PHPParserClass, PHPParserClone, PHPParserConst, PHPParserContinue, PHPParserDeclare, PHPParserDefault, PHPParserDo, PHPParserDoubleCast, PHPParserDoubleType, PHPParserEcho, PHPParserElse, PHPParserElseIf, PHPParserEmpty, PHPParserEnum_, PHPParserEndDeclare, PHPParserEndFor, PHPParserEndForeach, PHPParserEndIf, PHPParserEndSwitch, PHPParserEndWhile, PHPParserEval, PHPParserExit, PHPParserExtends, PHPParserFinal, PHPParserFinally, PHPParserFloatCast, PHPParserFor, PHPParserForeach, PHPParserFunction_, PHPParserGlobal, PHPParserGoto, PHPParserIf, PHPParserImplements, PHPParserImport, PHPParserInclude, PHPParserIncludeOnce, PHPParserInstanceOf, PHPParserInsteadOf, PHPParserInt8Cast, PHPParserInt16Cast, PHPParserInt64Type, PHPParserIntType, PHPParserInterface, PHPParserIsSet, PHPParserList, PHPParserLogicalAnd, PHPParserLogicalOr, PHPParserLogicalXor, PHPParserMatch_, PHPParserNamespace, PHPParserNew, PHPParserNull, PHPParserObjectType, PHPParserParent_, PHPParserPartial, PHPParserPrint, PHPParserPrivate, PHPParserProtected, PHPParserPublic, PHPParserReadonly, PHPParserRequire, PHPParserRequireOnce, PHPParserResource, PHPParserReturn, PHPParserStatic, PHPParserStringType, PHPParserSwitch, PHPParserThrow, PHPParserTrait, PHPParserTry, PHPParserTypeof, PHPParserUintCast, PHPParserUnicodeCast, PHPParserUnset, PHPParserUse, PHPParserVar, PHPParserWhile, PHPParserYield, PHPParserFrom, PHPParserLambdaFn, PHPParserTicks, PHPParserEncoding, PHPParserStrictTypes, PHPParserGet, PHPParserSet, PHPParserCall, PHPParserCallStatic, PHPParserConstructor, PHPParserDestruct, PHPParserWakeup, PHPParserSleep, PHPParserAutoload, PHPParserIsSet__, PHPParserUnset__, PHPParserToString__, PHPParserInvoke, PHPParserSetState, PHPParserClone__, PHPParserDebugInfo, PHPParserNamespace__, PHPParserClass__, PHPParserTraic__, PHPParserFunction__, PHPParserMethod__, PHPParserLine__, PHPParserFile__, PHPParserDir__, PHPParserNamespaceSeparator, PHPParserDollar, PHPParserOpenRoundBracket, PHPParserVarName, PHPParserLabel, PHPParserSingleQuoteString, PHPParserDoubleQuote, PHPParserStartNowDoc, PHPParserStartHereDoc:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1803)
			p.Chain()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IChainListContext is an interface to support dynamic dispatch.
type IChainListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsChainListContext differentiates from other interfaces.
	IsChainListContext()
}

type ChainListContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyChainListContext() *ChainListContext {
	var p = new(ChainListContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PHPParserRULE_chainList
	return p
}

func (*ChainListContext) IsChainListContext() {}

func NewChainListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ChainListContext {
	var p = new(ChainListContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PHPParserRULE_chainList

	return p
}

func (s *ChainListContext) GetParser() antlr.Parser { return s.parser }

func (s *ChainListContext) AllChain() []IChainContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IChainContext); ok {
			len++
		}
	}

	tst := make([]IChainContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IChainContext); ok {
			tst[i] = t.(IChainContext)
			i++
		}
	}

	return tst
}

func (s *ChainListContext) Chain(i int) IChainContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IChainContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IChainContext)
}

func (s *ChainListContext) AllComma() []antlr.TerminalNode {
	return s.GetTokens(PHPParserComma)
}

func (s *ChainListContext) Comma(i int) antlr.TerminalNode {
	return s.GetToken(PHPParserComma, i)
}

func (s *ChainListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ChainListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ChainListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PHPParserVisitor:
		return t.VisitChainList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PHPParser) ChainList() (localctx IChainListContext) {
	this := p
	_ = this

	localctx = NewChainListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 236, PHPParserRULE_chainList)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1806)
		p.Chain()
	}
	p.SetState(1811)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == PHPParserComma {
		{
			p.SetState(1807)
			p.Match(PHPParserComma)
		}
		{
			p.SetState(1808)
			p.Chain()
		}

		p.SetState(1813)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IChainContext is an interface to support dynamic dispatch.
type IChainContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsChainContext differentiates from other interfaces.
	IsChainContext()
}

type ChainContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyChainContext() *ChainContext {
	var p = new(ChainContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PHPParserRULE_chain
	return p
}

func (*ChainContext) IsChainContext() {}

func NewChainContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ChainContext {
	var p = new(ChainContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PHPParserRULE_chain

	return p
}

func (s *ChainContext) GetParser() antlr.Parser { return s.parser }

func (s *ChainContext) ChainOrigin() IChainOriginContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IChainOriginContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IChainOriginContext)
}

func (s *ChainContext) AllMemberAccess() []IMemberAccessContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IMemberAccessContext); ok {
			len++
		}
	}

	tst := make([]IMemberAccessContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IMemberAccessContext); ok {
			tst[i] = t.(IMemberAccessContext)
			i++
		}
	}

	return tst
}

func (s *ChainContext) MemberAccess(i int) IMemberAccessContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMemberAccessContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMemberAccessContext)
}

func (s *ChainContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ChainContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ChainContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PHPParserVisitor:
		return t.VisitChain(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PHPParser) Chain() (localctx IChainContext) {
	this := p
	_ = this

	localctx = NewChainContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 238, PHPParserRULE_chain)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1814)
		p.ChainOrigin()
	}
	p.SetState(1818)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 231, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1815)
				p.MemberAccess()
			}

		}
		p.SetState(1820)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 231, p.GetParserRuleContext())
	}

	return localctx
}

// IChainOriginContext is an interface to support dynamic dispatch.
type IChainOriginContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsChainOriginContext differentiates from other interfaces.
	IsChainOriginContext()
}

type ChainOriginContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyChainOriginContext() *ChainOriginContext {
	var p = new(ChainOriginContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PHPParserRULE_chainOrigin
	return p
}

func (*ChainOriginContext) IsChainOriginContext() {}

func NewChainOriginContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ChainOriginContext {
	var p = new(ChainOriginContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PHPParserRULE_chainOrigin

	return p
}

func (s *ChainOriginContext) GetParser() antlr.Parser { return s.parser }

func (s *ChainOriginContext) ChainBase() IChainBaseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IChainBaseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IChainBaseContext)
}

func (s *ChainOriginContext) FunctionCall() IFunctionCallContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionCallContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionCallContext)
}

func (s *ChainOriginContext) OpenRoundBracket() antlr.TerminalNode {
	return s.GetToken(PHPParserOpenRoundBracket, 0)
}

func (s *ChainOriginContext) NewExpr() INewExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INewExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INewExprContext)
}

func (s *ChainOriginContext) CloseRoundBracket() antlr.TerminalNode {
	return s.GetToken(PHPParserCloseRoundBracket, 0)
}

func (s *ChainOriginContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ChainOriginContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ChainOriginContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PHPParserVisitor:
		return t.VisitChainOrigin(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PHPParser) ChainOrigin() (localctx IChainOriginContext) {
	this := p
	_ = this

	localctx = NewChainOriginContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 240, PHPParserRULE_chainOrigin)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1827)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 232, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1821)
			p.ChainBase()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1822)
			p.FunctionCall()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1823)
			p.Match(PHPParserOpenRoundBracket)
		}
		{
			p.SetState(1824)
			p.NewExpr()
		}
		{
			p.SetState(1825)
			p.Match(PHPParserCloseRoundBracket)
		}

	}

	return localctx
}

// IMemberAccessContext is an interface to support dynamic dispatch.
type IMemberAccessContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMemberAccessContext differentiates from other interfaces.
	IsMemberAccessContext()
}

type MemberAccessContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMemberAccessContext() *MemberAccessContext {
	var p = new(MemberAccessContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PHPParserRULE_memberAccess
	return p
}

func (*MemberAccessContext) IsMemberAccessContext() {}

func NewMemberAccessContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MemberAccessContext {
	var p = new(MemberAccessContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PHPParserRULE_memberAccess

	return p
}

func (s *MemberAccessContext) GetParser() antlr.Parser { return s.parser }

func (s *MemberAccessContext) ObjectOperator() antlr.TerminalNode {
	return s.GetToken(PHPParserObjectOperator, 0)
}

func (s *MemberAccessContext) KeyedFieldName() IKeyedFieldNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKeyedFieldNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKeyedFieldNameContext)
}

func (s *MemberAccessContext) ActualArguments() IActualArgumentsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IActualArgumentsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IActualArgumentsContext)
}

func (s *MemberAccessContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MemberAccessContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MemberAccessContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PHPParserVisitor:
		return t.VisitMemberAccess(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PHPParser) MemberAccess() (localctx IMemberAccessContext) {
	this := p
	_ = this

	localctx = NewMemberAccessContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 242, PHPParserRULE_memberAccess)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1829)
		p.Match(PHPParserObjectOperator)
	}
	{
		p.SetState(1830)
		p.KeyedFieldName()
	}
	p.SetState(1832)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 233, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1831)
			p.ActualArguments()
		}

	}

	return localctx
}

// IFunctionCallContext is an interface to support dynamic dispatch.
type IFunctionCallContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFunctionCallContext differentiates from other interfaces.
	IsFunctionCallContext()
}

type FunctionCallContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunctionCallContext() *FunctionCallContext {
	var p = new(FunctionCallContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PHPParserRULE_functionCall
	return p
}

func (*FunctionCallContext) IsFunctionCallContext() {}

func NewFunctionCallContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FunctionCallContext {
	var p = new(FunctionCallContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PHPParserRULE_functionCall

	return p
}

func (s *FunctionCallContext) GetParser() antlr.Parser { return s.parser }

func (s *FunctionCallContext) FunctionCallName() IFunctionCallNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionCallNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionCallNameContext)
}

func (s *FunctionCallContext) ActualArguments() IActualArgumentsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IActualArgumentsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IActualArgumentsContext)
}

func (s *FunctionCallContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FunctionCallContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FunctionCallContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PHPParserVisitor:
		return t.VisitFunctionCall(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PHPParser) FunctionCall() (localctx IFunctionCallContext) {
	this := p
	_ = this

	localctx = NewFunctionCallContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 244, PHPParserRULE_functionCall)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1834)
		p.FunctionCallName()
	}
	{
		p.SetState(1835)
		p.ActualArguments()
	}

	return localctx
}

// IFunctionCallNameContext is an interface to support dynamic dispatch.
type IFunctionCallNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFunctionCallNameContext differentiates from other interfaces.
	IsFunctionCallNameContext()
}

type FunctionCallNameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunctionCallNameContext() *FunctionCallNameContext {
	var p = new(FunctionCallNameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PHPParserRULE_functionCallName
	return p
}

func (*FunctionCallNameContext) IsFunctionCallNameContext() {}

func NewFunctionCallNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FunctionCallNameContext {
	var p = new(FunctionCallNameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PHPParserRULE_functionCallName

	return p
}

func (s *FunctionCallNameContext) GetParser() antlr.Parser { return s.parser }

func (s *FunctionCallNameContext) QualifiedNamespaceName() IQualifiedNamespaceNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNamespaceNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNamespaceNameContext)
}

func (s *FunctionCallNameContext) ClassConstant() IClassConstantContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClassConstantContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClassConstantContext)
}

func (s *FunctionCallNameContext) ChainBase() IChainBaseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IChainBaseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IChainBaseContext)
}

func (s *FunctionCallNameContext) Parentheses() IParenthesesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IParenthesesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IParenthesesContext)
}

func (s *FunctionCallNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FunctionCallNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FunctionCallNameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PHPParserVisitor:
		return t.VisitFunctionCallName(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PHPParser) FunctionCallName() (localctx IFunctionCallNameContext) {
	this := p
	_ = this

	localctx = NewFunctionCallNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 246, PHPParserRULE_functionCallName)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1841)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 234, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1837)
			p.QualifiedNamespaceName()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1838)
			p.ClassConstant()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1839)
			p.ChainBase()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1840)
			p.Parentheses()
		}

	}

	return localctx
}

// IActualArgumentsContext is an interface to support dynamic dispatch.
type IActualArgumentsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsActualArgumentsContext differentiates from other interfaces.
	IsActualArgumentsContext()
}

type ActualArgumentsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyActualArgumentsContext() *ActualArgumentsContext {
	var p = new(ActualArgumentsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PHPParserRULE_actualArguments
	return p
}

func (*ActualArgumentsContext) IsActualArgumentsContext() {}

func NewActualArgumentsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ActualArgumentsContext {
	var p = new(ActualArgumentsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PHPParserRULE_actualArguments

	return p
}

func (s *ActualArgumentsContext) GetParser() antlr.Parser { return s.parser }

func (s *ActualArgumentsContext) GenericDynamicArgs() IGenericDynamicArgsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGenericDynamicArgsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGenericDynamicArgsContext)
}

func (s *ActualArgumentsContext) AllArguments() []IArgumentsContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IArgumentsContext); ok {
			len++
		}
	}

	tst := make([]IArgumentsContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IArgumentsContext); ok {
			tst[i] = t.(IArgumentsContext)
			i++
		}
	}

	return tst
}

func (s *ActualArgumentsContext) Arguments(i int) IArgumentsContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArgumentsContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArgumentsContext)
}

func (s *ActualArgumentsContext) AllSquareCurlyExpression() []ISquareCurlyExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISquareCurlyExpressionContext); ok {
			len++
		}
	}

	tst := make([]ISquareCurlyExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISquareCurlyExpressionContext); ok {
			tst[i] = t.(ISquareCurlyExpressionContext)
			i++
		}
	}

	return tst
}

func (s *ActualArgumentsContext) SquareCurlyExpression(i int) ISquareCurlyExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISquareCurlyExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISquareCurlyExpressionContext)
}

func (s *ActualArgumentsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ActualArgumentsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ActualArgumentsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PHPParserVisitor:
		return t.VisitActualArguments(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PHPParser) ActualArguments() (localctx IActualArgumentsContext) {
	this := p
	_ = this

	localctx = NewActualArgumentsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 248, PHPParserRULE_actualArguments)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1844)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == PHPParserLgeneric {
		{
			p.SetState(1843)
			p.GenericDynamicArgs()
		}

	}
	p.SetState(1847)
	p.GetErrorHandler().Sync(p)
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			{
				p.SetState(1846)
				p.Arguments()
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(1849)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 236, p.GetParserRuleContext())
	}
	p.SetState(1854)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 237, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1851)
				p.SquareCurlyExpression()
			}

		}
		p.SetState(1856)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 237, p.GetParserRuleContext())
	}

	return localctx
}

// IChainBaseContext is an interface to support dynamic dispatch.
type IChainBaseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsChainBaseContext differentiates from other interfaces.
	IsChainBaseContext()
}

type ChainBaseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyChainBaseContext() *ChainBaseContext {
	var p = new(ChainBaseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PHPParserRULE_chainBase
	return p
}

func (*ChainBaseContext) IsChainBaseContext() {}

func NewChainBaseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ChainBaseContext {
	var p = new(ChainBaseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PHPParserRULE_chainBase

	return p
}

func (s *ChainBaseContext) GetParser() antlr.Parser { return s.parser }

func (s *ChainBaseContext) AllKeyedVariable() []IKeyedVariableContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IKeyedVariableContext); ok {
			len++
		}
	}

	tst := make([]IKeyedVariableContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IKeyedVariableContext); ok {
			tst[i] = t.(IKeyedVariableContext)
			i++
		}
	}

	return tst
}

func (s *ChainBaseContext) KeyedVariable(i int) IKeyedVariableContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKeyedVariableContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKeyedVariableContext)
}

func (s *ChainBaseContext) DoubleColon() antlr.TerminalNode {
	return s.GetToken(PHPParserDoubleColon, 0)
}

func (s *ChainBaseContext) QualifiedStaticTypeRef() IQualifiedStaticTypeRefContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedStaticTypeRefContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedStaticTypeRefContext)
}

func (s *ChainBaseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ChainBaseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ChainBaseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PHPParserVisitor:
		return t.VisitChainBase(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PHPParser) ChainBase() (localctx IChainBaseContext) {
	this := p
	_ = this

	localctx = NewChainBaseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 250, PHPParserRULE_chainBase)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1866)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case PHPParserDollar, PHPParserVarName:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1857)
			p.KeyedVariable()
		}
		p.SetState(1860)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 238, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1858)
				p.Match(PHPParserDoubleColon)
			}
			{
				p.SetState(1859)
				p.KeyedVariable()
			}

		}

	case PHPParserAbstract, PHPParserArray, PHPParserAs, PHPParserBinaryCast, PHPParserBoolType, PHPParserBooleanConstant, PHPParserBreak, PHPParserCallable, PHPParserCase, PHPParserCatch, PHPParserClass, PHPParserClone, PHPParserConst, PHPParserContinue, PHPParserDeclare, PHPParserDefault, PHPParserDo, PHPParserDoubleCast, PHPParserDoubleType, PHPParserEcho, PHPParserElse, PHPParserElseIf, PHPParserEmpty, PHPParserEnum_, PHPParserEndDeclare, PHPParserEndFor, PHPParserEndForeach, PHPParserEndIf, PHPParserEndSwitch, PHPParserEndWhile, PHPParserEval, PHPParserExit, PHPParserExtends, PHPParserFinal, PHPParserFinally, PHPParserFloatCast, PHPParserFor, PHPParserForeach, PHPParserFunction_, PHPParserGlobal, PHPParserGoto, PHPParserIf, PHPParserImplements, PHPParserImport, PHPParserInclude, PHPParserIncludeOnce, PHPParserInstanceOf, PHPParserInsteadOf, PHPParserInt8Cast, PHPParserInt16Cast, PHPParserInt64Type, PHPParserIntType, PHPParserInterface, PHPParserIsSet, PHPParserList, PHPParserLogicalAnd, PHPParserLogicalOr, PHPParserLogicalXor, PHPParserMatch_, PHPParserNamespace, PHPParserNew, PHPParserNull, PHPParserObjectType, PHPParserParent_, PHPParserPartial, PHPParserPrint, PHPParserPrivate, PHPParserProtected, PHPParserPublic, PHPParserReadonly, PHPParserRequire, PHPParserRequireOnce, PHPParserResource, PHPParserReturn, PHPParserStatic, PHPParserStringType, PHPParserSwitch, PHPParserThrow, PHPParserTrait, PHPParserTry, PHPParserTypeof, PHPParserUintCast, PHPParserUnicodeCast, PHPParserUnset, PHPParserUse, PHPParserVar, PHPParserWhile, PHPParserYield, PHPParserFrom, PHPParserLambdaFn, PHPParserTicks, PHPParserEncoding, PHPParserStrictTypes, PHPParserGet, PHPParserSet, PHPParserCall, PHPParserCallStatic, PHPParserConstructor, PHPParserDestruct, PHPParserWakeup, PHPParserSleep, PHPParserAutoload, PHPParserIsSet__, PHPParserUnset__, PHPParserToString__, PHPParserInvoke, PHPParserSetState, PHPParserClone__, PHPParserDebugInfo, PHPParserNamespace__, PHPParserClass__, PHPParserTraic__, PHPParserFunction__, PHPParserMethod__, PHPParserLine__, PHPParserFile__, PHPParserDir__, PHPParserNamespaceSeparator, PHPParserLabel:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1862)
			p.QualifiedStaticTypeRef()
		}
		{
			p.SetState(1863)
			p.Match(PHPParserDoubleColon)
		}
		{
			p.SetState(1864)
			p.KeyedVariable()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IKeyedFieldNameContext is an interface to support dynamic dispatch.
type IKeyedFieldNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsKeyedFieldNameContext differentiates from other interfaces.
	IsKeyedFieldNameContext()
}

type KeyedFieldNameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKeyedFieldNameContext() *KeyedFieldNameContext {
	var p = new(KeyedFieldNameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PHPParserRULE_keyedFieldName
	return p
}

func (*KeyedFieldNameContext) IsKeyedFieldNameContext() {}

func NewKeyedFieldNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *KeyedFieldNameContext {
	var p = new(KeyedFieldNameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PHPParserRULE_keyedFieldName

	return p
}

func (s *KeyedFieldNameContext) GetParser() antlr.Parser { return s.parser }

func (s *KeyedFieldNameContext) KeyedSimpleFieldName() IKeyedSimpleFieldNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKeyedSimpleFieldNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKeyedSimpleFieldNameContext)
}

func (s *KeyedFieldNameContext) KeyedVariable() IKeyedVariableContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKeyedVariableContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKeyedVariableContext)
}

func (s *KeyedFieldNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KeyedFieldNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *KeyedFieldNameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PHPParserVisitor:
		return t.VisitKeyedFieldName(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PHPParser) KeyedFieldName() (localctx IKeyedFieldNameContext) {
	this := p
	_ = this

	localctx = NewKeyedFieldNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 252, PHPParserRULE_keyedFieldName)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1870)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case PHPParserAbstract, PHPParserArray, PHPParserAs, PHPParserBinaryCast, PHPParserBoolType, PHPParserBooleanConstant, PHPParserBreak, PHPParserCallable, PHPParserCase, PHPParserCatch, PHPParserClass, PHPParserClone, PHPParserConst, PHPParserContinue, PHPParserDeclare, PHPParserDefault, PHPParserDo, PHPParserDoubleCast, PHPParserDoubleType, PHPParserEcho, PHPParserElse, PHPParserElseIf, PHPParserEmpty, PHPParserEnum_, PHPParserEndDeclare, PHPParserEndFor, PHPParserEndForeach, PHPParserEndIf, PHPParserEndSwitch, PHPParserEndWhile, PHPParserEval, PHPParserExit, PHPParserExtends, PHPParserFinal, PHPParserFinally, PHPParserFloatCast, PHPParserFor, PHPParserForeach, PHPParserFunction_, PHPParserGlobal, PHPParserGoto, PHPParserIf, PHPParserImplements, PHPParserImport, PHPParserInclude, PHPParserIncludeOnce, PHPParserInstanceOf, PHPParserInsteadOf, PHPParserInt8Cast, PHPParserInt16Cast, PHPParserInt64Type, PHPParserIntType, PHPParserInterface, PHPParserIsSet, PHPParserList, PHPParserLogicalAnd, PHPParserLogicalOr, PHPParserLogicalXor, PHPParserMatch_, PHPParserNamespace, PHPParserNew, PHPParserNull, PHPParserObjectType, PHPParserParent_, PHPParserPartial, PHPParserPrint, PHPParserPrivate, PHPParserProtected, PHPParserPublic, PHPParserReadonly, PHPParserRequire, PHPParserRequireOnce, PHPParserResource, PHPParserReturn, PHPParserStatic, PHPParserStringType, PHPParserSwitch, PHPParserThrow, PHPParserTrait, PHPParserTry, PHPParserTypeof, PHPParserUintCast, PHPParserUnicodeCast, PHPParserUnset, PHPParserUse, PHPParserVar, PHPParserWhile, PHPParserYield, PHPParserFrom, PHPParserLambdaFn, PHPParserTicks, PHPParserEncoding, PHPParserStrictTypes, PHPParserGet, PHPParserSet, PHPParserCall, PHPParserCallStatic, PHPParserConstructor, PHPParserDestruct, PHPParserWakeup, PHPParserSleep, PHPParserAutoload, PHPParserIsSet__, PHPParserUnset__, PHPParserToString__, PHPParserInvoke, PHPParserSetState, PHPParserClone__, PHPParserDebugInfo, PHPParserNamespace__, PHPParserClass__, PHPParserTraic__, PHPParserFunction__, PHPParserMethod__, PHPParserLine__, PHPParserFile__, PHPParserDir__, PHPParserOpenCurlyBracket, PHPParserLabel:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1868)
			p.KeyedSimpleFieldName()
		}

	case PHPParserDollar, PHPParserVarName:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1869)
			p.KeyedVariable()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IKeyedSimpleFieldNameContext is an interface to support dynamic dispatch.
type IKeyedSimpleFieldNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsKeyedSimpleFieldNameContext differentiates from other interfaces.
	IsKeyedSimpleFieldNameContext()
}

type KeyedSimpleFieldNameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKeyedSimpleFieldNameContext() *KeyedSimpleFieldNameContext {
	var p = new(KeyedSimpleFieldNameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PHPParserRULE_keyedSimpleFieldName
	return p
}

func (*KeyedSimpleFieldNameContext) IsKeyedSimpleFieldNameContext() {}

func NewKeyedSimpleFieldNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *KeyedSimpleFieldNameContext {
	var p = new(KeyedSimpleFieldNameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PHPParserRULE_keyedSimpleFieldName

	return p
}

func (s *KeyedSimpleFieldNameContext) GetParser() antlr.Parser { return s.parser }

func (s *KeyedSimpleFieldNameContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *KeyedSimpleFieldNameContext) OpenCurlyBracket() antlr.TerminalNode {
	return s.GetToken(PHPParserOpenCurlyBracket, 0)
}

func (s *KeyedSimpleFieldNameContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *KeyedSimpleFieldNameContext) CloseCurlyBracket() antlr.TerminalNode {
	return s.GetToken(PHPParserCloseCurlyBracket, 0)
}

func (s *KeyedSimpleFieldNameContext) AllSquareCurlyExpression() []ISquareCurlyExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISquareCurlyExpressionContext); ok {
			len++
		}
	}

	tst := make([]ISquareCurlyExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISquareCurlyExpressionContext); ok {
			tst[i] = t.(ISquareCurlyExpressionContext)
			i++
		}
	}

	return tst
}

func (s *KeyedSimpleFieldNameContext) SquareCurlyExpression(i int) ISquareCurlyExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISquareCurlyExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISquareCurlyExpressionContext)
}

func (s *KeyedSimpleFieldNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KeyedSimpleFieldNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *KeyedSimpleFieldNameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PHPParserVisitor:
		return t.VisitKeyedSimpleFieldName(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PHPParser) KeyedSimpleFieldName() (localctx IKeyedSimpleFieldNameContext) {
	this := p
	_ = this

	localctx = NewKeyedSimpleFieldNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 254, PHPParserRULE_keyedSimpleFieldName)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1877)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case PHPParserAbstract, PHPParserArray, PHPParserAs, PHPParserBinaryCast, PHPParserBoolType, PHPParserBooleanConstant, PHPParserBreak, PHPParserCallable, PHPParserCase, PHPParserCatch, PHPParserClass, PHPParserClone, PHPParserConst, PHPParserContinue, PHPParserDeclare, PHPParserDefault, PHPParserDo, PHPParserDoubleCast, PHPParserDoubleType, PHPParserEcho, PHPParserElse, PHPParserElseIf, PHPParserEmpty, PHPParserEnum_, PHPParserEndDeclare, PHPParserEndFor, PHPParserEndForeach, PHPParserEndIf, PHPParserEndSwitch, PHPParserEndWhile, PHPParserEval, PHPParserExit, PHPParserExtends, PHPParserFinal, PHPParserFinally, PHPParserFloatCast, PHPParserFor, PHPParserForeach, PHPParserFunction_, PHPParserGlobal, PHPParserGoto, PHPParserIf, PHPParserImplements, PHPParserImport, PHPParserInclude, PHPParserIncludeOnce, PHPParserInstanceOf, PHPParserInsteadOf, PHPParserInt8Cast, PHPParserInt16Cast, PHPParserInt64Type, PHPParserIntType, PHPParserInterface, PHPParserIsSet, PHPParserList, PHPParserLogicalAnd, PHPParserLogicalOr, PHPParserLogicalXor, PHPParserMatch_, PHPParserNamespace, PHPParserNew, PHPParserNull, PHPParserObjectType, PHPParserParent_, PHPParserPartial, PHPParserPrint, PHPParserPrivate, PHPParserProtected, PHPParserPublic, PHPParserReadonly, PHPParserRequire, PHPParserRequireOnce, PHPParserResource, PHPParserReturn, PHPParserStatic, PHPParserStringType, PHPParserSwitch, PHPParserThrow, PHPParserTrait, PHPParserTry, PHPParserTypeof, PHPParserUintCast, PHPParserUnicodeCast, PHPParserUnset, PHPParserUse, PHPParserVar, PHPParserWhile, PHPParserYield, PHPParserFrom, PHPParserLambdaFn, PHPParserTicks, PHPParserEncoding, PHPParserStrictTypes, PHPParserGet, PHPParserSet, PHPParserCall, PHPParserCallStatic, PHPParserConstructor, PHPParserDestruct, PHPParserWakeup, PHPParserSleep, PHPParserAutoload, PHPParserIsSet__, PHPParserUnset__, PHPParserToString__, PHPParserInvoke, PHPParserSetState, PHPParserClone__, PHPParserDebugInfo, PHPParserNamespace__, PHPParserClass__, PHPParserTraic__, PHPParserFunction__, PHPParserMethod__, PHPParserLine__, PHPParserFile__, PHPParserDir__, PHPParserLabel:
		{
			p.SetState(1872)
			p.Identifier()
		}

	case PHPParserOpenCurlyBracket:
		{
			p.SetState(1873)
			p.Match(PHPParserOpenCurlyBracket)
		}
		{
			p.SetState(1874)
			p.expression(0)
		}
		{
			p.SetState(1875)
			p.Match(PHPParserCloseCurlyBracket)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}
	p.SetState(1882)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 242, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1879)
				p.SquareCurlyExpression()
			}

		}
		p.SetState(1884)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 242, p.GetParserRuleContext())
	}

	return localctx
}

// IKeyedVariableContext is an interface to support dynamic dispatch.
type IKeyedVariableContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsKeyedVariableContext differentiates from other interfaces.
	IsKeyedVariableContext()
}

type KeyedVariableContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKeyedVariableContext() *KeyedVariableContext {
	var p = new(KeyedVariableContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PHPParserRULE_keyedVariable
	return p
}

func (*KeyedVariableContext) IsKeyedVariableContext() {}

func NewKeyedVariableContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *KeyedVariableContext {
	var p = new(KeyedVariableContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PHPParserRULE_keyedVariable

	return p
}

func (s *KeyedVariableContext) GetParser() antlr.Parser { return s.parser }

func (s *KeyedVariableContext) VarName() antlr.TerminalNode {
	return s.GetToken(PHPParserVarName, 0)
}

func (s *KeyedVariableContext) AllDollar() []antlr.TerminalNode {
	return s.GetTokens(PHPParserDollar)
}

func (s *KeyedVariableContext) Dollar(i int) antlr.TerminalNode {
	return s.GetToken(PHPParserDollar, i)
}

func (s *KeyedVariableContext) OpenCurlyBracket() antlr.TerminalNode {
	return s.GetToken(PHPParserOpenCurlyBracket, 0)
}

func (s *KeyedVariableContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *KeyedVariableContext) CloseCurlyBracket() antlr.TerminalNode {
	return s.GetToken(PHPParserCloseCurlyBracket, 0)
}

func (s *KeyedVariableContext) AllSquareCurlyExpression() []ISquareCurlyExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISquareCurlyExpressionContext); ok {
			len++
		}
	}

	tst := make([]ISquareCurlyExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISquareCurlyExpressionContext); ok {
			tst[i] = t.(ISquareCurlyExpressionContext)
			i++
		}
	}

	return tst
}

func (s *KeyedVariableContext) SquareCurlyExpression(i int) ISquareCurlyExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISquareCurlyExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISquareCurlyExpressionContext)
}

func (s *KeyedVariableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KeyedVariableContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *KeyedVariableContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PHPParserVisitor:
		return t.VisitKeyedVariable(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PHPParser) KeyedVariable() (localctx IKeyedVariableContext) {
	this := p
	_ = this

	localctx = NewKeyedVariableContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 256, PHPParserRULE_keyedVariable)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1888)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 243, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1885)
				p.Match(PHPParserDollar)
			}

		}
		p.SetState(1890)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 243, p.GetParserRuleContext())
	}
	p.SetState(1897)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case PHPParserVarName:
		{
			p.SetState(1891)
			p.Match(PHPParserVarName)
		}

	case PHPParserDollar:
		{
			p.SetState(1892)
			p.Match(PHPParserDollar)
		}
		{
			p.SetState(1893)
			p.Match(PHPParserOpenCurlyBracket)
		}
		{
			p.SetState(1894)
			p.expression(0)
		}
		{
			p.SetState(1895)
			p.Match(PHPParserCloseCurlyBracket)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}
	p.SetState(1902)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 245, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1899)
				p.SquareCurlyExpression()
			}

		}
		p.SetState(1904)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 245, p.GetParserRuleContext())
	}

	return localctx
}

// ISquareCurlyExpressionContext is an interface to support dynamic dispatch.
type ISquareCurlyExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSquareCurlyExpressionContext differentiates from other interfaces.
	IsSquareCurlyExpressionContext()
}

type SquareCurlyExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySquareCurlyExpressionContext() *SquareCurlyExpressionContext {
	var p = new(SquareCurlyExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PHPParserRULE_squareCurlyExpression
	return p
}

func (*SquareCurlyExpressionContext) IsSquareCurlyExpressionContext() {}

func NewSquareCurlyExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SquareCurlyExpressionContext {
	var p = new(SquareCurlyExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PHPParserRULE_squareCurlyExpression

	return p
}

func (s *SquareCurlyExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *SquareCurlyExpressionContext) OpenSquareBracket() antlr.TerminalNode {
	return s.GetToken(PHPParserOpenSquareBracket, 0)
}

func (s *SquareCurlyExpressionContext) CloseSquareBracket() antlr.TerminalNode {
	return s.GetToken(PHPParserCloseSquareBracket, 0)
}

func (s *SquareCurlyExpressionContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *SquareCurlyExpressionContext) OpenCurlyBracket() antlr.TerminalNode {
	return s.GetToken(PHPParserOpenCurlyBracket, 0)
}

func (s *SquareCurlyExpressionContext) CloseCurlyBracket() antlr.TerminalNode {
	return s.GetToken(PHPParserCloseCurlyBracket, 0)
}

func (s *SquareCurlyExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SquareCurlyExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SquareCurlyExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PHPParserVisitor:
		return t.VisitSquareCurlyExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PHPParser) SquareCurlyExpression() (localctx ISquareCurlyExpressionContext) {
	this := p
	_ = this

	localctx = NewSquareCurlyExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 258, PHPParserRULE_squareCurlyExpression)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1914)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case PHPParserOpenSquareBracket:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1905)
			p.Match(PHPParserOpenSquareBracket)
		}
		p.SetState(1907)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if (int64((_la-44)) & ^0x3f) == 0 && ((int64(1)<<(_la-44))&-1) != 0 || (int64((_la-108)) & ^0x3f) == 0 && ((int64(1)<<(_la-108))&441352763482308607) != 0 || (int64((_la-194)) & ^0x3f) == 0 && ((int64(1)<<(_la-194))&4396974138177) != 0 {
			{
				p.SetState(1906)
				p.expression(0)
			}

		}
		{
			p.SetState(1909)
			p.Match(PHPParserCloseSquareBracket)
		}

	case PHPParserOpenCurlyBracket:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1910)
			p.Match(PHPParserOpenCurlyBracket)
		}
		{
			p.SetState(1911)
			p.expression(0)
		}
		{
			p.SetState(1912)
			p.Match(PHPParserCloseCurlyBracket)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IAssignmentListContext is an interface to support dynamic dispatch.
type IAssignmentListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAssignmentListContext differentiates from other interfaces.
	IsAssignmentListContext()
}

type AssignmentListContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAssignmentListContext() *AssignmentListContext {
	var p = new(AssignmentListContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PHPParserRULE_assignmentList
	return p
}

func (*AssignmentListContext) IsAssignmentListContext() {}

func NewAssignmentListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AssignmentListContext {
	var p = new(AssignmentListContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PHPParserRULE_assignmentList

	return p
}

func (s *AssignmentListContext) GetParser() antlr.Parser { return s.parser }

func (s *AssignmentListContext) AllAssignmentListElement() []IAssignmentListElementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAssignmentListElementContext); ok {
			len++
		}
	}

	tst := make([]IAssignmentListElementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAssignmentListElementContext); ok {
			tst[i] = t.(IAssignmentListElementContext)
			i++
		}
	}

	return tst
}

func (s *AssignmentListContext) AssignmentListElement(i int) IAssignmentListElementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAssignmentListElementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAssignmentListElementContext)
}

func (s *AssignmentListContext) AllComma() []antlr.TerminalNode {
	return s.GetTokens(PHPParserComma)
}

func (s *AssignmentListContext) Comma(i int) antlr.TerminalNode {
	return s.GetToken(PHPParserComma, i)
}

func (s *AssignmentListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AssignmentListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AssignmentListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PHPParserVisitor:
		return t.VisitAssignmentList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PHPParser) AssignmentList() (localctx IAssignmentListContext) {
	this := p
	_ = this

	localctx = NewAssignmentListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 260, PHPParserRULE_assignmentList)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1917)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if (int64((_la-44)) & ^0x3f) == 0 && ((int64(1)<<(_la-44))&-1) != 0 || (int64((_la-108)) & ^0x3f) == 0 && ((int64(1)<<(_la-108))&441352763482308607) != 0 || (int64((_la-194)) & ^0x3f) == 0 && ((int64(1)<<(_la-194))&4396974138193) != 0 {
		{
			p.SetState(1916)
			p.AssignmentListElement()
		}

	}
	p.SetState(1925)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == PHPParserComma {
		{
			p.SetState(1919)
			p.Match(PHPParserComma)
		}
		p.SetState(1921)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if (int64((_la-44)) & ^0x3f) == 0 && ((int64(1)<<(_la-44))&-1) != 0 || (int64((_la-108)) & ^0x3f) == 0 && ((int64(1)<<(_la-108))&441352763482308607) != 0 || (int64((_la-194)) & ^0x3f) == 0 && ((int64(1)<<(_la-194))&4396974138193) != 0 {
			{
				p.SetState(1920)
				p.AssignmentListElement()
			}

		}

		p.SetState(1927)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IAssignmentListElementContext is an interface to support dynamic dispatch.
type IAssignmentListElementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAssignmentListElementContext differentiates from other interfaces.
	IsAssignmentListElementContext()
}

type AssignmentListElementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAssignmentListElementContext() *AssignmentListElementContext {
	var p = new(AssignmentListElementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PHPParserRULE_assignmentListElement
	return p
}

func (*AssignmentListElementContext) IsAssignmentListElementContext() {}

func NewAssignmentListElementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AssignmentListElementContext {
	var p = new(AssignmentListElementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PHPParserRULE_assignmentListElement

	return p
}

func (s *AssignmentListElementContext) GetParser() antlr.Parser { return s.parser }

func (s *AssignmentListElementContext) Chain() IChainContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IChainContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IChainContext)
}

func (s *AssignmentListElementContext) List() antlr.TerminalNode {
	return s.GetToken(PHPParserList, 0)
}

func (s *AssignmentListElementContext) OpenRoundBracket() antlr.TerminalNode {
	return s.GetToken(PHPParserOpenRoundBracket, 0)
}

func (s *AssignmentListElementContext) AssignmentList() IAssignmentListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAssignmentListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAssignmentListContext)
}

func (s *AssignmentListElementContext) CloseRoundBracket() antlr.TerminalNode {
	return s.GetToken(PHPParserCloseRoundBracket, 0)
}

func (s *AssignmentListElementContext) ArrayItem() IArrayItemContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArrayItemContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArrayItemContext)
}

func (s *AssignmentListElementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AssignmentListElementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AssignmentListElementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PHPParserVisitor:
		return t.VisitAssignmentListElement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PHPParser) AssignmentListElement() (localctx IAssignmentListElementContext) {
	this := p
	_ = this

	localctx = NewAssignmentListElementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 262, PHPParserRULE_assignmentListElement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1935)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 251, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1928)
			p.Chain()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1929)
			p.Match(PHPParserList)
		}
		{
			p.SetState(1930)
			p.Match(PHPParserOpenRoundBracket)
		}
		{
			p.SetState(1931)
			p.AssignmentList()
		}
		{
			p.SetState(1932)
			p.Match(PHPParserCloseRoundBracket)
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1934)
			p.ArrayItem()
		}

	}

	return localctx
}

// IModifierContext is an interface to support dynamic dispatch.
type IModifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsModifierContext differentiates from other interfaces.
	IsModifierContext()
}

type ModifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyModifierContext() *ModifierContext {
	var p = new(ModifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PHPParserRULE_modifier
	return p
}

func (*ModifierContext) IsModifierContext() {}

func NewModifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ModifierContext {
	var p = new(ModifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PHPParserRULE_modifier

	return p
}

func (s *ModifierContext) GetParser() antlr.Parser { return s.parser }

func (s *ModifierContext) Abstract() antlr.TerminalNode {
	return s.GetToken(PHPParserAbstract, 0)
}

func (s *ModifierContext) Final() antlr.TerminalNode {
	return s.GetToken(PHPParserFinal, 0)
}

func (s *ModifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ModifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ModifierContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PHPParserVisitor:
		return t.VisitModifier(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PHPParser) Modifier() (localctx IModifierContext) {
	this := p
	_ = this

	localctx = NewModifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 264, PHPParserRULE_modifier)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1937)
		_la = p.GetTokenStream().LA(1)

		if !(_la == PHPParserAbstract || _la == PHPParserFinal) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IIdentifierContext is an interface to support dynamic dispatch.
type IIdentifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsIdentifierContext differentiates from other interfaces.
	IsIdentifierContext()
}

type IdentifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIdentifierContext() *IdentifierContext {
	var p = new(IdentifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PHPParserRULE_identifier
	return p
}

func (*IdentifierContext) IsIdentifierContext() {}

func NewIdentifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IdentifierContext {
	var p = new(IdentifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PHPParserRULE_identifier

	return p
}

func (s *IdentifierContext) GetParser() antlr.Parser { return s.parser }

func (s *IdentifierContext) Label() antlr.TerminalNode {
	return s.GetToken(PHPParserLabel, 0)
}

func (s *IdentifierContext) Abstract() antlr.TerminalNode {
	return s.GetToken(PHPParserAbstract, 0)
}

func (s *IdentifierContext) Array() antlr.TerminalNode {
	return s.GetToken(PHPParserArray, 0)
}

func (s *IdentifierContext) As() antlr.TerminalNode {
	return s.GetToken(PHPParserAs, 0)
}

func (s *IdentifierContext) BinaryCast() antlr.TerminalNode {
	return s.GetToken(PHPParserBinaryCast, 0)
}

func (s *IdentifierContext) BoolType() antlr.TerminalNode {
	return s.GetToken(PHPParserBoolType, 0)
}

func (s *IdentifierContext) BooleanConstant() antlr.TerminalNode {
	return s.GetToken(PHPParserBooleanConstant, 0)
}

func (s *IdentifierContext) Break() antlr.TerminalNode {
	return s.GetToken(PHPParserBreak, 0)
}

func (s *IdentifierContext) Callable() antlr.TerminalNode {
	return s.GetToken(PHPParserCallable, 0)
}

func (s *IdentifierContext) Case() antlr.TerminalNode {
	return s.GetToken(PHPParserCase, 0)
}

func (s *IdentifierContext) Catch() antlr.TerminalNode {
	return s.GetToken(PHPParserCatch, 0)
}

func (s *IdentifierContext) Class() antlr.TerminalNode {
	return s.GetToken(PHPParserClass, 0)
}

func (s *IdentifierContext) Clone() antlr.TerminalNode {
	return s.GetToken(PHPParserClone, 0)
}

func (s *IdentifierContext) Const() antlr.TerminalNode {
	return s.GetToken(PHPParserConst, 0)
}

func (s *IdentifierContext) Continue() antlr.TerminalNode {
	return s.GetToken(PHPParserContinue, 0)
}

func (s *IdentifierContext) Declare() antlr.TerminalNode {
	return s.GetToken(PHPParserDeclare, 0)
}

func (s *IdentifierContext) Default() antlr.TerminalNode {
	return s.GetToken(PHPParserDefault, 0)
}

func (s *IdentifierContext) Do() antlr.TerminalNode {
	return s.GetToken(PHPParserDo, 0)
}

func (s *IdentifierContext) DoubleCast() antlr.TerminalNode {
	return s.GetToken(PHPParserDoubleCast, 0)
}

func (s *IdentifierContext) DoubleType() antlr.TerminalNode {
	return s.GetToken(PHPParserDoubleType, 0)
}

func (s *IdentifierContext) Echo() antlr.TerminalNode {
	return s.GetToken(PHPParserEcho, 0)
}

func (s *IdentifierContext) Else() antlr.TerminalNode {
	return s.GetToken(PHPParserElse, 0)
}

func (s *IdentifierContext) ElseIf() antlr.TerminalNode {
	return s.GetToken(PHPParserElseIf, 0)
}

func (s *IdentifierContext) Empty() antlr.TerminalNode {
	return s.GetToken(PHPParserEmpty, 0)
}

func (s *IdentifierContext) EndDeclare() antlr.TerminalNode {
	return s.GetToken(PHPParserEndDeclare, 0)
}

func (s *IdentifierContext) EndFor() antlr.TerminalNode {
	return s.GetToken(PHPParserEndFor, 0)
}

func (s *IdentifierContext) EndForeach() antlr.TerminalNode {
	return s.GetToken(PHPParserEndForeach, 0)
}

func (s *IdentifierContext) EndIf() antlr.TerminalNode {
	return s.GetToken(PHPParserEndIf, 0)
}

func (s *IdentifierContext) EndSwitch() antlr.TerminalNode {
	return s.GetToken(PHPParserEndSwitch, 0)
}

func (s *IdentifierContext) EndWhile() antlr.TerminalNode {
	return s.GetToken(PHPParserEndWhile, 0)
}

func (s *IdentifierContext) Eval() antlr.TerminalNode {
	return s.GetToken(PHPParserEval, 0)
}

func (s *IdentifierContext) Exit() antlr.TerminalNode {
	return s.GetToken(PHPParserExit, 0)
}

func (s *IdentifierContext) Extends() antlr.TerminalNode {
	return s.GetToken(PHPParserExtends, 0)
}

func (s *IdentifierContext) Final() antlr.TerminalNode {
	return s.GetToken(PHPParserFinal, 0)
}

func (s *IdentifierContext) Finally() antlr.TerminalNode {
	return s.GetToken(PHPParserFinally, 0)
}

func (s *IdentifierContext) FloatCast() antlr.TerminalNode {
	return s.GetToken(PHPParserFloatCast, 0)
}

func (s *IdentifierContext) For() antlr.TerminalNode {
	return s.GetToken(PHPParserFor, 0)
}

func (s *IdentifierContext) Foreach() antlr.TerminalNode {
	return s.GetToken(PHPParserForeach, 0)
}

func (s *IdentifierContext) Function_() antlr.TerminalNode {
	return s.GetToken(PHPParserFunction_, 0)
}

func (s *IdentifierContext) Global() antlr.TerminalNode {
	return s.GetToken(PHPParserGlobal, 0)
}

func (s *IdentifierContext) Goto() antlr.TerminalNode {
	return s.GetToken(PHPParserGoto, 0)
}

func (s *IdentifierContext) If() antlr.TerminalNode {
	return s.GetToken(PHPParserIf, 0)
}

func (s *IdentifierContext) Implements() antlr.TerminalNode {
	return s.GetToken(PHPParserImplements, 0)
}

func (s *IdentifierContext) Import() antlr.TerminalNode {
	return s.GetToken(PHPParserImport, 0)
}

func (s *IdentifierContext) Include() antlr.TerminalNode {
	return s.GetToken(PHPParserInclude, 0)
}

func (s *IdentifierContext) IncludeOnce() antlr.TerminalNode {
	return s.GetToken(PHPParserIncludeOnce, 0)
}

func (s *IdentifierContext) InstanceOf() antlr.TerminalNode {
	return s.GetToken(PHPParserInstanceOf, 0)
}

func (s *IdentifierContext) InsteadOf() antlr.TerminalNode {
	return s.GetToken(PHPParserInsteadOf, 0)
}

func (s *IdentifierContext) Int16Cast() antlr.TerminalNode {
	return s.GetToken(PHPParserInt16Cast, 0)
}

func (s *IdentifierContext) Int64Type() antlr.TerminalNode {
	return s.GetToken(PHPParserInt64Type, 0)
}

func (s *IdentifierContext) Int8Cast() antlr.TerminalNode {
	return s.GetToken(PHPParserInt8Cast, 0)
}

func (s *IdentifierContext) Interface() antlr.TerminalNode {
	return s.GetToken(PHPParserInterface, 0)
}

func (s *IdentifierContext) IntType() antlr.TerminalNode {
	return s.GetToken(PHPParserIntType, 0)
}

func (s *IdentifierContext) IsSet() antlr.TerminalNode {
	return s.GetToken(PHPParserIsSet, 0)
}

func (s *IdentifierContext) LambdaFn() antlr.TerminalNode {
	return s.GetToken(PHPParserLambdaFn, 0)
}

func (s *IdentifierContext) List() antlr.TerminalNode {
	return s.GetToken(PHPParserList, 0)
}

func (s *IdentifierContext) LogicalAnd() antlr.TerminalNode {
	return s.GetToken(PHPParserLogicalAnd, 0)
}

func (s *IdentifierContext) LogicalOr() antlr.TerminalNode {
	return s.GetToken(PHPParserLogicalOr, 0)
}

func (s *IdentifierContext) LogicalXor() antlr.TerminalNode {
	return s.GetToken(PHPParserLogicalXor, 0)
}

func (s *IdentifierContext) Namespace() antlr.TerminalNode {
	return s.GetToken(PHPParserNamespace, 0)
}

func (s *IdentifierContext) New() antlr.TerminalNode {
	return s.GetToken(PHPParserNew, 0)
}

func (s *IdentifierContext) Null() antlr.TerminalNode {
	return s.GetToken(PHPParserNull, 0)
}

func (s *IdentifierContext) ObjectType() antlr.TerminalNode {
	return s.GetToken(PHPParserObjectType, 0)
}

func (s *IdentifierContext) Parent_() antlr.TerminalNode {
	return s.GetToken(PHPParserParent_, 0)
}

func (s *IdentifierContext) Partial() antlr.TerminalNode {
	return s.GetToken(PHPParserPartial, 0)
}

func (s *IdentifierContext) Print() antlr.TerminalNode {
	return s.GetToken(PHPParserPrint, 0)
}

func (s *IdentifierContext) Private() antlr.TerminalNode {
	return s.GetToken(PHPParserPrivate, 0)
}

func (s *IdentifierContext) Protected() antlr.TerminalNode {
	return s.GetToken(PHPParserProtected, 0)
}

func (s *IdentifierContext) Public() antlr.TerminalNode {
	return s.GetToken(PHPParserPublic, 0)
}

func (s *IdentifierContext) Readonly() antlr.TerminalNode {
	return s.GetToken(PHPParserReadonly, 0)
}

func (s *IdentifierContext) Require() antlr.TerminalNode {
	return s.GetToken(PHPParserRequire, 0)
}

func (s *IdentifierContext) RequireOnce() antlr.TerminalNode {
	return s.GetToken(PHPParserRequireOnce, 0)
}

func (s *IdentifierContext) Resource() antlr.TerminalNode {
	return s.GetToken(PHPParserResource, 0)
}

func (s *IdentifierContext) Return() antlr.TerminalNode {
	return s.GetToken(PHPParserReturn, 0)
}

func (s *IdentifierContext) Static() antlr.TerminalNode {
	return s.GetToken(PHPParserStatic, 0)
}

func (s *IdentifierContext) StringType() antlr.TerminalNode {
	return s.GetToken(PHPParserStringType, 0)
}

func (s *IdentifierContext) Switch() antlr.TerminalNode {
	return s.GetToken(PHPParserSwitch, 0)
}

func (s *IdentifierContext) Throw() antlr.TerminalNode {
	return s.GetToken(PHPParserThrow, 0)
}

func (s *IdentifierContext) Trait() antlr.TerminalNode {
	return s.GetToken(PHPParserTrait, 0)
}

func (s *IdentifierContext) Try() antlr.TerminalNode {
	return s.GetToken(PHPParserTry, 0)
}

func (s *IdentifierContext) Typeof() antlr.TerminalNode {
	return s.GetToken(PHPParserTypeof, 0)
}

func (s *IdentifierContext) UintCast() antlr.TerminalNode {
	return s.GetToken(PHPParserUintCast, 0)
}

func (s *IdentifierContext) UnicodeCast() antlr.TerminalNode {
	return s.GetToken(PHPParserUnicodeCast, 0)
}

func (s *IdentifierContext) Unset() antlr.TerminalNode {
	return s.GetToken(PHPParserUnset, 0)
}

func (s *IdentifierContext) Use() antlr.TerminalNode {
	return s.GetToken(PHPParserUse, 0)
}

func (s *IdentifierContext) Var() antlr.TerminalNode {
	return s.GetToken(PHPParserVar, 0)
}

func (s *IdentifierContext) While() antlr.TerminalNode {
	return s.GetToken(PHPParserWhile, 0)
}

func (s *IdentifierContext) Yield() antlr.TerminalNode {
	return s.GetToken(PHPParserYield, 0)
}

func (s *IdentifierContext) From() antlr.TerminalNode {
	return s.GetToken(PHPParserFrom, 0)
}

func (s *IdentifierContext) Enum_() antlr.TerminalNode {
	return s.GetToken(PHPParserEnum_, 0)
}

func (s *IdentifierContext) Match_() antlr.TerminalNode {
	return s.GetToken(PHPParserMatch_, 0)
}

func (s *IdentifierContext) Ticks() antlr.TerminalNode {
	return s.GetToken(PHPParserTicks, 0)
}

func (s *IdentifierContext) Encoding() antlr.TerminalNode {
	return s.GetToken(PHPParserEncoding, 0)
}

func (s *IdentifierContext) StrictTypes() antlr.TerminalNode {
	return s.GetToken(PHPParserStrictTypes, 0)
}

func (s *IdentifierContext) Get() antlr.TerminalNode {
	return s.GetToken(PHPParserGet, 0)
}

func (s *IdentifierContext) Set() antlr.TerminalNode {
	return s.GetToken(PHPParserSet, 0)
}

func (s *IdentifierContext) Call() antlr.TerminalNode {
	return s.GetToken(PHPParserCall, 0)
}

func (s *IdentifierContext) CallStatic() antlr.TerminalNode {
	return s.GetToken(PHPParserCallStatic, 0)
}

func (s *IdentifierContext) Constructor() antlr.TerminalNode {
	return s.GetToken(PHPParserConstructor, 0)
}

func (s *IdentifierContext) Destruct() antlr.TerminalNode {
	return s.GetToken(PHPParserDestruct, 0)
}

func (s *IdentifierContext) Wakeup() antlr.TerminalNode {
	return s.GetToken(PHPParserWakeup, 0)
}

func (s *IdentifierContext) Sleep() antlr.TerminalNode {
	return s.GetToken(PHPParserSleep, 0)
}

func (s *IdentifierContext) Autoload() antlr.TerminalNode {
	return s.GetToken(PHPParserAutoload, 0)
}

func (s *IdentifierContext) IsSet__() antlr.TerminalNode {
	return s.GetToken(PHPParserIsSet__, 0)
}

func (s *IdentifierContext) Unset__() antlr.TerminalNode {
	return s.GetToken(PHPParserUnset__, 0)
}

func (s *IdentifierContext) ToString__() antlr.TerminalNode {
	return s.GetToken(PHPParserToString__, 0)
}

func (s *IdentifierContext) Invoke() antlr.TerminalNode {
	return s.GetToken(PHPParserInvoke, 0)
}

func (s *IdentifierContext) SetState() antlr.TerminalNode {
	return s.GetToken(PHPParserSetState, 0)
}

func (s *IdentifierContext) Clone__() antlr.TerminalNode {
	return s.GetToken(PHPParserClone__, 0)
}

func (s *IdentifierContext) DebugInfo() antlr.TerminalNode {
	return s.GetToken(PHPParserDebugInfo, 0)
}

func (s *IdentifierContext) Namespace__() antlr.TerminalNode {
	return s.GetToken(PHPParserNamespace__, 0)
}

func (s *IdentifierContext) Class__() antlr.TerminalNode {
	return s.GetToken(PHPParserClass__, 0)
}

func (s *IdentifierContext) Traic__() antlr.TerminalNode {
	return s.GetToken(PHPParserTraic__, 0)
}

func (s *IdentifierContext) Function__() antlr.TerminalNode {
	return s.GetToken(PHPParserFunction__, 0)
}

func (s *IdentifierContext) Method__() antlr.TerminalNode {
	return s.GetToken(PHPParserMethod__, 0)
}

func (s *IdentifierContext) Line__() antlr.TerminalNode {
	return s.GetToken(PHPParserLine__, 0)
}

func (s *IdentifierContext) File__() antlr.TerminalNode {
	return s.GetToken(PHPParserFile__, 0)
}

func (s *IdentifierContext) Dir__() antlr.TerminalNode {
	return s.GetToken(PHPParserDir__, 0)
}

func (s *IdentifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IdentifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IdentifierContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PHPParserVisitor:
		return t.VisitIdentifier(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PHPParser) Identifier() (localctx IIdentifierContext) {
	this := p
	_ = this

	localctx = NewIdentifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 266, PHPParserRULE_identifier)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1939)
		_la = p.GetTokenStream().LA(1)

		if !((int64((_la-44)) & ^0x3f) == 0 && ((int64(1)<<(_la-44))&-1) != 0 || (int64((_la-108)) & ^0x3f) == 0 && ((int64(1)<<(_la-108))&9007199254740991) != 0 || _la == PHPParserLabel) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IMemberModifierContext is an interface to support dynamic dispatch.
type IMemberModifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMemberModifierContext differentiates from other interfaces.
	IsMemberModifierContext()
}

type MemberModifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMemberModifierContext() *MemberModifierContext {
	var p = new(MemberModifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PHPParserRULE_memberModifier
	return p
}

func (*MemberModifierContext) IsMemberModifierContext() {}

func NewMemberModifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MemberModifierContext {
	var p = new(MemberModifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PHPParserRULE_memberModifier

	return p
}

func (s *MemberModifierContext) GetParser() antlr.Parser { return s.parser }

func (s *MemberModifierContext) Public() antlr.TerminalNode {
	return s.GetToken(PHPParserPublic, 0)
}

func (s *MemberModifierContext) Protected() antlr.TerminalNode {
	return s.GetToken(PHPParserProtected, 0)
}

func (s *MemberModifierContext) Private() antlr.TerminalNode {
	return s.GetToken(PHPParserPrivate, 0)
}

func (s *MemberModifierContext) Static() antlr.TerminalNode {
	return s.GetToken(PHPParserStatic, 0)
}

func (s *MemberModifierContext) Abstract() antlr.TerminalNode {
	return s.GetToken(PHPParserAbstract, 0)
}

func (s *MemberModifierContext) Final() antlr.TerminalNode {
	return s.GetToken(PHPParserFinal, 0)
}

func (s *MemberModifierContext) Readonly() antlr.TerminalNode {
	return s.GetToken(PHPParserReadonly, 0)
}

func (s *MemberModifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MemberModifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MemberModifierContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PHPParserVisitor:
		return t.VisitMemberModifier(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PHPParser) MemberModifier() (localctx IMemberModifierContext) {
	this := p
	_ = this

	localctx = NewMemberModifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 268, PHPParserRULE_memberModifier)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1941)
		_la = p.GetTokenStream().LA(1)

		if !(_la == PHPParserAbstract || (int64((_la-77)) & ^0x3f) == 0 && ((int64(1)<<(_la-77))&2327872274433) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IMagicConstantContext is an interface to support dynamic dispatch.
type IMagicConstantContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMagicConstantContext differentiates from other interfaces.
	IsMagicConstantContext()
}

type MagicConstantContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMagicConstantContext() *MagicConstantContext {
	var p = new(MagicConstantContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PHPParserRULE_magicConstant
	return p
}

func (*MagicConstantContext) IsMagicConstantContext() {}

func NewMagicConstantContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MagicConstantContext {
	var p = new(MagicConstantContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PHPParserRULE_magicConstant

	return p
}

func (s *MagicConstantContext) GetParser() antlr.Parser { return s.parser }

func (s *MagicConstantContext) Namespace__() antlr.TerminalNode {
	return s.GetToken(PHPParserNamespace__, 0)
}

func (s *MagicConstantContext) Class__() antlr.TerminalNode {
	return s.GetToken(PHPParserClass__, 0)
}

func (s *MagicConstantContext) Traic__() antlr.TerminalNode {
	return s.GetToken(PHPParserTraic__, 0)
}

func (s *MagicConstantContext) Function__() antlr.TerminalNode {
	return s.GetToken(PHPParserFunction__, 0)
}

func (s *MagicConstantContext) Method__() antlr.TerminalNode {
	return s.GetToken(PHPParserMethod__, 0)
}

func (s *MagicConstantContext) Line__() antlr.TerminalNode {
	return s.GetToken(PHPParserLine__, 0)
}

func (s *MagicConstantContext) File__() antlr.TerminalNode {
	return s.GetToken(PHPParserFile__, 0)
}

func (s *MagicConstantContext) Dir__() antlr.TerminalNode {
	return s.GetToken(PHPParserDir__, 0)
}

func (s *MagicConstantContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MagicConstantContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MagicConstantContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PHPParserVisitor:
		return t.VisitMagicConstant(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PHPParser) MagicConstant() (localctx IMagicConstantContext) {
	this := p
	_ = this

	localctx = NewMagicConstantContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 270, PHPParserRULE_magicConstant)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1943)
		_la = p.GetTokenStream().LA(1)

		if !((int64((_la-153)) & ^0x3f) == 0 && ((int64(1)<<(_la-153))&255) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IMagicMethodContext is an interface to support dynamic dispatch.
type IMagicMethodContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMagicMethodContext differentiates from other interfaces.
	IsMagicMethodContext()
}

type MagicMethodContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMagicMethodContext() *MagicMethodContext {
	var p = new(MagicMethodContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PHPParserRULE_magicMethod
	return p
}

func (*MagicMethodContext) IsMagicMethodContext() {}

func NewMagicMethodContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MagicMethodContext {
	var p = new(MagicMethodContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PHPParserRULE_magicMethod

	return p
}

func (s *MagicMethodContext) GetParser() antlr.Parser { return s.parser }

func (s *MagicMethodContext) Get() antlr.TerminalNode {
	return s.GetToken(PHPParserGet, 0)
}

func (s *MagicMethodContext) Set() antlr.TerminalNode {
	return s.GetToken(PHPParserSet, 0)
}

func (s *MagicMethodContext) Call() antlr.TerminalNode {
	return s.GetToken(PHPParserCall, 0)
}

func (s *MagicMethodContext) CallStatic() antlr.TerminalNode {
	return s.GetToken(PHPParserCallStatic, 0)
}

func (s *MagicMethodContext) Constructor() antlr.TerminalNode {
	return s.GetToken(PHPParserConstructor, 0)
}

func (s *MagicMethodContext) Destruct() antlr.TerminalNode {
	return s.GetToken(PHPParserDestruct, 0)
}

func (s *MagicMethodContext) Wakeup() antlr.TerminalNode {
	return s.GetToken(PHPParserWakeup, 0)
}

func (s *MagicMethodContext) Sleep() antlr.TerminalNode {
	return s.GetToken(PHPParserSleep, 0)
}

func (s *MagicMethodContext) Autoload() antlr.TerminalNode {
	return s.GetToken(PHPParserAutoload, 0)
}

func (s *MagicMethodContext) IsSet__() antlr.TerminalNode {
	return s.GetToken(PHPParserIsSet__, 0)
}

func (s *MagicMethodContext) Unset__() antlr.TerminalNode {
	return s.GetToken(PHPParserUnset__, 0)
}

func (s *MagicMethodContext) ToString__() antlr.TerminalNode {
	return s.GetToken(PHPParserToString__, 0)
}

func (s *MagicMethodContext) Invoke() antlr.TerminalNode {
	return s.GetToken(PHPParserInvoke, 0)
}

func (s *MagicMethodContext) SetState() antlr.TerminalNode {
	return s.GetToken(PHPParserSetState, 0)
}

func (s *MagicMethodContext) Clone__() antlr.TerminalNode {
	return s.GetToken(PHPParserClone__, 0)
}

func (s *MagicMethodContext) DebugInfo() antlr.TerminalNode {
	return s.GetToken(PHPParserDebugInfo, 0)
}

func (s *MagicMethodContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MagicMethodContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MagicMethodContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PHPParserVisitor:
		return t.VisitMagicMethod(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PHPParser) MagicMethod() (localctx IMagicMethodContext) {
	this := p
	_ = this

	localctx = NewMagicMethodContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 272, PHPParserRULE_magicMethod)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1945)
		_la = p.GetTokenStream().LA(1)

		if !((int64((_la-137)) & ^0x3f) == 0 && ((int64(1)<<(_la-137))&65535) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IPrimitiveTypeContext is an interface to support dynamic dispatch.
type IPrimitiveTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPrimitiveTypeContext differentiates from other interfaces.
	IsPrimitiveTypeContext()
}

type PrimitiveTypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPrimitiveTypeContext() *PrimitiveTypeContext {
	var p = new(PrimitiveTypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PHPParserRULE_primitiveType
	return p
}

func (*PrimitiveTypeContext) IsPrimitiveTypeContext() {}

func NewPrimitiveTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PrimitiveTypeContext {
	var p = new(PrimitiveTypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PHPParserRULE_primitiveType

	return p
}

func (s *PrimitiveTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *PrimitiveTypeContext) BoolType() antlr.TerminalNode {
	return s.GetToken(PHPParserBoolType, 0)
}

func (s *PrimitiveTypeContext) IntType() antlr.TerminalNode {
	return s.GetToken(PHPParserIntType, 0)
}

func (s *PrimitiveTypeContext) Int64Type() antlr.TerminalNode {
	return s.GetToken(PHPParserInt64Type, 0)
}

func (s *PrimitiveTypeContext) DoubleType() antlr.TerminalNode {
	return s.GetToken(PHPParserDoubleType, 0)
}

func (s *PrimitiveTypeContext) StringType() antlr.TerminalNode {
	return s.GetToken(PHPParserStringType, 0)
}

func (s *PrimitiveTypeContext) Resource() antlr.TerminalNode {
	return s.GetToken(PHPParserResource, 0)
}

func (s *PrimitiveTypeContext) ObjectType() antlr.TerminalNode {
	return s.GetToken(PHPParserObjectType, 0)
}

func (s *PrimitiveTypeContext) Array() antlr.TerminalNode {
	return s.GetToken(PHPParserArray, 0)
}

func (s *PrimitiveTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrimitiveTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PrimitiveTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PHPParserVisitor:
		return t.VisitPrimitiveType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PHPParser) PrimitiveType() (localctx IPrimitiveTypeContext) {
	this := p
	_ = this

	localctx = NewPrimitiveTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 274, PHPParserRULE_primitiveType)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1947)
		_la = p.GetTokenStream().LA(1)

		if !((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&4612002677776187392) != 0 || (int64((_la-94)) & ^0x3f) == 0 && ((int64(1)<<(_la-94))&37752835) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// ICastOperationContext is an interface to support dynamic dispatch.
type ICastOperationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCastOperationContext differentiates from other interfaces.
	IsCastOperationContext()
}

type CastOperationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCastOperationContext() *CastOperationContext {
	var p = new(CastOperationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PHPParserRULE_castOperation
	return p
}

func (*CastOperationContext) IsCastOperationContext() {}

func NewCastOperationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CastOperationContext {
	var p = new(CastOperationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PHPParserRULE_castOperation

	return p
}

func (s *CastOperationContext) GetParser() antlr.Parser { return s.parser }

func (s *CastOperationContext) BoolType() antlr.TerminalNode {
	return s.GetToken(PHPParserBoolType, 0)
}

func (s *CastOperationContext) Int8Cast() antlr.TerminalNode {
	return s.GetToken(PHPParserInt8Cast, 0)
}

func (s *CastOperationContext) Int16Cast() antlr.TerminalNode {
	return s.GetToken(PHPParserInt16Cast, 0)
}

func (s *CastOperationContext) IntType() antlr.TerminalNode {
	return s.GetToken(PHPParserIntType, 0)
}

func (s *CastOperationContext) Int64Type() antlr.TerminalNode {
	return s.GetToken(PHPParserInt64Type, 0)
}

func (s *CastOperationContext) UintCast() antlr.TerminalNode {
	return s.GetToken(PHPParserUintCast, 0)
}

func (s *CastOperationContext) DoubleCast() antlr.TerminalNode {
	return s.GetToken(PHPParserDoubleCast, 0)
}

func (s *CastOperationContext) DoubleType() antlr.TerminalNode {
	return s.GetToken(PHPParserDoubleType, 0)
}

func (s *CastOperationContext) FloatCast() antlr.TerminalNode {
	return s.GetToken(PHPParserFloatCast, 0)
}

func (s *CastOperationContext) StringType() antlr.TerminalNode {
	return s.GetToken(PHPParserStringType, 0)
}

func (s *CastOperationContext) BinaryCast() antlr.TerminalNode {
	return s.GetToken(PHPParserBinaryCast, 0)
}

func (s *CastOperationContext) UnicodeCast() antlr.TerminalNode {
	return s.GetToken(PHPParserUnicodeCast, 0)
}

func (s *CastOperationContext) Array() antlr.TerminalNode {
	return s.GetToken(PHPParserArray, 0)
}

func (s *CastOperationContext) ObjectType() antlr.TerminalNode {
	return s.GetToken(PHPParserObjectType, 0)
}

func (s *CastOperationContext) Resource() antlr.TerminalNode {
	return s.GetToken(PHPParserResource, 0)
}

func (s *CastOperationContext) Unset() antlr.TerminalNode {
	return s.GetToken(PHPParserUnset, 0)
}

func (s *CastOperationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CastOperationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CastOperationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PHPParserVisitor:
		return t.VisitCastOperation(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PHPParser) CastOperation() (localctx ICastOperationContext) {
	this := p
	_ = this

	localctx = NewCastOperationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 276, PHPParserRULE_castOperation)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1949)
		_la = p.GetTokenStream().LA(1)

		if !((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&6917986424478236672) != 0 || (int64((_la-79)) & ^0x3f) == 0 && ((int64(1)<<(_la-79))&493818294165505) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

func (p *PHPParser) Sempred(localctx antlr.RuleContext, ruleIndex, predIndex int) bool {
	switch ruleIndex {
	case 60:
		var t *TypeHintContext = nil
		if localctx != nil {
			t = localctx.(*TypeHintContext)
		}
		return p.TypeHint_Sempred(t, predIndex)

	case 83:
		var t *ExpressionContext = nil
		if localctx != nil {
			t = localctx.(*ExpressionContext)
		}
		return p.Expression_Sempred(t, predIndex)

	default:
		panic("No predicate with index: " + fmt.Sprint(ruleIndex))
	}
}

func (p *PHPParser) TypeHint_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	this := p
	_ = this

	switch predIndex {
	case 0:
		return p.Precpred(p.GetParserRuleContext(), 1)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *PHPParser) Expression_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	this := p
	_ = this

	switch predIndex {
	case 1:
		return p.Precpred(p.GetParserRuleContext(), 22)

	case 2:
		return p.Precpred(p.GetParserRuleContext(), 20)

	case 3:
		return p.Precpred(p.GetParserRuleContext(), 19)

	case 4:
		return p.Precpred(p.GetParserRuleContext(), 18)

	case 5:
		return p.Precpred(p.GetParserRuleContext(), 17)

	case 6:
		return p.Precpred(p.GetParserRuleContext(), 16)

	case 7:
		return p.Precpred(p.GetParserRuleContext(), 15)

	case 8:
		return p.Precpred(p.GetParserRuleContext(), 14)

	case 9:
		return p.Precpred(p.GetParserRuleContext(), 13)

	case 10:
		return p.Precpred(p.GetParserRuleContext(), 12)

	case 11:
		return p.Precpred(p.GetParserRuleContext(), 11)

	case 12:
		return p.Precpred(p.GetParserRuleContext(), 10)

	case 13:
		return p.Precpred(p.GetParserRuleContext(), 9)

	case 14:
		return p.Precpred(p.GetParserRuleContext(), 8)

	case 15:
		return p.Precpred(p.GetParserRuleContext(), 3)

	case 16:
		return p.Precpred(p.GetParserRuleContext(), 2)

	case 17:
		return p.Precpred(p.GetParserRuleContext(), 1)

	case 18:
		return p.Precpred(p.GetParserRuleContext(), 21)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}
