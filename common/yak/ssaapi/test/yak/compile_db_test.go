package ssaapi

import (
	"context"
	"os"
	"strconv"
	"testing"

	"github.com/yaklang/yaklang/common/log"

	"github.com/google/uuid"
	"github.com/stretchr/testify/require"
	"github.com/yaklang/yaklang/common/consts"

	"github.com/yaklang/yaklang/common/utils/omap"
	"github.com/yaklang/yaklang/common/yak/ssa"
	"github.com/yaklang/yaklang/common/yak/ssa/ssadb"
	"github.com/yaklang/yaklang/common/yak/ssaapi"
	"github.com/yaklang/yaklang/common/yak/ssaapi/ssaconfig"
	"github.com/yaklang/yaklang/common/yak/ssaapi/test/ssatest"
	"github.com/yaklang/yaklang/common/yak/yaklib/codec"
)

func TestDatabase_Audit(t *testing.T) {
	var code = `
a = () => {
	href = request.GetParams("href")	
	if href.contains("abc") {
		href = "aaa"
	}
	system.getClient().Execute("basc -c " + strconv.Quote(href))
}

register("/someRoute", a)
`
	progName := uuid.NewString()
	prog, err := ssaapi.Parse(code, ssaapi.WithProgramName(progName))
	if err != nil {
		t.Fatal(err)
	}
	_ = prog
}

func TestCompileWithDatabase_Scope_Phi(t *testing.T) {
	t.Skip("skip for now, need to fix the scope lazy load")

	progName := uuid.NewString()
	prog, err := ssaapi.Parse(`
a = 1
if (c > 1) {
	a = 2
}
e = a
dump(c)
`)
	// `, ssaapi.WithProgramName(progName))
	defer ssadb.DeleteProgram(ssadb.GetDB(), progName)
	if err != nil {
		panic(err)
	}
	prog.Show()
	funcIns := prog.Program.GetFunction(string(ssa.MainFunctionName), "")
	require.NotNil(t, funcIns)
	brId := funcIns.Blocks[len(funcIns.Blocks)-1]
	br, _ := funcIns.GetBasicBlockByID(brId)
	block, _ := ssa.ToBasicBlock(br)
	require.NotNil(t, block)
	scope := block.ScopeTable
	require.NotNil(t, scope)
	name := scope.GetScopeName()
	log.Infof("scope name: %s", name)
	// id := scope.GetPersistentId()
	// if id <= 0 {
	// 	t.Fatal("scope is not a persistent scope")
	// }

	ePhi := scope.ReadValue("e")
	t.Log(ePhi.String())

	scopePersistent, err := ssa.GetScopeFromIrScopeName(progName, scope.GetScopeName())
	if err != nil {
		t.Fatalf("failed to get scope from ir scope id: %v", err)
	}
	eLazyPhi := scopePersistent.ReadValue("e")
	verbose := eLazyPhi.String()
	if verbose == "" {
		t.Fatal("failed to get variable e(a) verbos is nil ")
	}
	if eLazyPhi.GetId() != ePhi.GetId() {
		t.Fatalf("failed to get variable e(a) instruction errror: %d vs got(%d)", eLazyPhi.GetId(), ePhi.GetId())
	}
	log.Infof("eLazyPhi: %s", eLazyPhi.String())
	log.Infof("ePhi: %s", ePhi.String())

	if ePhi.GetSourceCode() == "" {
		t.Fatal("failed to get variable e(a) source code (memory)")
	}

	if eLazyPhi.GetSourceCode() == "" {
		t.Fatal("failed to get variable e(a) source code (lazy)")
	}

	require.Equal(t, ePhi.GetSourceCode(), eLazyPhi.GetSourceCode())
	require.Equal(t, ePhi.GetSourceCodeContext(2), eLazyPhi.GetSourceCodeContext(2))
}

func TestCompileWithDatabase_Scope_Phi2(t *testing.T) {
	prog, err := ssaapi.Parse(`
a = 1
if (c > 1) {
	a = 2
}
d = a
`, ssaapi.WithProgramName("a"))
	defer ssadb.DeleteProgram(ssadb.GetDB(), "a")
	if err != nil {
		panic(err)
	}
	prog.Show()
}

func TestCompileWithDatabase_Big(t *testing.T) {
	progName := uuid.New().String()
	code, _ := codec.DecodeBase64(`IyBtaXRtIHBsdWdpbiB0ZW1wbGF0ZQoKIy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tV09SS1NQQUNFLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0KX190ZXN0X18gPSBmdW5jKCkgewogICAgcmVzdWx0cywgZXJyIDo9IHlha2l0LkdlbmVyYXRlWWFraXRNSVRNSG9va3NQYXJhbXMoIkdFVCIsICJodHRwOi8vMTkyLjE2OC4zLjExMzo4MDg1L3NoaXJvLyIpCiAgICBpZiBlcnIgIT0gbmlsIHsKICAgICAgICByZXR1cm4KICAgIH0KICAgIGlzSHR0cHMsIHVybCwgcmVxUmF3LCByc3BSYXcsIGJvZHkgPSByZXN1bHRzCgogICAgbWlycm9yTmV3V2Vic2l0ZShyZXN1bHRzLi4uKQp9CgprZXlzID0gWwogICAgImtQSCtiSXhrNUQyZGVaaUl4Y2FhYUE9PSIsCiAgICAiNEF2VmhtRkxVczBLVEEzS3Byc2RhZz09IiwKICAgICJaM1Z1Y3dBQUFBQUFBQUFBQUFBQUFBPT0iLAogICAgImZDcSsveFc0ODhoTVRDRCtjbUozYVE9PSIsCiAgICAiMEF2VmhtRkxVczBLVEEzS3Byc2RhZz09IiwKICAgICIxQXZWaGRzZ1VzMEZTQTNTREZBZGFnPT0iLAogICAgIjFRV0x4ZytOWW14cmFNb3hBWHUvSXc9PSIsCiAgICAiMjVCc21kWXdqbmZjV21uaEFjaUREZz09IiwKICAgICIyQXZWaGRzZ1VzMEZTQTNTREZBZGFnPT0iLAogICAgIjNBdlZobUZMVXMwS1RBM0twcnNkYWc9PSIsCiAgICAiM0p2WWhtQkxVczBFVEE1S3Byc2RhZz09IiwKICAgICJyMGUzYzE2SWRWa291WmdrMVRLVk1nPT0iLAogICAgIjVhYUM1cUttNW9xQTVweXZBQUFBQUE9PSIsCiAgICAiNUF2VmhtRkxVczBLVEEzS3Byc2RhZz09IiwKICAgICI2QXZWaG1GTFVzMEtUQTNLcHJzZGFnPT0iLAogICAgIjZOZlhrQzdZVkNWNURBU0lyRW0xUmc9PSIsCiAgICAiNlptSTZJMmo1WStSNWFTbjVaT2xBQT09IiwKICAgICJjbVZ0WlcxaVpYSk5aUUFBQUFBQUFBPT0iLAogICAgIjdBdlZobUZMVXMwS1RBM0twcnNkYWc9PSIsCiAgICAiOEF2VmhtRkxVczBLVEEzS3Byc2RhZz09IiwKICAgICI4QnZWaG1GTFVzMEtUQTNLcHJzZGFnPT0iLAogICAgIjlBdlZobUZMVXMwS1RBM0twcnNkYWc9PSIsCiAgICAiT1VIWVF6eFEvVzllL1VqaUFHdTZyZz09IiwKICAgICJhM2R2Ym1jQUFBQUFBQUFBQUFBQUFBPT0iLAogICAgImFVMXBjbUZqYkdWcFRXbHlZV05zWlE9PSIsCiAgICAiYldsamNtOXpBQUFBQUFBQUFBQUFBQT09IiwKICAgICJiV2x1WlMxaGMzTmxkQzFyWlhrNlFRPT0iLAogICAgImJYUnZibk1BQUFBQUFBQUFBQUFBQUE9PSIsCiAgICAiWlVkc2FHSnVTbXhpYlZJMlpIYzlQUT09IiwKICAgICJ3R2lIcGxhbXlYbFZCMTFVWFdvbDhnPT0iLAogICAgIlUzQnlhVzVuUW14aFpHVUFBQUFBQUE9PSIsCiAgICAiTVRJek5EVTJOemc1TUdGaVkyUmxaZz09IiwKICAgICJMN1Jpb1VVTEVGaFJ5eE03YTJSL1lnPT0iLAogICAgImEyVmxjRTl1UjI5cGJtZEJibVJHYVE9PSIsCiAgICAiV2NmSEdVMjVnTm5UeFRsbUpNZVNwdz09IiwKICAgICJPWS8vQzRyaGZ3TnhDUUFRQ3JRUTFRPT0iLAogICAgIjVKN2JJSklWMExRU04zYzlMUGl0QlE9PSIsCiAgICAiZi9TWTVUSXZlNVdXelQ0YVFsQUJKQT09IiwKICAgICJieWEySGtZbzU3dTZmV2g1dGhlQVd3PT0iLAogICAgIld1Qit5MmdjSFJuWTJMZzkrQXFtcWc9PSIsCiAgICAia1B2NTl2eXF6ajAweDExTFhKWlRqSjJVSFc0OGp6SE4iLAogICAgIjNxRFZkTGF3b0lyMXhGZDZpZXRud2c9PSIsCiAgICAiWld2b2htUGRVc0FXVDM9S3BQcWRhIiwKICAgICJZSTErbkJWLy9tN0VMckl5REhtNkRRPT0iLAogICAgIjZabSs2STJqNVkrUjVhUys1Wk9sQUE9PSIsCiAgICAiMkEyVitSRkxVcytlVEEzS3ByK2RhZz09IiwKICAgICI2Wm1JNkkyajNZK1IxYVNuNUJPbEFBPT0iLAogICAgIlNrWnBibUZzUW14aFpHVUFBQUFBQUE9PSIsCiAgICAiMmNWdGlFODNjNGxJckVMSndLR0pVdz09IiwKICAgICJmc0hzcFp3LzkyUHJTM1hyUFcrdnh3PT0iLAogICAgIlhUeDZDS0xvL1NkU2d1YitPUEhTcnc9PSIsCiAgICAic0hkSWpVTjZ0emhsOHhaTUczVUxDUT09IiwKICAgICJPNHBkZis3ZSttWmU4Tnl4TVRQSm1RPT0iLAogICAgIkhXckJsdEd2RVpjMTRoOVZwTXZaV3c9PSIsCiAgICAiclBOcU02dUtGQ3lhTDEwQUs1MVVrUT09IiwKICAgICJZMUp4TlNQWFZ3TWt5dkVTL2tKR2VRPT0iLAogICAgImxUMlV2RFVtUXdld202bU1vaXc0SWc9PSIsCiAgICAiTVBkQ01aOXVyekVBNTBKRGxEWVlEZz09IiwKICAgICJ4Vm1tb2x0ZnBiOHRUY2V1VDVSN0J3PT0iLAogICAgImMrM2hGR1BqYmd6R2RyQytNSGdvUlE9PSIsCiAgICAiQ2xMazY5b05jQTNtK3MwaklNSWtwZz09IiwKICAgICJCZjdNZmtOUjBheEdHcHRvenJlYmFnPT0iLAogICAgIjF0Qy94ckRZczhleStzYTNlbXRpWXc9PSIsCiAgICAiWm1Gc1lXUnZMbmg1ZWk1emFHbHlidz09IiwKICAgICJjR2h5WVdOclkzUm1SRVVoZmlNa1pBPT0iLAogICAgIklkdUVsRFVwRERYRTY3N1praGhLblE9PSIsCiAgICAieWVBQW8xRThCT2VBWWZCbG00Tkc5UT09IiwKICAgICJjR2xqWVhNQUFBQUFBQUFBQUFBQUFBPT0iLAogICAgIjJpdGZXOTJYYXpZUmk1bHRXME0yeUE9PSIsCiAgICAiWGdHa2dxR3FZcml4OWxJNnZ4Y3JSdz09IiwKICAgICJlcnRWaG1GTFVzMEtUQTNLcHJzZGFnPT0iLAogICAgIjVBdlZobUZMVVMwQVRBNEtwcnNkYWc9PSIsCiAgICAiczBLVEEzbUZMVXBySzRBdlZoc2RhZz09IiwKICAgICJoQmx6S2c3OGFqYVp1VEUwVkx6RERnPT0iLAogICAgIjlGdlZodEZMVXMwS25BM0twcnNkeWc9PSIsCiAgICAiZDJWaVVtVnRaVzFpWlhKTlpVdGxlUT09IiwKICAgICJ5TmVVZ1N6TC9DZmlXdzFHQUxnNkFnPT0iLAogICAgIk5Hay8zY1E2RjUvVU5QUmg4THBNSWc9PSIsCiAgICAiNEJ2VmhtRkxVczBLVEEzS3Byc2RhZz09IiwKICAgICJNelZlU2tZeVdUSTJPRlZMWmpSelpnPT0iLAogICAgImVtcG9kREV5TXdBQUFBQUFBQUFBQUE9PSIsCiAgICAiQTdVekpnaDErRVdqNW9CRmkrbVNndz09IiwKICAgICJZVE0wTlpvbUl6STJPVHNtSXpNME5UdWVZUT09IiwKICAgICJjMmhwY205ZlltRjBhWE16TWdBQUFBPT0iLAogICAgImk0NUZWdDcySzJrTGd2RnJKdG9aUnc9PSIsCiAgICAiVTNCQWJXNW5RbXhoWkdVQUFBQUFBQT09IiwKICAgICJabkpsYzJoNlkyNHhNak0wTlRZM09BPT0iLAogICAgIkp0M0M5M2tNUjlENWU4UXp3ZnNpTXc9PSIsCiAgICAiTVRJek5EVTJOemd4TWpNME5UWTNPQT09IiwKICAgICJ2WFAzM0FvbklwOWJGd0dsN2FUN3JBPT0iLAogICAgIlYyaGhkQ0JVYUdVZ1NHVnNiQUFBQUE9PSIsCiAgICAiWjNoNmVXZDRlbmtsTWpFbE1qRWxNakU9IiwKICAgICJRMDFUWDBKR1RGbExSVmxmTWpBeE9RPT0iLAogICAgIlpBdnBoM2RzUXMwRlNMM1NERkFkYWc9PSIsCiAgICAiSXM5ekozcHpOaDJjZ1RIQjR1YTMrUT09IiwKICAgICJOc1pYalhWa2xXUFp3T2Zrdms2a1VBPT0iLAogICAgIkdBZXZZbnpudmdOQ1VSYXZCaENyMXc9PSIsCiAgICAiNjZ2MU84a2VLTlYzVFRjR1BLMXd6Zz09IiwKICAgICJTREtPTEtuMkoxai8yQkhqZVp3QW9RPT0iLApdCmRhdGEgPSBjb2RlYy5EZWNvZGVIZXgoYGFjZWQwMDA1NzM3MjAwMzI2ZjcyNjcyZTYxNzA2MTYzNjg2NTJlNzM2ODY5NzI2ZjJlNzM3NTYyNmE2NTYzNzQyZTUzNjk2ZDcwNmM2NTUwNzI2OTZlNjM2OTcwNjE2YzQzNmY2YzZjNjU2Mzc0Njk2ZjZlYTg3ZjU4MjVjNmEzMDg0YTAzMDAwMTRjMDAwZjcyNjU2MTZjNmQ1MDcyNjk2ZTYzNjk3MDYxNmM3Mzc0MDAwZjRjNmE2MTc2NjEyZjc1NzQ2OTZjMmY0ZDYxNzAzYjc4NzA3MDc3MDEwMDc4YClbMF0KZGF0YSA9IGNvZGVjLlBLQ1M1UGFkZGluZyhkYXRhLCAxNikKCmV4ZWN1dGluZ0NvdW50ID0gMApleGVjdXRpbmdDb3VudExvY2sgPSBzeW5jLk5ld011dGV4KCkKYWRkID0gZnVuYygpIHsKICAgIGV4ZWN1dGluZ0NvdW50TG9jay5Mb2NrKCkKICAgIGV4ZWN1dGluZ0NvdW50ICs9IDEKICAgIHlha2l0X3N0YXR1cygi5q2j5Zyo5qOA5rWLU2hpcm/nmoTnvZHnq5nmlbDph48iLCBleGVjdXRpbmdDb3VudCkKICAgIGV4ZWN1dGluZ0NvdW50TG9jay5VbmxvY2soKQp9CnN1YiA9IGZ1bmMoKSB7CiAgICBleGVjdXRpbmdDb3VudExvY2suTG9jaygpCiAgICBleGVjdXRpbmdDb3VudCAtPSAxCiAgICBpZiAoZXhlY3V0aW5nQ291bnQgPCAxKSB7CiAgICAgICAgeWFraXRfc3RhdHVzKCLmraPlnKjmo4DmtYtTaGlyb+eahOe9keermeaVsOmHjyIsICIiKQogICAgfWVsc2V7CiAgICAgICAgeWFraXRfc3RhdHVzKCLmraPlnKjmo4DmtYtTaGlyb+eahOe9keermeaVsOmHjyIsIGV4ZWN1dGluZ0NvdW50KQogICAgfQogICAgZXhlY3V0aW5nQ291bnRMb2NrLlVubG9jaygpCn0KY3R4LCBjYW5jZWwgPSBjb250ZXh0LldpdGhDYW5jZWwoY29udGV4dC5CYWNrZ3JvdW5kKCkpCnN3ZyA9IHN5bmMuTmV3U2l6ZWRXYWl0R3JvdXAoMjApCmdldFJlbWVtYmVyTWVOdW1iZXIgPSAocnNwLGtleSk9PnsKICAgIG5ld3JzcCA9IHN0ci5SZXBsYWNlKHJzcCxrZXksIiIsIC0xKQogICAgcmV0dXJuIChsZW4ocnNwKS1sZW4obmV3cnNwKSkvbGVuKGtleSkKfQoKRWNob1N1Y2Nlc3NIb3N0ID0gW10KRG5zTG9nU3VjY2Vzc0hvc3QgPSBbXQojIG1pcnJvck5ld1dlYnNpdGUg5q+P5paw5Ye6546w5LiA5Liq572R56uZ77yM6L+Z5Liq572R56uZ55qE56ys5LiA5Liq6K+35rGC77yM5bCG5Lya5Zyo6L+Z6YeM6KKr6LCD55So77yBCm1pcnJvck5ld1dlYnNpdGUgPSBmdW5jKGlzSHR0cHMgLypib29sKi8sIHVybCAvKnN0cmluZyovLCByZXEgLypbXWJ5dGUqLywgcnNwIC8qW11ieXRlKi8sIGJvZHkgLypbXWJ5dGUqLykgewogICAgc3dnLkFkZCgpCiAgICBhZGQoKQogICAgZGVmZXIgc3ViKCkKICAgIGRlZmVyIHN3Zy5Eb25lKCkKICAgIGZyZXEgPSBmdXp6LkhUVFBSZXF1ZXN0KHJlcSwgZnV6ei5odHRwcyhpc0h0dHBzKSlbMF0KICAgIHJlcUhlYWRlciwgXyA9IHN0ci5TcGxpdEhUVFBIZWFkZXJzQW5kQm9keUZyb21QYWNrZXQocmVxKQogICAgaG9zdCwgcG9ydCwgXyA9IHN0ci5QYXJzZVN0cmluZ1RvSG9zdFBvcnQodXJsKQogICAgc2hpcm9Db29raWVLZXkgPSAicmVtZW1iZXJNZSIKICAgIHlha2l0X291dHB1dChzcHJpbnRmKCLlh4blpIflj5HpgIEgc2hpcm8g5o6i5rWL6K+35rGCIGZvcjogJXYiLCB1cmwpKQogICAgcnNwLCBlcnIgPSBmcmVxLkZ1enpDb29raWUoInJlbWVtYmVyTWUiLCAie3tiYXNlNjQoe3tyYW5kc3RyKDEwKX19KX19OyIpLkV4ZWNGaXJzdChodHRwb29sLmNvbnRleHQoY3R4KSwgaHR0cG9vbC5odHRwcyhpc0h0dHBzKSkKICAgIGlmIGVyciAhPSBuaWwgfHwgcnNwLkVycm9yICE9IG5pbCB7CiAgICAgICAgeWFraXRfb3V0cHV0KHNwcmludGYoIuaJp+ihjOWksei0peOAkCV244CROiAldiAmICV2IiwgdXJsLCBlcnIsIHJzcC5FcnJvcikpCiAgICAgICAgcmV0dXJuCiAgICB9CiAgICBoZWFkZXJzLCBib2R5IDo9IHN0ci5TcGxpdEhUVFBIZWFkZXJzQW5kQm9keUZyb21QYWNrZXQocnNwLlJlc3BvbnNlUmF3KQogICAgLy8g5o+Q5Y+W57G75Ly8cmVtZW1iZXJNZeeahGtleQogICAgcmVzdWx0ID0gcmUuRmluZFN1Ym1hdGNoKGhlYWRlcnMsIGAoP2kpKHJlbWVtP2Jlck1lKVxzKj1ccypkZWxldGVNZTs/YCkKICAgIGlmIGxlbihyZXN1bHQpID4gMSB7CiAgICAgICAgc2hpcm9Db29raWVLZXkgPSByZXN1bHRbMV0KICAgIH0KICAgIC8vIOiOt+WPlnJlbWVtYmVyTWXnmoTmlbDph48KICAgIGN1cnJlbnRSZW1lbWJlck1lTnVtYmVyID0gZ2V0UmVtZW1iZXJNZU51bWJlcihoZWFkZXJzLHNoaXJvQ29va2llS2V5KQoKICAgIC8vIGN1cnJlbnRSZW1lbWJlck1lTnVtYmVyIDw9MOWImeWIpOaWreS4jeWtmOWcqHNoaXJvCiAgICBpZiBjdXJyZW50UmVtZW1iZXJNZU51bWJlciA8PTAgewogICAgICAgIHlha2l0X291dHB1dChzcHJpbnRmKCIldiDmnKrmo4DmtYvliLAgc2hpcm8iLCBzdHIuSG9zdFBvcnQoaG9zdCwgcG9ydCkpKQogICAgICAgIHJldHVybgogICAgfQoKCgogICAgeWFraXRfb3V0cHV0KHNwcmludGYoIiV2IOajgOa1i+WIsCBzaGlybywgQ29va2llOiAldiIsIHN0ci5Ib3N0UG9ydChob3N0LCBwb3J0KSwgc2hpcm9Db29raWVLZXkpKQogICAgeWFraXRfc3RhdHVzKCJTaGlybzoiK3N0ci5Ib3N0UG9ydChob3N0LCBwb3J0KSwgIlNoaXJvIOaMh+e6uSIpCgogICAgcmlzay5OZXdSaXNrKAogICAgICAgIHVybCwKICAgICAgICByaXNrLnRpdGxlKHNwcmludGYoIihNYXliZSkgU2hpcm8oQ29va2llKSBEZXRlY3RlZDogJXYiLCB1cmwpKSwKICAgICAgICByaXNrLnRpdGxlVmVyYm9zZSgi55aR5Ly85qOA5rWL5YiwIFNoaXJvKENvb2tpZSkg5qGG5p625L2/55SoIiksCiAgICAgICAgcmlzay50eXBlKCJpbmZvIiksIHJpc2sudHlwZVZlcmJvc2UoIueWkeS8vOaVj+aEn+ahhuaetuS9v+eUqCIpLAogICAgICAgIHJpc2suZGVzY3JpcHRpb24oYOacrOadoeiusOW9leaYr+ajgOa1i+eWkeS8vCBTaGlybyDmoYbmnrbooYzkuLrvvIzpgJrov4fmtYvor5UgcmVtZW1iZXJNZSAvIHJlbWViZXJNZSDnrYkgQ29va2llIOihjOS4uui/m+ihjOWIpOaWre+8jOW5tuS4jeiDveWHhuehruWIpOaWrSBTaGlybyDmoYbmnrbvvIzlj6/og73lrZjlnKjor6/miqXjgIIKCuWmguaenOehruiupOS9v+eUqOS6hiBTaGlybyDmoYbmnrbvvIzlkI7nu63mtYvor5XkvJrkvb/nlKggU2hpcm8g5qGG5p6255qE6buY6K6k5a+G6ZKl57uE6L+b6KGM54iG56C077yM5aaC5p6c54iG56C05oiQ5Yqf77yM5Y+v5Lul6L+b5LiA5q2l5qOA5rWL5piv5ZCm5a2Y5ZyoIFNoaXJvIOWPjeW6j+WIl+WMlua8j+a0nuOAggoKQXBhY2hlIFNoaXJvIDw9IDEuMi40IOeJiOacrOS4re+8jOWKoOWvhueahOeUqOaIt+S/oeaBr+W6j+WIl+WMluWQjuWtmOWCqOWcqENvb2tpZeeahHJlbWVtYmVyTWXlrZfmrrXkuK3vvIzmlLvlh7vogIXlj6/ku6Xkvb/nlKhTaGlyb+eahEFFU+WKoOWvhueul+azleeahOm7mOiupOWvhumSpeadpeaehOmAoOaBtuaEj+eahENvb2tpZSByZW1lbWJlck1l5YC877yM5Y+R6YCB5YiwU2hpcm/mnI3liqHnq6/kuYvlkI7kvJrlhYjlkI7ov5vooYxCYXNlNjTop6PnoIHjgIFBRVPop6Plr4bjgIFyZWFkT2JqZWN0KCnlj43luo/liJfljJbvvIzku47ogIzop6blj5FKYXZh5Y6f55Sf5Y+N5bqP5YiX5YyW5ryP5rSe77yM6L+b6ICM5a6e546wUkNF44CC6K+l5ryP5rSe55qE5qC55rqQ5Zyo5LqO56Gs57yW56CBS2V544CCCiAgICAgICAgYCksCiAgICAgICAgcmlzay5zb2x1dGlvbigi5Y2H57qn5YiwQXBhY2hlIFNoaXJvIDEuMi415oiW5pu06auY54mI5pys77yM5bm26YWN572uICdyZW1lbWJlck1lJyDlip/og73nmoTlr4bpkqXjgIIiKSwKICAgICAgICByaXNrLnNldmVyaXR5KCJsb3ciKSwKICAgICAgICByaXNrLnJlcXVlc3QocnNwLlJlcXVlc3RSYXcpLAogICAgICAgIHJpc2sucmVzcG9uc2UocnNwLlJlc3BvbnNlUmF3KSwKICAgICAgICByaXNrLmRldGFpbHMoeyJjb29raWVfbmFtZSI6IHNoaXJvQ29va2llS2V5fSksCiAgICApCgogICAgeWFraXRfb3V0cHV0KCLlvIDlp4vniIbnoLQgU2hpcm8gV2VhayBLZXkiKQogICAgY29va2llID0gbWFrZShbXXZhcikKCiAgICBmb3IgXywga2V5IDo9IHJhbmdlIGtleXMgewogICAgICAgIGZvciBfLCBlbmNJdGVtID0gcmFuZ2UgWwogICAgICAgICAgICB7Im5hbWUiOiAiYWVzLWNiYyIsICJoYW5kbGUiOiBjb2RlYy5BRVNDQkNFbmNyeXB0fSwKICAgICAgICAgICAgeyJuYW1lIjogImFlcy1nY20iLCAiaGFuZGxlIjogY29kZWMuQUVTR0NNRW5jcnlwdH0sCiAgICAgICAgXSB7CiAgICAgICAgICAgIGVuYyA9IGVuY0l0ZW0uaGFuZGxlCiAgICAgICAgICAgIGtleURlY29kZWQsZXJyID0gY29kZWMuRGVjb2RlQmFzZTY0KGtleSkKICAgICAgICAgICAgaWYgZXJyewogICAgICAgICAgICAgICAgY29udGludWUKICAgICAgICAgICAgfQogICAgICAgICAgICBpdiA9IFtdYnl0ZShyYW5kc3RyKDE2KSkKICAgICAgICAgICAgcmVzdWx0LGVyciA9IGVuYyhrZXlEZWNvZGVkLCBkYXRhLCBpdikKICAgICAgICAgICAgaWYgZXJyewogICAgICAgICAgICAgICAgY29udGludWUKICAgICAgICAgICAgfQogICAgICAgICAgICBpZiByZXN1bHQgPT0gbmlsIHsKICAgICAgICAgICAgICAgIGNvbnRpbnVlCiAgICAgICAgICAgIH0KCiAgICAgICAgICAgIGlmIGVuY0l0ZW0ubmFtZSA9PSAiYWVzLWdjbSIgewogICAgICAgICAgICAgICAgcmVzdWx0LGVyciA9IGVuYyhrZXlEZWNvZGVkLCBkYXRhLCBuaWwpCiAgICAgICAgICAgICAgICBpZiBlcnJ7CiAgICAgICAgICAgICAgICAgICAgY29udGludWUKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIGlmIHJlc3VsdCA9PSBuaWwgewogICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlCiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICBjb29raWUgPSBhcHBlbmQoY29va2llLCB7CiAgICAgICAgICAgICAgICAgICAgImNvb2tpZSI6IGNvZGVjLkVuY29kZUJhc2U2NChhcHBlbmQocmVzdWx0KSksCiAgICAgICAgICAgICAgICAgICAgImtleSI6IGtleSwKICAgICAgICAgICAgICAgICAgICAiYWVzLW1vZGUiOiBlbmNJdGVtLm5hbWUsCiAgICAgICAgICAgICAgICB9KQogICAgICAgICAgICB9ZWxzZXsKICAgICAgICAgICAgICAgIGNvb2tpZSA9IGFwcGVuZChjb29raWUsIHsKICAgICAgICAgICAgICAgICAgICAiY29va2llIjogY29kZWMuRW5jb2RlQmFzZTY0KGFwcGVuZChpdiwgcmVzdWx0Li4uKSksCiAgICAgICAgICAgICAgICAgICAgImtleSI6IGtleSwKICAgICAgICAgICAgICAgICAgICAiYWVzLW1vZGUiOiBlbmNJdGVtLm5hbWUsCiAgICAgICAgICAgICAgICB9KQogICAgICAgICAgICB9CgogICAgICAgIH0KICAgIH0KCgoKICAgIGZvciBfLCBjb29raWVFbGVtZW50IDo9IHJhbmdlIGNvb2tpZSB7CiAgICAgICAgeWFraXRfb3V0cHV0KHNwcmludGYoIlNoaXJvIFRyeSBLRVk6ICV2IGZvciAldiIsIGNvb2tpZUVsZW1lbnRbImtleSJdLCB1cmwpKQoKICAgICAgICByZXN1bHQgPSBmcmVxLkZ1enpDb29raWUoc2hpcm9Db29raWVLZXksIGNvb2tpZUVsZW1lbnRbImNvb2tpZSJdKS5FeGVjRmlyc3QoaHR0cG9vbC5odHRwcyhpc0h0dHBzKSlbMF0KCiAgICAgICAgaWYgcmVzdWx0ID09IG5pbHx8cmVzdWx0LkVycm9yICE9IG5pbCB7CiAgICAgICAgICAgIHlha2l0X291dHB1dCgiRkFJTEVEIGZvciAldj0ldiIsIHNoaXJvQ29va2llS2V5LCBjb29raWVFbGVtZW50WyJjb29raWUiXSkKICAgICAgICAgICAgY29udGludWUKICAgICAgICB9CiAgICAgICAgaGVhZGVycywgXyA9IHN0ci5TcGxpdEhUVFBIZWFkZXJzQW5kQm9keUZyb21QYWNrZXQocmVzdWx0LlJlc3BvbnNlUmF3KQoKICAgICAgICBpZiBoZWFkZXJzID09ICIiIHsKICAgICAgICAgICAgY29udGludWUKICAgICAgICB9CgogICAgICAgIC8vIOWmguaenFJlbWVtYmVyTWXmlbDph4/lh4/lsJHvvIzliJnliKTmlq3mtYvor5XmiJDlip8KICAgICAgICBpZiBnZXRSZW1lbWJlck1lTnVtYmVyKGhlYWRlcnMsc2hpcm9Db29raWVLZXkpIDwgY3VycmVudFJlbWVtYmVyTWVOdW1iZXJ7CiAgICAgICAgICAgIHZ1bEluZm8gPSAgIkNWRS0yMDE2LTQ0MzciCiAgICAgICAgICAgIGlmIGNvb2tpZUVsZW1lbnRbImFlcy1tb2RlIl0gPT0gImFlcy1nY20iIHsKICAgICAgICAgICAgICAgIHZ1bEluZm8gPSAiIgogICAgICAgICAgICB9CiAgICAgICAgICAgIGRldGFpbCA6PSB7CiAgICAgICAgICAgICAgICAic2hpcm9fY29va2llX2tleSI6IHNoaXJvQ29va2llS2V5LAogICAgICAgICAgICAgICAgInBheWxvYWQiOiBjb29raWVFbGVtZW50WyJjb29raWUiXSwKICAgICAgICAgICAgICAgICJzaGlyb19rZXkiOiBjb29raWVFbGVtZW50WyJrZXkiXSwKICAgICAgICAgICAgICAgICJzaGlyb19hZXNfbW9kZSI6IGNvb2tpZUVsZW1lbnRbImFlcy1tb2RlIl0sCiAgICAgICAgICAgICAgICAicmVxdWVzdCI6IHJlc3VsdC5SZXF1ZXN0UmF3LAogICAgICAgICAgICAgICAgInJlc3BvbnNlIjogcmVzdWx0LlJlc3BvbnNlUmF3LAogICAgICAgICAgICB9CgogICAgICAgICAgICByaXNrLk5ld1Jpc2soCiAgICAgICAgICAgICAgICAgICAgdXJsLAogICAgICAgICAgICAgICAgICAgIHJpc2suc2V2ZXJpdHkoImNyaXRpY2FsIiksCiAgICAgICAgICAgICAgICAgICAgcmlzay50aXRsZShzcHJpbnRmKCIldihTaGlybyBEZWZhdWx0IEtleSk6ICV2Iix2dWxJbmZvLCB1cmwpKSwKICAgICAgICAgICAgICAgICAgICByaXNrLmRlc2NyaXB0aW9uKCJBcGFjaGUgU2hpcm8gPD0gMS4yLjQg54mI5pys5Lit77yM5Yqg5a+G55qE55So5oi35L+h5oGv5bqP5YiX5YyW5ZCO5a2Y5YKo5ZyoQ29va2ll55qEcmVtZW1iZXJNZeWtl+auteS4re+8jOaUu+WHu+iAheWPr+S7peS9v+eUqFNoaXJv55qEQUVT5Yqg5a+G566X5rOV55qE6buY6K6k5a+G6ZKl5p2l5p6E6YCg5oG25oSP55qEQ29va2llIHJlbWVtYmVyTWXlgLzvvIzlj5HpgIHliLBTaGlyb+acjeWKoeerr+S5i+WQjuS8muWFiOWQjui/m+ihjEJhc2U2NOino+eggeOAgUFFU+ino+WvhuOAgXJlYWRPYmplY3QoKeWPjeW6j+WIl+WMlu+8jOS7juiAjOinpuWPkUphdmHljp/nlJ/lj43luo/liJfljJbmvI/mtJ7vvIzov5vogIzlrp7njrBSQ0XjgILor6XmvI/mtJ7nmoTmoLnmupDlnKjkuo7noaznvJbnoIFLZXnjgIIiKSwKICAgICAgICAgICAgICAgICAgICByaXNrLnNvbHV0aW9uKCLljYfnuqfliLBBcGFjaGUgU2hpcm8gMS4yLjXmiJbmm7Tpq5jniYjmnKzvvIzlubbphY3nva4gJ3JlbWVtYmVyTWUnIOWKn+iDveeahOWvhumSpeOAgiIpLAogICAgICAgICAgICAgICAgICAgIHJpc2sudGl0bGVWZXJib3NlKHNwcmludGYoIiV2KFNoaXJvIOm7mOiupCBLRVkp77yaJXYiLCB2dWxJbmZvLHVybCkpLAogICAgICAgICAgICAgICAgICAgIHJpc2sudHlwZSgicmNlIiksCiAgICAgICAgICAgICAgICAgICAgcmlzay5wYXJhbWV0ZXIoIktleTogIitjb29raWVFbGVtZW50WyJrZXkiXSksCiAgICAgICAgICAgICAgICAgICAgcmlzay5wYXlsb2FkKGNvb2tpZUVsZW1lbnRbImNvb2tpZSJdKSwKICAgICAgICAgICAgICAgICAgICByaXNrLmRldGFpbHMoZGV0YWlsKSwKICAgICAgICAgICAgICAgICkKICAgICAgICAgICAgZGVsZXRlKGRldGFpbCwgInJlcXVlc3QiKQogICAgICAgICAgICBkZWxldGUoZGV0YWlsLCAicmVzcG9uc2UiKQoKICAgICAgICAgICAgeWFraXRfb3V0cHV0KGRldGFpbCkKICAgICAgICAgICAgLy8g5byA5aeL55uy5omTIOS9v+eUqCBDQjE4M05vQ0PjgIFDQzE5Mk5vQ0PjgIFLMeOAgUsyCiAgICAgICAgICAgIGJsaW5kID0gYmxpbmRFY2hvKGNvb2tpZUVsZW1lbnRbImtleSJdLGNvb2tpZUVsZW1lbnRbImFlcy1tb2RlIl0sc2hpcm9Db29raWVLZXksZnJlcSxpc0h0dHBzKQoKICAgICAgICAgICAgaWYgYmxpbmQgewogICAgICAgICAgICAgICAgcmV0dXJuCiAgICAgICAgICAgIH0KCiAgICAgICAgICAgIHlha2l0LkluZm8oIiV2IGVjaG8gJXYgZG5zbG9nICV2Iix1cmwsIEVjaG9TdWNjZXNzSG9zdC5MZW5ndGgoKSxEbnNMb2dTdWNjZXNzSG9zdC5MZW5ndGgoKSkKCiAgICAgICAgICAgIGlmIEVjaG9TdWNjZXNzSG9zdC5MZW5ndGgoKSA9PSAwICAmJiBEbnNMb2dTdWNjZXNzSG9zdC5MZW5ndGgoKSA9PSAwIHsKICAgICAgICAgICAgICAgIHNlcnZlcix0b2tlbixlcnIgPSByaXNrLk5ld0ROU0xvZ0RvbWFpbigpCiAgICAgICAgICAgICAgICBpZiBlcnIgPT0gbmlsIHsKICAgICAgICAgICAgICAgICAgICB0cnkgewoKICAgICAgICAgICAgICAgICAgICAgICAgZmluZEdhZGdldERhdGEgPSB5c28uR2V0RmluZEdhZGdldEJ5RE5TSmF2YU9iamVjdChzZXJ2ZXIpfgogICAgICAgICAgICAgICAgICAgICAgICBmaW5kR2FkZ2V0RGF0YUJ5dGVzID0geXNvLlRvQnl0ZXMoZmluZEdhZGdldERhdGEpfgogICAgICAgICAgICAgICAgICAgICAgICBmaW5kR2FkZ2V0RGF0YUJ5dGVzID0gY29kZWMuUEtDUzVQYWRkaW5nKGZpbmRHYWRnZXREYXRhQnl0ZXMsIDE2KQogICAgICAgICAgICAgICAgICAgICAgICBrZXlEZWNvZGVkLF8gPSBjb2RlYy5EZWNvZGVCYXNlNjQoY29va2llRWxlbWVudFsia2V5Il0pCiAgICAgICAgICAgICAgICAgICAgICAgIHBheWxvYWQgPSAiIgogICAgICAgICAgICAgICAgICAgICAgICBpZiBjb29raWVFbGVtZW50WyJhZXMtbW9kZSJdID09ICJhZXMtZ2NtIiB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbkQsXyA9IGNvZGVjLkFFU0dDTUVuY3J5cHQoa2V5RGVjb2RlZCwgZmluZEdhZGdldERhdGFCeXRlcywgbmlsKQogICAgICAgICAgICAgICAgICAgICAgICAgICAgcGF5bG9hZCA9ICBjb2RlYy5FbmNvZGVCYXNlNjQoYXBwZW5kKGVuRCkpCiAgICAgICAgICAgICAgICAgICAgICAgIH1lbHNlewogICAgICAgICAgICAgICAgICAgICAgICAgICAgaXYgPSBbXWJ5dGUocmFuZHN0cigxNikpCiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbkQsXyA9IGNvZGVjLkFFU0NCQ0VuY3J5cHQoa2V5RGVjb2RlZCwgZmluZEdhZGdldERhdGFCeXRlcywgaXYpCiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXlsb2FkID0gIGNvZGVjLkVuY29kZUJhc2U2NChhcHBlbmQoaXYsIGVuRC4uLikpCiAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgICAgcmVzID0gZnJlcS5GdXp6Q29va2llKHNoaXJvQ29va2llS2V5LCBwYXlsb2FkKS5FeGVjRmlyc3QoaHR0cG9vbC5odHRwcyhpc0h0dHBzKSlbMF0KCiAgICAgICAgICAgICAgICAgICAgICAgIGZpbmRHYWRHZXREZXRhaWwgOj0gewogICAgICAgICAgICAgICAgICAgICAgICAgICAgInNoaXJvX2Nvb2tpZV9rZXkiOiBzaGlyb0Nvb2tpZUtleSwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICJwYXlsb2FkIjogcGF5bG9hZCwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICJzaGlyb19rZXkiOiBjb29raWVFbGVtZW50WyJrZXkiXSwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICJzaGlyb19hZXNfbW9kZSI6IGNvb2tpZUVsZW1lbnRbImFlcy1tb2RlIl0sCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAicmVxdWVzdCI6IHJlcy5SZXF1ZXN0UmF3LAogICAgICAgICAgICAgICAgICAgICAgICAgICAgInJlc3BvbnNlIjogcmVzLlJlc3BvbnNlUmF3LAogICAgICAgICAgICAgICAgICAgICAgICAgICAgImdhZGdldHMiOiAiIiwKICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgICB0b2tlbnMsXyA9IHJpc2suQ2hlY2tETlNMb2dCeVRva2VuKHRva2VuKQogICAgICAgICAgICAgICAgICAgICAgICBnYWRnZXRzID0gbWFrZShbXXN0cmluZykKICAgICAgICAgICAgICAgICAgICAgICAgZm9yIF8sdiA6PSByYW5nZSB0b2tlbnN7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb21haW4gPSBzdHIuVG9Mb3dlcih2LkRvbWFpbikKICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIHN0ci5Db250YWlucyhkb21haW4sIi4iK3Rva2VuKSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2FkZ2V0cyA9IGFwcGVuZChnYWRnZXRzLCBzdHIuU3BsaXQoZG9tYWluLCIuIiArIHRva2VuKVswXSkKICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgICBnYWRnZXRzID0gc3RyLlJlbW92ZVJlcGVhdChnYWRnZXRzKQoKICAgICAgICAgICAgICAgICAgICAgICAgaWYgZ2FkZ2V0cy5MZW5ndGgoKSA+IDAgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgRG5zTG9nU3VjY2Vzc0hvc3QuQXBwZW5kKHN0ci5QYXJzZVN0cmluZ1VybFRvVXJsSW5zdGFuY2UodXJsKX4uSG9zdCkKICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdhZGdldFN0ciA9IHN0ci5Kb2luKGdhZGdldHMsICIsIikKICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbmRHYWRHZXREZXRhaWwuU2V0KCJnYWRnZXRzIixnYWRnZXRTdHIpCiAgICAgICAgICAgICAgICAgICAgICAgICAgICByaXNrLk5ld1Jpc2soCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdXJsLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJpc2suc2V2ZXJpdHkoImNyaXRpY2FsIiksCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmlzay50aXRsZShzcHJpbnRmKCIldihTaGlybyBGaW5kR2FkZ2V0cyk6ICV2Iix2dWxJbmZvLCB1cmwpKSwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByaXNrLmRlc2NyaXB0aW9uKCJBcGFjaGUgU2hpcm8gPD0gMS4yLjQg54mI5pys5Lit77yM5Yqg5a+G55qE55So5oi35L+h5oGv5bqP5YiX5YyW5ZCO5a2Y5YKo5ZyoQ29va2ll55qEcmVtZW1iZXJNZeWtl+auteS4re+8jOaUu+WHu+iAheWPr+S7peS9v+eUqFNoaXJv55qEQUVT5Yqg5a+G566X5rOV55qE6buY6K6k5a+G6ZKl5p2l5p6E6YCg5oG25oSP55qEQ29va2llIHJlbWVtYmVyTWXlgLzvvIzlj5HpgIHliLBTaGlyb+acjeWKoeerr+S5i+WQjuS8muWFiOWQjui/m+ihjEJhc2U2NOino+eggeOAgUFFU+ino+WvhuOAgXJlYWRPYmplY3QoKeWPjeW6j+WIl+WMlu+8jOS7juiAjOinpuWPkUphdmHljp/nlJ/lj43luo/liJfljJbmvI/mtJ7vvIzov5vogIzlrp7njrBSQ0XjgILor6XmvI/mtJ7nmoTmoLnmupDlnKjkuo7noaznvJbnoIFLZXnjgIIiKSwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByaXNrLnNvbHV0aW9uKCLljYfnuqfliLBBcGFjaGUgU2hpcm8gMS4yLjXmiJbmm7Tpq5jniYjmnKzvvIzlubbphY3nva4gJ3JlbWVtYmVyTWUnIOWKn+iDveeahOWvhumSpeOAgiIpLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJpc2sudGl0bGVWZXJib3NlKHNwcmludGYoIiV2KFNoaXJvIOaOoua1i+WPr+WIqeeUqOmTvinvvJoldiIsIHZ1bEluZm8sdXJsKSksCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmlzay50eXBlKCJyY2UiKSwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByaXNrLnBhcmFtZXRlcigiS2V5OiAiK2Nvb2tpZUVsZW1lbnRbImtleSJdKyIg5Y+v6IO955qE5Yip55So6ZO+OiAiICsgZmluZEdhZEdldERldGFpbFsiZ2FkZ2V0cyJdKSwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByaXNrLnBheWxvYWQoY29va2llRWxlbWVudFsiY29va2llIl0pLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJpc2suZGV0YWlscyhmaW5kR2FkR2V0RGV0YWlsKSwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICkKICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZShmaW5kR2FkR2V0RGV0YWlsLCAicmVxdWVzdCIpCiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUoZmluZEdhZEdldERldGFpbCwgInJlc3BvbnNlIikKICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggZXJyIHsKICAgICAgICAgICAgICAgICAgICAgICAgeWFraXQuSW5mbygiR2V0RmluZEdhZGdldEJ5RE5TICV2IiwgZXJyKQogICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgfQoKCiAgICAgICAgICAgIHJldHVybgogICAgICAgIH0KICAgIH0KfQoKYmxpbmRFY2hvID0gZnVuYyAoYnM2NGtleSxtb2RlLHNoaXJvQ29va2llS2V5LGZyZXEsaXNIdHRwcykgewogICAgYnl0ZXNDb2RlLGVyciA9Y29kZWMuRGVjb2RlQmFzZTY0KCJ5djY2dmdBQUFESUFsUW9BQWdCRUJ3QkZDZ0JHQUVjSEFFZ0tBRVlBU1FvQUJBQktDZ0JMQUV3S0FFc0FUUW9BS1FCT0NnQlBBRkFLQUU4QVVRZ0FVZ29BS0FCVEJ3QlVDZ0JQQUZVSUFGWUtBRmNBV0FnQVdRZ0FXZ2NBV3dnQVhBZ0FYUWdBWGdjQVh3Z0FZQWNBWVFzQUdnQmlDd0FhQUdNSUFHUUhBR1VLQUI0QVpnY0Fad29BSUFCb0NnQWdBR2tKQUNnQWFnZ0Fhd29BVndCc0NnQnRBRzRJQUc4SEFIQUhBSEVCQUFwRlkyaHZTR1ZoWkdWeUFRQVNUR3BoZG1FdmJHRnVaeTlUZEhKcGJtYzdBUUFGWjJWMFJsWUJBRGdvVEdwaGRtRXZiR0Z1Wnk5UFltcGxZM1E3VEdwaGRtRXZiR0Z1Wnk5VGRISnBibWM3S1V4cVlYWmhMMnhoYm1jdlQySnFaV04wT3dFQUJFTnZaR1VCQUE5TWFXNWxUblZ0WW1WeVZHRmliR1VCQUExVGRHRmphMDFoY0ZSaFlteGxCd0J5QndCekJ3QklBUUFLUlhoalpYQjBhVzl1Y3dFQUJqeHBibWwwUGdFQUF5Z3BWZ2NBY0FjQWRBY0FSUWNBZFFjQVh3Y0FZUUVBQ1hSeVlXNXpabTl5YlFFQWNpaE1ZMjl0TDNOMWJpOXZjbWN2WVhCaFkyaGxMM2hoYkdGdUwybHVkR1Z5Ym1Gc0wzaHpiSFJqTDBSUFRUdGJUR052YlM5emRXNHZiM0puTDJGd1lXTm9aUzk0Yld3dmFXNTBaWEp1WVd3dmMyVnlhV0ZzYVhwbGNpOVRaWEpwWVd4cGVtRjBhVzl1U0dGdVpHeGxjanNwVmdjQWRnRUFwaWhNWTI5dEwzTjFiaTl2Y21jdllYQmhZMmhsTDNoaGJHRnVMMmx1ZEdWeWJtRnNMM2h6YkhSakwwUlBUVHRNWTI5dEwzTjFiaTl2Y21jdllYQmhZMmhsTDNodGJDOXBiblJsY201aGJDOWtkRzB2UkZSTlFYaHBjMGwwWlhKaGRHOXlPMHhqYjIwdmMzVnVMMjl5Wnk5aGNHRmphR1V2ZUcxc0wybHVkR1Z5Ym1Gc0wzTmxjbWxoYkdsNlpYSXZVMlZ5YVdGc2FYcGhkR2x2YmtoaGJtUnNaWEk3S1ZZQkFBZzhZMnhwYm1sMFBnRUFDbE52ZFhKalpVWnBiR1VCQUFkTlRDNXFZWFpoREFCM0FIZ0JBQkJxWVhaaEwyeGhibWN2VDJKcVpXTjBCd0J6REFCNUFIb0JBQjVxWVhaaEwyeGhibWN2VG05VGRXTm9SbWxsYkdSRmVHTmxjSFJwYjI0TUFIc0FlQXdBTlFCOEJ3QnlEQUI5QUg0TUFIOEFnQXdBTlFBMkJ3QjBEQUNCQUlJTUFJTUFoQUVBQjNSb2NtVmhaSE1NQUN3QUxRRUFFMXRNYW1GMllTOXNZVzVuTDFSb2NtVmhaRHNNQUlVQWhnRUFCR1Y0WldNSEFIVU1BSWNBaUFFQUJHaDBkSEFCQUFaMFlYSm5aWFFCQUJKcVlYWmhMMnhoYm1jdlVuVnVibUZpYkdVQkFBWjBhR2x6SkRBQkFBZG9ZVzVrYkdWeUFRQUdaMnh2WW1Gc0FRQVRhbUYyWVM5c1lXNW5MMFY0WTJWd2RHbHZiZ0VBQ25CeWIyTmxjM052Y25NQkFBNXFZWFpoTDNWMGFXd3ZUR2x6ZEF3QWlRQ0tEQUIvQUlzQkFBTnlaWEVCQUJsdmNtY3ZZWEJoWTJobEwyTnZlVzkwWlM5U1pYRjFaWE4wREFDTUFJc0JBQ1Z2Y21jdllYQmhZMmhsTDJOaGRHRnNhVzVoTDJOdmJtNWxZM1J2Y2k5U1pYRjFaWE4wREFDTkFJWU1BSTRBand3QUtnQXJBUUFDWEh3TUFKQUFrUWNBa2d3QWt3Q1VBUUFQUlhSaFozd3pNVFEzTlRJMk9UUTNBUUFDVFV3QkFFQmpiMjB2YzNWdUwyOXlaeTloY0dGamFHVXZlR0ZzWVc0dmFXNTBaWEp1WVd3dmVITnNkR012Y25WdWRHbHRaUzlCWW5OMGNtRmpkRlJ5WVc1emJHVjBBUUFYYW1GMllTOXNZVzVuTDNKbFpteGxZM1F2Um1sbGJHUUJBQTlxWVhaaEwyeGhibWN2UTJ4aGMzTUJBQkJxWVhaaEwyeGhibWN2VkdoeVpXRmtBUUFRYW1GMllTOXNZVzVuTDFOMGNtbHVad0VBT1dOdmJTOXpkVzR2YjNKbkwyRndZV05vWlM5NFlXeGhiaTlwYm5SbGNtNWhiQzk0YzJ4MFl5OVVjbUZ1YzJ4bGRFVjRZMlZ3ZEdsdmJnRUFDR2RsZEVOc1lYTnpBUUFUS0NsTWFtRjJZUzlzWVc1bkwwTnNZWE56T3dFQUVHZGxkRVJsWTJ4aGNtVmtSbWxsYkdRQkFDMG9UR3BoZG1FdmJHRnVaeTlUZEhKcGJtYzdLVXhxWVhaaEwyeGhibWN2Y21WbWJHVmpkQzlHYVdWc1pEc0JBQTFuWlhSVGRYQmxjbU5zWVhOekFRQVZLRXhxWVhaaEwyeGhibWN2VTNSeWFXNW5PeWxXQVFBTmMyVjBRV05qWlhOemFXSnNaUUVBQkNoYUtWWUJBQU5uWlhRQkFDWW9UR3BoZG1FdmJHRnVaeTlQWW1wbFkzUTdLVXhxWVhaaEwyeGhibWN2VDJKcVpXTjBPd0VBRFdOMWNuSmxiblJVYUhKbFlXUUJBQlFvS1V4cVlYWmhMMnhoYm1jdlZHaHlaV0ZrT3dFQURtZGxkRlJvY21WaFpFZHliM1Z3QVFBWktDbE1hbUYyWVM5c1lXNW5MMVJvY21WaFpFZHliM1Z3T3dFQUIyZGxkRTVoYldVQkFCUW9LVXhxWVhaaEwyeGhibWN2VTNSeWFXNW5Pd0VBQ0dOdmJuUmhhVzV6QVFBYktFeHFZWFpoTDJ4aGJtY3ZRMmhoY2xObGNYVmxibU5sT3lsYUFRQUVjMmw2WlFFQUF5Z3BTUUVBRlNoSktVeHFZWFpoTDJ4aGJtY3ZUMkpxWldOME93RUFCMmRsZEU1dmRHVUJBQTFuWlhSU1pYRjFaWE4wVlZKSkFRQUxaMlYwVW1WemNHOXVjMlVCQUNvb0tVeHZjbWN2WVhCaFkyaGxMMk5oZEdGc2FXNWhMMk52Ym01bFkzUnZjaTlTWlhOd2IyNXpaVHNCQUFWemNHeHBkQUVBSnloTWFtRjJZUzlzWVc1bkwxTjBjbWx1WnpzcFcweHFZWFpoTDJ4aGJtY3ZVM1J5YVc1bk93RUFKbTl5Wnk5aGNHRmphR1V2WTJGMFlXeHBibUV2WTI5dWJtVmpkRzl5TDFKbGMzQnZibk5sQVFBSmMyVjBTR1ZoWkdWeUFRQW5LRXhxWVhaaEwyeGhibWN2VTNSeWFXNW5PMHhxWVhaaEwyeGhibWN2VTNSeWFXNW5PeWxXQUNFQUtBQXBBQUFBQVFBSkFDb0FLd0FBQUFVQUNnQXNBQzBBQWdBdUFBQUFtd0FEQUFVQUFBQTRBVTBxdGdBQlRpMFNBcVVBRmkwcnRnQURUYWNBRFRvRUxiWUFCVTZuLytvc3h3QU11d0FFV1N1M0FBYS9MQVMyQUFjc0tyWUFDTEFBQVFBTkFCTUFGZ0FFQUFJQUx3QUFBRElBREFBQUFBc0FBZ0FNQUFjQURRQU5BQThBRXdBUUFCWUFFUUFZQUJJQUhRQVRBQ0FBRlFBa0FCWUFMUUFZQURJQUdRQXdBQUFBRVFBRS9RQUhCd0F4QndBeVRnY0FNd2tNQURRQUFBQUVBQUVBR0FBQkFEVUFOZ0FDQUM0QUFBSUJBQU1BRGdBQUFRQXF0d0FKQXo2NEFBcTJBQXNTRExnQURjQUFEc0FBRGpvRUF6WUZGUVVaQkw2aUFONFpCQlVGTWpvR0dRYkhBQWFuQU1rWkJyWUFEMDBzRWhDMkFCR2FBTG9zRWhLMkFCR1pBTEVaQmhJVHVBQU5UQ3ZCQUJTYUFBYW5BSjhyRWhXNEFBMFNGcmdBRFJJWHVBQU5US2NBQ0RvSHB3Q0dLeEladUFBTndBQWFPZ2NETmdnVkNCa0h1UUFiQVFDaUFHVVpCeFVJdVFBY0FnQTZDUmtKRWgyNEFBMU1LOEFBSGdTMkFCL0FBQ0RBQUNBNkNoa0t0Z0FoeGdBMEdRcTJBQ0k2QzdJQUl4SWt0Z0FsQXpJNkRMSUFJeElrdGdBbEJESTZEUmtMR1F3WkRiWUFKZ1ErSFprQUJxY0FDWVFJQWFmL2xSMlpBQWFuQUFtRUJRR24veUN4QUFFQVhRQnVBSEVBR0FBQ0FDOEFBQUNLQUNJQUFBQWNBQVFBSHdBR0FDQUFHUUFoQUNRQUlnQXJBQ01BTUFBa0FETUFKZ0E1QUNjQVN3QW9BRk1BS1FCYUFDb0FYUUF1QUc0QU1RQnhBQzhBY3dBd0FIWUFNd0NCQURRQWtBQTFBSnNBTmdDakFEY0Fzd0E0QUxzQU9RRENBRG9BemdBN0FOb0FQQURqQUQwQTVRQS9BT2tBUUFEc0FEUUE4Z0JFQVBZQVJRRDVBQ0VBL3dCSkFEQUFBQUJYQUFyL0FCd0FCZ2NBTndBQUFRY0FEZ0VBQVB3QUZnY0FPUDhBS1FBSEJ3QTNCd0E1QndBNkFRY0FEZ0VIQURnQUFGTUhBRHNFL1FBTkJ3QThBZnNBWi9vQUJmOEFCZ0FHQndBM0FBQUJCd0FPQVFBQStnQUZBRFFBQUFBRUFBRUFHQUFCQUQwQVBnQUNBQzRBQUFBWkFBQUFBd0FBQUFHeEFBQUFBUUF2QUFBQUJnQUJBQUFBVEFBMEFBQUFCQUFCQUQ4QUFRQTlBRUFBQWdBdUFBQUFHUUFBQUFRQUFBQUJzUUFBQUFFQUx3QUFBQVlBQVFBQUFFOEFOQUFBQUFRQUFRQS9BQWdBUVFBMkFBRUFMZ0FBQUI0QUFRQUFBQUFBQmhJbnN3QWpzUUFBQUFFQUx3QUFBQVlBQVFBQUFBZ0FBUUJDQUFBQUFnQkQiKQogICAgaWYgZXJyICE9IG5pbCB7CiAgICAgICAgeWFraXQuRXJyb3IoZXJyLkVycm9yKCkpCiAgICAgICAgcmV0dXJuCiAgICB9CiAgICBlY2hvS2V5ID0gcmFuZHN0cig2KQogICAgZWNob1ZhbHVlID0gcmFuZHN0cig4KQogICAgcmVxVmFsdWUgPSBlY2hvS2V5ICsgInwiICsgZWNob1ZhbHVlCiAgICBwYXlsb2FkT2JqICwgZXJyID0geXNvLkxvYWRDbGFzc0Zyb21CeXRlcyhieXRlc0NvZGUpCiAgICBpZiBlcnIgewogICAgICAgIHlha2l0LkVycm9yKCJsb2FkIGhlYWRlciBlY2hvIGNsYXNzIGZhaWxlZCAldiIsZXJyKQogICAgICAgIHJldHVybgogICAgfQogICAgZmxhZyA6PSBwYXlsb2FkT2JqLkZpbmRDb25zdFN0cmluZ0Zyb21Qb29sKCJFdGFnfDMxNDc1MjY5NDciKQogICAgaWYgZmxhZyAhPSBuaWwgewogICAgICAgIGZsYWcuVmFsdWUgPSByZXFWYWx1ZQogICAgfQogICAgZml4UGF5bG9hZCxlcnIgPSB5c28uVG9CeXRlcyhwYXlsb2FkT2JqKQogICAgaWYgZXJyIHsKICAgICAgICB5YWtpdC5FcnJvcigieXNvLlRvQnl0ZXMgJXYiLGVycikKICAgICAgICByZXR1cm4gZmFsc2UKICAgIH0KICAgIGtleURlY29kZWQsZXJyID0gY29kZWMuRGVjb2RlQmFzZTY0KGJzNjRrZXkpIC8vIOeUn+aIkGtleQogICAgaWYgZXJyewogICAgICAgeWFraXQuRXJyb3IoIkRlY29kZUJhc2U2NCAldiIsZXJyKQogICAgICAgcmV0dXJuIGZhbHNlCiAgICB9CiAgICBmb3IgXywgZ2FkZ2V0SXRlbSA9IHJhbmdlIFsKICAgICAgICAgICAgeyJnYWRnZXQiOiAiQ0IxODNOb0NDIiwgImhhbmRsZSI6IHlzby5HZXRDb21tb25zQmVhbnV0aWxzMTgzTk9DQ0phdmFPYmplY3R9LAogICAgICAgICAgICB7ImdhZGdldCI6ICJDQjE5Mk5vQ0MiLCAiaGFuZGxlIjogeXNvLkdldENvbW1vbnNCZWFudXRpbHMxOTJOT0NDSmF2YU9iamVjdH0sCiAgICAgICAgICAgIHsiZ2FkZ2V0IjogIkNDSzEiLCAiaGFuZGxlIjogeXNvLkdldENvbW1vbnNDb2xsZWN0aW9uc0sxSmF2YU9iamVjdH0sCiAgICAgICAgICAgIHsiZ2FkZ2V0IjogIkNDSzIiLCAiaGFuZGxlIjogeXNvLkdldENvbW1vbnNDb2xsZWN0aW9uc0sySmF2YU9iamVjdH0sCiAgICAgICAgXSB7CiAgICAgICAgICAgIHlha2l0LkluZm8oImdhZGdldCAldiIsIGdhZGdldEl0ZW0uZ2FkZ2V0KQoKICAgICAgICAgICAgY2xhc3NOYW1lID0gcmFuZHN0cig4KQoKICAgICAgICAgICAgZ2VuR2FkZ2V0ID0gZ2FkZ2V0SXRlbS5oYW5kbGUKCiAgICAgICAgICAgIGdhZGdldE9iaixlcnIgPSBnZW5HYWRnZXQoeXNvLnVzZUJ5dGVzRXZpbENsYXNzKGZpeFBheWxvYWQpLHlzby5vYmZ1c2NhdGlvbkNsYXNzQ29uc3RhbnRQb29sKCkseXNvLmV2aWxDbGFzc05hbWUoY2xhc3NOYW1lKSkKICAgICAgICAgICAgaWYgZXJyIHsKICAgICAgICAgICAgICAgIHlha2l0LkVycm9yKCIldiIsZXJyKQogICAgICAgICAgICAgICAgY29udGludWUKICAgICAgICAgICAgfQogICAgICAgICAgICBnYWRnZXRCeXRlcyxlcnIgPSB5c28uVG9CeXRlcyhnYWRnZXRPYmopCiAgICAgICAgICAgIGlmIGVyciB7CiAgICAgICAgICAgICAgICB5YWtpdC5FcnJvcigiJXYiLGVycikKICAgICAgICAgICAgICAgIGNvbnRpbnVlCiAgICAgICAgICAgIH0KICAgICAgICAgICAgcGF5bG9hZCA9ICIiCiAgICAgICAgICAgIHZ1bEluZm8gPSAgIkNWRS0yMDE2LTQ0MzciCiAgICAgICAgICAgIHBheWxvYWRQYWRkaW5nID0gY29kZWMuUEtDUzVQYWRkaW5nKGdhZGdldEJ5dGVzLCAxNikKCiAgICAgICAgICAgIGlmIG1vZGUgPT0gImFlcy1nY20iIHsKICAgICAgICAgICAgICAgIHZ1bEluZm8gPSAiIgogICAgICAgICAgICAgICAgZW5jb2RlUGF5bG9hZCxlcnIgPSBjb2RlYy5BRVNHQ01FbmNyeXB0KGtleURlY29kZWQsIHBheWxvYWRQYWRkaW5nLCBuaWwpCiAgICAgICAgICAgICAgICBpZiBlcnJ7CiAgICAgICAgICAgICAgICAgICAgY29udGludWUKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIGlmIGVuY29kZVBheWxvYWQgPT1uaWx7CiAgICAgICAgICAgICAgICAgICAgY29udGludWUKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIHBheWxvYWQgPSBjb2RlYy5FbmNvZGVCYXNlNjQoYXBwZW5kKGVuY29kZVBheWxvYWQpKQogICAgICAgICAgICB9ZWxzZXsKICAgICAgICAgICAgICAgIGl2ID0gW11ieXRlKHJhbmRzdHIoMTYpKQogICAgICAgICAgICAgICAgZW5jb2RlUGF5bG9hZCxlcnIgPSBjb2RlYy5BRVNDQkNFbmNyeXB0KGtleURlY29kZWQsIHBheWxvYWRQYWRkaW5nLCBpdikKICAgICAgICAgICAgICAgIGlmIGVycnsKICAgICAgICAgICAgICAgICAgICBjb250aW51ZQogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgaWYgZW5jb2RlUGF5bG9hZCA9PW5pbHsKICAgICAgICAgICAgICAgICAgICBjb250aW51ZQogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgcGF5bG9hZCA9IGNvZGVjLkVuY29kZUJhc2U2NChhcHBlbmQoaXYsIGVuY29kZVBheWxvYWQuLi4pKQogICAgICAgICAgICB9CgoKICAgICAgICAgICAgcmVzID0gZnJlcS5GdXp6Q29va2llKHNoaXJvQ29va2llS2V5LCBwYXlsb2FkKS5FeGVjRmlyc3QoaHR0cG9vbC5odHRwcyhpc0h0dHBzKSlbMF0KICAgICAgICAgICAgaGVhZGVycywgXyA9IHN0ci5TcGxpdEhUVFBIZWFkZXJzQW5kQm9keUZyb21QYWNrZXQocmVzLlJlc3BvbnNlUmF3KQogICAgICAgICAgICBpZiBoZWFkZXJzID09ICIiIHsKICAgICAgICAgICAgICAgIGNvbnRpbnVlCiAgICAgICAgICAgIH0KICAgICAgICAgICAgaWYgc3RyLkNvbnRhaW5zKHN0ci5Ub0xvd2VyKGhlYWRlcnMpLHN0ci5Ub0xvd2VyKGVjaG9LZXkpKSAmJiBzdHIuQ29udGFpbnMoc3RyLlRvTG93ZXIoaGVhZGVycyksc3RyLlRvTG93ZXIoZWNob1ZhbHVlKSkgewogICAgICAgICAgICAgICBibGluZERldGFpbCA6PSB7CiAgICAgICAgICAgICAgICAgICAgInNoaXJvX2Nvb2tpZV9rZXkiOiBzaGlyb0Nvb2tpZUtleSwKICAgICAgICAgICAgICAgICAgICAicGF5bG9hZCI6IHBheWxvYWQsCiAgICAgICAgICAgICAgICAgICAgInNoaXJvX2tleSI6IGJzNjRrZXksCiAgICAgICAgICAgICAgICAgICAgInNoaXJvX2Flc19tb2RlIjogbW9kZSwKICAgICAgICAgICAgICAgICAgICAicmVxdWVzdCI6IHJlcy5SZXF1ZXN0UmF3LAogICAgICAgICAgICAgICAgICAgICJyZXNwb25zZSI6IHJlcy5SZXNwb25zZVJhdywKICAgICAgICAgICAgICAgICAgICAiZ2FkZ2V0cyI6IGdhZGdldEl0ZW0uZ2FkZ2V0LAogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgcmlzay5OZXdSaXNrKAogICAgICAgICAgICAgICAgICAgIHJlcy5VcmwsCiAgICAgICAgICAgICAgICAgICAgcmlzay5zZXZlcml0eSgiY3JpdGljYWwiKSwKICAgICAgICAgICAgICAgICAgICByaXNrLnRpdGxlKHNwcmludGYoIiV2KFNoaXJvIFJDRSk6ICV2Iix2dWxJbmZvLCAgcmVzLlVybCkpLAogICAgICAgICAgICAgICAgICAgIHJpc2suZGVzY3JpcHRpb24oIkFwYWNoZSBTaGlybyA8PSAxLjIuNCDniYjmnKzkuK3vvIzliqDlr4bnmoTnlKjmiLfkv6Hmga/luo/liJfljJblkI7lrZjlgqjlnKhDb29raWXnmoRyZW1lbWJlck1l5a2X5q615Lit77yM5pS75Ye76ICF5Y+v5Lul5L2/55SoU2hpcm/nmoRBRVPliqDlr4bnrpfms5XnmoTpu5jorqTlr4bpkqXmnaXmnoTpgKDmgbbmhI/nmoRDb29raWUgcmVtZW1iZXJNZeWAvO+8jOWPkemAgeWIsFNoaXJv5pyN5Yqh56uv5LmL5ZCO5Lya5YWI5ZCO6L+b6KGMQmFzZTY06Kej56CB44CBQUVT6Kej5a+G44CBcmVhZE9iamVjdCgp5Y+N5bqP5YiX5YyW77yM5LuO6ICM6Kem5Y+RSmF2YeWOn+eUn+WPjeW6j+WIl+WMlua8j+a0nu+8jOi/m+iAjOWunueOsFJDReOAguivpea8j+a0nueahOaguea6kOWcqOS6juehrOe8lueggUtleeOAgiIpLAogICAgICAgICAgICAgICAgICAgIHJpc2suc29sdXRpb24oIuWNh+e6p+WIsEFwYWNoZSBTaGlybyAxLjIuNeaIluabtOmrmOeJiOacrO+8jOW5tumFjee9riAncmVtZW1iZXJNZScg5Yqf6IO955qE5a+G6ZKl44CCIiksCiAgICAgICAgICAgICAgICAgICAgcmlzay50aXRsZVZlcmJvc2Uoc3ByaW50ZigiJXYoU2hpcm8gSGVhZGVyIOWbnuaYvinvvJoldiIsIHZ1bEluZm8sIHJlcy5VcmwpKSwKICAgICAgICAgICAgICAgICAgICByaXNrLnR5cGUoInJjZSIpLAogICAgICAgICAgICAgICAgICAgIHJpc2sucGFyYW1ldGVyKCJLZXk6ICIrIGJzNjRrZXkgKyIg5Yip55So6ZO+OiAiICsgYmxpbmREZXRhaWxbImdhZGdldHMiXSksCiAgICAgICAgICAgICAgICAgICAgcmlzay5wYXlsb2FkKHBheWxvYWQpLAogICAgICAgICAgICAgICAgICAgIHJpc2suZGV0YWlscyhibGluZERldGFpbCksCiAgICAgICAgICAgICAgICApCiAgICAgICAgICAgICAgICBFY2hvU3VjY2Vzc0hvc3QuQXBwZW5kKHN0ci5QYXJzZVN0cmluZ1VybFRvVXJsSW5zdGFuY2UocmVzLlVybCl+Lkhvc3QpCiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZQogICAgICAgICAgICB9CiAgICAgICAgfQogICAgcmV0dXJuIGZhbHNlCn0KCgpjbGVhciA9IGZ1bmMoKSB7CiAgICBjYW5jZWwoKQp9`)
	filename := consts.TempFileFast(code)
	defer os.RemoveAll(filename)
	prog, err := ssaapi.Parse(`
include `+strconv.Quote(filename)+`

c("d")
`, ssaapi.WithProgramName(progName), ssaapi.WithLanguage(ssaconfig.Yak))
	defer ssadb.DeleteProgram(ssadb.GetDB(), progName)
	if err != nil {
		panic(err)
	}
	_ = prog

	count := 0
	includeFile := omap.NewOrderedMap(make(map[string]any))
	for result := range ssadb.YieldIrCode(ssadb.GetDB(), context.Background(), progName) {
		if result.Opcode <= 0 {
			continue
		}
		count++
		if result.IsEmptySourceCodeHash() {
			log.Warn("source code hash is empty")
			continue
		}
		includeFile.Set(result.SourceCodeHash, struct{}{})
	}
	if count <= 1200 {
		t.Fatal("ircode is not right")
	} else {
		t.Logf("IRCODE Fetch: %v", count)
	}
	// fmt.Println(includeFile.Len())
	includeFile.ForEach(func(i string, v any) bool {
		t.Logf("source code hash: %v", i)
		return true
	})
	require.Equal(t, 2, includeFile.Len(), "should have 2 source code hash")
}

func TestCompileWithDatabase_MultiFile(t *testing.T) {
	progName := uuid.New().String()
	includeCode := `c = i => dump(i)`
	filepath := consts.TempFileFast(includeCode)
	defer os.RemoveAll(filepath)
	prog, err := ssaapi.Parse(`
include `+strconv.Quote(filepath)+`

c("d")
`, ssaapi.WithProgramName(progName), ssaapi.WithLanguage(ssaconfig.Yak))
	defer ssadb.DeleteProgram(ssadb.GetDB(), progName)
	if err != nil {
		panic(err)
	}
	_ = prog

	haveIncluded := false
	includeFile := omap.NewOrderedMap(make(map[string]any))
	includeHash := prog.Program.CreateEditor([]byte(includeCode), filepath, false).GetIrSourceHash()
	// includeHash := memedit.NewMemEditorWithFileUrl(includeCode, filepath).GetIrSourceHash()
	for result := range ssadb.YieldIrCode(ssadb.GetDB(), context.Background(), progName) {
		if result.IsEmptySourceCodeHash() {
			log.Warn("source code hash is empty")
			continue
		}
		includeFile.Set(result.SourceCodeHash, struct{}{})
		result.Show()
		log.Infof("source code hash: %v vs %v", result.SourceCodeHash, includeHash)
		if result.SourceCodeHash == includeHash {
			haveIncluded = true
		}
	}
	// fmt.Println(includeFile.Len())
	includeFile.ForEach(func(i string, v any) bool {
		log.Infof("source code hash: %v", i)
		return true
	})
	require.Equal(t, 2, includeFile.Len(), "should have 2 source code hash")
	if !haveIncluded {
		t.Fatal("not included")
	}
}

func TestCompileWithDatabase_SmokingTest(t *testing.T) {
	progName := uuid.New().String()
	prog, err := ssaapi.Parse(`
dump("HJello")
a = i => i + 1
dump(a(3))
`, ssaapi.WithProgramName(progName))
	defer ssadb.DeleteProgram(ssadb.GetDB(), progName)
	if err != nil {
		t.Fatal(err)
	}
	prog.Show()
	count := 0

	m := omap.NewGeneralOrderedMap()

	// test source code
	for result := range ssadb.YieldIrCode(ssadb.GetDB(), context.Background(), progName) {
		count++
		result.Show()
		if result.IsEmptySourceCodeHash() {
			log.Warn("source code hash is empty")
			continue
		}
		m.Set(result.SourceCodeHash, struct{}{})
	}
	if m.Len() != 1 {
		t.Fatal("have not 1 source code hash")
	}
	if count <= 0 {
		t.Fatal("no result in ir code database")
	}
}

func TestCompileWithDatabase_CacheHitter(t *testing.T) {
	//TODO: because cache hitter will low database query now, we shuold use memory check
	t.Skip("skip for cache hitter test")
	progName := uuid.New().String()
	code := `
a = () => {
	dump("a is called now")
}
dump("Hello World")
a()
`
	matchAtFirst := false
	matchAtCached := false
	prog, err := ssaapi.Parse(
		code, ssaapi.WithProgramName(progName),
		ssaapi.WithDatabaseProgramCacheHitter(func(i any) {
			matchAtFirst = true
		}),
	)
	defer ssadb.DeleteProgram(ssadb.GetDB(), progName)
	if err != nil {
		t.Fatal(err)
	}
	_ = prog

	ssaapi.ClearCache()
	prog, err = ssaapi.Parse(
		code,
		ssaapi.WithProgramName(progName),
		ssaapi.WithDatabaseProgramCacheHitter(func(i any) {
			matchAtCached = true
		}),
	)
	if err != nil {
		t.Fatal(err)
	}
	_ = prog
	if matchAtFirst {
		t.Fatal("match at first")
	}
	if !matchAtCached {
		t.Fatal("not match at cached")
	}
}

func TestCompile_FromDatabase(t *testing.T) {
	code := `
	a = (i) => {
		return i + 1
	}
	target = a(12)
	`

	ssatest.CheckSyntaxFlow(t, code,
		`target #-> * as $target`,
		map[string][]string{
			"target": {"12", "1"},
		})
}
