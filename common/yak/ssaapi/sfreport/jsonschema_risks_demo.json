{
  "report_type": "irify",
  "engine_version": "dev",
  "report_time": "2025-08-08T11:17:50.344591+08:00",
  "program_name": "7a8f7821-0d17-4501-9f10-5b141c0e74a6",
  "RiskNums": 1,
  "Rules": [
    {
      "rule_name": "",
      "language": "",
      "description": "### 漏洞描述\n\n1. **漏洞原理**\n   路径 Traversal（也称为目录遍历）漏洞允许攻击者通过操纵文件路径参数，访问或执行服务器上受限目录之外的任意文件。在 Java 应用程序中，当应用程序直接使用用户提供的文件名或路径片段构建文件操作路径，且未对用户输入进行充分验证或清理时（例如去除 `../` 或其他目录遍历符），攻击者即可构造包含 `../` 等特殊字符的输入，向上遍历目录结构，访问位于应用程序根目录之外的文件，如配置文件、源代码、敏感数据文件甚至系统文件（如 `/etc/passwd`）。\n\n2. **触发场景**\n   以下代码示例未对用户输入的 `fileName` 进行充分验证，直接将其拼接在基本路径后创建文件对象并进行读取，存在路径穿越风险：\n   ```java\n   import java.io.File;\n   import java.io.FileReader;\n   import java.io.IOException;\n   import java.io.OutputStream;\n   import javax.servlet.ServletException;\n   import javax.servlet.http.HttpServlet;\n   import javax.servlet.http.HttpServletRequest;\n   import javax.servlet.http.HttpServletResponse;\n\n   public class InsecureFileReaderServlet extends HttpServlet {\n       @Override\n       protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n           String fileName = request.getParameter(\"file\");\n           String filePath = \"path/to/safe/directory/\" + fileName; // 未对fileName进行检查或清理\n\n           File file = new File(filePath);\n           // ... 后续文件读取操作\n       }\n   }\n   ```\n   攻击者可以通过构造 `fileName` 为 `../../../../etc/passwd` 来尝试读取系统密码文件。\n\n3. **潜在影响**\n   - **信息泄露**: 攻击者可以读取任意敏感文件，包括配置文件、源代码、用户上传文件、私钥等。\n   - **文件篡改或删除**: 如果应用程序允许写入或删除文件，攻击者可能利用此漏洞修改或删除服务器上的关键文件，导致拒绝服务或进一步入侵。\n   - **远程代码执行（RCE）**: 在某些情况下，如果攻击者能够上传或修改可执行文件并诱导服务器执行，可能导致远程代码执行。\n   - **进一步攻击**: 获取的敏感信息可能被用于进行更复杂的攻击，如提权、内网渗透等。",
      "solution": "",
      "content": "desc(\n\ttitle: \"Check Java Path Traversal Vulnerability\"\n\ttitle_zh: \"检测Java路径穿越漏洞\"\n\ttype: vuln\n\trisk: \"path-traversal\"\n\tdesc: \u003c\u003c\u003cDESC\n### 漏洞描述\n\n1. **漏洞原理**\n   路径 Traversal（也称为目录遍历）漏洞允许攻击者通过操纵文件路径参数，访问或执行服务器上受限目录之外的任意文件。在 Java 应用程序中，当应用程序直接使用用户提供的文件名或路径片段构建文件操作路径，且未对用户输入进行充分验证或清理时（例如去除 `../` 或其他目录遍历符），攻击者即可构造包含 `../` 等特殊字符的输入，向上遍历目录结构，访问位于应用程序根目录之外的文件，如配置文件、源代码、敏感数据文件甚至系统文件（如 `/etc/passwd`）。\n\n2. **触发场景**\n   以下代码示例未对用户输入的 `fileName` 进行充分验证，直接将其拼接在基本路径后创建文件对象并进行读取，存在路径穿越风险：\n   ```java\n   import java.io.File;\n   import java.io.FileReader;\n   import java.io.IOException;\n   import java.io.OutputStream;\n   import javax.servlet.ServletException;\n   import javax.servlet.http.HttpServlet;\n   import javax.servlet.http.HttpServletRequest;\n   import javax.servlet.http.HttpServletResponse;\n\n   public class InsecureFileReaderServlet extends HttpServlet {\n       @Override\n       protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n           String fileName = request.getParameter(\"file\");\n           String filePath = \"path/to/safe/directory/\" + fileName; // 未对fileName进行检查或清理\n\n           File file = new File(filePath);\n           // ... 后续文件读取操作\n       }\n   }\n   ```\n   攻击者可以通过构造 `fileName` 为 `../../../../etc/passwd` 来尝试读取系统密码文件。\n\n3. **潜在影响**\n   - **信息泄露**: 攻击者可以读取任意敏感文件，包括配置文件、源代码、用户上传文件、私钥等。\n   - **文件篡改或删除**: 如果应用程序允许写入或删除文件，攻击者可能利用此漏洞修改或删除服务器上的关键文件，导致拒绝服务或进一步入侵。\n   - **远程代码执行（RCE）**: 在某些情况下，如果攻击者能够上传或修改可执行文件并诱导服务器执行，可能导致远程代码执行。\n   - **进一步攻击**: 获取的敏感信息可能被用于进行更复杂的攻击，如提权、内网渗透等。\nDESC\n\trule_id: \"7b798768-13e1-4dcd-8ab5-99a6f9635605\"\n\tsolution: \u003c\u003c\u003cSOLUTION\n### 修复建议\n\n#### 1. 验证和清理用户输入\n在将用户输入用于构建文件路径之前，必须进行严格的验证和清理，移除目录穿越字符（如 `../`）。可以使用正则表达式或特定的安全库函数。\n\n```java\n// 修复代码示例 (简单清理示例，更健壮的清理需要考虑多种编码和操作系统差异)\nString fileName = request.getParameter(\"file\");\nif (fileName != null) {\n    // 移除 '../' 和 '..\\\\' 等目录穿越字符\n    fileName = fileName.replace(\"../\", \"\").replace(\"..\\\\\", \"\");\n    // 还可以进一步限制文件名只能包含字母、数字和特定安全字符\n    if (!fileName.matches(\"^[a-zA-Z0-9_\\\\-\\\\|\\\\.\\\\u4e00-\\\\u9fa5]+$\")) {\n         response.sendError(HttpServletResponse.SC_FORBIDDEN, \"Invalid file name.\");\n         return;\n    }\n}\nString filePath = \"path/to/safe/directory/\" + fileName;\n```\n\n#### 2. 使用标准库方法验证规范路径\n在文件操作前，获取文件的规范路径（Canonical Path），并检查该规范路径是否位于预期的安全目录下。这是更推荐和健壮的方法。\n\n```java\n// 修复代码示例 (使用 Canonical Path 验证)\nprivate static final String BASE_DIR = \"/usr/local/apache-tomcat/webapps/ROOT/safe_directory/\";\n\nprotected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n    String requestedFile = request.getParameter(\"file\");\n\n    // 构建潜在的完整路径\n    File file = new File(BASE_DIR, requestedFile);\n\n    // 获取文件的规范路径，此方法会解析并消除目录穿透符\n    String canonicalRequestedPath = file.getCanonicalPath();\n    String canonicalBaseDirPath = new File(BASE_DIR).getCanonicalPath();\n\n    // 检查文件的规范路径是否以安全目录的规范路径开头\n    if (!canonicalRequestedPath.startsWith(canonicalBaseDirPath)) {\n        response.sendError(HttpServletResponse.SC_FORBIDDEN, \"Access denied\");\n        return;\n    }\n\n    // ... 后续的文件读取操作，现在可以安全地使用 file 对象\n    if (!file.exists()) {\n        response.sendError(HttpServletResponse.SC_NOT_FOUND, \"File not found\");\n        return;\n    }\n    // ... 安全的文件操作\n}\n```\n\n#### 3. 限制文件访问范围\n配置应用程序或 Web 服务器，限制其只能访问特定的目录，或者使用沙箱机制隔离文件操作。\n\n#### 4. 使用白名单验证\n如果可能，不要接受用户输入的完整文件名或路径，而是让用户选择预定义的安全文件列表中的文件（白名单方式）。\nSOLUTION\n\treference: \u003c\u003c\u003cREFERENCE\n[CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal')](https://cwe.mitre.org/data/definitions/22.html)\nREFERENCE\n)\n\nfileName as $source\nFiles.copy() as $sink\n$sink #{\n    until:`* \u0026 $source`\n}-\u003e as $result\n\nalert $result for {\n\tdesc: \u003c\u003c\u003cCODE\n### 漏洞描述\n\n1. **漏洞原理**\n   路径 Traversal（也称为目录遍历）漏洞允许攻击者通过操纵文件路径参数，访问或执行服务器上受限目录之外的任意文件。在 Java 应用程序中，当应用程序直接使用用户提供的文件名或路径片段构建文件操作路径，且未对用户输入进行充分验证或清理时（例如去除 `../` 或其他目录遍历符），攻击者即可构造包含 `../` 等特殊字符的输入，向上遍历目录结构，访问位于应用程序根目录之外的文件，如配置文件、源代码、敏感数据文件甚至系统文件（如 `/etc/passwd`）。\n\n2. **触发场景**\n   以下代码示例未对用户输入的 `fileName` 进行充分验证，直接将其拼接在基本路径后创建文件对象并进行读取，存在路径穿越风险：\n   ```java\n   import java.io.File;\n   import java.io.FileReader;\n   import java.io.IOException;\n   import java.io.OutputStream;\n   import javax.servlet.ServletException;\n   import javax.servlet.http.HttpServlet;\n   import javax.servlet.http.HttpServletRequest;\n   import javax.servlet.http.HttpServletResponse;\n\n   public class InsecureFileReaderServlet extends HttpServlet {\n       @Override\n       protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n           String fileName = request.getParameter(\"file\");\n           String filePath = \"path/to/safe/directory/\" + fileName; // 未对fileName进行检查或清理\n\n           File file = new File(filePath);\n           // ... 后续文件读取操作\n       }\n   }\n   ```\n   攻击者可以通过构造 `fileName` 为 `../../../../etc/passwd` 来尝试读取系统密码文件。\n\n3. **潜在影响**\n   - **信息泄露**: 攻击者可以读取任意敏感文件，包括配置文件、源代码、用户上传文件、私钥等。\n   - **文件篡改或删除**: 如果应用程序允许写入或删除文件，攻击者可能利用此漏洞修改或删除服务器上的关键文件，导致拒绝服务或进一步入侵。\n   - **远程代码执行（RCE）**: 在某些情况下，如果攻击者能够上传或修改可执行文件并诱导服务器执行，可能导致远程代码执行。\n   - **进一步攻击**: 获取的敏感信息可能被用于进行更复杂的攻击，如提权、内网渗透等。\nCODE\n\tlevel: \"high\",\n\ttype: \"vuln\",\n\tmessage: \"Java代码中发现路径穿越漏洞，并且数据流中间没有进行任何过滤。\",\n\ttitle: \"Check Java Path Traversal Vulnerability\",\n\ttitle_zh: \"检测Java路径穿越漏洞\",\n\tsolution: \u003c\u003c\u003cCODE\n### 修复建议\n\n#### 1. 验证和清理用户输入\n在将用户输入用于构建文件路径之前，必须进行严格的验证和清理，移除目录穿越字符（如 `../`）。可以使用正则表达式或特定的安全库函数。\n\n```java\n// 修复代码示例 (简单清理示例，更健壮的清理需要考虑多种编码和操作系统差异)\nString fileName = request.getParameter(\"file\");\nif (fileName != null) {\n    // 移除 '../' 和 '..\\\\' 等目录穿越字符\n    fileName = fileName.replace(\"../\", \"\").replace(\"..\\\\\", \"\");\n    // 还可以进一步限制文件名只能包含字母、数字和特定安全字符\n    if (!fileName.matches(\"^[a-zA-Z0-9_\\\\-\\\\|\\\\.\\\\u4e00-\\\\u9fa5]+$\")) {\n         response.sendError(HttpServletResponse.SC_FORBIDDEN, \"Invalid file name.\");\n         return;\n    }\n}\nString filePath = \"path/to/safe/directory/\" + fileName;\n```\n\n#### 2. 使用标准库方法验证规范路径\n在文件操作前，获取文件的规范路径（Canonical Path），并检查该规范路径是否位于预期的安全目录下。这是更推荐和健壮的方法。\n\n```java\n// 修复代码示例 (使用 Canonical Path 验证)\nprivate static final String BASE_DIR = \"/usr/local/apache-tomcat/webapps/ROOT/safe_directory/\";\n\nprotected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n    String requestedFile = request.getParameter(\"file\");\n\n    // 构建潜在的完整路径\n    File file = new File(BASE_DIR, requestedFile);\n\n    // 获取文件的规范路径，此方法会解析并消除目录穿透符\n    String canonicalRequestedPath = file.getCanonicalPath();\n    String canonicalBaseDirPath = new File(BASE_DIR).getCanonicalPath();\n\n    // 检查文件的规范路径是否以安全目录的规范路径开头\n    if (!canonicalRequestedPath.startsWith(canonicalBaseDirPath)) {\n        response.sendError(HttpServletResponse.SC_FORBIDDEN, \"Access denied\");\n        return;\n    }\n\n    // ... 后续的文件读取操作，现在可以安全地使用 file 对象\n    if (!file.exists()) {\n        response.sendError(HttpServletResponse.SC_NOT_FOUND, \"File not found\");\n        return;\n    }\n    // ... 安全的文件操作\n}\n```\n\n#### 3. 限制文件访问范围\n配置应用程序或 Web 服务器，限制其只能访问特定的目录，或者使用沙箱机制隔离文件操作。\n\n#### 4. 使用白名单验证\n如果可能，不要接受用户输入的完整文件名或路径，而是让用户选择预定义的安全文件列表中的文件（白名单方式）。\nCODE\n}\n",
      "risks": [
        "c5153eae0789a64ae99b99a1ac7b4fec3a12bc17"
      ]
    }
  ],
  "Risks": {
    "c5153eae0789a64ae99b99a1ac7b4fec3a12bc17": {
      "id": 1323,
      "hash": "c5153eae0789a64ae99b99a1ac7b4fec3a12bc17",
      "title": "Check Java Path Traversal Vulnerability",
      "title_verbose": "检测Java路径穿越漏洞",
      "description": "### 漏洞描述\n\n1. **漏洞原理**\n   路径 Traversal（也称为目录遍历）漏洞允许攻击者通过操纵文件路径参数，访问或执行服务器上受限目录之外的任意文件。在 Java 应用程序中，当应用程序直接使用用户提供的文件名或路径片段构建文件操作路径，且未对用户输入进行充分验证或清理时（例如去除 `../` 或其他目录遍历符），攻击者即可构造包含 `../` 等特殊字符的输入，向上遍历目录结构，访问位于应用程序根目录之外的文件，如配置文件、源代码、敏感数据文件甚至系统文件（如 `/etc/passwd`）。\n\n2. **触发场景**\n   以下代码示例未对用户输入的 `fileName` 进行充分验证，直接将其拼接在基本路径后创建文件对象并进行读取，存在路径穿越风险：\n   ```java\n   import java.io.File;\n   import java.io.FileReader;\n   import java.io.IOException;\n   import java.io.OutputStream;\n   import javax.servlet.ServletException;\n   import javax.servlet.http.HttpServlet;\n   import javax.servlet.http.HttpServletRequest;\n   import javax.servlet.http.HttpServletResponse;\n\n   public class InsecureFileReaderServlet extends HttpServlet {\n       @Override\n       protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n           String fileName = request.getParameter(\"file\");\n           String filePath = \"path/to/safe/directory/\" + fileName; // 未对fileName进行检查或清理\n\n           File file = new File(filePath);\n           // ... 后续文件读取操作\n       }\n   }\n   ```\n   攻击者可以通过构造 `fileName` 为 `../../../../etc/passwd` 来尝试读取系统密码文件。\n\n3. **潜在影响**\n   - **信息泄露**: 攻击者可以读取任意敏感文件，包括配置文件、源代码、用户上传文件、私钥等。\n   - **文件篡改或删除**: 如果应用程序允许写入或删除文件，攻击者可能利用此漏洞修改或删除服务器上的关键文件，导致拒绝服务或进一步入侵。\n   - **远程代码执行（RCE）**: 在某些情况下，如果攻击者能够上传或修改可执行文件并诱导服务器执行，可能导致远程代码执行。\n   - **进一步攻击**: 获取的敏感信息可能被用于进行更复杂的攻击，如提权、内网渗透等。",
      "solution": "### 修复建议\n\n#### 1. 验证和清理用户输入\n在将用户输入用于构建文件路径之前，必须进行严格的验证和清理，移除目录穿越字符（如 `../`）。可以使用正则表达式或特定的安全库函数。\n\n```java\n// 修复代码示例 (简单清理示例，更健壮的清理需要考虑多种编码和操作系统差异)\nString fileName = request.getParameter(\"file\");\nif (fileName != null) {\n    // 移除 '../' 和 '..\\\\' 等目录穿越字符\n    fileName = fileName.replace(\"../\", \"\").replace(\"..\\\\\", \"\");\n    // 还可以进一步限制文件名只能包含字母、数字和特定安全字符\n    if (!fileName.matches(\"^[a-zA-Z0-9_\\\\-\\\\|\\\\.\\\\u4e00-\\\\u9fa5]+$\")) {\n         response.sendError(HttpServletResponse.SC_FORBIDDEN, \"Invalid file name.\");\n         return;\n    }\n}\nString filePath = \"path/to/safe/directory/\" + fileName;\n```\n\n#### 2. 使用标准库方法验证规范路径\n在文件操作前，获取文件的规范路径（Canonical Path），并检查该规范路径是否位于预期的安全目录下。这是更推荐和健壮的方法。\n\n```java\n// 修复代码示例 (使用 Canonical Path 验证)\nprivate static final String BASE_DIR = \"/usr/local/apache-tomcat/webapps/ROOT/safe_directory/\";\n\nprotected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n    String requestedFile = request.getParameter(\"file\");\n\n    // 构建潜在的完整路径\n    File file = new File(BASE_DIR, requestedFile);\n\n    // 获取文件的规范路径，此方法会解析并消除目录穿透符\n    String canonicalRequestedPath = file.getCanonicalPath();\n    String canonicalBaseDirPath = new File(BASE_DIR).getCanonicalPath();\n\n    // 检查文件的规范路径是否以安全目录的规范路径开头\n    if (!canonicalRequestedPath.startsWith(canonicalBaseDirPath)) {\n        response.sendError(HttpServletResponse.SC_FORBIDDEN, \"Access denied\");\n        return;\n    }\n\n    // ... 后续的文件读取操作，现在可以安全地使用 file 对象\n    if (!file.exists()) {\n        response.sendError(HttpServletResponse.SC_NOT_FOUND, \"File not found\");\n        return;\n    }\n    // ... 安全的文件操作\n}\n```\n\n#### 3. 限制文件访问范围\n配置应用程序或 Web 服务器，限制其只能访问特定的目录，或者使用沙箱机制隔离文件操作。\n\n#### 4. 使用白名单验证\n如果可能，不要接受用户输入的完整文件名或路径，而是让用户选择预定义的安全文件列表中的文件（白名单方式）。",
      "severity": "high",
      "risk_type": "path-traversal",
      "details": "Java代码中发现路径穿越漏洞，并且数据流中间没有进行任何过滤。",
      "cve": "",
      "time": "2025-08-08T11:17:50.3410823+08:00",
      "language": "java",
      "code_source_url": "FileUploader.java",
      "line": 24,
      "code_range": "{\"url\":\"/7a8f7821-0d17-4501-9f10-5b141c0e74a6/FileUploader.java\",\"start_line\":24,\"start_column\":62,\"end_line\":24,\"end_column\":77,\"source_code_line\":20}",
      "rule_name": "",
      "program_name": "7a8f7821-0d17-4501-9f10-5b141c0e74a6",
      "latest_disposal_status": "not_set",
      "data_flow_paths": [
        {
          "path_id": "path_1323",
          "description": "Data flow path for path-traversal vulnerability in 7a8f7821-0d17-4501-9f10-5b141c0e74a6",
          "nodes": [
            {
              "node_id": "n2",
              "ir_code": "add(add(Undefined-System.currentTimeMillis(Undefined-System), \"_\"), Parameter-fileName)",
              "source_code": "        }\n\n        // 5. 生成安全的文件名（避免覆盖现有文件）\n        String safeFileName = System.currentTimeMillis() + \"_\" + fileName;\n        Path destination = uploadDir.resolve(safeFileName);\n\n        // 6. 保存文件\n",
              "source_code_start": 0,
              "code_range": {
                "url": "/7a8f7821-0d17-4501-9f10-5b141c0e74a6/FileUploader.java",
                "start_line": 64,
                "start_column": 31,
                "end_line": 64,
                "end_column": 74,
                "source_code_line": 60
              }
            },
            {
              "node_id": "n4",
              "ir_code": "Undefined-uploadDir.resolve(Undefined-Paths.get(Paths,\"/var/www/uploads/\",phi(ternary_expression)[Parameter-subDir,\"\"]),add(add(Undefined-System.currentTimeMillis(Undefined-System), \"_\"), Parameter-fileName))",
              "source_code": "\n        // 5. 生成安全的文件名（避免覆盖现有文件）\n        String safeFileName = System.currentTimeMillis() + \"_\" + fileName;\n        Path destination = uploadDir.resolve(safeFileName);\n\n        // 6. 保存文件\n        Files.copy(inputStream, destination, StandardCopyOption.REPLACE_EXISTING);\n",
              "source_code_start": 0,
              "code_range": {
                "url": "/7a8f7821-0d17-4501-9f10-5b141c0e74a6/FileUploader.java",
                "start_line": 65,
                "start_column": 38,
                "end_line": 65,
                "end_column": 59,
                "source_code_line": 61
              }
            },
            {
              "node_id": "n6",
              "ir_code": "Undefined-Files.copy(Files,Parameter-inputStream,Undefined-uploadDir.resolve(Undefined-Paths.get(Paths,\"/var/www/uploads/\",phi(ternary_expression)[Parameter-subDir,\"\"]),add(add(Undefined-System.currentTimeMillis(Undefined-System), \"_\"), Parameter-fileName)),Undefined-StandardCopyOption.REPLACE_EXISTING)",
              "source_code": "        Path destination = uploadDir.resolve(safeFileName);\n\n        // 6. 保存文件\n        Files.copy(inputStream, destination, StandardCopyOption.REPLACE_EXISTING);\n\n        // 7. 返回相对路径（不暴露服务器绝对路径）\n        return Paths.get(subDir != nil ? subDir : \"\", safeFileName).toString();\n",
              "source_code_start": 0,
              "code_range": {
                "url": "/7a8f7821-0d17-4501-9f10-5b141c0e74a6/FileUploader.java",
                "start_line": 68,
                "start_column": 15,
                "end_line": 68,
                "end_column": 82,
                "source_code_line": 64
              }
            },
            {
              "node_id": "n8",
              "ir_code": "Undefined-Files.copy",
              "source_code": "        Path destination = uploadDir.resolve(safeFileName);\n\n        // 6. 保存文件\n        Files.copy(inputStream, destination, StandardCopyOption.REPLACE_EXISTING);\n\n        // 7. 返回相对路径（不暴露服务器绝对路径）\n        return Paths.get(subDir != nil ? subDir : \"\", safeFileName).toString();\n",
              "source_code_start": 0,
              "code_range": {
                "url": "/7a8f7821-0d17-4501-9f10-5b141c0e74a6/FileUploader.java",
                "start_line": 68,
                "start_column": 15,
                "end_line": 68,
                "end_column": 19,
                "source_code_line": 64
              }
            },
            {
              "node_id": "n9",
              "ir_code": "Files",
              "source_code": "import java.io.File;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\nimport java.nio.file.StandardCopyOption;\n",
              "source_code_start": 0,
              "code_range": {
                "url": "/7a8f7821-0d17-4501-9f10-5b141c0e74a6/FileUploader.java",
                "start_line": 4,
                "start_column": 1,
                "end_line": 4,
                "end_column": 28,
                "source_code_line": 0
              }
            },
            {
              "node_id": "n1",
              "ir_code": "Parameter-fileName",
              "source_code": "     * @throws IOException 如果上传过程中发生错误\n     * @throws SecurityException 如果检测到不安全操作\n     */\n    public static String uploadFile(InputStream inputStream, String fileName, String subDir)\n            throws IOException, SecurityException {\n\n        // 1. 检查文件名是否合法\n",
              "source_code_start": 0,
              "code_range": {
                "url": "/7a8f7821-0d17-4501-9f10-5b141c0e74a6/FileUploader.java",
                "start_line": 24,
                "start_column": 62,
                "end_line": 24,
                "end_column": 77,
                "source_code_line": 20
              }
            }
          ],
          "edges": [
            {
              "edge_id": "e0",
              "from_node_id": "n1",
              "to_node_id": "n2",
              "edge_type": "depend_on",
              "description": "The dependency edge in the dataflow, DependOn indicates which other values the current value depends on. For example, A DependOn B means Value A depends on Value B."
            },
            {
              "edge_id": "e1",
              "from_node_id": "n2",
              "to_node_id": "n4",
              "edge_type": "depend_on",
              "description": "The dependency edge in the dataflow, DependOn indicates which other values the current value depends on. For example, A DependOn B means Value A depends on Value B."
            },
            {
              "edge_id": "e2",
              "from_node_id": "n4",
              "to_node_id": "n6",
              "edge_type": "depend_on",
              "description": "The dependency edge in the dataflow, DependOn indicates which other values the current value depends on. For example, A DependOn B means Value A depends on Value B."
            },
            {
              "edge_id": "e3",
              "from_node_id": "n9",
              "to_node_id": "n8",
              "edge_type": "search-exact:copy",
              "description": "Search value from database exactly"
            },
            {
              "edge_id": "e4",
              "from_node_id": "n8",
              "to_node_id": "n6",
              "edge_type": "call",
              "description": "Function call"
            }
          ],
          "dot_graph": "strict digraph {\n    rankdir = \"BT\";\n    n4 [label=\"resolve(safeFileName)\"]\n    n6 [label=\"copy(inputStream, destination, StandardCopyOption.REPLACE_EXISTING)\"]\n    n8 [label=\"copy\"]\n    n9 [label=\"import java.nio.file.Files;\"]\n    n1 [label=\"String fileName\", style=\"filled\", fillcolor=\"lightyellow\", color=\"orange\", penwidth=\"3.0\", fontcolor=\"darkorange\"]\n    n2 [label=\"System.currentTimeMillis() + \\\"_\\\" + fileName\"]\n    n8 -\u003e n6 [label=\"call\", color=\"red\", fontcolor=\"red\", penwidth=\"3.0\"]\n    n1 -\u003e n2 [label=\"depend_on\"]\n    n2 -\u003e n4 [label=\"depend_on\"]\n    n4 -\u003e n6 [label=\"depend_on\"]\n    n9 -\u003e n8 [label=\"search-exact:copy\", color=\"red\", fontcolor=\"red\", penwidth=\"3.0\"]\n}\n"
        }
      ]
    }
  },
  "File": [
    {
      "path": "FileUploader.java",
      "length": 3129,
      "hash": {
        "md5": "af73de5509ea017768b9875b62ac10af",
        "sha1": "d67de95394aa7fe980974a82c3f10b1061e1bf3e",
        "sha256": "514232b3a104b0e844053ba1ece2c2231dd494bf30758de2394b69cd2873e496"
      },
      "content": "import java.io.File;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.nio.file.Fi...",
      "risks": [
        "c5153eae0789a64ae99b99a1ac7b4fec3a12bc17"
      ]
    }
  ]
}