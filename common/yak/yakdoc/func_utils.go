package yakdoc

import (
	"fmt"
	"go/ast"
	"go/doc"
	"go/format"
	"go/parser"
	"go/token"
	"os"
	"path/filepath"
	"reflect"
	"regexp"
	"runtime"
	"strconv"
	"strings"

	"github.com/samber/lo"
	"github.com/yaklang/yaklang/common/log"
	"github.com/yaklang/yaklang/common/utils"
)

type CacheAstBundle struct {
	fset       *token.FileSet
	pkg        *doc.Package
	parsedFile *ast.File
}

var (
	InterfaceToAnyRegep, _ = regexp.Compile(`interface\s*\{\}`)
	cacheAstBundleMap      = make(map[string]*CacheAstBundle) // filename -> CachePackage
	ErrAutoGenerated       = utils.Error("file is <autogenerated>")
	ErrIsInstanceMethod    = utils.Error("function is instance method")
)

func GetDeclAndCompletion(funcName string, params, results []*Field, funcRefType reflect.Type) (string, string) {
	// 通用处理params和results
	paramsStr := make([]string, 0, len(params))
	for i, p := range params {
		variadic := strings.HasPrefix(p.Type, "...")
		if !variadic && i == len(params)-1 && funcRefType != nil && funcRefType.Kind() == reflect.Func {
			variadic = funcRefType.IsVariadic()
		}

		if p.Name == "" {
			p.Name = fmt.Sprintf("v%d", i+1)
		}
		p.Type = ShrinkTypeVerboseName(p.Type)

		/*
			设置vscode AutoCompletion
			vscode 参数补全格式为： ${n:default}
			n 代表第几个光标：从1开始，0为末尾
			default 为默认补充的值
		*/
		if variadic {
			paramsStr = append(paramsStr, fmt.Sprintf("${%v:%v...}", i+1, p.Name))
		} else {
			if p.Type == "any" {
				paramsStr = append(paramsStr, fmt.Sprintf("${%v:%v}", i+1, p.Name))
			} else {
				paramsStr = append(paramsStr, fmt.Sprintf("${%v:%v /*type: %v*/}", i+1, p.Name, p.Type))
			}
		}
	}
	for i, r := range results {
		if r.Name == "" {
			results[i].Name = fmt.Sprintf("r%d", i+1)
		}
		r.Type = ShrinkTypeVerboseName(r.Type)
	}

	// 生成declaration
	paramStr := strings.Join(lo.Map(params, func(p *Field, _ int) string {
		return fmt.Sprintf("%s %s", p.Name, p.Type)
	}), ", ")
	resultStr := ""
	if len(results) == 1 {
		if results[0].Name == "r1" {
			resultStr = results[0].Type
		} else {
			resultStr = fmt.Sprintf("(%s %s)", results[0].Name, results[0].Type)
		}
	} else if len(results) > 0 {
		resultStr = fmt.Sprintf("(%s)", strings.Join(lo.Map(results, func(r *Field, i int) string {
			if r.Name == fmt.Sprintf("r%d", i+1) {
				return r.Type
			}
			return fmt.Sprintf("%s %s", r.Name, r.Type)
		}), ", "))
	}
	declaration := fmt.Sprintf("%s(%s) %s", funcName, paramStr, resultStr)
	declaration = strings.TrimSpace(declaration)
	completion := strings.Join(paramsStr, ", ")
	completion = fmt.Sprintf("%v(%v)", funcName, completion)
	return declaration, completion
}

func GetCacheAstBundle(fileName string, src string) (*CacheAstBundle, error) {
	var (
		cacheAstBundle *CacheAstBundle
		ok             bool
	)
	// ignore cache, parse src
	fset := token.NewFileSet()

	var (
		parsedAst *ast.File
		err       error
	)
	if fileName == "" && src != "" {
		parsedAst, err = parser.ParseFile(fset, "", src, parser.ParseComments|parser.AllErrors)
	} else if cacheAstBundle, ok = cacheAstBundleMap[fileName]; ok {
		return cacheAstBundle, nil
	} else {
		if !strings.Contains(fileName, `yaklang/common/yakgrpc/ypb`) {
			parsedAst, err = parser.ParseFile(fset, fileName, nil, parser.ParseComments|parser.AllErrors)
		} else {
			err = utils.Errorf("skip keywork: %v", "yaklang/common/yakgrpc/ypb")
		}
	}

	if err != nil {
		return nil, utils.Errorf("parse source error: %v", err)
	}
	pkg := &ast.Package{
		Name:  "Any",
		Files: make(map[string]*ast.File),
	}
	pkg.Files[fileName] = parsedAst

	importPath, _ := filepath.Abs(fileName)
	docPkg := doc.New(pkg, importPath, doc.AllDecls)

	cacheAstBundle = &CacheAstBundle{
		fset:       fset,
		pkg:        docPkg,
		parsedFile: parsedAst,
	}
	return cacheAstBundle, nil
}

// rename native type
func ShrinkTypeVerboseName(i string) string {
	if InterfaceToAnyRegep.MatchString(i) {
		return InterfaceToAnyRegep.ReplaceAllString(i, "any")
	}
	if i == "[]uint8" {
		return "[]byte"
	}
	if i == "" {
		return "any"
	}

	return i
}

func ASTGetTypeName(expr ast.Expr, fset *token.FileSet) string {
	switch t := expr.(type) {
	case *ast.Ident:
		return t.Name
	case *ast.StarExpr:
		return "*" + ASTGetTypeName(t.X, fset)
	case *ast.SelectorExpr:
		return ASTGetTypeName(t.X, fset) + "." + t.Sel.Name
	case *ast.InterfaceType:
		return "any"
	case *ast.Ellipsis:
		return "..." + ASTGetTypeName(t.Elt, fset)
	case *ast.ArrayType:
		return "[]" + ASTGetTypeName(t.Elt, fset)
	case *ast.MapType:
		return "map[" + ASTGetTypeName(t.Key, fset) + "]" + ASTGetTypeName(t.Value, fset)
	default:
		var buf strings.Builder
		err := format.Node(&buf, fset, expr)
		if err != nil {
			return ""
		}
		return buf.String()
	}
}

func HandleParams(funcRefType reflect.Type, typ *ast.FuncType, fset *token.FileSet) (params []*Field) {
	if typ.Params == nil {
		return nil
	}
	defer func() {
		if r := recover(); r != nil {
			params = nil
		}
	}()
	params = make([]*Field, 0, len(typ.Params.List))
	canRef := !utils.IsNil(funcRefType)

	for i, field := range typ.Params.List {
		var fieldRefType reflect.Type
		if canRef {
			fieldRefType = funcRefType.In(i)
		}

		typName := ShrinkTypeVerboseName(ASTGetTypeName(field.Type, fset))
		for _, name := range field.Names {
			param := &Field{
				Name: name.Name,
				Type: typName,
			}
			if canRef {
				param.RefType = fieldRefType
			}
			params = append(params, param)
		}
	}
	return params
}

func HandleResults(funcRefType reflect.Type, typ *ast.FuncType, fset *token.FileSet) (results []*Field) {
	if typ.Results == nil {
		return nil
	}
	defer func() {
		if r := recover(); r != nil {
			results = nil
		}
	}()
	results = make([]*Field, 0, len(typ.Results.List))
	canRef := !utils.IsNil(funcRefType)

	for i, field := range typ.Results.List {
		var fieldRefType reflect.Type
		if canRef {
			fieldRefType = funcRefType.Out(i)
		}

		typName := ShrinkTypeVerboseName(ASTGetTypeName(field.Type, fset))

		for _, name := range field.Names {
			result := &Field{
				Name: name.Name,
				Type: typName,
			}
			if canRef {
				result.RefType = fieldRefType
			}
			results = append(results, result)
		}
		// 处理没有实名返回值的情况
		if len(field.Names) == 0 {
			result := &Field{
				Name: "",
				Type: typName,
			}
			if canRef {
				result.RefType = fieldRefType
			}
			results = append(results, result)
		}
	}
	return results
}

func HandleFieldsRaw(fieldTypeFunc func(index int) reflect.Type, fieldStr string) []*Field {
	fieldStrs := strings.Split(fieldStr, ",")
	ret := make([]*Field, 0, len(fieldStr))
	tempFields := make([]*Field, 0)
	for i, r := range fieldStrs {
		r = strings.TrimSpace(r)
		if r == "" {
			continue
		}
		splited := strings.Split(r, " ")
		// 一般认为一定有变量名，所以splited出来的第一个一定是变量名
		if len(splited) < 2 {
			field := &Field{
				Name:    splited[0],
				RefType: fieldTypeFunc(i),
			}
			ret = append(ret, field)
			tempFields = append(tempFields, field)
		} else {
			name, typ := splited[0], splited[1]
			ret = append(ret, &Field{
				Name:    name,
				Type:    typ,
				RefType: fieldTypeFunc(i),
			})
			if len(tempFields) > 0 {
				for _, field := range tempFields {
					field.Type = typ
				}
				tempFields = make([]*Field, 0)
			}
		}
	}
	return ret
}

func customHandleParamsAndResults(libName string, overideName string, params []*Field, results []*Field) ([]*Field, []*Field) {
	// eval时丢掉第一个参数，因为第一个参数是context，是在执行时自动注入的
	// if libName == "__GLOBAL__" && overideName == "eval" {
	// 	params = params[1:]
	// }
	return params, results
}

// Get description and declaration of a func
func FuncToFuncDecl(f interface{}, libName string, overideName string) (*FuncDecl, error) {
	funcRefValue := reflect.ValueOf(f)
	funcRefType := funcRefValue.Type()
	if funcRefValue.Kind() != reflect.Func {
		return nil, fmt.Errorf("not a function")
	}
	pc := funcRefValue.Pointer()
	if pc == 0 {
		return nil, fmt.Errorf("cannot get function pointer")
	}
	function := runtime.FuncForPC(pc)
	if function == nil {
		return nil, fmt.Errorf("cannot get function from runtime")
	}

	var (
		docPkg *doc.Package
		fset   *token.FileSet
		err    error

		declaration string
		document    string
		completion  string
		params      []*Field
		results     []*Field
	)

	filename, line := function.FileLine(0)
	splitFuncName := strings.Split(function.Name(), ".")
	funcName := splitFuncName[len(splitFuncName)-1]
	fixedForInstanceFuncDoc := false
	// is returned instance func, fix for doc
	if strings.HasPrefix(funcName, "func") {
		funcName = funcName[4:]
		if _, err := strconv.Atoi(funcName); err == nil {
			funcName = splitFuncName[len(splitFuncName)-2]
			fixedForInstanceFuncDoc = true
		}
	}

	if strings.HasSuffix(funcName, "-fm") {
		return nil, ErrIsInstanceMethod
	}
	if filename == "<autogenerated>" {
		return nil, ErrAutoGenerated
	}

	bundle, err := GetCacheAstBundle(filename, "")
	if err != nil {
		return nil, err
	}
	fset, docPkg = bundle.fset, bundle.pkg

	found, hasFallback := false, false

	buf, err := os.ReadFile(filename)
	if err != nil {
		return nil, err
	}

FOUND_FUNCTION_DECLARATION:
	funcs := docPkg.Funcs
	for _, theType := range docPkg.Types {
		funcs = append(funcs, theType.Methods...)
		funcs = append(funcs, theType.Funcs...)
	}
	lo.Uniq(funcs)

	for _, theFunc := range funcs {
		if !hasFallback {
			if theFunc.Name != funcName {
				continue
			}
			position := fset.Position(theFunc.Decl.Pos())
			if position.Line != line && !fixedForInstanceFuncDoc {
				continue
			}

			// only fix for doc
			if fixedForInstanceFuncDoc {
				document = theFunc.Doc
				continue
			}
		}

		found = true

		decl := theFunc.Decl
		// 获取函数注释
		document = theFunc.Doc
		// // 删除CRLF
		// document = strings.ReplaceAll(document, "\r", "")
		// document = strings.ReplaceAll(document, "\n", "")

		// 获取参数
		if decl != nil && decl.Type != nil && decl.Type.Params != nil {
			params = HandleParams(funcRefType, decl.Type, fset)
		}

		// 获取返回值
		if decl != nil && decl.Type != nil && decl.Type.Results != nil {
			results = HandleResults(funcRefType, decl.Type, fset)
		}

		break
	}

	// 试图找到map里的
	if !found {
		for _, v := range docPkg.Vars {
			decl := v.Decl
			if decl == nil {
				continue
			}
			if len(decl.Specs) == 0 {
				continue
			}
			iSpec := decl.Specs[0]
			spec, ok := iSpec.(*ast.ValueSpec)
			if !ok {
				continue
			}
			if len(spec.Values) == 0 {
				continue
			}
			iValue := spec.Values[0]
			value, ok := iValue.(*ast.CompositeLit)
			if !ok {
				continue
			}

			iType := value.Type
			_, ok = iType.(*ast.MapType)
			if !ok {
				continue
			}
			for _, elt := range value.Elts {
				kv, ok := elt.(*ast.KeyValueExpr)
				if !ok {
					continue
				}
				key, ok := kv.Key.(*ast.BasicLit)
				if !ok {
					continue
				}
				keyStr, err := strconv.Unquote(key.Value)
				if err != nil {
					continue
				}
				if strings.ToLower(keyStr) != strings.ToLower(funcName) && keyStr != overideName {
					continue
				}

				// 处理 "asd" => 引用其他函数的情况
				v, ok := kv.Value.(*ast.Ident)
				if ok {
					obj := v.Obj
					if obj == nil {
						continue
					}
					decl := obj.Decl
					if decl == nil {
						continue
					}
					if funcDecl, ok := decl.(*ast.FuncDecl); ok {
						params = HandleParams(funcRefType, funcDecl.Type, fset)
						results = HandleResults(funcRefType, funcDecl.Type, fset)
						found = true
						break
					}

					// 处理 "asd" => 引用变量 => 函数情况
					if specs, ok := decl.(*ast.ValueSpec); ok {
						if len(specs.Values) == 0 {
							continue
						}
						funcLit, ok := specs.Values[0].(*ast.FuncLit)
						if ok {
							params = HandleParams(funcRefType, funcLit.Type, fset)
							results = HandleResults(funcRefType, funcLit.Type, fset)
							found = true
							break
						}
					}
				}

				// 处理 "asd" => 匿名函数的情况
				funcLit, ok := kv.Value.(*ast.FuncLit)
				if ok {
					params = HandleParams(funcRefType, funcLit.Type, fset)
					results = HandleResults(funcRefType, funcLit.Type, fset)
					found = true
					break
				}

				// 处理调用函数获得函数的情况
				callExpr, ok := kv.Value.(*ast.CallExpr)
				if !ok {
					continue
				}
				fun, ok := callExpr.Fun.(*ast.Ident)
				if !ok {
					continue
				}
				obj := fun.Obj
				if obj == nil {
					continue
				}
				decl := obj.Decl
				if decl == nil {
					continue
				}
				// 解析第一个返回值，是函数类型
				if funcDecl, ok := decl.(*ast.FuncDecl); ok {
					typ := funcDecl.Type
					if typ == nil {
						continue
					}
					rets := typ.Results
					if rets == nil {
						continue
					}
					if rets.List == nil || len(rets.List) != 1 {
						continue
					}
					field := rets.List[0]
					if field == nil {
						continue
					}
					typExpr := field.Type
					if typ, ok = typExpr.(*ast.FuncType); !ok {
						continue
					}
					params = HandleParams(funcRefType, typ, fset)
					results = HandleResults(funcRefType, typ, fset)
					found = true
					break
				}

				// 按理来说不应该出现 "asd" => utils.xxx的情况，因为上面已经处理了，出现的情况可能是因为重名了

				_ = decl
			}

			if found {
				break
			}
		}
	}

	// 最后的fallback，无法拿到变量名与返回名,尝试直接解析字符串
	if !found {
		if hasFallback {
			log.Errorf("cannot find function[%s.%s] anymore", libName, overideName)
			return nil, fmt.Errorf("cannot find function anymore")
		}
		lines := strings.Split(string(buf), "\n")
		if line >= len(lines) {
			return nil, fmt.Errorf("line out of range")
		}
		lineStr := lines[line-1]
		lineStr = ShrinkTypeVerboseName(lineStr)
		// 去除注释
		if commentIndex := strings.Index(lineStr, "//"); commentIndex != -1 {
			lineStr = lineStr[:commentIndex]
		}
		// 去除func 前的字符串
		if index := strings.Index(lineStr, "func "); index != -1 {
			lineStr = lineStr[index:]
		}
		// 是结构体方法
		if strings.HasPrefix(lineStr, "func (") {
			lineStr = lineStr[strings.Index(lineStr, ")")+1:]
		}
		// 去除赋值前的字符串
		if strings.Contains(lineStr, "=") {
			lineStr = lineStr[strings.Index(lineStr, "=")+1:]
		}
		if strings.Contains(lineStr, ":") {
			lineStr = lineStr[strings.Index(lineStr, ":")+1:]
		}
		// 去除空格
		lineStr = strings.TrimSpace(lineStr)
		// 去除return
		lineStr = strings.TrimPrefix(lineStr, "return ")
		// 去除func
		lineStr = strings.TrimPrefix(lineStr, "func")
		// 去除空格
		lineStr = strings.TrimSpace(lineStr)
		// 去除左花括号
		index := strings.Index(lineStr, "{")
		if index != -1 {
			lineStr = lineStr[:index]
		}
		lineStr = strings.TrimSpace(lineStr)
		if strings.HasPrefix(lineStr, "(") {
			funcName = "Anonymous"
			lineStr = "Anonymous" + lineStr
		}
		src := fmt.Sprintf("package main\nimport(\n. \"any\"\n)\nfunc %v{\n}", lineStr)
		bundle, err = GetCacheAstBundle("", src)
		if err != nil {
			return nil, err
		}
		fset, docPkg = bundle.fset, bundle.pkg
		hasFallback = true
		goto FOUND_FUNCTION_DECLARATION
		// // 获取参数
		// if paramsIndex := strings.Index(lineStr, "("); paramsIndex != -1 {
		// 	paramsStr := lineStr[paramsIndex+1:]
		// 	paramsEndIndex := strings.Index(paramsStr, ")")
		// 	if paramsEndIndex != -1 {
		// 		paramsStr = paramsStr[:paramsEndIndex]
		// 	}
		// 	paramsStr = strings.Trim(paramsStr, ")")
		// 	paramsStr = strings.TrimSpace(paramsStr)

		// 	params = HandleFieldsRaw(funcRefType.In, paramsStr)
		// 	paramsEndIndex = strings.Index(lineStr, ")")
		// 	if paramsEndIndex != -1 {
		// 		if paramsEndIndex+2 < len(lineStr) {
		// 			lineStr = lineStr[paramsEndIndex+2:]
		// 		} else {
		// 			lineStr = ""
		// 		}
		// 	}
		// }
		// // 获取返回值
		// if resultsIndex := strings.Index(lineStr, "("); resultsIndex != -1 {
		// 	// 多返回值
		// 	resultsStr := lineStr[resultsIndex+1:]
		// 	resultEndIndex := strings.Index(resultsStr, ")")
		// 	if resultEndIndex != -1 {
		// 		resultsStr = resultsStr[:resultEndIndex]
		// 	}
		// 	resultsStr = strings.TrimRight(resultsStr, ")")
		// 	resultsStr = strings.TrimSpace(resultsStr)

		// 	results = HandleFieldsRaw(funcRefType.Out, resultsStr)
		// } else {
		// 	// 单返回值
		// 	resultsStr := strings.TrimSpace(lineStr)
		// 	results = append(results, &Field{
		// 		Name: "",
		// 		Type: resultsStr,
		// 	})
		// }
	}

	finalName := overideName
	if finalName == "" {
		finalName = funcName
	}

	// 特殊处理params和results
	// params, results = customHandleParamsAndResults(libName, overideName, params, results)

	declaration, completion = GetDeclAndCompletion(finalName, params, results, funcRefType)

	// 特殊处理Document
	if document != "" {
		exampleIndex := strings.Index(document, "Example:")
		if exampleIndex != -1 {
			document = strings.ReplaceAll(document[:exampleIndex], "\n", "\n\n") + document[exampleIndex:]
		}
	}

	return &FuncDecl{
		LibName:        libName,
		MethodName:     finalName,
		Document:       document,
		Decl:           declaration,
		Params:         params,
		Results:        results,
		VSCodeSnippets: completion,
	}, nil
}

func ForceFuncToFuncDecl(f interface{}, libName string, overideName string, isMethod bool) (*FuncDecl, error) {
	funcRefValue := reflect.ValueOf(f)
	funcRefType := funcRefValue.Type()
	if funcRefValue.Kind() != reflect.Func {
		return nil, fmt.Errorf("not a function")
	}
	lenOfParams := funcRefType.NumIn()
	if isMethod {
		lenOfParams--
	}
	params, results := make([]*Field, 0, lenOfParams), make([]*Field, 0, funcRefType.NumOut())

	var i int
	if isMethod {
		i = 1
	}
	for ; i < funcRefType.NumIn(); i++ {
		inType := funcRefType.In(i)
		params = append(params, &Field{
			Name:    "",
			Type:    ShrinkTypeVerboseName(inType.String()),
			RefType: inType,
		})
	}

	for i := 0; i < funcRefType.NumOut(); i++ {
		outType := funcRefType.Out(i)
		results = append(results, &Field{
			Name:    "",
			Type:    ShrinkTypeVerboseName(outType.String()),
			RefType: outType,
		})
	}

	declaration, completion := GetDeclAndCompletion(overideName, params, results, funcRefType)

	return &FuncDecl{
		LibName:        libName,
		MethodName:     overideName,
		Document:       "",
		Decl:           declaration,
		Params:         params,
		Results:        results,
		VSCodeSnippets: completion,
	}, nil
}
