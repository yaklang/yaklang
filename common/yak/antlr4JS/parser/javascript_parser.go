// Code generated from ./JavaScriptParser.g4 by ANTLR 4.13.1. DO NOT EDIT.

package parser // JavaScriptParser

import (
	"fmt"
	"strconv"
	"sync"

	"github.com/antlr4-go/antlr/v4"
)

// Suppress unused import errors
var _ = fmt.Printf
var _ = strconv.Itoa
var _ = sync.Once{}

type JavaScriptParser struct {
	JavaScriptParserBase
}

var JavaScriptParserParserStaticData struct {
	once                   sync.Once
	serializedATN          []int32
	LiteralNames           []string
	SymbolicNames          []string
	RuleNames              []string
	PredictionContextCache *antlr.PredictionContextCache
	atn                    *antlr.ATN
	decisionToDFA          []*antlr.DFA
}

func javascriptparserParserInit() {
	staticData := &JavaScriptParserParserStaticData
	staticData.LiteralNames = []string{
		"", "", "", "", "", "'['", "']'", "'('", "')'", "'{'", "", "'}'", "';'",
		"','", "'='", "'?'", "'?.'", "':'", "'...'", "'.'", "'++'", "'--'",
		"'+'", "'-'", "'~'", "'!'", "'*'", "'/'", "'%'", "'**'", "'??'", "'#'",
		"'>>'", "'<<'", "'>>>'", "'<'", "'>'", "'<='", "'>='", "'=='", "'!='",
		"'==='", "'!=='", "'&'", "'^'", "'|'", "'&&'", "'||'", "'*='", "'/='",
		"'%='", "'+='", "'-='", "'<<='", "'>>='", "'>>>='", "'&='", "'^='",
		"'|='", "'**='", "'=>'", "'null'", "", "", "", "", "", "", "", "", "",
		"", "'break'", "'do'", "'instanceof'", "'typeof'", "'case'", "'else'",
		"'new'", "'var'", "'catch'", "'finally'", "'return'", "'void'", "'continue'",
		"'for'", "'switch'", "'while'", "'debugger'", "'function'", "'this'",
		"'with'", "'default'", "'if'", "'throw'", "'delete'", "'in'", "'try'",
		"'as'", "'from'", "'class'", "'enum'", "'extends'", "'super'", "'const'",
		"'export'", "'import'", "'async'", "'await'", "'yield'", "'implements'",
		"", "", "'private'", "'public'", "'interface'", "'package'", "'protected'",
		"'static'", "", "", "", "", "", "", "", "", "'${'",
	}
	staticData.SymbolicNames = []string{
		"", "HashBangLine", "MultiLineComment", "SingleLineComment", "RegularExpressionLiteral",
		"OpenBracket", "CloseBracket", "OpenParen", "CloseParen", "OpenBrace",
		"TemplateCloseBrace", "CloseBrace", "SemiColon", "Comma", "Assign",
		"QuestionMark", "QuestionMarkDot", "Colon", "Ellipsis", "Dot", "PlusPlus",
		"MinusMinus", "Plus", "Minus", "BitNot", "Not", "Multiply", "Divide",
		"Modulus", "Power", "NullCoalesce", "Hashtag", "RightShiftArithmetic",
		"LeftShiftArithmetic", "RightShiftLogical", "LessThan", "MoreThan",
		"LessThanEquals", "GreaterThanEquals", "Equals_", "NotEquals", "IdentityEquals",
		"IdentityNotEquals", "BitAnd", "BitXOr", "BitOr", "And", "Or", "MultiplyAssign",
		"DivideAssign", "ModulusAssign", "PlusAssign", "MinusAssign", "LeftShiftArithmeticAssign",
		"RightShiftArithmeticAssign", "RightShiftLogicalAssign", "BitAndAssign",
		"BitXorAssign", "BitOrAssign", "PowerAssign", "ARROW", "NullLiteral",
		"BooleanLiteral", "DecimalLiteral", "HexIntegerLiteral", "OctalIntegerLiteral",
		"OctalIntegerLiteral2", "BinaryIntegerLiteral", "BigHexIntegerLiteral",
		"BigOctalIntegerLiteral", "BigBinaryIntegerLiteral", "BigDecimalIntegerLiteral",
		"Break", "Do", "Instanceof", "Typeof", "Case", "Else", "New", "Var",
		"Catch", "Finally", "Return", "Void", "Continue", "For", "Switch", "While",
		"Debugger", "Function_", "This", "With", "Default", "If", "Throw", "Delete",
		"In", "Try", "As", "From", "Class", "Enum", "Extends", "Super", "Const",
		"Export", "Import", "Async", "Await", "Yield", "Implements", "StrictLet",
		"NonStrictLet", "Private", "Public", "Interface", "Package", "Protected",
		"Static", "Identifier", "StringLiteral", "BackTick", "WhiteSpaces",
		"LineTerminator", "HtmlComment", "CDataComment", "UnexpectedCharacter",
		"TemplateStringStartExpression", "TemplateStringAtom",
	}
	staticData.RuleNames = []string{
		"program", "sourceElement", "statement", "block", "statementList", "importStatement",
		"importFromBlock", "importModuleItems", "importAliasName", "moduleExportName",
		"importedBinding", "importDefault", "importNamespace", "importFrom",
		"aliasName", "exportStatement", "exportFromBlock", "exportModuleItems",
		"exportAliasName", "declaration", "variableStatement", "variableDeclarationList",
		"variableDeclaration", "emptyStatement_", "expressionStatement", "ifStatement",
		"forFirst", "forSecond", "forThird", "iterationStatement", "varModifier",
		"continueStatement", "breakStatement", "returnStatement", "yieldStatement",
		"withStatement", "switchStatement", "caseBlock", "caseClauses", "caseClause",
		"defaultClause", "labelledStatement", "throwStatement", "tryStatement",
		"catchProduction", "finallyProduction", "debuggerStatement", "functionDeclaration",
		"classDeclaration", "classTail", "classElement", "methodDefinition",
		"fieldDefinition", "classElementName", "privateIdentifier", "formalParameterList",
		"formalParameterArg", "lastFormalParameterArg", "functionBody", "sourceElements",
		"arrayLiteral", "elementList", "arrayElement", "propertyAssignment",
		"propertyName", "arguments", "argument", "expressionSequence", "singleExpression",
		"initializer", "assignable", "objectLiteral", "anonymousFunction", "arrowFunctionParameters",
		"arrowFunctionBody", "assignmentOperator", "literal", "templateStringLiteral",
		"templateStringAtom", "numericLiteral", "bigintLiteral", "getter", "setter",
		"identifierName", "identifier", "reservedWord", "keyword", "let_", "eos",
	}
	staticData.PredictionContextCache = antlr.NewPredictionContextCache()
	staticData.serializedATN = []int32{
		4, 1, 128, 1104, 2, 0, 7, 0, 2, 1, 7, 1, 2, 2, 7, 2, 2, 3, 7, 3, 2, 4,
		7, 4, 2, 5, 7, 5, 2, 6, 7, 6, 2, 7, 7, 7, 2, 8, 7, 8, 2, 9, 7, 9, 2, 10,
		7, 10, 2, 11, 7, 11, 2, 12, 7, 12, 2, 13, 7, 13, 2, 14, 7, 14, 2, 15, 7,
		15, 2, 16, 7, 16, 2, 17, 7, 17, 2, 18, 7, 18, 2, 19, 7, 19, 2, 20, 7, 20,
		2, 21, 7, 21, 2, 22, 7, 22, 2, 23, 7, 23, 2, 24, 7, 24, 2, 25, 7, 25, 2,
		26, 7, 26, 2, 27, 7, 27, 2, 28, 7, 28, 2, 29, 7, 29, 2, 30, 7, 30, 2, 31,
		7, 31, 2, 32, 7, 32, 2, 33, 7, 33, 2, 34, 7, 34, 2, 35, 7, 35, 2, 36, 7,
		36, 2, 37, 7, 37, 2, 38, 7, 38, 2, 39, 7, 39, 2, 40, 7, 40, 2, 41, 7, 41,
		2, 42, 7, 42, 2, 43, 7, 43, 2, 44, 7, 44, 2, 45, 7, 45, 2, 46, 7, 46, 2,
		47, 7, 47, 2, 48, 7, 48, 2, 49, 7, 49, 2, 50, 7, 50, 2, 51, 7, 51, 2, 52,
		7, 52, 2, 53, 7, 53, 2, 54, 7, 54, 2, 55, 7, 55, 2, 56, 7, 56, 2, 57, 7,
		57, 2, 58, 7, 58, 2, 59, 7, 59, 2, 60, 7, 60, 2, 61, 7, 61, 2, 62, 7, 62,
		2, 63, 7, 63, 2, 64, 7, 64, 2, 65, 7, 65, 2, 66, 7, 66, 2, 67, 7, 67, 2,
		68, 7, 68, 2, 69, 7, 69, 2, 70, 7, 70, 2, 71, 7, 71, 2, 72, 7, 72, 2, 73,
		7, 73, 2, 74, 7, 74, 2, 75, 7, 75, 2, 76, 7, 76, 2, 77, 7, 77, 2, 78, 7,
		78, 2, 79, 7, 79, 2, 80, 7, 80, 2, 81, 7, 81, 2, 82, 7, 82, 2, 83, 7, 83,
		2, 84, 7, 84, 2, 85, 7, 85, 2, 86, 7, 86, 2, 87, 7, 87, 2, 88, 7, 88, 1,
		0, 3, 0, 180, 8, 0, 1, 0, 3, 0, 183, 8, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 2,
		1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2,
		1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 3, 2, 209, 8, 2, 1, 3, 1, 3,
		3, 3, 213, 8, 3, 1, 3, 1, 3, 1, 4, 4, 4, 218, 8, 4, 11, 4, 12, 4, 219,
		1, 5, 1, 5, 1, 5, 1, 6, 3, 6, 226, 8, 6, 1, 6, 1, 6, 3, 6, 230, 8, 6, 1,
		6, 1, 6, 1, 6, 1, 6, 1, 6, 3, 6, 237, 8, 6, 1, 7, 1, 7, 1, 7, 1, 7, 5,
		7, 243, 8, 7, 10, 7, 12, 7, 246, 9, 7, 1, 7, 1, 7, 3, 7, 250, 8, 7, 3,
		7, 252, 8, 7, 1, 7, 1, 7, 1, 8, 1, 8, 1, 8, 3, 8, 259, 8, 8, 1, 9, 1, 9,
		3, 9, 263, 8, 9, 1, 10, 1, 10, 1, 11, 1, 11, 1, 11, 1, 12, 1, 12, 3, 12,
		272, 8, 12, 1, 12, 1, 12, 3, 12, 276, 8, 12, 1, 13, 1, 13, 1, 13, 1, 14,
		1, 14, 1, 14, 3, 14, 284, 8, 14, 1, 15, 1, 15, 3, 15, 288, 8, 15, 1, 15,
		1, 15, 3, 15, 292, 8, 15, 1, 15, 1, 15, 1, 15, 1, 15, 1, 15, 1, 15, 1,
		15, 3, 15, 301, 8, 15, 1, 16, 1, 16, 1, 16, 1, 16, 1, 16, 1, 16, 3, 16,
		309, 8, 16, 1, 16, 1, 16, 3, 16, 313, 8, 16, 1, 17, 1, 17, 1, 17, 1, 17,
		5, 17, 319, 8, 17, 10, 17, 12, 17, 322, 9, 17, 1, 17, 1, 17, 3, 17, 326,
		8, 17, 3, 17, 328, 8, 17, 1, 17, 1, 17, 1, 18, 1, 18, 1, 18, 3, 18, 335,
		8, 18, 1, 19, 1, 19, 1, 19, 3, 19, 340, 8, 19, 1, 20, 1, 20, 1, 20, 1,
		21, 1, 21, 1, 21, 1, 21, 5, 21, 349, 8, 21, 10, 21, 12, 21, 352, 9, 21,
		1, 22, 1, 22, 1, 22, 3, 22, 357, 8, 22, 1, 23, 1, 23, 1, 24, 1, 24, 1,
		24, 1, 24, 1, 25, 1, 25, 1, 25, 1, 25, 1, 25, 1, 25, 1, 25, 3, 25, 372,
		8, 25, 1, 26, 1, 26, 3, 26, 376, 8, 26, 1, 27, 1, 27, 1, 28, 1, 28, 1,
		29, 1, 29, 1, 29, 1, 29, 1, 29, 1, 29, 1, 29, 1, 29, 1, 29, 1, 29, 1, 29,
		1, 29, 1, 29, 1, 29, 1, 29, 1, 29, 1, 29, 3, 29, 399, 8, 29, 1, 29, 1,
		29, 3, 29, 403, 8, 29, 1, 29, 1, 29, 3, 29, 407, 8, 29, 1, 29, 1, 29, 1,
		29, 1, 29, 1, 29, 1, 29, 3, 29, 415, 8, 29, 1, 29, 1, 29, 1, 29, 1, 29,
		1, 29, 1, 29, 1, 29, 3, 29, 424, 8, 29, 1, 29, 1, 29, 1, 29, 3, 29, 429,
		8, 29, 1, 29, 1, 29, 1, 29, 1, 29, 1, 29, 1, 29, 3, 29, 437, 8, 29, 1,
		30, 1, 30, 1, 30, 3, 30, 442, 8, 30, 1, 31, 1, 31, 1, 31, 3, 31, 447, 8,
		31, 1, 31, 1, 31, 1, 32, 1, 32, 1, 32, 3, 32, 454, 8, 32, 1, 32, 1, 32,
		1, 33, 1, 33, 1, 33, 3, 33, 461, 8, 33, 1, 33, 1, 33, 1, 34, 1, 34, 1,
		34, 3, 34, 468, 8, 34, 1, 34, 1, 34, 1, 35, 1, 35, 1, 35, 1, 35, 1, 35,
		1, 35, 1, 36, 1, 36, 1, 36, 1, 36, 1, 36, 1, 36, 1, 37, 1, 37, 3, 37, 486,
		8, 37, 1, 37, 1, 37, 3, 37, 490, 8, 37, 3, 37, 492, 8, 37, 1, 37, 1, 37,
		1, 38, 4, 38, 497, 8, 38, 11, 38, 12, 38, 498, 1, 39, 1, 39, 1, 39, 1,
		39, 3, 39, 505, 8, 39, 1, 40, 1, 40, 1, 40, 3, 40, 510, 8, 40, 1, 41, 1,
		41, 1, 41, 1, 41, 1, 42, 1, 42, 1, 42, 1, 42, 1, 42, 1, 43, 1, 43, 1, 43,
		1, 43, 3, 43, 525, 8, 43, 1, 43, 3, 43, 528, 8, 43, 1, 44, 1, 44, 1, 44,
		3, 44, 533, 8, 44, 1, 44, 3, 44, 536, 8, 44, 1, 44, 1, 44, 1, 45, 1, 45,
		1, 45, 1, 46, 1, 46, 1, 46, 1, 47, 3, 47, 547, 8, 47, 1, 47, 1, 47, 3,
		47, 551, 8, 47, 1, 47, 1, 47, 1, 47, 3, 47, 556, 8, 47, 1, 47, 1, 47, 1,
		47, 1, 48, 1, 48, 1, 48, 1, 48, 1, 49, 1, 49, 3, 49, 567, 8, 49, 1, 49,
		1, 49, 5, 49, 571, 8, 49, 10, 49, 12, 49, 574, 9, 49, 1, 49, 1, 49, 1,
		50, 1, 50, 1, 50, 3, 50, 581, 8, 50, 1, 50, 1, 50, 1, 50, 1, 50, 3, 50,
		587, 8, 50, 1, 50, 1, 50, 1, 50, 1, 50, 3, 50, 593, 8, 50, 1, 50, 1, 50,
		3, 50, 597, 8, 50, 1, 51, 1, 51, 3, 51, 601, 8, 51, 1, 51, 3, 51, 604,
		8, 51, 1, 51, 1, 51, 1, 51, 3, 51, 609, 8, 51, 1, 51, 1, 51, 1, 51, 1,
		51, 3, 51, 615, 8, 51, 1, 51, 1, 51, 1, 51, 1, 51, 1, 51, 1, 51, 3, 51,
		623, 8, 51, 1, 51, 1, 51, 1, 51, 3, 51, 628, 8, 51, 1, 51, 1, 51, 1, 51,
		3, 51, 633, 8, 51, 1, 52, 1, 52, 3, 52, 637, 8, 52, 1, 53, 1, 53, 3, 53,
		641, 8, 53, 1, 54, 1, 54, 1, 54, 1, 55, 1, 55, 1, 55, 5, 55, 649, 8, 55,
		10, 55, 12, 55, 652, 9, 55, 1, 55, 1, 55, 3, 55, 656, 8, 55, 1, 55, 3,
		55, 659, 8, 55, 1, 56, 1, 56, 1, 56, 3, 56, 664, 8, 56, 1, 57, 1, 57, 1,
		57, 1, 58, 1, 58, 3, 58, 671, 8, 58, 1, 58, 1, 58, 1, 59, 4, 59, 676, 8,
		59, 11, 59, 12, 59, 677, 1, 60, 1, 60, 1, 60, 1, 60, 1, 61, 5, 61, 685,
		8, 61, 10, 61, 12, 61, 688, 9, 61, 1, 61, 3, 61, 691, 8, 61, 1, 61, 4,
		61, 694, 8, 61, 11, 61, 12, 61, 695, 1, 61, 5, 61, 699, 8, 61, 10, 61,
		12, 61, 702, 9, 61, 1, 61, 5, 61, 705, 8, 61, 10, 61, 12, 61, 708, 9, 61,
		1, 62, 3, 62, 711, 8, 62, 1, 62, 1, 62, 1, 63, 1, 63, 1, 63, 1, 63, 1,
		63, 1, 63, 1, 63, 1, 63, 1, 63, 1, 63, 1, 63, 3, 63, 726, 8, 63, 1, 63,
		3, 63, 729, 8, 63, 1, 63, 1, 63, 1, 63, 3, 63, 734, 8, 63, 1, 63, 1, 63,
		1, 63, 1, 63, 1, 63, 1, 63, 1, 63, 1, 63, 1, 63, 1, 63, 1, 63, 1, 63, 1,
		63, 1, 63, 1, 63, 3, 63, 751, 8, 63, 1, 63, 3, 63, 754, 8, 63, 1, 64, 1,
		64, 1, 64, 1, 64, 1, 64, 1, 64, 1, 64, 3, 64, 763, 8, 64, 1, 65, 1, 65,
		1, 65, 1, 65, 5, 65, 769, 8, 65, 10, 65, 12, 65, 772, 9, 65, 1, 65, 3,
		65, 775, 8, 65, 3, 65, 777, 8, 65, 1, 65, 1, 65, 1, 66, 3, 66, 782, 8,
		66, 1, 66, 1, 66, 3, 66, 786, 8, 66, 1, 67, 1, 67, 1, 67, 5, 67, 791, 8,
		67, 10, 67, 12, 67, 794, 9, 67, 1, 68, 1, 68, 1, 68, 1, 68, 3, 68, 800,
		8, 68, 1, 68, 1, 68, 1, 68, 1, 68, 1, 68, 1, 68, 1, 68, 1, 68, 1, 68, 1,
		68, 1, 68, 1, 68, 1, 68, 1, 68, 1, 68, 1, 68, 1, 68, 1, 68, 1, 68, 1, 68,
		1, 68, 1, 68, 1, 68, 1, 68, 1, 68, 1, 68, 1, 68, 1, 68, 1, 68, 1, 68, 1,
		68, 1, 68, 1, 68, 1, 68, 1, 68, 1, 68, 1, 68, 1, 68, 1, 68, 1, 68, 1, 68,
		1, 68, 1, 68, 1, 68, 1, 68, 1, 68, 3, 68, 848, 8, 68, 1, 68, 1, 68, 1,
		68, 1, 68, 1, 68, 1, 68, 1, 68, 1, 68, 1, 68, 1, 68, 1, 68, 1, 68, 1, 68,
		1, 68, 1, 68, 1, 68, 1, 68, 1, 68, 1, 68, 1, 68, 1, 68, 1, 68, 1, 68, 1,
		68, 1, 68, 1, 68, 1, 68, 1, 68, 1, 68, 1, 68, 1, 68, 1, 68, 1, 68, 1, 68,
		1, 68, 1, 68, 1, 68, 1, 68, 1, 68, 1, 68, 1, 68, 1, 68, 1, 68, 1, 68, 1,
		68, 1, 68, 1, 68, 1, 68, 1, 68, 1, 68, 1, 68, 1, 68, 1, 68, 1, 68, 1, 68,
		1, 68, 1, 68, 1, 68, 1, 68, 1, 68, 3, 68, 910, 8, 68, 1, 68, 1, 68, 1,
		68, 1, 68, 1, 68, 1, 68, 3, 68, 918, 8, 68, 1, 68, 1, 68, 3, 68, 922, 8,
		68, 1, 68, 1, 68, 1, 68, 1, 68, 1, 68, 1, 68, 1, 68, 1, 68, 1, 68, 1, 68,
		1, 68, 5, 68, 935, 8, 68, 10, 68, 12, 68, 938, 9, 68, 1, 69, 1, 69, 1,
		69, 1, 70, 1, 70, 1, 70, 3, 70, 946, 8, 70, 1, 71, 1, 71, 1, 71, 1, 71,
		5, 71, 952, 8, 71, 10, 71, 12, 71, 955, 9, 71, 1, 71, 3, 71, 958, 8, 71,
		3, 71, 960, 8, 71, 1, 71, 1, 71, 1, 72, 3, 72, 965, 8, 72, 1, 72, 1, 72,
		3, 72, 969, 8, 72, 1, 72, 1, 72, 3, 72, 973, 8, 72, 1, 72, 1, 72, 1, 72,
		3, 72, 978, 8, 72, 1, 72, 1, 72, 1, 72, 1, 72, 3, 72, 984, 8, 72, 1, 73,
		1, 73, 1, 73, 3, 73, 989, 8, 73, 1, 73, 3, 73, 992, 8, 73, 1, 74, 1, 74,
		3, 74, 996, 8, 74, 1, 75, 1, 75, 1, 76, 1, 76, 1, 76, 1, 76, 1, 76, 1,
		76, 1, 76, 3, 76, 1007, 8, 76, 1, 77, 1, 77, 5, 77, 1011, 8, 77, 10, 77,
		12, 77, 1014, 9, 77, 1, 77, 1, 77, 1, 78, 1, 78, 1, 78, 1, 78, 1, 78, 3,
		78, 1023, 8, 78, 1, 79, 1, 79, 1, 80, 1, 80, 1, 81, 1, 81, 1, 81, 1, 81,
		1, 82, 1, 82, 1, 82, 1, 82, 1, 83, 1, 83, 3, 83, 1039, 8, 83, 1, 84, 1,
		84, 1, 85, 1, 85, 1, 85, 3, 85, 1046, 8, 85, 1, 86, 1, 86, 1, 86, 1, 86,
		1, 86, 1, 86, 1, 86, 1, 86, 1, 86, 1, 86, 1, 86, 1, 86, 1, 86, 1, 86, 1,
		86, 1, 86, 1, 86, 1, 86, 1, 86, 1, 86, 1, 86, 1, 86, 1, 86, 1, 86, 1, 86,
		1, 86, 1, 86, 1, 86, 1, 86, 1, 86, 1, 86, 1, 86, 1, 86, 1, 86, 1, 86, 1,
		86, 1, 86, 1, 86, 1, 86, 1, 86, 1, 86, 1, 86, 1, 86, 1, 86, 1, 86, 1, 86,
		3, 86, 1094, 8, 86, 1, 87, 1, 87, 1, 88, 1, 88, 1, 88, 1, 88, 3, 88, 1102,
		8, 88, 1, 88, 0, 1, 136, 89, 0, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22,
		24, 26, 28, 30, 32, 34, 36, 38, 40, 42, 44, 46, 48, 50, 52, 54, 56, 58,
		60, 62, 64, 66, 68, 70, 72, 74, 76, 78, 80, 82, 84, 86, 88, 90, 92, 94,
		96, 98, 100, 102, 104, 106, 108, 110, 112, 114, 116, 118, 120, 122, 124,
		126, 128, 130, 132, 134, 136, 138, 140, 142, 144, 146, 148, 150, 152, 154,
		156, 158, 160, 162, 164, 166, 168, 170, 172, 174, 176, 0, 11, 2, 0, 108,
		109, 119, 119, 1, 0, 26, 28, 1, 0, 22, 23, 1, 0, 32, 34, 1, 0, 35, 38,
		1, 0, 39, 42, 1, 0, 48, 59, 1, 0, 63, 67, 1, 0, 68, 71, 4, 0, 98, 99, 107,
		107, 112, 112, 119, 119, 1, 0, 111, 112, 1265, 0, 179, 1, 0, 0, 0, 2, 186,
		1, 0, 0, 0, 4, 208, 1, 0, 0, 0, 6, 210, 1, 0, 0, 0, 8, 217, 1, 0, 0, 0,
		10, 221, 1, 0, 0, 0, 12, 236, 1, 0, 0, 0, 14, 238, 1, 0, 0, 0, 16, 255,
		1, 0, 0, 0, 18, 262, 1, 0, 0, 0, 20, 264, 1, 0, 0, 0, 22, 266, 1, 0, 0,
		0, 24, 271, 1, 0, 0, 0, 26, 277, 1, 0, 0, 0, 28, 280, 1, 0, 0, 0, 30, 300,
		1, 0, 0, 0, 32, 312, 1, 0, 0, 0, 34, 314, 1, 0, 0, 0, 36, 331, 1, 0, 0,
		0, 38, 339, 1, 0, 0, 0, 40, 341, 1, 0, 0, 0, 42, 344, 1, 0, 0, 0, 44, 353,
		1, 0, 0, 0, 46, 358, 1, 0, 0, 0, 48, 360, 1, 0, 0, 0, 50, 364, 1, 0, 0,
		0, 52, 375, 1, 0, 0, 0, 54, 377, 1, 0, 0, 0, 56, 379, 1, 0, 0, 0, 58, 436,
		1, 0, 0, 0, 60, 441, 1, 0, 0, 0, 62, 443, 1, 0, 0, 0, 64, 450, 1, 0, 0,
		0, 66, 457, 1, 0, 0, 0, 68, 464, 1, 0, 0, 0, 70, 471, 1, 0, 0, 0, 72, 477,
		1, 0, 0, 0, 74, 483, 1, 0, 0, 0, 76, 496, 1, 0, 0, 0, 78, 500, 1, 0, 0,
		0, 80, 506, 1, 0, 0, 0, 82, 511, 1, 0, 0, 0, 84, 515, 1, 0, 0, 0, 86, 520,
		1, 0, 0, 0, 88, 529, 1, 0, 0, 0, 90, 539, 1, 0, 0, 0, 92, 542, 1, 0, 0,
		0, 94, 546, 1, 0, 0, 0, 96, 560, 1, 0, 0, 0, 98, 566, 1, 0, 0, 0, 100,
		596, 1, 0, 0, 0, 102, 632, 1, 0, 0, 0, 104, 634, 1, 0, 0, 0, 106, 640,
		1, 0, 0, 0, 108, 642, 1, 0, 0, 0, 110, 658, 1, 0, 0, 0, 112, 660, 1, 0,
		0, 0, 114, 665, 1, 0, 0, 0, 116, 668, 1, 0, 0, 0, 118, 675, 1, 0, 0, 0,
		120, 679, 1, 0, 0, 0, 122, 686, 1, 0, 0, 0, 124, 710, 1, 0, 0, 0, 126,
		753, 1, 0, 0, 0, 128, 762, 1, 0, 0, 0, 130, 764, 1, 0, 0, 0, 132, 781,
		1, 0, 0, 0, 134, 787, 1, 0, 0, 0, 136, 847, 1, 0, 0, 0, 138, 939, 1, 0,
		0, 0, 140, 945, 1, 0, 0, 0, 142, 947, 1, 0, 0, 0, 144, 983, 1, 0, 0, 0,
		146, 991, 1, 0, 0, 0, 148, 995, 1, 0, 0, 0, 150, 997, 1, 0, 0, 0, 152,
		1006, 1, 0, 0, 0, 154, 1008, 1, 0, 0, 0, 156, 1022, 1, 0, 0, 0, 158, 1024,
		1, 0, 0, 0, 160, 1026, 1, 0, 0, 0, 162, 1028, 1, 0, 0, 0, 164, 1032, 1,
		0, 0, 0, 166, 1038, 1, 0, 0, 0, 168, 1040, 1, 0, 0, 0, 170, 1045, 1, 0,
		0, 0, 172, 1093, 1, 0, 0, 0, 174, 1095, 1, 0, 0, 0, 176, 1101, 1, 0, 0,
		0, 178, 180, 5, 1, 0, 0, 179, 178, 1, 0, 0, 0, 179, 180, 1, 0, 0, 0, 180,
		182, 1, 0, 0, 0, 181, 183, 3, 118, 59, 0, 182, 181, 1, 0, 0, 0, 182, 183,
		1, 0, 0, 0, 183, 184, 1, 0, 0, 0, 184, 185, 5, 0, 0, 1, 185, 1, 1, 0, 0,
		0, 186, 187, 3, 4, 2, 0, 187, 3, 1, 0, 0, 0, 188, 209, 3, 6, 3, 0, 189,
		209, 3, 40, 20, 0, 190, 209, 3, 10, 5, 0, 191, 209, 3, 30, 15, 0, 192,
		209, 3, 46, 23, 0, 193, 209, 3, 96, 48, 0, 194, 209, 3, 94, 47, 0, 195,
		209, 3, 48, 24, 0, 196, 209, 3, 50, 25, 0, 197, 209, 3, 58, 29, 0, 198,
		209, 3, 62, 31, 0, 199, 209, 3, 64, 32, 0, 200, 209, 3, 66, 33, 0, 201,
		209, 3, 68, 34, 0, 202, 209, 3, 70, 35, 0, 203, 209, 3, 82, 41, 0, 204,
		209, 3, 72, 36, 0, 205, 209, 3, 84, 42, 0, 206, 209, 3, 86, 43, 0, 207,
		209, 3, 92, 46, 0, 208, 188, 1, 0, 0, 0, 208, 189, 1, 0, 0, 0, 208, 190,
		1, 0, 0, 0, 208, 191, 1, 0, 0, 0, 208, 192, 1, 0, 0, 0, 208, 193, 1, 0,
		0, 0, 208, 194, 1, 0, 0, 0, 208, 195, 1, 0, 0, 0, 208, 196, 1, 0, 0, 0,
		208, 197, 1, 0, 0, 0, 208, 198, 1, 0, 0, 0, 208, 199, 1, 0, 0, 0, 208,
		200, 1, 0, 0, 0, 208, 201, 1, 0, 0, 0, 208, 202, 1, 0, 0, 0, 208, 203,
		1, 0, 0, 0, 208, 204, 1, 0, 0, 0, 208, 205, 1, 0, 0, 0, 208, 206, 1, 0,
		0, 0, 208, 207, 1, 0, 0, 0, 209, 5, 1, 0, 0, 0, 210, 212, 5, 9, 0, 0, 211,
		213, 3, 8, 4, 0, 212, 211, 1, 0, 0, 0, 212, 213, 1, 0, 0, 0, 213, 214,
		1, 0, 0, 0, 214, 215, 5, 11, 0, 0, 215, 7, 1, 0, 0, 0, 216, 218, 3, 4,
		2, 0, 217, 216, 1, 0, 0, 0, 218, 219, 1, 0, 0, 0, 219, 217, 1, 0, 0, 0,
		219, 220, 1, 0, 0, 0, 220, 9, 1, 0, 0, 0, 221, 222, 5, 106, 0, 0, 222,
		223, 3, 12, 6, 0, 223, 11, 1, 0, 0, 0, 224, 226, 3, 22, 11, 0, 225, 224,
		1, 0, 0, 0, 225, 226, 1, 0, 0, 0, 226, 229, 1, 0, 0, 0, 227, 230, 3, 24,
		12, 0, 228, 230, 3, 14, 7, 0, 229, 227, 1, 0, 0, 0, 229, 228, 1, 0, 0,
		0, 230, 231, 1, 0, 0, 0, 231, 232, 3, 26, 13, 0, 232, 233, 3, 176, 88,
		0, 233, 237, 1, 0, 0, 0, 234, 235, 5, 120, 0, 0, 235, 237, 3, 176, 88,
		0, 236, 225, 1, 0, 0, 0, 236, 234, 1, 0, 0, 0, 237, 13, 1, 0, 0, 0, 238,
		244, 5, 9, 0, 0, 239, 240, 3, 16, 8, 0, 240, 241, 5, 13, 0, 0, 241, 243,
		1, 0, 0, 0, 242, 239, 1, 0, 0, 0, 243, 246, 1, 0, 0, 0, 244, 242, 1, 0,
		0, 0, 244, 245, 1, 0, 0, 0, 245, 251, 1, 0, 0, 0, 246, 244, 1, 0, 0, 0,
		247, 249, 3, 16, 8, 0, 248, 250, 5, 13, 0, 0, 249, 248, 1, 0, 0, 0, 249,
		250, 1, 0, 0, 0, 250, 252, 1, 0, 0, 0, 251, 247, 1, 0, 0, 0, 251, 252,
		1, 0, 0, 0, 252, 253, 1, 0, 0, 0, 253, 254, 5, 11, 0, 0, 254, 15, 1, 0,
		0, 0, 255, 258, 3, 18, 9, 0, 256, 257, 5, 98, 0, 0, 257, 259, 3, 20, 10,
		0, 258, 256, 1, 0, 0, 0, 258, 259, 1, 0, 0, 0, 259, 17, 1, 0, 0, 0, 260,
		263, 3, 166, 83, 0, 261, 263, 5, 120, 0, 0, 262, 260, 1, 0, 0, 0, 262,
		261, 1, 0, 0, 0, 263, 19, 1, 0, 0, 0, 264, 265, 7, 0, 0, 0, 265, 21, 1,
		0, 0, 0, 266, 267, 3, 28, 14, 0, 267, 268, 5, 13, 0, 0, 268, 23, 1, 0,
		0, 0, 269, 272, 5, 26, 0, 0, 270, 272, 3, 166, 83, 0, 271, 269, 1, 0, 0,
		0, 271, 270, 1, 0, 0, 0, 272, 275, 1, 0, 0, 0, 273, 274, 5, 98, 0, 0, 274,
		276, 3, 166, 83, 0, 275, 273, 1, 0, 0, 0, 275, 276, 1, 0, 0, 0, 276, 25,
		1, 0, 0, 0, 277, 278, 5, 99, 0, 0, 278, 279, 5, 120, 0, 0, 279, 27, 1,
		0, 0, 0, 280, 283, 3, 166, 83, 0, 281, 282, 5, 98, 0, 0, 282, 284, 3, 166,
		83, 0, 283, 281, 1, 0, 0, 0, 283, 284, 1, 0, 0, 0, 284, 29, 1, 0, 0, 0,
		285, 287, 5, 105, 0, 0, 286, 288, 5, 92, 0, 0, 287, 286, 1, 0, 0, 0, 287,
		288, 1, 0, 0, 0, 288, 291, 1, 0, 0, 0, 289, 292, 3, 32, 16, 0, 290, 292,
		3, 38, 19, 0, 291, 289, 1, 0, 0, 0, 291, 290, 1, 0, 0, 0, 292, 293, 1,
		0, 0, 0, 293, 294, 3, 176, 88, 0, 294, 301, 1, 0, 0, 0, 295, 296, 5, 105,
		0, 0, 296, 297, 5, 92, 0, 0, 297, 298, 3, 136, 68, 0, 298, 299, 3, 176,
		88, 0, 299, 301, 1, 0, 0, 0, 300, 285, 1, 0, 0, 0, 300, 295, 1, 0, 0, 0,
		301, 31, 1, 0, 0, 0, 302, 303, 3, 24, 12, 0, 303, 304, 3, 26, 13, 0, 304,
		305, 3, 176, 88, 0, 305, 313, 1, 0, 0, 0, 306, 308, 3, 34, 17, 0, 307,
		309, 3, 26, 13, 0, 308, 307, 1, 0, 0, 0, 308, 309, 1, 0, 0, 0, 309, 310,
		1, 0, 0, 0, 310, 311, 3, 176, 88, 0, 311, 313, 1, 0, 0, 0, 312, 302, 1,
		0, 0, 0, 312, 306, 1, 0, 0, 0, 313, 33, 1, 0, 0, 0, 314, 320, 5, 9, 0,
		0, 315, 316, 3, 36, 18, 0, 316, 317, 5, 13, 0, 0, 317, 319, 1, 0, 0, 0,
		318, 315, 1, 0, 0, 0, 319, 322, 1, 0, 0, 0, 320, 318, 1, 0, 0, 0, 320,
		321, 1, 0, 0, 0, 321, 327, 1, 0, 0, 0, 322, 320, 1, 0, 0, 0, 323, 325,
		3, 36, 18, 0, 324, 326, 5, 13, 0, 0, 325, 324, 1, 0, 0, 0, 325, 326, 1,
		0, 0, 0, 326, 328, 1, 0, 0, 0, 327, 323, 1, 0, 0, 0, 327, 328, 1, 0, 0,
		0, 328, 329, 1, 0, 0, 0, 329, 330, 5, 11, 0, 0, 330, 35, 1, 0, 0, 0, 331,
		334, 3, 18, 9, 0, 332, 333, 5, 98, 0, 0, 333, 335, 3, 18, 9, 0, 334, 332,
		1, 0, 0, 0, 334, 335, 1, 0, 0, 0, 335, 37, 1, 0, 0, 0, 336, 340, 3, 40,
		20, 0, 337, 340, 3, 96, 48, 0, 338, 340, 3, 94, 47, 0, 339, 336, 1, 0,
		0, 0, 339, 337, 1, 0, 0, 0, 339, 338, 1, 0, 0, 0, 340, 39, 1, 0, 0, 0,
		341, 342, 3, 42, 21, 0, 342, 343, 3, 176, 88, 0, 343, 41, 1, 0, 0, 0, 344,
		345, 3, 60, 30, 0, 345, 350, 3, 44, 22, 0, 346, 347, 5, 13, 0, 0, 347,
		349, 3, 44, 22, 0, 348, 346, 1, 0, 0, 0, 349, 352, 1, 0, 0, 0, 350, 348,
		1, 0, 0, 0, 350, 351, 1, 0, 0, 0, 351, 43, 1, 0, 0, 0, 352, 350, 1, 0,
		0, 0, 353, 356, 3, 140, 70, 0, 354, 355, 5, 14, 0, 0, 355, 357, 3, 136,
		68, 0, 356, 354, 1, 0, 0, 0, 356, 357, 1, 0, 0, 0, 357, 45, 1, 0, 0, 0,
		358, 359, 5, 12, 0, 0, 359, 47, 1, 0, 0, 0, 360, 361, 4, 24, 0, 0, 361,
		362, 3, 134, 67, 0, 362, 363, 3, 176, 88, 0, 363, 49, 1, 0, 0, 0, 364,
		365, 5, 93, 0, 0, 365, 366, 5, 7, 0, 0, 366, 367, 3, 136, 68, 0, 367, 368,
		5, 8, 0, 0, 368, 371, 3, 4, 2, 0, 369, 370, 5, 77, 0, 0, 370, 372, 3, 4,
		2, 0, 371, 369, 1, 0, 0, 0, 371, 372, 1, 0, 0, 0, 372, 51, 1, 0, 0, 0,
		373, 376, 3, 136, 68, 0, 374, 376, 3, 42, 21, 0, 375, 373, 1, 0, 0, 0,
		375, 374, 1, 0, 0, 0, 376, 53, 1, 0, 0, 0, 377, 378, 3, 136, 68, 0, 378,
		55, 1, 0, 0, 0, 379, 380, 3, 136, 68, 0, 380, 57, 1, 0, 0, 0, 381, 382,
		5, 73, 0, 0, 382, 383, 3, 4, 2, 0, 383, 384, 5, 87, 0, 0, 384, 385, 5,
		7, 0, 0, 385, 386, 3, 136, 68, 0, 386, 387, 5, 8, 0, 0, 387, 388, 3, 176,
		88, 0, 388, 437, 1, 0, 0, 0, 389, 390, 5, 87, 0, 0, 390, 391, 5, 7, 0,
		0, 391, 392, 3, 136, 68, 0, 392, 393, 5, 8, 0, 0, 393, 394, 3, 4, 2, 0,
		394, 437, 1, 0, 0, 0, 395, 396, 5, 85, 0, 0, 396, 398, 5, 7, 0, 0, 397,
		399, 3, 52, 26, 0, 398, 397, 1, 0, 0, 0, 398, 399, 1, 0, 0, 0, 399, 400,
		1, 0, 0, 0, 400, 402, 5, 12, 0, 0, 401, 403, 3, 54, 27, 0, 402, 401, 1,
		0, 0, 0, 402, 403, 1, 0, 0, 0, 403, 404, 1, 0, 0, 0, 404, 406, 5, 12, 0,
		0, 405, 407, 3, 56, 28, 0, 406, 405, 1, 0, 0, 0, 406, 407, 1, 0, 0, 0,
		407, 408, 1, 0, 0, 0, 408, 409, 5, 8, 0, 0, 409, 437, 3, 4, 2, 0, 410,
		411, 5, 85, 0, 0, 411, 414, 5, 7, 0, 0, 412, 415, 3, 136, 68, 0, 413, 415,
		3, 44, 22, 0, 414, 412, 1, 0, 0, 0, 414, 413, 1, 0, 0, 0, 415, 416, 1,
		0, 0, 0, 416, 417, 5, 96, 0, 0, 417, 418, 3, 136, 68, 0, 418, 419, 5, 8,
		0, 0, 419, 420, 3, 4, 2, 0, 420, 437, 1, 0, 0, 0, 421, 423, 5, 85, 0, 0,
		422, 424, 5, 108, 0, 0, 423, 422, 1, 0, 0, 0, 423, 424, 1, 0, 0, 0, 424,
		425, 1, 0, 0, 0, 425, 428, 5, 7, 0, 0, 426, 429, 3, 136, 68, 0, 427, 429,
		3, 44, 22, 0, 428, 426, 1, 0, 0, 0, 428, 427, 1, 0, 0, 0, 429, 430, 1,
		0, 0, 0, 430, 431, 3, 168, 84, 0, 431, 432, 4, 29, 1, 0, 432, 433, 3, 136,
		68, 0, 433, 434, 5, 8, 0, 0, 434, 435, 3, 4, 2, 0, 435, 437, 1, 0, 0, 0,
		436, 381, 1, 0, 0, 0, 436, 389, 1, 0, 0, 0, 436, 395, 1, 0, 0, 0, 436,
		410, 1, 0, 0, 0, 436, 421, 1, 0, 0, 0, 437, 59, 1, 0, 0, 0, 438, 442, 5,
		79, 0, 0, 439, 442, 3, 174, 87, 0, 440, 442, 5, 104, 0, 0, 441, 438, 1,
		0, 0, 0, 441, 439, 1, 0, 0, 0, 441, 440, 1, 0, 0, 0, 442, 61, 1, 0, 0,
		0, 443, 446, 5, 84, 0, 0, 444, 445, 4, 31, 2, 0, 445, 447, 3, 168, 84,
		0, 446, 444, 1, 0, 0, 0, 446, 447, 1, 0, 0, 0, 447, 448, 1, 0, 0, 0, 448,
		449, 3, 176, 88, 0, 449, 63, 1, 0, 0, 0, 450, 453, 5, 72, 0, 0, 451, 452,
		4, 32, 3, 0, 452, 454, 3, 168, 84, 0, 453, 451, 1, 0, 0, 0, 453, 454, 1,
		0, 0, 0, 454, 455, 1, 0, 0, 0, 455, 456, 3, 176, 88, 0, 456, 65, 1, 0,
		0, 0, 457, 460, 5, 82, 0, 0, 458, 459, 4, 33, 4, 0, 459, 461, 3, 134, 67,
		0, 460, 458, 1, 0, 0, 0, 460, 461, 1, 0, 0, 0, 461, 462, 1, 0, 0, 0, 462,
		463, 3, 176, 88, 0, 463, 67, 1, 0, 0, 0, 464, 467, 5, 109, 0, 0, 465, 466,
		4, 34, 5, 0, 466, 468, 3, 134, 67, 0, 467, 465, 1, 0, 0, 0, 467, 468, 1,
		0, 0, 0, 468, 469, 1, 0, 0, 0, 469, 470, 3, 176, 88, 0, 470, 69, 1, 0,
		0, 0, 471, 472, 5, 91, 0, 0, 472, 473, 5, 7, 0, 0, 473, 474, 3, 134, 67,
		0, 474, 475, 5, 8, 0, 0, 475, 476, 3, 4, 2, 0, 476, 71, 1, 0, 0, 0, 477,
		478, 5, 86, 0, 0, 478, 479, 5, 7, 0, 0, 479, 480, 3, 136, 68, 0, 480, 481,
		5, 8, 0, 0, 481, 482, 3, 74, 37, 0, 482, 73, 1, 0, 0, 0, 483, 485, 5, 9,
		0, 0, 484, 486, 3, 76, 38, 0, 485, 484, 1, 0, 0, 0, 485, 486, 1, 0, 0,
		0, 486, 491, 1, 0, 0, 0, 487, 489, 3, 80, 40, 0, 488, 490, 3, 76, 38, 0,
		489, 488, 1, 0, 0, 0, 489, 490, 1, 0, 0, 0, 490, 492, 1, 0, 0, 0, 491,
		487, 1, 0, 0, 0, 491, 492, 1, 0, 0, 0, 492, 493, 1, 0, 0, 0, 493, 494,
		5, 11, 0, 0, 494, 75, 1, 0, 0, 0, 495, 497, 3, 78, 39, 0, 496, 495, 1,
		0, 0, 0, 497, 498, 1, 0, 0, 0, 498, 496, 1, 0, 0, 0, 498, 499, 1, 0, 0,
		0, 499, 77, 1, 0, 0, 0, 500, 501, 5, 76, 0, 0, 501, 502, 3, 136, 68, 0,
		502, 504, 5, 17, 0, 0, 503, 505, 3, 8, 4, 0, 504, 503, 1, 0, 0, 0, 504,
		505, 1, 0, 0, 0, 505, 79, 1, 0, 0, 0, 506, 507, 5, 92, 0, 0, 507, 509,
		5, 17, 0, 0, 508, 510, 3, 8, 4, 0, 509, 508, 1, 0, 0, 0, 509, 510, 1, 0,
		0, 0, 510, 81, 1, 0, 0, 0, 511, 512, 3, 168, 84, 0, 512, 513, 5, 17, 0,
		0, 513, 514, 3, 4, 2, 0, 514, 83, 1, 0, 0, 0, 515, 516, 5, 94, 0, 0, 516,
		517, 4, 42, 6, 0, 517, 518, 3, 134, 67, 0, 518, 519, 3, 176, 88, 0, 519,
		85, 1, 0, 0, 0, 520, 521, 5, 97, 0, 0, 521, 527, 3, 6, 3, 0, 522, 524,
		3, 88, 44, 0, 523, 525, 3, 90, 45, 0, 524, 523, 1, 0, 0, 0, 524, 525, 1,
		0, 0, 0, 525, 528, 1, 0, 0, 0, 526, 528, 3, 90, 45, 0, 527, 522, 1, 0,
		0, 0, 527, 526, 1, 0, 0, 0, 528, 87, 1, 0, 0, 0, 529, 535, 5, 80, 0, 0,
		530, 532, 5, 7, 0, 0, 531, 533, 3, 140, 70, 0, 532, 531, 1, 0, 0, 0, 532,
		533, 1, 0, 0, 0, 533, 534, 1, 0, 0, 0, 534, 536, 5, 8, 0, 0, 535, 530,
		1, 0, 0, 0, 535, 536, 1, 0, 0, 0, 536, 537, 1, 0, 0, 0, 537, 538, 3, 6,
		3, 0, 538, 89, 1, 0, 0, 0, 539, 540, 5, 81, 0, 0, 540, 541, 3, 6, 3, 0,
		541, 91, 1, 0, 0, 0, 542, 543, 5, 88, 0, 0, 543, 544, 3, 176, 88, 0, 544,
		93, 1, 0, 0, 0, 545, 547, 5, 107, 0, 0, 546, 545, 1, 0, 0, 0, 546, 547,
		1, 0, 0, 0, 547, 548, 1, 0, 0, 0, 548, 550, 5, 89, 0, 0, 549, 551, 5, 26,
		0, 0, 550, 549, 1, 0, 0, 0, 550, 551, 1, 0, 0, 0, 551, 552, 1, 0, 0, 0,
		552, 553, 3, 168, 84, 0, 553, 555, 5, 7, 0, 0, 554, 556, 3, 110, 55, 0,
		555, 554, 1, 0, 0, 0, 555, 556, 1, 0, 0, 0, 556, 557, 1, 0, 0, 0, 557,
		558, 5, 8, 0, 0, 558, 559, 3, 116, 58, 0, 559, 95, 1, 0, 0, 0, 560, 561,
		5, 100, 0, 0, 561, 562, 3, 168, 84, 0, 562, 563, 3, 98, 49, 0, 563, 97,
		1, 0, 0, 0, 564, 565, 5, 102, 0, 0, 565, 567, 3, 136, 68, 0, 566, 564,
		1, 0, 0, 0, 566, 567, 1, 0, 0, 0, 567, 568, 1, 0, 0, 0, 568, 572, 5, 9,
		0, 0, 569, 571, 3, 100, 50, 0, 570, 569, 1, 0, 0, 0, 571, 574, 1, 0, 0,
		0, 572, 570, 1, 0, 0, 0, 572, 573, 1, 0, 0, 0, 573, 575, 1, 0, 0, 0, 574,
		572, 1, 0, 0, 0, 575, 576, 5, 11, 0, 0, 576, 99, 1, 0, 0, 0, 577, 581,
		5, 118, 0, 0, 578, 579, 4, 50, 7, 0, 579, 581, 3, 168, 84, 0, 580, 577,
		1, 0, 0, 0, 580, 578, 1, 0, 0, 0, 580, 581, 1, 0, 0, 0, 581, 582, 1, 0,
		0, 0, 582, 597, 3, 102, 51, 0, 583, 587, 5, 118, 0, 0, 584, 585, 4, 50,
		8, 0, 585, 587, 3, 168, 84, 0, 586, 583, 1, 0, 0, 0, 586, 584, 1, 0, 0,
		0, 586, 587, 1, 0, 0, 0, 587, 588, 1, 0, 0, 0, 588, 597, 3, 104, 52, 0,
		589, 593, 5, 118, 0, 0, 590, 591, 4, 50, 9, 0, 591, 593, 3, 168, 84, 0,
		592, 589, 1, 0, 0, 0, 592, 590, 1, 0, 0, 0, 593, 594, 1, 0, 0, 0, 594,
		597, 3, 6, 3, 0, 595, 597, 3, 46, 23, 0, 596, 580, 1, 0, 0, 0, 596, 586,
		1, 0, 0, 0, 596, 592, 1, 0, 0, 0, 596, 595, 1, 0, 0, 0, 597, 101, 1, 0,
		0, 0, 598, 599, 5, 107, 0, 0, 599, 601, 4, 51, 10, 0, 600, 598, 1, 0, 0,
		0, 600, 601, 1, 0, 0, 0, 601, 603, 1, 0, 0, 0, 602, 604, 5, 26, 0, 0, 603,
		602, 1, 0, 0, 0, 603, 604, 1, 0, 0, 0, 604, 605, 1, 0, 0, 0, 605, 606,
		3, 106, 53, 0, 606, 608, 5, 7, 0, 0, 607, 609, 3, 110, 55, 0, 608, 607,
		1, 0, 0, 0, 608, 609, 1, 0, 0, 0, 609, 610, 1, 0, 0, 0, 610, 611, 5, 8,
		0, 0, 611, 612, 3, 116, 58, 0, 612, 633, 1, 0, 0, 0, 613, 615, 5, 26, 0,
		0, 614, 613, 1, 0, 0, 0, 614, 615, 1, 0, 0, 0, 615, 616, 1, 0, 0, 0, 616,
		617, 3, 162, 81, 0, 617, 618, 5, 7, 0, 0, 618, 619, 5, 8, 0, 0, 619, 620,
		3, 116, 58, 0, 620, 633, 1, 0, 0, 0, 621, 623, 5, 26, 0, 0, 622, 621, 1,
		0, 0, 0, 622, 623, 1, 0, 0, 0, 623, 624, 1, 0, 0, 0, 624, 625, 3, 164,
		82, 0, 625, 627, 5, 7, 0, 0, 626, 628, 3, 110, 55, 0, 627, 626, 1, 0, 0,
		0, 627, 628, 1, 0, 0, 0, 628, 629, 1, 0, 0, 0, 629, 630, 5, 8, 0, 0, 630,
		631, 3, 116, 58, 0, 631, 633, 1, 0, 0, 0, 632, 600, 1, 0, 0, 0, 632, 614,
		1, 0, 0, 0, 632, 622, 1, 0, 0, 0, 633, 103, 1, 0, 0, 0, 634, 636, 3, 106,
		53, 0, 635, 637, 3, 138, 69, 0, 636, 635, 1, 0, 0, 0, 636, 637, 1, 0, 0,
		0, 637, 105, 1, 0, 0, 0, 638, 641, 3, 128, 64, 0, 639, 641, 3, 108, 54,
		0, 640, 638, 1, 0, 0, 0, 640, 639, 1, 0, 0, 0, 641, 107, 1, 0, 0, 0, 642,
		643, 5, 31, 0, 0, 643, 644, 3, 166, 83, 0, 644, 109, 1, 0, 0, 0, 645, 650,
		3, 112, 56, 0, 646, 647, 5, 13, 0, 0, 647, 649, 3, 112, 56, 0, 648, 646,
		1, 0, 0, 0, 649, 652, 1, 0, 0, 0, 650, 648, 1, 0, 0, 0, 650, 651, 1, 0,
		0, 0, 651, 655, 1, 0, 0, 0, 652, 650, 1, 0, 0, 0, 653, 654, 5, 13, 0, 0,
		654, 656, 3, 114, 57, 0, 655, 653, 1, 0, 0, 0, 655, 656, 1, 0, 0, 0, 656,
		659, 1, 0, 0, 0, 657, 659, 3, 114, 57, 0, 658, 645, 1, 0, 0, 0, 658, 657,
		1, 0, 0, 0, 659, 111, 1, 0, 0, 0, 660, 663, 3, 140, 70, 0, 661, 662, 5,
		14, 0, 0, 662, 664, 3, 136, 68, 0, 663, 661, 1, 0, 0, 0, 663, 664, 1, 0,
		0, 0, 664, 113, 1, 0, 0, 0, 665, 666, 5, 18, 0, 0, 666, 667, 3, 136, 68,
		0, 667, 115, 1, 0, 0, 0, 668, 670, 5, 9, 0, 0, 669, 671, 3, 118, 59, 0,
		670, 669, 1, 0, 0, 0, 670, 671, 1, 0, 0, 0, 671, 672, 1, 0, 0, 0, 672,
		673, 5, 11, 0, 0, 673, 117, 1, 0, 0, 0, 674, 676, 3, 2, 1, 0, 675, 674,
		1, 0, 0, 0, 676, 677, 1, 0, 0, 0, 677, 675, 1, 0, 0, 0, 677, 678, 1, 0,
		0, 0, 678, 119, 1, 0, 0, 0, 679, 680, 5, 5, 0, 0, 680, 681, 3, 122, 61,
		0, 681, 682, 5, 6, 0, 0, 682, 121, 1, 0, 0, 0, 683, 685, 5, 13, 0, 0, 684,
		683, 1, 0, 0, 0, 685, 688, 1, 0, 0, 0, 686, 684, 1, 0, 0, 0, 686, 687,
		1, 0, 0, 0, 687, 690, 1, 0, 0, 0, 688, 686, 1, 0, 0, 0, 689, 691, 3, 124,
		62, 0, 690, 689, 1, 0, 0, 0, 690, 691, 1, 0, 0, 0, 691, 700, 1, 0, 0, 0,
		692, 694, 5, 13, 0, 0, 693, 692, 1, 0, 0, 0, 694, 695, 1, 0, 0, 0, 695,
		693, 1, 0, 0, 0, 695, 696, 1, 0, 0, 0, 696, 697, 1, 0, 0, 0, 697, 699,
		3, 124, 62, 0, 698, 693, 1, 0, 0, 0, 699, 702, 1, 0, 0, 0, 700, 698, 1,
		0, 0, 0, 700, 701, 1, 0, 0, 0, 701, 706, 1, 0, 0, 0, 702, 700, 1, 0, 0,
		0, 703, 705, 5, 13, 0, 0, 704, 703, 1, 0, 0, 0, 705, 708, 1, 0, 0, 0, 706,
		704, 1, 0, 0, 0, 706, 707, 1, 0, 0, 0, 707, 123, 1, 0, 0, 0, 708, 706,
		1, 0, 0, 0, 709, 711, 5, 18, 0, 0, 710, 709, 1, 0, 0, 0, 710, 711, 1, 0,
		0, 0, 711, 712, 1, 0, 0, 0, 712, 713, 3, 136, 68, 0, 713, 125, 1, 0, 0,
		0, 714, 715, 3, 128, 64, 0, 715, 716, 5, 17, 0, 0, 716, 717, 3, 136, 68,
		0, 717, 754, 1, 0, 0, 0, 718, 719, 5, 5, 0, 0, 719, 720, 3, 136, 68, 0,
		720, 721, 5, 6, 0, 0, 721, 722, 5, 17, 0, 0, 722, 723, 3, 136, 68, 0, 723,
		754, 1, 0, 0, 0, 724, 726, 5, 107, 0, 0, 725, 724, 1, 0, 0, 0, 725, 726,
		1, 0, 0, 0, 726, 728, 1, 0, 0, 0, 727, 729, 5, 26, 0, 0, 728, 727, 1, 0,
		0, 0, 728, 729, 1, 0, 0, 0, 729, 730, 1, 0, 0, 0, 730, 731, 3, 128, 64,
		0, 731, 733, 5, 7, 0, 0, 732, 734, 3, 110, 55, 0, 733, 732, 1, 0, 0, 0,
		733, 734, 1, 0, 0, 0, 734, 735, 1, 0, 0, 0, 735, 736, 5, 8, 0, 0, 736,
		737, 3, 116, 58, 0, 737, 754, 1, 0, 0, 0, 738, 739, 3, 162, 81, 0, 739,
		740, 5, 7, 0, 0, 740, 741, 5, 8, 0, 0, 741, 742, 3, 116, 58, 0, 742, 754,
		1, 0, 0, 0, 743, 744, 3, 164, 82, 0, 744, 745, 5, 7, 0, 0, 745, 746, 3,
		112, 56, 0, 746, 747, 5, 8, 0, 0, 747, 748, 3, 116, 58, 0, 748, 754, 1,
		0, 0, 0, 749, 751, 5, 18, 0, 0, 750, 749, 1, 0, 0, 0, 750, 751, 1, 0, 0,
		0, 751, 752, 1, 0, 0, 0, 752, 754, 3, 136, 68, 0, 753, 714, 1, 0, 0, 0,
		753, 718, 1, 0, 0, 0, 753, 725, 1, 0, 0, 0, 753, 738, 1, 0, 0, 0, 753,
		743, 1, 0, 0, 0, 753, 750, 1, 0, 0, 0, 754, 127, 1, 0, 0, 0, 755, 763,
		3, 166, 83, 0, 756, 763, 5, 120, 0, 0, 757, 763, 3, 158, 79, 0, 758, 759,
		5, 5, 0, 0, 759, 760, 3, 136, 68, 0, 760, 761, 5, 6, 0, 0, 761, 763, 1,
		0, 0, 0, 762, 755, 1, 0, 0, 0, 762, 756, 1, 0, 0, 0, 762, 757, 1, 0, 0,
		0, 762, 758, 1, 0, 0, 0, 763, 129, 1, 0, 0, 0, 764, 776, 5, 7, 0, 0, 765,
		770, 3, 132, 66, 0, 766, 767, 5, 13, 0, 0, 767, 769, 3, 132, 66, 0, 768,
		766, 1, 0, 0, 0, 769, 772, 1, 0, 0, 0, 770, 768, 1, 0, 0, 0, 770, 771,
		1, 0, 0, 0, 771, 774, 1, 0, 0, 0, 772, 770, 1, 0, 0, 0, 773, 775, 5, 13,
		0, 0, 774, 773, 1, 0, 0, 0, 774, 775, 1, 0, 0, 0, 775, 777, 1, 0, 0, 0,
		776, 765, 1, 0, 0, 0, 776, 777, 1, 0, 0, 0, 777, 778, 1, 0, 0, 0, 778,
		779, 5, 8, 0, 0, 779, 131, 1, 0, 0, 0, 780, 782, 5, 18, 0, 0, 781, 780,
		1, 0, 0, 0, 781, 782, 1, 0, 0, 0, 782, 785, 1, 0, 0, 0, 783, 786, 3, 136,
		68, 0, 784, 786, 3, 168, 84, 0, 785, 783, 1, 0, 0, 0, 785, 784, 1, 0, 0,
		0, 786, 133, 1, 0, 0, 0, 787, 792, 3, 136, 68, 0, 788, 789, 5, 13, 0, 0,
		789, 791, 3, 136, 68, 0, 790, 788, 1, 0, 0, 0, 791, 794, 1, 0, 0, 0, 792,
		790, 1, 0, 0, 0, 792, 793, 1, 0, 0, 0, 793, 135, 1, 0, 0, 0, 794, 792,
		1, 0, 0, 0, 795, 796, 6, 68, -1, 0, 796, 848, 3, 144, 72, 0, 797, 799,
		5, 100, 0, 0, 798, 800, 3, 168, 84, 0, 799, 798, 1, 0, 0, 0, 799, 800,
		1, 0, 0, 0, 800, 801, 1, 0, 0, 0, 801, 848, 3, 98, 49, 0, 802, 803, 5,
		78, 0, 0, 803, 804, 3, 136, 68, 0, 804, 805, 3, 130, 65, 0, 805, 848, 1,
		0, 0, 0, 806, 807, 5, 78, 0, 0, 807, 848, 3, 136, 68, 42, 808, 809, 5,
		78, 0, 0, 809, 810, 5, 19, 0, 0, 810, 848, 3, 168, 84, 0, 811, 812, 5,
		95, 0, 0, 812, 848, 3, 136, 68, 37, 813, 814, 5, 83, 0, 0, 814, 848, 3,
		136, 68, 36, 815, 816, 5, 75, 0, 0, 816, 848, 3, 136, 68, 35, 817, 818,
		5, 20, 0, 0, 818, 848, 3, 136, 68, 34, 819, 820, 5, 21, 0, 0, 820, 848,
		3, 136, 68, 33, 821, 822, 5, 22, 0, 0, 822, 848, 3, 136, 68, 32, 823, 824,
		5, 23, 0, 0, 824, 848, 3, 136, 68, 31, 825, 826, 5, 24, 0, 0, 826, 848,
		3, 136, 68, 30, 827, 828, 5, 25, 0, 0, 828, 848, 3, 136, 68, 29, 829, 830,
		5, 108, 0, 0, 830, 848, 3, 136, 68, 28, 831, 832, 5, 106, 0, 0, 832, 833,
		5, 7, 0, 0, 833, 834, 3, 136, 68, 0, 834, 835, 5, 8, 0, 0, 835, 848, 1,
		0, 0, 0, 836, 848, 3, 68, 34, 0, 837, 848, 5, 90, 0, 0, 838, 848, 3, 168,
		84, 0, 839, 848, 5, 103, 0, 0, 840, 848, 3, 152, 76, 0, 841, 848, 3, 120,
		60, 0, 842, 848, 3, 142, 71, 0, 843, 844, 5, 7, 0, 0, 844, 845, 3, 134,
		67, 0, 845, 846, 5, 8, 0, 0, 846, 848, 1, 0, 0, 0, 847, 795, 1, 0, 0, 0,
		847, 797, 1, 0, 0, 0, 847, 802, 1, 0, 0, 0, 847, 806, 1, 0, 0, 0, 847,
		808, 1, 0, 0, 0, 847, 811, 1, 0, 0, 0, 847, 813, 1, 0, 0, 0, 847, 815,
		1, 0, 0, 0, 847, 817, 1, 0, 0, 0, 847, 819, 1, 0, 0, 0, 847, 821, 1, 0,
		0, 0, 847, 823, 1, 0, 0, 0, 847, 825, 1, 0, 0, 0, 847, 827, 1, 0, 0, 0,
		847, 829, 1, 0, 0, 0, 847, 831, 1, 0, 0, 0, 847, 836, 1, 0, 0, 0, 847,
		837, 1, 0, 0, 0, 847, 838, 1, 0, 0, 0, 847, 839, 1, 0, 0, 0, 847, 840,
		1, 0, 0, 0, 847, 841, 1, 0, 0, 0, 847, 842, 1, 0, 0, 0, 847, 843, 1, 0,
		0, 0, 848, 936, 1, 0, 0, 0, 849, 850, 10, 46, 0, 0, 850, 851, 5, 16, 0,
		0, 851, 935, 3, 136, 68, 47, 852, 853, 10, 27, 0, 0, 853, 854, 5, 29, 0,
		0, 854, 935, 3, 136, 68, 27, 855, 856, 10, 26, 0, 0, 856, 857, 7, 1, 0,
		0, 857, 935, 3, 136, 68, 27, 858, 859, 10, 25, 0, 0, 859, 860, 7, 2, 0,
		0, 860, 935, 3, 136, 68, 26, 861, 862, 10, 24, 0, 0, 862, 863, 5, 30, 0,
		0, 863, 935, 3, 136, 68, 25, 864, 865, 10, 23, 0, 0, 865, 866, 7, 3, 0,
		0, 866, 935, 3, 136, 68, 24, 867, 868, 10, 22, 0, 0, 868, 869, 7, 4, 0,
		0, 869, 935, 3, 136, 68, 23, 870, 871, 10, 21, 0, 0, 871, 872, 5, 74, 0,
		0, 872, 935, 3, 136, 68, 22, 873, 874, 10, 20, 0, 0, 874, 875, 5, 96, 0,
		0, 875, 935, 3, 136, 68, 21, 876, 877, 10, 19, 0, 0, 877, 878, 7, 5, 0,
		0, 878, 935, 3, 136, 68, 20, 879, 880, 10, 18, 0, 0, 880, 881, 5, 43, 0,
		0, 881, 935, 3, 136, 68, 19, 882, 883, 10, 17, 0, 0, 883, 884, 5, 44, 0,
		0, 884, 935, 3, 136, 68, 18, 885, 886, 10, 16, 0, 0, 886, 887, 5, 45, 0,
		0, 887, 935, 3, 136, 68, 17, 888, 889, 10, 15, 0, 0, 889, 890, 5, 46, 0,
		0, 890, 935, 3, 136, 68, 16, 891, 892, 10, 14, 0, 0, 892, 893, 5, 47, 0,
		0, 893, 935, 3, 136, 68, 15, 894, 895, 10, 13, 0, 0, 895, 896, 5, 15, 0,
		0, 896, 897, 3, 136, 68, 0, 897, 898, 5, 17, 0, 0, 898, 899, 3, 136, 68,
		14, 899, 935, 1, 0, 0, 0, 900, 901, 10, 12, 0, 0, 901, 902, 5, 14, 0, 0,
		902, 935, 3, 136, 68, 12, 903, 904, 10, 11, 0, 0, 904, 905, 3, 150, 75,
		0, 905, 906, 3, 136, 68, 11, 906, 935, 1, 0, 0, 0, 907, 909, 10, 45, 0,
		0, 908, 910, 5, 16, 0, 0, 909, 908, 1, 0, 0, 0, 909, 910, 1, 0, 0, 0, 910,
		911, 1, 0, 0, 0, 911, 912, 5, 5, 0, 0, 912, 913, 3, 136, 68, 0, 913, 914,
		5, 6, 0, 0, 914, 935, 1, 0, 0, 0, 915, 917, 10, 44, 0, 0, 916, 918, 5,
		15, 0, 0, 917, 916, 1, 0, 0, 0, 917, 918, 1, 0, 0, 0, 918, 919, 1, 0, 0,
		0, 919, 921, 5, 19, 0, 0, 920, 922, 5, 31, 0, 0, 921, 920, 1, 0, 0, 0,
		921, 922, 1, 0, 0, 0, 922, 923, 1, 0, 0, 0, 923, 935, 3, 166, 83, 0, 924,
		925, 10, 41, 0, 0, 925, 935, 3, 130, 65, 0, 926, 927, 10, 39, 0, 0, 927,
		928, 4, 68, 33, 0, 928, 935, 5, 20, 0, 0, 929, 930, 10, 38, 0, 0, 930,
		931, 4, 68, 35, 0, 931, 935, 5, 21, 0, 0, 932, 933, 10, 9, 0, 0, 933, 935,
		3, 154, 77, 0, 934, 849, 1, 0, 0, 0, 934, 852, 1, 0, 0, 0, 934, 855, 1,
		0, 0, 0, 934, 858, 1, 0, 0, 0, 934, 861, 1, 0, 0, 0, 934, 864, 1, 0, 0,
		0, 934, 867, 1, 0, 0, 0, 934, 870, 1, 0, 0, 0, 934, 873, 1, 0, 0, 0, 934,
		876, 1, 0, 0, 0, 934, 879, 1, 0, 0, 0, 934, 882, 1, 0, 0, 0, 934, 885,
		1, 0, 0, 0, 934, 888, 1, 0, 0, 0, 934, 891, 1, 0, 0, 0, 934, 894, 1, 0,
		0, 0, 934, 900, 1, 0, 0, 0, 934, 903, 1, 0, 0, 0, 934, 907, 1, 0, 0, 0,
		934, 915, 1, 0, 0, 0, 934, 924, 1, 0, 0, 0, 934, 926, 1, 0, 0, 0, 934,
		929, 1, 0, 0, 0, 934, 932, 1, 0, 0, 0, 935, 938, 1, 0, 0, 0, 936, 934,
		1, 0, 0, 0, 936, 937, 1, 0, 0, 0, 937, 137, 1, 0, 0, 0, 938, 936, 1, 0,
		0, 0, 939, 940, 5, 14, 0, 0, 940, 941, 3, 136, 68, 0, 941, 139, 1, 0, 0,
		0, 942, 946, 3, 168, 84, 0, 943, 946, 3, 120, 60, 0, 944, 946, 3, 142,
		71, 0, 945, 942, 1, 0, 0, 0, 945, 943, 1, 0, 0, 0, 945, 944, 1, 0, 0, 0,
		946, 141, 1, 0, 0, 0, 947, 959, 5, 9, 0, 0, 948, 953, 3, 126, 63, 0, 949,
		950, 5, 13, 0, 0, 950, 952, 3, 126, 63, 0, 951, 949, 1, 0, 0, 0, 952, 955,
		1, 0, 0, 0, 953, 951, 1, 0, 0, 0, 953, 954, 1, 0, 0, 0, 954, 957, 1, 0,
		0, 0, 955, 953, 1, 0, 0, 0, 956, 958, 5, 13, 0, 0, 957, 956, 1, 0, 0, 0,
		957, 958, 1, 0, 0, 0, 958, 960, 1, 0, 0, 0, 959, 948, 1, 0, 0, 0, 959,
		960, 1, 0, 0, 0, 960, 961, 1, 0, 0, 0, 961, 962, 5, 11, 0, 0, 962, 143,
		1, 0, 0, 0, 963, 965, 5, 107, 0, 0, 964, 963, 1, 0, 0, 0, 964, 965, 1,
		0, 0, 0, 965, 966, 1, 0, 0, 0, 966, 968, 5, 89, 0, 0, 967, 969, 5, 26,
		0, 0, 968, 967, 1, 0, 0, 0, 968, 969, 1, 0, 0, 0, 969, 970, 1, 0, 0, 0,
		970, 972, 5, 7, 0, 0, 971, 973, 3, 110, 55, 0, 972, 971, 1, 0, 0, 0, 972,
		973, 1, 0, 0, 0, 973, 974, 1, 0, 0, 0, 974, 975, 5, 8, 0, 0, 975, 984,
		3, 116, 58, 0, 976, 978, 5, 107, 0, 0, 977, 976, 1, 0, 0, 0, 977, 978,
		1, 0, 0, 0, 978, 979, 1, 0, 0, 0, 979, 980, 3, 146, 73, 0, 980, 981, 5,
		60, 0, 0, 981, 982, 3, 148, 74, 0, 982, 984, 1, 0, 0, 0, 983, 964, 1, 0,
		0, 0, 983, 977, 1, 0, 0, 0, 984, 145, 1, 0, 0, 0, 985, 992, 3, 168, 84,
		0, 986, 988, 5, 7, 0, 0, 987, 989, 3, 110, 55, 0, 988, 987, 1, 0, 0, 0,
		988, 989, 1, 0, 0, 0, 989, 990, 1, 0, 0, 0, 990, 992, 5, 8, 0, 0, 991,
		985, 1, 0, 0, 0, 991, 986, 1, 0, 0, 0, 992, 147, 1, 0, 0, 0, 993, 996,
		3, 136, 68, 0, 994, 996, 3, 116, 58, 0, 995, 993, 1, 0, 0, 0, 995, 994,
		1, 0, 0, 0, 996, 149, 1, 0, 0, 0, 997, 998, 7, 6, 0, 0, 998, 151, 1, 0,
		0, 0, 999, 1007, 5, 61, 0, 0, 1000, 1007, 5, 62, 0, 0, 1001, 1007, 5, 120,
		0, 0, 1002, 1007, 3, 154, 77, 0, 1003, 1007, 5, 4, 0, 0, 1004, 1007, 3,
		158, 79, 0, 1005, 1007, 3, 160, 80, 0, 1006, 999, 1, 0, 0, 0, 1006, 1000,
		1, 0, 0, 0, 1006, 1001, 1, 0, 0, 0, 1006, 1002, 1, 0, 0, 0, 1006, 1003,
		1, 0, 0, 0, 1006, 1004, 1, 0, 0, 0, 1006, 1005, 1, 0, 0, 0, 1007, 153,
		1, 0, 0, 0, 1008, 1012, 5, 121, 0, 0, 1009, 1011, 3, 156, 78, 0, 1010,
		1009, 1, 0, 0, 0, 1011, 1014, 1, 0, 0, 0, 1012, 1010, 1, 0, 0, 0, 1012,
		1013, 1, 0, 0, 0, 1013, 1015, 1, 0, 0, 0, 1014, 1012, 1, 0, 0, 0, 1015,
		1016, 5, 121, 0, 0, 1016, 155, 1, 0, 0, 0, 1017, 1023, 5, 128, 0, 0, 1018,
		1019, 5, 127, 0, 0, 1019, 1020, 3, 136, 68, 0, 1020, 1021, 5, 10, 0, 0,
		1021, 1023, 1, 0, 0, 0, 1022, 1017, 1, 0, 0, 0, 1022, 1018, 1, 0, 0, 0,
		1023, 157, 1, 0, 0, 0, 1024, 1025, 7, 7, 0, 0, 1025, 159, 1, 0, 0, 0, 1026,
		1027, 7, 8, 0, 0, 1027, 161, 1, 0, 0, 0, 1028, 1029, 4, 81, 37, 0, 1029,
		1030, 3, 168, 84, 0, 1030, 1031, 3, 106, 53, 0, 1031, 163, 1, 0, 0, 0,
		1032, 1033, 4, 82, 38, 0, 1033, 1034, 3, 168, 84, 0, 1034, 1035, 3, 106,
		53, 0, 1035, 165, 1, 0, 0, 0, 1036, 1039, 3, 168, 84, 0, 1037, 1039, 3,
		170, 85, 0, 1038, 1036, 1, 0, 0, 0, 1038, 1037, 1, 0, 0, 0, 1039, 167,
		1, 0, 0, 0, 1040, 1041, 7, 9, 0, 0, 1041, 169, 1, 0, 0, 0, 1042, 1046,
		3, 172, 86, 0, 1043, 1046, 5, 61, 0, 0, 1044, 1046, 5, 62, 0, 0, 1045,
		1042, 1, 0, 0, 0, 1045, 1043, 1, 0, 0, 0, 1045, 1044, 1, 0, 0, 0, 1046,
		171, 1, 0, 0, 0, 1047, 1094, 5, 72, 0, 0, 1048, 1094, 5, 73, 0, 0, 1049,
		1094, 5, 74, 0, 0, 1050, 1094, 5, 75, 0, 0, 1051, 1094, 5, 76, 0, 0, 1052,
		1094, 5, 77, 0, 0, 1053, 1094, 5, 78, 0, 0, 1054, 1094, 5, 79, 0, 0, 1055,
		1094, 5, 80, 0, 0, 1056, 1094, 5, 81, 0, 0, 1057, 1094, 5, 82, 0, 0, 1058,
		1094, 5, 83, 0, 0, 1059, 1094, 5, 84, 0, 0, 1060, 1094, 5, 85, 0, 0, 1061,
		1094, 5, 86, 0, 0, 1062, 1094, 5, 87, 0, 0, 1063, 1094, 5, 88, 0, 0, 1064,
		1094, 5, 89, 0, 0, 1065, 1094, 5, 90, 0, 0, 1066, 1094, 5, 91, 0, 0, 1067,
		1094, 5, 92, 0, 0, 1068, 1094, 5, 93, 0, 0, 1069, 1094, 5, 94, 0, 0, 1070,
		1094, 5, 95, 0, 0, 1071, 1094, 5, 96, 0, 0, 1072, 1094, 5, 97, 0, 0, 1073,
		1094, 5, 100, 0, 0, 1074, 1094, 5, 101, 0, 0, 1075, 1094, 5, 102, 0, 0,
		1076, 1094, 5, 103, 0, 0, 1077, 1094, 5, 104, 0, 0, 1078, 1094, 5, 105,
		0, 0, 1079, 1094, 5, 106, 0, 0, 1080, 1094, 5, 110, 0, 0, 1081, 1094, 3,
		174, 87, 0, 1082, 1094, 5, 113, 0, 0, 1083, 1094, 5, 114, 0, 0, 1084, 1094,
		5, 115, 0, 0, 1085, 1094, 5, 116, 0, 0, 1086, 1094, 5, 117, 0, 0, 1087,
		1094, 5, 118, 0, 0, 1088, 1094, 5, 109, 0, 0, 1089, 1094, 5, 107, 0, 0,
		1090, 1094, 5, 108, 0, 0, 1091, 1094, 5, 99, 0, 0, 1092, 1094, 5, 98, 0,
		0, 1093, 1047, 1, 0, 0, 0, 1093, 1048, 1, 0, 0, 0, 1093, 1049, 1, 0, 0,
		0, 1093, 1050, 1, 0, 0, 0, 1093, 1051, 1, 0, 0, 0, 1093, 1052, 1, 0, 0,
		0, 1093, 1053, 1, 0, 0, 0, 1093, 1054, 1, 0, 0, 0, 1093, 1055, 1, 0, 0,
		0, 1093, 1056, 1, 0, 0, 0, 1093, 1057, 1, 0, 0, 0, 1093, 1058, 1, 0, 0,
		0, 1093, 1059, 1, 0, 0, 0, 1093, 1060, 1, 0, 0, 0, 1093, 1061, 1, 0, 0,
		0, 1093, 1062, 1, 0, 0, 0, 1093, 1063, 1, 0, 0, 0, 1093, 1064, 1, 0, 0,
		0, 1093, 1065, 1, 0, 0, 0, 1093, 1066, 1, 0, 0, 0, 1093, 1067, 1, 0, 0,
		0, 1093, 1068, 1, 0, 0, 0, 1093, 1069, 1, 0, 0, 0, 1093, 1070, 1, 0, 0,
		0, 1093, 1071, 1, 0, 0, 0, 1093, 1072, 1, 0, 0, 0, 1093, 1073, 1, 0, 0,
		0, 1093, 1074, 1, 0, 0, 0, 1093, 1075, 1, 0, 0, 0, 1093, 1076, 1, 0, 0,
		0, 1093, 1077, 1, 0, 0, 0, 1093, 1078, 1, 0, 0, 0, 1093, 1079, 1, 0, 0,
		0, 1093, 1080, 1, 0, 0, 0, 1093, 1081, 1, 0, 0, 0, 1093, 1082, 1, 0, 0,
		0, 1093, 1083, 1, 0, 0, 0, 1093, 1084, 1, 0, 0, 0, 1093, 1085, 1, 0, 0,
		0, 1093, 1086, 1, 0, 0, 0, 1093, 1087, 1, 0, 0, 0, 1093, 1088, 1, 0, 0,
		0, 1093, 1089, 1, 0, 0, 0, 1093, 1090, 1, 0, 0, 0, 1093, 1091, 1, 0, 0,
		0, 1093, 1092, 1, 0, 0, 0, 1094, 173, 1, 0, 0, 0, 1095, 1096, 7, 10, 0,
		0, 1096, 175, 1, 0, 0, 0, 1097, 1102, 5, 12, 0, 0, 1098, 1102, 5, 0, 0,
		1, 1099, 1102, 4, 88, 39, 0, 1100, 1102, 4, 88, 40, 0, 1101, 1097, 1, 0,
		0, 0, 1101, 1098, 1, 0, 0, 0, 1101, 1099, 1, 0, 0, 0, 1101, 1100, 1, 0,
		0, 0, 1102, 177, 1, 0, 0, 0, 120, 179, 182, 208, 212, 219, 225, 229, 236,
		244, 249, 251, 258, 262, 271, 275, 283, 287, 291, 300, 308, 312, 320, 325,
		327, 334, 339, 350, 356, 371, 375, 398, 402, 406, 414, 423, 428, 436, 441,
		446, 453, 460, 467, 485, 489, 491, 498, 504, 509, 524, 527, 532, 535, 546,
		550, 555, 566, 572, 580, 586, 592, 596, 600, 603, 608, 614, 622, 627, 632,
		636, 640, 650, 655, 658, 663, 670, 677, 686, 690, 695, 700, 706, 710, 725,
		728, 733, 750, 753, 762, 770, 774, 776, 781, 785, 792, 799, 847, 909, 917,
		921, 934, 936, 945, 953, 957, 959, 964, 968, 972, 977, 983, 988, 991, 995,
		1006, 1012, 1022, 1038, 1045, 1093, 1101,
	}
	deserializer := antlr.NewATNDeserializer(nil)
	staticData.atn = deserializer.Deserialize(staticData.serializedATN)
	atn := staticData.atn
	staticData.decisionToDFA = make([]*antlr.DFA, len(atn.DecisionToState))
	decisionToDFA := staticData.decisionToDFA
	for index, state := range atn.DecisionToState {
		decisionToDFA[index] = antlr.NewDFA(state, index)
	}
}

// JavaScriptParserInit initializes any static state used to implement JavaScriptParser. By default the
// static state used to implement the parser is lazily initialized during the first call to
// NewJavaScriptParser(). You can call this function if you wish to initialize the static state ahead
// of time.
func JavaScriptParserInit() {
	staticData := &JavaScriptParserParserStaticData
	staticData.once.Do(javascriptparserParserInit)
}

// NewJavaScriptParser produces a new parser instance for the optional input antlr.TokenStream.
func NewJavaScriptParser(input antlr.TokenStream) *JavaScriptParser {
	JavaScriptParserInit()
	this := new(JavaScriptParser)
	this.BaseParser = antlr.NewBaseParser(input)
	staticData := &JavaScriptParserParserStaticData
	this.Interpreter = antlr.NewParserATNSimulator(this, staticData.atn, staticData.decisionToDFA, staticData.PredictionContextCache)
	this.RuleNames = staticData.RuleNames
	this.LiteralNames = staticData.LiteralNames
	this.SymbolicNames = staticData.SymbolicNames
	this.GrammarFileName = "JavaScriptParser.g4"

	return this
}

// JavaScriptParser tokens.
const (
	JavaScriptParserEOF                           = antlr.TokenEOF
	JavaScriptParserHashBangLine                  = 1
	JavaScriptParserMultiLineComment              = 2
	JavaScriptParserSingleLineComment             = 3
	JavaScriptParserRegularExpressionLiteral      = 4
	JavaScriptParserOpenBracket                   = 5
	JavaScriptParserCloseBracket                  = 6
	JavaScriptParserOpenParen                     = 7
	JavaScriptParserCloseParen                    = 8
	JavaScriptParserOpenBrace                     = 9
	JavaScriptParserTemplateCloseBrace            = 10
	JavaScriptParserCloseBrace                    = 11
	JavaScriptParserSemiColon                     = 12
	JavaScriptParserComma                         = 13
	JavaScriptParserAssign                        = 14
	JavaScriptParserQuestionMark                  = 15
	JavaScriptParserQuestionMarkDot               = 16
	JavaScriptParserColon                         = 17
	JavaScriptParserEllipsis                      = 18
	JavaScriptParserDot                           = 19
	JavaScriptParserPlusPlus                      = 20
	JavaScriptParserMinusMinus                    = 21
	JavaScriptParserPlus                          = 22
	JavaScriptParserMinus                         = 23
	JavaScriptParserBitNot                        = 24
	JavaScriptParserNot                           = 25
	JavaScriptParserMultiply                      = 26
	JavaScriptParserDivide                        = 27
	JavaScriptParserModulus                       = 28
	JavaScriptParserPower                         = 29
	JavaScriptParserNullCoalesce                  = 30
	JavaScriptParserHashtag                       = 31
	JavaScriptParserRightShiftArithmetic          = 32
	JavaScriptParserLeftShiftArithmetic           = 33
	JavaScriptParserRightShiftLogical             = 34
	JavaScriptParserLessThan                      = 35
	JavaScriptParserMoreThan                      = 36
	JavaScriptParserLessThanEquals                = 37
	JavaScriptParserGreaterThanEquals             = 38
	JavaScriptParserEquals_                       = 39
	JavaScriptParserNotEquals                     = 40
	JavaScriptParserIdentityEquals                = 41
	JavaScriptParserIdentityNotEquals             = 42
	JavaScriptParserBitAnd                        = 43
	JavaScriptParserBitXOr                        = 44
	JavaScriptParserBitOr                         = 45
	JavaScriptParserAnd                           = 46
	JavaScriptParserOr                            = 47
	JavaScriptParserMultiplyAssign                = 48
	JavaScriptParserDivideAssign                  = 49
	JavaScriptParserModulusAssign                 = 50
	JavaScriptParserPlusAssign                    = 51
	JavaScriptParserMinusAssign                   = 52
	JavaScriptParserLeftShiftArithmeticAssign     = 53
	JavaScriptParserRightShiftArithmeticAssign    = 54
	JavaScriptParserRightShiftLogicalAssign       = 55
	JavaScriptParserBitAndAssign                  = 56
	JavaScriptParserBitXorAssign                  = 57
	JavaScriptParserBitOrAssign                   = 58
	JavaScriptParserPowerAssign                   = 59
	JavaScriptParserARROW                         = 60
	JavaScriptParserNullLiteral                   = 61
	JavaScriptParserBooleanLiteral                = 62
	JavaScriptParserDecimalLiteral                = 63
	JavaScriptParserHexIntegerLiteral             = 64
	JavaScriptParserOctalIntegerLiteral           = 65
	JavaScriptParserOctalIntegerLiteral2          = 66
	JavaScriptParserBinaryIntegerLiteral          = 67
	JavaScriptParserBigHexIntegerLiteral          = 68
	JavaScriptParserBigOctalIntegerLiteral        = 69
	JavaScriptParserBigBinaryIntegerLiteral       = 70
	JavaScriptParserBigDecimalIntegerLiteral      = 71
	JavaScriptParserBreak                         = 72
	JavaScriptParserDo                            = 73
	JavaScriptParserInstanceof                    = 74
	JavaScriptParserTypeof                        = 75
	JavaScriptParserCase                          = 76
	JavaScriptParserElse                          = 77
	JavaScriptParserNew                           = 78
	JavaScriptParserVar                           = 79
	JavaScriptParserCatch                         = 80
	JavaScriptParserFinally                       = 81
	JavaScriptParserReturn                        = 82
	JavaScriptParserVoid                          = 83
	JavaScriptParserContinue                      = 84
	JavaScriptParserFor                           = 85
	JavaScriptParserSwitch                        = 86
	JavaScriptParserWhile                         = 87
	JavaScriptParserDebugger                      = 88
	JavaScriptParserFunction_                     = 89
	JavaScriptParserThis                          = 90
	JavaScriptParserWith                          = 91
	JavaScriptParserDefault                       = 92
	JavaScriptParserIf                            = 93
	JavaScriptParserThrow                         = 94
	JavaScriptParserDelete                        = 95
	JavaScriptParserIn                            = 96
	JavaScriptParserTry                           = 97
	JavaScriptParserAs                            = 98
	JavaScriptParserFrom                          = 99
	JavaScriptParserClass                         = 100
	JavaScriptParserEnum                          = 101
	JavaScriptParserExtends                       = 102
	JavaScriptParserSuper                         = 103
	JavaScriptParserConst                         = 104
	JavaScriptParserExport                        = 105
	JavaScriptParserImport                        = 106
	JavaScriptParserAsync                         = 107
	JavaScriptParserAwait                         = 108
	JavaScriptParserYield                         = 109
	JavaScriptParserImplements                    = 110
	JavaScriptParserStrictLet                     = 111
	JavaScriptParserNonStrictLet                  = 112
	JavaScriptParserPrivate                       = 113
	JavaScriptParserPublic                        = 114
	JavaScriptParserInterface                     = 115
	JavaScriptParserPackage                       = 116
	JavaScriptParserProtected                     = 117
	JavaScriptParserStatic                        = 118
	JavaScriptParserIdentifier                    = 119
	JavaScriptParserStringLiteral                 = 120
	JavaScriptParserBackTick                      = 121
	JavaScriptParserWhiteSpaces                   = 122
	JavaScriptParserLineTerminator                = 123
	JavaScriptParserHtmlComment                   = 124
	JavaScriptParserCDataComment                  = 125
	JavaScriptParserUnexpectedCharacter           = 126
	JavaScriptParserTemplateStringStartExpression = 127
	JavaScriptParserTemplateStringAtom            = 128
)

// JavaScriptParser rules.
const (
	JavaScriptParserRULE_program                 = 0
	JavaScriptParserRULE_sourceElement           = 1
	JavaScriptParserRULE_statement               = 2
	JavaScriptParserRULE_block                   = 3
	JavaScriptParserRULE_statementList           = 4
	JavaScriptParserRULE_importStatement         = 5
	JavaScriptParserRULE_importFromBlock         = 6
	JavaScriptParserRULE_importModuleItems       = 7
	JavaScriptParserRULE_importAliasName         = 8
	JavaScriptParserRULE_moduleExportName        = 9
	JavaScriptParserRULE_importedBinding         = 10
	JavaScriptParserRULE_importDefault           = 11
	JavaScriptParserRULE_importNamespace         = 12
	JavaScriptParserRULE_importFrom              = 13
	JavaScriptParserRULE_aliasName               = 14
	JavaScriptParserRULE_exportStatement         = 15
	JavaScriptParserRULE_exportFromBlock         = 16
	JavaScriptParserRULE_exportModuleItems       = 17
	JavaScriptParserRULE_exportAliasName         = 18
	JavaScriptParserRULE_declaration             = 19
	JavaScriptParserRULE_variableStatement       = 20
	JavaScriptParserRULE_variableDeclarationList = 21
	JavaScriptParserRULE_variableDeclaration     = 22
	JavaScriptParserRULE_emptyStatement_         = 23
	JavaScriptParserRULE_expressionStatement     = 24
	JavaScriptParserRULE_ifStatement             = 25
	JavaScriptParserRULE_forFirst                = 26
	JavaScriptParserRULE_forSecond               = 27
	JavaScriptParserRULE_forThird                = 28
	JavaScriptParserRULE_iterationStatement      = 29
	JavaScriptParserRULE_varModifier             = 30
	JavaScriptParserRULE_continueStatement       = 31
	JavaScriptParserRULE_breakStatement          = 32
	JavaScriptParserRULE_returnStatement         = 33
	JavaScriptParserRULE_yieldStatement          = 34
	JavaScriptParserRULE_withStatement           = 35
	JavaScriptParserRULE_switchStatement         = 36
	JavaScriptParserRULE_caseBlock               = 37
	JavaScriptParserRULE_caseClauses             = 38
	JavaScriptParserRULE_caseClause              = 39
	JavaScriptParserRULE_defaultClause           = 40
	JavaScriptParserRULE_labelledStatement       = 41
	JavaScriptParserRULE_throwStatement          = 42
	JavaScriptParserRULE_tryStatement            = 43
	JavaScriptParserRULE_catchProduction         = 44
	JavaScriptParserRULE_finallyProduction       = 45
	JavaScriptParserRULE_debuggerStatement       = 46
	JavaScriptParserRULE_functionDeclaration     = 47
	JavaScriptParserRULE_classDeclaration        = 48
	JavaScriptParserRULE_classTail               = 49
	JavaScriptParserRULE_classElement            = 50
	JavaScriptParserRULE_methodDefinition        = 51
	JavaScriptParserRULE_fieldDefinition         = 52
	JavaScriptParserRULE_classElementName        = 53
	JavaScriptParserRULE_privateIdentifier       = 54
	JavaScriptParserRULE_formalParameterList     = 55
	JavaScriptParserRULE_formalParameterArg      = 56
	JavaScriptParserRULE_lastFormalParameterArg  = 57
	JavaScriptParserRULE_functionBody            = 58
	JavaScriptParserRULE_sourceElements          = 59
	JavaScriptParserRULE_arrayLiteral            = 60
	JavaScriptParserRULE_elementList             = 61
	JavaScriptParserRULE_arrayElement            = 62
	JavaScriptParserRULE_propertyAssignment      = 63
	JavaScriptParserRULE_propertyName            = 64
	JavaScriptParserRULE_arguments               = 65
	JavaScriptParserRULE_argument                = 66
	JavaScriptParserRULE_expressionSequence      = 67
	JavaScriptParserRULE_singleExpression        = 68
	JavaScriptParserRULE_initializer             = 69
	JavaScriptParserRULE_assignable              = 70
	JavaScriptParserRULE_objectLiteral           = 71
	JavaScriptParserRULE_anonymousFunction       = 72
	JavaScriptParserRULE_arrowFunctionParameters = 73
	JavaScriptParserRULE_arrowFunctionBody       = 74
	JavaScriptParserRULE_assignmentOperator      = 75
	JavaScriptParserRULE_literal                 = 76
	JavaScriptParserRULE_templateStringLiteral   = 77
	JavaScriptParserRULE_templateStringAtom      = 78
	JavaScriptParserRULE_numericLiteral          = 79
	JavaScriptParserRULE_bigintLiteral           = 80
	JavaScriptParserRULE_getter                  = 81
	JavaScriptParserRULE_setter                  = 82
	JavaScriptParserRULE_identifierName          = 83
	JavaScriptParserRULE_identifier              = 84
	JavaScriptParserRULE_reservedWord            = 85
	JavaScriptParserRULE_keyword                 = 86
	JavaScriptParserRULE_let_                    = 87
	JavaScriptParserRULE_eos                     = 88
)

// IProgramContext is an interface to support dynamic dispatch.
type IProgramContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	EOF() antlr.TerminalNode
	HashBangLine() antlr.TerminalNode
	SourceElements() ISourceElementsContext

	// IsProgramContext differentiates from other interfaces.
	IsProgramContext()
}

type ProgramContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyProgramContext() *ProgramContext {
	var p = new(ProgramContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaScriptParserRULE_program
	return p
}

func InitEmptyProgramContext(p *ProgramContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaScriptParserRULE_program
}

func (*ProgramContext) IsProgramContext() {}

func NewProgramContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ProgramContext {
	var p = new(ProgramContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaScriptParserRULE_program

	return p
}

func (s *ProgramContext) GetParser() antlr.Parser { return s.parser }

func (s *ProgramContext) EOF() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserEOF, 0)
}

func (s *ProgramContext) HashBangLine() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserHashBangLine, 0)
}

func (s *ProgramContext) SourceElements() ISourceElementsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISourceElementsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISourceElementsContext)
}

func (s *ProgramContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ProgramContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ProgramContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JavaScriptParserVisitor:
		return t.VisitProgram(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *JavaScriptParser) Program() (localctx IProgramContext) {
	localctx = NewProgramContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 0, JavaScriptParserRULE_program)
	p.EnterOuterAlt(localctx, 1)
	p.SetState(179)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 0, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(178)
			p.Match(JavaScriptParserHashBangLine)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(182)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 1, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(181)
			p.SourceElements()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(184)
		p.Match(JavaScriptParserEOF)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISourceElementContext is an interface to support dynamic dispatch.
type ISourceElementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Statement() IStatementContext

	// IsSourceElementContext differentiates from other interfaces.
	IsSourceElementContext()
}

type SourceElementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySourceElementContext() *SourceElementContext {
	var p = new(SourceElementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaScriptParserRULE_sourceElement
	return p
}

func InitEmptySourceElementContext(p *SourceElementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaScriptParserRULE_sourceElement
}

func (*SourceElementContext) IsSourceElementContext() {}

func NewSourceElementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SourceElementContext {
	var p = new(SourceElementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaScriptParserRULE_sourceElement

	return p
}

func (s *SourceElementContext) GetParser() antlr.Parser { return s.parser }

func (s *SourceElementContext) Statement() IStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *SourceElementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SourceElementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SourceElementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JavaScriptParserVisitor:
		return t.VisitSourceElement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *JavaScriptParser) SourceElement() (localctx ISourceElementContext) {
	localctx = NewSourceElementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 2, JavaScriptParserRULE_sourceElement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(186)
		p.Statement()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IStatementContext is an interface to support dynamic dispatch.
type IStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Block() IBlockContext
	VariableStatement() IVariableStatementContext
	ImportStatement() IImportStatementContext
	ExportStatement() IExportStatementContext
	EmptyStatement_() IEmptyStatement_Context
	ClassDeclaration() IClassDeclarationContext
	FunctionDeclaration() IFunctionDeclarationContext
	ExpressionStatement() IExpressionStatementContext
	IfStatement() IIfStatementContext
	IterationStatement() IIterationStatementContext
	ContinueStatement() IContinueStatementContext
	BreakStatement() IBreakStatementContext
	ReturnStatement() IReturnStatementContext
	YieldStatement() IYieldStatementContext
	WithStatement() IWithStatementContext
	LabelledStatement() ILabelledStatementContext
	SwitchStatement() ISwitchStatementContext
	ThrowStatement() IThrowStatementContext
	TryStatement() ITryStatementContext
	DebuggerStatement() IDebuggerStatementContext

	// IsStatementContext differentiates from other interfaces.
	IsStatementContext()
}

type StatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStatementContext() *StatementContext {
	var p = new(StatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaScriptParserRULE_statement
	return p
}

func InitEmptyStatementContext(p *StatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaScriptParserRULE_statement
}

func (*StatementContext) IsStatementContext() {}

func NewStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StatementContext {
	var p = new(StatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaScriptParserRULE_statement

	return p
}

func (s *StatementContext) GetParser() antlr.Parser { return s.parser }

func (s *StatementContext) Block() IBlockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBlockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBlockContext)
}

func (s *StatementContext) VariableStatement() IVariableStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVariableStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVariableStatementContext)
}

func (s *StatementContext) ImportStatement() IImportStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IImportStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IImportStatementContext)
}

func (s *StatementContext) ExportStatement() IExportStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExportStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExportStatementContext)
}

func (s *StatementContext) EmptyStatement_() IEmptyStatement_Context {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEmptyStatement_Context); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEmptyStatement_Context)
}

func (s *StatementContext) ClassDeclaration() IClassDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClassDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClassDeclarationContext)
}

func (s *StatementContext) FunctionDeclaration() IFunctionDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionDeclarationContext)
}

func (s *StatementContext) ExpressionStatement() IExpressionStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionStatementContext)
}

func (s *StatementContext) IfStatement() IIfStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIfStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIfStatementContext)
}

func (s *StatementContext) IterationStatement() IIterationStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIterationStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIterationStatementContext)
}

func (s *StatementContext) ContinueStatement() IContinueStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IContinueStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IContinueStatementContext)
}

func (s *StatementContext) BreakStatement() IBreakStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBreakStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBreakStatementContext)
}

func (s *StatementContext) ReturnStatement() IReturnStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReturnStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReturnStatementContext)
}

func (s *StatementContext) YieldStatement() IYieldStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IYieldStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IYieldStatementContext)
}

func (s *StatementContext) WithStatement() IWithStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWithStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWithStatementContext)
}

func (s *StatementContext) LabelledStatement() ILabelledStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILabelledStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILabelledStatementContext)
}

func (s *StatementContext) SwitchStatement() ISwitchStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISwitchStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISwitchStatementContext)
}

func (s *StatementContext) ThrowStatement() IThrowStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IThrowStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IThrowStatementContext)
}

func (s *StatementContext) TryStatement() ITryStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITryStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITryStatementContext)
}

func (s *StatementContext) DebuggerStatement() IDebuggerStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDebuggerStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDebuggerStatementContext)
}

func (s *StatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JavaScriptParserVisitor:
		return t.VisitStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *JavaScriptParser) Statement() (localctx IStatementContext) {
	localctx = NewStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 4, JavaScriptParserRULE_statement)
	p.SetState(208)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 2, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(188)
			p.Block()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(189)
			p.VariableStatement()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(190)
			p.ImportStatement()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(191)
			p.ExportStatement()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(192)
			p.EmptyStatement_()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(193)
			p.ClassDeclaration()
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(194)
			p.FunctionDeclaration()
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(195)
			p.ExpressionStatement()
		}

	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(196)
			p.IfStatement()
		}

	case 10:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(197)
			p.IterationStatement()
		}

	case 11:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(198)
			p.ContinueStatement()
		}

	case 12:
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(199)
			p.BreakStatement()
		}

	case 13:
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(200)
			p.ReturnStatement()
		}

	case 14:
		p.EnterOuterAlt(localctx, 14)
		{
			p.SetState(201)
			p.YieldStatement()
		}

	case 15:
		p.EnterOuterAlt(localctx, 15)
		{
			p.SetState(202)
			p.WithStatement()
		}

	case 16:
		p.EnterOuterAlt(localctx, 16)
		{
			p.SetState(203)
			p.LabelledStatement()
		}

	case 17:
		p.EnterOuterAlt(localctx, 17)
		{
			p.SetState(204)
			p.SwitchStatement()
		}

	case 18:
		p.EnterOuterAlt(localctx, 18)
		{
			p.SetState(205)
			p.ThrowStatement()
		}

	case 19:
		p.EnterOuterAlt(localctx, 19)
		{
			p.SetState(206)
			p.TryStatement()
		}

	case 20:
		p.EnterOuterAlt(localctx, 20)
		{
			p.SetState(207)
			p.DebuggerStatement()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IBlockContext is an interface to support dynamic dispatch.
type IBlockContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	OpenBrace() antlr.TerminalNode
	CloseBrace() antlr.TerminalNode
	StatementList() IStatementListContext

	// IsBlockContext differentiates from other interfaces.
	IsBlockContext()
}

type BlockContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBlockContext() *BlockContext {
	var p = new(BlockContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaScriptParserRULE_block
	return p
}

func InitEmptyBlockContext(p *BlockContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaScriptParserRULE_block
}

func (*BlockContext) IsBlockContext() {}

func NewBlockContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BlockContext {
	var p = new(BlockContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaScriptParserRULE_block

	return p
}

func (s *BlockContext) GetParser() antlr.Parser { return s.parser }

func (s *BlockContext) OpenBrace() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserOpenBrace, 0)
}

func (s *BlockContext) CloseBrace() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserCloseBrace, 0)
}

func (s *BlockContext) StatementList() IStatementListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementListContext)
}

func (s *BlockContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BlockContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BlockContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JavaScriptParserVisitor:
		return t.VisitBlock(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *JavaScriptParser) Block() (localctx IBlockContext) {
	localctx = NewBlockContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 6, JavaScriptParserRULE_block)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(210)
		p.Match(JavaScriptParserOpenBrace)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(212)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 3, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(211)
			p.StatementList()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(214)
		p.Match(JavaScriptParserCloseBrace)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IStatementListContext is an interface to support dynamic dispatch.
type IStatementListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllStatement() []IStatementContext
	Statement(i int) IStatementContext

	// IsStatementListContext differentiates from other interfaces.
	IsStatementListContext()
}

type StatementListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStatementListContext() *StatementListContext {
	var p = new(StatementListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaScriptParserRULE_statementList
	return p
}

func InitEmptyStatementListContext(p *StatementListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaScriptParserRULE_statementList
}

func (*StatementListContext) IsStatementListContext() {}

func NewStatementListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StatementListContext {
	var p = new(StatementListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaScriptParserRULE_statementList

	return p
}

func (s *StatementListContext) GetParser() antlr.Parser { return s.parser }

func (s *StatementListContext) AllStatement() []IStatementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStatementContext); ok {
			len++
		}
	}

	tst := make([]IStatementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStatementContext); ok {
			tst[i] = t.(IStatementContext)
			i++
		}
	}

	return tst
}

func (s *StatementListContext) Statement(i int) IStatementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *StatementListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StatementListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StatementListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JavaScriptParserVisitor:
		return t.VisitStatementList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *JavaScriptParser) StatementList() (localctx IStatementListContext) {
	localctx = NewStatementListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 8, JavaScriptParserRULE_statementList)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(217)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			{
				p.SetState(216)
				p.Statement()
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

		p.SetState(219)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 4, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IImportStatementContext is an interface to support dynamic dispatch.
type IImportStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Import() antlr.TerminalNode
	ImportFromBlock() IImportFromBlockContext

	// IsImportStatementContext differentiates from other interfaces.
	IsImportStatementContext()
}

type ImportStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyImportStatementContext() *ImportStatementContext {
	var p = new(ImportStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaScriptParserRULE_importStatement
	return p
}

func InitEmptyImportStatementContext(p *ImportStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaScriptParserRULE_importStatement
}

func (*ImportStatementContext) IsImportStatementContext() {}

func NewImportStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ImportStatementContext {
	var p = new(ImportStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaScriptParserRULE_importStatement

	return p
}

func (s *ImportStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ImportStatementContext) Import() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserImport, 0)
}

func (s *ImportStatementContext) ImportFromBlock() IImportFromBlockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IImportFromBlockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IImportFromBlockContext)
}

func (s *ImportStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ImportStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ImportStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JavaScriptParserVisitor:
		return t.VisitImportStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *JavaScriptParser) ImportStatement() (localctx IImportStatementContext) {
	localctx = NewImportStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 10, JavaScriptParserRULE_importStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(221)
		p.Match(JavaScriptParserImport)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(222)
		p.ImportFromBlock()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IImportFromBlockContext is an interface to support dynamic dispatch.
type IImportFromBlockContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ImportFrom() IImportFromContext
	Eos() IEosContext
	ImportNamespace() IImportNamespaceContext
	ImportModuleItems() IImportModuleItemsContext
	ImportDefault() IImportDefaultContext
	StringLiteral() antlr.TerminalNode

	// IsImportFromBlockContext differentiates from other interfaces.
	IsImportFromBlockContext()
}

type ImportFromBlockContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyImportFromBlockContext() *ImportFromBlockContext {
	var p = new(ImportFromBlockContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaScriptParserRULE_importFromBlock
	return p
}

func InitEmptyImportFromBlockContext(p *ImportFromBlockContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaScriptParserRULE_importFromBlock
}

func (*ImportFromBlockContext) IsImportFromBlockContext() {}

func NewImportFromBlockContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ImportFromBlockContext {
	var p = new(ImportFromBlockContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaScriptParserRULE_importFromBlock

	return p
}

func (s *ImportFromBlockContext) GetParser() antlr.Parser { return s.parser }

func (s *ImportFromBlockContext) ImportFrom() IImportFromContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IImportFromContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IImportFromContext)
}

func (s *ImportFromBlockContext) Eos() IEosContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEosContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEosContext)
}

func (s *ImportFromBlockContext) ImportNamespace() IImportNamespaceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IImportNamespaceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IImportNamespaceContext)
}

func (s *ImportFromBlockContext) ImportModuleItems() IImportModuleItemsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IImportModuleItemsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IImportModuleItemsContext)
}

func (s *ImportFromBlockContext) ImportDefault() IImportDefaultContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IImportDefaultContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IImportDefaultContext)
}

func (s *ImportFromBlockContext) StringLiteral() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserStringLiteral, 0)
}

func (s *ImportFromBlockContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ImportFromBlockContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ImportFromBlockContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JavaScriptParserVisitor:
		return t.VisitImportFromBlock(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *JavaScriptParser) ImportFromBlock() (localctx IImportFromBlockContext) {
	localctx = NewImportFromBlockContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 12, JavaScriptParserRULE_importFromBlock)
	p.SetState(236)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case JavaScriptParserOpenBrace, JavaScriptParserMultiply, JavaScriptParserNullLiteral, JavaScriptParserBooleanLiteral, JavaScriptParserBreak, JavaScriptParserDo, JavaScriptParserInstanceof, JavaScriptParserTypeof, JavaScriptParserCase, JavaScriptParserElse, JavaScriptParserNew, JavaScriptParserVar, JavaScriptParserCatch, JavaScriptParserFinally, JavaScriptParserReturn, JavaScriptParserVoid, JavaScriptParserContinue, JavaScriptParserFor, JavaScriptParserSwitch, JavaScriptParserWhile, JavaScriptParserDebugger, JavaScriptParserFunction_, JavaScriptParserThis, JavaScriptParserWith, JavaScriptParserDefault, JavaScriptParserIf, JavaScriptParserThrow, JavaScriptParserDelete, JavaScriptParserIn, JavaScriptParserTry, JavaScriptParserAs, JavaScriptParserFrom, JavaScriptParserClass, JavaScriptParserEnum, JavaScriptParserExtends, JavaScriptParserSuper, JavaScriptParserConst, JavaScriptParserExport, JavaScriptParserImport, JavaScriptParserAsync, JavaScriptParserAwait, JavaScriptParserYield, JavaScriptParserImplements, JavaScriptParserStrictLet, JavaScriptParserNonStrictLet, JavaScriptParserPrivate, JavaScriptParserPublic, JavaScriptParserInterface, JavaScriptParserPackage, JavaScriptParserProtected, JavaScriptParserStatic, JavaScriptParserIdentifier:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(225)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 5, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(224)
				p.ImportDefault()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(229)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case JavaScriptParserMultiply, JavaScriptParserNullLiteral, JavaScriptParserBooleanLiteral, JavaScriptParserBreak, JavaScriptParserDo, JavaScriptParserInstanceof, JavaScriptParserTypeof, JavaScriptParserCase, JavaScriptParserElse, JavaScriptParserNew, JavaScriptParserVar, JavaScriptParserCatch, JavaScriptParserFinally, JavaScriptParserReturn, JavaScriptParserVoid, JavaScriptParserContinue, JavaScriptParserFor, JavaScriptParserSwitch, JavaScriptParserWhile, JavaScriptParserDebugger, JavaScriptParserFunction_, JavaScriptParserThis, JavaScriptParserWith, JavaScriptParserDefault, JavaScriptParserIf, JavaScriptParserThrow, JavaScriptParserDelete, JavaScriptParserIn, JavaScriptParserTry, JavaScriptParserAs, JavaScriptParserFrom, JavaScriptParserClass, JavaScriptParserEnum, JavaScriptParserExtends, JavaScriptParserSuper, JavaScriptParserConst, JavaScriptParserExport, JavaScriptParserImport, JavaScriptParserAsync, JavaScriptParserAwait, JavaScriptParserYield, JavaScriptParserImplements, JavaScriptParserStrictLet, JavaScriptParserNonStrictLet, JavaScriptParserPrivate, JavaScriptParserPublic, JavaScriptParserInterface, JavaScriptParserPackage, JavaScriptParserProtected, JavaScriptParserStatic, JavaScriptParserIdentifier:
			{
				p.SetState(227)
				p.ImportNamespace()
			}

		case JavaScriptParserOpenBrace:
			{
				p.SetState(228)
				p.ImportModuleItems()
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}
		{
			p.SetState(231)
			p.ImportFrom()
		}
		{
			p.SetState(232)
			p.Eos()
		}

	case JavaScriptParserStringLiteral:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(234)
			p.Match(JavaScriptParserStringLiteral)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(235)
			p.Eos()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IImportModuleItemsContext is an interface to support dynamic dispatch.
type IImportModuleItemsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	OpenBrace() antlr.TerminalNode
	CloseBrace() antlr.TerminalNode
	AllImportAliasName() []IImportAliasNameContext
	ImportAliasName(i int) IImportAliasNameContext
	AllComma() []antlr.TerminalNode
	Comma(i int) antlr.TerminalNode

	// IsImportModuleItemsContext differentiates from other interfaces.
	IsImportModuleItemsContext()
}

type ImportModuleItemsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyImportModuleItemsContext() *ImportModuleItemsContext {
	var p = new(ImportModuleItemsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaScriptParserRULE_importModuleItems
	return p
}

func InitEmptyImportModuleItemsContext(p *ImportModuleItemsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaScriptParserRULE_importModuleItems
}

func (*ImportModuleItemsContext) IsImportModuleItemsContext() {}

func NewImportModuleItemsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ImportModuleItemsContext {
	var p = new(ImportModuleItemsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaScriptParserRULE_importModuleItems

	return p
}

func (s *ImportModuleItemsContext) GetParser() antlr.Parser { return s.parser }

func (s *ImportModuleItemsContext) OpenBrace() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserOpenBrace, 0)
}

func (s *ImportModuleItemsContext) CloseBrace() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserCloseBrace, 0)
}

func (s *ImportModuleItemsContext) AllImportAliasName() []IImportAliasNameContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IImportAliasNameContext); ok {
			len++
		}
	}

	tst := make([]IImportAliasNameContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IImportAliasNameContext); ok {
			tst[i] = t.(IImportAliasNameContext)
			i++
		}
	}

	return tst
}

func (s *ImportModuleItemsContext) ImportAliasName(i int) IImportAliasNameContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IImportAliasNameContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IImportAliasNameContext)
}

func (s *ImportModuleItemsContext) AllComma() []antlr.TerminalNode {
	return s.GetTokens(JavaScriptParserComma)
}

func (s *ImportModuleItemsContext) Comma(i int) antlr.TerminalNode {
	return s.GetToken(JavaScriptParserComma, i)
}

func (s *ImportModuleItemsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ImportModuleItemsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ImportModuleItemsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JavaScriptParserVisitor:
		return t.VisitImportModuleItems(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *JavaScriptParser) ImportModuleItems() (localctx IImportModuleItemsContext) {
	localctx = NewImportModuleItemsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 14, JavaScriptParserRULE_importModuleItems)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(238)
		p.Match(JavaScriptParserOpenBrace)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(244)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 8, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(239)
				p.ImportAliasName()
			}
			{
				p.SetState(240)
				p.Match(JavaScriptParserComma)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(246)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 8, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	p.SetState(251)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if (int64((_la-61)) & ^0x3f) == 0 && ((int64(1)<<(_la-61))&1152921504606844931) != 0 {
		{
			p.SetState(247)
			p.ImportAliasName()
		}
		p.SetState(249)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == JavaScriptParserComma {
			{
				p.SetState(248)
				p.Match(JavaScriptParserComma)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	}
	{
		p.SetState(253)
		p.Match(JavaScriptParserCloseBrace)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IImportAliasNameContext is an interface to support dynamic dispatch.
type IImportAliasNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ModuleExportName() IModuleExportNameContext
	As() antlr.TerminalNode
	ImportedBinding() IImportedBindingContext

	// IsImportAliasNameContext differentiates from other interfaces.
	IsImportAliasNameContext()
}

type ImportAliasNameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyImportAliasNameContext() *ImportAliasNameContext {
	var p = new(ImportAliasNameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaScriptParserRULE_importAliasName
	return p
}

func InitEmptyImportAliasNameContext(p *ImportAliasNameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaScriptParserRULE_importAliasName
}

func (*ImportAliasNameContext) IsImportAliasNameContext() {}

func NewImportAliasNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ImportAliasNameContext {
	var p = new(ImportAliasNameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaScriptParserRULE_importAliasName

	return p
}

func (s *ImportAliasNameContext) GetParser() antlr.Parser { return s.parser }

func (s *ImportAliasNameContext) ModuleExportName() IModuleExportNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IModuleExportNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IModuleExportNameContext)
}

func (s *ImportAliasNameContext) As() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserAs, 0)
}

func (s *ImportAliasNameContext) ImportedBinding() IImportedBindingContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IImportedBindingContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IImportedBindingContext)
}

func (s *ImportAliasNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ImportAliasNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ImportAliasNameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JavaScriptParserVisitor:
		return t.VisitImportAliasName(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *JavaScriptParser) ImportAliasName() (localctx IImportAliasNameContext) {
	localctx = NewImportAliasNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 16, JavaScriptParserRULE_importAliasName)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(255)
		p.ModuleExportName()
	}
	p.SetState(258)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == JavaScriptParserAs {
		{
			p.SetState(256)
			p.Match(JavaScriptParserAs)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(257)
			p.ImportedBinding()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IModuleExportNameContext is an interface to support dynamic dispatch.
type IModuleExportNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	IdentifierName() IIdentifierNameContext
	StringLiteral() antlr.TerminalNode

	// IsModuleExportNameContext differentiates from other interfaces.
	IsModuleExportNameContext()
}

type ModuleExportNameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyModuleExportNameContext() *ModuleExportNameContext {
	var p = new(ModuleExportNameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaScriptParserRULE_moduleExportName
	return p
}

func InitEmptyModuleExportNameContext(p *ModuleExportNameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaScriptParserRULE_moduleExportName
}

func (*ModuleExportNameContext) IsModuleExportNameContext() {}

func NewModuleExportNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ModuleExportNameContext {
	var p = new(ModuleExportNameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaScriptParserRULE_moduleExportName

	return p
}

func (s *ModuleExportNameContext) GetParser() antlr.Parser { return s.parser }

func (s *ModuleExportNameContext) IdentifierName() IIdentifierNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierNameContext)
}

func (s *ModuleExportNameContext) StringLiteral() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserStringLiteral, 0)
}

func (s *ModuleExportNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ModuleExportNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ModuleExportNameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JavaScriptParserVisitor:
		return t.VisitModuleExportName(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *JavaScriptParser) ModuleExportName() (localctx IModuleExportNameContext) {
	localctx = NewModuleExportNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 18, JavaScriptParserRULE_moduleExportName)
	p.SetState(262)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case JavaScriptParserNullLiteral, JavaScriptParserBooleanLiteral, JavaScriptParserBreak, JavaScriptParserDo, JavaScriptParserInstanceof, JavaScriptParserTypeof, JavaScriptParserCase, JavaScriptParserElse, JavaScriptParserNew, JavaScriptParserVar, JavaScriptParserCatch, JavaScriptParserFinally, JavaScriptParserReturn, JavaScriptParserVoid, JavaScriptParserContinue, JavaScriptParserFor, JavaScriptParserSwitch, JavaScriptParserWhile, JavaScriptParserDebugger, JavaScriptParserFunction_, JavaScriptParserThis, JavaScriptParserWith, JavaScriptParserDefault, JavaScriptParserIf, JavaScriptParserThrow, JavaScriptParserDelete, JavaScriptParserIn, JavaScriptParserTry, JavaScriptParserAs, JavaScriptParserFrom, JavaScriptParserClass, JavaScriptParserEnum, JavaScriptParserExtends, JavaScriptParserSuper, JavaScriptParserConst, JavaScriptParserExport, JavaScriptParserImport, JavaScriptParserAsync, JavaScriptParserAwait, JavaScriptParserYield, JavaScriptParserImplements, JavaScriptParserStrictLet, JavaScriptParserNonStrictLet, JavaScriptParserPrivate, JavaScriptParserPublic, JavaScriptParserInterface, JavaScriptParserPackage, JavaScriptParserProtected, JavaScriptParserStatic, JavaScriptParserIdentifier:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(260)
			p.IdentifierName()
		}

	case JavaScriptParserStringLiteral:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(261)
			p.Match(JavaScriptParserStringLiteral)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IImportedBindingContext is an interface to support dynamic dispatch.
type IImportedBindingContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() antlr.TerminalNode
	Yield() antlr.TerminalNode
	Await() antlr.TerminalNode

	// IsImportedBindingContext differentiates from other interfaces.
	IsImportedBindingContext()
}

type ImportedBindingContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyImportedBindingContext() *ImportedBindingContext {
	var p = new(ImportedBindingContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaScriptParserRULE_importedBinding
	return p
}

func InitEmptyImportedBindingContext(p *ImportedBindingContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaScriptParserRULE_importedBinding
}

func (*ImportedBindingContext) IsImportedBindingContext() {}

func NewImportedBindingContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ImportedBindingContext {
	var p = new(ImportedBindingContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaScriptParserRULE_importedBinding

	return p
}

func (s *ImportedBindingContext) GetParser() antlr.Parser { return s.parser }

func (s *ImportedBindingContext) Identifier() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserIdentifier, 0)
}

func (s *ImportedBindingContext) Yield() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserYield, 0)
}

func (s *ImportedBindingContext) Await() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserAwait, 0)
}

func (s *ImportedBindingContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ImportedBindingContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ImportedBindingContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JavaScriptParserVisitor:
		return t.VisitImportedBinding(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *JavaScriptParser) ImportedBinding() (localctx IImportedBindingContext) {
	localctx = NewImportedBindingContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 20, JavaScriptParserRULE_importedBinding)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(264)
		_la = p.GetTokenStream().LA(1)

		if !((int64((_la-108)) & ^0x3f) == 0 && ((int64(1)<<(_la-108))&2051) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IImportDefaultContext is an interface to support dynamic dispatch.
type IImportDefaultContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AliasName() IAliasNameContext
	Comma() antlr.TerminalNode

	// IsImportDefaultContext differentiates from other interfaces.
	IsImportDefaultContext()
}

type ImportDefaultContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyImportDefaultContext() *ImportDefaultContext {
	var p = new(ImportDefaultContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaScriptParserRULE_importDefault
	return p
}

func InitEmptyImportDefaultContext(p *ImportDefaultContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaScriptParserRULE_importDefault
}

func (*ImportDefaultContext) IsImportDefaultContext() {}

func NewImportDefaultContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ImportDefaultContext {
	var p = new(ImportDefaultContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaScriptParserRULE_importDefault

	return p
}

func (s *ImportDefaultContext) GetParser() antlr.Parser { return s.parser }

func (s *ImportDefaultContext) AliasName() IAliasNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAliasNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAliasNameContext)
}

func (s *ImportDefaultContext) Comma() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserComma, 0)
}

func (s *ImportDefaultContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ImportDefaultContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ImportDefaultContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JavaScriptParserVisitor:
		return t.VisitImportDefault(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *JavaScriptParser) ImportDefault() (localctx IImportDefaultContext) {
	localctx = NewImportDefaultContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 22, JavaScriptParserRULE_importDefault)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(266)
		p.AliasName()
	}
	{
		p.SetState(267)
		p.Match(JavaScriptParserComma)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IImportNamespaceContext is an interface to support dynamic dispatch.
type IImportNamespaceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Multiply() antlr.TerminalNode
	AllIdentifierName() []IIdentifierNameContext
	IdentifierName(i int) IIdentifierNameContext
	As() antlr.TerminalNode

	// IsImportNamespaceContext differentiates from other interfaces.
	IsImportNamespaceContext()
}

type ImportNamespaceContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyImportNamespaceContext() *ImportNamespaceContext {
	var p = new(ImportNamespaceContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaScriptParserRULE_importNamespace
	return p
}

func InitEmptyImportNamespaceContext(p *ImportNamespaceContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaScriptParserRULE_importNamespace
}

func (*ImportNamespaceContext) IsImportNamespaceContext() {}

func NewImportNamespaceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ImportNamespaceContext {
	var p = new(ImportNamespaceContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaScriptParserRULE_importNamespace

	return p
}

func (s *ImportNamespaceContext) GetParser() antlr.Parser { return s.parser }

func (s *ImportNamespaceContext) Multiply() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserMultiply, 0)
}

func (s *ImportNamespaceContext) AllIdentifierName() []IIdentifierNameContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierNameContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierNameContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierNameContext); ok {
			tst[i] = t.(IIdentifierNameContext)
			i++
		}
	}

	return tst
}

func (s *ImportNamespaceContext) IdentifierName(i int) IIdentifierNameContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierNameContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierNameContext)
}

func (s *ImportNamespaceContext) As() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserAs, 0)
}

func (s *ImportNamespaceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ImportNamespaceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ImportNamespaceContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JavaScriptParserVisitor:
		return t.VisitImportNamespace(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *JavaScriptParser) ImportNamespace() (localctx IImportNamespaceContext) {
	localctx = NewImportNamespaceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 24, JavaScriptParserRULE_importNamespace)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(271)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case JavaScriptParserMultiply:
		{
			p.SetState(269)
			p.Match(JavaScriptParserMultiply)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case JavaScriptParserNullLiteral, JavaScriptParserBooleanLiteral, JavaScriptParserBreak, JavaScriptParserDo, JavaScriptParserInstanceof, JavaScriptParserTypeof, JavaScriptParserCase, JavaScriptParserElse, JavaScriptParserNew, JavaScriptParserVar, JavaScriptParserCatch, JavaScriptParserFinally, JavaScriptParserReturn, JavaScriptParserVoid, JavaScriptParserContinue, JavaScriptParserFor, JavaScriptParserSwitch, JavaScriptParserWhile, JavaScriptParserDebugger, JavaScriptParserFunction_, JavaScriptParserThis, JavaScriptParserWith, JavaScriptParserDefault, JavaScriptParserIf, JavaScriptParserThrow, JavaScriptParserDelete, JavaScriptParserIn, JavaScriptParserTry, JavaScriptParserAs, JavaScriptParserFrom, JavaScriptParserClass, JavaScriptParserEnum, JavaScriptParserExtends, JavaScriptParserSuper, JavaScriptParserConst, JavaScriptParserExport, JavaScriptParserImport, JavaScriptParserAsync, JavaScriptParserAwait, JavaScriptParserYield, JavaScriptParserImplements, JavaScriptParserStrictLet, JavaScriptParserNonStrictLet, JavaScriptParserPrivate, JavaScriptParserPublic, JavaScriptParserInterface, JavaScriptParserPackage, JavaScriptParserProtected, JavaScriptParserStatic, JavaScriptParserIdentifier:
		{
			p.SetState(270)
			p.IdentifierName()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}
	p.SetState(275)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == JavaScriptParserAs {
		{
			p.SetState(273)
			p.Match(JavaScriptParserAs)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(274)
			p.IdentifierName()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IImportFromContext is an interface to support dynamic dispatch.
type IImportFromContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	From() antlr.TerminalNode
	StringLiteral() antlr.TerminalNode

	// IsImportFromContext differentiates from other interfaces.
	IsImportFromContext()
}

type ImportFromContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyImportFromContext() *ImportFromContext {
	var p = new(ImportFromContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaScriptParserRULE_importFrom
	return p
}

func InitEmptyImportFromContext(p *ImportFromContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaScriptParserRULE_importFrom
}

func (*ImportFromContext) IsImportFromContext() {}

func NewImportFromContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ImportFromContext {
	var p = new(ImportFromContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaScriptParserRULE_importFrom

	return p
}

func (s *ImportFromContext) GetParser() antlr.Parser { return s.parser }

func (s *ImportFromContext) From() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserFrom, 0)
}

func (s *ImportFromContext) StringLiteral() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserStringLiteral, 0)
}

func (s *ImportFromContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ImportFromContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ImportFromContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JavaScriptParserVisitor:
		return t.VisitImportFrom(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *JavaScriptParser) ImportFrom() (localctx IImportFromContext) {
	localctx = NewImportFromContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 26, JavaScriptParserRULE_importFrom)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(277)
		p.Match(JavaScriptParserFrom)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(278)
		p.Match(JavaScriptParserStringLiteral)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAliasNameContext is an interface to support dynamic dispatch.
type IAliasNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllIdentifierName() []IIdentifierNameContext
	IdentifierName(i int) IIdentifierNameContext
	As() antlr.TerminalNode

	// IsAliasNameContext differentiates from other interfaces.
	IsAliasNameContext()
}

type AliasNameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAliasNameContext() *AliasNameContext {
	var p = new(AliasNameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaScriptParserRULE_aliasName
	return p
}

func InitEmptyAliasNameContext(p *AliasNameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaScriptParserRULE_aliasName
}

func (*AliasNameContext) IsAliasNameContext() {}

func NewAliasNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AliasNameContext {
	var p = new(AliasNameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaScriptParserRULE_aliasName

	return p
}

func (s *AliasNameContext) GetParser() antlr.Parser { return s.parser }

func (s *AliasNameContext) AllIdentifierName() []IIdentifierNameContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierNameContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierNameContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierNameContext); ok {
			tst[i] = t.(IIdentifierNameContext)
			i++
		}
	}

	return tst
}

func (s *AliasNameContext) IdentifierName(i int) IIdentifierNameContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierNameContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierNameContext)
}

func (s *AliasNameContext) As() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserAs, 0)
}

func (s *AliasNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AliasNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AliasNameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JavaScriptParserVisitor:
		return t.VisitAliasName(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *JavaScriptParser) AliasName() (localctx IAliasNameContext) {
	localctx = NewAliasNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 28, JavaScriptParserRULE_aliasName)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(280)
		p.IdentifierName()
	}
	p.SetState(283)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == JavaScriptParserAs {
		{
			p.SetState(281)
			p.Match(JavaScriptParserAs)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(282)
			p.IdentifierName()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExportStatementContext is an interface to support dynamic dispatch.
type IExportStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsExportStatementContext differentiates from other interfaces.
	IsExportStatementContext()
}

type ExportStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExportStatementContext() *ExportStatementContext {
	var p = new(ExportStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaScriptParserRULE_exportStatement
	return p
}

func InitEmptyExportStatementContext(p *ExportStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaScriptParserRULE_exportStatement
}

func (*ExportStatementContext) IsExportStatementContext() {}

func NewExportStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExportStatementContext {
	var p = new(ExportStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaScriptParserRULE_exportStatement

	return p
}

func (s *ExportStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ExportStatementContext) CopyAll(ctx *ExportStatementContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *ExportStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExportStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type ExportDefaultDeclarationContext struct {
	ExportStatementContext
}

func NewExportDefaultDeclarationContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ExportDefaultDeclarationContext {
	var p = new(ExportDefaultDeclarationContext)

	InitEmptyExportStatementContext(&p.ExportStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*ExportStatementContext))

	return p
}

func (s *ExportDefaultDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExportDefaultDeclarationContext) Export() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserExport, 0)
}

func (s *ExportDefaultDeclarationContext) Default() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserDefault, 0)
}

func (s *ExportDefaultDeclarationContext) SingleExpression() ISingleExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISingleExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISingleExpressionContext)
}

func (s *ExportDefaultDeclarationContext) Eos() IEosContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEosContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEosContext)
}

func (s *ExportDefaultDeclarationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JavaScriptParserVisitor:
		return t.VisitExportDefaultDeclaration(s)

	default:
		return t.VisitChildren(s)
	}
}

type ExportDeclarationContext struct {
	ExportStatementContext
}

func NewExportDeclarationContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ExportDeclarationContext {
	var p = new(ExportDeclarationContext)

	InitEmptyExportStatementContext(&p.ExportStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*ExportStatementContext))

	return p
}

func (s *ExportDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExportDeclarationContext) Export() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserExport, 0)
}

func (s *ExportDeclarationContext) Eos() IEosContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEosContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEosContext)
}

func (s *ExportDeclarationContext) ExportFromBlock() IExportFromBlockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExportFromBlockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExportFromBlockContext)
}

func (s *ExportDeclarationContext) Declaration() IDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDeclarationContext)
}

func (s *ExportDeclarationContext) Default() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserDefault, 0)
}

func (s *ExportDeclarationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JavaScriptParserVisitor:
		return t.VisitExportDeclaration(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *JavaScriptParser) ExportStatement() (localctx IExportStatementContext) {
	localctx = NewExportStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 30, JavaScriptParserRULE_exportStatement)
	p.SetState(300)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 18, p.GetParserRuleContext()) {
	case 1:
		localctx = NewExportDeclarationContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(285)
			p.Match(JavaScriptParserExport)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(287)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 16, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(286)
				p.Match(JavaScriptParserDefault)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(291)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 17, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(289)
				p.ExportFromBlock()
			}

		case 2:
			{
				p.SetState(290)
				p.Declaration()
			}

		case antlr.ATNInvalidAltNumber:
			goto errorExit
		}
		{
			p.SetState(293)
			p.Eos()
		}

	case 2:
		localctx = NewExportDefaultDeclarationContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(295)
			p.Match(JavaScriptParserExport)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(296)
			p.Match(JavaScriptParserDefault)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(297)
			p.singleExpression(0)
		}
		{
			p.SetState(298)
			p.Eos()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExportFromBlockContext is an interface to support dynamic dispatch.
type IExportFromBlockContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ImportNamespace() IImportNamespaceContext
	ImportFrom() IImportFromContext
	Eos() IEosContext
	ExportModuleItems() IExportModuleItemsContext

	// IsExportFromBlockContext differentiates from other interfaces.
	IsExportFromBlockContext()
}

type ExportFromBlockContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExportFromBlockContext() *ExportFromBlockContext {
	var p = new(ExportFromBlockContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaScriptParserRULE_exportFromBlock
	return p
}

func InitEmptyExportFromBlockContext(p *ExportFromBlockContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaScriptParserRULE_exportFromBlock
}

func (*ExportFromBlockContext) IsExportFromBlockContext() {}

func NewExportFromBlockContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExportFromBlockContext {
	var p = new(ExportFromBlockContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaScriptParserRULE_exportFromBlock

	return p
}

func (s *ExportFromBlockContext) GetParser() antlr.Parser { return s.parser }

func (s *ExportFromBlockContext) ImportNamespace() IImportNamespaceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IImportNamespaceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IImportNamespaceContext)
}

func (s *ExportFromBlockContext) ImportFrom() IImportFromContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IImportFromContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IImportFromContext)
}

func (s *ExportFromBlockContext) Eos() IEosContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEosContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEosContext)
}

func (s *ExportFromBlockContext) ExportModuleItems() IExportModuleItemsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExportModuleItemsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExportModuleItemsContext)
}

func (s *ExportFromBlockContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExportFromBlockContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExportFromBlockContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JavaScriptParserVisitor:
		return t.VisitExportFromBlock(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *JavaScriptParser) ExportFromBlock() (localctx IExportFromBlockContext) {
	localctx = NewExportFromBlockContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 32, JavaScriptParserRULE_exportFromBlock)
	p.SetState(312)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case JavaScriptParserMultiply, JavaScriptParserNullLiteral, JavaScriptParserBooleanLiteral, JavaScriptParserBreak, JavaScriptParserDo, JavaScriptParserInstanceof, JavaScriptParserTypeof, JavaScriptParserCase, JavaScriptParserElse, JavaScriptParserNew, JavaScriptParserVar, JavaScriptParserCatch, JavaScriptParserFinally, JavaScriptParserReturn, JavaScriptParserVoid, JavaScriptParserContinue, JavaScriptParserFor, JavaScriptParserSwitch, JavaScriptParserWhile, JavaScriptParserDebugger, JavaScriptParserFunction_, JavaScriptParserThis, JavaScriptParserWith, JavaScriptParserDefault, JavaScriptParserIf, JavaScriptParserThrow, JavaScriptParserDelete, JavaScriptParserIn, JavaScriptParserTry, JavaScriptParserAs, JavaScriptParserFrom, JavaScriptParserClass, JavaScriptParserEnum, JavaScriptParserExtends, JavaScriptParserSuper, JavaScriptParserConst, JavaScriptParserExport, JavaScriptParserImport, JavaScriptParserAsync, JavaScriptParserAwait, JavaScriptParserYield, JavaScriptParserImplements, JavaScriptParserStrictLet, JavaScriptParserNonStrictLet, JavaScriptParserPrivate, JavaScriptParserPublic, JavaScriptParserInterface, JavaScriptParserPackage, JavaScriptParserProtected, JavaScriptParserStatic, JavaScriptParserIdentifier:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(302)
			p.ImportNamespace()
		}
		{
			p.SetState(303)
			p.ImportFrom()
		}
		{
			p.SetState(304)
			p.Eos()
		}

	case JavaScriptParserOpenBrace:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(306)
			p.ExportModuleItems()
		}
		p.SetState(308)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 19, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(307)
				p.ImportFrom()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(310)
			p.Eos()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExportModuleItemsContext is an interface to support dynamic dispatch.
type IExportModuleItemsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	OpenBrace() antlr.TerminalNode
	CloseBrace() antlr.TerminalNode
	AllExportAliasName() []IExportAliasNameContext
	ExportAliasName(i int) IExportAliasNameContext
	AllComma() []antlr.TerminalNode
	Comma(i int) antlr.TerminalNode

	// IsExportModuleItemsContext differentiates from other interfaces.
	IsExportModuleItemsContext()
}

type ExportModuleItemsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExportModuleItemsContext() *ExportModuleItemsContext {
	var p = new(ExportModuleItemsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaScriptParserRULE_exportModuleItems
	return p
}

func InitEmptyExportModuleItemsContext(p *ExportModuleItemsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaScriptParserRULE_exportModuleItems
}

func (*ExportModuleItemsContext) IsExportModuleItemsContext() {}

func NewExportModuleItemsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExportModuleItemsContext {
	var p = new(ExportModuleItemsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaScriptParserRULE_exportModuleItems

	return p
}

func (s *ExportModuleItemsContext) GetParser() antlr.Parser { return s.parser }

func (s *ExportModuleItemsContext) OpenBrace() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserOpenBrace, 0)
}

func (s *ExportModuleItemsContext) CloseBrace() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserCloseBrace, 0)
}

func (s *ExportModuleItemsContext) AllExportAliasName() []IExportAliasNameContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExportAliasNameContext); ok {
			len++
		}
	}

	tst := make([]IExportAliasNameContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExportAliasNameContext); ok {
			tst[i] = t.(IExportAliasNameContext)
			i++
		}
	}

	return tst
}

func (s *ExportModuleItemsContext) ExportAliasName(i int) IExportAliasNameContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExportAliasNameContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExportAliasNameContext)
}

func (s *ExportModuleItemsContext) AllComma() []antlr.TerminalNode {
	return s.GetTokens(JavaScriptParserComma)
}

func (s *ExportModuleItemsContext) Comma(i int) antlr.TerminalNode {
	return s.GetToken(JavaScriptParserComma, i)
}

func (s *ExportModuleItemsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExportModuleItemsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExportModuleItemsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JavaScriptParserVisitor:
		return t.VisitExportModuleItems(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *JavaScriptParser) ExportModuleItems() (localctx IExportModuleItemsContext) {
	localctx = NewExportModuleItemsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 34, JavaScriptParserRULE_exportModuleItems)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(314)
		p.Match(JavaScriptParserOpenBrace)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(320)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 21, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(315)
				p.ExportAliasName()
			}
			{
				p.SetState(316)
				p.Match(JavaScriptParserComma)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(322)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 21, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	p.SetState(327)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if (int64((_la-61)) & ^0x3f) == 0 && ((int64(1)<<(_la-61))&1152921504606844931) != 0 {
		{
			p.SetState(323)
			p.ExportAliasName()
		}
		p.SetState(325)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == JavaScriptParserComma {
			{
				p.SetState(324)
				p.Match(JavaScriptParserComma)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	}
	{
		p.SetState(329)
		p.Match(JavaScriptParserCloseBrace)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExportAliasNameContext is an interface to support dynamic dispatch.
type IExportAliasNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllModuleExportName() []IModuleExportNameContext
	ModuleExportName(i int) IModuleExportNameContext
	As() antlr.TerminalNode

	// IsExportAliasNameContext differentiates from other interfaces.
	IsExportAliasNameContext()
}

type ExportAliasNameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExportAliasNameContext() *ExportAliasNameContext {
	var p = new(ExportAliasNameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaScriptParserRULE_exportAliasName
	return p
}

func InitEmptyExportAliasNameContext(p *ExportAliasNameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaScriptParserRULE_exportAliasName
}

func (*ExportAliasNameContext) IsExportAliasNameContext() {}

func NewExportAliasNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExportAliasNameContext {
	var p = new(ExportAliasNameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaScriptParserRULE_exportAliasName

	return p
}

func (s *ExportAliasNameContext) GetParser() antlr.Parser { return s.parser }

func (s *ExportAliasNameContext) AllModuleExportName() []IModuleExportNameContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IModuleExportNameContext); ok {
			len++
		}
	}

	tst := make([]IModuleExportNameContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IModuleExportNameContext); ok {
			tst[i] = t.(IModuleExportNameContext)
			i++
		}
	}

	return tst
}

func (s *ExportAliasNameContext) ModuleExportName(i int) IModuleExportNameContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IModuleExportNameContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IModuleExportNameContext)
}

func (s *ExportAliasNameContext) As() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserAs, 0)
}

func (s *ExportAliasNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExportAliasNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExportAliasNameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JavaScriptParserVisitor:
		return t.VisitExportAliasName(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *JavaScriptParser) ExportAliasName() (localctx IExportAliasNameContext) {
	localctx = NewExportAliasNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 36, JavaScriptParserRULE_exportAliasName)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(331)
		p.ModuleExportName()
	}
	p.SetState(334)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == JavaScriptParserAs {
		{
			p.SetState(332)
			p.Match(JavaScriptParserAs)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(333)
			p.ModuleExportName()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDeclarationContext is an interface to support dynamic dispatch.
type IDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	VariableStatement() IVariableStatementContext
	ClassDeclaration() IClassDeclarationContext
	FunctionDeclaration() IFunctionDeclarationContext

	// IsDeclarationContext differentiates from other interfaces.
	IsDeclarationContext()
}

type DeclarationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDeclarationContext() *DeclarationContext {
	var p = new(DeclarationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaScriptParserRULE_declaration
	return p
}

func InitEmptyDeclarationContext(p *DeclarationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaScriptParserRULE_declaration
}

func (*DeclarationContext) IsDeclarationContext() {}

func NewDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DeclarationContext {
	var p = new(DeclarationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaScriptParserRULE_declaration

	return p
}

func (s *DeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *DeclarationContext) VariableStatement() IVariableStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVariableStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVariableStatementContext)
}

func (s *DeclarationContext) ClassDeclaration() IClassDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClassDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClassDeclarationContext)
}

func (s *DeclarationContext) FunctionDeclaration() IFunctionDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionDeclarationContext)
}

func (s *DeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DeclarationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JavaScriptParserVisitor:
		return t.VisitDeclaration(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *JavaScriptParser) Declaration() (localctx IDeclarationContext) {
	localctx = NewDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 38, JavaScriptParserRULE_declaration)
	p.SetState(339)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case JavaScriptParserVar, JavaScriptParserConst, JavaScriptParserStrictLet, JavaScriptParserNonStrictLet:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(336)
			p.VariableStatement()
		}

	case JavaScriptParserClass:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(337)
			p.ClassDeclaration()
		}

	case JavaScriptParserFunction_, JavaScriptParserAsync:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(338)
			p.FunctionDeclaration()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IVariableStatementContext is an interface to support dynamic dispatch.
type IVariableStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	VariableDeclarationList() IVariableDeclarationListContext
	Eos() IEosContext

	// IsVariableStatementContext differentiates from other interfaces.
	IsVariableStatementContext()
}

type VariableStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVariableStatementContext() *VariableStatementContext {
	var p = new(VariableStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaScriptParserRULE_variableStatement
	return p
}

func InitEmptyVariableStatementContext(p *VariableStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaScriptParserRULE_variableStatement
}

func (*VariableStatementContext) IsVariableStatementContext() {}

func NewVariableStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *VariableStatementContext {
	var p = new(VariableStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaScriptParserRULE_variableStatement

	return p
}

func (s *VariableStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *VariableStatementContext) VariableDeclarationList() IVariableDeclarationListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVariableDeclarationListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVariableDeclarationListContext)
}

func (s *VariableStatementContext) Eos() IEosContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEosContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEosContext)
}

func (s *VariableStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VariableStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *VariableStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JavaScriptParserVisitor:
		return t.VisitVariableStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *JavaScriptParser) VariableStatement() (localctx IVariableStatementContext) {
	localctx = NewVariableStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 40, JavaScriptParserRULE_variableStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(341)
		p.VariableDeclarationList()
	}
	{
		p.SetState(342)
		p.Eos()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IVariableDeclarationListContext is an interface to support dynamic dispatch.
type IVariableDeclarationListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	VarModifier() IVarModifierContext
	AllVariableDeclaration() []IVariableDeclarationContext
	VariableDeclaration(i int) IVariableDeclarationContext
	AllComma() []antlr.TerminalNode
	Comma(i int) antlr.TerminalNode

	// IsVariableDeclarationListContext differentiates from other interfaces.
	IsVariableDeclarationListContext()
}

type VariableDeclarationListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVariableDeclarationListContext() *VariableDeclarationListContext {
	var p = new(VariableDeclarationListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaScriptParserRULE_variableDeclarationList
	return p
}

func InitEmptyVariableDeclarationListContext(p *VariableDeclarationListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaScriptParserRULE_variableDeclarationList
}

func (*VariableDeclarationListContext) IsVariableDeclarationListContext() {}

func NewVariableDeclarationListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *VariableDeclarationListContext {
	var p = new(VariableDeclarationListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaScriptParserRULE_variableDeclarationList

	return p
}

func (s *VariableDeclarationListContext) GetParser() antlr.Parser { return s.parser }

func (s *VariableDeclarationListContext) VarModifier() IVarModifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVarModifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVarModifierContext)
}

func (s *VariableDeclarationListContext) AllVariableDeclaration() []IVariableDeclarationContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IVariableDeclarationContext); ok {
			len++
		}
	}

	tst := make([]IVariableDeclarationContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IVariableDeclarationContext); ok {
			tst[i] = t.(IVariableDeclarationContext)
			i++
		}
	}

	return tst
}

func (s *VariableDeclarationListContext) VariableDeclaration(i int) IVariableDeclarationContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVariableDeclarationContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVariableDeclarationContext)
}

func (s *VariableDeclarationListContext) AllComma() []antlr.TerminalNode {
	return s.GetTokens(JavaScriptParserComma)
}

func (s *VariableDeclarationListContext) Comma(i int) antlr.TerminalNode {
	return s.GetToken(JavaScriptParserComma, i)
}

func (s *VariableDeclarationListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VariableDeclarationListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *VariableDeclarationListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JavaScriptParserVisitor:
		return t.VisitVariableDeclarationList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *JavaScriptParser) VariableDeclarationList() (localctx IVariableDeclarationListContext) {
	localctx = NewVariableDeclarationListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 42, JavaScriptParserRULE_variableDeclarationList)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(344)
		p.VarModifier()
	}
	{
		p.SetState(345)
		p.VariableDeclaration()
	}
	p.SetState(350)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 26, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(346)
				p.Match(JavaScriptParserComma)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(347)
				p.VariableDeclaration()
			}

		}
		p.SetState(352)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 26, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IVariableDeclarationContext is an interface to support dynamic dispatch.
type IVariableDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Assignable() IAssignableContext
	Assign() antlr.TerminalNode
	SingleExpression() ISingleExpressionContext

	// IsVariableDeclarationContext differentiates from other interfaces.
	IsVariableDeclarationContext()
}

type VariableDeclarationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVariableDeclarationContext() *VariableDeclarationContext {
	var p = new(VariableDeclarationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaScriptParserRULE_variableDeclaration
	return p
}

func InitEmptyVariableDeclarationContext(p *VariableDeclarationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaScriptParserRULE_variableDeclaration
}

func (*VariableDeclarationContext) IsVariableDeclarationContext() {}

func NewVariableDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *VariableDeclarationContext {
	var p = new(VariableDeclarationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaScriptParserRULE_variableDeclaration

	return p
}

func (s *VariableDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *VariableDeclarationContext) Assignable() IAssignableContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAssignableContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAssignableContext)
}

func (s *VariableDeclarationContext) Assign() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserAssign, 0)
}

func (s *VariableDeclarationContext) SingleExpression() ISingleExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISingleExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISingleExpressionContext)
}

func (s *VariableDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VariableDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *VariableDeclarationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JavaScriptParserVisitor:
		return t.VisitVariableDeclaration(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *JavaScriptParser) VariableDeclaration() (localctx IVariableDeclarationContext) {
	localctx = NewVariableDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 44, JavaScriptParserRULE_variableDeclaration)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(353)
		p.Assignable()
	}
	p.SetState(356)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 27, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(354)
			p.Match(JavaScriptParserAssign)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(355)
			p.singleExpression(0)
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IEmptyStatement_Context is an interface to support dynamic dispatch.
type IEmptyStatement_Context interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SemiColon() antlr.TerminalNode

	// IsEmptyStatement_Context differentiates from other interfaces.
	IsEmptyStatement_Context()
}

type EmptyStatement_Context struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEmptyStatement_Context() *EmptyStatement_Context {
	var p = new(EmptyStatement_Context)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaScriptParserRULE_emptyStatement_
	return p
}

func InitEmptyEmptyStatement_Context(p *EmptyStatement_Context) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaScriptParserRULE_emptyStatement_
}

func (*EmptyStatement_Context) IsEmptyStatement_Context() {}

func NewEmptyStatement_Context(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EmptyStatement_Context {
	var p = new(EmptyStatement_Context)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaScriptParserRULE_emptyStatement_

	return p
}

func (s *EmptyStatement_Context) GetParser() antlr.Parser { return s.parser }

func (s *EmptyStatement_Context) SemiColon() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserSemiColon, 0)
}

func (s *EmptyStatement_Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EmptyStatement_Context) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EmptyStatement_Context) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JavaScriptParserVisitor:
		return t.VisitEmptyStatement_(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *JavaScriptParser) EmptyStatement_() (localctx IEmptyStatement_Context) {
	localctx = NewEmptyStatement_Context(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 46, JavaScriptParserRULE_emptyStatement_)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(358)
		p.Match(JavaScriptParserSemiColon)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExpressionStatementContext is an interface to support dynamic dispatch.
type IExpressionStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ExpressionSequence() IExpressionSequenceContext
	Eos() IEosContext

	// IsExpressionStatementContext differentiates from other interfaces.
	IsExpressionStatementContext()
}

type ExpressionStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpressionStatementContext() *ExpressionStatementContext {
	var p = new(ExpressionStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaScriptParserRULE_expressionStatement
	return p
}

func InitEmptyExpressionStatementContext(p *ExpressionStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaScriptParserRULE_expressionStatement
}

func (*ExpressionStatementContext) IsExpressionStatementContext() {}

func NewExpressionStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExpressionStatementContext {
	var p = new(ExpressionStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaScriptParserRULE_expressionStatement

	return p
}

func (s *ExpressionStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ExpressionStatementContext) ExpressionSequence() IExpressionSequenceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionSequenceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionSequenceContext)
}

func (s *ExpressionStatementContext) Eos() IEosContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEosContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEosContext)
}

func (s *ExpressionStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExpressionStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExpressionStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JavaScriptParserVisitor:
		return t.VisitExpressionStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *JavaScriptParser) ExpressionStatement() (localctx IExpressionStatementContext) {
	localctx = NewExpressionStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 48, JavaScriptParserRULE_expressionStatement)
	p.EnterOuterAlt(localctx, 1)
	p.SetState(360)

	if !(p.notOpenBraceAndNotFunction()) {
		p.SetError(antlr.NewFailedPredicateException(p, "p.notOpenBraceAndNotFunction()", ""))
		goto errorExit
	}
	{
		p.SetState(361)
		p.ExpressionSequence()
	}
	{
		p.SetState(362)
		p.Eos()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIfStatementContext is an interface to support dynamic dispatch.
type IIfStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	If() antlr.TerminalNode
	OpenParen() antlr.TerminalNode
	SingleExpression() ISingleExpressionContext
	CloseParen() antlr.TerminalNode
	AllStatement() []IStatementContext
	Statement(i int) IStatementContext
	Else() antlr.TerminalNode

	// IsIfStatementContext differentiates from other interfaces.
	IsIfStatementContext()
}

type IfStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIfStatementContext() *IfStatementContext {
	var p = new(IfStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaScriptParserRULE_ifStatement
	return p
}

func InitEmptyIfStatementContext(p *IfStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaScriptParserRULE_ifStatement
}

func (*IfStatementContext) IsIfStatementContext() {}

func NewIfStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IfStatementContext {
	var p = new(IfStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaScriptParserRULE_ifStatement

	return p
}

func (s *IfStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *IfStatementContext) If() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserIf, 0)
}

func (s *IfStatementContext) OpenParen() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserOpenParen, 0)
}

func (s *IfStatementContext) SingleExpression() ISingleExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISingleExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISingleExpressionContext)
}

func (s *IfStatementContext) CloseParen() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserCloseParen, 0)
}

func (s *IfStatementContext) AllStatement() []IStatementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStatementContext); ok {
			len++
		}
	}

	tst := make([]IStatementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStatementContext); ok {
			tst[i] = t.(IStatementContext)
			i++
		}
	}

	return tst
}

func (s *IfStatementContext) Statement(i int) IStatementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *IfStatementContext) Else() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserElse, 0)
}

func (s *IfStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IfStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IfStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JavaScriptParserVisitor:
		return t.VisitIfStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *JavaScriptParser) IfStatement() (localctx IIfStatementContext) {
	localctx = NewIfStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 50, JavaScriptParserRULE_ifStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(364)
		p.Match(JavaScriptParserIf)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(365)
		p.Match(JavaScriptParserOpenParen)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(366)
		p.singleExpression(0)
	}
	{
		p.SetState(367)
		p.Match(JavaScriptParserCloseParen)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(368)
		p.Statement()
	}
	p.SetState(371)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 28, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(369)
			p.Match(JavaScriptParserElse)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(370)
			p.Statement()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IForFirstContext is an interface to support dynamic dispatch.
type IForFirstContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SingleExpression() ISingleExpressionContext
	VariableDeclarationList() IVariableDeclarationListContext

	// IsForFirstContext differentiates from other interfaces.
	IsForFirstContext()
}

type ForFirstContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyForFirstContext() *ForFirstContext {
	var p = new(ForFirstContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaScriptParserRULE_forFirst
	return p
}

func InitEmptyForFirstContext(p *ForFirstContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaScriptParserRULE_forFirst
}

func (*ForFirstContext) IsForFirstContext() {}

func NewForFirstContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ForFirstContext {
	var p = new(ForFirstContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaScriptParserRULE_forFirst

	return p
}

func (s *ForFirstContext) GetParser() antlr.Parser { return s.parser }

func (s *ForFirstContext) SingleExpression() ISingleExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISingleExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISingleExpressionContext)
}

func (s *ForFirstContext) VariableDeclarationList() IVariableDeclarationListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVariableDeclarationListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVariableDeclarationListContext)
}

func (s *ForFirstContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ForFirstContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ForFirstContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JavaScriptParserVisitor:
		return t.VisitForFirst(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *JavaScriptParser) ForFirst() (localctx IForFirstContext) {
	localctx = NewForFirstContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 52, JavaScriptParserRULE_forFirst)
	p.SetState(375)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 29, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(373)
			p.singleExpression(0)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(374)
			p.VariableDeclarationList()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IForSecondContext is an interface to support dynamic dispatch.
type IForSecondContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SingleExpression() ISingleExpressionContext

	// IsForSecondContext differentiates from other interfaces.
	IsForSecondContext()
}

type ForSecondContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyForSecondContext() *ForSecondContext {
	var p = new(ForSecondContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaScriptParserRULE_forSecond
	return p
}

func InitEmptyForSecondContext(p *ForSecondContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaScriptParserRULE_forSecond
}

func (*ForSecondContext) IsForSecondContext() {}

func NewForSecondContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ForSecondContext {
	var p = new(ForSecondContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaScriptParserRULE_forSecond

	return p
}

func (s *ForSecondContext) GetParser() antlr.Parser { return s.parser }

func (s *ForSecondContext) SingleExpression() ISingleExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISingleExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISingleExpressionContext)
}

func (s *ForSecondContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ForSecondContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ForSecondContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JavaScriptParserVisitor:
		return t.VisitForSecond(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *JavaScriptParser) ForSecond() (localctx IForSecondContext) {
	localctx = NewForSecondContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 54, JavaScriptParserRULE_forSecond)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(377)
		p.singleExpression(0)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IForThirdContext is an interface to support dynamic dispatch.
type IForThirdContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SingleExpression() ISingleExpressionContext

	// IsForThirdContext differentiates from other interfaces.
	IsForThirdContext()
}

type ForThirdContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyForThirdContext() *ForThirdContext {
	var p = new(ForThirdContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaScriptParserRULE_forThird
	return p
}

func InitEmptyForThirdContext(p *ForThirdContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaScriptParserRULE_forThird
}

func (*ForThirdContext) IsForThirdContext() {}

func NewForThirdContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ForThirdContext {
	var p = new(ForThirdContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaScriptParserRULE_forThird

	return p
}

func (s *ForThirdContext) GetParser() antlr.Parser { return s.parser }

func (s *ForThirdContext) SingleExpression() ISingleExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISingleExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISingleExpressionContext)
}

func (s *ForThirdContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ForThirdContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ForThirdContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JavaScriptParserVisitor:
		return t.VisitForThird(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *JavaScriptParser) ForThird() (localctx IForThirdContext) {
	localctx = NewForThirdContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 56, JavaScriptParserRULE_forThird)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(379)
		p.singleExpression(0)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIterationStatementContext is an interface to support dynamic dispatch.
type IIterationStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsIterationStatementContext differentiates from other interfaces.
	IsIterationStatementContext()
}

type IterationStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIterationStatementContext() *IterationStatementContext {
	var p = new(IterationStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaScriptParserRULE_iterationStatement
	return p
}

func InitEmptyIterationStatementContext(p *IterationStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaScriptParserRULE_iterationStatement
}

func (*IterationStatementContext) IsIterationStatementContext() {}

func NewIterationStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IterationStatementContext {
	var p = new(IterationStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaScriptParserRULE_iterationStatement

	return p
}

func (s *IterationStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *IterationStatementContext) CopyAll(ctx *IterationStatementContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *IterationStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IterationStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type DoStatementContext struct {
	IterationStatementContext
}

func NewDoStatementContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DoStatementContext {
	var p = new(DoStatementContext)

	InitEmptyIterationStatementContext(&p.IterationStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*IterationStatementContext))

	return p
}

func (s *DoStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DoStatementContext) Do() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserDo, 0)
}

func (s *DoStatementContext) Statement() IStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *DoStatementContext) While() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserWhile, 0)
}

func (s *DoStatementContext) OpenParen() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserOpenParen, 0)
}

func (s *DoStatementContext) SingleExpression() ISingleExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISingleExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISingleExpressionContext)
}

func (s *DoStatementContext) CloseParen() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserCloseParen, 0)
}

func (s *DoStatementContext) Eos() IEosContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEosContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEosContext)
}

func (s *DoStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JavaScriptParserVisitor:
		return t.VisitDoStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

type WhileStatementContext struct {
	IterationStatementContext
}

func NewWhileStatementContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *WhileStatementContext {
	var p = new(WhileStatementContext)

	InitEmptyIterationStatementContext(&p.IterationStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*IterationStatementContext))

	return p
}

func (s *WhileStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WhileStatementContext) While() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserWhile, 0)
}

func (s *WhileStatementContext) OpenParen() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserOpenParen, 0)
}

func (s *WhileStatementContext) SingleExpression() ISingleExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISingleExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISingleExpressionContext)
}

func (s *WhileStatementContext) CloseParen() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserCloseParen, 0)
}

func (s *WhileStatementContext) Statement() IStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *WhileStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JavaScriptParserVisitor:
		return t.VisitWhileStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

type ForStatementContext struct {
	IterationStatementContext
}

func NewForStatementContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ForStatementContext {
	var p = new(ForStatementContext)

	InitEmptyIterationStatementContext(&p.IterationStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*IterationStatementContext))

	return p
}

func (s *ForStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ForStatementContext) For() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserFor, 0)
}

func (s *ForStatementContext) OpenParen() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserOpenParen, 0)
}

func (s *ForStatementContext) AllSemiColon() []antlr.TerminalNode {
	return s.GetTokens(JavaScriptParserSemiColon)
}

func (s *ForStatementContext) SemiColon(i int) antlr.TerminalNode {
	return s.GetToken(JavaScriptParserSemiColon, i)
}

func (s *ForStatementContext) CloseParen() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserCloseParen, 0)
}

func (s *ForStatementContext) Statement() IStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *ForStatementContext) ForFirst() IForFirstContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IForFirstContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IForFirstContext)
}

func (s *ForStatementContext) ForSecond() IForSecondContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IForSecondContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IForSecondContext)
}

func (s *ForStatementContext) ForThird() IForThirdContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IForThirdContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IForThirdContext)
}

func (s *ForStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JavaScriptParserVisitor:
		return t.VisitForStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

type ForInStatementContext struct {
	IterationStatementContext
}

func NewForInStatementContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ForInStatementContext {
	var p = new(ForInStatementContext)

	InitEmptyIterationStatementContext(&p.IterationStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*IterationStatementContext))

	return p
}

func (s *ForInStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ForInStatementContext) For() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserFor, 0)
}

func (s *ForInStatementContext) OpenParen() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserOpenParen, 0)
}

func (s *ForInStatementContext) In() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserIn, 0)
}

func (s *ForInStatementContext) AllSingleExpression() []ISingleExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISingleExpressionContext); ok {
			len++
		}
	}

	tst := make([]ISingleExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISingleExpressionContext); ok {
			tst[i] = t.(ISingleExpressionContext)
			i++
		}
	}

	return tst
}

func (s *ForInStatementContext) SingleExpression(i int) ISingleExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISingleExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISingleExpressionContext)
}

func (s *ForInStatementContext) CloseParen() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserCloseParen, 0)
}

func (s *ForInStatementContext) Statement() IStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *ForInStatementContext) VariableDeclaration() IVariableDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVariableDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVariableDeclarationContext)
}

func (s *ForInStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JavaScriptParserVisitor:
		return t.VisitForInStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

type ForOfStatementContext struct {
	IterationStatementContext
}

func NewForOfStatementContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ForOfStatementContext {
	var p = new(ForOfStatementContext)

	InitEmptyIterationStatementContext(&p.IterationStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*IterationStatementContext))

	return p
}

func (s *ForOfStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ForOfStatementContext) For() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserFor, 0)
}

func (s *ForOfStatementContext) OpenParen() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserOpenParen, 0)
}

func (s *ForOfStatementContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ForOfStatementContext) AllSingleExpression() []ISingleExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISingleExpressionContext); ok {
			len++
		}
	}

	tst := make([]ISingleExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISingleExpressionContext); ok {
			tst[i] = t.(ISingleExpressionContext)
			i++
		}
	}

	return tst
}

func (s *ForOfStatementContext) SingleExpression(i int) ISingleExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISingleExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISingleExpressionContext)
}

func (s *ForOfStatementContext) CloseParen() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserCloseParen, 0)
}

func (s *ForOfStatementContext) Statement() IStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *ForOfStatementContext) VariableDeclaration() IVariableDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVariableDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVariableDeclarationContext)
}

func (s *ForOfStatementContext) Await() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserAwait, 0)
}

func (s *ForOfStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JavaScriptParserVisitor:
		return t.VisitForOfStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *JavaScriptParser) IterationStatement() (localctx IIterationStatementContext) {
	localctx = NewIterationStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 58, JavaScriptParserRULE_iterationStatement)
	var _la int

	p.SetState(436)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 36, p.GetParserRuleContext()) {
	case 1:
		localctx = NewDoStatementContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(381)
			p.Match(JavaScriptParserDo)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(382)
			p.Statement()
		}
		{
			p.SetState(383)
			p.Match(JavaScriptParserWhile)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(384)
			p.Match(JavaScriptParserOpenParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(385)
			p.singleExpression(0)
		}
		{
			p.SetState(386)
			p.Match(JavaScriptParserCloseParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(387)
			p.Eos()
		}

	case 2:
		localctx = NewWhileStatementContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(389)
			p.Match(JavaScriptParserWhile)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(390)
			p.Match(JavaScriptParserOpenParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(391)
			p.singleExpression(0)
		}
		{
			p.SetState(392)
			p.Match(JavaScriptParserCloseParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(393)
			p.Statement()
		}

	case 3:
		localctx = NewForStatementContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(395)
			p.Match(JavaScriptParserFor)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(396)
			p.Match(JavaScriptParserOpenParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(398)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-2305843009147632976) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&252691534070728959) != 0) {
			{
				p.SetState(397)
				p.ForFirst()
			}

		}
		{
			p.SetState(400)
			p.Match(JavaScriptParserSemiColon)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(402)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-2305843009147632976) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&252549697070713087) != 0) {
			{
				p.SetState(401)
				p.ForSecond()
			}

		}
		{
			p.SetState(404)
			p.Match(JavaScriptParserSemiColon)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(406)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-2305843009147632976) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&252549697070713087) != 0) {
			{
				p.SetState(405)
				p.ForThird()
			}

		}
		{
			p.SetState(408)
			p.Match(JavaScriptParserCloseParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(409)
			p.Statement()
		}

	case 4:
		localctx = NewForInStatementContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(410)
			p.Match(JavaScriptParserFor)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(411)
			p.Match(JavaScriptParserOpenParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(414)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 33, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(412)
				p.singleExpression(0)
			}

		case 2:
			{
				p.SetState(413)
				p.VariableDeclaration()
			}

		case antlr.ATNInvalidAltNumber:
			goto errorExit
		}
		{
			p.SetState(416)
			p.Match(JavaScriptParserIn)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(417)
			p.singleExpression(0)
		}
		{
			p.SetState(418)
			p.Match(JavaScriptParserCloseParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(419)
			p.Statement()
		}

	case 5:
		localctx = NewForOfStatementContext(p, localctx)
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(421)
			p.Match(JavaScriptParserFor)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(423)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == JavaScriptParserAwait {
			{
				p.SetState(422)
				p.Match(JavaScriptParserAwait)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(425)
			p.Match(JavaScriptParserOpenParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(428)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 35, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(426)
				p.singleExpression(0)
			}

		case 2:
			{
				p.SetState(427)
				p.VariableDeclaration()
			}

		case antlr.ATNInvalidAltNumber:
			goto errorExit
		}
		{
			p.SetState(430)
			p.Identifier()
		}
		p.SetState(431)

		if !(p.p("of")) {
			p.SetError(antlr.NewFailedPredicateException(p, "p.p(\"of\")", ""))
			goto errorExit
		}
		{
			p.SetState(432)
			p.singleExpression(0)
		}
		{
			p.SetState(433)
			p.Match(JavaScriptParserCloseParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(434)
			p.Statement()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IVarModifierContext is an interface to support dynamic dispatch.
type IVarModifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Var() antlr.TerminalNode
	Let_() ILet_Context
	Const() antlr.TerminalNode

	// IsVarModifierContext differentiates from other interfaces.
	IsVarModifierContext()
}

type VarModifierContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVarModifierContext() *VarModifierContext {
	var p = new(VarModifierContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaScriptParserRULE_varModifier
	return p
}

func InitEmptyVarModifierContext(p *VarModifierContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaScriptParserRULE_varModifier
}

func (*VarModifierContext) IsVarModifierContext() {}

func NewVarModifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *VarModifierContext {
	var p = new(VarModifierContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaScriptParserRULE_varModifier

	return p
}

func (s *VarModifierContext) GetParser() antlr.Parser { return s.parser }

func (s *VarModifierContext) Var() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserVar, 0)
}

func (s *VarModifierContext) Let_() ILet_Context {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILet_Context); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILet_Context)
}

func (s *VarModifierContext) Const() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserConst, 0)
}

func (s *VarModifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VarModifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *VarModifierContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JavaScriptParserVisitor:
		return t.VisitVarModifier(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *JavaScriptParser) VarModifier() (localctx IVarModifierContext) {
	localctx = NewVarModifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 60, JavaScriptParserRULE_varModifier)
	p.SetState(441)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case JavaScriptParserVar:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(438)
			p.Match(JavaScriptParserVar)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case JavaScriptParserStrictLet, JavaScriptParserNonStrictLet:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(439)
			p.Let_()
		}

	case JavaScriptParserConst:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(440)
			p.Match(JavaScriptParserConst)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IContinueStatementContext is an interface to support dynamic dispatch.
type IContinueStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Continue() antlr.TerminalNode
	Eos() IEosContext
	Identifier() IIdentifierContext

	// IsContinueStatementContext differentiates from other interfaces.
	IsContinueStatementContext()
}

type ContinueStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyContinueStatementContext() *ContinueStatementContext {
	var p = new(ContinueStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaScriptParserRULE_continueStatement
	return p
}

func InitEmptyContinueStatementContext(p *ContinueStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaScriptParserRULE_continueStatement
}

func (*ContinueStatementContext) IsContinueStatementContext() {}

func NewContinueStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ContinueStatementContext {
	var p = new(ContinueStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaScriptParserRULE_continueStatement

	return p
}

func (s *ContinueStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ContinueStatementContext) Continue() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserContinue, 0)
}

func (s *ContinueStatementContext) Eos() IEosContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEosContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEosContext)
}

func (s *ContinueStatementContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ContinueStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ContinueStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ContinueStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JavaScriptParserVisitor:
		return t.VisitContinueStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *JavaScriptParser) ContinueStatement() (localctx IContinueStatementContext) {
	localctx = NewContinueStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 62, JavaScriptParserRULE_continueStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(443)
		p.Match(JavaScriptParserContinue)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(446)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 38, p.GetParserRuleContext()) == 1 {
		p.SetState(444)

		if !(p.notLineTerminator()) {
			p.SetError(antlr.NewFailedPredicateException(p, "p.notLineTerminator()", ""))
			goto errorExit
		}
		{
			p.SetState(445)
			p.Identifier()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(448)
		p.Eos()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IBreakStatementContext is an interface to support dynamic dispatch.
type IBreakStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Break() antlr.TerminalNode
	Eos() IEosContext
	Identifier() IIdentifierContext

	// IsBreakStatementContext differentiates from other interfaces.
	IsBreakStatementContext()
}

type BreakStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBreakStatementContext() *BreakStatementContext {
	var p = new(BreakStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaScriptParserRULE_breakStatement
	return p
}

func InitEmptyBreakStatementContext(p *BreakStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaScriptParserRULE_breakStatement
}

func (*BreakStatementContext) IsBreakStatementContext() {}

func NewBreakStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BreakStatementContext {
	var p = new(BreakStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaScriptParserRULE_breakStatement

	return p
}

func (s *BreakStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *BreakStatementContext) Break() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserBreak, 0)
}

func (s *BreakStatementContext) Eos() IEosContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEosContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEosContext)
}

func (s *BreakStatementContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *BreakStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BreakStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BreakStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JavaScriptParserVisitor:
		return t.VisitBreakStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *JavaScriptParser) BreakStatement() (localctx IBreakStatementContext) {
	localctx = NewBreakStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 64, JavaScriptParserRULE_breakStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(450)
		p.Match(JavaScriptParserBreak)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(453)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 39, p.GetParserRuleContext()) == 1 {
		p.SetState(451)

		if !(p.notLineTerminator()) {
			p.SetError(antlr.NewFailedPredicateException(p, "p.notLineTerminator()", ""))
			goto errorExit
		}
		{
			p.SetState(452)
			p.Identifier()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(455)
		p.Eos()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IReturnStatementContext is an interface to support dynamic dispatch.
type IReturnStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Return() antlr.TerminalNode
	Eos() IEosContext
	ExpressionSequence() IExpressionSequenceContext

	// IsReturnStatementContext differentiates from other interfaces.
	IsReturnStatementContext()
}

type ReturnStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReturnStatementContext() *ReturnStatementContext {
	var p = new(ReturnStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaScriptParserRULE_returnStatement
	return p
}

func InitEmptyReturnStatementContext(p *ReturnStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaScriptParserRULE_returnStatement
}

func (*ReturnStatementContext) IsReturnStatementContext() {}

func NewReturnStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReturnStatementContext {
	var p = new(ReturnStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaScriptParserRULE_returnStatement

	return p
}

func (s *ReturnStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ReturnStatementContext) Return() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserReturn, 0)
}

func (s *ReturnStatementContext) Eos() IEosContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEosContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEosContext)
}

func (s *ReturnStatementContext) ExpressionSequence() IExpressionSequenceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionSequenceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionSequenceContext)
}

func (s *ReturnStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReturnStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReturnStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JavaScriptParserVisitor:
		return t.VisitReturnStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *JavaScriptParser) ReturnStatement() (localctx IReturnStatementContext) {
	localctx = NewReturnStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 66, JavaScriptParserRULE_returnStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(457)
		p.Match(JavaScriptParserReturn)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(460)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 40, p.GetParserRuleContext()) == 1 {
		p.SetState(458)

		if !(p.notLineTerminator()) {
			p.SetError(antlr.NewFailedPredicateException(p, "p.notLineTerminator()", ""))
			goto errorExit
		}
		{
			p.SetState(459)
			p.ExpressionSequence()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(462)
		p.Eos()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IYieldStatementContext is an interface to support dynamic dispatch.
type IYieldStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Yield() antlr.TerminalNode
	Eos() IEosContext
	ExpressionSequence() IExpressionSequenceContext

	// IsYieldStatementContext differentiates from other interfaces.
	IsYieldStatementContext()
}

type YieldStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyYieldStatementContext() *YieldStatementContext {
	var p = new(YieldStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaScriptParserRULE_yieldStatement
	return p
}

func InitEmptyYieldStatementContext(p *YieldStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaScriptParserRULE_yieldStatement
}

func (*YieldStatementContext) IsYieldStatementContext() {}

func NewYieldStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *YieldStatementContext {
	var p = new(YieldStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaScriptParserRULE_yieldStatement

	return p
}

func (s *YieldStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *YieldStatementContext) Yield() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserYield, 0)
}

func (s *YieldStatementContext) Eos() IEosContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEosContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEosContext)
}

func (s *YieldStatementContext) ExpressionSequence() IExpressionSequenceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionSequenceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionSequenceContext)
}

func (s *YieldStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *YieldStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *YieldStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JavaScriptParserVisitor:
		return t.VisitYieldStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *JavaScriptParser) YieldStatement() (localctx IYieldStatementContext) {
	localctx = NewYieldStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 68, JavaScriptParserRULE_yieldStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(464)
		p.Match(JavaScriptParserYield)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(467)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 41, p.GetParserRuleContext()) == 1 {
		p.SetState(465)

		if !(p.notLineTerminator()) {
			p.SetError(antlr.NewFailedPredicateException(p, "p.notLineTerminator()", ""))
			goto errorExit
		}
		{
			p.SetState(466)
			p.ExpressionSequence()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(469)
		p.Eos()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IWithStatementContext is an interface to support dynamic dispatch.
type IWithStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	With() antlr.TerminalNode
	OpenParen() antlr.TerminalNode
	ExpressionSequence() IExpressionSequenceContext
	CloseParen() antlr.TerminalNode
	Statement() IStatementContext

	// IsWithStatementContext differentiates from other interfaces.
	IsWithStatementContext()
}

type WithStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWithStatementContext() *WithStatementContext {
	var p = new(WithStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaScriptParserRULE_withStatement
	return p
}

func InitEmptyWithStatementContext(p *WithStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaScriptParserRULE_withStatement
}

func (*WithStatementContext) IsWithStatementContext() {}

func NewWithStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WithStatementContext {
	var p = new(WithStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaScriptParserRULE_withStatement

	return p
}

func (s *WithStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *WithStatementContext) With() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserWith, 0)
}

func (s *WithStatementContext) OpenParen() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserOpenParen, 0)
}

func (s *WithStatementContext) ExpressionSequence() IExpressionSequenceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionSequenceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionSequenceContext)
}

func (s *WithStatementContext) CloseParen() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserCloseParen, 0)
}

func (s *WithStatementContext) Statement() IStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *WithStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WithStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WithStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JavaScriptParserVisitor:
		return t.VisitWithStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *JavaScriptParser) WithStatement() (localctx IWithStatementContext) {
	localctx = NewWithStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 70, JavaScriptParserRULE_withStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(471)
		p.Match(JavaScriptParserWith)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(472)
		p.Match(JavaScriptParserOpenParen)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(473)
		p.ExpressionSequence()
	}
	{
		p.SetState(474)
		p.Match(JavaScriptParserCloseParen)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(475)
		p.Statement()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISwitchStatementContext is an interface to support dynamic dispatch.
type ISwitchStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Switch() antlr.TerminalNode
	OpenParen() antlr.TerminalNode
	SingleExpression() ISingleExpressionContext
	CloseParen() antlr.TerminalNode
	CaseBlock() ICaseBlockContext

	// IsSwitchStatementContext differentiates from other interfaces.
	IsSwitchStatementContext()
}

type SwitchStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySwitchStatementContext() *SwitchStatementContext {
	var p = new(SwitchStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaScriptParserRULE_switchStatement
	return p
}

func InitEmptySwitchStatementContext(p *SwitchStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaScriptParserRULE_switchStatement
}

func (*SwitchStatementContext) IsSwitchStatementContext() {}

func NewSwitchStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SwitchStatementContext {
	var p = new(SwitchStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaScriptParserRULE_switchStatement

	return p
}

func (s *SwitchStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *SwitchStatementContext) Switch() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserSwitch, 0)
}

func (s *SwitchStatementContext) OpenParen() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserOpenParen, 0)
}

func (s *SwitchStatementContext) SingleExpression() ISingleExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISingleExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISingleExpressionContext)
}

func (s *SwitchStatementContext) CloseParen() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserCloseParen, 0)
}

func (s *SwitchStatementContext) CaseBlock() ICaseBlockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICaseBlockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICaseBlockContext)
}

func (s *SwitchStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SwitchStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SwitchStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JavaScriptParserVisitor:
		return t.VisitSwitchStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *JavaScriptParser) SwitchStatement() (localctx ISwitchStatementContext) {
	localctx = NewSwitchStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 72, JavaScriptParserRULE_switchStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(477)
		p.Match(JavaScriptParserSwitch)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(478)
		p.Match(JavaScriptParserOpenParen)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(479)
		p.singleExpression(0)
	}
	{
		p.SetState(480)
		p.Match(JavaScriptParserCloseParen)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(481)
		p.CaseBlock()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICaseBlockContext is an interface to support dynamic dispatch.
type ICaseBlockContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	OpenBrace() antlr.TerminalNode
	CloseBrace() antlr.TerminalNode
	AllCaseClauses() []ICaseClausesContext
	CaseClauses(i int) ICaseClausesContext
	DefaultClause() IDefaultClauseContext

	// IsCaseBlockContext differentiates from other interfaces.
	IsCaseBlockContext()
}

type CaseBlockContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCaseBlockContext() *CaseBlockContext {
	var p = new(CaseBlockContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaScriptParserRULE_caseBlock
	return p
}

func InitEmptyCaseBlockContext(p *CaseBlockContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaScriptParserRULE_caseBlock
}

func (*CaseBlockContext) IsCaseBlockContext() {}

func NewCaseBlockContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CaseBlockContext {
	var p = new(CaseBlockContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaScriptParserRULE_caseBlock

	return p
}

func (s *CaseBlockContext) GetParser() antlr.Parser { return s.parser }

func (s *CaseBlockContext) OpenBrace() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserOpenBrace, 0)
}

func (s *CaseBlockContext) CloseBrace() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserCloseBrace, 0)
}

func (s *CaseBlockContext) AllCaseClauses() []ICaseClausesContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ICaseClausesContext); ok {
			len++
		}
	}

	tst := make([]ICaseClausesContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ICaseClausesContext); ok {
			tst[i] = t.(ICaseClausesContext)
			i++
		}
	}

	return tst
}

func (s *CaseBlockContext) CaseClauses(i int) ICaseClausesContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICaseClausesContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICaseClausesContext)
}

func (s *CaseBlockContext) DefaultClause() IDefaultClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDefaultClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDefaultClauseContext)
}

func (s *CaseBlockContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CaseBlockContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CaseBlockContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JavaScriptParserVisitor:
		return t.VisitCaseBlock(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *JavaScriptParser) CaseBlock() (localctx ICaseBlockContext) {
	localctx = NewCaseBlockContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 74, JavaScriptParserRULE_caseBlock)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(483)
		p.Match(JavaScriptParserOpenBrace)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(485)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == JavaScriptParserCase {
		{
			p.SetState(484)
			p.CaseClauses()
		}

	}
	p.SetState(491)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == JavaScriptParserDefault {
		{
			p.SetState(487)
			p.DefaultClause()
		}
		p.SetState(489)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == JavaScriptParserCase {
			{
				p.SetState(488)
				p.CaseClauses()
			}

		}

	}
	{
		p.SetState(493)
		p.Match(JavaScriptParserCloseBrace)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICaseClausesContext is an interface to support dynamic dispatch.
type ICaseClausesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllCaseClause() []ICaseClauseContext
	CaseClause(i int) ICaseClauseContext

	// IsCaseClausesContext differentiates from other interfaces.
	IsCaseClausesContext()
}

type CaseClausesContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCaseClausesContext() *CaseClausesContext {
	var p = new(CaseClausesContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaScriptParserRULE_caseClauses
	return p
}

func InitEmptyCaseClausesContext(p *CaseClausesContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaScriptParserRULE_caseClauses
}

func (*CaseClausesContext) IsCaseClausesContext() {}

func NewCaseClausesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CaseClausesContext {
	var p = new(CaseClausesContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaScriptParserRULE_caseClauses

	return p
}

func (s *CaseClausesContext) GetParser() antlr.Parser { return s.parser }

func (s *CaseClausesContext) AllCaseClause() []ICaseClauseContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ICaseClauseContext); ok {
			len++
		}
	}

	tst := make([]ICaseClauseContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ICaseClauseContext); ok {
			tst[i] = t.(ICaseClauseContext)
			i++
		}
	}

	return tst
}

func (s *CaseClausesContext) CaseClause(i int) ICaseClauseContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICaseClauseContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICaseClauseContext)
}

func (s *CaseClausesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CaseClausesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CaseClausesContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JavaScriptParserVisitor:
		return t.VisitCaseClauses(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *JavaScriptParser) CaseClauses() (localctx ICaseClausesContext) {
	localctx = NewCaseClausesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 76, JavaScriptParserRULE_caseClauses)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(496)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = _la == JavaScriptParserCase {
		{
			p.SetState(495)
			p.CaseClause()
		}

		p.SetState(498)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICaseClauseContext is an interface to support dynamic dispatch.
type ICaseClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Case() antlr.TerminalNode
	SingleExpression() ISingleExpressionContext
	Colon() antlr.TerminalNode
	StatementList() IStatementListContext

	// IsCaseClauseContext differentiates from other interfaces.
	IsCaseClauseContext()
}

type CaseClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCaseClauseContext() *CaseClauseContext {
	var p = new(CaseClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaScriptParserRULE_caseClause
	return p
}

func InitEmptyCaseClauseContext(p *CaseClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaScriptParserRULE_caseClause
}

func (*CaseClauseContext) IsCaseClauseContext() {}

func NewCaseClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CaseClauseContext {
	var p = new(CaseClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaScriptParserRULE_caseClause

	return p
}

func (s *CaseClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *CaseClauseContext) Case() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserCase, 0)
}

func (s *CaseClauseContext) SingleExpression() ISingleExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISingleExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISingleExpressionContext)
}

func (s *CaseClauseContext) Colon() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserColon, 0)
}

func (s *CaseClauseContext) StatementList() IStatementListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementListContext)
}

func (s *CaseClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CaseClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CaseClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JavaScriptParserVisitor:
		return t.VisitCaseClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *JavaScriptParser) CaseClause() (localctx ICaseClauseContext) {
	localctx = NewCaseClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 78, JavaScriptParserRULE_caseClause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(500)
		p.Match(JavaScriptParserCase)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(501)
		p.singleExpression(0)
	}
	{
		p.SetState(502)
		p.Match(JavaScriptParserColon)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(504)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 46, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(503)
			p.StatementList()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDefaultClauseContext is an interface to support dynamic dispatch.
type IDefaultClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Default() antlr.TerminalNode
	Colon() antlr.TerminalNode
	StatementList() IStatementListContext

	// IsDefaultClauseContext differentiates from other interfaces.
	IsDefaultClauseContext()
}

type DefaultClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDefaultClauseContext() *DefaultClauseContext {
	var p = new(DefaultClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaScriptParserRULE_defaultClause
	return p
}

func InitEmptyDefaultClauseContext(p *DefaultClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaScriptParserRULE_defaultClause
}

func (*DefaultClauseContext) IsDefaultClauseContext() {}

func NewDefaultClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DefaultClauseContext {
	var p = new(DefaultClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaScriptParserRULE_defaultClause

	return p
}

func (s *DefaultClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *DefaultClauseContext) Default() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserDefault, 0)
}

func (s *DefaultClauseContext) Colon() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserColon, 0)
}

func (s *DefaultClauseContext) StatementList() IStatementListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementListContext)
}

func (s *DefaultClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DefaultClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DefaultClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JavaScriptParserVisitor:
		return t.VisitDefaultClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *JavaScriptParser) DefaultClause() (localctx IDefaultClauseContext) {
	localctx = NewDefaultClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 80, JavaScriptParserRULE_defaultClause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(506)
		p.Match(JavaScriptParserDefault)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(507)
		p.Match(JavaScriptParserColon)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(509)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 47, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(508)
			p.StatementList()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILabelledStatementContext is an interface to support dynamic dispatch.
type ILabelledStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext
	Colon() antlr.TerminalNode
	Statement() IStatementContext

	// IsLabelledStatementContext differentiates from other interfaces.
	IsLabelledStatementContext()
}

type LabelledStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLabelledStatementContext() *LabelledStatementContext {
	var p = new(LabelledStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaScriptParserRULE_labelledStatement
	return p
}

func InitEmptyLabelledStatementContext(p *LabelledStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaScriptParserRULE_labelledStatement
}

func (*LabelledStatementContext) IsLabelledStatementContext() {}

func NewLabelledStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LabelledStatementContext {
	var p = new(LabelledStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaScriptParserRULE_labelledStatement

	return p
}

func (s *LabelledStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *LabelledStatementContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *LabelledStatementContext) Colon() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserColon, 0)
}

func (s *LabelledStatementContext) Statement() IStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *LabelledStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LabelledStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LabelledStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JavaScriptParserVisitor:
		return t.VisitLabelledStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *JavaScriptParser) LabelledStatement() (localctx ILabelledStatementContext) {
	localctx = NewLabelledStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 82, JavaScriptParserRULE_labelledStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(511)
		p.Identifier()
	}
	{
		p.SetState(512)
		p.Match(JavaScriptParserColon)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(513)
		p.Statement()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IThrowStatementContext is an interface to support dynamic dispatch.
type IThrowStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Throw() antlr.TerminalNode
	ExpressionSequence() IExpressionSequenceContext
	Eos() IEosContext

	// IsThrowStatementContext differentiates from other interfaces.
	IsThrowStatementContext()
}

type ThrowStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyThrowStatementContext() *ThrowStatementContext {
	var p = new(ThrowStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaScriptParserRULE_throwStatement
	return p
}

func InitEmptyThrowStatementContext(p *ThrowStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaScriptParserRULE_throwStatement
}

func (*ThrowStatementContext) IsThrowStatementContext() {}

func NewThrowStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ThrowStatementContext {
	var p = new(ThrowStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaScriptParserRULE_throwStatement

	return p
}

func (s *ThrowStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ThrowStatementContext) Throw() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserThrow, 0)
}

func (s *ThrowStatementContext) ExpressionSequence() IExpressionSequenceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionSequenceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionSequenceContext)
}

func (s *ThrowStatementContext) Eos() IEosContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEosContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEosContext)
}

func (s *ThrowStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ThrowStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ThrowStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JavaScriptParserVisitor:
		return t.VisitThrowStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *JavaScriptParser) ThrowStatement() (localctx IThrowStatementContext) {
	localctx = NewThrowStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 84, JavaScriptParserRULE_throwStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(515)
		p.Match(JavaScriptParserThrow)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(516)

	if !(p.notLineTerminator()) {
		p.SetError(antlr.NewFailedPredicateException(p, "p.notLineTerminator()", ""))
		goto errorExit
	}
	{
		p.SetState(517)
		p.ExpressionSequence()
	}
	{
		p.SetState(518)
		p.Eos()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITryStatementContext is an interface to support dynamic dispatch.
type ITryStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Try() antlr.TerminalNode
	Block() IBlockContext
	CatchProduction() ICatchProductionContext
	FinallyProduction() IFinallyProductionContext

	// IsTryStatementContext differentiates from other interfaces.
	IsTryStatementContext()
}

type TryStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTryStatementContext() *TryStatementContext {
	var p = new(TryStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaScriptParserRULE_tryStatement
	return p
}

func InitEmptyTryStatementContext(p *TryStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaScriptParserRULE_tryStatement
}

func (*TryStatementContext) IsTryStatementContext() {}

func NewTryStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TryStatementContext {
	var p = new(TryStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaScriptParserRULE_tryStatement

	return p
}

func (s *TryStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *TryStatementContext) Try() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserTry, 0)
}

func (s *TryStatementContext) Block() IBlockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBlockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBlockContext)
}

func (s *TryStatementContext) CatchProduction() ICatchProductionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICatchProductionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICatchProductionContext)
}

func (s *TryStatementContext) FinallyProduction() IFinallyProductionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFinallyProductionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFinallyProductionContext)
}

func (s *TryStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TryStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TryStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JavaScriptParserVisitor:
		return t.VisitTryStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *JavaScriptParser) TryStatement() (localctx ITryStatementContext) {
	localctx = NewTryStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 86, JavaScriptParserRULE_tryStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(520)
		p.Match(JavaScriptParserTry)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(521)
		p.Block()
	}
	p.SetState(527)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case JavaScriptParserCatch:
		{
			p.SetState(522)
			p.CatchProduction()
		}
		p.SetState(524)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 48, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(523)
				p.FinallyProduction()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case JavaScriptParserFinally:
		{
			p.SetState(526)
			p.FinallyProduction()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICatchProductionContext is an interface to support dynamic dispatch.
type ICatchProductionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Catch() antlr.TerminalNode
	Block() IBlockContext
	OpenParen() antlr.TerminalNode
	CloseParen() antlr.TerminalNode
	Assignable() IAssignableContext

	// IsCatchProductionContext differentiates from other interfaces.
	IsCatchProductionContext()
}

type CatchProductionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCatchProductionContext() *CatchProductionContext {
	var p = new(CatchProductionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaScriptParserRULE_catchProduction
	return p
}

func InitEmptyCatchProductionContext(p *CatchProductionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaScriptParserRULE_catchProduction
}

func (*CatchProductionContext) IsCatchProductionContext() {}

func NewCatchProductionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CatchProductionContext {
	var p = new(CatchProductionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaScriptParserRULE_catchProduction

	return p
}

func (s *CatchProductionContext) GetParser() antlr.Parser { return s.parser }

func (s *CatchProductionContext) Catch() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserCatch, 0)
}

func (s *CatchProductionContext) Block() IBlockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBlockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBlockContext)
}

func (s *CatchProductionContext) OpenParen() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserOpenParen, 0)
}

func (s *CatchProductionContext) CloseParen() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserCloseParen, 0)
}

func (s *CatchProductionContext) Assignable() IAssignableContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAssignableContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAssignableContext)
}

func (s *CatchProductionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CatchProductionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CatchProductionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JavaScriptParserVisitor:
		return t.VisitCatchProduction(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *JavaScriptParser) CatchProduction() (localctx ICatchProductionContext) {
	localctx = NewCatchProductionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 88, JavaScriptParserRULE_catchProduction)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(529)
		p.Match(JavaScriptParserCatch)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(535)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == JavaScriptParserOpenParen {
		{
			p.SetState(530)
			p.Match(JavaScriptParserOpenParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(532)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == JavaScriptParserOpenBracket || _la == JavaScriptParserOpenBrace || ((int64((_la-98)) & ^0x3f) == 0 && ((int64(1)<<(_la-98))&2114051) != 0) {
			{
				p.SetState(531)
				p.Assignable()
			}

		}
		{
			p.SetState(534)
			p.Match(JavaScriptParserCloseParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(537)
		p.Block()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFinallyProductionContext is an interface to support dynamic dispatch.
type IFinallyProductionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Finally() antlr.TerminalNode
	Block() IBlockContext

	// IsFinallyProductionContext differentiates from other interfaces.
	IsFinallyProductionContext()
}

type FinallyProductionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFinallyProductionContext() *FinallyProductionContext {
	var p = new(FinallyProductionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaScriptParserRULE_finallyProduction
	return p
}

func InitEmptyFinallyProductionContext(p *FinallyProductionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaScriptParserRULE_finallyProduction
}

func (*FinallyProductionContext) IsFinallyProductionContext() {}

func NewFinallyProductionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FinallyProductionContext {
	var p = new(FinallyProductionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaScriptParserRULE_finallyProduction

	return p
}

func (s *FinallyProductionContext) GetParser() antlr.Parser { return s.parser }

func (s *FinallyProductionContext) Finally() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserFinally, 0)
}

func (s *FinallyProductionContext) Block() IBlockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBlockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBlockContext)
}

func (s *FinallyProductionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FinallyProductionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FinallyProductionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JavaScriptParserVisitor:
		return t.VisitFinallyProduction(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *JavaScriptParser) FinallyProduction() (localctx IFinallyProductionContext) {
	localctx = NewFinallyProductionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 90, JavaScriptParserRULE_finallyProduction)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(539)
		p.Match(JavaScriptParserFinally)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(540)
		p.Block()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDebuggerStatementContext is an interface to support dynamic dispatch.
type IDebuggerStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Debugger() antlr.TerminalNode
	Eos() IEosContext

	// IsDebuggerStatementContext differentiates from other interfaces.
	IsDebuggerStatementContext()
}

type DebuggerStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDebuggerStatementContext() *DebuggerStatementContext {
	var p = new(DebuggerStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaScriptParserRULE_debuggerStatement
	return p
}

func InitEmptyDebuggerStatementContext(p *DebuggerStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaScriptParserRULE_debuggerStatement
}

func (*DebuggerStatementContext) IsDebuggerStatementContext() {}

func NewDebuggerStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DebuggerStatementContext {
	var p = new(DebuggerStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaScriptParserRULE_debuggerStatement

	return p
}

func (s *DebuggerStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *DebuggerStatementContext) Debugger() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserDebugger, 0)
}

func (s *DebuggerStatementContext) Eos() IEosContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEosContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEosContext)
}

func (s *DebuggerStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DebuggerStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DebuggerStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JavaScriptParserVisitor:
		return t.VisitDebuggerStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *JavaScriptParser) DebuggerStatement() (localctx IDebuggerStatementContext) {
	localctx = NewDebuggerStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 92, JavaScriptParserRULE_debuggerStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(542)
		p.Match(JavaScriptParserDebugger)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(543)
		p.Eos()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFunctionDeclarationContext is an interface to support dynamic dispatch.
type IFunctionDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Function_() antlr.TerminalNode
	Identifier() IIdentifierContext
	OpenParen() antlr.TerminalNode
	CloseParen() antlr.TerminalNode
	FunctionBody() IFunctionBodyContext
	Async() antlr.TerminalNode
	Multiply() antlr.TerminalNode
	FormalParameterList() IFormalParameterListContext

	// IsFunctionDeclarationContext differentiates from other interfaces.
	IsFunctionDeclarationContext()
}

type FunctionDeclarationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunctionDeclarationContext() *FunctionDeclarationContext {
	var p = new(FunctionDeclarationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaScriptParserRULE_functionDeclaration
	return p
}

func InitEmptyFunctionDeclarationContext(p *FunctionDeclarationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaScriptParserRULE_functionDeclaration
}

func (*FunctionDeclarationContext) IsFunctionDeclarationContext() {}

func NewFunctionDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FunctionDeclarationContext {
	var p = new(FunctionDeclarationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaScriptParserRULE_functionDeclaration

	return p
}

func (s *FunctionDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *FunctionDeclarationContext) Function_() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserFunction_, 0)
}

func (s *FunctionDeclarationContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *FunctionDeclarationContext) OpenParen() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserOpenParen, 0)
}

func (s *FunctionDeclarationContext) CloseParen() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserCloseParen, 0)
}

func (s *FunctionDeclarationContext) FunctionBody() IFunctionBodyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionBodyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionBodyContext)
}

func (s *FunctionDeclarationContext) Async() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserAsync, 0)
}

func (s *FunctionDeclarationContext) Multiply() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserMultiply, 0)
}

func (s *FunctionDeclarationContext) FormalParameterList() IFormalParameterListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFormalParameterListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFormalParameterListContext)
}

func (s *FunctionDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FunctionDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FunctionDeclarationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JavaScriptParserVisitor:
		return t.VisitFunctionDeclaration(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *JavaScriptParser) FunctionDeclaration() (localctx IFunctionDeclarationContext) {
	localctx = NewFunctionDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 94, JavaScriptParserRULE_functionDeclaration)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(546)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == JavaScriptParserAsync {
		{
			p.SetState(545)
			p.Match(JavaScriptParserAsync)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(548)
		p.Match(JavaScriptParserFunction_)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(550)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == JavaScriptParserMultiply {
		{
			p.SetState(549)
			p.Match(JavaScriptParserMultiply)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(552)
		p.Identifier()
	}
	{
		p.SetState(553)
		p.Match(JavaScriptParserOpenParen)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(555)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&262688) != 0) || ((int64((_la-98)) & ^0x3f) == 0 && ((int64(1)<<(_la-98))&2114051) != 0) {
		{
			p.SetState(554)
			p.FormalParameterList()
		}

	}
	{
		p.SetState(557)
		p.Match(JavaScriptParserCloseParen)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(558)
		p.FunctionBody()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IClassDeclarationContext is an interface to support dynamic dispatch.
type IClassDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Class() antlr.TerminalNode
	Identifier() IIdentifierContext
	ClassTail() IClassTailContext

	// IsClassDeclarationContext differentiates from other interfaces.
	IsClassDeclarationContext()
}

type ClassDeclarationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyClassDeclarationContext() *ClassDeclarationContext {
	var p = new(ClassDeclarationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaScriptParserRULE_classDeclaration
	return p
}

func InitEmptyClassDeclarationContext(p *ClassDeclarationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaScriptParserRULE_classDeclaration
}

func (*ClassDeclarationContext) IsClassDeclarationContext() {}

func NewClassDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ClassDeclarationContext {
	var p = new(ClassDeclarationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaScriptParserRULE_classDeclaration

	return p
}

func (s *ClassDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *ClassDeclarationContext) Class() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserClass, 0)
}

func (s *ClassDeclarationContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ClassDeclarationContext) ClassTail() IClassTailContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClassTailContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClassTailContext)
}

func (s *ClassDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ClassDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ClassDeclarationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JavaScriptParserVisitor:
		return t.VisitClassDeclaration(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *JavaScriptParser) ClassDeclaration() (localctx IClassDeclarationContext) {
	localctx = NewClassDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 96, JavaScriptParserRULE_classDeclaration)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(560)
		p.Match(JavaScriptParserClass)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(561)
		p.Identifier()
	}
	{
		p.SetState(562)
		p.ClassTail()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IClassTailContext is an interface to support dynamic dispatch.
type IClassTailContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	OpenBrace() antlr.TerminalNode
	CloseBrace() antlr.TerminalNode
	Extends() antlr.TerminalNode
	SingleExpression() ISingleExpressionContext
	AllClassElement() []IClassElementContext
	ClassElement(i int) IClassElementContext

	// IsClassTailContext differentiates from other interfaces.
	IsClassTailContext()
}

type ClassTailContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyClassTailContext() *ClassTailContext {
	var p = new(ClassTailContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaScriptParserRULE_classTail
	return p
}

func InitEmptyClassTailContext(p *ClassTailContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaScriptParserRULE_classTail
}

func (*ClassTailContext) IsClassTailContext() {}

func NewClassTailContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ClassTailContext {
	var p = new(ClassTailContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaScriptParserRULE_classTail

	return p
}

func (s *ClassTailContext) GetParser() antlr.Parser { return s.parser }

func (s *ClassTailContext) OpenBrace() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserOpenBrace, 0)
}

func (s *ClassTailContext) CloseBrace() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserCloseBrace, 0)
}

func (s *ClassTailContext) Extends() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserExtends, 0)
}

func (s *ClassTailContext) SingleExpression() ISingleExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISingleExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISingleExpressionContext)
}

func (s *ClassTailContext) AllClassElement() []IClassElementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IClassElementContext); ok {
			len++
		}
	}

	tst := make([]IClassElementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IClassElementContext); ok {
			tst[i] = t.(IClassElementContext)
			i++
		}
	}

	return tst
}

func (s *ClassTailContext) ClassElement(i int) IClassElementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClassElementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClassElementContext)
}

func (s *ClassTailContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ClassTailContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ClassTailContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JavaScriptParserVisitor:
		return t.VisitClassTail(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *JavaScriptParser) ClassTail() (localctx IClassTailContext) {
	localctx = NewClassTailContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 98, JavaScriptParserRULE_classTail)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(566)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == JavaScriptParserExtends {
		{
			p.SetState(564)
			p.Match(JavaScriptParserExtends)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(565)
			p.singleExpression(0)
		}

	}
	{
		p.SetState(568)
		p.Match(JavaScriptParserOpenBrace)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(572)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 56, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(569)
				p.ClassElement()
			}

		}
		p.SetState(574)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 56, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	{
		p.SetState(575)
		p.Match(JavaScriptParserCloseBrace)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IClassElementContext is an interface to support dynamic dispatch.
type IClassElementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	MethodDefinition() IMethodDefinitionContext
	Static() antlr.TerminalNode
	Identifier() IIdentifierContext
	FieldDefinition() IFieldDefinitionContext
	Block() IBlockContext
	EmptyStatement_() IEmptyStatement_Context

	// IsClassElementContext differentiates from other interfaces.
	IsClassElementContext()
}

type ClassElementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyClassElementContext() *ClassElementContext {
	var p = new(ClassElementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaScriptParserRULE_classElement
	return p
}

func InitEmptyClassElementContext(p *ClassElementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaScriptParserRULE_classElement
}

func (*ClassElementContext) IsClassElementContext() {}

func NewClassElementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ClassElementContext {
	var p = new(ClassElementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaScriptParserRULE_classElement

	return p
}

func (s *ClassElementContext) GetParser() antlr.Parser { return s.parser }

func (s *ClassElementContext) MethodDefinition() IMethodDefinitionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMethodDefinitionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMethodDefinitionContext)
}

func (s *ClassElementContext) Static() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserStatic, 0)
}

func (s *ClassElementContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ClassElementContext) FieldDefinition() IFieldDefinitionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFieldDefinitionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFieldDefinitionContext)
}

func (s *ClassElementContext) Block() IBlockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBlockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBlockContext)
}

func (s *ClassElementContext) EmptyStatement_() IEmptyStatement_Context {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEmptyStatement_Context); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEmptyStatement_Context)
}

func (s *ClassElementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ClassElementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ClassElementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JavaScriptParserVisitor:
		return t.VisitClassElement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *JavaScriptParser) ClassElement() (localctx IClassElementContext) {
	localctx = NewClassElementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 100, JavaScriptParserRULE_classElement)
	p.SetState(596)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 60, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(580)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 57, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(577)
				p.Match(JavaScriptParserStatic)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		} else if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 57, p.GetParserRuleContext()) == 2 {
			p.SetState(578)

			if !(p.n("static")) {
				p.SetError(antlr.NewFailedPredicateException(p, "p.n(\"static\")", ""))
				goto errorExit
			}
			{
				p.SetState(579)
				p.Identifier()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(582)
			p.MethodDefinition()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(586)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 58, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(583)
				p.Match(JavaScriptParserStatic)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		} else if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 58, p.GetParserRuleContext()) == 2 {
			p.SetState(584)

			if !(p.n("static")) {
				p.SetError(antlr.NewFailedPredicateException(p, "p.n(\"static\")", ""))
				goto errorExit
			}
			{
				p.SetState(585)
				p.Identifier()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(588)
			p.FieldDefinition()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		p.SetState(592)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 59, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(589)
				p.Match(JavaScriptParserStatic)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case 2:
			p.SetState(590)

			if !(p.n("static")) {
				p.SetError(antlr.NewFailedPredicateException(p, "p.n(\"static\")", ""))
				goto errorExit
			}
			{
				p.SetState(591)
				p.Identifier()
			}

		case antlr.ATNInvalidAltNumber:
			goto errorExit
		}
		{
			p.SetState(594)
			p.Block()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(595)
			p.EmptyStatement_()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMethodDefinitionContext is an interface to support dynamic dispatch.
type IMethodDefinitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ClassElementName() IClassElementNameContext
	OpenParen() antlr.TerminalNode
	CloseParen() antlr.TerminalNode
	FunctionBody() IFunctionBodyContext
	Async() antlr.TerminalNode
	Multiply() antlr.TerminalNode
	FormalParameterList() IFormalParameterListContext
	Getter() IGetterContext
	Setter() ISetterContext

	// IsMethodDefinitionContext differentiates from other interfaces.
	IsMethodDefinitionContext()
}

type MethodDefinitionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMethodDefinitionContext() *MethodDefinitionContext {
	var p = new(MethodDefinitionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaScriptParserRULE_methodDefinition
	return p
}

func InitEmptyMethodDefinitionContext(p *MethodDefinitionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaScriptParserRULE_methodDefinition
}

func (*MethodDefinitionContext) IsMethodDefinitionContext() {}

func NewMethodDefinitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MethodDefinitionContext {
	var p = new(MethodDefinitionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaScriptParserRULE_methodDefinition

	return p
}

func (s *MethodDefinitionContext) GetParser() antlr.Parser { return s.parser }

func (s *MethodDefinitionContext) ClassElementName() IClassElementNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClassElementNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClassElementNameContext)
}

func (s *MethodDefinitionContext) OpenParen() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserOpenParen, 0)
}

func (s *MethodDefinitionContext) CloseParen() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserCloseParen, 0)
}

func (s *MethodDefinitionContext) FunctionBody() IFunctionBodyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionBodyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionBodyContext)
}

func (s *MethodDefinitionContext) Async() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserAsync, 0)
}

func (s *MethodDefinitionContext) Multiply() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserMultiply, 0)
}

func (s *MethodDefinitionContext) FormalParameterList() IFormalParameterListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFormalParameterListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFormalParameterListContext)
}

func (s *MethodDefinitionContext) Getter() IGetterContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGetterContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGetterContext)
}

func (s *MethodDefinitionContext) Setter() ISetterContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISetterContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISetterContext)
}

func (s *MethodDefinitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MethodDefinitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MethodDefinitionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JavaScriptParserVisitor:
		return t.VisitMethodDefinition(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *JavaScriptParser) MethodDefinition() (localctx IMethodDefinitionContext) {
	localctx = NewMethodDefinitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 102, JavaScriptParserRULE_methodDefinition)
	var _la int

	p.SetState(632)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 67, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(600)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 61, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(598)
				p.Match(JavaScriptParserAsync)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			p.SetState(599)

			if !(p.notLineTerminator()) {
				p.SetError(antlr.NewFailedPredicateException(p, "p.notLineTerminator()", ""))
				goto errorExit
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(603)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == JavaScriptParserMultiply {
			{
				p.SetState(602)
				p.Match(JavaScriptParserMultiply)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(605)
			p.ClassElementName()
		}
		{
			p.SetState(606)
			p.Match(JavaScriptParserOpenParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(608)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&262688) != 0) || ((int64((_la-98)) & ^0x3f) == 0 && ((int64(1)<<(_la-98))&2114051) != 0) {
			{
				p.SetState(607)
				p.FormalParameterList()
			}

		}
		{
			p.SetState(610)
			p.Match(JavaScriptParserCloseParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(611)
			p.FunctionBody()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(614)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 64, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(613)
				p.Match(JavaScriptParserMultiply)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(616)
			p.Getter()
		}
		{
			p.SetState(617)
			p.Match(JavaScriptParserOpenParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(618)
			p.Match(JavaScriptParserCloseParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(619)
			p.FunctionBody()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		p.SetState(622)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 65, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(621)
				p.Match(JavaScriptParserMultiply)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(624)
			p.Setter()
		}
		{
			p.SetState(625)
			p.Match(JavaScriptParserOpenParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(627)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&262688) != 0) || ((int64((_la-98)) & ^0x3f) == 0 && ((int64(1)<<(_la-98))&2114051) != 0) {
			{
				p.SetState(626)
				p.FormalParameterList()
			}

		}
		{
			p.SetState(629)
			p.Match(JavaScriptParserCloseParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(630)
			p.FunctionBody()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFieldDefinitionContext is an interface to support dynamic dispatch.
type IFieldDefinitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ClassElementName() IClassElementNameContext
	Initializer() IInitializerContext

	// IsFieldDefinitionContext differentiates from other interfaces.
	IsFieldDefinitionContext()
}

type FieldDefinitionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFieldDefinitionContext() *FieldDefinitionContext {
	var p = new(FieldDefinitionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaScriptParserRULE_fieldDefinition
	return p
}

func InitEmptyFieldDefinitionContext(p *FieldDefinitionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaScriptParserRULE_fieldDefinition
}

func (*FieldDefinitionContext) IsFieldDefinitionContext() {}

func NewFieldDefinitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FieldDefinitionContext {
	var p = new(FieldDefinitionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaScriptParserRULE_fieldDefinition

	return p
}

func (s *FieldDefinitionContext) GetParser() antlr.Parser { return s.parser }

func (s *FieldDefinitionContext) ClassElementName() IClassElementNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClassElementNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClassElementNameContext)
}

func (s *FieldDefinitionContext) Initializer() IInitializerContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInitializerContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInitializerContext)
}

func (s *FieldDefinitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FieldDefinitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FieldDefinitionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JavaScriptParserVisitor:
		return t.VisitFieldDefinition(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *JavaScriptParser) FieldDefinition() (localctx IFieldDefinitionContext) {
	localctx = NewFieldDefinitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 104, JavaScriptParserRULE_fieldDefinition)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(634)
		p.ClassElementName()
	}
	p.SetState(636)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 68, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(635)
			p.Initializer()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IClassElementNameContext is an interface to support dynamic dispatch.
type IClassElementNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PropertyName() IPropertyNameContext
	PrivateIdentifier() IPrivateIdentifierContext

	// IsClassElementNameContext differentiates from other interfaces.
	IsClassElementNameContext()
}

type ClassElementNameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyClassElementNameContext() *ClassElementNameContext {
	var p = new(ClassElementNameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaScriptParserRULE_classElementName
	return p
}

func InitEmptyClassElementNameContext(p *ClassElementNameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaScriptParserRULE_classElementName
}

func (*ClassElementNameContext) IsClassElementNameContext() {}

func NewClassElementNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ClassElementNameContext {
	var p = new(ClassElementNameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaScriptParserRULE_classElementName

	return p
}

func (s *ClassElementNameContext) GetParser() antlr.Parser { return s.parser }

func (s *ClassElementNameContext) PropertyName() IPropertyNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyNameContext)
}

func (s *ClassElementNameContext) PrivateIdentifier() IPrivateIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrivateIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrivateIdentifierContext)
}

func (s *ClassElementNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ClassElementNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ClassElementNameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JavaScriptParserVisitor:
		return t.VisitClassElementName(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *JavaScriptParser) ClassElementName() (localctx IClassElementNameContext) {
	localctx = NewClassElementNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 106, JavaScriptParserRULE_classElementName)
	p.SetState(640)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case JavaScriptParserOpenBracket, JavaScriptParserNullLiteral, JavaScriptParserBooleanLiteral, JavaScriptParserDecimalLiteral, JavaScriptParserHexIntegerLiteral, JavaScriptParserOctalIntegerLiteral, JavaScriptParserOctalIntegerLiteral2, JavaScriptParserBinaryIntegerLiteral, JavaScriptParserBreak, JavaScriptParserDo, JavaScriptParserInstanceof, JavaScriptParserTypeof, JavaScriptParserCase, JavaScriptParserElse, JavaScriptParserNew, JavaScriptParserVar, JavaScriptParserCatch, JavaScriptParserFinally, JavaScriptParserReturn, JavaScriptParserVoid, JavaScriptParserContinue, JavaScriptParserFor, JavaScriptParserSwitch, JavaScriptParserWhile, JavaScriptParserDebugger, JavaScriptParserFunction_, JavaScriptParserThis, JavaScriptParserWith, JavaScriptParserDefault, JavaScriptParserIf, JavaScriptParserThrow, JavaScriptParserDelete, JavaScriptParserIn, JavaScriptParserTry, JavaScriptParserAs, JavaScriptParserFrom, JavaScriptParserClass, JavaScriptParserEnum, JavaScriptParserExtends, JavaScriptParserSuper, JavaScriptParserConst, JavaScriptParserExport, JavaScriptParserImport, JavaScriptParserAsync, JavaScriptParserAwait, JavaScriptParserYield, JavaScriptParserImplements, JavaScriptParserStrictLet, JavaScriptParserNonStrictLet, JavaScriptParserPrivate, JavaScriptParserPublic, JavaScriptParserInterface, JavaScriptParserPackage, JavaScriptParserProtected, JavaScriptParserStatic, JavaScriptParserIdentifier, JavaScriptParserStringLiteral:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(638)
			p.PropertyName()
		}

	case JavaScriptParserHashtag:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(639)
			p.PrivateIdentifier()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPrivateIdentifierContext is an interface to support dynamic dispatch.
type IPrivateIdentifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Hashtag() antlr.TerminalNode
	IdentifierName() IIdentifierNameContext

	// IsPrivateIdentifierContext differentiates from other interfaces.
	IsPrivateIdentifierContext()
}

type PrivateIdentifierContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPrivateIdentifierContext() *PrivateIdentifierContext {
	var p = new(PrivateIdentifierContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaScriptParserRULE_privateIdentifier
	return p
}

func InitEmptyPrivateIdentifierContext(p *PrivateIdentifierContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaScriptParserRULE_privateIdentifier
}

func (*PrivateIdentifierContext) IsPrivateIdentifierContext() {}

func NewPrivateIdentifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PrivateIdentifierContext {
	var p = new(PrivateIdentifierContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaScriptParserRULE_privateIdentifier

	return p
}

func (s *PrivateIdentifierContext) GetParser() antlr.Parser { return s.parser }

func (s *PrivateIdentifierContext) Hashtag() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserHashtag, 0)
}

func (s *PrivateIdentifierContext) IdentifierName() IIdentifierNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierNameContext)
}

func (s *PrivateIdentifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrivateIdentifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PrivateIdentifierContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JavaScriptParserVisitor:
		return t.VisitPrivateIdentifier(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *JavaScriptParser) PrivateIdentifier() (localctx IPrivateIdentifierContext) {
	localctx = NewPrivateIdentifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 108, JavaScriptParserRULE_privateIdentifier)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(642)
		p.Match(JavaScriptParserHashtag)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(643)
		p.IdentifierName()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFormalParameterListContext is an interface to support dynamic dispatch.
type IFormalParameterListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllFormalParameterArg() []IFormalParameterArgContext
	FormalParameterArg(i int) IFormalParameterArgContext
	AllComma() []antlr.TerminalNode
	Comma(i int) antlr.TerminalNode
	LastFormalParameterArg() ILastFormalParameterArgContext

	// IsFormalParameterListContext differentiates from other interfaces.
	IsFormalParameterListContext()
}

type FormalParameterListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFormalParameterListContext() *FormalParameterListContext {
	var p = new(FormalParameterListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaScriptParserRULE_formalParameterList
	return p
}

func InitEmptyFormalParameterListContext(p *FormalParameterListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaScriptParserRULE_formalParameterList
}

func (*FormalParameterListContext) IsFormalParameterListContext() {}

func NewFormalParameterListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FormalParameterListContext {
	var p = new(FormalParameterListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaScriptParserRULE_formalParameterList

	return p
}

func (s *FormalParameterListContext) GetParser() antlr.Parser { return s.parser }

func (s *FormalParameterListContext) AllFormalParameterArg() []IFormalParameterArgContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IFormalParameterArgContext); ok {
			len++
		}
	}

	tst := make([]IFormalParameterArgContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IFormalParameterArgContext); ok {
			tst[i] = t.(IFormalParameterArgContext)
			i++
		}
	}

	return tst
}

func (s *FormalParameterListContext) FormalParameterArg(i int) IFormalParameterArgContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFormalParameterArgContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFormalParameterArgContext)
}

func (s *FormalParameterListContext) AllComma() []antlr.TerminalNode {
	return s.GetTokens(JavaScriptParserComma)
}

func (s *FormalParameterListContext) Comma(i int) antlr.TerminalNode {
	return s.GetToken(JavaScriptParserComma, i)
}

func (s *FormalParameterListContext) LastFormalParameterArg() ILastFormalParameterArgContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILastFormalParameterArgContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILastFormalParameterArgContext)
}

func (s *FormalParameterListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FormalParameterListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FormalParameterListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JavaScriptParserVisitor:
		return t.VisitFormalParameterList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *JavaScriptParser) FormalParameterList() (localctx IFormalParameterListContext) {
	localctx = NewFormalParameterListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 110, JavaScriptParserRULE_formalParameterList)
	var _la int

	var _alt int

	p.SetState(658)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case JavaScriptParserOpenBracket, JavaScriptParserOpenBrace, JavaScriptParserAs, JavaScriptParserFrom, JavaScriptParserAsync, JavaScriptParserNonStrictLet, JavaScriptParserIdentifier:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(645)
			p.FormalParameterArg()
		}
		p.SetState(650)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 70, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(646)
					p.Match(JavaScriptParserComma)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(647)
					p.FormalParameterArg()
				}

			}
			p.SetState(652)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 70, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}
		p.SetState(655)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == JavaScriptParserComma {
			{
				p.SetState(653)
				p.Match(JavaScriptParserComma)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(654)
				p.LastFormalParameterArg()
			}

		}

	case JavaScriptParserEllipsis:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(657)
			p.LastFormalParameterArg()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFormalParameterArgContext is an interface to support dynamic dispatch.
type IFormalParameterArgContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Assignable() IAssignableContext
	Assign() antlr.TerminalNode
	SingleExpression() ISingleExpressionContext

	// IsFormalParameterArgContext differentiates from other interfaces.
	IsFormalParameterArgContext()
}

type FormalParameterArgContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFormalParameterArgContext() *FormalParameterArgContext {
	var p = new(FormalParameterArgContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaScriptParserRULE_formalParameterArg
	return p
}

func InitEmptyFormalParameterArgContext(p *FormalParameterArgContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaScriptParserRULE_formalParameterArg
}

func (*FormalParameterArgContext) IsFormalParameterArgContext() {}

func NewFormalParameterArgContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FormalParameterArgContext {
	var p = new(FormalParameterArgContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaScriptParserRULE_formalParameterArg

	return p
}

func (s *FormalParameterArgContext) GetParser() antlr.Parser { return s.parser }

func (s *FormalParameterArgContext) Assignable() IAssignableContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAssignableContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAssignableContext)
}

func (s *FormalParameterArgContext) Assign() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserAssign, 0)
}

func (s *FormalParameterArgContext) SingleExpression() ISingleExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISingleExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISingleExpressionContext)
}

func (s *FormalParameterArgContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FormalParameterArgContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FormalParameterArgContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JavaScriptParserVisitor:
		return t.VisitFormalParameterArg(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *JavaScriptParser) FormalParameterArg() (localctx IFormalParameterArgContext) {
	localctx = NewFormalParameterArgContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 112, JavaScriptParserRULE_formalParameterArg)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(660)
		p.Assignable()
	}
	p.SetState(663)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == JavaScriptParserAssign {
		{
			p.SetState(661)
			p.Match(JavaScriptParserAssign)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(662)
			p.singleExpression(0)
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILastFormalParameterArgContext is an interface to support dynamic dispatch.
type ILastFormalParameterArgContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Ellipsis() antlr.TerminalNode
	SingleExpression() ISingleExpressionContext

	// IsLastFormalParameterArgContext differentiates from other interfaces.
	IsLastFormalParameterArgContext()
}

type LastFormalParameterArgContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLastFormalParameterArgContext() *LastFormalParameterArgContext {
	var p = new(LastFormalParameterArgContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaScriptParserRULE_lastFormalParameterArg
	return p
}

func InitEmptyLastFormalParameterArgContext(p *LastFormalParameterArgContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaScriptParserRULE_lastFormalParameterArg
}

func (*LastFormalParameterArgContext) IsLastFormalParameterArgContext() {}

func NewLastFormalParameterArgContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LastFormalParameterArgContext {
	var p = new(LastFormalParameterArgContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaScriptParserRULE_lastFormalParameterArg

	return p
}

func (s *LastFormalParameterArgContext) GetParser() antlr.Parser { return s.parser }

func (s *LastFormalParameterArgContext) Ellipsis() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserEllipsis, 0)
}

func (s *LastFormalParameterArgContext) SingleExpression() ISingleExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISingleExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISingleExpressionContext)
}

func (s *LastFormalParameterArgContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LastFormalParameterArgContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LastFormalParameterArgContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JavaScriptParserVisitor:
		return t.VisitLastFormalParameterArg(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *JavaScriptParser) LastFormalParameterArg() (localctx ILastFormalParameterArgContext) {
	localctx = NewLastFormalParameterArgContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 114, JavaScriptParserRULE_lastFormalParameterArg)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(665)
		p.Match(JavaScriptParserEllipsis)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(666)
		p.singleExpression(0)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFunctionBodyContext is an interface to support dynamic dispatch.
type IFunctionBodyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	OpenBrace() antlr.TerminalNode
	CloseBrace() antlr.TerminalNode
	SourceElements() ISourceElementsContext

	// IsFunctionBodyContext differentiates from other interfaces.
	IsFunctionBodyContext()
}

type FunctionBodyContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunctionBodyContext() *FunctionBodyContext {
	var p = new(FunctionBodyContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaScriptParserRULE_functionBody
	return p
}

func InitEmptyFunctionBodyContext(p *FunctionBodyContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaScriptParserRULE_functionBody
}

func (*FunctionBodyContext) IsFunctionBodyContext() {}

func NewFunctionBodyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FunctionBodyContext {
	var p = new(FunctionBodyContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaScriptParserRULE_functionBody

	return p
}

func (s *FunctionBodyContext) GetParser() antlr.Parser { return s.parser }

func (s *FunctionBodyContext) OpenBrace() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserOpenBrace, 0)
}

func (s *FunctionBodyContext) CloseBrace() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserCloseBrace, 0)
}

func (s *FunctionBodyContext) SourceElements() ISourceElementsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISourceElementsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISourceElementsContext)
}

func (s *FunctionBodyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FunctionBodyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FunctionBodyContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JavaScriptParserVisitor:
		return t.VisitFunctionBody(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *JavaScriptParser) FunctionBody() (localctx IFunctionBodyContext) {
	localctx = NewFunctionBodyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 116, JavaScriptParserRULE_functionBody)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(668)
		p.Match(JavaScriptParserOpenBrace)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(670)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 74, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(669)
			p.SourceElements()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(672)
		p.Match(JavaScriptParserCloseBrace)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISourceElementsContext is an interface to support dynamic dispatch.
type ISourceElementsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllSourceElement() []ISourceElementContext
	SourceElement(i int) ISourceElementContext

	// IsSourceElementsContext differentiates from other interfaces.
	IsSourceElementsContext()
}

type SourceElementsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySourceElementsContext() *SourceElementsContext {
	var p = new(SourceElementsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaScriptParserRULE_sourceElements
	return p
}

func InitEmptySourceElementsContext(p *SourceElementsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaScriptParserRULE_sourceElements
}

func (*SourceElementsContext) IsSourceElementsContext() {}

func NewSourceElementsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SourceElementsContext {
	var p = new(SourceElementsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaScriptParserRULE_sourceElements

	return p
}

func (s *SourceElementsContext) GetParser() antlr.Parser { return s.parser }

func (s *SourceElementsContext) AllSourceElement() []ISourceElementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISourceElementContext); ok {
			len++
		}
	}

	tst := make([]ISourceElementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISourceElementContext); ok {
			tst[i] = t.(ISourceElementContext)
			i++
		}
	}

	return tst
}

func (s *SourceElementsContext) SourceElement(i int) ISourceElementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISourceElementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISourceElementContext)
}

func (s *SourceElementsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SourceElementsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SourceElementsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JavaScriptParserVisitor:
		return t.VisitSourceElements(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *JavaScriptParser) SourceElements() (localctx ISourceElementsContext) {
	localctx = NewSourceElementsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 118, JavaScriptParserRULE_sourceElements)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(675)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			{
				p.SetState(674)
				p.SourceElement()
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

		p.SetState(677)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 75, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IArrayLiteralContext is an interface to support dynamic dispatch.
type IArrayLiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	OpenBracket() antlr.TerminalNode
	ElementList() IElementListContext
	CloseBracket() antlr.TerminalNode

	// IsArrayLiteralContext differentiates from other interfaces.
	IsArrayLiteralContext()
}

type ArrayLiteralContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyArrayLiteralContext() *ArrayLiteralContext {
	var p = new(ArrayLiteralContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaScriptParserRULE_arrayLiteral
	return p
}

func InitEmptyArrayLiteralContext(p *ArrayLiteralContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaScriptParserRULE_arrayLiteral
}

func (*ArrayLiteralContext) IsArrayLiteralContext() {}

func NewArrayLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ArrayLiteralContext {
	var p = new(ArrayLiteralContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaScriptParserRULE_arrayLiteral

	return p
}

func (s *ArrayLiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *ArrayLiteralContext) OpenBracket() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserOpenBracket, 0)
}

func (s *ArrayLiteralContext) ElementList() IElementListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IElementListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IElementListContext)
}

func (s *ArrayLiteralContext) CloseBracket() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserCloseBracket, 0)
}

func (s *ArrayLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArrayLiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ArrayLiteralContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JavaScriptParserVisitor:
		return t.VisitArrayLiteral(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *JavaScriptParser) ArrayLiteral() (localctx IArrayLiteralContext) {
	localctx = NewArrayLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 120, JavaScriptParserRULE_arrayLiteral)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(679)
		p.Match(JavaScriptParserOpenBracket)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(680)
		p.ElementList()
	}
	{
		p.SetState(681)
		p.Match(JavaScriptParserCloseBracket)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IElementListContext is an interface to support dynamic dispatch.
type IElementListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllComma() []antlr.TerminalNode
	Comma(i int) antlr.TerminalNode
	AllArrayElement() []IArrayElementContext
	ArrayElement(i int) IArrayElementContext

	// IsElementListContext differentiates from other interfaces.
	IsElementListContext()
}

type ElementListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyElementListContext() *ElementListContext {
	var p = new(ElementListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaScriptParserRULE_elementList
	return p
}

func InitEmptyElementListContext(p *ElementListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaScriptParserRULE_elementList
}

func (*ElementListContext) IsElementListContext() {}

func NewElementListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ElementListContext {
	var p = new(ElementListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaScriptParserRULE_elementList

	return p
}

func (s *ElementListContext) GetParser() antlr.Parser { return s.parser }

func (s *ElementListContext) AllComma() []antlr.TerminalNode {
	return s.GetTokens(JavaScriptParserComma)
}

func (s *ElementListContext) Comma(i int) antlr.TerminalNode {
	return s.GetToken(JavaScriptParserComma, i)
}

func (s *ElementListContext) AllArrayElement() []IArrayElementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IArrayElementContext); ok {
			len++
		}
	}

	tst := make([]IArrayElementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IArrayElementContext); ok {
			tst[i] = t.(IArrayElementContext)
			i++
		}
	}

	return tst
}

func (s *ElementListContext) ArrayElement(i int) IArrayElementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArrayElementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArrayElementContext)
}

func (s *ElementListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ElementListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ElementListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JavaScriptParserVisitor:
		return t.VisitElementList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *JavaScriptParser) ElementList() (localctx IElementListContext) {
	localctx = NewElementListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 122, JavaScriptParserRULE_elementList)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(686)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 76, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(683)
				p.Match(JavaScriptParserComma)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(688)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 76, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	p.SetState(690)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-2305843009147370832) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&252549697070713087) != 0) {
		{
			p.SetState(689)
			p.ArrayElement()
		}

	}
	p.SetState(700)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 79, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			p.SetState(693)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for ok := true; ok; ok = _la == JavaScriptParserComma {
				{
					p.SetState(692)
					p.Match(JavaScriptParserComma)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

				p.SetState(695)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(697)
				p.ArrayElement()
			}

		}
		p.SetState(702)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 79, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	p.SetState(706)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == JavaScriptParserComma {
		{
			p.SetState(703)
			p.Match(JavaScriptParserComma)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		p.SetState(708)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IArrayElementContext is an interface to support dynamic dispatch.
type IArrayElementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SingleExpression() ISingleExpressionContext
	Ellipsis() antlr.TerminalNode

	// IsArrayElementContext differentiates from other interfaces.
	IsArrayElementContext()
}

type ArrayElementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyArrayElementContext() *ArrayElementContext {
	var p = new(ArrayElementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaScriptParserRULE_arrayElement
	return p
}

func InitEmptyArrayElementContext(p *ArrayElementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaScriptParserRULE_arrayElement
}

func (*ArrayElementContext) IsArrayElementContext() {}

func NewArrayElementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ArrayElementContext {
	var p = new(ArrayElementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaScriptParserRULE_arrayElement

	return p
}

func (s *ArrayElementContext) GetParser() antlr.Parser { return s.parser }

func (s *ArrayElementContext) SingleExpression() ISingleExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISingleExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISingleExpressionContext)
}

func (s *ArrayElementContext) Ellipsis() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserEllipsis, 0)
}

func (s *ArrayElementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArrayElementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ArrayElementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JavaScriptParserVisitor:
		return t.VisitArrayElement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *JavaScriptParser) ArrayElement() (localctx IArrayElementContext) {
	localctx = NewArrayElementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 124, JavaScriptParserRULE_arrayElement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(710)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == JavaScriptParserEllipsis {
		{
			p.SetState(709)
			p.Match(JavaScriptParserEllipsis)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(712)
		p.singleExpression(0)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPropertyAssignmentContext is an interface to support dynamic dispatch.
type IPropertyAssignmentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsPropertyAssignmentContext differentiates from other interfaces.
	IsPropertyAssignmentContext()
}

type PropertyAssignmentContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPropertyAssignmentContext() *PropertyAssignmentContext {
	var p = new(PropertyAssignmentContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaScriptParserRULE_propertyAssignment
	return p
}

func InitEmptyPropertyAssignmentContext(p *PropertyAssignmentContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaScriptParserRULE_propertyAssignment
}

func (*PropertyAssignmentContext) IsPropertyAssignmentContext() {}

func NewPropertyAssignmentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PropertyAssignmentContext {
	var p = new(PropertyAssignmentContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaScriptParserRULE_propertyAssignment

	return p
}

func (s *PropertyAssignmentContext) GetParser() antlr.Parser { return s.parser }

func (s *PropertyAssignmentContext) CopyAll(ctx *PropertyAssignmentContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *PropertyAssignmentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PropertyAssignmentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type PropertyExpressionAssignmentContext struct {
	PropertyAssignmentContext
}

func NewPropertyExpressionAssignmentContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *PropertyExpressionAssignmentContext {
	var p = new(PropertyExpressionAssignmentContext)

	InitEmptyPropertyAssignmentContext(&p.PropertyAssignmentContext)
	p.parser = parser
	p.CopyAll(ctx.(*PropertyAssignmentContext))

	return p
}

func (s *PropertyExpressionAssignmentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PropertyExpressionAssignmentContext) PropertyName() IPropertyNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyNameContext)
}

func (s *PropertyExpressionAssignmentContext) Colon() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserColon, 0)
}

func (s *PropertyExpressionAssignmentContext) SingleExpression() ISingleExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISingleExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISingleExpressionContext)
}

func (s *PropertyExpressionAssignmentContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JavaScriptParserVisitor:
		return t.VisitPropertyExpressionAssignment(s)

	default:
		return t.VisitChildren(s)
	}
}

type ComputedPropertyExpressionAssignmentContext struct {
	PropertyAssignmentContext
}

func NewComputedPropertyExpressionAssignmentContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ComputedPropertyExpressionAssignmentContext {
	var p = new(ComputedPropertyExpressionAssignmentContext)

	InitEmptyPropertyAssignmentContext(&p.PropertyAssignmentContext)
	p.parser = parser
	p.CopyAll(ctx.(*PropertyAssignmentContext))

	return p
}

func (s *ComputedPropertyExpressionAssignmentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ComputedPropertyExpressionAssignmentContext) OpenBracket() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserOpenBracket, 0)
}

func (s *ComputedPropertyExpressionAssignmentContext) AllSingleExpression() []ISingleExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISingleExpressionContext); ok {
			len++
		}
	}

	tst := make([]ISingleExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISingleExpressionContext); ok {
			tst[i] = t.(ISingleExpressionContext)
			i++
		}
	}

	return tst
}

func (s *ComputedPropertyExpressionAssignmentContext) SingleExpression(i int) ISingleExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISingleExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISingleExpressionContext)
}

func (s *ComputedPropertyExpressionAssignmentContext) CloseBracket() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserCloseBracket, 0)
}

func (s *ComputedPropertyExpressionAssignmentContext) Colon() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserColon, 0)
}

func (s *ComputedPropertyExpressionAssignmentContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JavaScriptParserVisitor:
		return t.VisitComputedPropertyExpressionAssignment(s)

	default:
		return t.VisitChildren(s)
	}
}

type PropertyShorthandContext struct {
	PropertyAssignmentContext
}

func NewPropertyShorthandContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *PropertyShorthandContext {
	var p = new(PropertyShorthandContext)

	InitEmptyPropertyAssignmentContext(&p.PropertyAssignmentContext)
	p.parser = parser
	p.CopyAll(ctx.(*PropertyAssignmentContext))

	return p
}

func (s *PropertyShorthandContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PropertyShorthandContext) SingleExpression() ISingleExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISingleExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISingleExpressionContext)
}

func (s *PropertyShorthandContext) Ellipsis() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserEllipsis, 0)
}

func (s *PropertyShorthandContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JavaScriptParserVisitor:
		return t.VisitPropertyShorthand(s)

	default:
		return t.VisitChildren(s)
	}
}

type PropertySetterContext struct {
	PropertyAssignmentContext
}

func NewPropertySetterContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *PropertySetterContext {
	var p = new(PropertySetterContext)

	InitEmptyPropertyAssignmentContext(&p.PropertyAssignmentContext)
	p.parser = parser
	p.CopyAll(ctx.(*PropertyAssignmentContext))

	return p
}

func (s *PropertySetterContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PropertySetterContext) Setter() ISetterContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISetterContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISetterContext)
}

func (s *PropertySetterContext) OpenParen() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserOpenParen, 0)
}

func (s *PropertySetterContext) FormalParameterArg() IFormalParameterArgContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFormalParameterArgContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFormalParameterArgContext)
}

func (s *PropertySetterContext) CloseParen() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserCloseParen, 0)
}

func (s *PropertySetterContext) FunctionBody() IFunctionBodyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionBodyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionBodyContext)
}

func (s *PropertySetterContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JavaScriptParserVisitor:
		return t.VisitPropertySetter(s)

	default:
		return t.VisitChildren(s)
	}
}

type PropertyGetterContext struct {
	PropertyAssignmentContext
}

func NewPropertyGetterContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *PropertyGetterContext {
	var p = new(PropertyGetterContext)

	InitEmptyPropertyAssignmentContext(&p.PropertyAssignmentContext)
	p.parser = parser
	p.CopyAll(ctx.(*PropertyAssignmentContext))

	return p
}

func (s *PropertyGetterContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PropertyGetterContext) Getter() IGetterContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGetterContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGetterContext)
}

func (s *PropertyGetterContext) OpenParen() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserOpenParen, 0)
}

func (s *PropertyGetterContext) CloseParen() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserCloseParen, 0)
}

func (s *PropertyGetterContext) FunctionBody() IFunctionBodyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionBodyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionBodyContext)
}

func (s *PropertyGetterContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JavaScriptParserVisitor:
		return t.VisitPropertyGetter(s)

	default:
		return t.VisitChildren(s)
	}
}

type FunctionPropertyContext struct {
	PropertyAssignmentContext
}

func NewFunctionPropertyContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *FunctionPropertyContext {
	var p = new(FunctionPropertyContext)

	InitEmptyPropertyAssignmentContext(&p.PropertyAssignmentContext)
	p.parser = parser
	p.CopyAll(ctx.(*PropertyAssignmentContext))

	return p
}

func (s *FunctionPropertyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FunctionPropertyContext) PropertyName() IPropertyNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyNameContext)
}

func (s *FunctionPropertyContext) OpenParen() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserOpenParen, 0)
}

func (s *FunctionPropertyContext) CloseParen() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserCloseParen, 0)
}

func (s *FunctionPropertyContext) FunctionBody() IFunctionBodyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionBodyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionBodyContext)
}

func (s *FunctionPropertyContext) Async() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserAsync, 0)
}

func (s *FunctionPropertyContext) Multiply() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserMultiply, 0)
}

func (s *FunctionPropertyContext) FormalParameterList() IFormalParameterListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFormalParameterListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFormalParameterListContext)
}

func (s *FunctionPropertyContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JavaScriptParserVisitor:
		return t.VisitFunctionProperty(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *JavaScriptParser) PropertyAssignment() (localctx IPropertyAssignmentContext) {
	localctx = NewPropertyAssignmentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 126, JavaScriptParserRULE_propertyAssignment)
	var _la int

	p.SetState(753)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 86, p.GetParserRuleContext()) {
	case 1:
		localctx = NewPropertyExpressionAssignmentContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(714)
			p.PropertyName()
		}
		{
			p.SetState(715)
			p.Match(JavaScriptParserColon)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(716)
			p.singleExpression(0)
		}

	case 2:
		localctx = NewComputedPropertyExpressionAssignmentContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(718)
			p.Match(JavaScriptParserOpenBracket)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(719)
			p.singleExpression(0)
		}
		{
			p.SetState(720)
			p.Match(JavaScriptParserCloseBracket)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(721)
			p.Match(JavaScriptParserColon)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(722)
			p.singleExpression(0)
		}

	case 3:
		localctx = NewFunctionPropertyContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		p.SetState(725)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 82, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(724)
				p.Match(JavaScriptParserAsync)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(728)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == JavaScriptParserMultiply {
			{
				p.SetState(727)
				p.Match(JavaScriptParserMultiply)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(730)
			p.PropertyName()
		}
		{
			p.SetState(731)
			p.Match(JavaScriptParserOpenParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(733)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&262688) != 0) || ((int64((_la-98)) & ^0x3f) == 0 && ((int64(1)<<(_la-98))&2114051) != 0) {
			{
				p.SetState(732)
				p.FormalParameterList()
			}

		}
		{
			p.SetState(735)
			p.Match(JavaScriptParserCloseParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(736)
			p.FunctionBody()
		}

	case 4:
		localctx = NewPropertyGetterContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(738)
			p.Getter()
		}
		{
			p.SetState(739)
			p.Match(JavaScriptParserOpenParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(740)
			p.Match(JavaScriptParserCloseParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(741)
			p.FunctionBody()
		}

	case 5:
		localctx = NewPropertySetterContext(p, localctx)
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(743)
			p.Setter()
		}
		{
			p.SetState(744)
			p.Match(JavaScriptParserOpenParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(745)
			p.FormalParameterArg()
		}
		{
			p.SetState(746)
			p.Match(JavaScriptParserCloseParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(747)
			p.FunctionBody()
		}

	case 6:
		localctx = NewPropertyShorthandContext(p, localctx)
		p.EnterOuterAlt(localctx, 6)
		p.SetState(750)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == JavaScriptParserEllipsis {
			{
				p.SetState(749)
				p.Match(JavaScriptParserEllipsis)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(752)
			p.singleExpression(0)
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPropertyNameContext is an interface to support dynamic dispatch.
type IPropertyNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	IdentifierName() IIdentifierNameContext
	StringLiteral() antlr.TerminalNode
	NumericLiteral() INumericLiteralContext
	OpenBracket() antlr.TerminalNode
	SingleExpression() ISingleExpressionContext
	CloseBracket() antlr.TerminalNode

	// IsPropertyNameContext differentiates from other interfaces.
	IsPropertyNameContext()
}

type PropertyNameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPropertyNameContext() *PropertyNameContext {
	var p = new(PropertyNameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaScriptParserRULE_propertyName
	return p
}

func InitEmptyPropertyNameContext(p *PropertyNameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaScriptParserRULE_propertyName
}

func (*PropertyNameContext) IsPropertyNameContext() {}

func NewPropertyNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PropertyNameContext {
	var p = new(PropertyNameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaScriptParserRULE_propertyName

	return p
}

func (s *PropertyNameContext) GetParser() antlr.Parser { return s.parser }

func (s *PropertyNameContext) IdentifierName() IIdentifierNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierNameContext)
}

func (s *PropertyNameContext) StringLiteral() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserStringLiteral, 0)
}

func (s *PropertyNameContext) NumericLiteral() INumericLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INumericLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INumericLiteralContext)
}

func (s *PropertyNameContext) OpenBracket() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserOpenBracket, 0)
}

func (s *PropertyNameContext) SingleExpression() ISingleExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISingleExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISingleExpressionContext)
}

func (s *PropertyNameContext) CloseBracket() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserCloseBracket, 0)
}

func (s *PropertyNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PropertyNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PropertyNameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JavaScriptParserVisitor:
		return t.VisitPropertyName(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *JavaScriptParser) PropertyName() (localctx IPropertyNameContext) {
	localctx = NewPropertyNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 128, JavaScriptParserRULE_propertyName)
	p.SetState(762)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case JavaScriptParserNullLiteral, JavaScriptParserBooleanLiteral, JavaScriptParserBreak, JavaScriptParserDo, JavaScriptParserInstanceof, JavaScriptParserTypeof, JavaScriptParserCase, JavaScriptParserElse, JavaScriptParserNew, JavaScriptParserVar, JavaScriptParserCatch, JavaScriptParserFinally, JavaScriptParserReturn, JavaScriptParserVoid, JavaScriptParserContinue, JavaScriptParserFor, JavaScriptParserSwitch, JavaScriptParserWhile, JavaScriptParserDebugger, JavaScriptParserFunction_, JavaScriptParserThis, JavaScriptParserWith, JavaScriptParserDefault, JavaScriptParserIf, JavaScriptParserThrow, JavaScriptParserDelete, JavaScriptParserIn, JavaScriptParserTry, JavaScriptParserAs, JavaScriptParserFrom, JavaScriptParserClass, JavaScriptParserEnum, JavaScriptParserExtends, JavaScriptParserSuper, JavaScriptParserConst, JavaScriptParserExport, JavaScriptParserImport, JavaScriptParserAsync, JavaScriptParserAwait, JavaScriptParserYield, JavaScriptParserImplements, JavaScriptParserStrictLet, JavaScriptParserNonStrictLet, JavaScriptParserPrivate, JavaScriptParserPublic, JavaScriptParserInterface, JavaScriptParserPackage, JavaScriptParserProtected, JavaScriptParserStatic, JavaScriptParserIdentifier:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(755)
			p.IdentifierName()
		}

	case JavaScriptParserStringLiteral:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(756)
			p.Match(JavaScriptParserStringLiteral)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case JavaScriptParserDecimalLiteral, JavaScriptParserHexIntegerLiteral, JavaScriptParserOctalIntegerLiteral, JavaScriptParserOctalIntegerLiteral2, JavaScriptParserBinaryIntegerLiteral:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(757)
			p.NumericLiteral()
		}

	case JavaScriptParserOpenBracket:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(758)
			p.Match(JavaScriptParserOpenBracket)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(759)
			p.singleExpression(0)
		}
		{
			p.SetState(760)
			p.Match(JavaScriptParserCloseBracket)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IArgumentsContext is an interface to support dynamic dispatch.
type IArgumentsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	OpenParen() antlr.TerminalNode
	CloseParen() antlr.TerminalNode
	AllArgument() []IArgumentContext
	Argument(i int) IArgumentContext
	AllComma() []antlr.TerminalNode
	Comma(i int) antlr.TerminalNode

	// IsArgumentsContext differentiates from other interfaces.
	IsArgumentsContext()
}

type ArgumentsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyArgumentsContext() *ArgumentsContext {
	var p = new(ArgumentsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaScriptParserRULE_arguments
	return p
}

func InitEmptyArgumentsContext(p *ArgumentsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaScriptParserRULE_arguments
}

func (*ArgumentsContext) IsArgumentsContext() {}

func NewArgumentsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ArgumentsContext {
	var p = new(ArgumentsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaScriptParserRULE_arguments

	return p
}

func (s *ArgumentsContext) GetParser() antlr.Parser { return s.parser }

func (s *ArgumentsContext) OpenParen() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserOpenParen, 0)
}

func (s *ArgumentsContext) CloseParen() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserCloseParen, 0)
}

func (s *ArgumentsContext) AllArgument() []IArgumentContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IArgumentContext); ok {
			len++
		}
	}

	tst := make([]IArgumentContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IArgumentContext); ok {
			tst[i] = t.(IArgumentContext)
			i++
		}
	}

	return tst
}

func (s *ArgumentsContext) Argument(i int) IArgumentContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArgumentContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArgumentContext)
}

func (s *ArgumentsContext) AllComma() []antlr.TerminalNode {
	return s.GetTokens(JavaScriptParserComma)
}

func (s *ArgumentsContext) Comma(i int) antlr.TerminalNode {
	return s.GetToken(JavaScriptParserComma, i)
}

func (s *ArgumentsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArgumentsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ArgumentsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JavaScriptParserVisitor:
		return t.VisitArguments(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *JavaScriptParser) Arguments() (localctx IArgumentsContext) {
	localctx = NewArgumentsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 130, JavaScriptParserRULE_arguments)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(764)
		p.Match(JavaScriptParserOpenParen)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(776)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-2305843009147370832) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&252549697070713087) != 0) {
		{
			p.SetState(765)
			p.Argument()
		}
		p.SetState(770)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 88, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(766)
					p.Match(JavaScriptParserComma)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(767)
					p.Argument()
				}

			}
			p.SetState(772)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 88, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}
		p.SetState(774)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == JavaScriptParserComma {
			{
				p.SetState(773)
				p.Match(JavaScriptParserComma)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	}
	{
		p.SetState(778)
		p.Match(JavaScriptParserCloseParen)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IArgumentContext is an interface to support dynamic dispatch.
type IArgumentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SingleExpression() ISingleExpressionContext
	Identifier() IIdentifierContext
	Ellipsis() antlr.TerminalNode

	// IsArgumentContext differentiates from other interfaces.
	IsArgumentContext()
}

type ArgumentContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyArgumentContext() *ArgumentContext {
	var p = new(ArgumentContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaScriptParserRULE_argument
	return p
}

func InitEmptyArgumentContext(p *ArgumentContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaScriptParserRULE_argument
}

func (*ArgumentContext) IsArgumentContext() {}

func NewArgumentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ArgumentContext {
	var p = new(ArgumentContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaScriptParserRULE_argument

	return p
}

func (s *ArgumentContext) GetParser() antlr.Parser { return s.parser }

func (s *ArgumentContext) SingleExpression() ISingleExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISingleExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISingleExpressionContext)
}

func (s *ArgumentContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ArgumentContext) Ellipsis() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserEllipsis, 0)
}

func (s *ArgumentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArgumentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ArgumentContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JavaScriptParserVisitor:
		return t.VisitArgument(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *JavaScriptParser) Argument() (localctx IArgumentContext) {
	localctx = NewArgumentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 132, JavaScriptParserRULE_argument)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(781)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == JavaScriptParserEllipsis {
		{
			p.SetState(780)
			p.Match(JavaScriptParserEllipsis)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	p.SetState(785)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 92, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(783)
			p.singleExpression(0)
		}

	case 2:
		{
			p.SetState(784)
			p.Identifier()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExpressionSequenceContext is an interface to support dynamic dispatch.
type IExpressionSequenceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllSingleExpression() []ISingleExpressionContext
	SingleExpression(i int) ISingleExpressionContext
	AllComma() []antlr.TerminalNode
	Comma(i int) antlr.TerminalNode

	// IsExpressionSequenceContext differentiates from other interfaces.
	IsExpressionSequenceContext()
}

type ExpressionSequenceContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpressionSequenceContext() *ExpressionSequenceContext {
	var p = new(ExpressionSequenceContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaScriptParserRULE_expressionSequence
	return p
}

func InitEmptyExpressionSequenceContext(p *ExpressionSequenceContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaScriptParserRULE_expressionSequence
}

func (*ExpressionSequenceContext) IsExpressionSequenceContext() {}

func NewExpressionSequenceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExpressionSequenceContext {
	var p = new(ExpressionSequenceContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaScriptParserRULE_expressionSequence

	return p
}

func (s *ExpressionSequenceContext) GetParser() antlr.Parser { return s.parser }

func (s *ExpressionSequenceContext) AllSingleExpression() []ISingleExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISingleExpressionContext); ok {
			len++
		}
	}

	tst := make([]ISingleExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISingleExpressionContext); ok {
			tst[i] = t.(ISingleExpressionContext)
			i++
		}
	}

	return tst
}

func (s *ExpressionSequenceContext) SingleExpression(i int) ISingleExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISingleExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISingleExpressionContext)
}

func (s *ExpressionSequenceContext) AllComma() []antlr.TerminalNode {
	return s.GetTokens(JavaScriptParserComma)
}

func (s *ExpressionSequenceContext) Comma(i int) antlr.TerminalNode {
	return s.GetToken(JavaScriptParserComma, i)
}

func (s *ExpressionSequenceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExpressionSequenceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExpressionSequenceContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JavaScriptParserVisitor:
		return t.VisitExpressionSequence(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *JavaScriptParser) ExpressionSequence() (localctx IExpressionSequenceContext) {
	localctx = NewExpressionSequenceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 134, JavaScriptParserRULE_expressionSequence)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(787)
		p.singleExpression(0)
	}
	p.SetState(792)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 93, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(788)
				p.Match(JavaScriptParserComma)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(789)
				p.singleExpression(0)
			}

		}
		p.SetState(794)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 93, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISingleExpressionContext is an interface to support dynamic dispatch.
type ISingleExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsSingleExpressionContext differentiates from other interfaces.
	IsSingleExpressionContext()
}

type SingleExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySingleExpressionContext() *SingleExpressionContext {
	var p = new(SingleExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaScriptParserRULE_singleExpression
	return p
}

func InitEmptySingleExpressionContext(p *SingleExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaScriptParserRULE_singleExpression
}

func (*SingleExpressionContext) IsSingleExpressionContext() {}

func NewSingleExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SingleExpressionContext {
	var p = new(SingleExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaScriptParserRULE_singleExpression

	return p
}

func (s *SingleExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *SingleExpressionContext) CopyAll(ctx *SingleExpressionContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *SingleExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SingleExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type TemplateStringExpressionContext struct {
	SingleExpressionContext
}

func NewTemplateStringExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TemplateStringExpressionContext {
	var p = new(TemplateStringExpressionContext)

	InitEmptySingleExpressionContext(&p.SingleExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*SingleExpressionContext))

	return p
}

func (s *TemplateStringExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TemplateStringExpressionContext) SingleExpression() ISingleExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISingleExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISingleExpressionContext)
}

func (s *TemplateStringExpressionContext) TemplateStringLiteral() ITemplateStringLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITemplateStringLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITemplateStringLiteralContext)
}

func (s *TemplateStringExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JavaScriptParserVisitor:
		return t.VisitTemplateStringExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

type TernaryExpressionContext struct {
	SingleExpressionContext
}

func NewTernaryExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TernaryExpressionContext {
	var p = new(TernaryExpressionContext)

	InitEmptySingleExpressionContext(&p.SingleExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*SingleExpressionContext))

	return p
}

func (s *TernaryExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TernaryExpressionContext) AllSingleExpression() []ISingleExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISingleExpressionContext); ok {
			len++
		}
	}

	tst := make([]ISingleExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISingleExpressionContext); ok {
			tst[i] = t.(ISingleExpressionContext)
			i++
		}
	}

	return tst
}

func (s *TernaryExpressionContext) SingleExpression(i int) ISingleExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISingleExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISingleExpressionContext)
}

func (s *TernaryExpressionContext) QuestionMark() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserQuestionMark, 0)
}

func (s *TernaryExpressionContext) Colon() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserColon, 0)
}

func (s *TernaryExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JavaScriptParserVisitor:
		return t.VisitTernaryExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

type LogicalAndExpressionContext struct {
	SingleExpressionContext
}

func NewLogicalAndExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LogicalAndExpressionContext {
	var p = new(LogicalAndExpressionContext)

	InitEmptySingleExpressionContext(&p.SingleExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*SingleExpressionContext))

	return p
}

func (s *LogicalAndExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LogicalAndExpressionContext) AllSingleExpression() []ISingleExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISingleExpressionContext); ok {
			len++
		}
	}

	tst := make([]ISingleExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISingleExpressionContext); ok {
			tst[i] = t.(ISingleExpressionContext)
			i++
		}
	}

	return tst
}

func (s *LogicalAndExpressionContext) SingleExpression(i int) ISingleExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISingleExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISingleExpressionContext)
}

func (s *LogicalAndExpressionContext) And() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserAnd, 0)
}

func (s *LogicalAndExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JavaScriptParserVisitor:
		return t.VisitLogicalAndExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

type PowerExpressionContext struct {
	SingleExpressionContext
}

func NewPowerExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *PowerExpressionContext {
	var p = new(PowerExpressionContext)

	InitEmptySingleExpressionContext(&p.SingleExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*SingleExpressionContext))

	return p
}

func (s *PowerExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PowerExpressionContext) AllSingleExpression() []ISingleExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISingleExpressionContext); ok {
			len++
		}
	}

	tst := make([]ISingleExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISingleExpressionContext); ok {
			tst[i] = t.(ISingleExpressionContext)
			i++
		}
	}

	return tst
}

func (s *PowerExpressionContext) SingleExpression(i int) ISingleExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISingleExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISingleExpressionContext)
}

func (s *PowerExpressionContext) Power() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserPower, 0)
}

func (s *PowerExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JavaScriptParserVisitor:
		return t.VisitPowerExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

type PreIncrementExpressionContext struct {
	SingleExpressionContext
}

func NewPreIncrementExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *PreIncrementExpressionContext {
	var p = new(PreIncrementExpressionContext)

	InitEmptySingleExpressionContext(&p.SingleExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*SingleExpressionContext))

	return p
}

func (s *PreIncrementExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PreIncrementExpressionContext) PlusPlus() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserPlusPlus, 0)
}

func (s *PreIncrementExpressionContext) SingleExpression() ISingleExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISingleExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISingleExpressionContext)
}

func (s *PreIncrementExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JavaScriptParserVisitor:
		return t.VisitPreIncrementExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

type ObjectLiteralExpressionContext struct {
	SingleExpressionContext
}

func NewObjectLiteralExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ObjectLiteralExpressionContext {
	var p = new(ObjectLiteralExpressionContext)

	InitEmptySingleExpressionContext(&p.SingleExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*SingleExpressionContext))

	return p
}

func (s *ObjectLiteralExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ObjectLiteralExpressionContext) ObjectLiteral() IObjectLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IObjectLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IObjectLiteralContext)
}

func (s *ObjectLiteralExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JavaScriptParserVisitor:
		return t.VisitObjectLiteralExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

type MetaExpressionContext struct {
	SingleExpressionContext
}

func NewMetaExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *MetaExpressionContext {
	var p = new(MetaExpressionContext)

	InitEmptySingleExpressionContext(&p.SingleExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*SingleExpressionContext))

	return p
}

func (s *MetaExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MetaExpressionContext) New() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserNew, 0)
}

func (s *MetaExpressionContext) Dot() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserDot, 0)
}

func (s *MetaExpressionContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *MetaExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JavaScriptParserVisitor:
		return t.VisitMetaExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

type InExpressionContext struct {
	SingleExpressionContext
}

func NewInExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *InExpressionContext {
	var p = new(InExpressionContext)

	InitEmptySingleExpressionContext(&p.SingleExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*SingleExpressionContext))

	return p
}

func (s *InExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InExpressionContext) AllSingleExpression() []ISingleExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISingleExpressionContext); ok {
			len++
		}
	}

	tst := make([]ISingleExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISingleExpressionContext); ok {
			tst[i] = t.(ISingleExpressionContext)
			i++
		}
	}

	return tst
}

func (s *InExpressionContext) SingleExpression(i int) ISingleExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISingleExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISingleExpressionContext)
}

func (s *InExpressionContext) In() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserIn, 0)
}

func (s *InExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JavaScriptParserVisitor:
		return t.VisitInExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

type LogicalOrExpressionContext struct {
	SingleExpressionContext
}

func NewLogicalOrExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LogicalOrExpressionContext {
	var p = new(LogicalOrExpressionContext)

	InitEmptySingleExpressionContext(&p.SingleExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*SingleExpressionContext))

	return p
}

func (s *LogicalOrExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LogicalOrExpressionContext) AllSingleExpression() []ISingleExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISingleExpressionContext); ok {
			len++
		}
	}

	tst := make([]ISingleExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISingleExpressionContext); ok {
			tst[i] = t.(ISingleExpressionContext)
			i++
		}
	}

	return tst
}

func (s *LogicalOrExpressionContext) SingleExpression(i int) ISingleExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISingleExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISingleExpressionContext)
}

func (s *LogicalOrExpressionContext) Or() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserOr, 0)
}

func (s *LogicalOrExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JavaScriptParserVisitor:
		return t.VisitLogicalOrExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

type OptionalChainExpressionContext struct {
	SingleExpressionContext
}

func NewOptionalChainExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *OptionalChainExpressionContext {
	var p = new(OptionalChainExpressionContext)

	InitEmptySingleExpressionContext(&p.SingleExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*SingleExpressionContext))

	return p
}

func (s *OptionalChainExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OptionalChainExpressionContext) AllSingleExpression() []ISingleExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISingleExpressionContext); ok {
			len++
		}
	}

	tst := make([]ISingleExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISingleExpressionContext); ok {
			tst[i] = t.(ISingleExpressionContext)
			i++
		}
	}

	return tst
}

func (s *OptionalChainExpressionContext) SingleExpression(i int) ISingleExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISingleExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISingleExpressionContext)
}

func (s *OptionalChainExpressionContext) QuestionMarkDot() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserQuestionMarkDot, 0)
}

func (s *OptionalChainExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JavaScriptParserVisitor:
		return t.VisitOptionalChainExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

type NotExpressionContext struct {
	SingleExpressionContext
}

func NewNotExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *NotExpressionContext {
	var p = new(NotExpressionContext)

	InitEmptySingleExpressionContext(&p.SingleExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*SingleExpressionContext))

	return p
}

func (s *NotExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NotExpressionContext) Not() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserNot, 0)
}

func (s *NotExpressionContext) SingleExpression() ISingleExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISingleExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISingleExpressionContext)
}

func (s *NotExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JavaScriptParserVisitor:
		return t.VisitNotExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

type PreDecreaseExpressionContext struct {
	SingleExpressionContext
}

func NewPreDecreaseExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *PreDecreaseExpressionContext {
	var p = new(PreDecreaseExpressionContext)

	InitEmptySingleExpressionContext(&p.SingleExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*SingleExpressionContext))

	return p
}

func (s *PreDecreaseExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PreDecreaseExpressionContext) MinusMinus() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserMinusMinus, 0)
}

func (s *PreDecreaseExpressionContext) SingleExpression() ISingleExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISingleExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISingleExpressionContext)
}

func (s *PreDecreaseExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JavaScriptParserVisitor:
		return t.VisitPreDecreaseExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

type ArgumentsExpressionContext struct {
	SingleExpressionContext
}

func NewArgumentsExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ArgumentsExpressionContext {
	var p = new(ArgumentsExpressionContext)

	InitEmptySingleExpressionContext(&p.SingleExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*SingleExpressionContext))

	return p
}

func (s *ArgumentsExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArgumentsExpressionContext) SingleExpression() ISingleExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISingleExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISingleExpressionContext)
}

func (s *ArgumentsExpressionContext) Arguments() IArgumentsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArgumentsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArgumentsContext)
}

func (s *ArgumentsExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JavaScriptParserVisitor:
		return t.VisitArgumentsExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

type AwaitExpressionContext struct {
	SingleExpressionContext
}

func NewAwaitExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AwaitExpressionContext {
	var p = new(AwaitExpressionContext)

	InitEmptySingleExpressionContext(&p.SingleExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*SingleExpressionContext))

	return p
}

func (s *AwaitExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AwaitExpressionContext) Await() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserAwait, 0)
}

func (s *AwaitExpressionContext) SingleExpression() ISingleExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISingleExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISingleExpressionContext)
}

func (s *AwaitExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JavaScriptParserVisitor:
		return t.VisitAwaitExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

type ThisExpressionContext struct {
	SingleExpressionContext
}

func NewThisExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ThisExpressionContext {
	var p = new(ThisExpressionContext)

	InitEmptySingleExpressionContext(&p.SingleExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*SingleExpressionContext))

	return p
}

func (s *ThisExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ThisExpressionContext) This() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserThis, 0)
}

func (s *ThisExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JavaScriptParserVisitor:
		return t.VisitThisExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

type FunctionExpressionContext struct {
	SingleExpressionContext
}

func NewFunctionExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *FunctionExpressionContext {
	var p = new(FunctionExpressionContext)

	InitEmptySingleExpressionContext(&p.SingleExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*SingleExpressionContext))

	return p
}

func (s *FunctionExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FunctionExpressionContext) AnonymousFunction() IAnonymousFunctionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAnonymousFunctionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAnonymousFunctionContext)
}

func (s *FunctionExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JavaScriptParserVisitor:
		return t.VisitFunctionExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

type UnaryMinusExpressionContext struct {
	SingleExpressionContext
}

func NewUnaryMinusExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *UnaryMinusExpressionContext {
	var p = new(UnaryMinusExpressionContext)

	InitEmptySingleExpressionContext(&p.SingleExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*SingleExpressionContext))

	return p
}

func (s *UnaryMinusExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnaryMinusExpressionContext) Minus() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserMinus, 0)
}

func (s *UnaryMinusExpressionContext) SingleExpression() ISingleExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISingleExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISingleExpressionContext)
}

func (s *UnaryMinusExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JavaScriptParserVisitor:
		return t.VisitUnaryMinusExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

type AssignmentExpressionContext struct {
	SingleExpressionContext
}

func NewAssignmentExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AssignmentExpressionContext {
	var p = new(AssignmentExpressionContext)

	InitEmptySingleExpressionContext(&p.SingleExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*SingleExpressionContext))

	return p
}

func (s *AssignmentExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AssignmentExpressionContext) AllSingleExpression() []ISingleExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISingleExpressionContext); ok {
			len++
		}
	}

	tst := make([]ISingleExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISingleExpressionContext); ok {
			tst[i] = t.(ISingleExpressionContext)
			i++
		}
	}

	return tst
}

func (s *AssignmentExpressionContext) SingleExpression(i int) ISingleExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISingleExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISingleExpressionContext)
}

func (s *AssignmentExpressionContext) Assign() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserAssign, 0)
}

func (s *AssignmentExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JavaScriptParserVisitor:
		return t.VisitAssignmentExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

type PostDecreaseExpressionContext struct {
	SingleExpressionContext
}

func NewPostDecreaseExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *PostDecreaseExpressionContext {
	var p = new(PostDecreaseExpressionContext)

	InitEmptySingleExpressionContext(&p.SingleExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*SingleExpressionContext))

	return p
}

func (s *PostDecreaseExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PostDecreaseExpressionContext) SingleExpression() ISingleExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISingleExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISingleExpressionContext)
}

func (s *PostDecreaseExpressionContext) MinusMinus() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserMinusMinus, 0)
}

func (s *PostDecreaseExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JavaScriptParserVisitor:
		return t.VisitPostDecreaseExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

type TypeofExpressionContext struct {
	SingleExpressionContext
}

func NewTypeofExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TypeofExpressionContext {
	var p = new(TypeofExpressionContext)

	InitEmptySingleExpressionContext(&p.SingleExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*SingleExpressionContext))

	return p
}

func (s *TypeofExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeofExpressionContext) Typeof() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserTypeof, 0)
}

func (s *TypeofExpressionContext) SingleExpression() ISingleExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISingleExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISingleExpressionContext)
}

func (s *TypeofExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JavaScriptParserVisitor:
		return t.VisitTypeofExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

type InstanceofExpressionContext struct {
	SingleExpressionContext
}

func NewInstanceofExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *InstanceofExpressionContext {
	var p = new(InstanceofExpressionContext)

	InitEmptySingleExpressionContext(&p.SingleExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*SingleExpressionContext))

	return p
}

func (s *InstanceofExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InstanceofExpressionContext) AllSingleExpression() []ISingleExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISingleExpressionContext); ok {
			len++
		}
	}

	tst := make([]ISingleExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISingleExpressionContext); ok {
			tst[i] = t.(ISingleExpressionContext)
			i++
		}
	}

	return tst
}

func (s *InstanceofExpressionContext) SingleExpression(i int) ISingleExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISingleExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISingleExpressionContext)
}

func (s *InstanceofExpressionContext) Instanceof() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserInstanceof, 0)
}

func (s *InstanceofExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JavaScriptParserVisitor:
		return t.VisitInstanceofExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

type UnaryPlusExpressionContext struct {
	SingleExpressionContext
}

func NewUnaryPlusExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *UnaryPlusExpressionContext {
	var p = new(UnaryPlusExpressionContext)

	InitEmptySingleExpressionContext(&p.SingleExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*SingleExpressionContext))

	return p
}

func (s *UnaryPlusExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnaryPlusExpressionContext) Plus() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserPlus, 0)
}

func (s *UnaryPlusExpressionContext) SingleExpression() ISingleExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISingleExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISingleExpressionContext)
}

func (s *UnaryPlusExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JavaScriptParserVisitor:
		return t.VisitUnaryPlusExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

type DeleteExpressionContext struct {
	SingleExpressionContext
}

func NewDeleteExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DeleteExpressionContext {
	var p = new(DeleteExpressionContext)

	InitEmptySingleExpressionContext(&p.SingleExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*SingleExpressionContext))

	return p
}

func (s *DeleteExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DeleteExpressionContext) Delete() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserDelete, 0)
}

func (s *DeleteExpressionContext) SingleExpression() ISingleExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISingleExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISingleExpressionContext)
}

func (s *DeleteExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JavaScriptParserVisitor:
		return t.VisitDeleteExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

type ImportExpressionContext struct {
	SingleExpressionContext
}

func NewImportExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ImportExpressionContext {
	var p = new(ImportExpressionContext)

	InitEmptySingleExpressionContext(&p.SingleExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*SingleExpressionContext))

	return p
}

func (s *ImportExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ImportExpressionContext) Import() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserImport, 0)
}

func (s *ImportExpressionContext) OpenParen() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserOpenParen, 0)
}

func (s *ImportExpressionContext) SingleExpression() ISingleExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISingleExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISingleExpressionContext)
}

func (s *ImportExpressionContext) CloseParen() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserCloseParen, 0)
}

func (s *ImportExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JavaScriptParserVisitor:
		return t.VisitImportExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

type EqualityExpressionContext struct {
	SingleExpressionContext
}

func NewEqualityExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *EqualityExpressionContext {
	var p = new(EqualityExpressionContext)

	InitEmptySingleExpressionContext(&p.SingleExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*SingleExpressionContext))

	return p
}

func (s *EqualityExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EqualityExpressionContext) AllSingleExpression() []ISingleExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISingleExpressionContext); ok {
			len++
		}
	}

	tst := make([]ISingleExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISingleExpressionContext); ok {
			tst[i] = t.(ISingleExpressionContext)
			i++
		}
	}

	return tst
}

func (s *EqualityExpressionContext) SingleExpression(i int) ISingleExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISingleExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISingleExpressionContext)
}

func (s *EqualityExpressionContext) Equals_() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserEquals_, 0)
}

func (s *EqualityExpressionContext) NotEquals() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserNotEquals, 0)
}

func (s *EqualityExpressionContext) IdentityEquals() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserIdentityEquals, 0)
}

func (s *EqualityExpressionContext) IdentityNotEquals() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserIdentityNotEquals, 0)
}

func (s *EqualityExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JavaScriptParserVisitor:
		return t.VisitEqualityExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

type BitXOrExpressionContext struct {
	SingleExpressionContext
}

func NewBitXOrExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *BitXOrExpressionContext {
	var p = new(BitXOrExpressionContext)

	InitEmptySingleExpressionContext(&p.SingleExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*SingleExpressionContext))

	return p
}

func (s *BitXOrExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BitXOrExpressionContext) AllSingleExpression() []ISingleExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISingleExpressionContext); ok {
			len++
		}
	}

	tst := make([]ISingleExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISingleExpressionContext); ok {
			tst[i] = t.(ISingleExpressionContext)
			i++
		}
	}

	return tst
}

func (s *BitXOrExpressionContext) SingleExpression(i int) ISingleExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISingleExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISingleExpressionContext)
}

func (s *BitXOrExpressionContext) BitXOr() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserBitXOr, 0)
}

func (s *BitXOrExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JavaScriptParserVisitor:
		return t.VisitBitXOrExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

type SuperExpressionContext struct {
	SingleExpressionContext
}

func NewSuperExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SuperExpressionContext {
	var p = new(SuperExpressionContext)

	InitEmptySingleExpressionContext(&p.SingleExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*SingleExpressionContext))

	return p
}

func (s *SuperExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SuperExpressionContext) Super() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserSuper, 0)
}

func (s *SuperExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JavaScriptParserVisitor:
		return t.VisitSuperExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

type MultiplicativeExpressionContext struct {
	SingleExpressionContext
}

func NewMultiplicativeExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *MultiplicativeExpressionContext {
	var p = new(MultiplicativeExpressionContext)

	InitEmptySingleExpressionContext(&p.SingleExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*SingleExpressionContext))

	return p
}

func (s *MultiplicativeExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MultiplicativeExpressionContext) AllSingleExpression() []ISingleExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISingleExpressionContext); ok {
			len++
		}
	}

	tst := make([]ISingleExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISingleExpressionContext); ok {
			tst[i] = t.(ISingleExpressionContext)
			i++
		}
	}

	return tst
}

func (s *MultiplicativeExpressionContext) SingleExpression(i int) ISingleExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISingleExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISingleExpressionContext)
}

func (s *MultiplicativeExpressionContext) Multiply() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserMultiply, 0)
}

func (s *MultiplicativeExpressionContext) Divide() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserDivide, 0)
}

func (s *MultiplicativeExpressionContext) Modulus() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserModulus, 0)
}

func (s *MultiplicativeExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JavaScriptParserVisitor:
		return t.VisitMultiplicativeExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

type BitShiftExpressionContext struct {
	SingleExpressionContext
}

func NewBitShiftExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *BitShiftExpressionContext {
	var p = new(BitShiftExpressionContext)

	InitEmptySingleExpressionContext(&p.SingleExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*SingleExpressionContext))

	return p
}

func (s *BitShiftExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BitShiftExpressionContext) AllSingleExpression() []ISingleExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISingleExpressionContext); ok {
			len++
		}
	}

	tst := make([]ISingleExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISingleExpressionContext); ok {
			tst[i] = t.(ISingleExpressionContext)
			i++
		}
	}

	return tst
}

func (s *BitShiftExpressionContext) SingleExpression(i int) ISingleExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISingleExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISingleExpressionContext)
}

func (s *BitShiftExpressionContext) LeftShiftArithmetic() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserLeftShiftArithmetic, 0)
}

func (s *BitShiftExpressionContext) RightShiftArithmetic() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserRightShiftArithmetic, 0)
}

func (s *BitShiftExpressionContext) RightShiftLogical() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserRightShiftLogical, 0)
}

func (s *BitShiftExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JavaScriptParserVisitor:
		return t.VisitBitShiftExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

type ParenthesizedExpressionContext struct {
	SingleExpressionContext
}

func NewParenthesizedExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ParenthesizedExpressionContext {
	var p = new(ParenthesizedExpressionContext)

	InitEmptySingleExpressionContext(&p.SingleExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*SingleExpressionContext))

	return p
}

func (s *ParenthesizedExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ParenthesizedExpressionContext) OpenParen() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserOpenParen, 0)
}

func (s *ParenthesizedExpressionContext) ExpressionSequence() IExpressionSequenceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionSequenceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionSequenceContext)
}

func (s *ParenthesizedExpressionContext) CloseParen() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserCloseParen, 0)
}

func (s *ParenthesizedExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JavaScriptParserVisitor:
		return t.VisitParenthesizedExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

type AdditiveExpressionContext struct {
	SingleExpressionContext
}

func NewAdditiveExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AdditiveExpressionContext {
	var p = new(AdditiveExpressionContext)

	InitEmptySingleExpressionContext(&p.SingleExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*SingleExpressionContext))

	return p
}

func (s *AdditiveExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AdditiveExpressionContext) AllSingleExpression() []ISingleExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISingleExpressionContext); ok {
			len++
		}
	}

	tst := make([]ISingleExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISingleExpressionContext); ok {
			tst[i] = t.(ISingleExpressionContext)
			i++
		}
	}

	return tst
}

func (s *AdditiveExpressionContext) SingleExpression(i int) ISingleExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISingleExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISingleExpressionContext)
}

func (s *AdditiveExpressionContext) Plus() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserPlus, 0)
}

func (s *AdditiveExpressionContext) Minus() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserMinus, 0)
}

func (s *AdditiveExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JavaScriptParserVisitor:
		return t.VisitAdditiveExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

type RelationalExpressionContext struct {
	SingleExpressionContext
}

func NewRelationalExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *RelationalExpressionContext {
	var p = new(RelationalExpressionContext)

	InitEmptySingleExpressionContext(&p.SingleExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*SingleExpressionContext))

	return p
}

func (s *RelationalExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RelationalExpressionContext) AllSingleExpression() []ISingleExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISingleExpressionContext); ok {
			len++
		}
	}

	tst := make([]ISingleExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISingleExpressionContext); ok {
			tst[i] = t.(ISingleExpressionContext)
			i++
		}
	}

	return tst
}

func (s *RelationalExpressionContext) SingleExpression(i int) ISingleExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISingleExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISingleExpressionContext)
}

func (s *RelationalExpressionContext) LessThan() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserLessThan, 0)
}

func (s *RelationalExpressionContext) MoreThan() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserMoreThan, 0)
}

func (s *RelationalExpressionContext) LessThanEquals() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserLessThanEquals, 0)
}

func (s *RelationalExpressionContext) GreaterThanEquals() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserGreaterThanEquals, 0)
}

func (s *RelationalExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JavaScriptParserVisitor:
		return t.VisitRelationalExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

type PostIncrementExpressionContext struct {
	SingleExpressionContext
}

func NewPostIncrementExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *PostIncrementExpressionContext {
	var p = new(PostIncrementExpressionContext)

	InitEmptySingleExpressionContext(&p.SingleExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*SingleExpressionContext))

	return p
}

func (s *PostIncrementExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PostIncrementExpressionContext) SingleExpression() ISingleExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISingleExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISingleExpressionContext)
}

func (s *PostIncrementExpressionContext) PlusPlus() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserPlusPlus, 0)
}

func (s *PostIncrementExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JavaScriptParserVisitor:
		return t.VisitPostIncrementExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

type YieldExpressionContext struct {
	SingleExpressionContext
}

func NewYieldExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *YieldExpressionContext {
	var p = new(YieldExpressionContext)

	InitEmptySingleExpressionContext(&p.SingleExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*SingleExpressionContext))

	return p
}

func (s *YieldExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *YieldExpressionContext) YieldStatement() IYieldStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IYieldStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IYieldStatementContext)
}

func (s *YieldExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JavaScriptParserVisitor:
		return t.VisitYieldExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

type BitNotExpressionContext struct {
	SingleExpressionContext
}

func NewBitNotExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *BitNotExpressionContext {
	var p = new(BitNotExpressionContext)

	InitEmptySingleExpressionContext(&p.SingleExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*SingleExpressionContext))

	return p
}

func (s *BitNotExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BitNotExpressionContext) BitNot() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserBitNot, 0)
}

func (s *BitNotExpressionContext) SingleExpression() ISingleExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISingleExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISingleExpressionContext)
}

func (s *BitNotExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JavaScriptParserVisitor:
		return t.VisitBitNotExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

type NewExpressionContext struct {
	SingleExpressionContext
}

func NewNewExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *NewExpressionContext {
	var p = new(NewExpressionContext)

	InitEmptySingleExpressionContext(&p.SingleExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*SingleExpressionContext))

	return p
}

func (s *NewExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NewExpressionContext) New() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserNew, 0)
}

func (s *NewExpressionContext) SingleExpression() ISingleExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISingleExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISingleExpressionContext)
}

func (s *NewExpressionContext) Arguments() IArgumentsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArgumentsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArgumentsContext)
}

func (s *NewExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JavaScriptParserVisitor:
		return t.VisitNewExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

type LiteralExpressionContext struct {
	SingleExpressionContext
}

func NewLiteralExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LiteralExpressionContext {
	var p = new(LiteralExpressionContext)

	InitEmptySingleExpressionContext(&p.SingleExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*SingleExpressionContext))

	return p
}

func (s *LiteralExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LiteralExpressionContext) Literal() ILiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILiteralContext)
}

func (s *LiteralExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JavaScriptParserVisitor:
		return t.VisitLiteralExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

type ArrayLiteralExpressionContext struct {
	SingleExpressionContext
}

func NewArrayLiteralExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ArrayLiteralExpressionContext {
	var p = new(ArrayLiteralExpressionContext)

	InitEmptySingleExpressionContext(&p.SingleExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*SingleExpressionContext))

	return p
}

func (s *ArrayLiteralExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArrayLiteralExpressionContext) ArrayLiteral() IArrayLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArrayLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArrayLiteralContext)
}

func (s *ArrayLiteralExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JavaScriptParserVisitor:
		return t.VisitArrayLiteralExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

type MemberDotExpressionContext struct {
	SingleExpressionContext
}

func NewMemberDotExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *MemberDotExpressionContext {
	var p = new(MemberDotExpressionContext)

	InitEmptySingleExpressionContext(&p.SingleExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*SingleExpressionContext))

	return p
}

func (s *MemberDotExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MemberDotExpressionContext) SingleExpression() ISingleExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISingleExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISingleExpressionContext)
}

func (s *MemberDotExpressionContext) Dot() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserDot, 0)
}

func (s *MemberDotExpressionContext) IdentifierName() IIdentifierNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierNameContext)
}

func (s *MemberDotExpressionContext) QuestionMark() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserQuestionMark, 0)
}

func (s *MemberDotExpressionContext) Hashtag() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserHashtag, 0)
}

func (s *MemberDotExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JavaScriptParserVisitor:
		return t.VisitMemberDotExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

type ClassExpressionContext struct {
	SingleExpressionContext
}

func NewClassExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ClassExpressionContext {
	var p = new(ClassExpressionContext)

	InitEmptySingleExpressionContext(&p.SingleExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*SingleExpressionContext))

	return p
}

func (s *ClassExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ClassExpressionContext) Class() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserClass, 0)
}

func (s *ClassExpressionContext) ClassTail() IClassTailContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClassTailContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClassTailContext)
}

func (s *ClassExpressionContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ClassExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JavaScriptParserVisitor:
		return t.VisitClassExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

type MemberIndexExpressionContext struct {
	SingleExpressionContext
}

func NewMemberIndexExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *MemberIndexExpressionContext {
	var p = new(MemberIndexExpressionContext)

	InitEmptySingleExpressionContext(&p.SingleExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*SingleExpressionContext))

	return p
}

func (s *MemberIndexExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MemberIndexExpressionContext) AllSingleExpression() []ISingleExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISingleExpressionContext); ok {
			len++
		}
	}

	tst := make([]ISingleExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISingleExpressionContext); ok {
			tst[i] = t.(ISingleExpressionContext)
			i++
		}
	}

	return tst
}

func (s *MemberIndexExpressionContext) SingleExpression(i int) ISingleExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISingleExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISingleExpressionContext)
}

func (s *MemberIndexExpressionContext) OpenBracket() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserOpenBracket, 0)
}

func (s *MemberIndexExpressionContext) CloseBracket() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserCloseBracket, 0)
}

func (s *MemberIndexExpressionContext) QuestionMarkDot() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserQuestionMarkDot, 0)
}

func (s *MemberIndexExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JavaScriptParserVisitor:
		return t.VisitMemberIndexExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

type IdentifierExpressionContext struct {
	SingleExpressionContext
}

func NewIdentifierExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *IdentifierExpressionContext {
	var p = new(IdentifierExpressionContext)

	InitEmptySingleExpressionContext(&p.SingleExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*SingleExpressionContext))

	return p
}

func (s *IdentifierExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IdentifierExpressionContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *IdentifierExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JavaScriptParserVisitor:
		return t.VisitIdentifierExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

type BitAndExpressionContext struct {
	SingleExpressionContext
}

func NewBitAndExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *BitAndExpressionContext {
	var p = new(BitAndExpressionContext)

	InitEmptySingleExpressionContext(&p.SingleExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*SingleExpressionContext))

	return p
}

func (s *BitAndExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BitAndExpressionContext) AllSingleExpression() []ISingleExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISingleExpressionContext); ok {
			len++
		}
	}

	tst := make([]ISingleExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISingleExpressionContext); ok {
			tst[i] = t.(ISingleExpressionContext)
			i++
		}
	}

	return tst
}

func (s *BitAndExpressionContext) SingleExpression(i int) ISingleExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISingleExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISingleExpressionContext)
}

func (s *BitAndExpressionContext) BitAnd() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserBitAnd, 0)
}

func (s *BitAndExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JavaScriptParserVisitor:
		return t.VisitBitAndExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

type BitOrExpressionContext struct {
	SingleExpressionContext
}

func NewBitOrExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *BitOrExpressionContext {
	var p = new(BitOrExpressionContext)

	InitEmptySingleExpressionContext(&p.SingleExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*SingleExpressionContext))

	return p
}

func (s *BitOrExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BitOrExpressionContext) AllSingleExpression() []ISingleExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISingleExpressionContext); ok {
			len++
		}
	}

	tst := make([]ISingleExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISingleExpressionContext); ok {
			tst[i] = t.(ISingleExpressionContext)
			i++
		}
	}

	return tst
}

func (s *BitOrExpressionContext) SingleExpression(i int) ISingleExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISingleExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISingleExpressionContext)
}

func (s *BitOrExpressionContext) BitOr() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserBitOr, 0)
}

func (s *BitOrExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JavaScriptParserVisitor:
		return t.VisitBitOrExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

type AssignmentOperatorExpressionContext struct {
	SingleExpressionContext
}

func NewAssignmentOperatorExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AssignmentOperatorExpressionContext {
	var p = new(AssignmentOperatorExpressionContext)

	InitEmptySingleExpressionContext(&p.SingleExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*SingleExpressionContext))

	return p
}

func (s *AssignmentOperatorExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AssignmentOperatorExpressionContext) AllSingleExpression() []ISingleExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISingleExpressionContext); ok {
			len++
		}
	}

	tst := make([]ISingleExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISingleExpressionContext); ok {
			tst[i] = t.(ISingleExpressionContext)
			i++
		}
	}

	return tst
}

func (s *AssignmentOperatorExpressionContext) SingleExpression(i int) ISingleExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISingleExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISingleExpressionContext)
}

func (s *AssignmentOperatorExpressionContext) AssignmentOperator() IAssignmentOperatorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAssignmentOperatorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAssignmentOperatorContext)
}

func (s *AssignmentOperatorExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JavaScriptParserVisitor:
		return t.VisitAssignmentOperatorExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

type VoidExpressionContext struct {
	SingleExpressionContext
}

func NewVoidExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *VoidExpressionContext {
	var p = new(VoidExpressionContext)

	InitEmptySingleExpressionContext(&p.SingleExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*SingleExpressionContext))

	return p
}

func (s *VoidExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VoidExpressionContext) Void() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserVoid, 0)
}

func (s *VoidExpressionContext) SingleExpression() ISingleExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISingleExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISingleExpressionContext)
}

func (s *VoidExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JavaScriptParserVisitor:
		return t.VisitVoidExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

type CoalesceExpressionContext struct {
	SingleExpressionContext
}

func NewCoalesceExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CoalesceExpressionContext {
	var p = new(CoalesceExpressionContext)

	InitEmptySingleExpressionContext(&p.SingleExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*SingleExpressionContext))

	return p
}

func (s *CoalesceExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CoalesceExpressionContext) AllSingleExpression() []ISingleExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISingleExpressionContext); ok {
			len++
		}
	}

	tst := make([]ISingleExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISingleExpressionContext); ok {
			tst[i] = t.(ISingleExpressionContext)
			i++
		}
	}

	return tst
}

func (s *CoalesceExpressionContext) SingleExpression(i int) ISingleExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISingleExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISingleExpressionContext)
}

func (s *CoalesceExpressionContext) NullCoalesce() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserNullCoalesce, 0)
}

func (s *CoalesceExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JavaScriptParserVisitor:
		return t.VisitCoalesceExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *JavaScriptParser) SingleExpression() (localctx ISingleExpressionContext) {
	return p.singleExpression(0)
}

func (p *JavaScriptParser) singleExpression(_p int) (localctx ISingleExpressionContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()

	_parentState := p.GetState()
	localctx = NewSingleExpressionContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx ISingleExpressionContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 136
	p.EnterRecursionRule(localctx, 136, JavaScriptParserRULE_singleExpression, _p)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(847)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 95, p.GetParserRuleContext()) {
	case 1:
		localctx = NewFunctionExpressionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx

		{
			p.SetState(796)
			p.AnonymousFunction()
		}

	case 2:
		localctx = NewClassExpressionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(797)
			p.Match(JavaScriptParserClass)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(799)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if (int64((_la-98)) & ^0x3f) == 0 && ((int64(1)<<(_la-98))&2114051) != 0 {
			{
				p.SetState(798)
				p.Identifier()
			}

		}
		{
			p.SetState(801)
			p.ClassTail()
		}

	case 3:
		localctx = NewNewExpressionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(802)
			p.Match(JavaScriptParserNew)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(803)
			p.singleExpression(0)
		}
		{
			p.SetState(804)
			p.Arguments()
		}

	case 4:
		localctx = NewNewExpressionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(806)
			p.Match(JavaScriptParserNew)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(807)
			p.singleExpression(42)
		}

	case 5:
		localctx = NewMetaExpressionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(808)
			p.Match(JavaScriptParserNew)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(809)
			p.Match(JavaScriptParserDot)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(810)
			p.Identifier()
		}

	case 6:
		localctx = NewDeleteExpressionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(811)
			p.Match(JavaScriptParserDelete)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(812)
			p.singleExpression(37)
		}

	case 7:
		localctx = NewVoidExpressionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(813)
			p.Match(JavaScriptParserVoid)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(814)
			p.singleExpression(36)
		}

	case 8:
		localctx = NewTypeofExpressionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(815)
			p.Match(JavaScriptParserTypeof)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(816)
			p.singleExpression(35)
		}

	case 9:
		localctx = NewPreIncrementExpressionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(817)
			p.Match(JavaScriptParserPlusPlus)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(818)
			p.singleExpression(34)
		}

	case 10:
		localctx = NewPreDecreaseExpressionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(819)
			p.Match(JavaScriptParserMinusMinus)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(820)
			p.singleExpression(33)
		}

	case 11:
		localctx = NewUnaryPlusExpressionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(821)
			p.Match(JavaScriptParserPlus)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(822)
			p.singleExpression(32)
		}

	case 12:
		localctx = NewUnaryMinusExpressionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(823)
			p.Match(JavaScriptParserMinus)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(824)
			p.singleExpression(31)
		}

	case 13:
		localctx = NewBitNotExpressionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(825)
			p.Match(JavaScriptParserBitNot)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(826)
			p.singleExpression(30)
		}

	case 14:
		localctx = NewNotExpressionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(827)
			p.Match(JavaScriptParserNot)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(828)
			p.singleExpression(29)
		}

	case 15:
		localctx = NewAwaitExpressionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(829)
			p.Match(JavaScriptParserAwait)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(830)
			p.singleExpression(28)
		}

	case 16:
		localctx = NewImportExpressionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(831)
			p.Match(JavaScriptParserImport)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(832)
			p.Match(JavaScriptParserOpenParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(833)
			p.singleExpression(0)
		}
		{
			p.SetState(834)
			p.Match(JavaScriptParserCloseParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 17:
		localctx = NewYieldExpressionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(836)
			p.YieldStatement()
		}

	case 18:
		localctx = NewThisExpressionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(837)
			p.Match(JavaScriptParserThis)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 19:
		localctx = NewIdentifierExpressionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(838)
			p.Identifier()
		}

	case 20:
		localctx = NewSuperExpressionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(839)
			p.Match(JavaScriptParserSuper)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 21:
		localctx = NewLiteralExpressionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(840)
			p.Literal()
		}

	case 22:
		localctx = NewArrayLiteralExpressionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(841)
			p.ArrayLiteral()
		}

	case 23:
		localctx = NewObjectLiteralExpressionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(842)
			p.ObjectLiteral()
		}

	case 24:
		localctx = NewParenthesizedExpressionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(843)
			p.Match(JavaScriptParserOpenParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(844)
			p.ExpressionSequence()
		}
		{
			p.SetState(845)
			p.Match(JavaScriptParserCloseParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}
	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(936)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 100, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			p.SetState(934)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 99, p.GetParserRuleContext()) {
			case 1:
				localctx = NewOptionalChainExpressionContext(p, NewSingleExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, JavaScriptParserRULE_singleExpression)
				p.SetState(849)

				if !(p.Precpred(p.GetParserRuleContext(), 46)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 46)", ""))
					goto errorExit
				}
				{
					p.SetState(850)
					p.Match(JavaScriptParserQuestionMarkDot)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(851)
					p.singleExpression(47)
				}

			case 2:
				localctx = NewPowerExpressionContext(p, NewSingleExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, JavaScriptParserRULE_singleExpression)
				p.SetState(852)

				if !(p.Precpred(p.GetParserRuleContext(), 27)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 27)", ""))
					goto errorExit
				}
				{
					p.SetState(853)
					p.Match(JavaScriptParserPower)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(854)
					p.singleExpression(27)
				}

			case 3:
				localctx = NewMultiplicativeExpressionContext(p, NewSingleExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, JavaScriptParserRULE_singleExpression)
				p.SetState(855)

				if !(p.Precpred(p.GetParserRuleContext(), 26)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 26)", ""))
					goto errorExit
				}
				{
					p.SetState(856)
					_la = p.GetTokenStream().LA(1)

					if !((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&469762048) != 0) {
						p.GetErrorHandler().RecoverInline(p)
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				{
					p.SetState(857)
					p.singleExpression(27)
				}

			case 4:
				localctx = NewAdditiveExpressionContext(p, NewSingleExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, JavaScriptParserRULE_singleExpression)
				p.SetState(858)

				if !(p.Precpred(p.GetParserRuleContext(), 25)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 25)", ""))
					goto errorExit
				}
				{
					p.SetState(859)
					_la = p.GetTokenStream().LA(1)

					if !(_la == JavaScriptParserPlus || _la == JavaScriptParserMinus) {
						p.GetErrorHandler().RecoverInline(p)
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				{
					p.SetState(860)
					p.singleExpression(26)
				}

			case 5:
				localctx = NewCoalesceExpressionContext(p, NewSingleExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, JavaScriptParserRULE_singleExpression)
				p.SetState(861)

				if !(p.Precpred(p.GetParserRuleContext(), 24)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 24)", ""))
					goto errorExit
				}
				{
					p.SetState(862)
					p.Match(JavaScriptParserNullCoalesce)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(863)
					p.singleExpression(25)
				}

			case 6:
				localctx = NewBitShiftExpressionContext(p, NewSingleExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, JavaScriptParserRULE_singleExpression)
				p.SetState(864)

				if !(p.Precpred(p.GetParserRuleContext(), 23)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 23)", ""))
					goto errorExit
				}
				{
					p.SetState(865)
					_la = p.GetTokenStream().LA(1)

					if !((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&30064771072) != 0) {
						p.GetErrorHandler().RecoverInline(p)
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				{
					p.SetState(866)
					p.singleExpression(24)
				}

			case 7:
				localctx = NewRelationalExpressionContext(p, NewSingleExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, JavaScriptParserRULE_singleExpression)
				p.SetState(867)

				if !(p.Precpred(p.GetParserRuleContext(), 22)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 22)", ""))
					goto errorExit
				}
				{
					p.SetState(868)
					_la = p.GetTokenStream().LA(1)

					if !((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&515396075520) != 0) {
						p.GetErrorHandler().RecoverInline(p)
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				{
					p.SetState(869)
					p.singleExpression(23)
				}

			case 8:
				localctx = NewInstanceofExpressionContext(p, NewSingleExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, JavaScriptParserRULE_singleExpression)
				p.SetState(870)

				if !(p.Precpred(p.GetParserRuleContext(), 21)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 21)", ""))
					goto errorExit
				}
				{
					p.SetState(871)
					p.Match(JavaScriptParserInstanceof)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(872)
					p.singleExpression(22)
				}

			case 9:
				localctx = NewInExpressionContext(p, NewSingleExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, JavaScriptParserRULE_singleExpression)
				p.SetState(873)

				if !(p.Precpred(p.GetParserRuleContext(), 20)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 20)", ""))
					goto errorExit
				}
				{
					p.SetState(874)
					p.Match(JavaScriptParserIn)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(875)
					p.singleExpression(21)
				}

			case 10:
				localctx = NewEqualityExpressionContext(p, NewSingleExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, JavaScriptParserRULE_singleExpression)
				p.SetState(876)

				if !(p.Precpred(p.GetParserRuleContext(), 19)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 19)", ""))
					goto errorExit
				}
				{
					p.SetState(877)
					_la = p.GetTokenStream().LA(1)

					if !((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&8246337208320) != 0) {
						p.GetErrorHandler().RecoverInline(p)
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				{
					p.SetState(878)
					p.singleExpression(20)
				}

			case 11:
				localctx = NewBitAndExpressionContext(p, NewSingleExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, JavaScriptParserRULE_singleExpression)
				p.SetState(879)

				if !(p.Precpred(p.GetParserRuleContext(), 18)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 18)", ""))
					goto errorExit
				}
				{
					p.SetState(880)
					p.Match(JavaScriptParserBitAnd)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(881)
					p.singleExpression(19)
				}

			case 12:
				localctx = NewBitXOrExpressionContext(p, NewSingleExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, JavaScriptParserRULE_singleExpression)
				p.SetState(882)

				if !(p.Precpred(p.GetParserRuleContext(), 17)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 17)", ""))
					goto errorExit
				}
				{
					p.SetState(883)
					p.Match(JavaScriptParserBitXOr)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(884)
					p.singleExpression(18)
				}

			case 13:
				localctx = NewBitOrExpressionContext(p, NewSingleExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, JavaScriptParserRULE_singleExpression)
				p.SetState(885)

				if !(p.Precpred(p.GetParserRuleContext(), 16)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 16)", ""))
					goto errorExit
				}
				{
					p.SetState(886)
					p.Match(JavaScriptParserBitOr)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(887)
					p.singleExpression(17)
				}

			case 14:
				localctx = NewLogicalAndExpressionContext(p, NewSingleExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, JavaScriptParserRULE_singleExpression)
				p.SetState(888)

				if !(p.Precpred(p.GetParserRuleContext(), 15)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 15)", ""))
					goto errorExit
				}
				{
					p.SetState(889)
					p.Match(JavaScriptParserAnd)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(890)
					p.singleExpression(16)
				}

			case 15:
				localctx = NewLogicalOrExpressionContext(p, NewSingleExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, JavaScriptParserRULE_singleExpression)
				p.SetState(891)

				if !(p.Precpred(p.GetParserRuleContext(), 14)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 14)", ""))
					goto errorExit
				}
				{
					p.SetState(892)
					p.Match(JavaScriptParserOr)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(893)
					p.singleExpression(15)
				}

			case 16:
				localctx = NewTernaryExpressionContext(p, NewSingleExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, JavaScriptParserRULE_singleExpression)
				p.SetState(894)

				if !(p.Precpred(p.GetParserRuleContext(), 13)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 13)", ""))
					goto errorExit
				}
				{
					p.SetState(895)
					p.Match(JavaScriptParserQuestionMark)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(896)
					p.singleExpression(0)
				}
				{
					p.SetState(897)
					p.Match(JavaScriptParserColon)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(898)
					p.singleExpression(14)
				}

			case 17:
				localctx = NewAssignmentExpressionContext(p, NewSingleExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, JavaScriptParserRULE_singleExpression)
				p.SetState(900)

				if !(p.Precpred(p.GetParserRuleContext(), 12)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 12)", ""))
					goto errorExit
				}
				{
					p.SetState(901)
					p.Match(JavaScriptParserAssign)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(902)
					p.singleExpression(12)
				}

			case 18:
				localctx = NewAssignmentOperatorExpressionContext(p, NewSingleExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, JavaScriptParserRULE_singleExpression)
				p.SetState(903)

				if !(p.Precpred(p.GetParserRuleContext(), 11)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 11)", ""))
					goto errorExit
				}
				{
					p.SetState(904)
					p.AssignmentOperator()
				}
				{
					p.SetState(905)
					p.singleExpression(11)
				}

			case 19:
				localctx = NewMemberIndexExpressionContext(p, NewSingleExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, JavaScriptParserRULE_singleExpression)
				p.SetState(907)

				if !(p.Precpred(p.GetParserRuleContext(), 45)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 45)", ""))
					goto errorExit
				}
				p.SetState(909)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)

				if _la == JavaScriptParserQuestionMarkDot {
					{
						p.SetState(908)
						p.Match(JavaScriptParserQuestionMarkDot)
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}

				}
				{
					p.SetState(911)
					p.Match(JavaScriptParserOpenBracket)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(912)
					p.singleExpression(0)
				}
				{
					p.SetState(913)
					p.Match(JavaScriptParserCloseBracket)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			case 20:
				localctx = NewMemberDotExpressionContext(p, NewSingleExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, JavaScriptParserRULE_singleExpression)
				p.SetState(915)

				if !(p.Precpred(p.GetParserRuleContext(), 44)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 44)", ""))
					goto errorExit
				}
				p.SetState(917)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)

				if _la == JavaScriptParserQuestionMark {
					{
						p.SetState(916)
						p.Match(JavaScriptParserQuestionMark)
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}

				}
				{
					p.SetState(919)
					p.Match(JavaScriptParserDot)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				p.SetState(921)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)

				if _la == JavaScriptParserHashtag {
					{
						p.SetState(920)
						p.Match(JavaScriptParserHashtag)
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}

				}
				{
					p.SetState(923)
					p.IdentifierName()
				}

			case 21:
				localctx = NewArgumentsExpressionContext(p, NewSingleExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, JavaScriptParserRULE_singleExpression)
				p.SetState(924)

				if !(p.Precpred(p.GetParserRuleContext(), 41)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 41)", ""))
					goto errorExit
				}
				{
					p.SetState(925)
					p.Arguments()
				}

			case 22:
				localctx = NewPostIncrementExpressionContext(p, NewSingleExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, JavaScriptParserRULE_singleExpression)
				p.SetState(926)

				if !(p.Precpred(p.GetParserRuleContext(), 39)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 39)", ""))
					goto errorExit
				}
				p.SetState(927)

				if !(p.notLineTerminator()) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.notLineTerminator()", ""))
					goto errorExit
				}
				{
					p.SetState(928)
					p.Match(JavaScriptParserPlusPlus)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			case 23:
				localctx = NewPostDecreaseExpressionContext(p, NewSingleExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, JavaScriptParserRULE_singleExpression)
				p.SetState(929)

				if !(p.Precpred(p.GetParserRuleContext(), 38)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 38)", ""))
					goto errorExit
				}
				p.SetState(930)

				if !(p.notLineTerminator()) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.notLineTerminator()", ""))
					goto errorExit
				}
				{
					p.SetState(931)
					p.Match(JavaScriptParserMinusMinus)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			case 24:
				localctx = NewTemplateStringExpressionContext(p, NewSingleExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, JavaScriptParserRULE_singleExpression)
				p.SetState(932)

				if !(p.Precpred(p.GetParserRuleContext(), 9)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 9)", ""))
					goto errorExit
				}
				{
					p.SetState(933)
					p.TemplateStringLiteral()
				}

			case antlr.ATNInvalidAltNumber:
				goto errorExit
			}

		}
		p.SetState(938)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 100, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.UnrollRecursionContexts(_parentctx)
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IInitializerContext is an interface to support dynamic dispatch.
type IInitializerContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Assign() antlr.TerminalNode
	SingleExpression() ISingleExpressionContext

	// IsInitializerContext differentiates from other interfaces.
	IsInitializerContext()
}

type InitializerContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInitializerContext() *InitializerContext {
	var p = new(InitializerContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaScriptParserRULE_initializer
	return p
}

func InitEmptyInitializerContext(p *InitializerContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaScriptParserRULE_initializer
}

func (*InitializerContext) IsInitializerContext() {}

func NewInitializerContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InitializerContext {
	var p = new(InitializerContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaScriptParserRULE_initializer

	return p
}

func (s *InitializerContext) GetParser() antlr.Parser { return s.parser }

func (s *InitializerContext) Assign() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserAssign, 0)
}

func (s *InitializerContext) SingleExpression() ISingleExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISingleExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISingleExpressionContext)
}

func (s *InitializerContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InitializerContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InitializerContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JavaScriptParserVisitor:
		return t.VisitInitializer(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *JavaScriptParser) Initializer() (localctx IInitializerContext) {
	localctx = NewInitializerContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 138, JavaScriptParserRULE_initializer)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(939)
		p.Match(JavaScriptParserAssign)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(940)
		p.singleExpression(0)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAssignableContext is an interface to support dynamic dispatch.
type IAssignableContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext
	ArrayLiteral() IArrayLiteralContext
	ObjectLiteral() IObjectLiteralContext

	// IsAssignableContext differentiates from other interfaces.
	IsAssignableContext()
}

type AssignableContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAssignableContext() *AssignableContext {
	var p = new(AssignableContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaScriptParserRULE_assignable
	return p
}

func InitEmptyAssignableContext(p *AssignableContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaScriptParserRULE_assignable
}

func (*AssignableContext) IsAssignableContext() {}

func NewAssignableContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AssignableContext {
	var p = new(AssignableContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaScriptParserRULE_assignable

	return p
}

func (s *AssignableContext) GetParser() antlr.Parser { return s.parser }

func (s *AssignableContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *AssignableContext) ArrayLiteral() IArrayLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArrayLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArrayLiteralContext)
}

func (s *AssignableContext) ObjectLiteral() IObjectLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IObjectLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IObjectLiteralContext)
}

func (s *AssignableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AssignableContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AssignableContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JavaScriptParserVisitor:
		return t.VisitAssignable(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *JavaScriptParser) Assignable() (localctx IAssignableContext) {
	localctx = NewAssignableContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 140, JavaScriptParserRULE_assignable)
	p.SetState(945)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case JavaScriptParserAs, JavaScriptParserFrom, JavaScriptParserAsync, JavaScriptParserNonStrictLet, JavaScriptParserIdentifier:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(942)
			p.Identifier()
		}

	case JavaScriptParserOpenBracket:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(943)
			p.ArrayLiteral()
		}

	case JavaScriptParserOpenBrace:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(944)
			p.ObjectLiteral()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IObjectLiteralContext is an interface to support dynamic dispatch.
type IObjectLiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	OpenBrace() antlr.TerminalNode
	CloseBrace() antlr.TerminalNode
	AllPropertyAssignment() []IPropertyAssignmentContext
	PropertyAssignment(i int) IPropertyAssignmentContext
	AllComma() []antlr.TerminalNode
	Comma(i int) antlr.TerminalNode

	// IsObjectLiteralContext differentiates from other interfaces.
	IsObjectLiteralContext()
}

type ObjectLiteralContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyObjectLiteralContext() *ObjectLiteralContext {
	var p = new(ObjectLiteralContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaScriptParserRULE_objectLiteral
	return p
}

func InitEmptyObjectLiteralContext(p *ObjectLiteralContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaScriptParserRULE_objectLiteral
}

func (*ObjectLiteralContext) IsObjectLiteralContext() {}

func NewObjectLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ObjectLiteralContext {
	var p = new(ObjectLiteralContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaScriptParserRULE_objectLiteral

	return p
}

func (s *ObjectLiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *ObjectLiteralContext) OpenBrace() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserOpenBrace, 0)
}

func (s *ObjectLiteralContext) CloseBrace() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserCloseBrace, 0)
}

func (s *ObjectLiteralContext) AllPropertyAssignment() []IPropertyAssignmentContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPropertyAssignmentContext); ok {
			len++
		}
	}

	tst := make([]IPropertyAssignmentContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPropertyAssignmentContext); ok {
			tst[i] = t.(IPropertyAssignmentContext)
			i++
		}
	}

	return tst
}

func (s *ObjectLiteralContext) PropertyAssignment(i int) IPropertyAssignmentContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyAssignmentContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyAssignmentContext)
}

func (s *ObjectLiteralContext) AllComma() []antlr.TerminalNode {
	return s.GetTokens(JavaScriptParserComma)
}

func (s *ObjectLiteralContext) Comma(i int) antlr.TerminalNode {
	return s.GetToken(JavaScriptParserComma, i)
}

func (s *ObjectLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ObjectLiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ObjectLiteralContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JavaScriptParserVisitor:
		return t.VisitObjectLiteral(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *JavaScriptParser) ObjectLiteral() (localctx IObjectLiteralContext) {
	localctx = NewObjectLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 142, JavaScriptParserRULE_objectLiteral)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(947)
		p.Match(JavaScriptParserOpenBrace)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(959)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 104, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(948)
			p.PropertyAssignment()
		}
		p.SetState(953)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 102, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(949)
					p.Match(JavaScriptParserComma)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(950)
					p.PropertyAssignment()
				}

			}
			p.SetState(955)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 102, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}
		p.SetState(957)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == JavaScriptParserComma {
			{
				p.SetState(956)
				p.Match(JavaScriptParserComma)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(961)
		p.Match(JavaScriptParserCloseBrace)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAnonymousFunctionContext is an interface to support dynamic dispatch.
type IAnonymousFunctionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsAnonymousFunctionContext differentiates from other interfaces.
	IsAnonymousFunctionContext()
}

type AnonymousFunctionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAnonymousFunctionContext() *AnonymousFunctionContext {
	var p = new(AnonymousFunctionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaScriptParserRULE_anonymousFunction
	return p
}

func InitEmptyAnonymousFunctionContext(p *AnonymousFunctionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaScriptParserRULE_anonymousFunction
}

func (*AnonymousFunctionContext) IsAnonymousFunctionContext() {}

func NewAnonymousFunctionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AnonymousFunctionContext {
	var p = new(AnonymousFunctionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaScriptParserRULE_anonymousFunction

	return p
}

func (s *AnonymousFunctionContext) GetParser() antlr.Parser { return s.parser }

func (s *AnonymousFunctionContext) CopyAll(ctx *AnonymousFunctionContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *AnonymousFunctionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AnonymousFunctionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type AnonymousFunctionDeclContext struct {
	AnonymousFunctionContext
}

func NewAnonymousFunctionDeclContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AnonymousFunctionDeclContext {
	var p = new(AnonymousFunctionDeclContext)

	InitEmptyAnonymousFunctionContext(&p.AnonymousFunctionContext)
	p.parser = parser
	p.CopyAll(ctx.(*AnonymousFunctionContext))

	return p
}

func (s *AnonymousFunctionDeclContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AnonymousFunctionDeclContext) Function_() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserFunction_, 0)
}

func (s *AnonymousFunctionDeclContext) OpenParen() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserOpenParen, 0)
}

func (s *AnonymousFunctionDeclContext) CloseParen() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserCloseParen, 0)
}

func (s *AnonymousFunctionDeclContext) FunctionBody() IFunctionBodyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionBodyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionBodyContext)
}

func (s *AnonymousFunctionDeclContext) Async() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserAsync, 0)
}

func (s *AnonymousFunctionDeclContext) Multiply() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserMultiply, 0)
}

func (s *AnonymousFunctionDeclContext) FormalParameterList() IFormalParameterListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFormalParameterListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFormalParameterListContext)
}

func (s *AnonymousFunctionDeclContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JavaScriptParserVisitor:
		return t.VisitAnonymousFunctionDecl(s)

	default:
		return t.VisitChildren(s)
	}
}

type ArrowFunctionContext struct {
	AnonymousFunctionContext
}

func NewArrowFunctionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ArrowFunctionContext {
	var p = new(ArrowFunctionContext)

	InitEmptyAnonymousFunctionContext(&p.AnonymousFunctionContext)
	p.parser = parser
	p.CopyAll(ctx.(*AnonymousFunctionContext))

	return p
}

func (s *ArrowFunctionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArrowFunctionContext) ArrowFunctionParameters() IArrowFunctionParametersContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArrowFunctionParametersContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArrowFunctionParametersContext)
}

func (s *ArrowFunctionContext) ARROW() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserARROW, 0)
}

func (s *ArrowFunctionContext) ArrowFunctionBody() IArrowFunctionBodyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArrowFunctionBodyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArrowFunctionBodyContext)
}

func (s *ArrowFunctionContext) Async() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserAsync, 0)
}

func (s *ArrowFunctionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JavaScriptParserVisitor:
		return t.VisitArrowFunction(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *JavaScriptParser) AnonymousFunction() (localctx IAnonymousFunctionContext) {
	localctx = NewAnonymousFunctionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 144, JavaScriptParserRULE_anonymousFunction)
	var _la int

	p.SetState(983)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 109, p.GetParserRuleContext()) {
	case 1:
		localctx = NewAnonymousFunctionDeclContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		p.SetState(964)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == JavaScriptParserAsync {
			{
				p.SetState(963)
				p.Match(JavaScriptParserAsync)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(966)
			p.Match(JavaScriptParserFunction_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(968)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == JavaScriptParserMultiply {
			{
				p.SetState(967)
				p.Match(JavaScriptParserMultiply)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(970)
			p.Match(JavaScriptParserOpenParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(972)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&262688) != 0) || ((int64((_la-98)) & ^0x3f) == 0 && ((int64(1)<<(_la-98))&2114051) != 0) {
			{
				p.SetState(971)
				p.FormalParameterList()
			}

		}
		{
			p.SetState(974)
			p.Match(JavaScriptParserCloseParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(975)
			p.FunctionBody()
		}

	case 2:
		localctx = NewArrowFunctionContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		p.SetState(977)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 108, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(976)
				p.Match(JavaScriptParserAsync)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(979)
			p.ArrowFunctionParameters()
		}
		{
			p.SetState(980)
			p.Match(JavaScriptParserARROW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(981)
			p.ArrowFunctionBody()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IArrowFunctionParametersContext is an interface to support dynamic dispatch.
type IArrowFunctionParametersContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext
	OpenParen() antlr.TerminalNode
	CloseParen() antlr.TerminalNode
	FormalParameterList() IFormalParameterListContext

	// IsArrowFunctionParametersContext differentiates from other interfaces.
	IsArrowFunctionParametersContext()
}

type ArrowFunctionParametersContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyArrowFunctionParametersContext() *ArrowFunctionParametersContext {
	var p = new(ArrowFunctionParametersContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaScriptParserRULE_arrowFunctionParameters
	return p
}

func InitEmptyArrowFunctionParametersContext(p *ArrowFunctionParametersContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaScriptParserRULE_arrowFunctionParameters
}

func (*ArrowFunctionParametersContext) IsArrowFunctionParametersContext() {}

func NewArrowFunctionParametersContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ArrowFunctionParametersContext {
	var p = new(ArrowFunctionParametersContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaScriptParserRULE_arrowFunctionParameters

	return p
}

func (s *ArrowFunctionParametersContext) GetParser() antlr.Parser { return s.parser }

func (s *ArrowFunctionParametersContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ArrowFunctionParametersContext) OpenParen() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserOpenParen, 0)
}

func (s *ArrowFunctionParametersContext) CloseParen() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserCloseParen, 0)
}

func (s *ArrowFunctionParametersContext) FormalParameterList() IFormalParameterListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFormalParameterListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFormalParameterListContext)
}

func (s *ArrowFunctionParametersContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArrowFunctionParametersContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ArrowFunctionParametersContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JavaScriptParserVisitor:
		return t.VisitArrowFunctionParameters(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *JavaScriptParser) ArrowFunctionParameters() (localctx IArrowFunctionParametersContext) {
	localctx = NewArrowFunctionParametersContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 146, JavaScriptParserRULE_arrowFunctionParameters)
	var _la int

	p.SetState(991)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case JavaScriptParserAs, JavaScriptParserFrom, JavaScriptParserAsync, JavaScriptParserNonStrictLet, JavaScriptParserIdentifier:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(985)
			p.Identifier()
		}

	case JavaScriptParserOpenParen:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(986)
			p.Match(JavaScriptParserOpenParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(988)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&262688) != 0) || ((int64((_la-98)) & ^0x3f) == 0 && ((int64(1)<<(_la-98))&2114051) != 0) {
			{
				p.SetState(987)
				p.FormalParameterList()
			}

		}
		{
			p.SetState(990)
			p.Match(JavaScriptParserCloseParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IArrowFunctionBodyContext is an interface to support dynamic dispatch.
type IArrowFunctionBodyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SingleExpression() ISingleExpressionContext
	FunctionBody() IFunctionBodyContext

	// IsArrowFunctionBodyContext differentiates from other interfaces.
	IsArrowFunctionBodyContext()
}

type ArrowFunctionBodyContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyArrowFunctionBodyContext() *ArrowFunctionBodyContext {
	var p = new(ArrowFunctionBodyContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaScriptParserRULE_arrowFunctionBody
	return p
}

func InitEmptyArrowFunctionBodyContext(p *ArrowFunctionBodyContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaScriptParserRULE_arrowFunctionBody
}

func (*ArrowFunctionBodyContext) IsArrowFunctionBodyContext() {}

func NewArrowFunctionBodyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ArrowFunctionBodyContext {
	var p = new(ArrowFunctionBodyContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaScriptParserRULE_arrowFunctionBody

	return p
}

func (s *ArrowFunctionBodyContext) GetParser() antlr.Parser { return s.parser }

func (s *ArrowFunctionBodyContext) SingleExpression() ISingleExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISingleExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISingleExpressionContext)
}

func (s *ArrowFunctionBodyContext) FunctionBody() IFunctionBodyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionBodyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionBodyContext)
}

func (s *ArrowFunctionBodyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArrowFunctionBodyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ArrowFunctionBodyContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JavaScriptParserVisitor:
		return t.VisitArrowFunctionBody(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *JavaScriptParser) ArrowFunctionBody() (localctx IArrowFunctionBodyContext) {
	localctx = NewArrowFunctionBodyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 148, JavaScriptParserRULE_arrowFunctionBody)
	p.SetState(995)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 112, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(993)
			p.singleExpression(0)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(994)
			p.FunctionBody()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAssignmentOperatorContext is an interface to support dynamic dispatch.
type IAssignmentOperatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	MultiplyAssign() antlr.TerminalNode
	DivideAssign() antlr.TerminalNode
	ModulusAssign() antlr.TerminalNode
	PlusAssign() antlr.TerminalNode
	MinusAssign() antlr.TerminalNode
	LeftShiftArithmeticAssign() antlr.TerminalNode
	RightShiftArithmeticAssign() antlr.TerminalNode
	RightShiftLogicalAssign() antlr.TerminalNode
	BitAndAssign() antlr.TerminalNode
	BitXorAssign() antlr.TerminalNode
	BitOrAssign() antlr.TerminalNode
	PowerAssign() antlr.TerminalNode

	// IsAssignmentOperatorContext differentiates from other interfaces.
	IsAssignmentOperatorContext()
}

type AssignmentOperatorContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAssignmentOperatorContext() *AssignmentOperatorContext {
	var p = new(AssignmentOperatorContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaScriptParserRULE_assignmentOperator
	return p
}

func InitEmptyAssignmentOperatorContext(p *AssignmentOperatorContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaScriptParserRULE_assignmentOperator
}

func (*AssignmentOperatorContext) IsAssignmentOperatorContext() {}

func NewAssignmentOperatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AssignmentOperatorContext {
	var p = new(AssignmentOperatorContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaScriptParserRULE_assignmentOperator

	return p
}

func (s *AssignmentOperatorContext) GetParser() antlr.Parser { return s.parser }

func (s *AssignmentOperatorContext) MultiplyAssign() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserMultiplyAssign, 0)
}

func (s *AssignmentOperatorContext) DivideAssign() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserDivideAssign, 0)
}

func (s *AssignmentOperatorContext) ModulusAssign() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserModulusAssign, 0)
}

func (s *AssignmentOperatorContext) PlusAssign() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserPlusAssign, 0)
}

func (s *AssignmentOperatorContext) MinusAssign() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserMinusAssign, 0)
}

func (s *AssignmentOperatorContext) LeftShiftArithmeticAssign() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserLeftShiftArithmeticAssign, 0)
}

func (s *AssignmentOperatorContext) RightShiftArithmeticAssign() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserRightShiftArithmeticAssign, 0)
}

func (s *AssignmentOperatorContext) RightShiftLogicalAssign() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserRightShiftLogicalAssign, 0)
}

func (s *AssignmentOperatorContext) BitAndAssign() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserBitAndAssign, 0)
}

func (s *AssignmentOperatorContext) BitXorAssign() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserBitXorAssign, 0)
}

func (s *AssignmentOperatorContext) BitOrAssign() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserBitOrAssign, 0)
}

func (s *AssignmentOperatorContext) PowerAssign() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserPowerAssign, 0)
}

func (s *AssignmentOperatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AssignmentOperatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AssignmentOperatorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JavaScriptParserVisitor:
		return t.VisitAssignmentOperator(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *JavaScriptParser) AssignmentOperator() (localctx IAssignmentOperatorContext) {
	localctx = NewAssignmentOperatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 150, JavaScriptParserRULE_assignmentOperator)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(997)
		_la = p.GetTokenStream().LA(1)

		if !((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&1152640029630136320) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILiteralContext is an interface to support dynamic dispatch.
type ILiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	NullLiteral() antlr.TerminalNode
	BooleanLiteral() antlr.TerminalNode
	StringLiteral() antlr.TerminalNode
	TemplateStringLiteral() ITemplateStringLiteralContext
	RegularExpressionLiteral() antlr.TerminalNode
	NumericLiteral() INumericLiteralContext
	BigintLiteral() IBigintLiteralContext

	// IsLiteralContext differentiates from other interfaces.
	IsLiteralContext()
}

type LiteralContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLiteralContext() *LiteralContext {
	var p = new(LiteralContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaScriptParserRULE_literal
	return p
}

func InitEmptyLiteralContext(p *LiteralContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaScriptParserRULE_literal
}

func (*LiteralContext) IsLiteralContext() {}

func NewLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LiteralContext {
	var p = new(LiteralContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaScriptParserRULE_literal

	return p
}

func (s *LiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *LiteralContext) NullLiteral() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserNullLiteral, 0)
}

func (s *LiteralContext) BooleanLiteral() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserBooleanLiteral, 0)
}

func (s *LiteralContext) StringLiteral() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserStringLiteral, 0)
}

func (s *LiteralContext) TemplateStringLiteral() ITemplateStringLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITemplateStringLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITemplateStringLiteralContext)
}

func (s *LiteralContext) RegularExpressionLiteral() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserRegularExpressionLiteral, 0)
}

func (s *LiteralContext) NumericLiteral() INumericLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INumericLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INumericLiteralContext)
}

func (s *LiteralContext) BigintLiteral() IBigintLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBigintLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBigintLiteralContext)
}

func (s *LiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LiteralContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JavaScriptParserVisitor:
		return t.VisitLiteral(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *JavaScriptParser) Literal() (localctx ILiteralContext) {
	localctx = NewLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 152, JavaScriptParserRULE_literal)
	p.SetState(1006)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case JavaScriptParserNullLiteral:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(999)
			p.Match(JavaScriptParserNullLiteral)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case JavaScriptParserBooleanLiteral:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1000)
			p.Match(JavaScriptParserBooleanLiteral)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case JavaScriptParserStringLiteral:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1001)
			p.Match(JavaScriptParserStringLiteral)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case JavaScriptParserBackTick:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1002)
			p.TemplateStringLiteral()
		}

	case JavaScriptParserRegularExpressionLiteral:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1003)
			p.Match(JavaScriptParserRegularExpressionLiteral)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case JavaScriptParserDecimalLiteral, JavaScriptParserHexIntegerLiteral, JavaScriptParserOctalIntegerLiteral, JavaScriptParserOctalIntegerLiteral2, JavaScriptParserBinaryIntegerLiteral:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(1004)
			p.NumericLiteral()
		}

	case JavaScriptParserBigHexIntegerLiteral, JavaScriptParserBigOctalIntegerLiteral, JavaScriptParserBigBinaryIntegerLiteral, JavaScriptParserBigDecimalIntegerLiteral:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(1005)
			p.BigintLiteral()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITemplateStringLiteralContext is an interface to support dynamic dispatch.
type ITemplateStringLiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllBackTick() []antlr.TerminalNode
	BackTick(i int) antlr.TerminalNode
	AllTemplateStringAtom() []ITemplateStringAtomContext
	TemplateStringAtom(i int) ITemplateStringAtomContext

	// IsTemplateStringLiteralContext differentiates from other interfaces.
	IsTemplateStringLiteralContext()
}

type TemplateStringLiteralContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTemplateStringLiteralContext() *TemplateStringLiteralContext {
	var p = new(TemplateStringLiteralContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaScriptParserRULE_templateStringLiteral
	return p
}

func InitEmptyTemplateStringLiteralContext(p *TemplateStringLiteralContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaScriptParserRULE_templateStringLiteral
}

func (*TemplateStringLiteralContext) IsTemplateStringLiteralContext() {}

func NewTemplateStringLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TemplateStringLiteralContext {
	var p = new(TemplateStringLiteralContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaScriptParserRULE_templateStringLiteral

	return p
}

func (s *TemplateStringLiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *TemplateStringLiteralContext) AllBackTick() []antlr.TerminalNode {
	return s.GetTokens(JavaScriptParserBackTick)
}

func (s *TemplateStringLiteralContext) BackTick(i int) antlr.TerminalNode {
	return s.GetToken(JavaScriptParserBackTick, i)
}

func (s *TemplateStringLiteralContext) AllTemplateStringAtom() []ITemplateStringAtomContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITemplateStringAtomContext); ok {
			len++
		}
	}

	tst := make([]ITemplateStringAtomContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITemplateStringAtomContext); ok {
			tst[i] = t.(ITemplateStringAtomContext)
			i++
		}
	}

	return tst
}

func (s *TemplateStringLiteralContext) TemplateStringAtom(i int) ITemplateStringAtomContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITemplateStringAtomContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITemplateStringAtomContext)
}

func (s *TemplateStringLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TemplateStringLiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TemplateStringLiteralContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JavaScriptParserVisitor:
		return t.VisitTemplateStringLiteral(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *JavaScriptParser) TemplateStringLiteral() (localctx ITemplateStringLiteralContext) {
	localctx = NewTemplateStringLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 154, JavaScriptParserRULE_templateStringLiteral)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1008)
		p.Match(JavaScriptParserBackTick)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1012)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == JavaScriptParserTemplateStringStartExpression || _la == JavaScriptParserTemplateStringAtom {
		{
			p.SetState(1009)
			p.TemplateStringAtom()
		}

		p.SetState(1014)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1015)
		p.Match(JavaScriptParserBackTick)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITemplateStringAtomContext is an interface to support dynamic dispatch.
type ITemplateStringAtomContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TemplateStringAtom() antlr.TerminalNode
	TemplateStringStartExpression() antlr.TerminalNode
	SingleExpression() ISingleExpressionContext
	TemplateCloseBrace() antlr.TerminalNode

	// IsTemplateStringAtomContext differentiates from other interfaces.
	IsTemplateStringAtomContext()
}

type TemplateStringAtomContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTemplateStringAtomContext() *TemplateStringAtomContext {
	var p = new(TemplateStringAtomContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaScriptParserRULE_templateStringAtom
	return p
}

func InitEmptyTemplateStringAtomContext(p *TemplateStringAtomContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaScriptParserRULE_templateStringAtom
}

func (*TemplateStringAtomContext) IsTemplateStringAtomContext() {}

func NewTemplateStringAtomContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TemplateStringAtomContext {
	var p = new(TemplateStringAtomContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaScriptParserRULE_templateStringAtom

	return p
}

func (s *TemplateStringAtomContext) GetParser() antlr.Parser { return s.parser }

func (s *TemplateStringAtomContext) TemplateStringAtom() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserTemplateStringAtom, 0)
}

func (s *TemplateStringAtomContext) TemplateStringStartExpression() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserTemplateStringStartExpression, 0)
}

func (s *TemplateStringAtomContext) SingleExpression() ISingleExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISingleExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISingleExpressionContext)
}

func (s *TemplateStringAtomContext) TemplateCloseBrace() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserTemplateCloseBrace, 0)
}

func (s *TemplateStringAtomContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TemplateStringAtomContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TemplateStringAtomContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JavaScriptParserVisitor:
		return t.VisitTemplateStringAtom(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *JavaScriptParser) TemplateStringAtom() (localctx ITemplateStringAtomContext) {
	localctx = NewTemplateStringAtomContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 156, JavaScriptParserRULE_templateStringAtom)
	p.SetState(1022)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case JavaScriptParserTemplateStringAtom:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1017)
			p.Match(JavaScriptParserTemplateStringAtom)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case JavaScriptParserTemplateStringStartExpression:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1018)
			p.Match(JavaScriptParserTemplateStringStartExpression)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1019)
			p.singleExpression(0)
		}
		{
			p.SetState(1020)
			p.Match(JavaScriptParserTemplateCloseBrace)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// INumericLiteralContext is an interface to support dynamic dispatch.
type INumericLiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DecimalLiteral() antlr.TerminalNode
	HexIntegerLiteral() antlr.TerminalNode
	OctalIntegerLiteral() antlr.TerminalNode
	OctalIntegerLiteral2() antlr.TerminalNode
	BinaryIntegerLiteral() antlr.TerminalNode

	// IsNumericLiteralContext differentiates from other interfaces.
	IsNumericLiteralContext()
}

type NumericLiteralContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNumericLiteralContext() *NumericLiteralContext {
	var p = new(NumericLiteralContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaScriptParserRULE_numericLiteral
	return p
}

func InitEmptyNumericLiteralContext(p *NumericLiteralContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaScriptParserRULE_numericLiteral
}

func (*NumericLiteralContext) IsNumericLiteralContext() {}

func NewNumericLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NumericLiteralContext {
	var p = new(NumericLiteralContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaScriptParserRULE_numericLiteral

	return p
}

func (s *NumericLiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *NumericLiteralContext) DecimalLiteral() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserDecimalLiteral, 0)
}

func (s *NumericLiteralContext) HexIntegerLiteral() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserHexIntegerLiteral, 0)
}

func (s *NumericLiteralContext) OctalIntegerLiteral() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserOctalIntegerLiteral, 0)
}

func (s *NumericLiteralContext) OctalIntegerLiteral2() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserOctalIntegerLiteral2, 0)
}

func (s *NumericLiteralContext) BinaryIntegerLiteral() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserBinaryIntegerLiteral, 0)
}

func (s *NumericLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NumericLiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NumericLiteralContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JavaScriptParserVisitor:
		return t.VisitNumericLiteral(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *JavaScriptParser) NumericLiteral() (localctx INumericLiteralContext) {
	localctx = NewNumericLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 158, JavaScriptParserRULE_numericLiteral)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1024)
		_la = p.GetTokenStream().LA(1)

		if !((int64((_la-63)) & ^0x3f) == 0 && ((int64(1)<<(_la-63))&31) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IBigintLiteralContext is an interface to support dynamic dispatch.
type IBigintLiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	BigDecimalIntegerLiteral() antlr.TerminalNode
	BigHexIntegerLiteral() antlr.TerminalNode
	BigOctalIntegerLiteral() antlr.TerminalNode
	BigBinaryIntegerLiteral() antlr.TerminalNode

	// IsBigintLiteralContext differentiates from other interfaces.
	IsBigintLiteralContext()
}

type BigintLiteralContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBigintLiteralContext() *BigintLiteralContext {
	var p = new(BigintLiteralContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaScriptParserRULE_bigintLiteral
	return p
}

func InitEmptyBigintLiteralContext(p *BigintLiteralContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaScriptParserRULE_bigintLiteral
}

func (*BigintLiteralContext) IsBigintLiteralContext() {}

func NewBigintLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BigintLiteralContext {
	var p = new(BigintLiteralContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaScriptParserRULE_bigintLiteral

	return p
}

func (s *BigintLiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *BigintLiteralContext) BigDecimalIntegerLiteral() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserBigDecimalIntegerLiteral, 0)
}

func (s *BigintLiteralContext) BigHexIntegerLiteral() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserBigHexIntegerLiteral, 0)
}

func (s *BigintLiteralContext) BigOctalIntegerLiteral() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserBigOctalIntegerLiteral, 0)
}

func (s *BigintLiteralContext) BigBinaryIntegerLiteral() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserBigBinaryIntegerLiteral, 0)
}

func (s *BigintLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BigintLiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BigintLiteralContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JavaScriptParserVisitor:
		return t.VisitBigintLiteral(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *JavaScriptParser) BigintLiteral() (localctx IBigintLiteralContext) {
	localctx = NewBigintLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 160, JavaScriptParserRULE_bigintLiteral)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1026)
		_la = p.GetTokenStream().LA(1)

		if !((int64((_la-68)) & ^0x3f) == 0 && ((int64(1)<<(_la-68))&15) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IGetterContext is an interface to support dynamic dispatch.
type IGetterContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext
	ClassElementName() IClassElementNameContext

	// IsGetterContext differentiates from other interfaces.
	IsGetterContext()
}

type GetterContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGetterContext() *GetterContext {
	var p = new(GetterContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaScriptParserRULE_getter
	return p
}

func InitEmptyGetterContext(p *GetterContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaScriptParserRULE_getter
}

func (*GetterContext) IsGetterContext() {}

func NewGetterContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GetterContext {
	var p = new(GetterContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaScriptParserRULE_getter

	return p
}

func (s *GetterContext) GetParser() antlr.Parser { return s.parser }

func (s *GetterContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *GetterContext) ClassElementName() IClassElementNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClassElementNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClassElementNameContext)
}

func (s *GetterContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GetterContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GetterContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JavaScriptParserVisitor:
		return t.VisitGetter(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *JavaScriptParser) Getter() (localctx IGetterContext) {
	localctx = NewGetterContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 162, JavaScriptParserRULE_getter)
	p.EnterOuterAlt(localctx, 1)
	p.SetState(1028)

	if !(p.n("get")) {
		p.SetError(antlr.NewFailedPredicateException(p, "p.n(\"get\")", ""))
		goto errorExit
	}
	{
		p.SetState(1029)
		p.Identifier()
	}
	{
		p.SetState(1030)
		p.ClassElementName()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISetterContext is an interface to support dynamic dispatch.
type ISetterContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext
	ClassElementName() IClassElementNameContext

	// IsSetterContext differentiates from other interfaces.
	IsSetterContext()
}

type SetterContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySetterContext() *SetterContext {
	var p = new(SetterContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaScriptParserRULE_setter
	return p
}

func InitEmptySetterContext(p *SetterContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaScriptParserRULE_setter
}

func (*SetterContext) IsSetterContext() {}

func NewSetterContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SetterContext {
	var p = new(SetterContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaScriptParserRULE_setter

	return p
}

func (s *SetterContext) GetParser() antlr.Parser { return s.parser }

func (s *SetterContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *SetterContext) ClassElementName() IClassElementNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClassElementNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClassElementNameContext)
}

func (s *SetterContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SetterContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SetterContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JavaScriptParserVisitor:
		return t.VisitSetter(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *JavaScriptParser) Setter() (localctx ISetterContext) {
	localctx = NewSetterContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 164, JavaScriptParserRULE_setter)
	p.EnterOuterAlt(localctx, 1)
	p.SetState(1032)

	if !(p.n("set")) {
		p.SetError(antlr.NewFailedPredicateException(p, "p.n(\"set\")", ""))
		goto errorExit
	}
	{
		p.SetState(1033)
		p.Identifier()
	}
	{
		p.SetState(1034)
		p.ClassElementName()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIdentifierNameContext is an interface to support dynamic dispatch.
type IIdentifierNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext
	ReservedWord() IReservedWordContext

	// IsIdentifierNameContext differentiates from other interfaces.
	IsIdentifierNameContext()
}

type IdentifierNameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIdentifierNameContext() *IdentifierNameContext {
	var p = new(IdentifierNameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaScriptParserRULE_identifierName
	return p
}

func InitEmptyIdentifierNameContext(p *IdentifierNameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaScriptParserRULE_identifierName
}

func (*IdentifierNameContext) IsIdentifierNameContext() {}

func NewIdentifierNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IdentifierNameContext {
	var p = new(IdentifierNameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaScriptParserRULE_identifierName

	return p
}

func (s *IdentifierNameContext) GetParser() antlr.Parser { return s.parser }

func (s *IdentifierNameContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *IdentifierNameContext) ReservedWord() IReservedWordContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReservedWordContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReservedWordContext)
}

func (s *IdentifierNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IdentifierNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IdentifierNameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JavaScriptParserVisitor:
		return t.VisitIdentifierName(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *JavaScriptParser) IdentifierName() (localctx IIdentifierNameContext) {
	localctx = NewIdentifierNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 166, JavaScriptParserRULE_identifierName)
	p.SetState(1038)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 116, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1036)
			p.Identifier()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1037)
			p.ReservedWord()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIdentifierContext is an interface to support dynamic dispatch.
type IIdentifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() antlr.TerminalNode
	NonStrictLet() antlr.TerminalNode
	Async() antlr.TerminalNode
	As() antlr.TerminalNode
	From() antlr.TerminalNode

	// IsIdentifierContext differentiates from other interfaces.
	IsIdentifierContext()
}

type IdentifierContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIdentifierContext() *IdentifierContext {
	var p = new(IdentifierContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaScriptParserRULE_identifier
	return p
}

func InitEmptyIdentifierContext(p *IdentifierContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaScriptParserRULE_identifier
}

func (*IdentifierContext) IsIdentifierContext() {}

func NewIdentifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IdentifierContext {
	var p = new(IdentifierContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaScriptParserRULE_identifier

	return p
}

func (s *IdentifierContext) GetParser() antlr.Parser { return s.parser }

func (s *IdentifierContext) Identifier() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserIdentifier, 0)
}

func (s *IdentifierContext) NonStrictLet() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserNonStrictLet, 0)
}

func (s *IdentifierContext) Async() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserAsync, 0)
}

func (s *IdentifierContext) As() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserAs, 0)
}

func (s *IdentifierContext) From() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserFrom, 0)
}

func (s *IdentifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IdentifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IdentifierContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JavaScriptParserVisitor:
		return t.VisitIdentifier(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *JavaScriptParser) Identifier() (localctx IIdentifierContext) {
	localctx = NewIdentifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 168, JavaScriptParserRULE_identifier)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1040)
		_la = p.GetTokenStream().LA(1)

		if !((int64((_la-98)) & ^0x3f) == 0 && ((int64(1)<<(_la-98))&2114051) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IReservedWordContext is an interface to support dynamic dispatch.
type IReservedWordContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Keyword() IKeywordContext
	NullLiteral() antlr.TerminalNode
	BooleanLiteral() antlr.TerminalNode

	// IsReservedWordContext differentiates from other interfaces.
	IsReservedWordContext()
}

type ReservedWordContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReservedWordContext() *ReservedWordContext {
	var p = new(ReservedWordContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaScriptParserRULE_reservedWord
	return p
}

func InitEmptyReservedWordContext(p *ReservedWordContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaScriptParserRULE_reservedWord
}

func (*ReservedWordContext) IsReservedWordContext() {}

func NewReservedWordContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReservedWordContext {
	var p = new(ReservedWordContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaScriptParserRULE_reservedWord

	return p
}

func (s *ReservedWordContext) GetParser() antlr.Parser { return s.parser }

func (s *ReservedWordContext) Keyword() IKeywordContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKeywordContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKeywordContext)
}

func (s *ReservedWordContext) NullLiteral() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserNullLiteral, 0)
}

func (s *ReservedWordContext) BooleanLiteral() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserBooleanLiteral, 0)
}

func (s *ReservedWordContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReservedWordContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReservedWordContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JavaScriptParserVisitor:
		return t.VisitReservedWord(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *JavaScriptParser) ReservedWord() (localctx IReservedWordContext) {
	localctx = NewReservedWordContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 170, JavaScriptParserRULE_reservedWord)
	p.SetState(1045)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case JavaScriptParserBreak, JavaScriptParserDo, JavaScriptParserInstanceof, JavaScriptParserTypeof, JavaScriptParserCase, JavaScriptParserElse, JavaScriptParserNew, JavaScriptParserVar, JavaScriptParserCatch, JavaScriptParserFinally, JavaScriptParserReturn, JavaScriptParserVoid, JavaScriptParserContinue, JavaScriptParserFor, JavaScriptParserSwitch, JavaScriptParserWhile, JavaScriptParserDebugger, JavaScriptParserFunction_, JavaScriptParserThis, JavaScriptParserWith, JavaScriptParserDefault, JavaScriptParserIf, JavaScriptParserThrow, JavaScriptParserDelete, JavaScriptParserIn, JavaScriptParserTry, JavaScriptParserAs, JavaScriptParserFrom, JavaScriptParserClass, JavaScriptParserEnum, JavaScriptParserExtends, JavaScriptParserSuper, JavaScriptParserConst, JavaScriptParserExport, JavaScriptParserImport, JavaScriptParserAsync, JavaScriptParserAwait, JavaScriptParserYield, JavaScriptParserImplements, JavaScriptParserStrictLet, JavaScriptParserNonStrictLet, JavaScriptParserPrivate, JavaScriptParserPublic, JavaScriptParserInterface, JavaScriptParserPackage, JavaScriptParserProtected, JavaScriptParserStatic:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1042)
			p.Keyword()
		}

	case JavaScriptParserNullLiteral:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1043)
			p.Match(JavaScriptParserNullLiteral)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case JavaScriptParserBooleanLiteral:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1044)
			p.Match(JavaScriptParserBooleanLiteral)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IKeywordContext is an interface to support dynamic dispatch.
type IKeywordContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Break() antlr.TerminalNode
	Do() antlr.TerminalNode
	Instanceof() antlr.TerminalNode
	Typeof() antlr.TerminalNode
	Case() antlr.TerminalNode
	Else() antlr.TerminalNode
	New() antlr.TerminalNode
	Var() antlr.TerminalNode
	Catch() antlr.TerminalNode
	Finally() antlr.TerminalNode
	Return() antlr.TerminalNode
	Void() antlr.TerminalNode
	Continue() antlr.TerminalNode
	For() antlr.TerminalNode
	Switch() antlr.TerminalNode
	While() antlr.TerminalNode
	Debugger() antlr.TerminalNode
	Function_() antlr.TerminalNode
	This() antlr.TerminalNode
	With() antlr.TerminalNode
	Default() antlr.TerminalNode
	If() antlr.TerminalNode
	Throw() antlr.TerminalNode
	Delete() antlr.TerminalNode
	In() antlr.TerminalNode
	Try() antlr.TerminalNode
	Class() antlr.TerminalNode
	Enum() antlr.TerminalNode
	Extends() antlr.TerminalNode
	Super() antlr.TerminalNode
	Const() antlr.TerminalNode
	Export() antlr.TerminalNode
	Import() antlr.TerminalNode
	Implements() antlr.TerminalNode
	Let_() ILet_Context
	Private() antlr.TerminalNode
	Public() antlr.TerminalNode
	Interface() antlr.TerminalNode
	Package() antlr.TerminalNode
	Protected() antlr.TerminalNode
	Static() antlr.TerminalNode
	Yield() antlr.TerminalNode
	Async() antlr.TerminalNode
	Await() antlr.TerminalNode
	From() antlr.TerminalNode
	As() antlr.TerminalNode

	// IsKeywordContext differentiates from other interfaces.
	IsKeywordContext()
}

type KeywordContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKeywordContext() *KeywordContext {
	var p = new(KeywordContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaScriptParserRULE_keyword
	return p
}

func InitEmptyKeywordContext(p *KeywordContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaScriptParserRULE_keyword
}

func (*KeywordContext) IsKeywordContext() {}

func NewKeywordContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *KeywordContext {
	var p = new(KeywordContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaScriptParserRULE_keyword

	return p
}

func (s *KeywordContext) GetParser() antlr.Parser { return s.parser }

func (s *KeywordContext) Break() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserBreak, 0)
}

func (s *KeywordContext) Do() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserDo, 0)
}

func (s *KeywordContext) Instanceof() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserInstanceof, 0)
}

func (s *KeywordContext) Typeof() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserTypeof, 0)
}

func (s *KeywordContext) Case() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserCase, 0)
}

func (s *KeywordContext) Else() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserElse, 0)
}

func (s *KeywordContext) New() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserNew, 0)
}

func (s *KeywordContext) Var() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserVar, 0)
}

func (s *KeywordContext) Catch() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserCatch, 0)
}

func (s *KeywordContext) Finally() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserFinally, 0)
}

func (s *KeywordContext) Return() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserReturn, 0)
}

func (s *KeywordContext) Void() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserVoid, 0)
}

func (s *KeywordContext) Continue() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserContinue, 0)
}

func (s *KeywordContext) For() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserFor, 0)
}

func (s *KeywordContext) Switch() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserSwitch, 0)
}

func (s *KeywordContext) While() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserWhile, 0)
}

func (s *KeywordContext) Debugger() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserDebugger, 0)
}

func (s *KeywordContext) Function_() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserFunction_, 0)
}

func (s *KeywordContext) This() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserThis, 0)
}

func (s *KeywordContext) With() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserWith, 0)
}

func (s *KeywordContext) Default() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserDefault, 0)
}

func (s *KeywordContext) If() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserIf, 0)
}

func (s *KeywordContext) Throw() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserThrow, 0)
}

func (s *KeywordContext) Delete() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserDelete, 0)
}

func (s *KeywordContext) In() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserIn, 0)
}

func (s *KeywordContext) Try() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserTry, 0)
}

func (s *KeywordContext) Class() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserClass, 0)
}

func (s *KeywordContext) Enum() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserEnum, 0)
}

func (s *KeywordContext) Extends() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserExtends, 0)
}

func (s *KeywordContext) Super() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserSuper, 0)
}

func (s *KeywordContext) Const() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserConst, 0)
}

func (s *KeywordContext) Export() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserExport, 0)
}

func (s *KeywordContext) Import() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserImport, 0)
}

func (s *KeywordContext) Implements() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserImplements, 0)
}

func (s *KeywordContext) Let_() ILet_Context {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILet_Context); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILet_Context)
}

func (s *KeywordContext) Private() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserPrivate, 0)
}

func (s *KeywordContext) Public() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserPublic, 0)
}

func (s *KeywordContext) Interface() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserInterface, 0)
}

func (s *KeywordContext) Package() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserPackage, 0)
}

func (s *KeywordContext) Protected() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserProtected, 0)
}

func (s *KeywordContext) Static() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserStatic, 0)
}

func (s *KeywordContext) Yield() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserYield, 0)
}

func (s *KeywordContext) Async() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserAsync, 0)
}

func (s *KeywordContext) Await() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserAwait, 0)
}

func (s *KeywordContext) From() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserFrom, 0)
}

func (s *KeywordContext) As() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserAs, 0)
}

func (s *KeywordContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KeywordContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *KeywordContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JavaScriptParserVisitor:
		return t.VisitKeyword(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *JavaScriptParser) Keyword() (localctx IKeywordContext) {
	localctx = NewKeywordContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 172, JavaScriptParserRULE_keyword)
	p.SetState(1093)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case JavaScriptParserBreak:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1047)
			p.Match(JavaScriptParserBreak)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case JavaScriptParserDo:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1048)
			p.Match(JavaScriptParserDo)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case JavaScriptParserInstanceof:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1049)
			p.Match(JavaScriptParserInstanceof)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case JavaScriptParserTypeof:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1050)
			p.Match(JavaScriptParserTypeof)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case JavaScriptParserCase:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1051)
			p.Match(JavaScriptParserCase)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case JavaScriptParserElse:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(1052)
			p.Match(JavaScriptParserElse)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case JavaScriptParserNew:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(1053)
			p.Match(JavaScriptParserNew)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case JavaScriptParserVar:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(1054)
			p.Match(JavaScriptParserVar)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case JavaScriptParserCatch:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(1055)
			p.Match(JavaScriptParserCatch)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case JavaScriptParserFinally:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(1056)
			p.Match(JavaScriptParserFinally)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case JavaScriptParserReturn:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(1057)
			p.Match(JavaScriptParserReturn)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case JavaScriptParserVoid:
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(1058)
			p.Match(JavaScriptParserVoid)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case JavaScriptParserContinue:
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(1059)
			p.Match(JavaScriptParserContinue)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case JavaScriptParserFor:
		p.EnterOuterAlt(localctx, 14)
		{
			p.SetState(1060)
			p.Match(JavaScriptParserFor)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case JavaScriptParserSwitch:
		p.EnterOuterAlt(localctx, 15)
		{
			p.SetState(1061)
			p.Match(JavaScriptParserSwitch)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case JavaScriptParserWhile:
		p.EnterOuterAlt(localctx, 16)
		{
			p.SetState(1062)
			p.Match(JavaScriptParserWhile)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case JavaScriptParserDebugger:
		p.EnterOuterAlt(localctx, 17)
		{
			p.SetState(1063)
			p.Match(JavaScriptParserDebugger)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case JavaScriptParserFunction_:
		p.EnterOuterAlt(localctx, 18)
		{
			p.SetState(1064)
			p.Match(JavaScriptParserFunction_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case JavaScriptParserThis:
		p.EnterOuterAlt(localctx, 19)
		{
			p.SetState(1065)
			p.Match(JavaScriptParserThis)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case JavaScriptParserWith:
		p.EnterOuterAlt(localctx, 20)
		{
			p.SetState(1066)
			p.Match(JavaScriptParserWith)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case JavaScriptParserDefault:
		p.EnterOuterAlt(localctx, 21)
		{
			p.SetState(1067)
			p.Match(JavaScriptParserDefault)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case JavaScriptParserIf:
		p.EnterOuterAlt(localctx, 22)
		{
			p.SetState(1068)
			p.Match(JavaScriptParserIf)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case JavaScriptParserThrow:
		p.EnterOuterAlt(localctx, 23)
		{
			p.SetState(1069)
			p.Match(JavaScriptParserThrow)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case JavaScriptParserDelete:
		p.EnterOuterAlt(localctx, 24)
		{
			p.SetState(1070)
			p.Match(JavaScriptParserDelete)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case JavaScriptParserIn:
		p.EnterOuterAlt(localctx, 25)
		{
			p.SetState(1071)
			p.Match(JavaScriptParserIn)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case JavaScriptParserTry:
		p.EnterOuterAlt(localctx, 26)
		{
			p.SetState(1072)
			p.Match(JavaScriptParserTry)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case JavaScriptParserClass:
		p.EnterOuterAlt(localctx, 27)
		{
			p.SetState(1073)
			p.Match(JavaScriptParserClass)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case JavaScriptParserEnum:
		p.EnterOuterAlt(localctx, 28)
		{
			p.SetState(1074)
			p.Match(JavaScriptParserEnum)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case JavaScriptParserExtends:
		p.EnterOuterAlt(localctx, 29)
		{
			p.SetState(1075)
			p.Match(JavaScriptParserExtends)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case JavaScriptParserSuper:
		p.EnterOuterAlt(localctx, 30)
		{
			p.SetState(1076)
			p.Match(JavaScriptParserSuper)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case JavaScriptParserConst:
		p.EnterOuterAlt(localctx, 31)
		{
			p.SetState(1077)
			p.Match(JavaScriptParserConst)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case JavaScriptParserExport:
		p.EnterOuterAlt(localctx, 32)
		{
			p.SetState(1078)
			p.Match(JavaScriptParserExport)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case JavaScriptParserImport:
		p.EnterOuterAlt(localctx, 33)
		{
			p.SetState(1079)
			p.Match(JavaScriptParserImport)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case JavaScriptParserImplements:
		p.EnterOuterAlt(localctx, 34)
		{
			p.SetState(1080)
			p.Match(JavaScriptParserImplements)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case JavaScriptParserStrictLet, JavaScriptParserNonStrictLet:
		p.EnterOuterAlt(localctx, 35)
		{
			p.SetState(1081)
			p.Let_()
		}

	case JavaScriptParserPrivate:
		p.EnterOuterAlt(localctx, 36)
		{
			p.SetState(1082)
			p.Match(JavaScriptParserPrivate)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case JavaScriptParserPublic:
		p.EnterOuterAlt(localctx, 37)
		{
			p.SetState(1083)
			p.Match(JavaScriptParserPublic)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case JavaScriptParserInterface:
		p.EnterOuterAlt(localctx, 38)
		{
			p.SetState(1084)
			p.Match(JavaScriptParserInterface)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case JavaScriptParserPackage:
		p.EnterOuterAlt(localctx, 39)
		{
			p.SetState(1085)
			p.Match(JavaScriptParserPackage)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case JavaScriptParserProtected:
		p.EnterOuterAlt(localctx, 40)
		{
			p.SetState(1086)
			p.Match(JavaScriptParserProtected)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case JavaScriptParserStatic:
		p.EnterOuterAlt(localctx, 41)
		{
			p.SetState(1087)
			p.Match(JavaScriptParserStatic)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case JavaScriptParserYield:
		p.EnterOuterAlt(localctx, 42)
		{
			p.SetState(1088)
			p.Match(JavaScriptParserYield)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case JavaScriptParserAsync:
		p.EnterOuterAlt(localctx, 43)
		{
			p.SetState(1089)
			p.Match(JavaScriptParserAsync)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case JavaScriptParserAwait:
		p.EnterOuterAlt(localctx, 44)
		{
			p.SetState(1090)
			p.Match(JavaScriptParserAwait)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case JavaScriptParserFrom:
		p.EnterOuterAlt(localctx, 45)
		{
			p.SetState(1091)
			p.Match(JavaScriptParserFrom)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case JavaScriptParserAs:
		p.EnterOuterAlt(localctx, 46)
		{
			p.SetState(1092)
			p.Match(JavaScriptParserAs)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILet_Context is an interface to support dynamic dispatch.
type ILet_Context interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	NonStrictLet() antlr.TerminalNode
	StrictLet() antlr.TerminalNode

	// IsLet_Context differentiates from other interfaces.
	IsLet_Context()
}

type Let_Context struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLet_Context() *Let_Context {
	var p = new(Let_Context)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaScriptParserRULE_let_
	return p
}

func InitEmptyLet_Context(p *Let_Context) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaScriptParserRULE_let_
}

func (*Let_Context) IsLet_Context() {}

func NewLet_Context(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Let_Context {
	var p = new(Let_Context)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaScriptParserRULE_let_

	return p
}

func (s *Let_Context) GetParser() antlr.Parser { return s.parser }

func (s *Let_Context) NonStrictLet() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserNonStrictLet, 0)
}

func (s *Let_Context) StrictLet() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserStrictLet, 0)
}

func (s *Let_Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Let_Context) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Let_Context) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JavaScriptParserVisitor:
		return t.VisitLet_(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *JavaScriptParser) Let_() (localctx ILet_Context) {
	localctx = NewLet_Context(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 174, JavaScriptParserRULE_let_)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1095)
		_la = p.GetTokenStream().LA(1)

		if !(_la == JavaScriptParserStrictLet || _la == JavaScriptParserNonStrictLet) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IEosContext is an interface to support dynamic dispatch.
type IEosContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SemiColon() antlr.TerminalNode
	EOF() antlr.TerminalNode

	// IsEosContext differentiates from other interfaces.
	IsEosContext()
}

type EosContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEosContext() *EosContext {
	var p = new(EosContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaScriptParserRULE_eos
	return p
}

func InitEmptyEosContext(p *EosContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaScriptParserRULE_eos
}

func (*EosContext) IsEosContext() {}

func NewEosContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EosContext {
	var p = new(EosContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaScriptParserRULE_eos

	return p
}

func (s *EosContext) GetParser() antlr.Parser { return s.parser }

func (s *EosContext) SemiColon() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserSemiColon, 0)
}

func (s *EosContext) EOF() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserEOF, 0)
}

func (s *EosContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EosContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EosContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JavaScriptParserVisitor:
		return t.VisitEos(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *JavaScriptParser) Eos() (localctx IEosContext) {
	localctx = NewEosContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 176, JavaScriptParserRULE_eos)
	p.SetState(1101)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 119, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1097)
			p.Match(JavaScriptParserSemiColon)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1098)
			p.Match(JavaScriptParserEOF)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		p.SetState(1099)

		if !(p.lineTerminatorAhead()) {
			p.SetError(antlr.NewFailedPredicateException(p, "p.lineTerminatorAhead()", ""))
			goto errorExit
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		p.SetState(1100)

		if !(p.closeBrace()) {
			p.SetError(antlr.NewFailedPredicateException(p, "p.closeBrace()", ""))
			goto errorExit
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

func (p *JavaScriptParser) Sempred(localctx antlr.RuleContext, ruleIndex, predIndex int) bool {
	switch ruleIndex {
	case 24:
		var t *ExpressionStatementContext = nil
		if localctx != nil {
			t = localctx.(*ExpressionStatementContext)
		}
		return p.ExpressionStatement_Sempred(t, predIndex)

	case 29:
		var t *IterationStatementContext = nil
		if localctx != nil {
			t = localctx.(*IterationStatementContext)
		}
		return p.IterationStatement_Sempred(t, predIndex)

	case 31:
		var t *ContinueStatementContext = nil
		if localctx != nil {
			t = localctx.(*ContinueStatementContext)
		}
		return p.ContinueStatement_Sempred(t, predIndex)

	case 32:
		var t *BreakStatementContext = nil
		if localctx != nil {
			t = localctx.(*BreakStatementContext)
		}
		return p.BreakStatement_Sempred(t, predIndex)

	case 33:
		var t *ReturnStatementContext = nil
		if localctx != nil {
			t = localctx.(*ReturnStatementContext)
		}
		return p.ReturnStatement_Sempred(t, predIndex)

	case 34:
		var t *YieldStatementContext = nil
		if localctx != nil {
			t = localctx.(*YieldStatementContext)
		}
		return p.YieldStatement_Sempred(t, predIndex)

	case 42:
		var t *ThrowStatementContext = nil
		if localctx != nil {
			t = localctx.(*ThrowStatementContext)
		}
		return p.ThrowStatement_Sempred(t, predIndex)

	case 50:
		var t *ClassElementContext = nil
		if localctx != nil {
			t = localctx.(*ClassElementContext)
		}
		return p.ClassElement_Sempred(t, predIndex)

	case 51:
		var t *MethodDefinitionContext = nil
		if localctx != nil {
			t = localctx.(*MethodDefinitionContext)
		}
		return p.MethodDefinition_Sempred(t, predIndex)

	case 68:
		var t *SingleExpressionContext = nil
		if localctx != nil {
			t = localctx.(*SingleExpressionContext)
		}
		return p.SingleExpression_Sempred(t, predIndex)

	case 81:
		var t *GetterContext = nil
		if localctx != nil {
			t = localctx.(*GetterContext)
		}
		return p.Getter_Sempred(t, predIndex)

	case 82:
		var t *SetterContext = nil
		if localctx != nil {
			t = localctx.(*SetterContext)
		}
		return p.Setter_Sempred(t, predIndex)

	case 88:
		var t *EosContext = nil
		if localctx != nil {
			t = localctx.(*EosContext)
		}
		return p.Eos_Sempred(t, predIndex)

	default:
		panic("No predicate with index: " + fmt.Sprint(ruleIndex))
	}
}

func (p *JavaScriptParser) ExpressionStatement_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 0:
		return p.notOpenBraceAndNotFunction()

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *JavaScriptParser) IterationStatement_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 1:
		return p.p("of")

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *JavaScriptParser) ContinueStatement_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 2:
		return p.notLineTerminator()

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *JavaScriptParser) BreakStatement_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 3:
		return p.notLineTerminator()

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *JavaScriptParser) ReturnStatement_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 4:
		return p.notLineTerminator()

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *JavaScriptParser) YieldStatement_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 5:
		return p.notLineTerminator()

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *JavaScriptParser) ThrowStatement_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 6:
		return p.notLineTerminator()

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *JavaScriptParser) ClassElement_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 7:
		return p.n("static")

	case 8:
		return p.n("static")

	case 9:
		return p.n("static")

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *JavaScriptParser) MethodDefinition_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 10:
		return p.notLineTerminator()

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *JavaScriptParser) SingleExpression_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 11:
		return p.Precpred(p.GetParserRuleContext(), 46)

	case 12:
		return p.Precpred(p.GetParserRuleContext(), 27)

	case 13:
		return p.Precpred(p.GetParserRuleContext(), 26)

	case 14:
		return p.Precpred(p.GetParserRuleContext(), 25)

	case 15:
		return p.Precpred(p.GetParserRuleContext(), 24)

	case 16:
		return p.Precpred(p.GetParserRuleContext(), 23)

	case 17:
		return p.Precpred(p.GetParserRuleContext(), 22)

	case 18:
		return p.Precpred(p.GetParserRuleContext(), 21)

	case 19:
		return p.Precpred(p.GetParserRuleContext(), 20)

	case 20:
		return p.Precpred(p.GetParserRuleContext(), 19)

	case 21:
		return p.Precpred(p.GetParserRuleContext(), 18)

	case 22:
		return p.Precpred(p.GetParserRuleContext(), 17)

	case 23:
		return p.Precpred(p.GetParserRuleContext(), 16)

	case 24:
		return p.Precpred(p.GetParserRuleContext(), 15)

	case 25:
		return p.Precpred(p.GetParserRuleContext(), 14)

	case 26:
		return p.Precpred(p.GetParserRuleContext(), 13)

	case 27:
		return p.Precpred(p.GetParserRuleContext(), 12)

	case 28:
		return p.Precpred(p.GetParserRuleContext(), 11)

	case 29:
		return p.Precpred(p.GetParserRuleContext(), 45)

	case 30:
		return p.Precpred(p.GetParserRuleContext(), 44)

	case 31:
		return p.Precpred(p.GetParserRuleContext(), 41)

	case 32:
		return p.Precpred(p.GetParserRuleContext(), 39)

	case 33:
		return p.notLineTerminator()

	case 34:
		return p.Precpred(p.GetParserRuleContext(), 38)

	case 35:
		return p.notLineTerminator()

	case 36:
		return p.Precpred(p.GetParserRuleContext(), 9)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *JavaScriptParser) Getter_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 37:
		return p.n("get")

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *JavaScriptParser) Setter_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 38:
		return p.n("set")

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *JavaScriptParser) Eos_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 39:
		return p.lineTerminatorAhead()

	case 40:
		return p.closeBrace()

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}
