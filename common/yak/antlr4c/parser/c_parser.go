// Code generated from java-escape by ANTLR 4.11.1. DO NOT EDIT.

package c // CParser
import (
	"fmt"
	"strconv"
	"sync"

	"github.com/antlr/antlr4/runtime/Go/antlr/v4"
)

// Suppress unused import errors
var _ = fmt.Printf
var _ = strconv.Itoa
var _ = sync.Once{}

type CParser struct {
	*antlr.BaseParser
}

var cparserParserStaticData struct {
	once                   sync.Once
	serializedATN          []int32
	literalNames           []string
	symbolicNames          []string
	ruleNames              []string
	predictionContextCache *antlr.PredictionContextCache
	atn                    *antlr.ATN
	decisionToDFA          []*antlr.DFA
}

func cparserParserInit() {
	staticData := &cparserParserStaticData
	staticData.literalNames = []string{
		"", "'auto'", "'break'", "'case'", "'char'", "'const'", "'continue'",
		"'default'", "'do'", "'double'", "'long double'", "'else'", "'enum'",
		"'extern'", "'float'", "'for'", "'goto'", "'if'", "'inline'", "'int'",
		"'long'", "'long long'", "'register'", "'restrict'", "'return'", "'short'",
		"'signed'", "'sizeof'", "'static'", "'struct'", "'switch'", "'typedef'",
		"'union'", "'unsigned'", "'void'", "'volatile'", "'while'", "'_Alignas'",
		"'_Alignof'", "'_Atomic'", "'_Bool'", "'_Complex'", "'_Generic'", "'_Imaginary'",
		"'_Noreturn'", "'_Static_assert'", "'_Thread_local'", "'('", "')'",
		"'['", "']'", "'{'", "'}'", "'<'", "'<='", "'>'", "'>='", "'<<'", "'>>'",
		"'+'", "'++'", "'-'", "'--'", "'*'", "'/'", "'%'", "'&'", "'|'", "'&&'",
		"'||'", "'^'", "'!'", "'~'", "'?'", "':'", "';'", "','", "'='", "'*='",
		"'/='", "'%='", "'+='", "'-='", "'<<='", "'>>='", "'&='", "'^='", "'|='",
		"'=='", "'!='", "'->'", "'.'", "'...'", "", "'__attribute__'", "", "",
		"", "", "", "", "", "'__extension__'", "'__builtin_va_arg'", "'__builtin_offsetof'",
		"'__m128'", "'__m128d'", "'__m128i'", "'__typeof__'", "'__inline__'",
		"'__stdcall'", "'__declspec'", "'__cdecl'", "'__clrcall'", "'__fastcall'",
		"'__thiscall'", "'__vectorcall'", "'__volatile__'",
	}
	staticData.symbolicNames = []string{
		"", "Auto", "Break", "Case", "Char", "Const", "Continue", "Default",
		"Do", "Double", "Longdouble", "Else", "Enum", "Extern", "Float", "For",
		"Goto", "If", "Inline", "Int", "Long", "Longlong", "Register", "Restrict",
		"Return", "Short", "Signed", "Sizeof", "Static", "Struct", "Switch",
		"Typedef", "Union", "Unsigned", "Void", "Volatile", "While", "Alignas",
		"Alignof", "Atomic", "Bool", "Complex", "Generic", "Imaginary", "Noreturn",
		"StaticAssert", "ThreadLocal", "LeftParen", "RightParen", "LeftBracket",
		"RightBracket", "LeftBrace", "RightBrace", "Less", "LessEqual", "Greater",
		"GreaterEqual", "LeftShift", "RightShift", "Plus", "PlusPlus", "Minus",
		"MinusMinus", "Star", "Div", "Mod", "And", "Or", "AndAnd", "OrOr", "Caret",
		"Not", "Tilde", "Question", "Colon", "Semi", "Comma", "Assign", "StarAssign",
		"DivAssign", "ModAssign", "PlusAssign", "MinusAssign", "LeftShiftAssign",
		"RightShiftAssign", "AndAssign", "XorAssign", "OrAssign", "Equal", "NotEqual",
		"Arrow", "Dot", "Ellipsis", "Asm", "Attribute__", "Identifier", "Constant",
		"DigitSequence", "StringLiteral", "WS", "LINE_COMMENT", "BLOCK_COMMENT",
		"Extension", "BuiltinVaArg", "BuiltinOffsetof", "M128", "M128d", "M128i",
		"Typeof", "Inline__", "Stdcall", "Declspec", "Cdecl", "Clrcall", "Fastcall",
		"Thiscall", "Vectorcall", "Volatile__", "MultiLineMacro", "Directive",
		"AsmBlock", "Whitespace", "Newline", "BlockComment", "LineComment",
	}
	staticData.ruleNames = []string{
		"primaryExpression", "genericSelection", "genericAssocList", "genericAssociation",
		"postfixExpression", "postfixExpressionLvalue", "argumentExpressionList",
		"unaryExpression", "castExpression", "assignmentExpression", "assignmentOperator",
		"expressionList", "statementsExpression", "leftExpression", "expression",
		"declaration", "declarationSpecifiers", "declarationSpecifiers2", "declarationSpecifier",
		"initDeclaratorList", "initDeclarator", "storageClassSpecifier", "typeSpecifier",
		"structOrUnionSpecifier", "structOrUnion", "structDeclarationList",
		"structDeclaration", "specifierQualifierList", "structDeclaratorList",
		"structDeclarator", "enumSpecifier", "enumeratorList", "enumerator",
		"atomicTypeSpecifier", "typeQualifier", "functionSpecifier", "alignmentSpecifier",
		"declarator", "directDeclarator", "vcSpecificModifer", "gccDeclaratorExtension",
		"gccAttributeSpecifier", "gccAttributeList", "gccAttribute", "pointer",
		"pointerPart", "typeQualifierList", "parameterTypeList", "parameterList",
		"parameterDeclaration", "identifierList", "typeName", "abstractDeclarator",
		"directAbstractDeclarator", "typedefName", "initializer", "initializerList",
		"designation", "designatorList", "designator", "staticAssertDeclaration",
		"statement", "asmStatement", "asmExprList", "labeledStatement", "compoundStatement",
		"blockItemList", "blockItem", "expressionStatement", "selectionStatement",
		"iterationStatement", "forCondition", "assignmentExpressions", "forDeclarations",
		"forDeclaration", "forExpression", "jumpStatement", "compilationUnit",
		"translationUnit", "externalDeclaration", "functionDefinition", "declarationList",
	}
	staticData.predictionContextCache = antlr.NewPredictionContextCache()
	staticData.serializedATN = []int32{
		4, 1, 124, 1199, 2, 0, 7, 0, 2, 1, 7, 1, 2, 2, 7, 2, 2, 3, 7, 3, 2, 4,
		7, 4, 2, 5, 7, 5, 2, 6, 7, 6, 2, 7, 7, 7, 2, 8, 7, 8, 2, 9, 7, 9, 2, 10,
		7, 10, 2, 11, 7, 11, 2, 12, 7, 12, 2, 13, 7, 13, 2, 14, 7, 14, 2, 15, 7,
		15, 2, 16, 7, 16, 2, 17, 7, 17, 2, 18, 7, 18, 2, 19, 7, 19, 2, 20, 7, 20,
		2, 21, 7, 21, 2, 22, 7, 22, 2, 23, 7, 23, 2, 24, 7, 24, 2, 25, 7, 25, 2,
		26, 7, 26, 2, 27, 7, 27, 2, 28, 7, 28, 2, 29, 7, 29, 2, 30, 7, 30, 2, 31,
		7, 31, 2, 32, 7, 32, 2, 33, 7, 33, 2, 34, 7, 34, 2, 35, 7, 35, 2, 36, 7,
		36, 2, 37, 7, 37, 2, 38, 7, 38, 2, 39, 7, 39, 2, 40, 7, 40, 2, 41, 7, 41,
		2, 42, 7, 42, 2, 43, 7, 43, 2, 44, 7, 44, 2, 45, 7, 45, 2, 46, 7, 46, 2,
		47, 7, 47, 2, 48, 7, 48, 2, 49, 7, 49, 2, 50, 7, 50, 2, 51, 7, 51, 2, 52,
		7, 52, 2, 53, 7, 53, 2, 54, 7, 54, 2, 55, 7, 55, 2, 56, 7, 56, 2, 57, 7,
		57, 2, 58, 7, 58, 2, 59, 7, 59, 2, 60, 7, 60, 2, 61, 7, 61, 2, 62, 7, 62,
		2, 63, 7, 63, 2, 64, 7, 64, 2, 65, 7, 65, 2, 66, 7, 66, 2, 67, 7, 67, 2,
		68, 7, 68, 2, 69, 7, 69, 2, 70, 7, 70, 2, 71, 7, 71, 2, 72, 7, 72, 2, 73,
		7, 73, 2, 74, 7, 74, 2, 75, 7, 75, 2, 76, 7, 76, 2, 77, 7, 77, 2, 78, 7,
		78, 2, 79, 7, 79, 2, 80, 7, 80, 2, 81, 7, 81, 1, 0, 1, 0, 1, 0, 4, 0, 168,
		8, 0, 11, 0, 12, 0, 169, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 3, 0, 178,
		8, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0,
		1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 3, 0, 198, 8, 0, 1, 1, 1, 1,
		1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 2, 1, 2, 5, 2, 210, 8, 2, 10, 2,
		12, 2, 213, 9, 2, 1, 3, 1, 3, 3, 3, 217, 8, 3, 1, 3, 1, 3, 1, 3, 1, 4,
		1, 4, 1, 4, 3, 4, 225, 8, 4, 1, 4, 1, 4, 1, 4, 1, 4, 1, 4, 1, 4, 3, 4,
		233, 8, 4, 1, 4, 1, 4, 3, 4, 237, 8, 4, 1, 4, 1, 4, 1, 4, 1, 4, 1, 4, 1,
		4, 3, 4, 245, 8, 4, 1, 4, 1, 4, 1, 4, 1, 4, 1, 4, 1, 4, 1, 4, 1, 4, 3,
		4, 255, 8, 4, 1, 4, 1, 4, 1, 4, 1, 4, 5, 4, 261, 8, 4, 10, 4, 12, 4, 264,
		9, 4, 1, 5, 1, 5, 1, 5, 3, 5, 269, 8, 5, 1, 5, 1, 5, 1, 5, 1, 5, 1, 5,
		1, 5, 3, 5, 277, 8, 5, 1, 5, 1, 5, 3, 5, 281, 8, 5, 1, 5, 1, 5, 1, 5, 1,
		5, 1, 5, 1, 5, 1, 5, 1, 5, 5, 5, 291, 8, 5, 10, 5, 12, 5, 294, 9, 5, 1,
		6, 1, 6, 1, 6, 5, 6, 299, 8, 6, 10, 6, 12, 6, 302, 9, 6, 1, 7, 1, 7, 1,
		7, 1, 7, 1, 7, 1, 7, 1, 7, 1, 7, 1, 7, 5, 7, 313, 8, 7, 10, 7, 12, 7, 316,
		9, 7, 1, 7, 1, 7, 1, 7, 1, 7, 1, 7, 1, 7, 3, 7, 324, 8, 7, 1, 8, 3, 8,
		327, 8, 8, 1, 8, 1, 8, 1, 8, 1, 8, 1, 8, 1, 8, 1, 8, 3, 8, 336, 8, 8, 1,
		9, 1, 9, 1, 9, 1, 9, 1, 9, 1, 9, 3, 9, 344, 8, 9, 1, 10, 1, 10, 1, 11,
		1, 11, 1, 11, 5, 11, 351, 8, 11, 10, 11, 12, 11, 354, 9, 11, 1, 12, 1,
		12, 1, 12, 5, 12, 359, 8, 12, 10, 12, 12, 12, 362, 9, 12, 1, 12, 3, 12,
		365, 8, 12, 1, 12, 3, 12, 368, 8, 12, 1, 12, 1, 12, 1, 12, 1, 13, 1, 13,
		1, 13, 1, 13, 1, 13, 1, 13, 1, 13, 3, 13, 380, 8, 13, 1, 14, 1, 14, 1,
		14, 1, 14, 1, 14, 1, 14, 1, 14, 1, 14, 1, 14, 1, 14, 1, 14, 3, 14, 393,
		8, 14, 1, 14, 1, 14, 1, 14, 1, 14, 1, 14, 1, 14, 1, 14, 1, 14, 1, 14, 1,
		14, 1, 14, 1, 14, 1, 14, 1, 14, 1, 14, 1, 14, 1, 14, 1, 14, 1, 14, 1, 14,
		1, 14, 5, 14, 416, 8, 14, 10, 14, 12, 14, 419, 9, 14, 1, 15, 1, 15, 3,
		15, 423, 8, 15, 1, 15, 1, 15, 1, 15, 3, 15, 428, 8, 15, 1, 16, 1, 16, 1,
		16, 3, 16, 433, 8, 16, 1, 17, 1, 17, 1, 17, 3, 17, 438, 8, 17, 1, 18, 1,
		18, 1, 18, 5, 18, 443, 8, 18, 10, 18, 12, 18, 446, 9, 18, 1, 18, 3, 18,
		449, 8, 18, 1, 18, 1, 18, 3, 18, 453, 8, 18, 1, 18, 5, 18, 456, 8, 18,
		10, 18, 12, 18, 459, 9, 18, 1, 18, 3, 18, 462, 8, 18, 1, 19, 1, 19, 1,
		19, 5, 19, 467, 8, 19, 10, 19, 12, 19, 470, 9, 19, 1, 20, 1, 20, 1, 20,
		3, 20, 475, 8, 20, 1, 21, 1, 21, 1, 22, 1, 22, 1, 22, 1, 22, 1, 22, 1,
		22, 1, 22, 1, 22, 1, 22, 1, 22, 1, 22, 1, 22, 1, 22, 1, 22, 1, 22, 1, 22,
		1, 22, 1, 22, 1, 22, 1, 22, 1, 22, 1, 22, 1, 22, 1, 22, 1, 22, 1, 22, 1,
		22, 3, 22, 506, 8, 22, 1, 23, 1, 23, 3, 23, 510, 8, 23, 1, 23, 1, 23, 1,
		23, 1, 23, 3, 23, 516, 8, 23, 1, 24, 1, 24, 1, 25, 4, 25, 521, 8, 25, 11,
		25, 12, 25, 522, 1, 26, 1, 26, 1, 26, 1, 26, 1, 26, 1, 26, 1, 26, 1, 26,
		3, 26, 533, 8, 26, 1, 27, 1, 27, 3, 27, 537, 8, 27, 1, 27, 3, 27, 540,
		8, 27, 1, 28, 1, 28, 1, 28, 5, 28, 545, 8, 28, 10, 28, 12, 28, 548, 9,
		28, 1, 29, 1, 29, 3, 29, 552, 8, 29, 1, 29, 1, 29, 3, 29, 556, 8, 29, 1,
		30, 1, 30, 3, 30, 560, 8, 30, 1, 30, 1, 30, 1, 30, 3, 30, 565, 8, 30, 1,
		30, 1, 30, 1, 30, 1, 30, 3, 30, 571, 8, 30, 1, 31, 1, 31, 1, 31, 5, 31,
		576, 8, 31, 10, 31, 12, 31, 579, 9, 31, 1, 32, 1, 32, 1, 32, 1, 32, 3,
		32, 585, 8, 32, 1, 32, 1, 32, 1, 32, 3, 32, 590, 8, 32, 3, 32, 592, 8,
		32, 1, 33, 1, 33, 1, 33, 1, 33, 1, 33, 1, 34, 1, 34, 1, 35, 1, 35, 1, 35,
		1, 35, 1, 35, 1, 35, 1, 35, 1, 35, 1, 35, 3, 35, 610, 8, 35, 1, 36, 1,
		36, 1, 36, 1, 36, 3, 36, 616, 8, 36, 1, 36, 1, 36, 1, 37, 3, 37, 621, 8,
		37, 1, 37, 1, 37, 5, 37, 625, 8, 37, 10, 37, 12, 37, 628, 9, 37, 1, 38,
		1, 38, 1, 38, 1, 38, 1, 38, 1, 38, 1, 38, 1, 38, 1, 38, 1, 38, 1, 38, 1,
		38, 1, 38, 1, 38, 1, 38, 1, 38, 1, 38, 3, 38, 647, 8, 38, 1, 38, 1, 38,
		1, 38, 3, 38, 652, 8, 38, 1, 38, 3, 38, 655, 8, 38, 1, 38, 1, 38, 1, 38,
		1, 38, 1, 38, 3, 38, 662, 8, 38, 1, 38, 1, 38, 1, 38, 1, 38, 1, 38, 1,
		38, 1, 38, 1, 38, 1, 38, 1, 38, 1, 38, 1, 38, 1, 38, 3, 38, 677, 8, 38,
		1, 38, 1, 38, 1, 38, 1, 38, 1, 38, 1, 38, 1, 38, 1, 38, 1, 38, 1, 38, 3,
		38, 689, 8, 38, 1, 38, 5, 38, 692, 8, 38, 10, 38, 12, 38, 695, 9, 38, 1,
		39, 1, 39, 1, 40, 1, 40, 1, 40, 1, 40, 1, 40, 1, 40, 1, 40, 3, 40, 706,
		8, 40, 3, 40, 708, 8, 40, 1, 41, 1, 41, 1, 41, 1, 41, 3, 41, 714, 8, 41,
		1, 41, 1, 41, 1, 41, 1, 42, 1, 42, 1, 42, 5, 42, 722, 8, 42, 10, 42, 12,
		42, 725, 9, 42, 1, 43, 1, 43, 1, 43, 3, 43, 730, 8, 43, 1, 43, 3, 43, 733,
		8, 43, 1, 43, 1, 43, 1, 43, 3, 43, 738, 8, 43, 1, 43, 3, 43, 741, 8, 43,
		3, 43, 743, 8, 43, 1, 44, 4, 44, 746, 8, 44, 11, 44, 12, 44, 747, 1, 45,
		1, 45, 3, 45, 752, 8, 45, 1, 46, 4, 46, 755, 8, 46, 11, 46, 12, 46, 756,
		1, 47, 1, 47, 1, 47, 3, 47, 762, 8, 47, 3, 47, 764, 8, 47, 1, 48, 1, 48,
		1, 48, 5, 48, 769, 8, 48, 10, 48, 12, 48, 772, 9, 48, 1, 49, 1, 49, 1,
		49, 1, 49, 1, 49, 3, 49, 779, 8, 49, 3, 49, 781, 8, 49, 1, 50, 1, 50, 1,
		50, 5, 50, 786, 8, 50, 10, 50, 12, 50, 789, 9, 50, 1, 51, 1, 51, 1, 51,
		3, 51, 794, 8, 51, 1, 51, 1, 51, 1, 51, 5, 51, 799, 8, 51, 10, 51, 12,
		51, 802, 9, 51, 1, 52, 1, 52, 3, 52, 806, 8, 52, 1, 52, 1, 52, 5, 52, 810,
		8, 52, 10, 52, 12, 52, 813, 9, 52, 3, 52, 815, 8, 52, 1, 53, 1, 53, 1,
		53, 1, 53, 1, 53, 5, 53, 822, 8, 53, 10, 53, 12, 53, 825, 9, 53, 1, 53,
		1, 53, 3, 53, 829, 8, 53, 1, 53, 3, 53, 832, 8, 53, 1, 53, 1, 53, 1, 53,
		1, 53, 3, 53, 838, 8, 53, 1, 53, 1, 53, 1, 53, 1, 53, 1, 53, 1, 53, 1,
		53, 1, 53, 1, 53, 1, 53, 1, 53, 1, 53, 1, 53, 1, 53, 3, 53, 854, 8, 53,
		1, 53, 1, 53, 5, 53, 858, 8, 53, 10, 53, 12, 53, 861, 9, 53, 3, 53, 863,
		8, 53, 1, 53, 1, 53, 1, 53, 3, 53, 868, 8, 53, 1, 53, 3, 53, 871, 8, 53,
		1, 53, 1, 53, 1, 53, 1, 53, 1, 53, 3, 53, 878, 8, 53, 1, 53, 1, 53, 1,
		53, 1, 53, 1, 53, 1, 53, 1, 53, 1, 53, 1, 53, 1, 53, 1, 53, 1, 53, 1, 53,
		1, 53, 1, 53, 1, 53, 1, 53, 3, 53, 897, 8, 53, 1, 53, 1, 53, 5, 53, 901,
		8, 53, 10, 53, 12, 53, 904, 9, 53, 5, 53, 906, 8, 53, 10, 53, 12, 53, 909,
		9, 53, 1, 54, 3, 54, 912, 8, 54, 1, 54, 1, 54, 1, 55, 1, 55, 1, 55, 3,
		55, 919, 8, 55, 1, 55, 3, 55, 922, 8, 55, 1, 55, 3, 55, 925, 8, 55, 1,
		56, 3, 56, 928, 8, 56, 1, 56, 1, 56, 1, 56, 3, 56, 933, 8, 56, 1, 56, 5,
		56, 936, 8, 56, 10, 56, 12, 56, 939, 9, 56, 1, 57, 1, 57, 1, 57, 1, 58,
		4, 58, 945, 8, 58, 11, 58, 12, 58, 946, 1, 59, 1, 59, 1, 59, 1, 59, 1,
		59, 1, 59, 3, 59, 955, 8, 59, 1, 60, 1, 60, 1, 60, 1, 60, 1, 60, 4, 60,
		962, 8, 60, 11, 60, 12, 60, 963, 1, 60, 1, 60, 1, 60, 1, 61, 1, 61, 1,
		61, 3, 61, 972, 8, 61, 1, 61, 1, 61, 1, 61, 1, 61, 1, 61, 1, 61, 1, 61,
		1, 61, 3, 61, 982, 8, 61, 1, 62, 1, 62, 3, 62, 986, 8, 62, 1, 62, 1, 62,
		3, 62, 990, 8, 62, 1, 62, 1, 62, 3, 62, 994, 8, 62, 1, 62, 1, 62, 3, 62,
		998, 8, 62, 1, 62, 1, 62, 3, 62, 1002, 8, 62, 3, 62, 1004, 8, 62, 3, 62,
		1006, 8, 62, 3, 62, 1008, 8, 62, 1, 62, 1, 62, 1, 62, 1, 63, 1, 63, 1,
		63, 5, 63, 1016, 8, 63, 10, 63, 12, 63, 1019, 9, 63, 1, 64, 1, 64, 1, 64,
		1, 64, 5, 64, 1025, 8, 64, 10, 64, 12, 64, 1028, 9, 64, 1, 64, 1, 64, 1,
		64, 5, 64, 1033, 8, 64, 10, 64, 12, 64, 1036, 9, 64, 3, 64, 1038, 8, 64,
		1, 65, 1, 65, 3, 65, 1042, 8, 65, 1, 65, 1, 65, 1, 66, 4, 66, 1047, 8,
		66, 11, 66, 12, 66, 1048, 1, 67, 1, 67, 3, 67, 1053, 8, 67, 1, 68, 1, 68,
		1, 68, 1, 69, 1, 69, 1, 69, 1, 69, 1, 69, 1, 69, 1, 69, 3, 69, 1065, 8,
		69, 1, 69, 1, 69, 1, 69, 1, 69, 1, 69, 1, 69, 5, 69, 1073, 8, 69, 10, 69,
		12, 69, 1076, 9, 69, 1, 69, 1, 69, 3, 69, 1080, 8, 69, 1, 70, 1, 70, 1,
		70, 1, 70, 1, 70, 3, 70, 1087, 8, 70, 1, 70, 1, 70, 1, 70, 1, 70, 1, 70,
		1, 70, 1, 70, 1, 70, 1, 70, 3, 70, 1098, 8, 70, 1, 70, 1, 70, 1, 70, 1,
		70, 1, 70, 1, 70, 3, 70, 1106, 8, 70, 1, 71, 1, 71, 3, 71, 1110, 8, 71,
		3, 71, 1112, 8, 71, 1, 71, 1, 71, 3, 71, 1116, 8, 71, 1, 71, 1, 71, 3,
		71, 1120, 8, 71, 1, 72, 1, 72, 1, 72, 5, 72, 1125, 8, 72, 10, 72, 12, 72,
		1128, 9, 72, 1, 73, 1, 73, 1, 73, 5, 73, 1133, 8, 73, 10, 73, 12, 73, 1136,
		9, 73, 1, 74, 1, 74, 3, 74, 1140, 8, 74, 1, 75, 1, 75, 1, 75, 5, 75, 1145,
		8, 75, 10, 75, 12, 75, 1148, 9, 75, 1, 76, 1, 76, 5, 76, 1152, 8, 76, 10,
		76, 12, 76, 1155, 9, 76, 1, 76, 1, 76, 1, 76, 1, 76, 1, 76, 3, 76, 1162,
		8, 76, 3, 76, 1164, 8, 76, 1, 76, 1, 76, 1, 77, 3, 77, 1169, 8, 77, 1,
		77, 1, 77, 1, 78, 4, 78, 1174, 8, 78, 11, 78, 12, 78, 1175, 1, 79, 1, 79,
		1, 79, 1, 79, 3, 79, 1182, 8, 79, 1, 80, 3, 80, 1185, 8, 80, 1, 80, 1,
		80, 3, 80, 1189, 8, 80, 1, 80, 3, 80, 1192, 8, 80, 1, 81, 4, 81, 1195,
		8, 81, 11, 81, 12, 81, 1196, 1, 81, 0, 6, 8, 10, 28, 76, 102, 106, 82,
		0, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30, 32, 34, 36,
		38, 40, 42, 44, 46, 48, 50, 52, 54, 56, 58, 60, 62, 64, 66, 68, 70, 72,
		74, 76, 78, 80, 82, 84, 86, 88, 90, 92, 94, 96, 98, 100, 102, 104, 106,
		108, 110, 112, 114, 116, 118, 120, 122, 124, 126, 128, 130, 132, 134, 136,
		138, 140, 142, 144, 146, 148, 150, 152, 154, 156, 158, 160, 162, 0, 16,
		1, 0, 90, 91, 2, 0, 60, 60, 62, 62, 2, 0, 27, 27, 38, 38, 1, 0, 77, 87,
		5, 0, 59, 59, 61, 61, 63, 63, 66, 66, 70, 72, 2, 0, 57, 58, 63, 66, 4,
		0, 59, 59, 61, 61, 67, 67, 70, 70, 2, 0, 53, 56, 88, 89, 6, 0, 1, 1, 13,
		13, 22, 22, 28, 28, 31, 31, 46, 46, 1, 0, 105, 107, 2, 0, 29, 29, 32, 32,
		6, 0, 5, 5, 23, 23, 26, 26, 33, 33, 35, 35, 39, 39, 2, 0, 110, 110, 112,
		116, 2, 0, 47, 48, 76, 76, 2, 0, 63, 63, 70, 70, 2, 0, 35, 35, 117, 117,
		1350, 0, 197, 1, 0, 0, 0, 2, 199, 1, 0, 0, 0, 4, 206, 1, 0, 0, 0, 6, 216,
		1, 0, 0, 0, 8, 244, 1, 0, 0, 0, 10, 265, 1, 0, 0, 0, 12, 295, 1, 0, 0,
		0, 14, 323, 1, 0, 0, 0, 16, 335, 1, 0, 0, 0, 18, 343, 1, 0, 0, 0, 20, 345,
		1, 0, 0, 0, 22, 347, 1, 0, 0, 0, 24, 355, 1, 0, 0, 0, 26, 379, 1, 0, 0,
		0, 28, 392, 1, 0, 0, 0, 30, 427, 1, 0, 0, 0, 32, 429, 1, 0, 0, 0, 34, 434,
		1, 0, 0, 0, 36, 461, 1, 0, 0, 0, 38, 463, 1, 0, 0, 0, 40, 471, 1, 0, 0,
		0, 42, 476, 1, 0, 0, 0, 44, 505, 1, 0, 0, 0, 46, 507, 1, 0, 0, 0, 48, 517,
		1, 0, 0, 0, 50, 520, 1, 0, 0, 0, 52, 532, 1, 0, 0, 0, 54, 536, 1, 0, 0,
		0, 56, 541, 1, 0, 0, 0, 58, 555, 1, 0, 0, 0, 60, 570, 1, 0, 0, 0, 62, 572,
		1, 0, 0, 0, 64, 591, 1, 0, 0, 0, 66, 593, 1, 0, 0, 0, 68, 598, 1, 0, 0,
		0, 70, 609, 1, 0, 0, 0, 72, 611, 1, 0, 0, 0, 74, 620, 1, 0, 0, 0, 76, 646,
		1, 0, 0, 0, 78, 696, 1, 0, 0, 0, 80, 707, 1, 0, 0, 0, 82, 709, 1, 0, 0,
		0, 84, 718, 1, 0, 0, 0, 86, 742, 1, 0, 0, 0, 88, 745, 1, 0, 0, 0, 90, 749,
		1, 0, 0, 0, 92, 754, 1, 0, 0, 0, 94, 758, 1, 0, 0, 0, 96, 765, 1, 0, 0,
		0, 98, 780, 1, 0, 0, 0, 100, 782, 1, 0, 0, 0, 102, 790, 1, 0, 0, 0, 104,
		814, 1, 0, 0, 0, 106, 862, 1, 0, 0, 0, 108, 911, 1, 0, 0, 0, 110, 924,
		1, 0, 0, 0, 112, 927, 1, 0, 0, 0, 114, 940, 1, 0, 0, 0, 116, 944, 1, 0,
		0, 0, 118, 954, 1, 0, 0, 0, 120, 956, 1, 0, 0, 0, 122, 981, 1, 0, 0, 0,
		124, 983, 1, 0, 0, 0, 126, 1012, 1, 0, 0, 0, 128, 1037, 1, 0, 0, 0, 130,
		1039, 1, 0, 0, 0, 132, 1046, 1, 0, 0, 0, 134, 1052, 1, 0, 0, 0, 136, 1054,
		1, 0, 0, 0, 138, 1079, 1, 0, 0, 0, 140, 1105, 1, 0, 0, 0, 142, 1111, 1,
		0, 0, 0, 144, 1121, 1, 0, 0, 0, 146, 1129, 1, 0, 0, 0, 148, 1137, 1, 0,
		0, 0, 150, 1141, 1, 0, 0, 0, 152, 1163, 1, 0, 0, 0, 154, 1168, 1, 0, 0,
		0, 156, 1173, 1, 0, 0, 0, 158, 1181, 1, 0, 0, 0, 160, 1184, 1, 0, 0, 0,
		162, 1194, 1, 0, 0, 0, 164, 198, 5, 95, 0, 0, 165, 198, 5, 96, 0, 0, 166,
		168, 5, 98, 0, 0, 167, 166, 1, 0, 0, 0, 168, 169, 1, 0, 0, 0, 169, 167,
		1, 0, 0, 0, 169, 170, 1, 0, 0, 0, 170, 198, 1, 0, 0, 0, 171, 172, 5, 47,
		0, 0, 172, 173, 3, 28, 14, 0, 173, 174, 5, 48, 0, 0, 174, 198, 1, 0, 0,
		0, 175, 198, 3, 2, 1, 0, 176, 178, 5, 102, 0, 0, 177, 176, 1, 0, 0, 0,
		177, 178, 1, 0, 0, 0, 178, 179, 1, 0, 0, 0, 179, 180, 5, 47, 0, 0, 180,
		181, 3, 130, 65, 0, 181, 182, 5, 48, 0, 0, 182, 198, 1, 0, 0, 0, 183, 184,
		5, 103, 0, 0, 184, 185, 5, 47, 0, 0, 185, 186, 3, 14, 7, 0, 186, 187, 5,
		76, 0, 0, 187, 188, 3, 102, 51, 0, 188, 189, 5, 48, 0, 0, 189, 198, 1,
		0, 0, 0, 190, 191, 5, 104, 0, 0, 191, 192, 5, 47, 0, 0, 192, 193, 3, 102,
		51, 0, 193, 194, 5, 76, 0, 0, 194, 195, 3, 14, 7, 0, 195, 196, 5, 48, 0,
		0, 196, 198, 1, 0, 0, 0, 197, 164, 1, 0, 0, 0, 197, 165, 1, 0, 0, 0, 197,
		167, 1, 0, 0, 0, 197, 171, 1, 0, 0, 0, 197, 175, 1, 0, 0, 0, 197, 177,
		1, 0, 0, 0, 197, 183, 1, 0, 0, 0, 197, 190, 1, 0, 0, 0, 198, 1, 1, 0, 0,
		0, 199, 200, 5, 42, 0, 0, 200, 201, 5, 47, 0, 0, 201, 202, 3, 18, 9, 0,
		202, 203, 5, 76, 0, 0, 203, 204, 3, 4, 2, 0, 204, 205, 5, 48, 0, 0, 205,
		3, 1, 0, 0, 0, 206, 211, 3, 6, 3, 0, 207, 208, 5, 76, 0, 0, 208, 210, 3,
		6, 3, 0, 209, 207, 1, 0, 0, 0, 210, 213, 1, 0, 0, 0, 211, 209, 1, 0, 0,
		0, 211, 212, 1, 0, 0, 0, 212, 5, 1, 0, 0, 0, 213, 211, 1, 0, 0, 0, 214,
		217, 3, 102, 51, 0, 215, 217, 5, 7, 0, 0, 216, 214, 1, 0, 0, 0, 216, 215,
		1, 0, 0, 0, 217, 218, 1, 0, 0, 0, 218, 219, 5, 74, 0, 0, 219, 220, 3, 18,
		9, 0, 220, 7, 1, 0, 0, 0, 221, 236, 6, 4, -1, 0, 222, 237, 3, 0, 0, 0,
		223, 225, 5, 102, 0, 0, 224, 223, 1, 0, 0, 0, 224, 225, 1, 0, 0, 0, 225,
		226, 1, 0, 0, 0, 226, 227, 5, 47, 0, 0, 227, 228, 3, 102, 51, 0, 228, 229,
		5, 48, 0, 0, 229, 230, 5, 51, 0, 0, 230, 232, 3, 112, 56, 0, 231, 233,
		5, 76, 0, 0, 232, 231, 1, 0, 0, 0, 232, 233, 1, 0, 0, 0, 233, 234, 1, 0,
		0, 0, 234, 235, 5, 52, 0, 0, 235, 237, 1, 0, 0, 0, 236, 222, 1, 0, 0, 0,
		236, 224, 1, 0, 0, 0, 237, 245, 1, 0, 0, 0, 238, 239, 3, 26, 13, 0, 239,
		240, 5, 60, 0, 0, 240, 245, 1, 0, 0, 0, 241, 242, 3, 26, 13, 0, 242, 243,
		5, 62, 0, 0, 243, 245, 1, 0, 0, 0, 244, 221, 1, 0, 0, 0, 244, 238, 1, 0,
		0, 0, 244, 241, 1, 0, 0, 0, 245, 262, 1, 0, 0, 0, 246, 247, 10, 5, 0, 0,
		247, 248, 5, 49, 0, 0, 248, 249, 3, 28, 14, 0, 249, 250, 5, 50, 0, 0, 250,
		261, 1, 0, 0, 0, 251, 252, 10, 4, 0, 0, 252, 254, 5, 47, 0, 0, 253, 255,
		3, 12, 6, 0, 254, 253, 1, 0, 0, 0, 254, 255, 1, 0, 0, 0, 255, 256, 1, 0,
		0, 0, 256, 261, 5, 48, 0, 0, 257, 258, 10, 3, 0, 0, 258, 259, 7, 0, 0,
		0, 259, 261, 5, 95, 0, 0, 260, 246, 1, 0, 0, 0, 260, 251, 1, 0, 0, 0, 260,
		257, 1, 0, 0, 0, 261, 264, 1, 0, 0, 0, 262, 260, 1, 0, 0, 0, 262, 263,
		1, 0, 0, 0, 263, 9, 1, 0, 0, 0, 264, 262, 1, 0, 0, 0, 265, 280, 6, 5, -1,
		0, 266, 281, 3, 0, 0, 0, 267, 269, 5, 102, 0, 0, 268, 267, 1, 0, 0, 0,
		268, 269, 1, 0, 0, 0, 269, 270, 1, 0, 0, 0, 270, 271, 5, 47, 0, 0, 271,
		272, 3, 102, 51, 0, 272, 273, 5, 48, 0, 0, 273, 274, 5, 51, 0, 0, 274,
		276, 3, 112, 56, 0, 275, 277, 5, 76, 0, 0, 276, 275, 1, 0, 0, 0, 276, 277,
		1, 0, 0, 0, 277, 278, 1, 0, 0, 0, 278, 279, 5, 52, 0, 0, 279, 281, 1, 0,
		0, 0, 280, 266, 1, 0, 0, 0, 280, 268, 1, 0, 0, 0, 281, 292, 1, 0, 0, 0,
		282, 283, 10, 2, 0, 0, 283, 284, 5, 49, 0, 0, 284, 285, 3, 28, 14, 0, 285,
		286, 5, 50, 0, 0, 286, 291, 1, 0, 0, 0, 287, 288, 10, 1, 0, 0, 288, 289,
		7, 0, 0, 0, 289, 291, 5, 95, 0, 0, 290, 282, 1, 0, 0, 0, 290, 287, 1, 0,
		0, 0, 291, 294, 1, 0, 0, 0, 292, 290, 1, 0, 0, 0, 292, 293, 1, 0, 0, 0,
		293, 11, 1, 0, 0, 0, 294, 292, 1, 0, 0, 0, 295, 300, 3, 28, 14, 0, 296,
		297, 5, 76, 0, 0, 297, 299, 3, 28, 14, 0, 298, 296, 1, 0, 0, 0, 299, 302,
		1, 0, 0, 0, 300, 298, 1, 0, 0, 0, 300, 301, 1, 0, 0, 0, 301, 13, 1, 0,
		0, 0, 302, 300, 1, 0, 0, 0, 303, 304, 7, 1, 0, 0, 304, 324, 3, 26, 13,
		0, 305, 306, 5, 63, 0, 0, 306, 324, 3, 14, 7, 0, 307, 308, 5, 66, 0, 0,
		308, 324, 3, 26, 13, 0, 309, 310, 7, 2, 0, 0, 310, 314, 5, 47, 0, 0, 311,
		313, 5, 63, 0, 0, 312, 311, 1, 0, 0, 0, 313, 316, 1, 0, 0, 0, 314, 312,
		1, 0, 0, 0, 314, 315, 1, 0, 0, 0, 315, 317, 1, 0, 0, 0, 316, 314, 1, 0,
		0, 0, 317, 318, 3, 102, 51, 0, 318, 319, 5, 48, 0, 0, 319, 324, 1, 0, 0,
		0, 320, 321, 5, 68, 0, 0, 321, 324, 3, 14, 7, 0, 322, 324, 3, 8, 4, 0,
		323, 303, 1, 0, 0, 0, 323, 305, 1, 0, 0, 0, 323, 307, 1, 0, 0, 0, 323,
		309, 1, 0, 0, 0, 323, 320, 1, 0, 0, 0, 323, 322, 1, 0, 0, 0, 324, 15, 1,
		0, 0, 0, 325, 327, 5, 102, 0, 0, 326, 325, 1, 0, 0, 0, 326, 327, 1, 0,
		0, 0, 327, 328, 1, 0, 0, 0, 328, 329, 5, 47, 0, 0, 329, 330, 3, 102, 51,
		0, 330, 331, 5, 48, 0, 0, 331, 332, 3, 16, 8, 0, 332, 336, 1, 0, 0, 0,
		333, 336, 3, 14, 7, 0, 334, 336, 5, 97, 0, 0, 335, 326, 1, 0, 0, 0, 335,
		333, 1, 0, 0, 0, 335, 334, 1, 0, 0, 0, 336, 17, 1, 0, 0, 0, 337, 338, 3,
		26, 13, 0, 338, 339, 3, 20, 10, 0, 339, 340, 3, 28, 14, 0, 340, 344, 1,
		0, 0, 0, 341, 344, 3, 16, 8, 0, 342, 344, 5, 97, 0, 0, 343, 337, 1, 0,
		0, 0, 343, 341, 1, 0, 0, 0, 343, 342, 1, 0, 0, 0, 344, 19, 1, 0, 0, 0,
		345, 346, 7, 3, 0, 0, 346, 21, 1, 0, 0, 0, 347, 352, 3, 28, 14, 0, 348,
		349, 5, 76, 0, 0, 349, 351, 3, 28, 14, 0, 350, 348, 1, 0, 0, 0, 351, 354,
		1, 0, 0, 0, 352, 350, 1, 0, 0, 0, 352, 353, 1, 0, 0, 0, 353, 23, 1, 0,
		0, 0, 354, 352, 1, 0, 0, 0, 355, 356, 5, 47, 0, 0, 356, 360, 5, 51, 0,
		0, 357, 359, 3, 122, 61, 0, 358, 357, 1, 0, 0, 0, 359, 362, 1, 0, 0, 0,
		360, 358, 1, 0, 0, 0, 360, 361, 1, 0, 0, 0, 361, 364, 1, 0, 0, 0, 362,
		360, 1, 0, 0, 0, 363, 365, 3, 28, 14, 0, 364, 363, 1, 0, 0, 0, 364, 365,
		1, 0, 0, 0, 365, 367, 1, 0, 0, 0, 366, 368, 5, 75, 0, 0, 367, 366, 1, 0,
		0, 0, 367, 368, 1, 0, 0, 0, 368, 369, 1, 0, 0, 0, 369, 370, 5, 52, 0, 0,
		370, 371, 5, 48, 0, 0, 371, 25, 1, 0, 0, 0, 372, 373, 5, 63, 0, 0, 373,
		380, 3, 14, 7, 0, 374, 380, 3, 10, 5, 0, 375, 376, 5, 47, 0, 0, 376, 377,
		3, 26, 13, 0, 377, 378, 5, 48, 0, 0, 378, 380, 1, 0, 0, 0, 379, 372, 1,
		0, 0, 0, 379, 374, 1, 0, 0, 0, 379, 375, 1, 0, 0, 0, 380, 27, 1, 0, 0,
		0, 381, 382, 6, 14, -1, 0, 382, 383, 7, 4, 0, 0, 383, 393, 3, 28, 14, 12,
		384, 385, 5, 47, 0, 0, 385, 386, 3, 28, 14, 0, 386, 387, 5, 48, 0, 0, 387,
		393, 1, 0, 0, 0, 388, 393, 3, 16, 8, 0, 389, 393, 3, 18, 9, 0, 390, 393,
		3, 24, 12, 0, 391, 393, 3, 36, 18, 0, 392, 381, 1, 0, 0, 0, 392, 384, 1,
		0, 0, 0, 392, 388, 1, 0, 0, 0, 392, 389, 1, 0, 0, 0, 392, 390, 1, 0, 0,
		0, 392, 391, 1, 0, 0, 0, 393, 417, 1, 0, 0, 0, 394, 395, 10, 11, 0, 0,
		395, 396, 7, 5, 0, 0, 396, 416, 3, 28, 14, 12, 397, 398, 10, 10, 0, 0,
		398, 399, 7, 6, 0, 0, 399, 416, 3, 28, 14, 11, 400, 401, 10, 9, 0, 0, 401,
		402, 7, 7, 0, 0, 402, 416, 3, 28, 14, 10, 403, 404, 10, 8, 0, 0, 404, 405,
		5, 68, 0, 0, 405, 416, 3, 28, 14, 9, 406, 407, 10, 7, 0, 0, 407, 408, 5,
		69, 0, 0, 408, 416, 3, 28, 14, 8, 409, 410, 10, 5, 0, 0, 410, 411, 5, 73,
		0, 0, 411, 412, 3, 28, 14, 0, 412, 413, 5, 74, 0, 0, 413, 414, 3, 28, 14,
		0, 414, 416, 1, 0, 0, 0, 415, 394, 1, 0, 0, 0, 415, 397, 1, 0, 0, 0, 415,
		400, 1, 0, 0, 0, 415, 403, 1, 0, 0, 0, 415, 406, 1, 0, 0, 0, 415, 409,
		1, 0, 0, 0, 416, 419, 1, 0, 0, 0, 417, 415, 1, 0, 0, 0, 417, 418, 1, 0,
		0, 0, 418, 29, 1, 0, 0, 0, 419, 417, 1, 0, 0, 0, 420, 422, 3, 36, 18, 0,
		421, 423, 3, 38, 19, 0, 422, 421, 1, 0, 0, 0, 422, 423, 1, 0, 0, 0, 423,
		424, 1, 0, 0, 0, 424, 425, 5, 75, 0, 0, 425, 428, 1, 0, 0, 0, 426, 428,
		3, 120, 60, 0, 427, 420, 1, 0, 0, 0, 427, 426, 1, 0, 0, 0, 428, 31, 1,
		0, 0, 0, 429, 432, 3, 36, 18, 0, 430, 431, 5, 76, 0, 0, 431, 433, 3, 36,
		18, 0, 432, 430, 1, 0, 0, 0, 432, 433, 1, 0, 0, 0, 433, 33, 1, 0, 0, 0,
		434, 437, 3, 36, 18, 0, 435, 436, 5, 76, 0, 0, 436, 438, 3, 36, 18, 0,
		437, 435, 1, 0, 0, 0, 437, 438, 1, 0, 0, 0, 438, 35, 1, 0, 0, 0, 439, 443,
		3, 42, 21, 0, 440, 443, 3, 68, 34, 0, 441, 443, 3, 70, 35, 0, 442, 439,
		1, 0, 0, 0, 442, 440, 1, 0, 0, 0, 442, 441, 1, 0, 0, 0, 443, 446, 1, 0,
		0, 0, 444, 442, 1, 0, 0, 0, 444, 445, 1, 0, 0, 0, 445, 448, 1, 0, 0, 0,
		446, 444, 1, 0, 0, 0, 447, 449, 3, 48, 24, 0, 448, 447, 1, 0, 0, 0, 448,
		449, 1, 0, 0, 0, 449, 452, 1, 0, 0, 0, 450, 453, 3, 44, 22, 0, 451, 453,
		5, 95, 0, 0, 452, 450, 1, 0, 0, 0, 452, 451, 1, 0, 0, 0, 453, 457, 1, 0,
		0, 0, 454, 456, 5, 63, 0, 0, 455, 454, 1, 0, 0, 0, 456, 459, 1, 0, 0, 0,
		457, 455, 1, 0, 0, 0, 457, 458, 1, 0, 0, 0, 458, 462, 1, 0, 0, 0, 459,
		457, 1, 0, 0, 0, 460, 462, 3, 72, 36, 0, 461, 444, 1, 0, 0, 0, 461, 460,
		1, 0, 0, 0, 462, 37, 1, 0, 0, 0, 463, 468, 3, 40, 20, 0, 464, 465, 5, 76,
		0, 0, 465, 467, 3, 40, 20, 0, 466, 464, 1, 0, 0, 0, 467, 470, 1, 0, 0,
		0, 468, 466, 1, 0, 0, 0, 468, 469, 1, 0, 0, 0, 469, 39, 1, 0, 0, 0, 470,
		468, 1, 0, 0, 0, 471, 474, 3, 74, 37, 0, 472, 473, 5, 77, 0, 0, 473, 475,
		3, 110, 55, 0, 474, 472, 1, 0, 0, 0, 474, 475, 1, 0, 0, 0, 475, 41, 1,
		0, 0, 0, 476, 477, 7, 8, 0, 0, 477, 43, 1, 0, 0, 0, 478, 506, 5, 34, 0,
		0, 479, 506, 5, 4, 0, 0, 480, 506, 5, 25, 0, 0, 481, 506, 5, 19, 0, 0,
		482, 506, 5, 20, 0, 0, 483, 506, 5, 21, 0, 0, 484, 506, 5, 14, 0, 0, 485,
		506, 5, 9, 0, 0, 486, 506, 5, 10, 0, 0, 487, 506, 5, 40, 0, 0, 488, 506,
		5, 41, 0, 0, 489, 506, 5, 105, 0, 0, 490, 506, 5, 106, 0, 0, 491, 506,
		5, 107, 0, 0, 492, 493, 5, 102, 0, 0, 493, 494, 5, 47, 0, 0, 494, 495,
		7, 9, 0, 0, 495, 506, 5, 48, 0, 0, 496, 506, 3, 66, 33, 0, 497, 506, 3,
		46, 23, 0, 498, 506, 3, 60, 30, 0, 499, 506, 3, 108, 54, 0, 500, 501, 5,
		108, 0, 0, 501, 502, 5, 47, 0, 0, 502, 503, 3, 28, 14, 0, 503, 504, 5,
		48, 0, 0, 504, 506, 1, 0, 0, 0, 505, 478, 1, 0, 0, 0, 505, 479, 1, 0, 0,
		0, 505, 480, 1, 0, 0, 0, 505, 481, 1, 0, 0, 0, 505, 482, 1, 0, 0, 0, 505,
		483, 1, 0, 0, 0, 505, 484, 1, 0, 0, 0, 505, 485, 1, 0, 0, 0, 505, 486,
		1, 0, 0, 0, 505, 487, 1, 0, 0, 0, 505, 488, 1, 0, 0, 0, 505, 489, 1, 0,
		0, 0, 505, 490, 1, 0, 0, 0, 505, 491, 1, 0, 0, 0, 505, 492, 1, 0, 0, 0,
		505, 496, 1, 0, 0, 0, 505, 497, 1, 0, 0, 0, 505, 498, 1, 0, 0, 0, 505,
		499, 1, 0, 0, 0, 505, 500, 1, 0, 0, 0, 506, 45, 1, 0, 0, 0, 507, 509, 3,
		48, 24, 0, 508, 510, 5, 95, 0, 0, 509, 508, 1, 0, 0, 0, 509, 510, 1, 0,
		0, 0, 510, 511, 1, 0, 0, 0, 511, 512, 5, 51, 0, 0, 512, 513, 3, 50, 25,
		0, 513, 515, 5, 52, 0, 0, 514, 516, 5, 95, 0, 0, 515, 514, 1, 0, 0, 0,
		515, 516, 1, 0, 0, 0, 516, 47, 1, 0, 0, 0, 517, 518, 7, 10, 0, 0, 518,
		49, 1, 0, 0, 0, 519, 521, 3, 52, 26, 0, 520, 519, 1, 0, 0, 0, 521, 522,
		1, 0, 0, 0, 522, 520, 1, 0, 0, 0, 522, 523, 1, 0, 0, 0, 523, 51, 1, 0,
		0, 0, 524, 525, 3, 54, 27, 0, 525, 526, 3, 56, 28, 0, 526, 527, 5, 75,
		0, 0, 527, 533, 1, 0, 0, 0, 528, 529, 3, 54, 27, 0, 529, 530, 5, 75, 0,
		0, 530, 533, 1, 0, 0, 0, 531, 533, 3, 120, 60, 0, 532, 524, 1, 0, 0, 0,
		532, 528, 1, 0, 0, 0, 532, 531, 1, 0, 0, 0, 533, 53, 1, 0, 0, 0, 534, 537,
		3, 44, 22, 0, 535, 537, 3, 68, 34, 0, 536, 534, 1, 0, 0, 0, 536, 535, 1,
		0, 0, 0, 537, 539, 1, 0, 0, 0, 538, 540, 3, 54, 27, 0, 539, 538, 1, 0,
		0, 0, 539, 540, 1, 0, 0, 0, 540, 55, 1, 0, 0, 0, 541, 546, 3, 58, 29, 0,
		542, 543, 5, 76, 0, 0, 543, 545, 3, 58, 29, 0, 544, 542, 1, 0, 0, 0, 545,
		548, 1, 0, 0, 0, 546, 544, 1, 0, 0, 0, 546, 547, 1, 0, 0, 0, 547, 57, 1,
		0, 0, 0, 548, 546, 1, 0, 0, 0, 549, 556, 3, 74, 37, 0, 550, 552, 3, 74,
		37, 0, 551, 550, 1, 0, 0, 0, 551, 552, 1, 0, 0, 0, 552, 553, 1, 0, 0, 0,
		553, 554, 5, 74, 0, 0, 554, 556, 3, 28, 14, 0, 555, 549, 1, 0, 0, 0, 555,
		551, 1, 0, 0, 0, 556, 59, 1, 0, 0, 0, 557, 559, 5, 12, 0, 0, 558, 560,
		5, 95, 0, 0, 559, 558, 1, 0, 0, 0, 559, 560, 1, 0, 0, 0, 560, 561, 1, 0,
		0, 0, 561, 562, 5, 51, 0, 0, 562, 564, 3, 62, 31, 0, 563, 565, 5, 76, 0,
		0, 564, 563, 1, 0, 0, 0, 564, 565, 1, 0, 0, 0, 565, 566, 1, 0, 0, 0, 566,
		567, 5, 52, 0, 0, 567, 571, 1, 0, 0, 0, 568, 569, 5, 12, 0, 0, 569, 571,
		5, 95, 0, 0, 570, 557, 1, 0, 0, 0, 570, 568, 1, 0, 0, 0, 571, 61, 1, 0,
		0, 0, 572, 577, 3, 64, 32, 0, 573, 574, 5, 76, 0, 0, 574, 576, 3, 64, 32,
		0, 575, 573, 1, 0, 0, 0, 576, 579, 1, 0, 0, 0, 577, 575, 1, 0, 0, 0, 577,
		578, 1, 0, 0, 0, 578, 63, 1, 0, 0, 0, 579, 577, 1, 0, 0, 0, 580, 581, 5,
		95, 0, 0, 581, 584, 3, 82, 41, 0, 582, 583, 5, 77, 0, 0, 583, 585, 3, 28,
		14, 0, 584, 582, 1, 0, 0, 0, 584, 585, 1, 0, 0, 0, 585, 592, 1, 0, 0, 0,
		586, 589, 5, 95, 0, 0, 587, 588, 5, 77, 0, 0, 588, 590, 3, 28, 14, 0, 589,
		587, 1, 0, 0, 0, 589, 590, 1, 0, 0, 0, 590, 592, 1, 0, 0, 0, 591, 580,
		1, 0, 0, 0, 591, 586, 1, 0, 0, 0, 592, 65, 1, 0, 0, 0, 593, 594, 5, 39,
		0, 0, 594, 595, 5, 47, 0, 0, 595, 596, 3, 102, 51, 0, 596, 597, 5, 48,
		0, 0, 597, 67, 1, 0, 0, 0, 598, 599, 7, 11, 0, 0, 599, 69, 1, 0, 0, 0,
		600, 610, 5, 18, 0, 0, 601, 610, 5, 44, 0, 0, 602, 610, 5, 109, 0, 0, 603,
		610, 5, 110, 0, 0, 604, 610, 3, 82, 41, 0, 605, 606, 5, 111, 0, 0, 606,
		607, 5, 47, 0, 0, 607, 608, 5, 95, 0, 0, 608, 610, 5, 48, 0, 0, 609, 600,
		1, 0, 0, 0, 609, 601, 1, 0, 0, 0, 609, 602, 1, 0, 0, 0, 609, 603, 1, 0,
		0, 0, 609, 604, 1, 0, 0, 0, 609, 605, 1, 0, 0, 0, 610, 71, 1, 0, 0, 0,
		611, 612, 5, 37, 0, 0, 612, 615, 5, 47, 0, 0, 613, 616, 3, 102, 51, 0,
		614, 616, 3, 28, 14, 0, 615, 613, 1, 0, 0, 0, 615, 614, 1, 0, 0, 0, 616,
		617, 1, 0, 0, 0, 617, 618, 5, 48, 0, 0, 618, 73, 1, 0, 0, 0, 619, 621,
		3, 88, 44, 0, 620, 619, 1, 0, 0, 0, 620, 621, 1, 0, 0, 0, 621, 622, 1,
		0, 0, 0, 622, 626, 3, 76, 38, 0, 623, 625, 3, 80, 40, 0, 624, 623, 1, 0,
		0, 0, 625, 628, 1, 0, 0, 0, 626, 624, 1, 0, 0, 0, 626, 627, 1, 0, 0, 0,
		627, 75, 1, 0, 0, 0, 628, 626, 1, 0, 0, 0, 629, 630, 6, 38, -1, 0, 630,
		647, 5, 95, 0, 0, 631, 632, 5, 47, 0, 0, 632, 633, 3, 74, 37, 0, 633, 634,
		5, 48, 0, 0, 634, 647, 1, 0, 0, 0, 635, 636, 5, 95, 0, 0, 636, 637, 5,
		74, 0, 0, 637, 647, 5, 97, 0, 0, 638, 639, 3, 78, 39, 0, 639, 640, 5, 95,
		0, 0, 640, 647, 1, 0, 0, 0, 641, 642, 5, 47, 0, 0, 642, 643, 3, 78, 39,
		0, 643, 644, 3, 74, 37, 0, 644, 645, 5, 48, 0, 0, 645, 647, 1, 0, 0, 0,
		646, 629, 1, 0, 0, 0, 646, 631, 1, 0, 0, 0, 646, 635, 1, 0, 0, 0, 646,
		638, 1, 0, 0, 0, 646, 641, 1, 0, 0, 0, 647, 693, 1, 0, 0, 0, 648, 649,
		10, 9, 0, 0, 649, 651, 5, 49, 0, 0, 650, 652, 3, 92, 46, 0, 651, 650, 1,
		0, 0, 0, 651, 652, 1, 0, 0, 0, 652, 654, 1, 0, 0, 0, 653, 655, 3, 28, 14,
		0, 654, 653, 1, 0, 0, 0, 654, 655, 1, 0, 0, 0, 655, 656, 1, 0, 0, 0, 656,
		692, 5, 50, 0, 0, 657, 658, 10, 8, 0, 0, 658, 659, 5, 49, 0, 0, 659, 661,
		5, 28, 0, 0, 660, 662, 3, 92, 46, 0, 661, 660, 1, 0, 0, 0, 661, 662, 1,
		0, 0, 0, 662, 663, 1, 0, 0, 0, 663, 664, 3, 28, 14, 0, 664, 665, 5, 50,
		0, 0, 665, 692, 1, 0, 0, 0, 666, 667, 10, 7, 0, 0, 667, 668, 5, 49, 0,
		0, 668, 669, 3, 92, 46, 0, 669, 670, 5, 28, 0, 0, 670, 671, 3, 28, 14,
		0, 671, 672, 5, 50, 0, 0, 672, 692, 1, 0, 0, 0, 673, 674, 10, 6, 0, 0,
		674, 676, 5, 49, 0, 0, 675, 677, 3, 92, 46, 0, 676, 675, 1, 0, 0, 0, 676,
		677, 1, 0, 0, 0, 677, 678, 1, 0, 0, 0, 678, 679, 5, 63, 0, 0, 679, 692,
		5, 50, 0, 0, 680, 681, 10, 5, 0, 0, 681, 682, 5, 47, 0, 0, 682, 683, 3,
		94, 47, 0, 683, 684, 5, 48, 0, 0, 684, 692, 1, 0, 0, 0, 685, 686, 10, 4,
		0, 0, 686, 688, 5, 47, 0, 0, 687, 689, 3, 100, 50, 0, 688, 687, 1, 0, 0,
		0, 688, 689, 1, 0, 0, 0, 689, 690, 1, 0, 0, 0, 690, 692, 5, 48, 0, 0, 691,
		648, 1, 0, 0, 0, 691, 657, 1, 0, 0, 0, 691, 666, 1, 0, 0, 0, 691, 673,
		1, 0, 0, 0, 691, 680, 1, 0, 0, 0, 691, 685, 1, 0, 0, 0, 692, 695, 1, 0,
		0, 0, 693, 691, 1, 0, 0, 0, 693, 694, 1, 0, 0, 0, 694, 77, 1, 0, 0, 0,
		695, 693, 1, 0, 0, 0, 696, 697, 7, 12, 0, 0, 697, 79, 1, 0, 0, 0, 698,
		708, 5, 93, 0, 0, 699, 708, 3, 82, 41, 0, 700, 705, 5, 95, 0, 0, 701, 702,
		5, 47, 0, 0, 702, 703, 3, 84, 42, 0, 703, 704, 5, 48, 0, 0, 704, 706, 1,
		0, 0, 0, 705, 701, 1, 0, 0, 0, 705, 706, 1, 0, 0, 0, 706, 708, 1, 0, 0,
		0, 707, 698, 1, 0, 0, 0, 707, 699, 1, 0, 0, 0, 707, 700, 1, 0, 0, 0, 708,
		81, 1, 0, 0, 0, 709, 710, 5, 94, 0, 0, 710, 711, 5, 47, 0, 0, 711, 713,
		5, 47, 0, 0, 712, 714, 3, 84, 42, 0, 713, 712, 1, 0, 0, 0, 713, 714, 1,
		0, 0, 0, 714, 715, 1, 0, 0, 0, 715, 716, 5, 48, 0, 0, 716, 717, 5, 48,
		0, 0, 717, 83, 1, 0, 0, 0, 718, 723, 3, 86, 43, 0, 719, 720, 5, 76, 0,
		0, 720, 722, 3, 86, 43, 0, 721, 719, 1, 0, 0, 0, 722, 725, 1, 0, 0, 0,
		723, 721, 1, 0, 0, 0, 723, 724, 1, 0, 0, 0, 724, 85, 1, 0, 0, 0, 725, 723,
		1, 0, 0, 0, 726, 732, 8, 13, 0, 0, 727, 729, 5, 47, 0, 0, 728, 730, 3,
		12, 6, 0, 729, 728, 1, 0, 0, 0, 729, 730, 1, 0, 0, 0, 730, 731, 1, 0, 0,
		0, 731, 733, 5, 48, 0, 0, 732, 727, 1, 0, 0, 0, 732, 733, 1, 0, 0, 0, 733,
		743, 1, 0, 0, 0, 734, 740, 5, 95, 0, 0, 735, 737, 5, 47, 0, 0, 736, 738,
		3, 12, 6, 0, 737, 736, 1, 0, 0, 0, 737, 738, 1, 0, 0, 0, 738, 739, 1, 0,
		0, 0, 739, 741, 5, 48, 0, 0, 740, 735, 1, 0, 0, 0, 740, 741, 1, 0, 0, 0,
		741, 743, 1, 0, 0, 0, 742, 726, 1, 0, 0, 0, 742, 734, 1, 0, 0, 0, 743,
		87, 1, 0, 0, 0, 744, 746, 3, 90, 45, 0, 745, 744, 1, 0, 0, 0, 746, 747,
		1, 0, 0, 0, 747, 745, 1, 0, 0, 0, 747, 748, 1, 0, 0, 0, 748, 89, 1, 0,
		0, 0, 749, 751, 7, 14, 0, 0, 750, 752, 3, 92, 46, 0, 751, 750, 1, 0, 0,
		0, 751, 752, 1, 0, 0, 0, 752, 91, 1, 0, 0, 0, 753, 755, 3, 68, 34, 0, 754,
		753, 1, 0, 0, 0, 755, 756, 1, 0, 0, 0, 756, 754, 1, 0, 0, 0, 756, 757,
		1, 0, 0, 0, 757, 93, 1, 0, 0, 0, 758, 763, 3, 96, 48, 0, 759, 761, 5, 76,
		0, 0, 760, 762, 5, 92, 0, 0, 761, 760, 1, 0, 0, 0, 761, 762, 1, 0, 0, 0,
		762, 764, 1, 0, 0, 0, 763, 759, 1, 0, 0, 0, 763, 764, 1, 0, 0, 0, 764,
		95, 1, 0, 0, 0, 765, 770, 3, 98, 49, 0, 766, 767, 5, 76, 0, 0, 767, 769,
		3, 98, 49, 0, 768, 766, 1, 0, 0, 0, 769, 772, 1, 0, 0, 0, 770, 768, 1,
		0, 0, 0, 770, 771, 1, 0, 0, 0, 771, 97, 1, 0, 0, 0, 772, 770, 1, 0, 0,
		0, 773, 774, 3, 36, 18, 0, 774, 775, 3, 74, 37, 0, 775, 781, 1, 0, 0, 0,
		776, 778, 3, 36, 18, 0, 777, 779, 3, 104, 52, 0, 778, 777, 1, 0, 0, 0,
		778, 779, 1, 0, 0, 0, 779, 781, 1, 0, 0, 0, 780, 773, 1, 0, 0, 0, 780,
		776, 1, 0, 0, 0, 781, 99, 1, 0, 0, 0, 782, 787, 5, 95, 0, 0, 783, 784,
		5, 76, 0, 0, 784, 786, 5, 95, 0, 0, 785, 783, 1, 0, 0, 0, 786, 789, 1,
		0, 0, 0, 787, 785, 1, 0, 0, 0, 787, 788, 1, 0, 0, 0, 788, 101, 1, 0, 0,
		0, 789, 787, 1, 0, 0, 0, 790, 791, 6, 51, -1, 0, 791, 793, 3, 54, 27, 0,
		792, 794, 3, 104, 52, 0, 793, 792, 1, 0, 0, 0, 793, 794, 1, 0, 0, 0, 794,
		800, 1, 0, 0, 0, 795, 796, 10, 1, 0, 0, 796, 797, 7, 0, 0, 0, 797, 799,
		5, 95, 0, 0, 798, 795, 1, 0, 0, 0, 799, 802, 1, 0, 0, 0, 800, 798, 1, 0,
		0, 0, 800, 801, 1, 0, 0, 0, 801, 103, 1, 0, 0, 0, 802, 800, 1, 0, 0, 0,
		803, 815, 3, 88, 44, 0, 804, 806, 3, 88, 44, 0, 805, 804, 1, 0, 0, 0, 805,
		806, 1, 0, 0, 0, 806, 807, 1, 0, 0, 0, 807, 811, 3, 106, 53, 0, 808, 810,
		3, 80, 40, 0, 809, 808, 1, 0, 0, 0, 810, 813, 1, 0, 0, 0, 811, 809, 1,
		0, 0, 0, 811, 812, 1, 0, 0, 0, 812, 815, 1, 0, 0, 0, 813, 811, 1, 0, 0,
		0, 814, 803, 1, 0, 0, 0, 814, 805, 1, 0, 0, 0, 815, 105, 1, 0, 0, 0, 816,
		817, 6, 53, -1, 0, 817, 818, 5, 47, 0, 0, 818, 819, 3, 104, 52, 0, 819,
		823, 5, 48, 0, 0, 820, 822, 3, 80, 40, 0, 821, 820, 1, 0, 0, 0, 822, 825,
		1, 0, 0, 0, 823, 821, 1, 0, 0, 0, 823, 824, 1, 0, 0, 0, 824, 863, 1, 0,
		0, 0, 825, 823, 1, 0, 0, 0, 826, 828, 5, 49, 0, 0, 827, 829, 3, 92, 46,
		0, 828, 827, 1, 0, 0, 0, 828, 829, 1, 0, 0, 0, 829, 831, 1, 0, 0, 0, 830,
		832, 3, 18, 9, 0, 831, 830, 1, 0, 0, 0, 831, 832, 1, 0, 0, 0, 832, 833,
		1, 0, 0, 0, 833, 863, 5, 50, 0, 0, 834, 835, 5, 49, 0, 0, 835, 837, 5,
		28, 0, 0, 836, 838, 3, 92, 46, 0, 837, 836, 1, 0, 0, 0, 837, 838, 1, 0,
		0, 0, 838, 839, 1, 0, 0, 0, 839, 840, 3, 18, 9, 0, 840, 841, 5, 50, 0,
		0, 841, 863, 1, 0, 0, 0, 842, 843, 5, 49, 0, 0, 843, 844, 3, 92, 46, 0,
		844, 845, 5, 28, 0, 0, 845, 846, 3, 18, 9, 0, 846, 847, 5, 50, 0, 0, 847,
		863, 1, 0, 0, 0, 848, 849, 5, 49, 0, 0, 849, 850, 5, 63, 0, 0, 850, 863,
		5, 50, 0, 0, 851, 853, 5, 47, 0, 0, 852, 854, 3, 94, 47, 0, 853, 852, 1,
		0, 0, 0, 853, 854, 1, 0, 0, 0, 854, 855, 1, 0, 0, 0, 855, 859, 5, 48, 0,
		0, 856, 858, 3, 80, 40, 0, 857, 856, 1, 0, 0, 0, 858, 861, 1, 0, 0, 0,
		859, 857, 1, 0, 0, 0, 859, 860, 1, 0, 0, 0, 860, 863, 1, 0, 0, 0, 861,
		859, 1, 0, 0, 0, 862, 816, 1, 0, 0, 0, 862, 826, 1, 0, 0, 0, 862, 834,
		1, 0, 0, 0, 862, 842, 1, 0, 0, 0, 862, 848, 1, 0, 0, 0, 862, 851, 1, 0,
		0, 0, 863, 907, 1, 0, 0, 0, 864, 865, 10, 5, 0, 0, 865, 867, 5, 49, 0,
		0, 866, 868, 3, 92, 46, 0, 867, 866, 1, 0, 0, 0, 867, 868, 1, 0, 0, 0,
		868, 870, 1, 0, 0, 0, 869, 871, 3, 18, 9, 0, 870, 869, 1, 0, 0, 0, 870,
		871, 1, 0, 0, 0, 871, 872, 1, 0, 0, 0, 872, 906, 5, 50, 0, 0, 873, 874,
		10, 4, 0, 0, 874, 875, 5, 49, 0, 0, 875, 877, 5, 28, 0, 0, 876, 878, 3,
		92, 46, 0, 877, 876, 1, 0, 0, 0, 877, 878, 1, 0, 0, 0, 878, 879, 1, 0,
		0, 0, 879, 880, 3, 18, 9, 0, 880, 881, 5, 50, 0, 0, 881, 906, 1, 0, 0,
		0, 882, 883, 10, 3, 0, 0, 883, 884, 5, 49, 0, 0, 884, 885, 3, 92, 46, 0,
		885, 886, 5, 28, 0, 0, 886, 887, 3, 18, 9, 0, 887, 888, 5, 50, 0, 0, 888,
		906, 1, 0, 0, 0, 889, 890, 10, 2, 0, 0, 890, 891, 5, 49, 0, 0, 891, 892,
		5, 63, 0, 0, 892, 906, 5, 50, 0, 0, 893, 894, 10, 1, 0, 0, 894, 896, 5,
		47, 0, 0, 895, 897, 3, 94, 47, 0, 896, 895, 1, 0, 0, 0, 896, 897, 1, 0,
		0, 0, 897, 898, 1, 0, 0, 0, 898, 902, 5, 48, 0, 0, 899, 901, 3, 80, 40,
		0, 900, 899, 1, 0, 0, 0, 901, 904, 1, 0, 0, 0, 902, 900, 1, 0, 0, 0, 902,
		903, 1, 0, 0, 0, 903, 906, 1, 0, 0, 0, 904, 902, 1, 0, 0, 0, 905, 864,
		1, 0, 0, 0, 905, 873, 1, 0, 0, 0, 905, 882, 1, 0, 0, 0, 905, 889, 1, 0,
		0, 0, 905, 893, 1, 0, 0, 0, 906, 909, 1, 0, 0, 0, 907, 905, 1, 0, 0, 0,
		907, 908, 1, 0, 0, 0, 908, 107, 1, 0, 0, 0, 909, 907, 1, 0, 0, 0, 910,
		912, 3, 48, 24, 0, 911, 910, 1, 0, 0, 0, 911, 912, 1, 0, 0, 0, 912, 913,
		1, 0, 0, 0, 913, 914, 5, 95, 0, 0, 914, 109, 1, 0, 0, 0, 915, 925, 3, 28,
		14, 0, 916, 918, 5, 51, 0, 0, 917, 919, 3, 112, 56, 0, 918, 917, 1, 0,
		0, 0, 918, 919, 1, 0, 0, 0, 919, 921, 1, 0, 0, 0, 920, 922, 5, 76, 0, 0,
		921, 920, 1, 0, 0, 0, 921, 922, 1, 0, 0, 0, 922, 923, 1, 0, 0, 0, 923,
		925, 5, 52, 0, 0, 924, 915, 1, 0, 0, 0, 924, 916, 1, 0, 0, 0, 925, 111,
		1, 0, 0, 0, 926, 928, 3, 114, 57, 0, 927, 926, 1, 0, 0, 0, 927, 928, 1,
		0, 0, 0, 928, 929, 1, 0, 0, 0, 929, 937, 3, 110, 55, 0, 930, 932, 5, 76,
		0, 0, 931, 933, 3, 114, 57, 0, 932, 931, 1, 0, 0, 0, 932, 933, 1, 0, 0,
		0, 933, 934, 1, 0, 0, 0, 934, 936, 3, 110, 55, 0, 935, 930, 1, 0, 0, 0,
		936, 939, 1, 0, 0, 0, 937, 935, 1, 0, 0, 0, 937, 938, 1, 0, 0, 0, 938,
		113, 1, 0, 0, 0, 939, 937, 1, 0, 0, 0, 940, 941, 3, 116, 58, 0, 941, 942,
		5, 77, 0, 0, 942, 115, 1, 0, 0, 0, 943, 945, 3, 118, 59, 0, 944, 943, 1,
		0, 0, 0, 945, 946, 1, 0, 0, 0, 946, 944, 1, 0, 0, 0, 946, 947, 1, 0, 0,
		0, 947, 117, 1, 0, 0, 0, 948, 949, 5, 49, 0, 0, 949, 950, 3, 28, 14, 0,
		950, 951, 5, 50, 0, 0, 951, 955, 1, 0, 0, 0, 952, 953, 5, 91, 0, 0, 953,
		955, 5, 95, 0, 0, 954, 948, 1, 0, 0, 0, 954, 952, 1, 0, 0, 0, 955, 119,
		1, 0, 0, 0, 956, 957, 5, 45, 0, 0, 957, 958, 5, 47, 0, 0, 958, 959, 3,
		28, 14, 0, 959, 961, 5, 76, 0, 0, 960, 962, 5, 98, 0, 0, 961, 960, 1, 0,
		0, 0, 962, 963, 1, 0, 0, 0, 963, 961, 1, 0, 0, 0, 963, 964, 1, 0, 0, 0,
		964, 965, 1, 0, 0, 0, 965, 966, 5, 48, 0, 0, 966, 967, 5, 75, 0, 0, 967,
		121, 1, 0, 0, 0, 968, 969, 5, 95, 0, 0, 969, 971, 5, 74, 0, 0, 970, 972,
		3, 122, 61, 0, 971, 970, 1, 0, 0, 0, 971, 972, 1, 0, 0, 0, 972, 982, 1,
		0, 0, 0, 973, 982, 3, 130, 65, 0, 974, 982, 3, 136, 68, 0, 975, 982, 3,
		24, 12, 0, 976, 982, 3, 138, 69, 0, 977, 982, 3, 140, 70, 0, 978, 982,
		3, 152, 76, 0, 979, 982, 3, 124, 62, 0, 980, 982, 5, 75, 0, 0, 981, 968,
		1, 0, 0, 0, 981, 973, 1, 0, 0, 0, 981, 974, 1, 0, 0, 0, 981, 975, 1, 0,
		0, 0, 981, 976, 1, 0, 0, 0, 981, 977, 1, 0, 0, 0, 981, 978, 1, 0, 0, 0,
		981, 979, 1, 0, 0, 0, 981, 980, 1, 0, 0, 0, 982, 123, 1, 0, 0, 0, 983,
		985, 5, 93, 0, 0, 984, 986, 7, 15, 0, 0, 985, 984, 1, 0, 0, 0, 985, 986,
		1, 0, 0, 0, 986, 987, 1, 0, 0, 0, 987, 989, 5, 47, 0, 0, 988, 990, 3, 126,
		63, 0, 989, 988, 1, 0, 0, 0, 989, 990, 1, 0, 0, 0, 990, 1007, 1, 0, 0,
		0, 991, 993, 5, 74, 0, 0, 992, 994, 3, 126, 63, 0, 993, 992, 1, 0, 0, 0,
		993, 994, 1, 0, 0, 0, 994, 1005, 1, 0, 0, 0, 995, 997, 5, 74, 0, 0, 996,
		998, 3, 126, 63, 0, 997, 996, 1, 0, 0, 0, 997, 998, 1, 0, 0, 0, 998, 1003,
		1, 0, 0, 0, 999, 1001, 5, 74, 0, 0, 1000, 1002, 3, 126, 63, 0, 1001, 1000,
		1, 0, 0, 0, 1001, 1002, 1, 0, 0, 0, 1002, 1004, 1, 0, 0, 0, 1003, 999,
		1, 0, 0, 0, 1003, 1004, 1, 0, 0, 0, 1004, 1006, 1, 0, 0, 0, 1005, 995,
		1, 0, 0, 0, 1005, 1006, 1, 0, 0, 0, 1006, 1008, 1, 0, 0, 0, 1007, 991,
		1, 0, 0, 0, 1007, 1008, 1, 0, 0, 0, 1008, 1009, 1, 0, 0, 0, 1009, 1010,
		5, 48, 0, 0, 1010, 1011, 5, 75, 0, 0, 1011, 125, 1, 0, 0, 0, 1012, 1017,
		3, 28, 14, 0, 1013, 1014, 5, 76, 0, 0, 1014, 1016, 3, 28, 14, 0, 1015,
		1013, 1, 0, 0, 0, 1016, 1019, 1, 0, 0, 0, 1017, 1015, 1, 0, 0, 0, 1017,
		1018, 1, 0, 0, 0, 1018, 127, 1, 0, 0, 0, 1019, 1017, 1, 0, 0, 0, 1020,
		1021, 5, 3, 0, 0, 1021, 1022, 3, 28, 14, 0, 1022, 1026, 5, 74, 0, 0, 1023,
		1025, 3, 122, 61, 0, 1024, 1023, 1, 0, 0, 0, 1025, 1028, 1, 0, 0, 0, 1026,
		1024, 1, 0, 0, 0, 1026, 1027, 1, 0, 0, 0, 1027, 1038, 1, 0, 0, 0, 1028,
		1026, 1, 0, 0, 0, 1029, 1030, 5, 7, 0, 0, 1030, 1034, 5, 74, 0, 0, 1031,
		1033, 3, 122, 61, 0, 1032, 1031, 1, 0, 0, 0, 1033, 1036, 1, 0, 0, 0, 1034,
		1032, 1, 0, 0, 0, 1034, 1035, 1, 0, 0, 0, 1035, 1038, 1, 0, 0, 0, 1036,
		1034, 1, 0, 0, 0, 1037, 1020, 1, 0, 0, 0, 1037, 1029, 1, 0, 0, 0, 1038,
		129, 1, 0, 0, 0, 1039, 1041, 5, 51, 0, 0, 1040, 1042, 3, 132, 66, 0, 1041,
		1040, 1, 0, 0, 0, 1041, 1042, 1, 0, 0, 0, 1042, 1043, 1, 0, 0, 0, 1043,
		1044, 5, 52, 0, 0, 1044, 131, 1, 0, 0, 0, 1045, 1047, 3, 134, 67, 0, 1046,
		1045, 1, 0, 0, 0, 1047, 1048, 1, 0, 0, 0, 1048, 1046, 1, 0, 0, 0, 1048,
		1049, 1, 0, 0, 0, 1049, 133, 1, 0, 0, 0, 1050, 1053, 3, 122, 61, 0, 1051,
		1053, 3, 30, 15, 0, 1052, 1050, 1, 0, 0, 0, 1052, 1051, 1, 0, 0, 0, 1053,
		135, 1, 0, 0, 0, 1054, 1055, 3, 144, 72, 0, 1055, 1056, 5, 75, 0, 0, 1056,
		137, 1, 0, 0, 0, 1057, 1058, 5, 17, 0, 0, 1058, 1059, 5, 47, 0, 0, 1059,
		1060, 3, 28, 14, 0, 1060, 1061, 5, 48, 0, 0, 1061, 1064, 3, 122, 61, 0,
		1062, 1063, 5, 11, 0, 0, 1063, 1065, 3, 122, 61, 0, 1064, 1062, 1, 0, 0,
		0, 1064, 1065, 1, 0, 0, 0, 1065, 1080, 1, 0, 0, 0, 1066, 1067, 5, 30, 0,
		0, 1067, 1068, 5, 47, 0, 0, 1068, 1069, 3, 28, 14, 0, 1069, 1070, 5, 48,
		0, 0, 1070, 1074, 5, 51, 0, 0, 1071, 1073, 3, 128, 64, 0, 1072, 1071, 1,
		0, 0, 0, 1073, 1076, 1, 0, 0, 0, 1074, 1072, 1, 0, 0, 0, 1074, 1075, 1,
		0, 0, 0, 1075, 1077, 1, 0, 0, 0, 1076, 1074, 1, 0, 0, 0, 1077, 1078, 5,
		52, 0, 0, 1078, 1080, 1, 0, 0, 0, 1079, 1057, 1, 0, 0, 0, 1079, 1066, 1,
		0, 0, 0, 1080, 139, 1, 0, 0, 0, 1081, 1082, 5, 36, 0, 0, 1082, 1083, 5,
		47, 0, 0, 1083, 1084, 3, 28, 14, 0, 1084, 1086, 5, 48, 0, 0, 1085, 1087,
		5, 75, 0, 0, 1086, 1085, 1, 0, 0, 0, 1086, 1087, 1, 0, 0, 0, 1087, 1088,
		1, 0, 0, 0, 1088, 1089, 3, 122, 61, 0, 1089, 1106, 1, 0, 0, 0, 1090, 1091,
		5, 8, 0, 0, 1091, 1092, 3, 122, 61, 0, 1092, 1093, 5, 36, 0, 0, 1093, 1094,
		5, 47, 0, 0, 1094, 1095, 3, 28, 14, 0, 1095, 1097, 5, 48, 0, 0, 1096, 1098,
		5, 75, 0, 0, 1097, 1096, 1, 0, 0, 0, 1097, 1098, 1, 0, 0, 0, 1098, 1106,
		1, 0, 0, 0, 1099, 1100, 5, 15, 0, 0, 1100, 1101, 5, 47, 0, 0, 1101, 1102,
		3, 142, 71, 0, 1102, 1103, 5, 48, 0, 0, 1103, 1104, 3, 122, 61, 0, 1104,
		1106, 1, 0, 0, 0, 1105, 1081, 1, 0, 0, 0, 1105, 1090, 1, 0, 0, 0, 1105,
		1099, 1, 0, 0, 0, 1106, 141, 1, 0, 0, 0, 1107, 1112, 3, 146, 73, 0, 1108,
		1110, 3, 144, 72, 0, 1109, 1108, 1, 0, 0, 0, 1109, 1110, 1, 0, 0, 0, 1110,
		1112, 1, 0, 0, 0, 1111, 1107, 1, 0, 0, 0, 1111, 1109, 1, 0, 0, 0, 1112,
		1113, 1, 0, 0, 0, 1113, 1115, 5, 75, 0, 0, 1114, 1116, 3, 150, 75, 0, 1115,
		1114, 1, 0, 0, 0, 1115, 1116, 1, 0, 0, 0, 1116, 1117, 1, 0, 0, 0, 1117,
		1119, 5, 75, 0, 0, 1118, 1120, 3, 150, 75, 0, 1119, 1118, 1, 0, 0, 0, 1119,
		1120, 1, 0, 0, 0, 1120, 143, 1, 0, 0, 0, 1121, 1126, 3, 18, 9, 0, 1122,
		1123, 5, 76, 0, 0, 1123, 1125, 3, 18, 9, 0, 1124, 1122, 1, 0, 0, 0, 1125,
		1128, 1, 0, 0, 0, 1126, 1124, 1, 0, 0, 0, 1126, 1127, 1, 0, 0, 0, 1127,
		145, 1, 0, 0, 0, 1128, 1126, 1, 0, 0, 0, 1129, 1134, 3, 148, 74, 0, 1130,
		1131, 5, 76, 0, 0, 1131, 1133, 3, 148, 74, 0, 1132, 1130, 1, 0, 0, 0, 1133,
		1136, 1, 0, 0, 0, 1134, 1132, 1, 0, 0, 0, 1134, 1135, 1, 0, 0, 0, 1135,
		147, 1, 0, 0, 0, 1136, 1134, 1, 0, 0, 0, 1137, 1139, 3, 36, 18, 0, 1138,
		1140, 3, 38, 19, 0, 1139, 1138, 1, 0, 0, 0, 1139, 1140, 1, 0, 0, 0, 1140,
		149, 1, 0, 0, 0, 1141, 1146, 3, 28, 14, 0, 1142, 1143, 5, 76, 0, 0, 1143,
		1145, 3, 28, 14, 0, 1144, 1142, 1, 0, 0, 0, 1145, 1148, 1, 0, 0, 0, 1146,
		1144, 1, 0, 0, 0, 1146, 1147, 1, 0, 0, 0, 1147, 151, 1, 0, 0, 0, 1148,
		1146, 1, 0, 0, 0, 1149, 1153, 5, 16, 0, 0, 1150, 1152, 5, 63, 0, 0, 1151,
		1150, 1, 0, 0, 0, 1152, 1155, 1, 0, 0, 0, 1153, 1151, 1, 0, 0, 0, 1153,
		1154, 1, 0, 0, 0, 1154, 1156, 1, 0, 0, 0, 1155, 1153, 1, 0, 0, 0, 1156,
		1164, 5, 95, 0, 0, 1157, 1164, 5, 6, 0, 0, 1158, 1164, 5, 2, 0, 0, 1159,
		1161, 5, 24, 0, 0, 1160, 1162, 3, 28, 14, 0, 1161, 1160, 1, 0, 0, 0, 1161,
		1162, 1, 0, 0, 0, 1162, 1164, 1, 0, 0, 0, 1163, 1149, 1, 0, 0, 0, 1163,
		1157, 1, 0, 0, 0, 1163, 1158, 1, 0, 0, 0, 1163, 1159, 1, 0, 0, 0, 1164,
		1165, 1, 0, 0, 0, 1165, 1166, 5, 75, 0, 0, 1166, 153, 1, 0, 0, 0, 1167,
		1169, 3, 156, 78, 0, 1168, 1167, 1, 0, 0, 0, 1168, 1169, 1, 0, 0, 0, 1169,
		1170, 1, 0, 0, 0, 1170, 1171, 5, 0, 0, 1, 1171, 155, 1, 0, 0, 0, 1172,
		1174, 3, 158, 79, 0, 1173, 1172, 1, 0, 0, 0, 1174, 1175, 1, 0, 0, 0, 1175,
		1173, 1, 0, 0, 0, 1175, 1176, 1, 0, 0, 0, 1176, 157, 1, 0, 0, 0, 1177,
		1182, 3, 36, 18, 0, 1178, 1182, 3, 160, 80, 0, 1179, 1182, 3, 30, 15, 0,
		1180, 1182, 5, 75, 0, 0, 1181, 1177, 1, 0, 0, 0, 1181, 1178, 1, 0, 0, 0,
		1181, 1179, 1, 0, 0, 0, 1181, 1180, 1, 0, 0, 0, 1182, 159, 1, 0, 0, 0,
		1183, 1185, 3, 36, 18, 0, 1184, 1183, 1, 0, 0, 0, 1184, 1185, 1, 0, 0,
		0, 1185, 1186, 1, 0, 0, 0, 1186, 1188, 3, 74, 37, 0, 1187, 1189, 3, 162,
		81, 0, 1188, 1187, 1, 0, 0, 0, 1188, 1189, 1, 0, 0, 0, 1189, 1191, 1, 0,
		0, 0, 1190, 1192, 3, 130, 65, 0, 1191, 1190, 1, 0, 0, 0, 1191, 1192, 1,
		0, 0, 0, 1192, 161, 1, 0, 0, 0, 1193, 1195, 3, 30, 15, 0, 1194, 1193, 1,
		0, 0, 0, 1195, 1196, 1, 0, 0, 0, 1196, 1194, 1, 0, 0, 0, 1196, 1197, 1,
		0, 0, 0, 1197, 163, 1, 0, 0, 0, 160, 169, 177, 197, 211, 216, 224, 232,
		236, 244, 254, 260, 262, 268, 276, 280, 290, 292, 300, 314, 323, 326, 335,
		343, 352, 360, 364, 367, 379, 392, 415, 417, 422, 427, 432, 437, 442, 444,
		448, 452, 457, 461, 468, 474, 505, 509, 515, 522, 532, 536, 539, 546, 551,
		555, 559, 564, 570, 577, 584, 589, 591, 609, 615, 620, 626, 646, 651, 654,
		661, 676, 688, 691, 693, 705, 707, 713, 723, 729, 732, 737, 740, 742, 747,
		751, 756, 761, 763, 770, 778, 780, 787, 793, 800, 805, 811, 814, 823, 828,
		831, 837, 853, 859, 862, 867, 870, 877, 896, 902, 905, 907, 911, 918, 921,
		924, 927, 932, 937, 946, 954, 963, 971, 981, 985, 989, 993, 997, 1001,
		1003, 1005, 1007, 1017, 1026, 1034, 1037, 1041, 1048, 1052, 1064, 1074,
		1079, 1086, 1097, 1105, 1109, 1111, 1115, 1119, 1126, 1134, 1139, 1146,
		1153, 1161, 1163, 1168, 1175, 1181, 1184, 1188, 1191, 1196,
	}
	deserializer := antlr.NewATNDeserializer(nil)
	staticData.atn = deserializer.Deserialize(staticData.serializedATN)
	atn := staticData.atn
	staticData.decisionToDFA = make([]*antlr.DFA, len(atn.DecisionToState))
	decisionToDFA := staticData.decisionToDFA
	for index, state := range atn.DecisionToState {
		decisionToDFA[index] = antlr.NewDFA(state, index)
	}
}

// CParserInit initializes any static state used to implement CParser. By default the
// static state used to implement the parser is lazily initialized during the first call to
// NewCParser(). You can call this function if you wish to initialize the static state ahead
// of time.
func CParserInit() {
	staticData := &cparserParserStaticData
	staticData.once.Do(cparserParserInit)
}

// NewCParser produces a new parser instance for the optional input antlr.TokenStream.
func NewCParser(input antlr.TokenStream) *CParser {
	CParserInit()
	this := new(CParser)
	this.BaseParser = antlr.NewBaseParser(input)
	staticData := &cparserParserStaticData
	this.Interpreter = antlr.NewParserATNSimulator(this, staticData.atn, staticData.decisionToDFA, staticData.predictionContextCache)
	this.RuleNames = staticData.ruleNames
	this.LiteralNames = staticData.literalNames
	this.SymbolicNames = staticData.symbolicNames
	this.GrammarFileName = "java-escape"

	return this
}

// CParser tokens.
const (
	CParserEOF              = antlr.TokenEOF
	CParserAuto             = 1
	CParserBreak            = 2
	CParserCase             = 3
	CParserChar             = 4
	CParserConst            = 5
	CParserContinue         = 6
	CParserDefault          = 7
	CParserDo               = 8
	CParserDouble           = 9
	CParserLongdouble       = 10
	CParserElse             = 11
	CParserEnum             = 12
	CParserExtern           = 13
	CParserFloat            = 14
	CParserFor              = 15
	CParserGoto             = 16
	CParserIf               = 17
	CParserInline           = 18
	CParserInt              = 19
	CParserLong             = 20
	CParserLonglong         = 21
	CParserRegister         = 22
	CParserRestrict         = 23
	CParserReturn           = 24
	CParserShort            = 25
	CParserSigned           = 26
	CParserSizeof           = 27
	CParserStatic           = 28
	CParserStruct           = 29
	CParserSwitch           = 30
	CParserTypedef          = 31
	CParserUnion            = 32
	CParserUnsigned         = 33
	CParserVoid             = 34
	CParserVolatile         = 35
	CParserWhile            = 36
	CParserAlignas          = 37
	CParserAlignof          = 38
	CParserAtomic           = 39
	CParserBool             = 40
	CParserComplex          = 41
	CParserGeneric          = 42
	CParserImaginary        = 43
	CParserNoreturn         = 44
	CParserStaticAssert     = 45
	CParserThreadLocal      = 46
	CParserLeftParen        = 47
	CParserRightParen       = 48
	CParserLeftBracket      = 49
	CParserRightBracket     = 50
	CParserLeftBrace        = 51
	CParserRightBrace       = 52
	CParserLess             = 53
	CParserLessEqual        = 54
	CParserGreater          = 55
	CParserGreaterEqual     = 56
	CParserLeftShift        = 57
	CParserRightShift       = 58
	CParserPlus             = 59
	CParserPlusPlus         = 60
	CParserMinus            = 61
	CParserMinusMinus       = 62
	CParserStar             = 63
	CParserDiv              = 64
	CParserMod              = 65
	CParserAnd              = 66
	CParserOr               = 67
	CParserAndAnd           = 68
	CParserOrOr             = 69
	CParserCaret            = 70
	CParserNot              = 71
	CParserTilde            = 72
	CParserQuestion         = 73
	CParserColon            = 74
	CParserSemi             = 75
	CParserComma            = 76
	CParserAssign           = 77
	CParserStarAssign       = 78
	CParserDivAssign        = 79
	CParserModAssign        = 80
	CParserPlusAssign       = 81
	CParserMinusAssign      = 82
	CParserLeftShiftAssign  = 83
	CParserRightShiftAssign = 84
	CParserAndAssign        = 85
	CParserXorAssign        = 86
	CParserOrAssign         = 87
	CParserEqual            = 88
	CParserNotEqual         = 89
	CParserArrow            = 90
	CParserDot              = 91
	CParserEllipsis         = 92
	CParserAsm              = 93
	CParserAttribute__      = 94
	CParserIdentifier       = 95
	CParserConstant         = 96
	CParserDigitSequence    = 97
	CParserStringLiteral    = 98
	CParserWS               = 99
	CParserLINE_COMMENT     = 100
	CParserBLOCK_COMMENT    = 101
	CParserExtension        = 102
	CParserBuiltinVaArg     = 103
	CParserBuiltinOffsetof  = 104
	CParserM128             = 105
	CParserM128d            = 106
	CParserM128i            = 107
	CParserTypeof           = 108
	CParserInline__         = 109
	CParserStdcall          = 110
	CParserDeclspec         = 111
	CParserCdecl            = 112
	CParserClrcall          = 113
	CParserFastcall         = 114
	CParserThiscall         = 115
	CParserVectorcall       = 116
	CParserVolatile__       = 117
	CParserMultiLineMacro   = 118
	CParserDirective        = 119
	CParserAsmBlock         = 120
	CParserWhitespace       = 121
	CParserNewline          = 122
	CParserBlockComment     = 123
	CParserLineComment      = 124
)

// CParser rules.
const (
	CParserRULE_primaryExpression        = 0
	CParserRULE_genericSelection         = 1
	CParserRULE_genericAssocList         = 2
	CParserRULE_genericAssociation       = 3
	CParserRULE_postfixExpression        = 4
	CParserRULE_postfixExpressionLvalue  = 5
	CParserRULE_argumentExpressionList   = 6
	CParserRULE_unaryExpression          = 7
	CParserRULE_castExpression           = 8
	CParserRULE_assignmentExpression     = 9
	CParserRULE_assignmentOperator       = 10
	CParserRULE_expressionList           = 11
	CParserRULE_statementsExpression     = 12
	CParserRULE_leftExpression           = 13
	CParserRULE_expression               = 14
	CParserRULE_declaration              = 15
	CParserRULE_declarationSpecifiers    = 16
	CParserRULE_declarationSpecifiers2   = 17
	CParserRULE_declarationSpecifier     = 18
	CParserRULE_initDeclaratorList       = 19
	CParserRULE_initDeclarator           = 20
	CParserRULE_storageClassSpecifier    = 21
	CParserRULE_typeSpecifier            = 22
	CParserRULE_structOrUnionSpecifier   = 23
	CParserRULE_structOrUnion            = 24
	CParserRULE_structDeclarationList    = 25
	CParserRULE_structDeclaration        = 26
	CParserRULE_specifierQualifierList   = 27
	CParserRULE_structDeclaratorList     = 28
	CParserRULE_structDeclarator         = 29
	CParserRULE_enumSpecifier            = 30
	CParserRULE_enumeratorList           = 31
	CParserRULE_enumerator               = 32
	CParserRULE_atomicTypeSpecifier      = 33
	CParserRULE_typeQualifier            = 34
	CParserRULE_functionSpecifier        = 35
	CParserRULE_alignmentSpecifier       = 36
	CParserRULE_declarator               = 37
	CParserRULE_directDeclarator         = 38
	CParserRULE_vcSpecificModifer        = 39
	CParserRULE_gccDeclaratorExtension   = 40
	CParserRULE_gccAttributeSpecifier    = 41
	CParserRULE_gccAttributeList         = 42
	CParserRULE_gccAttribute             = 43
	CParserRULE_pointer                  = 44
	CParserRULE_pointerPart              = 45
	CParserRULE_typeQualifierList        = 46
	CParserRULE_parameterTypeList        = 47
	CParserRULE_parameterList            = 48
	CParserRULE_parameterDeclaration     = 49
	CParserRULE_identifierList           = 50
	CParserRULE_typeName                 = 51
	CParserRULE_abstractDeclarator       = 52
	CParserRULE_directAbstractDeclarator = 53
	CParserRULE_typedefName              = 54
	CParserRULE_initializer              = 55
	CParserRULE_initializerList          = 56
	CParserRULE_designation              = 57
	CParserRULE_designatorList           = 58
	CParserRULE_designator               = 59
	CParserRULE_staticAssertDeclaration  = 60
	CParserRULE_statement                = 61
	CParserRULE_asmStatement             = 62
	CParserRULE_asmExprList              = 63
	CParserRULE_labeledStatement         = 64
	CParserRULE_compoundStatement        = 65
	CParserRULE_blockItemList            = 66
	CParserRULE_blockItem                = 67
	CParserRULE_expressionStatement      = 68
	CParserRULE_selectionStatement       = 69
	CParserRULE_iterationStatement       = 70
	CParserRULE_forCondition             = 71
	CParserRULE_assignmentExpressions    = 72
	CParserRULE_forDeclarations          = 73
	CParserRULE_forDeclaration           = 74
	CParserRULE_forExpression            = 75
	CParserRULE_jumpStatement            = 76
	CParserRULE_compilationUnit          = 77
	CParserRULE_translationUnit          = 78
	CParserRULE_externalDeclaration      = 79
	CParserRULE_functionDefinition       = 80
	CParserRULE_declarationList          = 81
)

// IPrimaryExpressionContext is an interface to support dynamic dispatch.
type IPrimaryExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPrimaryExpressionContext differentiates from other interfaces.
	IsPrimaryExpressionContext()
}

type PrimaryExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPrimaryExpressionContext() *PrimaryExpressionContext {
	var p = new(PrimaryExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CParserRULE_primaryExpression
	return p
}

func (*PrimaryExpressionContext) IsPrimaryExpressionContext() {}

func NewPrimaryExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PrimaryExpressionContext {
	var p = new(PrimaryExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CParserRULE_primaryExpression

	return p
}

func (s *PrimaryExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *PrimaryExpressionContext) Identifier() antlr.TerminalNode {
	return s.GetToken(CParserIdentifier, 0)
}

func (s *PrimaryExpressionContext) Constant() antlr.TerminalNode {
	return s.GetToken(CParserConstant, 0)
}

func (s *PrimaryExpressionContext) AllStringLiteral() []antlr.TerminalNode {
	return s.GetTokens(CParserStringLiteral)
}

func (s *PrimaryExpressionContext) StringLiteral(i int) antlr.TerminalNode {
	return s.GetToken(CParserStringLiteral, i)
}

func (s *PrimaryExpressionContext) LeftParen() antlr.TerminalNode {
	return s.GetToken(CParserLeftParen, 0)
}

func (s *PrimaryExpressionContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *PrimaryExpressionContext) RightParen() antlr.TerminalNode {
	return s.GetToken(CParserRightParen, 0)
}

func (s *PrimaryExpressionContext) GenericSelection() IGenericSelectionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGenericSelectionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGenericSelectionContext)
}

func (s *PrimaryExpressionContext) CompoundStatement() ICompoundStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICompoundStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICompoundStatementContext)
}

func (s *PrimaryExpressionContext) Extension() antlr.TerminalNode {
	return s.GetToken(CParserExtension, 0)
}

func (s *PrimaryExpressionContext) BuiltinVaArg() antlr.TerminalNode {
	return s.GetToken(CParserBuiltinVaArg, 0)
}

func (s *PrimaryExpressionContext) UnaryExpression() IUnaryExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnaryExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnaryExpressionContext)
}

func (s *PrimaryExpressionContext) Comma() antlr.TerminalNode {
	return s.GetToken(CParserComma, 0)
}

func (s *PrimaryExpressionContext) TypeName() ITypeNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeNameContext)
}

func (s *PrimaryExpressionContext) BuiltinOffsetof() antlr.TerminalNode {
	return s.GetToken(CParserBuiltinOffsetof, 0)
}

func (s *PrimaryExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrimaryExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PrimaryExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CParserVisitor:
		return t.VisitPrimaryExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CParser) PrimaryExpression() (localctx IPrimaryExpressionContext) {
	this := p
	_ = this

	localctx = NewPrimaryExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 0, CParserRULE_primaryExpression)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.SetState(197)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 2, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(164)
			p.Match(CParserIdentifier)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(165)
			p.Match(CParserConstant)
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		p.SetState(167)
		p.GetErrorHandler().Sync(p)
		_alt = 1
		for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			switch _alt {
			case 1:
				{
					p.SetState(166)
					p.Match(CParserStringLiteral)
				}

			default:
				panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			}

			p.SetState(169)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 0, p.GetParserRuleContext())
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(171)
			p.Match(CParserLeftParen)
		}
		{
			p.SetState(172)
			p.expression(0)
		}
		{
			p.SetState(173)
			p.Match(CParserRightParen)
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(175)
			p.GenericSelection()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		p.SetState(177)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == CParserExtension {
			{
				p.SetState(176)
				p.Match(CParserExtension)
			}

		}
		{
			p.SetState(179)
			p.Match(CParserLeftParen)
		}
		{
			p.SetState(180)
			p.CompoundStatement()
		}
		{
			p.SetState(181)
			p.Match(CParserRightParen)
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(183)
			p.Match(CParserBuiltinVaArg)
		}
		{
			p.SetState(184)
			p.Match(CParserLeftParen)
		}
		{
			p.SetState(185)
			p.UnaryExpression()
		}
		{
			p.SetState(186)
			p.Match(CParserComma)
		}
		{
			p.SetState(187)
			p.typeName(0)
		}
		{
			p.SetState(188)
			p.Match(CParserRightParen)
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(190)
			p.Match(CParserBuiltinOffsetof)
		}
		{
			p.SetState(191)
			p.Match(CParserLeftParen)
		}
		{
			p.SetState(192)
			p.typeName(0)
		}
		{
			p.SetState(193)
			p.Match(CParserComma)
		}
		{
			p.SetState(194)
			p.UnaryExpression()
		}
		{
			p.SetState(195)
			p.Match(CParserRightParen)
		}

	}

	return localctx
}

// IGenericSelectionContext is an interface to support dynamic dispatch.
type IGenericSelectionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsGenericSelectionContext differentiates from other interfaces.
	IsGenericSelectionContext()
}

type GenericSelectionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGenericSelectionContext() *GenericSelectionContext {
	var p = new(GenericSelectionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CParserRULE_genericSelection
	return p
}

func (*GenericSelectionContext) IsGenericSelectionContext() {}

func NewGenericSelectionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GenericSelectionContext {
	var p = new(GenericSelectionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CParserRULE_genericSelection

	return p
}

func (s *GenericSelectionContext) GetParser() antlr.Parser { return s.parser }

func (s *GenericSelectionContext) Generic() antlr.TerminalNode {
	return s.GetToken(CParserGeneric, 0)
}

func (s *GenericSelectionContext) LeftParen() antlr.TerminalNode {
	return s.GetToken(CParserLeftParen, 0)
}

func (s *GenericSelectionContext) AssignmentExpression() IAssignmentExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAssignmentExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAssignmentExpressionContext)
}

func (s *GenericSelectionContext) Comma() antlr.TerminalNode {
	return s.GetToken(CParserComma, 0)
}

func (s *GenericSelectionContext) GenericAssocList() IGenericAssocListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGenericAssocListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGenericAssocListContext)
}

func (s *GenericSelectionContext) RightParen() antlr.TerminalNode {
	return s.GetToken(CParserRightParen, 0)
}

func (s *GenericSelectionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GenericSelectionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GenericSelectionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CParserVisitor:
		return t.VisitGenericSelection(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CParser) GenericSelection() (localctx IGenericSelectionContext) {
	this := p
	_ = this

	localctx = NewGenericSelectionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 2, CParserRULE_genericSelection)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(199)
		p.Match(CParserGeneric)
	}
	{
		p.SetState(200)
		p.Match(CParserLeftParen)
	}
	{
		p.SetState(201)
		p.AssignmentExpression()
	}
	{
		p.SetState(202)
		p.Match(CParserComma)
	}
	{
		p.SetState(203)
		p.GenericAssocList()
	}
	{
		p.SetState(204)
		p.Match(CParserRightParen)
	}

	return localctx
}

// IGenericAssocListContext is an interface to support dynamic dispatch.
type IGenericAssocListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsGenericAssocListContext differentiates from other interfaces.
	IsGenericAssocListContext()
}

type GenericAssocListContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGenericAssocListContext() *GenericAssocListContext {
	var p = new(GenericAssocListContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CParserRULE_genericAssocList
	return p
}

func (*GenericAssocListContext) IsGenericAssocListContext() {}

func NewGenericAssocListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GenericAssocListContext {
	var p = new(GenericAssocListContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CParserRULE_genericAssocList

	return p
}

func (s *GenericAssocListContext) GetParser() antlr.Parser { return s.parser }

func (s *GenericAssocListContext) AllGenericAssociation() []IGenericAssociationContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IGenericAssociationContext); ok {
			len++
		}
	}

	tst := make([]IGenericAssociationContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IGenericAssociationContext); ok {
			tst[i] = t.(IGenericAssociationContext)
			i++
		}
	}

	return tst
}

func (s *GenericAssocListContext) GenericAssociation(i int) IGenericAssociationContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGenericAssociationContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGenericAssociationContext)
}

func (s *GenericAssocListContext) AllComma() []antlr.TerminalNode {
	return s.GetTokens(CParserComma)
}

func (s *GenericAssocListContext) Comma(i int) antlr.TerminalNode {
	return s.GetToken(CParserComma, i)
}

func (s *GenericAssocListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GenericAssocListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GenericAssocListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CParserVisitor:
		return t.VisitGenericAssocList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CParser) GenericAssocList() (localctx IGenericAssocListContext) {
	this := p
	_ = this

	localctx = NewGenericAssocListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 4, CParserRULE_genericAssocList)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(206)
		p.GenericAssociation()
	}
	p.SetState(211)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == CParserComma {
		{
			p.SetState(207)
			p.Match(CParserComma)
		}
		{
			p.SetState(208)
			p.GenericAssociation()
		}

		p.SetState(213)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IGenericAssociationContext is an interface to support dynamic dispatch.
type IGenericAssociationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsGenericAssociationContext differentiates from other interfaces.
	IsGenericAssociationContext()
}

type GenericAssociationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGenericAssociationContext() *GenericAssociationContext {
	var p = new(GenericAssociationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CParserRULE_genericAssociation
	return p
}

func (*GenericAssociationContext) IsGenericAssociationContext() {}

func NewGenericAssociationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GenericAssociationContext {
	var p = new(GenericAssociationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CParserRULE_genericAssociation

	return p
}

func (s *GenericAssociationContext) GetParser() antlr.Parser { return s.parser }

func (s *GenericAssociationContext) Colon() antlr.TerminalNode {
	return s.GetToken(CParserColon, 0)
}

func (s *GenericAssociationContext) AssignmentExpression() IAssignmentExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAssignmentExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAssignmentExpressionContext)
}

func (s *GenericAssociationContext) TypeName() ITypeNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeNameContext)
}

func (s *GenericAssociationContext) Default() antlr.TerminalNode {
	return s.GetToken(CParserDefault, 0)
}

func (s *GenericAssociationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GenericAssociationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GenericAssociationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CParserVisitor:
		return t.VisitGenericAssociation(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CParser) GenericAssociation() (localctx IGenericAssociationContext) {
	this := p
	_ = this

	localctx = NewGenericAssociationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 6, CParserRULE_genericAssociation)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(216)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case CParserChar, CParserConst, CParserDouble, CParserLongdouble, CParserEnum, CParserFloat, CParserInt, CParserLong, CParserLonglong, CParserRestrict, CParserShort, CParserSigned, CParserStruct, CParserUnion, CParserUnsigned, CParserVoid, CParserVolatile, CParserAtomic, CParserBool, CParserComplex, CParserIdentifier, CParserExtension, CParserM128, CParserM128d, CParserM128i, CParserTypeof:
		{
			p.SetState(214)
			p.typeName(0)
		}

	case CParserDefault:
		{
			p.SetState(215)
			p.Match(CParserDefault)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}
	{
		p.SetState(218)
		p.Match(CParserColon)
	}
	{
		p.SetState(219)
		p.AssignmentExpression()
	}

	return localctx
}

// IPostfixExpressionContext is an interface to support dynamic dispatch.
type IPostfixExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPostfixExpressionContext differentiates from other interfaces.
	IsPostfixExpressionContext()
}

type PostfixExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPostfixExpressionContext() *PostfixExpressionContext {
	var p = new(PostfixExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CParserRULE_postfixExpression
	return p
}

func (*PostfixExpressionContext) IsPostfixExpressionContext() {}

func NewPostfixExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PostfixExpressionContext {
	var p = new(PostfixExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CParserRULE_postfixExpression

	return p
}

func (s *PostfixExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *PostfixExpressionContext) PrimaryExpression() IPrimaryExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrimaryExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrimaryExpressionContext)
}

func (s *PostfixExpressionContext) LeftParen() antlr.TerminalNode {
	return s.GetToken(CParserLeftParen, 0)
}

func (s *PostfixExpressionContext) TypeName() ITypeNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeNameContext)
}

func (s *PostfixExpressionContext) RightParen() antlr.TerminalNode {
	return s.GetToken(CParserRightParen, 0)
}

func (s *PostfixExpressionContext) LeftBrace() antlr.TerminalNode {
	return s.GetToken(CParserLeftBrace, 0)
}

func (s *PostfixExpressionContext) InitializerList() IInitializerListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInitializerListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInitializerListContext)
}

func (s *PostfixExpressionContext) RightBrace() antlr.TerminalNode {
	return s.GetToken(CParserRightBrace, 0)
}

func (s *PostfixExpressionContext) Extension() antlr.TerminalNode {
	return s.GetToken(CParserExtension, 0)
}

func (s *PostfixExpressionContext) Comma() antlr.TerminalNode {
	return s.GetToken(CParserComma, 0)
}

func (s *PostfixExpressionContext) LeftExpression() ILeftExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILeftExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILeftExpressionContext)
}

func (s *PostfixExpressionContext) PlusPlus() antlr.TerminalNode {
	return s.GetToken(CParserPlusPlus, 0)
}

func (s *PostfixExpressionContext) MinusMinus() antlr.TerminalNode {
	return s.GetToken(CParserMinusMinus, 0)
}

func (s *PostfixExpressionContext) PostfixExpression() IPostfixExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPostfixExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPostfixExpressionContext)
}

func (s *PostfixExpressionContext) LeftBracket() antlr.TerminalNode {
	return s.GetToken(CParserLeftBracket, 0)
}

func (s *PostfixExpressionContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *PostfixExpressionContext) RightBracket() antlr.TerminalNode {
	return s.GetToken(CParserRightBracket, 0)
}

func (s *PostfixExpressionContext) ArgumentExpressionList() IArgumentExpressionListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArgumentExpressionListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArgumentExpressionListContext)
}

func (s *PostfixExpressionContext) Identifier() antlr.TerminalNode {
	return s.GetToken(CParserIdentifier, 0)
}

func (s *PostfixExpressionContext) Dot() antlr.TerminalNode {
	return s.GetToken(CParserDot, 0)
}

func (s *PostfixExpressionContext) Arrow() antlr.TerminalNode {
	return s.GetToken(CParserArrow, 0)
}

func (s *PostfixExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PostfixExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PostfixExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CParserVisitor:
		return t.VisitPostfixExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CParser) PostfixExpression() (localctx IPostfixExpressionContext) {
	return p.postfixExpression(0)
}

func (p *CParser) postfixExpression(_p int) (localctx IPostfixExpressionContext) {
	this := p
	_ = this

	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()
	_parentState := p.GetState()
	localctx = NewPostfixExpressionContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IPostfixExpressionContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 8
	p.EnterRecursionRule(localctx, 8, CParserRULE_postfixExpression, _p)
	var _la int

	defer func() {
		p.UnrollRecursionContexts(_parentctx)
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(244)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 8, p.GetParserRuleContext()) {
	case 1:
		p.SetState(236)
		p.GetErrorHandler().Sync(p)
		switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 7, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(222)
				p.PrimaryExpression()
			}

		case 2:
			p.SetState(224)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == CParserExtension {
				{
					p.SetState(223)
					p.Match(CParserExtension)
				}

			}
			{
				p.SetState(226)
				p.Match(CParserLeftParen)
			}
			{
				p.SetState(227)
				p.typeName(0)
			}
			{
				p.SetState(228)
				p.Match(CParserRightParen)
			}
			{
				p.SetState(229)
				p.Match(CParserLeftBrace)
			}
			{
				p.SetState(230)
				p.InitializerList()
			}
			p.SetState(232)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == CParserComma {
				{
					p.SetState(231)
					p.Match(CParserComma)
				}

			}
			{
				p.SetState(234)
				p.Match(CParserRightBrace)
			}

		}

	case 2:
		{
			p.SetState(238)
			p.LeftExpression()
		}
		{
			p.SetState(239)
			p.Match(CParserPlusPlus)
		}

	case 3:
		{
			p.SetState(241)
			p.LeftExpression()
		}
		{
			p.SetState(242)
			p.Match(CParserMinusMinus)
		}

	}
	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(262)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 11, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			p.SetState(260)
			p.GetErrorHandler().Sync(p)
			switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 10, p.GetParserRuleContext()) {
			case 1:
				localctx = NewPostfixExpressionContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, CParserRULE_postfixExpression)
				p.SetState(246)

				if !(p.Precpred(p.GetParserRuleContext(), 5)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 5)", ""))
				}
				{
					p.SetState(247)
					p.Match(CParserLeftBracket)
				}
				{
					p.SetState(248)
					p.expression(0)
				}
				{
					p.SetState(249)
					p.Match(CParserRightBracket)
				}

			case 2:
				localctx = NewPostfixExpressionContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, CParserRULE_postfixExpression)
				p.SetState(251)

				if !(p.Precpred(p.GetParserRuleContext(), 4)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 4)", ""))
				}
				{
					p.SetState(252)
					p.Match(CParserLeftParen)
				}
				p.SetState(254)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)

				if (int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-576223327602051534) != 0 || (int64((_la-66)) & ^0x3f) == 0 && ((int64(1)<<(_la-66))&70308346200181) != 0 {
					{
						p.SetState(253)
						p.ArgumentExpressionList()
					}

				}
				{
					p.SetState(256)
					p.Match(CParserRightParen)
				}

			case 3:
				localctx = NewPostfixExpressionContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, CParserRULE_postfixExpression)
				p.SetState(257)

				if !(p.Precpred(p.GetParserRuleContext(), 3)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 3)", ""))
				}
				{
					p.SetState(258)
					_la = p.GetTokenStream().LA(1)

					if !(_la == CParserArrow || _la == CParserDot) {
						p.GetErrorHandler().RecoverInline(p)
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				{
					p.SetState(259)
					p.Match(CParserIdentifier)
				}

			}

		}
		p.SetState(264)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 11, p.GetParserRuleContext())
	}

	return localctx
}

// IPostfixExpressionLvalueContext is an interface to support dynamic dispatch.
type IPostfixExpressionLvalueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPostfixExpressionLvalueContext differentiates from other interfaces.
	IsPostfixExpressionLvalueContext()
}

type PostfixExpressionLvalueContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPostfixExpressionLvalueContext() *PostfixExpressionLvalueContext {
	var p = new(PostfixExpressionLvalueContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CParserRULE_postfixExpressionLvalue
	return p
}

func (*PostfixExpressionLvalueContext) IsPostfixExpressionLvalueContext() {}

func NewPostfixExpressionLvalueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PostfixExpressionLvalueContext {
	var p = new(PostfixExpressionLvalueContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CParserRULE_postfixExpressionLvalue

	return p
}

func (s *PostfixExpressionLvalueContext) GetParser() antlr.Parser { return s.parser }

func (s *PostfixExpressionLvalueContext) PrimaryExpression() IPrimaryExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrimaryExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrimaryExpressionContext)
}

func (s *PostfixExpressionLvalueContext) LeftParen() antlr.TerminalNode {
	return s.GetToken(CParserLeftParen, 0)
}

func (s *PostfixExpressionLvalueContext) TypeName() ITypeNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeNameContext)
}

func (s *PostfixExpressionLvalueContext) RightParen() antlr.TerminalNode {
	return s.GetToken(CParserRightParen, 0)
}

func (s *PostfixExpressionLvalueContext) LeftBrace() antlr.TerminalNode {
	return s.GetToken(CParserLeftBrace, 0)
}

func (s *PostfixExpressionLvalueContext) InitializerList() IInitializerListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInitializerListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInitializerListContext)
}

func (s *PostfixExpressionLvalueContext) RightBrace() antlr.TerminalNode {
	return s.GetToken(CParserRightBrace, 0)
}

func (s *PostfixExpressionLvalueContext) Extension() antlr.TerminalNode {
	return s.GetToken(CParserExtension, 0)
}

func (s *PostfixExpressionLvalueContext) Comma() antlr.TerminalNode {
	return s.GetToken(CParserComma, 0)
}

func (s *PostfixExpressionLvalueContext) PostfixExpressionLvalue() IPostfixExpressionLvalueContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPostfixExpressionLvalueContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPostfixExpressionLvalueContext)
}

func (s *PostfixExpressionLvalueContext) LeftBracket() antlr.TerminalNode {
	return s.GetToken(CParserLeftBracket, 0)
}

func (s *PostfixExpressionLvalueContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *PostfixExpressionLvalueContext) RightBracket() antlr.TerminalNode {
	return s.GetToken(CParserRightBracket, 0)
}

func (s *PostfixExpressionLvalueContext) Identifier() antlr.TerminalNode {
	return s.GetToken(CParserIdentifier, 0)
}

func (s *PostfixExpressionLvalueContext) Dot() antlr.TerminalNode {
	return s.GetToken(CParserDot, 0)
}

func (s *PostfixExpressionLvalueContext) Arrow() antlr.TerminalNode {
	return s.GetToken(CParserArrow, 0)
}

func (s *PostfixExpressionLvalueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PostfixExpressionLvalueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PostfixExpressionLvalueContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CParserVisitor:
		return t.VisitPostfixExpressionLvalue(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CParser) PostfixExpressionLvalue() (localctx IPostfixExpressionLvalueContext) {
	return p.postfixExpressionLvalue(0)
}

func (p *CParser) postfixExpressionLvalue(_p int) (localctx IPostfixExpressionLvalueContext) {
	this := p
	_ = this

	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()
	_parentState := p.GetState()
	localctx = NewPostfixExpressionLvalueContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IPostfixExpressionLvalueContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 10
	p.EnterRecursionRule(localctx, 10, CParserRULE_postfixExpressionLvalue, _p)
	var _la int

	defer func() {
		p.UnrollRecursionContexts(_parentctx)
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(280)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 14, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(266)
			p.PrimaryExpression()
		}

	case 2:
		p.SetState(268)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == CParserExtension {
			{
				p.SetState(267)
				p.Match(CParserExtension)
			}

		}
		{
			p.SetState(270)
			p.Match(CParserLeftParen)
		}
		{
			p.SetState(271)
			p.typeName(0)
		}
		{
			p.SetState(272)
			p.Match(CParserRightParen)
		}
		{
			p.SetState(273)
			p.Match(CParserLeftBrace)
		}
		{
			p.SetState(274)
			p.InitializerList()
		}
		p.SetState(276)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == CParserComma {
			{
				p.SetState(275)
				p.Match(CParserComma)
			}

		}
		{
			p.SetState(278)
			p.Match(CParserRightBrace)
		}

	}

	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(292)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 16, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			p.SetState(290)
			p.GetErrorHandler().Sync(p)
			switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 15, p.GetParserRuleContext()) {
			case 1:
				localctx = NewPostfixExpressionLvalueContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, CParserRULE_postfixExpressionLvalue)
				p.SetState(282)

				if !(p.Precpred(p.GetParserRuleContext(), 2)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 2)", ""))
				}
				{
					p.SetState(283)
					p.Match(CParserLeftBracket)
				}
				{
					p.SetState(284)
					p.expression(0)
				}
				{
					p.SetState(285)
					p.Match(CParserRightBracket)
				}

			case 2:
				localctx = NewPostfixExpressionLvalueContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, CParserRULE_postfixExpressionLvalue)
				p.SetState(287)

				if !(p.Precpred(p.GetParserRuleContext(), 1)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 1)", ""))
				}
				{
					p.SetState(288)
					_la = p.GetTokenStream().LA(1)

					if !(_la == CParserArrow || _la == CParserDot) {
						p.GetErrorHandler().RecoverInline(p)
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				{
					p.SetState(289)
					p.Match(CParserIdentifier)
				}

			}

		}
		p.SetState(294)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 16, p.GetParserRuleContext())
	}

	return localctx
}

// IArgumentExpressionListContext is an interface to support dynamic dispatch.
type IArgumentExpressionListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsArgumentExpressionListContext differentiates from other interfaces.
	IsArgumentExpressionListContext()
}

type ArgumentExpressionListContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyArgumentExpressionListContext() *ArgumentExpressionListContext {
	var p = new(ArgumentExpressionListContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CParserRULE_argumentExpressionList
	return p
}

func (*ArgumentExpressionListContext) IsArgumentExpressionListContext() {}

func NewArgumentExpressionListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ArgumentExpressionListContext {
	var p = new(ArgumentExpressionListContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CParserRULE_argumentExpressionList

	return p
}

func (s *ArgumentExpressionListContext) GetParser() antlr.Parser { return s.parser }

func (s *ArgumentExpressionListContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *ArgumentExpressionListContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ArgumentExpressionListContext) AllComma() []antlr.TerminalNode {
	return s.GetTokens(CParserComma)
}

func (s *ArgumentExpressionListContext) Comma(i int) antlr.TerminalNode {
	return s.GetToken(CParserComma, i)
}

func (s *ArgumentExpressionListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArgumentExpressionListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ArgumentExpressionListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CParserVisitor:
		return t.VisitArgumentExpressionList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CParser) ArgumentExpressionList() (localctx IArgumentExpressionListContext) {
	this := p
	_ = this

	localctx = NewArgumentExpressionListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 12, CParserRULE_argumentExpressionList)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(295)
		p.expression(0)
	}
	p.SetState(300)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == CParserComma {
		{
			p.SetState(296)
			p.Match(CParserComma)
		}
		{
			p.SetState(297)
			p.expression(0)
		}

		p.SetState(302)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IUnaryExpressionContext is an interface to support dynamic dispatch.
type IUnaryExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsUnaryExpressionContext differentiates from other interfaces.
	IsUnaryExpressionContext()
}

type UnaryExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnaryExpressionContext() *UnaryExpressionContext {
	var p = new(UnaryExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CParserRULE_unaryExpression
	return p
}

func (*UnaryExpressionContext) IsUnaryExpressionContext() {}

func NewUnaryExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UnaryExpressionContext {
	var p = new(UnaryExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CParserRULE_unaryExpression

	return p
}

func (s *UnaryExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *UnaryExpressionContext) LeftExpression() ILeftExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILeftExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILeftExpressionContext)
}

func (s *UnaryExpressionContext) PlusPlus() antlr.TerminalNode {
	return s.GetToken(CParserPlusPlus, 0)
}

func (s *UnaryExpressionContext) MinusMinus() antlr.TerminalNode {
	return s.GetToken(CParserMinusMinus, 0)
}

func (s *UnaryExpressionContext) AllStar() []antlr.TerminalNode {
	return s.GetTokens(CParserStar)
}

func (s *UnaryExpressionContext) Star(i int) antlr.TerminalNode {
	return s.GetToken(CParserStar, i)
}

func (s *UnaryExpressionContext) UnaryExpression() IUnaryExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnaryExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnaryExpressionContext)
}

func (s *UnaryExpressionContext) And() antlr.TerminalNode {
	return s.GetToken(CParserAnd, 0)
}

func (s *UnaryExpressionContext) LeftParen() antlr.TerminalNode {
	return s.GetToken(CParserLeftParen, 0)
}

func (s *UnaryExpressionContext) TypeName() ITypeNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeNameContext)
}

func (s *UnaryExpressionContext) RightParen() antlr.TerminalNode {
	return s.GetToken(CParserRightParen, 0)
}

func (s *UnaryExpressionContext) Sizeof() antlr.TerminalNode {
	return s.GetToken(CParserSizeof, 0)
}

func (s *UnaryExpressionContext) Alignof() antlr.TerminalNode {
	return s.GetToken(CParserAlignof, 0)
}

func (s *UnaryExpressionContext) AndAnd() antlr.TerminalNode {
	return s.GetToken(CParserAndAnd, 0)
}

func (s *UnaryExpressionContext) PostfixExpression() IPostfixExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPostfixExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPostfixExpressionContext)
}

func (s *UnaryExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnaryExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UnaryExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CParserVisitor:
		return t.VisitUnaryExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CParser) UnaryExpression() (localctx IUnaryExpressionContext) {
	this := p
	_ = this

	localctx = NewUnaryExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 14, CParserRULE_unaryExpression)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(323)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 19, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(303)
			_la = p.GetTokenStream().LA(1)

			if !(_la == CParserPlusPlus || _la == CParserMinusMinus) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(304)
			p.LeftExpression()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(305)
			p.Match(CParserStar)
		}
		{
			p.SetState(306)
			p.UnaryExpression()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(307)
			p.Match(CParserAnd)
		}
		{
			p.SetState(308)
			p.LeftExpression()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(309)
			_la = p.GetTokenStream().LA(1)

			if !(_la == CParserSizeof || _la == CParserAlignof) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(310)
			p.Match(CParserLeftParen)
		}
		p.SetState(314)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == CParserStar {
			{
				p.SetState(311)
				p.Match(CParserStar)
			}

			p.SetState(316)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(317)
			p.typeName(0)
		}
		{
			p.SetState(318)
			p.Match(CParserRightParen)
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(320)
			p.Match(CParserAndAnd)
		}
		{
			p.SetState(321)
			p.UnaryExpression()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(322)
			p.postfixExpression(0)
		}

	}

	return localctx
}

// ICastExpressionContext is an interface to support dynamic dispatch.
type ICastExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCastExpressionContext differentiates from other interfaces.
	IsCastExpressionContext()
}

type CastExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCastExpressionContext() *CastExpressionContext {
	var p = new(CastExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CParserRULE_castExpression
	return p
}

func (*CastExpressionContext) IsCastExpressionContext() {}

func NewCastExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CastExpressionContext {
	var p = new(CastExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CParserRULE_castExpression

	return p
}

func (s *CastExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *CastExpressionContext) LeftParen() antlr.TerminalNode {
	return s.GetToken(CParserLeftParen, 0)
}

func (s *CastExpressionContext) TypeName() ITypeNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeNameContext)
}

func (s *CastExpressionContext) RightParen() antlr.TerminalNode {
	return s.GetToken(CParserRightParen, 0)
}

func (s *CastExpressionContext) CastExpression() ICastExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICastExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICastExpressionContext)
}

func (s *CastExpressionContext) Extension() antlr.TerminalNode {
	return s.GetToken(CParserExtension, 0)
}

func (s *CastExpressionContext) UnaryExpression() IUnaryExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnaryExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnaryExpressionContext)
}

func (s *CastExpressionContext) DigitSequence() antlr.TerminalNode {
	return s.GetToken(CParserDigitSequence, 0)
}

func (s *CastExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CastExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CastExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CParserVisitor:
		return t.VisitCastExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CParser) CastExpression() (localctx ICastExpressionContext) {
	this := p
	_ = this

	localctx = NewCastExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 16, CParserRULE_castExpression)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(335)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 21, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(326)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == CParserExtension {
			{
				p.SetState(325)
				p.Match(CParserExtension)
			}

		}
		{
			p.SetState(328)
			p.Match(CParserLeftParen)
		}
		{
			p.SetState(329)
			p.typeName(0)
		}
		{
			p.SetState(330)
			p.Match(CParserRightParen)
		}
		{
			p.SetState(331)
			p.CastExpression()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(333)
			p.UnaryExpression()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(334)
			p.Match(CParserDigitSequence)
		}

	}

	return localctx
}

// IAssignmentExpressionContext is an interface to support dynamic dispatch.
type IAssignmentExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAssignmentExpressionContext differentiates from other interfaces.
	IsAssignmentExpressionContext()
}

type AssignmentExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAssignmentExpressionContext() *AssignmentExpressionContext {
	var p = new(AssignmentExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CParserRULE_assignmentExpression
	return p
}

func (*AssignmentExpressionContext) IsAssignmentExpressionContext() {}

func NewAssignmentExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AssignmentExpressionContext {
	var p = new(AssignmentExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CParserRULE_assignmentExpression

	return p
}

func (s *AssignmentExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *AssignmentExpressionContext) LeftExpression() ILeftExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILeftExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILeftExpressionContext)
}

func (s *AssignmentExpressionContext) AssignmentOperator() IAssignmentOperatorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAssignmentOperatorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAssignmentOperatorContext)
}

func (s *AssignmentExpressionContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *AssignmentExpressionContext) CastExpression() ICastExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICastExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICastExpressionContext)
}

func (s *AssignmentExpressionContext) DigitSequence() antlr.TerminalNode {
	return s.GetToken(CParserDigitSequence, 0)
}

func (s *AssignmentExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AssignmentExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AssignmentExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CParserVisitor:
		return t.VisitAssignmentExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CParser) AssignmentExpression() (localctx IAssignmentExpressionContext) {
	this := p
	_ = this

	localctx = NewAssignmentExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 18, CParserRULE_assignmentExpression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(343)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 22, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(337)
			p.LeftExpression()
		}
		{
			p.SetState(338)
			p.AssignmentOperator()
		}
		{
			p.SetState(339)
			p.expression(0)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(341)
			p.CastExpression()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(342)
			p.Match(CParserDigitSequence)
		}

	}

	return localctx
}

// IAssignmentOperatorContext is an interface to support dynamic dispatch.
type IAssignmentOperatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAssignmentOperatorContext differentiates from other interfaces.
	IsAssignmentOperatorContext()
}

type AssignmentOperatorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAssignmentOperatorContext() *AssignmentOperatorContext {
	var p = new(AssignmentOperatorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CParserRULE_assignmentOperator
	return p
}

func (*AssignmentOperatorContext) IsAssignmentOperatorContext() {}

func NewAssignmentOperatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AssignmentOperatorContext {
	var p = new(AssignmentOperatorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CParserRULE_assignmentOperator

	return p
}

func (s *AssignmentOperatorContext) GetParser() antlr.Parser { return s.parser }

func (s *AssignmentOperatorContext) Assign() antlr.TerminalNode {
	return s.GetToken(CParserAssign, 0)
}

func (s *AssignmentOperatorContext) StarAssign() antlr.TerminalNode {
	return s.GetToken(CParserStarAssign, 0)
}

func (s *AssignmentOperatorContext) DivAssign() antlr.TerminalNode {
	return s.GetToken(CParserDivAssign, 0)
}

func (s *AssignmentOperatorContext) ModAssign() antlr.TerminalNode {
	return s.GetToken(CParserModAssign, 0)
}

func (s *AssignmentOperatorContext) PlusAssign() antlr.TerminalNode {
	return s.GetToken(CParserPlusAssign, 0)
}

func (s *AssignmentOperatorContext) MinusAssign() antlr.TerminalNode {
	return s.GetToken(CParserMinusAssign, 0)
}

func (s *AssignmentOperatorContext) LeftShiftAssign() antlr.TerminalNode {
	return s.GetToken(CParserLeftShiftAssign, 0)
}

func (s *AssignmentOperatorContext) RightShiftAssign() antlr.TerminalNode {
	return s.GetToken(CParserRightShiftAssign, 0)
}

func (s *AssignmentOperatorContext) AndAssign() antlr.TerminalNode {
	return s.GetToken(CParserAndAssign, 0)
}

func (s *AssignmentOperatorContext) XorAssign() antlr.TerminalNode {
	return s.GetToken(CParserXorAssign, 0)
}

func (s *AssignmentOperatorContext) OrAssign() antlr.TerminalNode {
	return s.GetToken(CParserOrAssign, 0)
}

func (s *AssignmentOperatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AssignmentOperatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AssignmentOperatorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CParserVisitor:
		return t.VisitAssignmentOperator(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CParser) AssignmentOperator() (localctx IAssignmentOperatorContext) {
	this := p
	_ = this

	localctx = NewAssignmentOperatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 20, CParserRULE_assignmentOperator)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(345)
		_la = p.GetTokenStream().LA(1)

		if !((int64((_la-77)) & ^0x3f) == 0 && ((int64(1)<<(_la-77))&2047) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IExpressionListContext is an interface to support dynamic dispatch.
type IExpressionListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExpressionListContext differentiates from other interfaces.
	IsExpressionListContext()
}

type ExpressionListContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpressionListContext() *ExpressionListContext {
	var p = new(ExpressionListContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CParserRULE_expressionList
	return p
}

func (*ExpressionListContext) IsExpressionListContext() {}

func NewExpressionListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExpressionListContext {
	var p = new(ExpressionListContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CParserRULE_expressionList

	return p
}

func (s *ExpressionListContext) GetParser() antlr.Parser { return s.parser }

func (s *ExpressionListContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *ExpressionListContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ExpressionListContext) AllComma() []antlr.TerminalNode {
	return s.GetTokens(CParserComma)
}

func (s *ExpressionListContext) Comma(i int) antlr.TerminalNode {
	return s.GetToken(CParserComma, i)
}

func (s *ExpressionListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExpressionListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExpressionListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CParserVisitor:
		return t.VisitExpressionList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CParser) ExpressionList() (localctx IExpressionListContext) {
	this := p
	_ = this

	localctx = NewExpressionListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 22, CParserRULE_expressionList)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(347)
		p.expression(0)
	}
	p.SetState(352)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == CParserComma {
		{
			p.SetState(348)
			p.Match(CParserComma)
		}
		{
			p.SetState(349)
			p.expression(0)
		}

		p.SetState(354)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IStatementsExpressionContext is an interface to support dynamic dispatch.
type IStatementsExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsStatementsExpressionContext differentiates from other interfaces.
	IsStatementsExpressionContext()
}

type StatementsExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStatementsExpressionContext() *StatementsExpressionContext {
	var p = new(StatementsExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CParserRULE_statementsExpression
	return p
}

func (*StatementsExpressionContext) IsStatementsExpressionContext() {}

func NewStatementsExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StatementsExpressionContext {
	var p = new(StatementsExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CParserRULE_statementsExpression

	return p
}

func (s *StatementsExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *StatementsExpressionContext) LeftParen() antlr.TerminalNode {
	return s.GetToken(CParserLeftParen, 0)
}

func (s *StatementsExpressionContext) LeftBrace() antlr.TerminalNode {
	return s.GetToken(CParserLeftBrace, 0)
}

func (s *StatementsExpressionContext) RightBrace() antlr.TerminalNode {
	return s.GetToken(CParserRightBrace, 0)
}

func (s *StatementsExpressionContext) RightParen() antlr.TerminalNode {
	return s.GetToken(CParserRightParen, 0)
}

func (s *StatementsExpressionContext) AllStatement() []IStatementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStatementContext); ok {
			len++
		}
	}

	tst := make([]IStatementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStatementContext); ok {
			tst[i] = t.(IStatementContext)
			i++
		}
	}

	return tst
}

func (s *StatementsExpressionContext) Statement(i int) IStatementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *StatementsExpressionContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *StatementsExpressionContext) Semi() antlr.TerminalNode {
	return s.GetToken(CParserSemi, 0)
}

func (s *StatementsExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StatementsExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StatementsExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CParserVisitor:
		return t.VisitStatementsExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CParser) StatementsExpression() (localctx IStatementsExpressionContext) {
	this := p
	_ = this

	localctx = NewStatementsExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 24, CParserRULE_statementsExpression)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(355)
		p.Match(CParserLeftParen)
	}
	{
		p.SetState(356)
		p.Match(CParserLeftBrace)
	}
	p.SetState(360)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 24, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(357)
				p.Statement()
			}

		}
		p.SetState(362)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 24, p.GetParserRuleContext())
	}
	p.SetState(364)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if (int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-576223327602051534) != 0 || (int64((_la-66)) & ^0x3f) == 0 && ((int64(1)<<(_la-66))&70308346200181) != 0 {
		{
			p.SetState(363)
			p.expression(0)
		}

	}
	p.SetState(367)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == CParserSemi {
		{
			p.SetState(366)
			p.Match(CParserSemi)
		}

	}
	{
		p.SetState(369)
		p.Match(CParserRightBrace)
	}
	{
		p.SetState(370)
		p.Match(CParserRightParen)
	}

	return localctx
}

// ILeftExpressionContext is an interface to support dynamic dispatch.
type ILeftExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLeftExpressionContext differentiates from other interfaces.
	IsLeftExpressionContext()
}

type LeftExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLeftExpressionContext() *LeftExpressionContext {
	var p = new(LeftExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CParserRULE_leftExpression
	return p
}

func (*LeftExpressionContext) IsLeftExpressionContext() {}

func NewLeftExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LeftExpressionContext {
	var p = new(LeftExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CParserRULE_leftExpression

	return p
}

func (s *LeftExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *LeftExpressionContext) Star() antlr.TerminalNode {
	return s.GetToken(CParserStar, 0)
}

func (s *LeftExpressionContext) UnaryExpression() IUnaryExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnaryExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnaryExpressionContext)
}

func (s *LeftExpressionContext) PostfixExpressionLvalue() IPostfixExpressionLvalueContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPostfixExpressionLvalueContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPostfixExpressionLvalueContext)
}

func (s *LeftExpressionContext) LeftParen() antlr.TerminalNode {
	return s.GetToken(CParserLeftParen, 0)
}

func (s *LeftExpressionContext) LeftExpression() ILeftExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILeftExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILeftExpressionContext)
}

func (s *LeftExpressionContext) RightParen() antlr.TerminalNode {
	return s.GetToken(CParserRightParen, 0)
}

func (s *LeftExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LeftExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LeftExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CParserVisitor:
		return t.VisitLeftExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CParser) LeftExpression() (localctx ILeftExpressionContext) {
	this := p
	_ = this

	localctx = NewLeftExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 26, CParserRULE_leftExpression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(379)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 27, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(372)
			p.Match(CParserStar)
		}
		{
			p.SetState(373)
			p.UnaryExpression()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(374)
			p.postfixExpressionLvalue(0)
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(375)
			p.Match(CParserLeftParen)
		}
		{
			p.SetState(376)
			p.LeftExpression()
		}
		{
			p.SetState(377)
			p.Match(CParserRightParen)
		}

	}

	return localctx
}

// IExpressionContext is an interface to support dynamic dispatch.
type IExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetUnary_op returns the unary_op token.
	GetUnary_op() antlr.Token

	// GetMul_op returns the mul_op token.
	GetMul_op() antlr.Token

	// GetAdd_op returns the add_op token.
	GetAdd_op() antlr.Token

	// GetRel_op returns the rel_op token.
	GetRel_op() antlr.Token

	// SetUnary_op sets the unary_op token.
	SetUnary_op(antlr.Token)

	// SetMul_op sets the mul_op token.
	SetMul_op(antlr.Token)

	// SetAdd_op sets the add_op token.
	SetAdd_op(antlr.Token)

	// SetRel_op sets the rel_op token.
	SetRel_op(antlr.Token)

	// IsExpressionContext differentiates from other interfaces.
	IsExpressionContext()
}

type ExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser   antlr.Parser
	unary_op antlr.Token
	mul_op   antlr.Token
	add_op   antlr.Token
	rel_op   antlr.Token
}

func NewEmptyExpressionContext() *ExpressionContext {
	var p = new(ExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CParserRULE_expression
	return p
}

func (*ExpressionContext) IsExpressionContext() {}

func NewExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExpressionContext {
	var p = new(ExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CParserRULE_expression

	return p
}

func (s *ExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *ExpressionContext) GetUnary_op() antlr.Token { return s.unary_op }

func (s *ExpressionContext) GetMul_op() antlr.Token { return s.mul_op }

func (s *ExpressionContext) GetAdd_op() antlr.Token { return s.add_op }

func (s *ExpressionContext) GetRel_op() antlr.Token { return s.rel_op }

func (s *ExpressionContext) SetUnary_op(v antlr.Token) { s.unary_op = v }

func (s *ExpressionContext) SetMul_op(v antlr.Token) { s.mul_op = v }

func (s *ExpressionContext) SetAdd_op(v antlr.Token) { s.add_op = v }

func (s *ExpressionContext) SetRel_op(v antlr.Token) { s.rel_op = v }

func (s *ExpressionContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *ExpressionContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ExpressionContext) Tilde() antlr.TerminalNode {
	return s.GetToken(CParserTilde, 0)
}

func (s *ExpressionContext) Plus() antlr.TerminalNode {
	return s.GetToken(CParserPlus, 0)
}

func (s *ExpressionContext) Minus() antlr.TerminalNode {
	return s.GetToken(CParserMinus, 0)
}

func (s *ExpressionContext) Not() antlr.TerminalNode {
	return s.GetToken(CParserNot, 0)
}

func (s *ExpressionContext) Caret() antlr.TerminalNode {
	return s.GetToken(CParserCaret, 0)
}

func (s *ExpressionContext) Star() antlr.TerminalNode {
	return s.GetToken(CParserStar, 0)
}

func (s *ExpressionContext) And() antlr.TerminalNode {
	return s.GetToken(CParserAnd, 0)
}

func (s *ExpressionContext) LeftParen() antlr.TerminalNode {
	return s.GetToken(CParserLeftParen, 0)
}

func (s *ExpressionContext) RightParen() antlr.TerminalNode {
	return s.GetToken(CParserRightParen, 0)
}

func (s *ExpressionContext) CastExpression() ICastExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICastExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICastExpressionContext)
}

func (s *ExpressionContext) AssignmentExpression() IAssignmentExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAssignmentExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAssignmentExpressionContext)
}

func (s *ExpressionContext) StatementsExpression() IStatementsExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementsExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementsExpressionContext)
}

func (s *ExpressionContext) DeclarationSpecifier() IDeclarationSpecifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDeclarationSpecifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDeclarationSpecifierContext)
}

func (s *ExpressionContext) Div() antlr.TerminalNode {
	return s.GetToken(CParserDiv, 0)
}

func (s *ExpressionContext) Mod() antlr.TerminalNode {
	return s.GetToken(CParserMod, 0)
}

func (s *ExpressionContext) LeftShift() antlr.TerminalNode {
	return s.GetToken(CParserLeftShift, 0)
}

func (s *ExpressionContext) RightShift() antlr.TerminalNode {
	return s.GetToken(CParserRightShift, 0)
}

func (s *ExpressionContext) Or() antlr.TerminalNode {
	return s.GetToken(CParserOr, 0)
}

func (s *ExpressionContext) Equal() antlr.TerminalNode {
	return s.GetToken(CParserEqual, 0)
}

func (s *ExpressionContext) NotEqual() antlr.TerminalNode {
	return s.GetToken(CParserNotEqual, 0)
}

func (s *ExpressionContext) Less() antlr.TerminalNode {
	return s.GetToken(CParserLess, 0)
}

func (s *ExpressionContext) LessEqual() antlr.TerminalNode {
	return s.GetToken(CParserLessEqual, 0)
}

func (s *ExpressionContext) Greater() antlr.TerminalNode {
	return s.GetToken(CParserGreater, 0)
}

func (s *ExpressionContext) GreaterEqual() antlr.TerminalNode {
	return s.GetToken(CParserGreaterEqual, 0)
}

func (s *ExpressionContext) AndAnd() antlr.TerminalNode {
	return s.GetToken(CParserAndAnd, 0)
}

func (s *ExpressionContext) OrOr() antlr.TerminalNode {
	return s.GetToken(CParserOrOr, 0)
}

func (s *ExpressionContext) Question() antlr.TerminalNode {
	return s.GetToken(CParserQuestion, 0)
}

func (s *ExpressionContext) Colon() antlr.TerminalNode {
	return s.GetToken(CParserColon, 0)
}

func (s *ExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CParserVisitor:
		return t.VisitExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CParser) Expression() (localctx IExpressionContext) {
	return p.expression(0)
}

func (p *CParser) expression(_p int) (localctx IExpressionContext) {
	this := p
	_ = this

	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()
	_parentState := p.GetState()
	localctx = NewExpressionContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IExpressionContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 28
	p.EnterRecursionRule(localctx, 28, CParserRULE_expression, _p)
	var _la int

	defer func() {
		p.UnrollRecursionContexts(_parentctx)
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(392)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 28, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(382)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*ExpressionContext).unary_op = _lt

			_la = p.GetTokenStream().LA(1)

			if !((int64((_la-59)) & ^0x3f) == 0 && ((int64(1)<<(_la-59))&14485) != 0) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*ExpressionContext).unary_op = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(383)
			p.expression(12)
		}

	case 2:
		{
			p.SetState(384)
			p.Match(CParserLeftParen)
		}
		{
			p.SetState(385)
			p.expression(0)
		}
		{
			p.SetState(386)
			p.Match(CParserRightParen)
		}

	case 3:
		{
			p.SetState(388)
			p.CastExpression()
		}

	case 4:
		{
			p.SetState(389)
			p.AssignmentExpression()
		}

	case 5:
		{
			p.SetState(390)
			p.StatementsExpression()
		}

	case 6:
		{
			p.SetState(391)
			p.DeclarationSpecifier()
		}

	}
	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(417)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 30, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			p.SetState(415)
			p.GetErrorHandler().Sync(p)
			switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 29, p.GetParserRuleContext()) {
			case 1:
				localctx = NewExpressionContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, CParserRULE_expression)
				p.SetState(394)

				if !(p.Precpred(p.GetParserRuleContext(), 11)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 11)", ""))
				}
				{
					p.SetState(395)

					var _lt = p.GetTokenStream().LT(1)

					localctx.(*ExpressionContext).mul_op = _lt

					_la = p.GetTokenStream().LA(1)

					if !((int64((_la-57)) & ^0x3f) == 0 && ((int64(1)<<(_la-57))&963) != 0) {
						var _ri = p.GetErrorHandler().RecoverInline(p)

						localctx.(*ExpressionContext).mul_op = _ri
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				{
					p.SetState(396)
					p.expression(12)
				}

			case 2:
				localctx = NewExpressionContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, CParserRULE_expression)
				p.SetState(397)

				if !(p.Precpred(p.GetParserRuleContext(), 10)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 10)", ""))
				}
				{
					p.SetState(398)

					var _lt = p.GetTokenStream().LT(1)

					localctx.(*ExpressionContext).add_op = _lt

					_la = p.GetTokenStream().LA(1)

					if !((int64((_la-59)) & ^0x3f) == 0 && ((int64(1)<<(_la-59))&2309) != 0) {
						var _ri = p.GetErrorHandler().RecoverInline(p)

						localctx.(*ExpressionContext).add_op = _ri
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				{
					p.SetState(399)
					p.expression(11)
				}

			case 3:
				localctx = NewExpressionContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, CParserRULE_expression)
				p.SetState(400)

				if !(p.Precpred(p.GetParserRuleContext(), 9)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 9)", ""))
				}
				{
					p.SetState(401)

					var _lt = p.GetTokenStream().LT(1)

					localctx.(*ExpressionContext).rel_op = _lt

					_la = p.GetTokenStream().LA(1)

					if !((int64((_la-53)) & ^0x3f) == 0 && ((int64(1)<<(_la-53))&103079215119) != 0) {
						var _ri = p.GetErrorHandler().RecoverInline(p)

						localctx.(*ExpressionContext).rel_op = _ri
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				{
					p.SetState(402)
					p.expression(10)
				}

			case 4:
				localctx = NewExpressionContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, CParserRULE_expression)
				p.SetState(403)

				if !(p.Precpred(p.GetParserRuleContext(), 8)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 8)", ""))
				}
				{
					p.SetState(404)
					p.Match(CParserAndAnd)
				}
				{
					p.SetState(405)
					p.expression(9)
				}

			case 5:
				localctx = NewExpressionContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, CParserRULE_expression)
				p.SetState(406)

				if !(p.Precpred(p.GetParserRuleContext(), 7)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 7)", ""))
				}
				{
					p.SetState(407)
					p.Match(CParserOrOr)
				}
				{
					p.SetState(408)
					p.expression(8)
				}

			case 6:
				localctx = NewExpressionContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, CParserRULE_expression)
				p.SetState(409)

				if !(p.Precpred(p.GetParserRuleContext(), 5)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 5)", ""))
				}

				{
					p.SetState(410)
					p.Match(CParserQuestion)
				}
				{
					p.SetState(411)
					p.expression(0)
				}
				{
					p.SetState(412)
					p.Match(CParserColon)
				}
				{
					p.SetState(413)
					p.expression(0)
				}

			}

		}
		p.SetState(419)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 30, p.GetParserRuleContext())
	}

	return localctx
}

// IDeclarationContext is an interface to support dynamic dispatch.
type IDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDeclarationContext differentiates from other interfaces.
	IsDeclarationContext()
}

type DeclarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDeclarationContext() *DeclarationContext {
	var p = new(DeclarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CParserRULE_declaration
	return p
}

func (*DeclarationContext) IsDeclarationContext() {}

func NewDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DeclarationContext {
	var p = new(DeclarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CParserRULE_declaration

	return p
}

func (s *DeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *DeclarationContext) DeclarationSpecifier() IDeclarationSpecifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDeclarationSpecifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDeclarationSpecifierContext)
}

func (s *DeclarationContext) Semi() antlr.TerminalNode {
	return s.GetToken(CParserSemi, 0)
}

func (s *DeclarationContext) InitDeclaratorList() IInitDeclaratorListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInitDeclaratorListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInitDeclaratorListContext)
}

func (s *DeclarationContext) StaticAssertDeclaration() IStaticAssertDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStaticAssertDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStaticAssertDeclarationContext)
}

func (s *DeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DeclarationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CParserVisitor:
		return t.VisitDeclaration(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CParser) Declaration() (localctx IDeclarationContext) {
	this := p
	_ = this

	localctx = NewDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 30, CParserRULE_declaration)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(427)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case CParserAuto, CParserChar, CParserConst, CParserDouble, CParserLongdouble, CParserEnum, CParserExtern, CParserFloat, CParserInline, CParserInt, CParserLong, CParserLonglong, CParserRegister, CParserRestrict, CParserShort, CParserSigned, CParserStatic, CParserStruct, CParserTypedef, CParserUnion, CParserUnsigned, CParserVoid, CParserVolatile, CParserAlignas, CParserAtomic, CParserBool, CParserComplex, CParserNoreturn, CParserThreadLocal, CParserAttribute__, CParserIdentifier, CParserExtension, CParserM128, CParserM128d, CParserM128i, CParserTypeof, CParserInline__, CParserStdcall, CParserDeclspec:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(420)
			p.DeclarationSpecifier()
		}
		p.SetState(422)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == CParserLeftParen || _la == CParserStar || (int64((_la-70)) & ^0x3f) == 0 && ((int64(1)<<(_la-70))&137438987026433) != 0 {
			{
				p.SetState(421)
				p.InitDeclaratorList()
			}

		}
		{
			p.SetState(424)
			p.Match(CParserSemi)
		}

	case CParserStaticAssert:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(426)
			p.StaticAssertDeclaration()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IDeclarationSpecifiersContext is an interface to support dynamic dispatch.
type IDeclarationSpecifiersContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDeclarationSpecifiersContext differentiates from other interfaces.
	IsDeclarationSpecifiersContext()
}

type DeclarationSpecifiersContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDeclarationSpecifiersContext() *DeclarationSpecifiersContext {
	var p = new(DeclarationSpecifiersContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CParserRULE_declarationSpecifiers
	return p
}

func (*DeclarationSpecifiersContext) IsDeclarationSpecifiersContext() {}

func NewDeclarationSpecifiersContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DeclarationSpecifiersContext {
	var p = new(DeclarationSpecifiersContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CParserRULE_declarationSpecifiers

	return p
}

func (s *DeclarationSpecifiersContext) GetParser() antlr.Parser { return s.parser }

func (s *DeclarationSpecifiersContext) AllDeclarationSpecifier() []IDeclarationSpecifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IDeclarationSpecifierContext); ok {
			len++
		}
	}

	tst := make([]IDeclarationSpecifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IDeclarationSpecifierContext); ok {
			tst[i] = t.(IDeclarationSpecifierContext)
			i++
		}
	}

	return tst
}

func (s *DeclarationSpecifiersContext) DeclarationSpecifier(i int) IDeclarationSpecifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDeclarationSpecifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDeclarationSpecifierContext)
}

func (s *DeclarationSpecifiersContext) Comma() antlr.TerminalNode {
	return s.GetToken(CParserComma, 0)
}

func (s *DeclarationSpecifiersContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DeclarationSpecifiersContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DeclarationSpecifiersContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CParserVisitor:
		return t.VisitDeclarationSpecifiers(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CParser) DeclarationSpecifiers() (localctx IDeclarationSpecifiersContext) {
	this := p
	_ = this

	localctx = NewDeclarationSpecifiersContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 32, CParserRULE_declarationSpecifiers)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(429)
		p.DeclarationSpecifier()
	}
	p.SetState(432)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == CParserComma {
		{
			p.SetState(430)
			p.Match(CParserComma)
		}
		{
			p.SetState(431)
			p.DeclarationSpecifier()
		}

	}

	return localctx
}

// IDeclarationSpecifiers2Context is an interface to support dynamic dispatch.
type IDeclarationSpecifiers2Context interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDeclarationSpecifiers2Context differentiates from other interfaces.
	IsDeclarationSpecifiers2Context()
}

type DeclarationSpecifiers2Context struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDeclarationSpecifiers2Context() *DeclarationSpecifiers2Context {
	var p = new(DeclarationSpecifiers2Context)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CParserRULE_declarationSpecifiers2
	return p
}

func (*DeclarationSpecifiers2Context) IsDeclarationSpecifiers2Context() {}

func NewDeclarationSpecifiers2Context(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DeclarationSpecifiers2Context {
	var p = new(DeclarationSpecifiers2Context)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CParserRULE_declarationSpecifiers2

	return p
}

func (s *DeclarationSpecifiers2Context) GetParser() antlr.Parser { return s.parser }

func (s *DeclarationSpecifiers2Context) AllDeclarationSpecifier() []IDeclarationSpecifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IDeclarationSpecifierContext); ok {
			len++
		}
	}

	tst := make([]IDeclarationSpecifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IDeclarationSpecifierContext); ok {
			tst[i] = t.(IDeclarationSpecifierContext)
			i++
		}
	}

	return tst
}

func (s *DeclarationSpecifiers2Context) DeclarationSpecifier(i int) IDeclarationSpecifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDeclarationSpecifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDeclarationSpecifierContext)
}

func (s *DeclarationSpecifiers2Context) Comma() antlr.TerminalNode {
	return s.GetToken(CParserComma, 0)
}

func (s *DeclarationSpecifiers2Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DeclarationSpecifiers2Context) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DeclarationSpecifiers2Context) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CParserVisitor:
		return t.VisitDeclarationSpecifiers2(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CParser) DeclarationSpecifiers2() (localctx IDeclarationSpecifiers2Context) {
	this := p
	_ = this

	localctx = NewDeclarationSpecifiers2Context(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 34, CParserRULE_declarationSpecifiers2)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(434)
		p.DeclarationSpecifier()
	}
	p.SetState(437)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == CParserComma {
		{
			p.SetState(435)
			p.Match(CParserComma)
		}
		{
			p.SetState(436)
			p.DeclarationSpecifier()
		}

	}

	return localctx
}

// IDeclarationSpecifierContext is an interface to support dynamic dispatch.
type IDeclarationSpecifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDeclarationSpecifierContext differentiates from other interfaces.
	IsDeclarationSpecifierContext()
}

type DeclarationSpecifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDeclarationSpecifierContext() *DeclarationSpecifierContext {
	var p = new(DeclarationSpecifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CParserRULE_declarationSpecifier
	return p
}

func (*DeclarationSpecifierContext) IsDeclarationSpecifierContext() {}

func NewDeclarationSpecifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DeclarationSpecifierContext {
	var p = new(DeclarationSpecifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CParserRULE_declarationSpecifier

	return p
}

func (s *DeclarationSpecifierContext) GetParser() antlr.Parser { return s.parser }

func (s *DeclarationSpecifierContext) TypeSpecifier() ITypeSpecifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeSpecifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeSpecifierContext)
}

func (s *DeclarationSpecifierContext) Identifier() antlr.TerminalNode {
	return s.GetToken(CParserIdentifier, 0)
}

func (s *DeclarationSpecifierContext) AllStorageClassSpecifier() []IStorageClassSpecifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStorageClassSpecifierContext); ok {
			len++
		}
	}

	tst := make([]IStorageClassSpecifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStorageClassSpecifierContext); ok {
			tst[i] = t.(IStorageClassSpecifierContext)
			i++
		}
	}

	return tst
}

func (s *DeclarationSpecifierContext) StorageClassSpecifier(i int) IStorageClassSpecifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStorageClassSpecifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStorageClassSpecifierContext)
}

func (s *DeclarationSpecifierContext) AllTypeQualifier() []ITypeQualifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITypeQualifierContext); ok {
			len++
		}
	}

	tst := make([]ITypeQualifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITypeQualifierContext); ok {
			tst[i] = t.(ITypeQualifierContext)
			i++
		}
	}

	return tst
}

func (s *DeclarationSpecifierContext) TypeQualifier(i int) ITypeQualifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeQualifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeQualifierContext)
}

func (s *DeclarationSpecifierContext) AllFunctionSpecifier() []IFunctionSpecifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IFunctionSpecifierContext); ok {
			len++
		}
	}

	tst := make([]IFunctionSpecifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IFunctionSpecifierContext); ok {
			tst[i] = t.(IFunctionSpecifierContext)
			i++
		}
	}

	return tst
}

func (s *DeclarationSpecifierContext) FunctionSpecifier(i int) IFunctionSpecifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionSpecifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionSpecifierContext)
}

func (s *DeclarationSpecifierContext) StructOrUnion() IStructOrUnionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStructOrUnionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStructOrUnionContext)
}

func (s *DeclarationSpecifierContext) AllStar() []antlr.TerminalNode {
	return s.GetTokens(CParserStar)
}

func (s *DeclarationSpecifierContext) Star(i int) antlr.TerminalNode {
	return s.GetToken(CParserStar, i)
}

func (s *DeclarationSpecifierContext) AlignmentSpecifier() IAlignmentSpecifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlignmentSpecifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlignmentSpecifierContext)
}

func (s *DeclarationSpecifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DeclarationSpecifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DeclarationSpecifierContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CParserVisitor:
		return t.VisitDeclarationSpecifier(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CParser) DeclarationSpecifier() (localctx IDeclarationSpecifierContext) {
	this := p
	_ = this

	localctx = NewDeclarationSpecifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 36, CParserRULE_declarationSpecifier)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.SetState(461)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case CParserAuto, CParserChar, CParserConst, CParserDouble, CParserLongdouble, CParserEnum, CParserExtern, CParserFloat, CParserInline, CParserInt, CParserLong, CParserLonglong, CParserRegister, CParserRestrict, CParserShort, CParserSigned, CParserStatic, CParserStruct, CParserTypedef, CParserUnion, CParserUnsigned, CParserVoid, CParserVolatile, CParserAtomic, CParserBool, CParserComplex, CParserNoreturn, CParserThreadLocal, CParserAttribute__, CParserIdentifier, CParserExtension, CParserM128, CParserM128d, CParserM128i, CParserTypeof, CParserInline__, CParserStdcall, CParserDeclspec:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(444)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 36, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				p.SetState(442)
				p.GetErrorHandler().Sync(p)

				switch p.GetTokenStream().LA(1) {
				case CParserAuto, CParserExtern, CParserRegister, CParserStatic, CParserTypedef, CParserThreadLocal:
					{
						p.SetState(439)
						p.StorageClassSpecifier()
					}

				case CParserConst, CParserRestrict, CParserSigned, CParserUnsigned, CParserVolatile, CParserAtomic:
					{
						p.SetState(440)
						p.TypeQualifier()
					}

				case CParserInline, CParserNoreturn, CParserAttribute__, CParserInline__, CParserStdcall, CParserDeclspec:
					{
						p.SetState(441)
						p.FunctionSpecifier()
					}

				default:
					panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
				}

			}
			p.SetState(446)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 36, p.GetParserRuleContext())
		}
		p.SetState(448)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 37, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(447)
				p.StructOrUnion()
			}

		}
		p.SetState(452)
		p.GetErrorHandler().Sync(p)
		switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 38, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(450)
				p.TypeSpecifier()
			}

		case 2:
			{
				p.SetState(451)
				p.Match(CParserIdentifier)
			}

		}
		p.SetState(457)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 39, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(454)
					p.Match(CParserStar)
				}

			}
			p.SetState(459)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 39, p.GetParserRuleContext())
		}

	case CParserAlignas:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(460)
			p.AlignmentSpecifier()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IInitDeclaratorListContext is an interface to support dynamic dispatch.
type IInitDeclaratorListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInitDeclaratorListContext differentiates from other interfaces.
	IsInitDeclaratorListContext()
}

type InitDeclaratorListContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInitDeclaratorListContext() *InitDeclaratorListContext {
	var p = new(InitDeclaratorListContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CParserRULE_initDeclaratorList
	return p
}

func (*InitDeclaratorListContext) IsInitDeclaratorListContext() {}

func NewInitDeclaratorListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InitDeclaratorListContext {
	var p = new(InitDeclaratorListContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CParserRULE_initDeclaratorList

	return p
}

func (s *InitDeclaratorListContext) GetParser() antlr.Parser { return s.parser }

func (s *InitDeclaratorListContext) AllInitDeclarator() []IInitDeclaratorContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IInitDeclaratorContext); ok {
			len++
		}
	}

	tst := make([]IInitDeclaratorContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IInitDeclaratorContext); ok {
			tst[i] = t.(IInitDeclaratorContext)
			i++
		}
	}

	return tst
}

func (s *InitDeclaratorListContext) InitDeclarator(i int) IInitDeclaratorContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInitDeclaratorContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInitDeclaratorContext)
}

func (s *InitDeclaratorListContext) AllComma() []antlr.TerminalNode {
	return s.GetTokens(CParserComma)
}

func (s *InitDeclaratorListContext) Comma(i int) antlr.TerminalNode {
	return s.GetToken(CParserComma, i)
}

func (s *InitDeclaratorListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InitDeclaratorListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InitDeclaratorListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CParserVisitor:
		return t.VisitInitDeclaratorList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CParser) InitDeclaratorList() (localctx IInitDeclaratorListContext) {
	this := p
	_ = this

	localctx = NewInitDeclaratorListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 38, CParserRULE_initDeclaratorList)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(463)
		p.InitDeclarator()
	}
	p.SetState(468)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 41, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(464)
				p.Match(CParserComma)
			}
			{
				p.SetState(465)
				p.InitDeclarator()
			}

		}
		p.SetState(470)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 41, p.GetParserRuleContext())
	}

	return localctx
}

// IInitDeclaratorContext is an interface to support dynamic dispatch.
type IInitDeclaratorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInitDeclaratorContext differentiates from other interfaces.
	IsInitDeclaratorContext()
}

type InitDeclaratorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInitDeclaratorContext() *InitDeclaratorContext {
	var p = new(InitDeclaratorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CParserRULE_initDeclarator
	return p
}

func (*InitDeclaratorContext) IsInitDeclaratorContext() {}

func NewInitDeclaratorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InitDeclaratorContext {
	var p = new(InitDeclaratorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CParserRULE_initDeclarator

	return p
}

func (s *InitDeclaratorContext) GetParser() antlr.Parser { return s.parser }

func (s *InitDeclaratorContext) Declarator() IDeclaratorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDeclaratorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDeclaratorContext)
}

func (s *InitDeclaratorContext) Assign() antlr.TerminalNode {
	return s.GetToken(CParserAssign, 0)
}

func (s *InitDeclaratorContext) Initializer() IInitializerContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInitializerContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInitializerContext)
}

func (s *InitDeclaratorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InitDeclaratorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InitDeclaratorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CParserVisitor:
		return t.VisitInitDeclarator(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CParser) InitDeclarator() (localctx IInitDeclaratorContext) {
	this := p
	_ = this

	localctx = NewInitDeclaratorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 40, CParserRULE_initDeclarator)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(471)
		p.Declarator()
	}
	p.SetState(474)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == CParserAssign {
		{
			p.SetState(472)
			p.Match(CParserAssign)
		}
		{
			p.SetState(473)
			p.Initializer()
		}

	}

	return localctx
}

// IStorageClassSpecifierContext is an interface to support dynamic dispatch.
type IStorageClassSpecifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsStorageClassSpecifierContext differentiates from other interfaces.
	IsStorageClassSpecifierContext()
}

type StorageClassSpecifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStorageClassSpecifierContext() *StorageClassSpecifierContext {
	var p = new(StorageClassSpecifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CParserRULE_storageClassSpecifier
	return p
}

func (*StorageClassSpecifierContext) IsStorageClassSpecifierContext() {}

func NewStorageClassSpecifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StorageClassSpecifierContext {
	var p = new(StorageClassSpecifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CParserRULE_storageClassSpecifier

	return p
}

func (s *StorageClassSpecifierContext) GetParser() antlr.Parser { return s.parser }

func (s *StorageClassSpecifierContext) Typedef() antlr.TerminalNode {
	return s.GetToken(CParserTypedef, 0)
}

func (s *StorageClassSpecifierContext) Extern() antlr.TerminalNode {
	return s.GetToken(CParserExtern, 0)
}

func (s *StorageClassSpecifierContext) Static() antlr.TerminalNode {
	return s.GetToken(CParserStatic, 0)
}

func (s *StorageClassSpecifierContext) ThreadLocal() antlr.TerminalNode {
	return s.GetToken(CParserThreadLocal, 0)
}

func (s *StorageClassSpecifierContext) Auto() antlr.TerminalNode {
	return s.GetToken(CParserAuto, 0)
}

func (s *StorageClassSpecifierContext) Register() antlr.TerminalNode {
	return s.GetToken(CParserRegister, 0)
}

func (s *StorageClassSpecifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StorageClassSpecifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StorageClassSpecifierContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CParserVisitor:
		return t.VisitStorageClassSpecifier(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CParser) StorageClassSpecifier() (localctx IStorageClassSpecifierContext) {
	this := p
	_ = this

	localctx = NewStorageClassSpecifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 42, CParserRULE_storageClassSpecifier)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(476)
		_la = p.GetTokenStream().LA(1)

		if !((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&70371164299266) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// ITypeSpecifierContext is an interface to support dynamic dispatch.
type ITypeSpecifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTypeSpecifierContext differentiates from other interfaces.
	IsTypeSpecifierContext()
}

type TypeSpecifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeSpecifierContext() *TypeSpecifierContext {
	var p = new(TypeSpecifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CParserRULE_typeSpecifier
	return p
}

func (*TypeSpecifierContext) IsTypeSpecifierContext() {}

func NewTypeSpecifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeSpecifierContext {
	var p = new(TypeSpecifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CParserRULE_typeSpecifier

	return p
}

func (s *TypeSpecifierContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeSpecifierContext) Void() antlr.TerminalNode {
	return s.GetToken(CParserVoid, 0)
}

func (s *TypeSpecifierContext) Char() antlr.TerminalNode {
	return s.GetToken(CParserChar, 0)
}

func (s *TypeSpecifierContext) Short() antlr.TerminalNode {
	return s.GetToken(CParserShort, 0)
}

func (s *TypeSpecifierContext) Int() antlr.TerminalNode {
	return s.GetToken(CParserInt, 0)
}

func (s *TypeSpecifierContext) Long() antlr.TerminalNode {
	return s.GetToken(CParserLong, 0)
}

func (s *TypeSpecifierContext) Longlong() antlr.TerminalNode {
	return s.GetToken(CParserLonglong, 0)
}

func (s *TypeSpecifierContext) Float() antlr.TerminalNode {
	return s.GetToken(CParserFloat, 0)
}

func (s *TypeSpecifierContext) Double() antlr.TerminalNode {
	return s.GetToken(CParserDouble, 0)
}

func (s *TypeSpecifierContext) Longdouble() antlr.TerminalNode {
	return s.GetToken(CParserLongdouble, 0)
}

func (s *TypeSpecifierContext) Bool() antlr.TerminalNode {
	return s.GetToken(CParserBool, 0)
}

func (s *TypeSpecifierContext) Complex() antlr.TerminalNode {
	return s.GetToken(CParserComplex, 0)
}

func (s *TypeSpecifierContext) M128() antlr.TerminalNode {
	return s.GetToken(CParserM128, 0)
}

func (s *TypeSpecifierContext) M128d() antlr.TerminalNode {
	return s.GetToken(CParserM128d, 0)
}

func (s *TypeSpecifierContext) M128i() antlr.TerminalNode {
	return s.GetToken(CParserM128i, 0)
}

func (s *TypeSpecifierContext) Extension() antlr.TerminalNode {
	return s.GetToken(CParserExtension, 0)
}

func (s *TypeSpecifierContext) LeftParen() antlr.TerminalNode {
	return s.GetToken(CParserLeftParen, 0)
}

func (s *TypeSpecifierContext) RightParen() antlr.TerminalNode {
	return s.GetToken(CParserRightParen, 0)
}

func (s *TypeSpecifierContext) AtomicTypeSpecifier() IAtomicTypeSpecifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAtomicTypeSpecifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAtomicTypeSpecifierContext)
}

func (s *TypeSpecifierContext) StructOrUnionSpecifier() IStructOrUnionSpecifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStructOrUnionSpecifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStructOrUnionSpecifierContext)
}

func (s *TypeSpecifierContext) EnumSpecifier() IEnumSpecifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEnumSpecifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEnumSpecifierContext)
}

func (s *TypeSpecifierContext) TypedefName() ITypedefNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypedefNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypedefNameContext)
}

func (s *TypeSpecifierContext) Typeof() antlr.TerminalNode {
	return s.GetToken(CParserTypeof, 0)
}

func (s *TypeSpecifierContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *TypeSpecifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeSpecifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeSpecifierContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CParserVisitor:
		return t.VisitTypeSpecifier(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CParser) TypeSpecifier() (localctx ITypeSpecifierContext) {
	this := p
	_ = this

	localctx = NewTypeSpecifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 44, CParserRULE_typeSpecifier)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(505)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 43, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(478)
			p.Match(CParserVoid)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(479)
			p.Match(CParserChar)
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(480)
			p.Match(CParserShort)
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(481)
			p.Match(CParserInt)
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(482)
			p.Match(CParserLong)
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(483)
			p.Match(CParserLonglong)
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(484)
			p.Match(CParserFloat)
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(485)
			p.Match(CParserDouble)
		}

	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(486)
			p.Match(CParserLongdouble)
		}

	case 10:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(487)
			p.Match(CParserBool)
		}

	case 11:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(488)
			p.Match(CParserComplex)
		}

	case 12:
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(489)
			p.Match(CParserM128)
		}

	case 13:
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(490)
			p.Match(CParserM128d)
		}

	case 14:
		p.EnterOuterAlt(localctx, 14)
		{
			p.SetState(491)
			p.Match(CParserM128i)
		}

	case 15:
		p.EnterOuterAlt(localctx, 15)
		{
			p.SetState(492)
			p.Match(CParserExtension)
		}
		{
			p.SetState(493)
			p.Match(CParserLeftParen)
		}
		{
			p.SetState(494)
			_la = p.GetTokenStream().LA(1)

			if !((int64((_la-105)) & ^0x3f) == 0 && ((int64(1)<<(_la-105))&7) != 0) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(495)
			p.Match(CParserRightParen)
		}

	case 16:
		p.EnterOuterAlt(localctx, 16)
		{
			p.SetState(496)
			p.AtomicTypeSpecifier()
		}

	case 17:
		p.EnterOuterAlt(localctx, 17)
		{
			p.SetState(497)
			p.StructOrUnionSpecifier()
		}

	case 18:
		p.EnterOuterAlt(localctx, 18)
		{
			p.SetState(498)
			p.EnumSpecifier()
		}

	case 19:
		p.EnterOuterAlt(localctx, 19)
		{
			p.SetState(499)
			p.TypedefName()
		}

	case 20:
		p.EnterOuterAlt(localctx, 20)
		{
			p.SetState(500)
			p.Match(CParserTypeof)
		}
		{
			p.SetState(501)
			p.Match(CParserLeftParen)
		}
		{
			p.SetState(502)
			p.expression(0)
		}
		{
			p.SetState(503)
			p.Match(CParserRightParen)
		}

	}

	return localctx
}

// IStructOrUnionSpecifierContext is an interface to support dynamic dispatch.
type IStructOrUnionSpecifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsStructOrUnionSpecifierContext differentiates from other interfaces.
	IsStructOrUnionSpecifierContext()
}

type StructOrUnionSpecifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStructOrUnionSpecifierContext() *StructOrUnionSpecifierContext {
	var p = new(StructOrUnionSpecifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CParserRULE_structOrUnionSpecifier
	return p
}

func (*StructOrUnionSpecifierContext) IsStructOrUnionSpecifierContext() {}

func NewStructOrUnionSpecifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StructOrUnionSpecifierContext {
	var p = new(StructOrUnionSpecifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CParserRULE_structOrUnionSpecifier

	return p
}

func (s *StructOrUnionSpecifierContext) GetParser() antlr.Parser { return s.parser }

func (s *StructOrUnionSpecifierContext) StructOrUnion() IStructOrUnionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStructOrUnionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStructOrUnionContext)
}

func (s *StructOrUnionSpecifierContext) LeftBrace() antlr.TerminalNode {
	return s.GetToken(CParserLeftBrace, 0)
}

func (s *StructOrUnionSpecifierContext) StructDeclarationList() IStructDeclarationListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStructDeclarationListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStructDeclarationListContext)
}

func (s *StructOrUnionSpecifierContext) RightBrace() antlr.TerminalNode {
	return s.GetToken(CParserRightBrace, 0)
}

func (s *StructOrUnionSpecifierContext) AllIdentifier() []antlr.TerminalNode {
	return s.GetTokens(CParserIdentifier)
}

func (s *StructOrUnionSpecifierContext) Identifier(i int) antlr.TerminalNode {
	return s.GetToken(CParserIdentifier, i)
}

func (s *StructOrUnionSpecifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StructOrUnionSpecifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StructOrUnionSpecifierContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CParserVisitor:
		return t.VisitStructOrUnionSpecifier(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CParser) StructOrUnionSpecifier() (localctx IStructOrUnionSpecifierContext) {
	this := p
	_ = this

	localctx = NewStructOrUnionSpecifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 46, CParserRULE_structOrUnionSpecifier)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(507)
		p.StructOrUnion()
	}
	p.SetState(509)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == CParserIdentifier {
		{
			p.SetState(508)
			p.Match(CParserIdentifier)
		}

	}
	{
		p.SetState(511)
		p.Match(CParserLeftBrace)
	}
	{
		p.SetState(512)
		p.StructDeclarationList()
	}
	{
		p.SetState(513)
		p.Match(CParserRightBrace)
	}
	p.SetState(515)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 45, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(514)
			p.Match(CParserIdentifier)
		}

	}

	return localctx
}

// IStructOrUnionContext is an interface to support dynamic dispatch.
type IStructOrUnionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsStructOrUnionContext differentiates from other interfaces.
	IsStructOrUnionContext()
}

type StructOrUnionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStructOrUnionContext() *StructOrUnionContext {
	var p = new(StructOrUnionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CParserRULE_structOrUnion
	return p
}

func (*StructOrUnionContext) IsStructOrUnionContext() {}

func NewStructOrUnionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StructOrUnionContext {
	var p = new(StructOrUnionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CParserRULE_structOrUnion

	return p
}

func (s *StructOrUnionContext) GetParser() antlr.Parser { return s.parser }

func (s *StructOrUnionContext) Struct() antlr.TerminalNode {
	return s.GetToken(CParserStruct, 0)
}

func (s *StructOrUnionContext) Union() antlr.TerminalNode {
	return s.GetToken(CParserUnion, 0)
}

func (s *StructOrUnionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StructOrUnionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StructOrUnionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CParserVisitor:
		return t.VisitStructOrUnion(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CParser) StructOrUnion() (localctx IStructOrUnionContext) {
	this := p
	_ = this

	localctx = NewStructOrUnionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 48, CParserRULE_structOrUnion)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(517)
		_la = p.GetTokenStream().LA(1)

		if !(_la == CParserStruct || _la == CParserUnion) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IStructDeclarationListContext is an interface to support dynamic dispatch.
type IStructDeclarationListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsStructDeclarationListContext differentiates from other interfaces.
	IsStructDeclarationListContext()
}

type StructDeclarationListContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStructDeclarationListContext() *StructDeclarationListContext {
	var p = new(StructDeclarationListContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CParserRULE_structDeclarationList
	return p
}

func (*StructDeclarationListContext) IsStructDeclarationListContext() {}

func NewStructDeclarationListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StructDeclarationListContext {
	var p = new(StructDeclarationListContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CParserRULE_structDeclarationList

	return p
}

func (s *StructDeclarationListContext) GetParser() antlr.Parser { return s.parser }

func (s *StructDeclarationListContext) AllStructDeclaration() []IStructDeclarationContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStructDeclarationContext); ok {
			len++
		}
	}

	tst := make([]IStructDeclarationContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStructDeclarationContext); ok {
			tst[i] = t.(IStructDeclarationContext)
			i++
		}
	}

	return tst
}

func (s *StructDeclarationListContext) StructDeclaration(i int) IStructDeclarationContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStructDeclarationContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStructDeclarationContext)
}

func (s *StructDeclarationListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StructDeclarationListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StructDeclarationListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CParserVisitor:
		return t.VisitStructDeclarationList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CParser) StructDeclarationList() (localctx IStructDeclarationListContext) {
	this := p
	_ = this

	localctx = NewStructDeclarationListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 50, CParserRULE_structDeclarationList)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(520)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = (int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&39097736910384) != 0 || (int64((_la-95)) & ^0x3f) == 0 && ((int64(1)<<(_la-95))&15489) != 0 {
		{
			p.SetState(519)
			p.StructDeclaration()
		}

		p.SetState(522)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IStructDeclarationContext is an interface to support dynamic dispatch.
type IStructDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsStructDeclarationContext differentiates from other interfaces.
	IsStructDeclarationContext()
}

type StructDeclarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStructDeclarationContext() *StructDeclarationContext {
	var p = new(StructDeclarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CParserRULE_structDeclaration
	return p
}

func (*StructDeclarationContext) IsStructDeclarationContext() {}

func NewStructDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StructDeclarationContext {
	var p = new(StructDeclarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CParserRULE_structDeclaration

	return p
}

func (s *StructDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *StructDeclarationContext) SpecifierQualifierList() ISpecifierQualifierListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISpecifierQualifierListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISpecifierQualifierListContext)
}

func (s *StructDeclarationContext) StructDeclaratorList() IStructDeclaratorListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStructDeclaratorListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStructDeclaratorListContext)
}

func (s *StructDeclarationContext) Semi() antlr.TerminalNode {
	return s.GetToken(CParserSemi, 0)
}

func (s *StructDeclarationContext) StaticAssertDeclaration() IStaticAssertDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStaticAssertDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStaticAssertDeclarationContext)
}

func (s *StructDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StructDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StructDeclarationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CParserVisitor:
		return t.VisitStructDeclaration(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CParser) StructDeclaration() (localctx IStructDeclarationContext) {
	this := p
	_ = this

	localctx = NewStructDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 52, CParserRULE_structDeclaration)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(532)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 47, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(524)
			p.SpecifierQualifierList()
		}
		{
			p.SetState(525)
			p.StructDeclaratorList()
		}
		{
			p.SetState(526)
			p.Match(CParserSemi)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(528)
			p.SpecifierQualifierList()
		}
		{
			p.SetState(529)
			p.Match(CParserSemi)
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(531)
			p.StaticAssertDeclaration()
		}

	}

	return localctx
}

// ISpecifierQualifierListContext is an interface to support dynamic dispatch.
type ISpecifierQualifierListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSpecifierQualifierListContext differentiates from other interfaces.
	IsSpecifierQualifierListContext()
}

type SpecifierQualifierListContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySpecifierQualifierListContext() *SpecifierQualifierListContext {
	var p = new(SpecifierQualifierListContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CParserRULE_specifierQualifierList
	return p
}

func (*SpecifierQualifierListContext) IsSpecifierQualifierListContext() {}

func NewSpecifierQualifierListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SpecifierQualifierListContext {
	var p = new(SpecifierQualifierListContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CParserRULE_specifierQualifierList

	return p
}

func (s *SpecifierQualifierListContext) GetParser() antlr.Parser { return s.parser }

func (s *SpecifierQualifierListContext) TypeSpecifier() ITypeSpecifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeSpecifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeSpecifierContext)
}

func (s *SpecifierQualifierListContext) TypeQualifier() ITypeQualifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeQualifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeQualifierContext)
}

func (s *SpecifierQualifierListContext) SpecifierQualifierList() ISpecifierQualifierListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISpecifierQualifierListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISpecifierQualifierListContext)
}

func (s *SpecifierQualifierListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SpecifierQualifierListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SpecifierQualifierListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CParserVisitor:
		return t.VisitSpecifierQualifierList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CParser) SpecifierQualifierList() (localctx ISpecifierQualifierListContext) {
	this := p
	_ = this

	localctx = NewSpecifierQualifierListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 54, CParserRULE_specifierQualifierList)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(536)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 48, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(534)
			p.TypeSpecifier()
		}

	case 2:
		{
			p.SetState(535)
			p.TypeQualifier()
		}

	}
	p.SetState(539)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 49, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(538)
			p.SpecifierQualifierList()
		}

	}

	return localctx
}

// IStructDeclaratorListContext is an interface to support dynamic dispatch.
type IStructDeclaratorListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsStructDeclaratorListContext differentiates from other interfaces.
	IsStructDeclaratorListContext()
}

type StructDeclaratorListContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStructDeclaratorListContext() *StructDeclaratorListContext {
	var p = new(StructDeclaratorListContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CParserRULE_structDeclaratorList
	return p
}

func (*StructDeclaratorListContext) IsStructDeclaratorListContext() {}

func NewStructDeclaratorListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StructDeclaratorListContext {
	var p = new(StructDeclaratorListContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CParserRULE_structDeclaratorList

	return p
}

func (s *StructDeclaratorListContext) GetParser() antlr.Parser { return s.parser }

func (s *StructDeclaratorListContext) AllStructDeclarator() []IStructDeclaratorContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStructDeclaratorContext); ok {
			len++
		}
	}

	tst := make([]IStructDeclaratorContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStructDeclaratorContext); ok {
			tst[i] = t.(IStructDeclaratorContext)
			i++
		}
	}

	return tst
}

func (s *StructDeclaratorListContext) StructDeclarator(i int) IStructDeclaratorContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStructDeclaratorContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStructDeclaratorContext)
}

func (s *StructDeclaratorListContext) AllComma() []antlr.TerminalNode {
	return s.GetTokens(CParserComma)
}

func (s *StructDeclaratorListContext) Comma(i int) antlr.TerminalNode {
	return s.GetToken(CParserComma, i)
}

func (s *StructDeclaratorListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StructDeclaratorListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StructDeclaratorListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CParserVisitor:
		return t.VisitStructDeclaratorList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CParser) StructDeclaratorList() (localctx IStructDeclaratorListContext) {
	this := p
	_ = this

	localctx = NewStructDeclaratorListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 56, CParserRULE_structDeclaratorList)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(541)
		p.StructDeclarator()
	}
	p.SetState(546)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == CParserComma {
		{
			p.SetState(542)
			p.Match(CParserComma)
		}
		{
			p.SetState(543)
			p.StructDeclarator()
		}

		p.SetState(548)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IStructDeclaratorContext is an interface to support dynamic dispatch.
type IStructDeclaratorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsStructDeclaratorContext differentiates from other interfaces.
	IsStructDeclaratorContext()
}

type StructDeclaratorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStructDeclaratorContext() *StructDeclaratorContext {
	var p = new(StructDeclaratorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CParserRULE_structDeclarator
	return p
}

func (*StructDeclaratorContext) IsStructDeclaratorContext() {}

func NewStructDeclaratorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StructDeclaratorContext {
	var p = new(StructDeclaratorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CParserRULE_structDeclarator

	return p
}

func (s *StructDeclaratorContext) GetParser() antlr.Parser { return s.parser }

func (s *StructDeclaratorContext) Declarator() IDeclaratorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDeclaratorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDeclaratorContext)
}

func (s *StructDeclaratorContext) Colon() antlr.TerminalNode {
	return s.GetToken(CParserColon, 0)
}

func (s *StructDeclaratorContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *StructDeclaratorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StructDeclaratorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StructDeclaratorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CParserVisitor:
		return t.VisitStructDeclarator(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CParser) StructDeclarator() (localctx IStructDeclaratorContext) {
	this := p
	_ = this

	localctx = NewStructDeclaratorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 58, CParserRULE_structDeclarator)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(555)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 52, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(549)
			p.Declarator()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(551)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == CParserLeftParen || _la == CParserStar || (int64((_la-70)) & ^0x3f) == 0 && ((int64(1)<<(_la-70))&137438987026433) != 0 {
			{
				p.SetState(550)
				p.Declarator()
			}

		}
		{
			p.SetState(553)
			p.Match(CParserColon)
		}
		{
			p.SetState(554)
			p.expression(0)
		}

	}

	return localctx
}

// IEnumSpecifierContext is an interface to support dynamic dispatch.
type IEnumSpecifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEnumSpecifierContext differentiates from other interfaces.
	IsEnumSpecifierContext()
}

type EnumSpecifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEnumSpecifierContext() *EnumSpecifierContext {
	var p = new(EnumSpecifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CParserRULE_enumSpecifier
	return p
}

func (*EnumSpecifierContext) IsEnumSpecifierContext() {}

func NewEnumSpecifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EnumSpecifierContext {
	var p = new(EnumSpecifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CParserRULE_enumSpecifier

	return p
}

func (s *EnumSpecifierContext) GetParser() antlr.Parser { return s.parser }

func (s *EnumSpecifierContext) Enum() antlr.TerminalNode {
	return s.GetToken(CParserEnum, 0)
}

func (s *EnumSpecifierContext) LeftBrace() antlr.TerminalNode {
	return s.GetToken(CParserLeftBrace, 0)
}

func (s *EnumSpecifierContext) EnumeratorList() IEnumeratorListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEnumeratorListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEnumeratorListContext)
}

func (s *EnumSpecifierContext) RightBrace() antlr.TerminalNode {
	return s.GetToken(CParserRightBrace, 0)
}

func (s *EnumSpecifierContext) Identifier() antlr.TerminalNode {
	return s.GetToken(CParserIdentifier, 0)
}

func (s *EnumSpecifierContext) Comma() antlr.TerminalNode {
	return s.GetToken(CParserComma, 0)
}

func (s *EnumSpecifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EnumSpecifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EnumSpecifierContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CParserVisitor:
		return t.VisitEnumSpecifier(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CParser) EnumSpecifier() (localctx IEnumSpecifierContext) {
	this := p
	_ = this

	localctx = NewEnumSpecifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 60, CParserRULE_enumSpecifier)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(570)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 55, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(557)
			p.Match(CParserEnum)
		}
		p.SetState(559)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == CParserIdentifier {
			{
				p.SetState(558)
				p.Match(CParserIdentifier)
			}

		}
		{
			p.SetState(561)
			p.Match(CParserLeftBrace)
		}
		{
			p.SetState(562)
			p.EnumeratorList()
		}
		p.SetState(564)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == CParserComma {
			{
				p.SetState(563)
				p.Match(CParserComma)
			}

		}
		{
			p.SetState(566)
			p.Match(CParserRightBrace)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(568)
			p.Match(CParserEnum)
		}
		{
			p.SetState(569)
			p.Match(CParserIdentifier)
		}

	}

	return localctx
}

// IEnumeratorListContext is an interface to support dynamic dispatch.
type IEnumeratorListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEnumeratorListContext differentiates from other interfaces.
	IsEnumeratorListContext()
}

type EnumeratorListContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEnumeratorListContext() *EnumeratorListContext {
	var p = new(EnumeratorListContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CParserRULE_enumeratorList
	return p
}

func (*EnumeratorListContext) IsEnumeratorListContext() {}

func NewEnumeratorListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EnumeratorListContext {
	var p = new(EnumeratorListContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CParserRULE_enumeratorList

	return p
}

func (s *EnumeratorListContext) GetParser() antlr.Parser { return s.parser }

func (s *EnumeratorListContext) AllEnumerator() []IEnumeratorContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IEnumeratorContext); ok {
			len++
		}
	}

	tst := make([]IEnumeratorContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IEnumeratorContext); ok {
			tst[i] = t.(IEnumeratorContext)
			i++
		}
	}

	return tst
}

func (s *EnumeratorListContext) Enumerator(i int) IEnumeratorContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEnumeratorContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEnumeratorContext)
}

func (s *EnumeratorListContext) AllComma() []antlr.TerminalNode {
	return s.GetTokens(CParserComma)
}

func (s *EnumeratorListContext) Comma(i int) antlr.TerminalNode {
	return s.GetToken(CParserComma, i)
}

func (s *EnumeratorListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EnumeratorListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EnumeratorListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CParserVisitor:
		return t.VisitEnumeratorList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CParser) EnumeratorList() (localctx IEnumeratorListContext) {
	this := p
	_ = this

	localctx = NewEnumeratorListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 62, CParserRULE_enumeratorList)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(572)
		p.Enumerator()
	}
	p.SetState(577)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 56, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(573)
				p.Match(CParserComma)
			}
			{
				p.SetState(574)
				p.Enumerator()
			}

		}
		p.SetState(579)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 56, p.GetParserRuleContext())
	}

	return localctx
}

// IEnumeratorContext is an interface to support dynamic dispatch.
type IEnumeratorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEnumeratorContext differentiates from other interfaces.
	IsEnumeratorContext()
}

type EnumeratorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEnumeratorContext() *EnumeratorContext {
	var p = new(EnumeratorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CParserRULE_enumerator
	return p
}

func (*EnumeratorContext) IsEnumeratorContext() {}

func NewEnumeratorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EnumeratorContext {
	var p = new(EnumeratorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CParserRULE_enumerator

	return p
}

func (s *EnumeratorContext) GetParser() antlr.Parser { return s.parser }

func (s *EnumeratorContext) Identifier() antlr.TerminalNode {
	return s.GetToken(CParserIdentifier, 0)
}

func (s *EnumeratorContext) GccAttributeSpecifier() IGccAttributeSpecifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGccAttributeSpecifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGccAttributeSpecifierContext)
}

func (s *EnumeratorContext) Assign() antlr.TerminalNode {
	return s.GetToken(CParserAssign, 0)
}

func (s *EnumeratorContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *EnumeratorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EnumeratorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EnumeratorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CParserVisitor:
		return t.VisitEnumerator(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CParser) Enumerator() (localctx IEnumeratorContext) {
	this := p
	_ = this

	localctx = NewEnumeratorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 64, CParserRULE_enumerator)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(591)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 59, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(580)
			p.Match(CParserIdentifier)
		}
		{
			p.SetState(581)
			p.GccAttributeSpecifier()
		}
		p.SetState(584)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == CParserAssign {
			{
				p.SetState(582)
				p.Match(CParserAssign)
			}
			{
				p.SetState(583)
				p.expression(0)
			}

		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(586)
			p.Match(CParserIdentifier)
		}
		p.SetState(589)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == CParserAssign {
			{
				p.SetState(587)
				p.Match(CParserAssign)
			}
			{
				p.SetState(588)
				p.expression(0)
			}

		}

	}

	return localctx
}

// IAtomicTypeSpecifierContext is an interface to support dynamic dispatch.
type IAtomicTypeSpecifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAtomicTypeSpecifierContext differentiates from other interfaces.
	IsAtomicTypeSpecifierContext()
}

type AtomicTypeSpecifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAtomicTypeSpecifierContext() *AtomicTypeSpecifierContext {
	var p = new(AtomicTypeSpecifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CParserRULE_atomicTypeSpecifier
	return p
}

func (*AtomicTypeSpecifierContext) IsAtomicTypeSpecifierContext() {}

func NewAtomicTypeSpecifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AtomicTypeSpecifierContext {
	var p = new(AtomicTypeSpecifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CParserRULE_atomicTypeSpecifier

	return p
}

func (s *AtomicTypeSpecifierContext) GetParser() antlr.Parser { return s.parser }

func (s *AtomicTypeSpecifierContext) Atomic() antlr.TerminalNode {
	return s.GetToken(CParserAtomic, 0)
}

func (s *AtomicTypeSpecifierContext) LeftParen() antlr.TerminalNode {
	return s.GetToken(CParserLeftParen, 0)
}

func (s *AtomicTypeSpecifierContext) TypeName() ITypeNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeNameContext)
}

func (s *AtomicTypeSpecifierContext) RightParen() antlr.TerminalNode {
	return s.GetToken(CParserRightParen, 0)
}

func (s *AtomicTypeSpecifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AtomicTypeSpecifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AtomicTypeSpecifierContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CParserVisitor:
		return t.VisitAtomicTypeSpecifier(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CParser) AtomicTypeSpecifier() (localctx IAtomicTypeSpecifierContext) {
	this := p
	_ = this

	localctx = NewAtomicTypeSpecifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 66, CParserRULE_atomicTypeSpecifier)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(593)
		p.Match(CParserAtomic)
	}
	{
		p.SetState(594)
		p.Match(CParserLeftParen)
	}
	{
		p.SetState(595)
		p.typeName(0)
	}
	{
		p.SetState(596)
		p.Match(CParserRightParen)
	}

	return localctx
}

// ITypeQualifierContext is an interface to support dynamic dispatch.
type ITypeQualifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTypeQualifierContext differentiates from other interfaces.
	IsTypeQualifierContext()
}

type TypeQualifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeQualifierContext() *TypeQualifierContext {
	var p = new(TypeQualifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CParserRULE_typeQualifier
	return p
}

func (*TypeQualifierContext) IsTypeQualifierContext() {}

func NewTypeQualifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeQualifierContext {
	var p = new(TypeQualifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CParserRULE_typeQualifier

	return p
}

func (s *TypeQualifierContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeQualifierContext) Const() antlr.TerminalNode {
	return s.GetToken(CParserConst, 0)
}

func (s *TypeQualifierContext) Restrict() antlr.TerminalNode {
	return s.GetToken(CParserRestrict, 0)
}

func (s *TypeQualifierContext) Volatile() antlr.TerminalNode {
	return s.GetToken(CParserVolatile, 0)
}

func (s *TypeQualifierContext) Atomic() antlr.TerminalNode {
	return s.GetToken(CParserAtomic, 0)
}

func (s *TypeQualifierContext) Signed() antlr.TerminalNode {
	return s.GetToken(CParserSigned, 0)
}

func (s *TypeQualifierContext) Unsigned() antlr.TerminalNode {
	return s.GetToken(CParserUnsigned, 0)
}

func (s *TypeQualifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeQualifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeQualifierContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CParserVisitor:
		return t.VisitTypeQualifier(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CParser) TypeQualifier() (localctx ITypeQualifierContext) {
	this := p
	_ = this

	localctx = NewTypeQualifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 68, CParserRULE_typeQualifier)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(598)
		_la = p.GetTokenStream().LA(1)

		if !((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&592780984352) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IFunctionSpecifierContext is an interface to support dynamic dispatch.
type IFunctionSpecifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFunctionSpecifierContext differentiates from other interfaces.
	IsFunctionSpecifierContext()
}

type FunctionSpecifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunctionSpecifierContext() *FunctionSpecifierContext {
	var p = new(FunctionSpecifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CParserRULE_functionSpecifier
	return p
}

func (*FunctionSpecifierContext) IsFunctionSpecifierContext() {}

func NewFunctionSpecifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FunctionSpecifierContext {
	var p = new(FunctionSpecifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CParserRULE_functionSpecifier

	return p
}

func (s *FunctionSpecifierContext) GetParser() antlr.Parser { return s.parser }

func (s *FunctionSpecifierContext) Inline() antlr.TerminalNode {
	return s.GetToken(CParserInline, 0)
}

func (s *FunctionSpecifierContext) Noreturn() antlr.TerminalNode {
	return s.GetToken(CParserNoreturn, 0)
}

func (s *FunctionSpecifierContext) Inline__() antlr.TerminalNode {
	return s.GetToken(CParserInline__, 0)
}

func (s *FunctionSpecifierContext) Stdcall() antlr.TerminalNode {
	return s.GetToken(CParserStdcall, 0)
}

func (s *FunctionSpecifierContext) GccAttributeSpecifier() IGccAttributeSpecifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGccAttributeSpecifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGccAttributeSpecifierContext)
}

func (s *FunctionSpecifierContext) Declspec() antlr.TerminalNode {
	return s.GetToken(CParserDeclspec, 0)
}

func (s *FunctionSpecifierContext) LeftParen() antlr.TerminalNode {
	return s.GetToken(CParserLeftParen, 0)
}

func (s *FunctionSpecifierContext) Identifier() antlr.TerminalNode {
	return s.GetToken(CParserIdentifier, 0)
}

func (s *FunctionSpecifierContext) RightParen() antlr.TerminalNode {
	return s.GetToken(CParserRightParen, 0)
}

func (s *FunctionSpecifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FunctionSpecifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FunctionSpecifierContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CParserVisitor:
		return t.VisitFunctionSpecifier(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CParser) FunctionSpecifier() (localctx IFunctionSpecifierContext) {
	this := p
	_ = this

	localctx = NewFunctionSpecifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 70, CParserRULE_functionSpecifier)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(609)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case CParserInline:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(600)
			p.Match(CParserInline)
		}

	case CParserNoreturn:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(601)
			p.Match(CParserNoreturn)
		}

	case CParserInline__:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(602)
			p.Match(CParserInline__)
		}

	case CParserStdcall:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(603)
			p.Match(CParserStdcall)
		}

	case CParserAttribute__:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(604)
			p.GccAttributeSpecifier()
		}

	case CParserDeclspec:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(605)
			p.Match(CParserDeclspec)
		}
		{
			p.SetState(606)
			p.Match(CParserLeftParen)
		}
		{
			p.SetState(607)
			p.Match(CParserIdentifier)
		}
		{
			p.SetState(608)
			p.Match(CParserRightParen)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IAlignmentSpecifierContext is an interface to support dynamic dispatch.
type IAlignmentSpecifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAlignmentSpecifierContext differentiates from other interfaces.
	IsAlignmentSpecifierContext()
}

type AlignmentSpecifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlignmentSpecifierContext() *AlignmentSpecifierContext {
	var p = new(AlignmentSpecifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CParserRULE_alignmentSpecifier
	return p
}

func (*AlignmentSpecifierContext) IsAlignmentSpecifierContext() {}

func NewAlignmentSpecifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlignmentSpecifierContext {
	var p = new(AlignmentSpecifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CParserRULE_alignmentSpecifier

	return p
}

func (s *AlignmentSpecifierContext) GetParser() antlr.Parser { return s.parser }

func (s *AlignmentSpecifierContext) Alignas() antlr.TerminalNode {
	return s.GetToken(CParserAlignas, 0)
}

func (s *AlignmentSpecifierContext) LeftParen() antlr.TerminalNode {
	return s.GetToken(CParserLeftParen, 0)
}

func (s *AlignmentSpecifierContext) RightParen() antlr.TerminalNode {
	return s.GetToken(CParserRightParen, 0)
}

func (s *AlignmentSpecifierContext) TypeName() ITypeNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeNameContext)
}

func (s *AlignmentSpecifierContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *AlignmentSpecifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlignmentSpecifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AlignmentSpecifierContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CParserVisitor:
		return t.VisitAlignmentSpecifier(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CParser) AlignmentSpecifier() (localctx IAlignmentSpecifierContext) {
	this := p
	_ = this

	localctx = NewAlignmentSpecifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 72, CParserRULE_alignmentSpecifier)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(611)
		p.Match(CParserAlignas)
	}
	{
		p.SetState(612)
		p.Match(CParserLeftParen)
	}
	p.SetState(615)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 61, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(613)
			p.typeName(0)
		}

	case 2:
		{
			p.SetState(614)
			p.expression(0)
		}

	}
	{
		p.SetState(617)
		p.Match(CParserRightParen)
	}

	return localctx
}

// IDeclaratorContext is an interface to support dynamic dispatch.
type IDeclaratorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDeclaratorContext differentiates from other interfaces.
	IsDeclaratorContext()
}

type DeclaratorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDeclaratorContext() *DeclaratorContext {
	var p = new(DeclaratorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CParserRULE_declarator
	return p
}

func (*DeclaratorContext) IsDeclaratorContext() {}

func NewDeclaratorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DeclaratorContext {
	var p = new(DeclaratorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CParserRULE_declarator

	return p
}

func (s *DeclaratorContext) GetParser() antlr.Parser { return s.parser }

func (s *DeclaratorContext) DirectDeclarator() IDirectDeclaratorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDirectDeclaratorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDirectDeclaratorContext)
}

func (s *DeclaratorContext) Pointer() IPointerContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPointerContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPointerContext)
}

func (s *DeclaratorContext) AllGccDeclaratorExtension() []IGccDeclaratorExtensionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IGccDeclaratorExtensionContext); ok {
			len++
		}
	}

	tst := make([]IGccDeclaratorExtensionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IGccDeclaratorExtensionContext); ok {
			tst[i] = t.(IGccDeclaratorExtensionContext)
			i++
		}
	}

	return tst
}

func (s *DeclaratorContext) GccDeclaratorExtension(i int) IGccDeclaratorExtensionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGccDeclaratorExtensionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGccDeclaratorExtensionContext)
}

func (s *DeclaratorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DeclaratorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DeclaratorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CParserVisitor:
		return t.VisitDeclarator(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CParser) Declarator() (localctx IDeclaratorContext) {
	this := p
	_ = this

	localctx = NewDeclaratorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 74, CParserRULE_declarator)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(620)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == CParserStar || _la == CParserCaret {
		{
			p.SetState(619)
			p.Pointer()
		}

	}
	{
		p.SetState(622)
		p.directDeclarator(0)
	}
	p.SetState(626)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 63, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(623)
				p.GccDeclaratorExtension()
			}

		}
		p.SetState(628)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 63, p.GetParserRuleContext())
	}

	return localctx
}

// IDirectDeclaratorContext is an interface to support dynamic dispatch.
type IDirectDeclaratorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDirectDeclaratorContext differentiates from other interfaces.
	IsDirectDeclaratorContext()
}

type DirectDeclaratorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDirectDeclaratorContext() *DirectDeclaratorContext {
	var p = new(DirectDeclaratorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CParserRULE_directDeclarator
	return p
}

func (*DirectDeclaratorContext) IsDirectDeclaratorContext() {}

func NewDirectDeclaratorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DirectDeclaratorContext {
	var p = new(DirectDeclaratorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CParserRULE_directDeclarator

	return p
}

func (s *DirectDeclaratorContext) GetParser() antlr.Parser { return s.parser }

func (s *DirectDeclaratorContext) Identifier() antlr.TerminalNode {
	return s.GetToken(CParserIdentifier, 0)
}

func (s *DirectDeclaratorContext) LeftParen() antlr.TerminalNode {
	return s.GetToken(CParserLeftParen, 0)
}

func (s *DirectDeclaratorContext) Declarator() IDeclaratorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDeclaratorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDeclaratorContext)
}

func (s *DirectDeclaratorContext) RightParen() antlr.TerminalNode {
	return s.GetToken(CParserRightParen, 0)
}

func (s *DirectDeclaratorContext) Colon() antlr.TerminalNode {
	return s.GetToken(CParserColon, 0)
}

func (s *DirectDeclaratorContext) DigitSequence() antlr.TerminalNode {
	return s.GetToken(CParserDigitSequence, 0)
}

func (s *DirectDeclaratorContext) VcSpecificModifer() IVcSpecificModiferContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVcSpecificModiferContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVcSpecificModiferContext)
}

func (s *DirectDeclaratorContext) DirectDeclarator() IDirectDeclaratorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDirectDeclaratorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDirectDeclaratorContext)
}

func (s *DirectDeclaratorContext) LeftBracket() antlr.TerminalNode {
	return s.GetToken(CParserLeftBracket, 0)
}

func (s *DirectDeclaratorContext) RightBracket() antlr.TerminalNode {
	return s.GetToken(CParserRightBracket, 0)
}

func (s *DirectDeclaratorContext) TypeQualifierList() ITypeQualifierListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeQualifierListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeQualifierListContext)
}

func (s *DirectDeclaratorContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *DirectDeclaratorContext) Static() antlr.TerminalNode {
	return s.GetToken(CParserStatic, 0)
}

func (s *DirectDeclaratorContext) Star() antlr.TerminalNode {
	return s.GetToken(CParserStar, 0)
}

func (s *DirectDeclaratorContext) ParameterTypeList() IParameterTypeListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IParameterTypeListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IParameterTypeListContext)
}

func (s *DirectDeclaratorContext) IdentifierList() IIdentifierListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierListContext)
}

func (s *DirectDeclaratorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DirectDeclaratorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DirectDeclaratorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CParserVisitor:
		return t.VisitDirectDeclarator(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CParser) DirectDeclarator() (localctx IDirectDeclaratorContext) {
	return p.directDeclarator(0)
}

func (p *CParser) directDeclarator(_p int) (localctx IDirectDeclaratorContext) {
	this := p
	_ = this

	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()
	_parentState := p.GetState()
	localctx = NewDirectDeclaratorContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IDirectDeclaratorContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 76
	p.EnterRecursionRule(localctx, 76, CParserRULE_directDeclarator, _p)
	var _la int

	defer func() {
		p.UnrollRecursionContexts(_parentctx)
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(646)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 64, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(630)
			p.Match(CParserIdentifier)
		}

	case 2:
		{
			p.SetState(631)
			p.Match(CParserLeftParen)
		}
		{
			p.SetState(632)
			p.Declarator()
		}
		{
			p.SetState(633)
			p.Match(CParserRightParen)
		}

	case 3:
		{
			p.SetState(635)
			p.Match(CParserIdentifier)
		}
		{
			p.SetState(636)
			p.Match(CParserColon)
		}
		{
			p.SetState(637)
			p.Match(CParserDigitSequence)
		}

	case 4:
		{
			p.SetState(638)
			p.VcSpecificModifer()
		}
		{
			p.SetState(639)
			p.Match(CParserIdentifier)
		}

	case 5:
		{
			p.SetState(641)
			p.Match(CParserLeftParen)
		}
		{
			p.SetState(642)
			p.VcSpecificModifer()
		}
		{
			p.SetState(643)
			p.Declarator()
		}
		{
			p.SetState(644)
			p.Match(CParserRightParen)
		}

	}
	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(693)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 71, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			p.SetState(691)
			p.GetErrorHandler().Sync(p)
			switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 70, p.GetParserRuleContext()) {
			case 1:
				localctx = NewDirectDeclaratorContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, CParserRULE_directDeclarator)
				p.SetState(648)

				if !(p.Precpred(p.GetParserRuleContext(), 9)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 9)", ""))
				}
				{
					p.SetState(649)
					p.Match(CParserLeftBracket)
				}
				p.SetState(651)
				p.GetErrorHandler().Sync(p)

				if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 65, p.GetParserRuleContext()) == 1 {
					{
						p.SetState(650)
						p.TypeQualifierList()
					}

				}
				p.SetState(654)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)

				if (int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-576223327602051534) != 0 || (int64((_la-66)) & ^0x3f) == 0 && ((int64(1)<<(_la-66))&70308346200181) != 0 {
					{
						p.SetState(653)
						p.expression(0)
					}

				}
				{
					p.SetState(656)
					p.Match(CParserRightBracket)
				}

			case 2:
				localctx = NewDirectDeclaratorContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, CParserRULE_directDeclarator)
				p.SetState(657)

				if !(p.Precpred(p.GetParserRuleContext(), 8)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 8)", ""))
				}
				{
					p.SetState(658)
					p.Match(CParserLeftBracket)
				}
				{
					p.SetState(659)
					p.Match(CParserStatic)
				}
				p.SetState(661)
				p.GetErrorHandler().Sync(p)

				if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 67, p.GetParserRuleContext()) == 1 {
					{
						p.SetState(660)
						p.TypeQualifierList()
					}

				}
				{
					p.SetState(663)
					p.expression(0)
				}
				{
					p.SetState(664)
					p.Match(CParserRightBracket)
				}

			case 3:
				localctx = NewDirectDeclaratorContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, CParserRULE_directDeclarator)
				p.SetState(666)

				if !(p.Precpred(p.GetParserRuleContext(), 7)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 7)", ""))
				}
				{
					p.SetState(667)
					p.Match(CParserLeftBracket)
				}
				{
					p.SetState(668)
					p.TypeQualifierList()
				}
				{
					p.SetState(669)
					p.Match(CParserStatic)
				}
				{
					p.SetState(670)
					p.expression(0)
				}
				{
					p.SetState(671)
					p.Match(CParserRightBracket)
				}

			case 4:
				localctx = NewDirectDeclaratorContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, CParserRULE_directDeclarator)
				p.SetState(673)

				if !(p.Precpred(p.GetParserRuleContext(), 6)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 6)", ""))
				}
				{
					p.SetState(674)
					p.Match(CParserLeftBracket)
				}
				p.SetState(676)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)

				if (int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&592780984352) != 0 {
					{
						p.SetState(675)
						p.TypeQualifierList()
					}

				}
				{
					p.SetState(678)
					p.Match(CParserStar)
				}
				{
					p.SetState(679)
					p.Match(CParserRightBracket)
				}

			case 5:
				localctx = NewDirectDeclaratorContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, CParserRULE_directDeclarator)
				p.SetState(680)

				if !(p.Precpred(p.GetParserRuleContext(), 5)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 5)", ""))
				}
				{
					p.SetState(681)
					p.Match(CParserLeftParen)
				}
				{
					p.SetState(682)
					p.ParameterTypeList()
				}
				{
					p.SetState(683)
					p.Match(CParserRightParen)
				}

			case 6:
				localctx = NewDirectDeclaratorContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, CParserRULE_directDeclarator)
				p.SetState(685)

				if !(p.Precpred(p.GetParserRuleContext(), 4)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 4)", ""))
				}
				{
					p.SetState(686)
					p.Match(CParserLeftParen)
				}
				p.SetState(688)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)

				if _la == CParserIdentifier {
					{
						p.SetState(687)
						p.IdentifierList()
					}

				}
				{
					p.SetState(690)
					p.Match(CParserRightParen)
				}

			}

		}
		p.SetState(695)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 71, p.GetParserRuleContext())
	}

	return localctx
}

// IVcSpecificModiferContext is an interface to support dynamic dispatch.
type IVcSpecificModiferContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsVcSpecificModiferContext differentiates from other interfaces.
	IsVcSpecificModiferContext()
}

type VcSpecificModiferContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVcSpecificModiferContext() *VcSpecificModiferContext {
	var p = new(VcSpecificModiferContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CParserRULE_vcSpecificModifer
	return p
}

func (*VcSpecificModiferContext) IsVcSpecificModiferContext() {}

func NewVcSpecificModiferContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *VcSpecificModiferContext {
	var p = new(VcSpecificModiferContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CParserRULE_vcSpecificModifer

	return p
}

func (s *VcSpecificModiferContext) GetParser() antlr.Parser { return s.parser }

func (s *VcSpecificModiferContext) Cdecl() antlr.TerminalNode {
	return s.GetToken(CParserCdecl, 0)
}

func (s *VcSpecificModiferContext) Clrcall() antlr.TerminalNode {
	return s.GetToken(CParserClrcall, 0)
}

func (s *VcSpecificModiferContext) Stdcall() antlr.TerminalNode {
	return s.GetToken(CParserStdcall, 0)
}

func (s *VcSpecificModiferContext) Fastcall() antlr.TerminalNode {
	return s.GetToken(CParserFastcall, 0)
}

func (s *VcSpecificModiferContext) Thiscall() antlr.TerminalNode {
	return s.GetToken(CParserThiscall, 0)
}

func (s *VcSpecificModiferContext) Vectorcall() antlr.TerminalNode {
	return s.GetToken(CParserVectorcall, 0)
}

func (s *VcSpecificModiferContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VcSpecificModiferContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *VcSpecificModiferContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CParserVisitor:
		return t.VisitVcSpecificModifer(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CParser) VcSpecificModifer() (localctx IVcSpecificModiferContext) {
	this := p
	_ = this

	localctx = NewVcSpecificModiferContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 78, CParserRULE_vcSpecificModifer)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(696)
		_la = p.GetTokenStream().LA(1)

		if !((int64((_la-110)) & ^0x3f) == 0 && ((int64(1)<<(_la-110))&125) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IGccDeclaratorExtensionContext is an interface to support dynamic dispatch.
type IGccDeclaratorExtensionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsGccDeclaratorExtensionContext differentiates from other interfaces.
	IsGccDeclaratorExtensionContext()
}

type GccDeclaratorExtensionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGccDeclaratorExtensionContext() *GccDeclaratorExtensionContext {
	var p = new(GccDeclaratorExtensionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CParserRULE_gccDeclaratorExtension
	return p
}

func (*GccDeclaratorExtensionContext) IsGccDeclaratorExtensionContext() {}

func NewGccDeclaratorExtensionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GccDeclaratorExtensionContext {
	var p = new(GccDeclaratorExtensionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CParserRULE_gccDeclaratorExtension

	return p
}

func (s *GccDeclaratorExtensionContext) GetParser() antlr.Parser { return s.parser }

func (s *GccDeclaratorExtensionContext) Asm() antlr.TerminalNode {
	return s.GetToken(CParserAsm, 0)
}

func (s *GccDeclaratorExtensionContext) GccAttributeSpecifier() IGccAttributeSpecifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGccAttributeSpecifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGccAttributeSpecifierContext)
}

func (s *GccDeclaratorExtensionContext) Identifier() antlr.TerminalNode {
	return s.GetToken(CParserIdentifier, 0)
}

func (s *GccDeclaratorExtensionContext) LeftParen() antlr.TerminalNode {
	return s.GetToken(CParserLeftParen, 0)
}

func (s *GccDeclaratorExtensionContext) GccAttributeList() IGccAttributeListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGccAttributeListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGccAttributeListContext)
}

func (s *GccDeclaratorExtensionContext) RightParen() antlr.TerminalNode {
	return s.GetToken(CParserRightParen, 0)
}

func (s *GccDeclaratorExtensionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GccDeclaratorExtensionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GccDeclaratorExtensionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CParserVisitor:
		return t.VisitGccDeclaratorExtension(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CParser) GccDeclaratorExtension() (localctx IGccDeclaratorExtensionContext) {
	this := p
	_ = this

	localctx = NewGccDeclaratorExtensionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 80, CParserRULE_gccDeclaratorExtension)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(707)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case CParserAsm:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(698)
			p.Match(CParserAsm)
		}

	case CParserAttribute__:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(699)
			p.GccAttributeSpecifier()
		}

	case CParserIdentifier:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(700)
			p.Match(CParserIdentifier)
		}
		p.SetState(705)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 72, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(701)
				p.Match(CParserLeftParen)
			}
			{
				p.SetState(702)
				p.GccAttributeList()
			}
			{
				p.SetState(703)
				p.Match(CParserRightParen)
			}

		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IGccAttributeSpecifierContext is an interface to support dynamic dispatch.
type IGccAttributeSpecifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsGccAttributeSpecifierContext differentiates from other interfaces.
	IsGccAttributeSpecifierContext()
}

type GccAttributeSpecifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGccAttributeSpecifierContext() *GccAttributeSpecifierContext {
	var p = new(GccAttributeSpecifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CParserRULE_gccAttributeSpecifier
	return p
}

func (*GccAttributeSpecifierContext) IsGccAttributeSpecifierContext() {}

func NewGccAttributeSpecifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GccAttributeSpecifierContext {
	var p = new(GccAttributeSpecifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CParserRULE_gccAttributeSpecifier

	return p
}

func (s *GccAttributeSpecifierContext) GetParser() antlr.Parser { return s.parser }

func (s *GccAttributeSpecifierContext) Attribute__() antlr.TerminalNode {
	return s.GetToken(CParserAttribute__, 0)
}

func (s *GccAttributeSpecifierContext) AllLeftParen() []antlr.TerminalNode {
	return s.GetTokens(CParserLeftParen)
}

func (s *GccAttributeSpecifierContext) LeftParen(i int) antlr.TerminalNode {
	return s.GetToken(CParserLeftParen, i)
}

func (s *GccAttributeSpecifierContext) AllRightParen() []antlr.TerminalNode {
	return s.GetTokens(CParserRightParen)
}

func (s *GccAttributeSpecifierContext) RightParen(i int) antlr.TerminalNode {
	return s.GetToken(CParserRightParen, i)
}

func (s *GccAttributeSpecifierContext) GccAttributeList() IGccAttributeListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGccAttributeListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGccAttributeListContext)
}

func (s *GccAttributeSpecifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GccAttributeSpecifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GccAttributeSpecifierContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CParserVisitor:
		return t.VisitGccAttributeSpecifier(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CParser) GccAttributeSpecifier() (localctx IGccAttributeSpecifierContext) {
	this := p
	_ = this

	localctx = NewGccAttributeSpecifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 82, CParserRULE_gccAttributeSpecifier)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(709)
		p.Match(CParserAttribute__)
	}
	{
		p.SetState(710)
		p.Match(CParserLeftParen)
	}
	{
		p.SetState(711)
		p.Match(CParserLeftParen)
	}
	p.SetState(713)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if (int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-422212465065986) != 0 || (int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&2305843009213689855) != 0 {
		{
			p.SetState(712)
			p.GccAttributeList()
		}

	}
	{
		p.SetState(715)
		p.Match(CParserRightParen)
	}
	{
		p.SetState(716)
		p.Match(CParserRightParen)
	}

	return localctx
}

// IGccAttributeListContext is an interface to support dynamic dispatch.
type IGccAttributeListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsGccAttributeListContext differentiates from other interfaces.
	IsGccAttributeListContext()
}

type GccAttributeListContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGccAttributeListContext() *GccAttributeListContext {
	var p = new(GccAttributeListContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CParserRULE_gccAttributeList
	return p
}

func (*GccAttributeListContext) IsGccAttributeListContext() {}

func NewGccAttributeListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GccAttributeListContext {
	var p = new(GccAttributeListContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CParserRULE_gccAttributeList

	return p
}

func (s *GccAttributeListContext) GetParser() antlr.Parser { return s.parser }

func (s *GccAttributeListContext) AllGccAttribute() []IGccAttributeContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IGccAttributeContext); ok {
			len++
		}
	}

	tst := make([]IGccAttributeContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IGccAttributeContext); ok {
			tst[i] = t.(IGccAttributeContext)
			i++
		}
	}

	return tst
}

func (s *GccAttributeListContext) GccAttribute(i int) IGccAttributeContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGccAttributeContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGccAttributeContext)
}

func (s *GccAttributeListContext) AllComma() []antlr.TerminalNode {
	return s.GetTokens(CParserComma)
}

func (s *GccAttributeListContext) Comma(i int) antlr.TerminalNode {
	return s.GetToken(CParserComma, i)
}

func (s *GccAttributeListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GccAttributeListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GccAttributeListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CParserVisitor:
		return t.VisitGccAttributeList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CParser) GccAttributeList() (localctx IGccAttributeListContext) {
	this := p
	_ = this

	localctx = NewGccAttributeListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 84, CParserRULE_gccAttributeList)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(718)
		p.GccAttribute()
	}
	p.SetState(723)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == CParserComma {
		{
			p.SetState(719)
			p.Match(CParserComma)
		}
		{
			p.SetState(720)
			p.GccAttribute()
		}

		p.SetState(725)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IGccAttributeContext is an interface to support dynamic dispatch.
type IGccAttributeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsGccAttributeContext differentiates from other interfaces.
	IsGccAttributeContext()
}

type GccAttributeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGccAttributeContext() *GccAttributeContext {
	var p = new(GccAttributeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CParserRULE_gccAttribute
	return p
}

func (*GccAttributeContext) IsGccAttributeContext() {}

func NewGccAttributeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GccAttributeContext {
	var p = new(GccAttributeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CParserRULE_gccAttribute

	return p
}

func (s *GccAttributeContext) GetParser() antlr.Parser { return s.parser }

func (s *GccAttributeContext) Comma() antlr.TerminalNode {
	return s.GetToken(CParserComma, 0)
}

func (s *GccAttributeContext) AllLeftParen() []antlr.TerminalNode {
	return s.GetTokens(CParserLeftParen)
}

func (s *GccAttributeContext) LeftParen(i int) antlr.TerminalNode {
	return s.GetToken(CParserLeftParen, i)
}

func (s *GccAttributeContext) AllRightParen() []antlr.TerminalNode {
	return s.GetTokens(CParserRightParen)
}

func (s *GccAttributeContext) RightParen(i int) antlr.TerminalNode {
	return s.GetToken(CParserRightParen, i)
}

func (s *GccAttributeContext) ArgumentExpressionList() IArgumentExpressionListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArgumentExpressionListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArgumentExpressionListContext)
}

func (s *GccAttributeContext) Identifier() antlr.TerminalNode {
	return s.GetToken(CParserIdentifier, 0)
}

func (s *GccAttributeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GccAttributeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GccAttributeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CParserVisitor:
		return t.VisitGccAttribute(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CParser) GccAttribute() (localctx IGccAttributeContext) {
	this := p
	_ = this

	localctx = NewGccAttributeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 86, CParserRULE_gccAttribute)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(742)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 80, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(726)
			_la = p.GetTokenStream().LA(1)

			if _la <= 0 || (int64((_la-47)) & ^0x3f) == 0 && ((int64(1)<<(_la-47))&536870915) != 0 {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		p.SetState(732)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == CParserLeftParen {
			{
				p.SetState(727)
				p.Match(CParserLeftParen)
			}
			p.SetState(729)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if (int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-576223327602051534) != 0 || (int64((_la-66)) & ^0x3f) == 0 && ((int64(1)<<(_la-66))&70308346200181) != 0 {
				{
					p.SetState(728)
					p.ArgumentExpressionList()
				}

			}
			{
				p.SetState(731)
				p.Match(CParserRightParen)
			}

		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(734)
			p.Match(CParserIdentifier)
		}
		p.SetState(740)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == CParserLeftParen {
			{
				p.SetState(735)
				p.Match(CParserLeftParen)
			}
			p.SetState(737)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if (int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-576223327602051534) != 0 || (int64((_la-66)) & ^0x3f) == 0 && ((int64(1)<<(_la-66))&70308346200181) != 0 {
				{
					p.SetState(736)
					p.ArgumentExpressionList()
				}

			}
			{
				p.SetState(739)
				p.Match(CParserRightParen)
			}

		}

	}

	return localctx
}

// IPointerContext is an interface to support dynamic dispatch.
type IPointerContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPointerContext differentiates from other interfaces.
	IsPointerContext()
}

type PointerContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPointerContext() *PointerContext {
	var p = new(PointerContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CParserRULE_pointer
	return p
}

func (*PointerContext) IsPointerContext() {}

func NewPointerContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PointerContext {
	var p = new(PointerContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CParserRULE_pointer

	return p
}

func (s *PointerContext) GetParser() antlr.Parser { return s.parser }

func (s *PointerContext) AllPointerPart() []IPointerPartContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPointerPartContext); ok {
			len++
		}
	}

	tst := make([]IPointerPartContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPointerPartContext); ok {
			tst[i] = t.(IPointerPartContext)
			i++
		}
	}

	return tst
}

func (s *PointerContext) PointerPart(i int) IPointerPartContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPointerPartContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPointerPartContext)
}

func (s *PointerContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PointerContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PointerContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CParserVisitor:
		return t.VisitPointer(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CParser) Pointer() (localctx IPointerContext) {
	this := p
	_ = this

	localctx = NewPointerContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 88, CParserRULE_pointer)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(745)
	p.GetErrorHandler().Sync(p)
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			{
				p.SetState(744)
				p.PointerPart()
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(747)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 81, p.GetParserRuleContext())
	}

	return localctx
}

// IPointerPartContext is an interface to support dynamic dispatch.
type IPointerPartContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPointerPartContext differentiates from other interfaces.
	IsPointerPartContext()
}

type PointerPartContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPointerPartContext() *PointerPartContext {
	var p = new(PointerPartContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CParserRULE_pointerPart
	return p
}

func (*PointerPartContext) IsPointerPartContext() {}

func NewPointerPartContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PointerPartContext {
	var p = new(PointerPartContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CParserRULE_pointerPart

	return p
}

func (s *PointerPartContext) GetParser() antlr.Parser { return s.parser }

func (s *PointerPartContext) Star() antlr.TerminalNode {
	return s.GetToken(CParserStar, 0)
}

func (s *PointerPartContext) Caret() antlr.TerminalNode {
	return s.GetToken(CParserCaret, 0)
}

func (s *PointerPartContext) TypeQualifierList() ITypeQualifierListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeQualifierListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeQualifierListContext)
}

func (s *PointerPartContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PointerPartContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PointerPartContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CParserVisitor:
		return t.VisitPointerPart(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CParser) PointerPart() (localctx IPointerPartContext) {
	this := p
	_ = this

	localctx = NewPointerPartContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 90, CParserRULE_pointerPart)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(749)
		_la = p.GetTokenStream().LA(1)

		if !(_la == CParserStar || _la == CParserCaret) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	p.SetState(751)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 82, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(750)
			p.TypeQualifierList()
		}

	}

	return localctx
}

// ITypeQualifierListContext is an interface to support dynamic dispatch.
type ITypeQualifierListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTypeQualifierListContext differentiates from other interfaces.
	IsTypeQualifierListContext()
}

type TypeQualifierListContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeQualifierListContext() *TypeQualifierListContext {
	var p = new(TypeQualifierListContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CParserRULE_typeQualifierList
	return p
}

func (*TypeQualifierListContext) IsTypeQualifierListContext() {}

func NewTypeQualifierListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeQualifierListContext {
	var p = new(TypeQualifierListContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CParserRULE_typeQualifierList

	return p
}

func (s *TypeQualifierListContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeQualifierListContext) AllTypeQualifier() []ITypeQualifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITypeQualifierContext); ok {
			len++
		}
	}

	tst := make([]ITypeQualifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITypeQualifierContext); ok {
			tst[i] = t.(ITypeQualifierContext)
			i++
		}
	}

	return tst
}

func (s *TypeQualifierListContext) TypeQualifier(i int) ITypeQualifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeQualifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeQualifierContext)
}

func (s *TypeQualifierListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeQualifierListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeQualifierListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CParserVisitor:
		return t.VisitTypeQualifierList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CParser) TypeQualifierList() (localctx ITypeQualifierListContext) {
	this := p
	_ = this

	localctx = NewTypeQualifierListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 92, CParserRULE_typeQualifierList)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(754)
	p.GetErrorHandler().Sync(p)
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			{
				p.SetState(753)
				p.TypeQualifier()
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(756)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 83, p.GetParserRuleContext())
	}

	return localctx
}

// IParameterTypeListContext is an interface to support dynamic dispatch.
type IParameterTypeListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsParameterTypeListContext differentiates from other interfaces.
	IsParameterTypeListContext()
}

type ParameterTypeListContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyParameterTypeListContext() *ParameterTypeListContext {
	var p = new(ParameterTypeListContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CParserRULE_parameterTypeList
	return p
}

func (*ParameterTypeListContext) IsParameterTypeListContext() {}

func NewParameterTypeListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ParameterTypeListContext {
	var p = new(ParameterTypeListContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CParserRULE_parameterTypeList

	return p
}

func (s *ParameterTypeListContext) GetParser() antlr.Parser { return s.parser }

func (s *ParameterTypeListContext) ParameterList() IParameterListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IParameterListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IParameterListContext)
}

func (s *ParameterTypeListContext) Comma() antlr.TerminalNode {
	return s.GetToken(CParserComma, 0)
}

func (s *ParameterTypeListContext) Ellipsis() antlr.TerminalNode {
	return s.GetToken(CParserEllipsis, 0)
}

func (s *ParameterTypeListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ParameterTypeListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ParameterTypeListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CParserVisitor:
		return t.VisitParameterTypeList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CParser) ParameterTypeList() (localctx IParameterTypeListContext) {
	this := p
	_ = this

	localctx = NewParameterTypeListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 94, CParserRULE_parameterTypeList)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(758)
		p.ParameterList()
	}
	p.SetState(763)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == CParserComma {
		{
			p.SetState(759)
			p.Match(CParserComma)
		}
		p.SetState(761)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == CParserEllipsis {
			{
				p.SetState(760)
				p.Match(CParserEllipsis)
			}

		}

	}

	return localctx
}

// IParameterListContext is an interface to support dynamic dispatch.
type IParameterListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsParameterListContext differentiates from other interfaces.
	IsParameterListContext()
}

type ParameterListContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyParameterListContext() *ParameterListContext {
	var p = new(ParameterListContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CParserRULE_parameterList
	return p
}

func (*ParameterListContext) IsParameterListContext() {}

func NewParameterListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ParameterListContext {
	var p = new(ParameterListContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CParserRULE_parameterList

	return p
}

func (s *ParameterListContext) GetParser() antlr.Parser { return s.parser }

func (s *ParameterListContext) AllParameterDeclaration() []IParameterDeclarationContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IParameterDeclarationContext); ok {
			len++
		}
	}

	tst := make([]IParameterDeclarationContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IParameterDeclarationContext); ok {
			tst[i] = t.(IParameterDeclarationContext)
			i++
		}
	}

	return tst
}

func (s *ParameterListContext) ParameterDeclaration(i int) IParameterDeclarationContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IParameterDeclarationContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IParameterDeclarationContext)
}

func (s *ParameterListContext) AllComma() []antlr.TerminalNode {
	return s.GetTokens(CParserComma)
}

func (s *ParameterListContext) Comma(i int) antlr.TerminalNode {
	return s.GetToken(CParserComma, i)
}

func (s *ParameterListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ParameterListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ParameterListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CParserVisitor:
		return t.VisitParameterList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CParser) ParameterList() (localctx IParameterListContext) {
	this := p
	_ = this

	localctx = NewParameterListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 96, CParserRULE_parameterList)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(765)
		p.ParameterDeclaration()
	}
	p.SetState(770)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 86, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(766)
				p.Match(CParserComma)
			}
			{
				p.SetState(767)
				p.ParameterDeclaration()
			}

		}
		p.SetState(772)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 86, p.GetParserRuleContext())
	}

	return localctx
}

// IParameterDeclarationContext is an interface to support dynamic dispatch.
type IParameterDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsParameterDeclarationContext differentiates from other interfaces.
	IsParameterDeclarationContext()
}

type ParameterDeclarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyParameterDeclarationContext() *ParameterDeclarationContext {
	var p = new(ParameterDeclarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CParserRULE_parameterDeclaration
	return p
}

func (*ParameterDeclarationContext) IsParameterDeclarationContext() {}

func NewParameterDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ParameterDeclarationContext {
	var p = new(ParameterDeclarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CParserRULE_parameterDeclaration

	return p
}

func (s *ParameterDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *ParameterDeclarationContext) DeclarationSpecifier() IDeclarationSpecifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDeclarationSpecifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDeclarationSpecifierContext)
}

func (s *ParameterDeclarationContext) Declarator() IDeclaratorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDeclaratorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDeclaratorContext)
}

func (s *ParameterDeclarationContext) AbstractDeclarator() IAbstractDeclaratorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAbstractDeclaratorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAbstractDeclaratorContext)
}

func (s *ParameterDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ParameterDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ParameterDeclarationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CParserVisitor:
		return t.VisitParameterDeclaration(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CParser) ParameterDeclaration() (localctx IParameterDeclarationContext) {
	this := p
	_ = this

	localctx = NewParameterDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 98, CParserRULE_parameterDeclaration)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(780)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 88, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(773)
			p.DeclarationSpecifier()
		}
		{
			p.SetState(774)
			p.Declarator()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(776)
			p.DeclarationSpecifier()
		}
		p.SetState(778)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if (int64((_la-47)) & ^0x3f) == 0 && ((int64(1)<<(_la-47))&8454149) != 0 {
			{
				p.SetState(777)
				p.AbstractDeclarator()
			}

		}

	}

	return localctx
}

// IIdentifierListContext is an interface to support dynamic dispatch.
type IIdentifierListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsIdentifierListContext differentiates from other interfaces.
	IsIdentifierListContext()
}

type IdentifierListContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIdentifierListContext() *IdentifierListContext {
	var p = new(IdentifierListContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CParserRULE_identifierList
	return p
}

func (*IdentifierListContext) IsIdentifierListContext() {}

func NewIdentifierListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IdentifierListContext {
	var p = new(IdentifierListContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CParserRULE_identifierList

	return p
}

func (s *IdentifierListContext) GetParser() antlr.Parser { return s.parser }

func (s *IdentifierListContext) AllIdentifier() []antlr.TerminalNode {
	return s.GetTokens(CParserIdentifier)
}

func (s *IdentifierListContext) Identifier(i int) antlr.TerminalNode {
	return s.GetToken(CParserIdentifier, i)
}

func (s *IdentifierListContext) AllComma() []antlr.TerminalNode {
	return s.GetTokens(CParserComma)
}

func (s *IdentifierListContext) Comma(i int) antlr.TerminalNode {
	return s.GetToken(CParserComma, i)
}

func (s *IdentifierListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IdentifierListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IdentifierListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CParserVisitor:
		return t.VisitIdentifierList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CParser) IdentifierList() (localctx IIdentifierListContext) {
	this := p
	_ = this

	localctx = NewIdentifierListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 100, CParserRULE_identifierList)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(782)
		p.Match(CParserIdentifier)
	}
	p.SetState(787)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == CParserComma {
		{
			p.SetState(783)
			p.Match(CParserComma)
		}
		{
			p.SetState(784)
			p.Match(CParserIdentifier)
		}

		p.SetState(789)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// ITypeNameContext is an interface to support dynamic dispatch.
type ITypeNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTypeNameContext differentiates from other interfaces.
	IsTypeNameContext()
}

type TypeNameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeNameContext() *TypeNameContext {
	var p = new(TypeNameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CParserRULE_typeName
	return p
}

func (*TypeNameContext) IsTypeNameContext() {}

func NewTypeNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeNameContext {
	var p = new(TypeNameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CParserRULE_typeName

	return p
}

func (s *TypeNameContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeNameContext) SpecifierQualifierList() ISpecifierQualifierListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISpecifierQualifierListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISpecifierQualifierListContext)
}

func (s *TypeNameContext) AbstractDeclarator() IAbstractDeclaratorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAbstractDeclaratorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAbstractDeclaratorContext)
}

func (s *TypeNameContext) TypeName() ITypeNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeNameContext)
}

func (s *TypeNameContext) Identifier() antlr.TerminalNode {
	return s.GetToken(CParserIdentifier, 0)
}

func (s *TypeNameContext) Dot() antlr.TerminalNode {
	return s.GetToken(CParserDot, 0)
}

func (s *TypeNameContext) Arrow() antlr.TerminalNode {
	return s.GetToken(CParserArrow, 0)
}

func (s *TypeNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeNameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CParserVisitor:
		return t.VisitTypeName(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CParser) TypeName() (localctx ITypeNameContext) {
	return p.typeName(0)
}

func (p *CParser) typeName(_p int) (localctx ITypeNameContext) {
	this := p
	_ = this

	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()
	_parentState := p.GetState()
	localctx = NewTypeNameContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx ITypeNameContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 102
	p.EnterRecursionRule(localctx, 102, CParserRULE_typeName, _p)
	var _la int

	defer func() {
		p.UnrollRecursionContexts(_parentctx)
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(791)
		p.SpecifierQualifierList()
	}
	p.SetState(793)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 90, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(792)
			p.AbstractDeclarator()
		}

	}

	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(800)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 91, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			localctx = NewTypeNameContext(p, _parentctx, _parentState)
			p.PushNewRecursionContext(localctx, _startState, CParserRULE_typeName)
			p.SetState(795)

			if !(p.Precpred(p.GetParserRuleContext(), 1)) {
				panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 1)", ""))
			}
			{
				p.SetState(796)
				_la = p.GetTokenStream().LA(1)

				if !(_la == CParserArrow || _la == CParserDot) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}
			{
				p.SetState(797)
				p.Match(CParserIdentifier)
			}

		}
		p.SetState(802)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 91, p.GetParserRuleContext())
	}

	return localctx
}

// IAbstractDeclaratorContext is an interface to support dynamic dispatch.
type IAbstractDeclaratorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAbstractDeclaratorContext differentiates from other interfaces.
	IsAbstractDeclaratorContext()
}

type AbstractDeclaratorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAbstractDeclaratorContext() *AbstractDeclaratorContext {
	var p = new(AbstractDeclaratorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CParserRULE_abstractDeclarator
	return p
}

func (*AbstractDeclaratorContext) IsAbstractDeclaratorContext() {}

func NewAbstractDeclaratorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AbstractDeclaratorContext {
	var p = new(AbstractDeclaratorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CParserRULE_abstractDeclarator

	return p
}

func (s *AbstractDeclaratorContext) GetParser() antlr.Parser { return s.parser }

func (s *AbstractDeclaratorContext) Pointer() IPointerContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPointerContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPointerContext)
}

func (s *AbstractDeclaratorContext) DirectAbstractDeclarator() IDirectAbstractDeclaratorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDirectAbstractDeclaratorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDirectAbstractDeclaratorContext)
}

func (s *AbstractDeclaratorContext) AllGccDeclaratorExtension() []IGccDeclaratorExtensionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IGccDeclaratorExtensionContext); ok {
			len++
		}
	}

	tst := make([]IGccDeclaratorExtensionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IGccDeclaratorExtensionContext); ok {
			tst[i] = t.(IGccDeclaratorExtensionContext)
			i++
		}
	}

	return tst
}

func (s *AbstractDeclaratorContext) GccDeclaratorExtension(i int) IGccDeclaratorExtensionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGccDeclaratorExtensionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGccDeclaratorExtensionContext)
}

func (s *AbstractDeclaratorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AbstractDeclaratorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AbstractDeclaratorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CParserVisitor:
		return t.VisitAbstractDeclarator(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CParser) AbstractDeclarator() (localctx IAbstractDeclaratorContext) {
	this := p
	_ = this

	localctx = NewAbstractDeclaratorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 104, CParserRULE_abstractDeclarator)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.SetState(814)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 94, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(803)
			p.Pointer()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(805)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == CParserStar || _la == CParserCaret {
			{
				p.SetState(804)
				p.Pointer()
			}

		}
		{
			p.SetState(807)
			p.directAbstractDeclarator(0)
		}
		p.SetState(811)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 93, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(808)
					p.GccDeclaratorExtension()
				}

			}
			p.SetState(813)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 93, p.GetParserRuleContext())
		}

	}

	return localctx
}

// IDirectAbstractDeclaratorContext is an interface to support dynamic dispatch.
type IDirectAbstractDeclaratorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDirectAbstractDeclaratorContext differentiates from other interfaces.
	IsDirectAbstractDeclaratorContext()
}

type DirectAbstractDeclaratorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDirectAbstractDeclaratorContext() *DirectAbstractDeclaratorContext {
	var p = new(DirectAbstractDeclaratorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CParserRULE_directAbstractDeclarator
	return p
}

func (*DirectAbstractDeclaratorContext) IsDirectAbstractDeclaratorContext() {}

func NewDirectAbstractDeclaratorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DirectAbstractDeclaratorContext {
	var p = new(DirectAbstractDeclaratorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CParserRULE_directAbstractDeclarator

	return p
}

func (s *DirectAbstractDeclaratorContext) GetParser() antlr.Parser { return s.parser }

func (s *DirectAbstractDeclaratorContext) LeftParen() antlr.TerminalNode {
	return s.GetToken(CParserLeftParen, 0)
}

func (s *DirectAbstractDeclaratorContext) AbstractDeclarator() IAbstractDeclaratorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAbstractDeclaratorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAbstractDeclaratorContext)
}

func (s *DirectAbstractDeclaratorContext) RightParen() antlr.TerminalNode {
	return s.GetToken(CParserRightParen, 0)
}

func (s *DirectAbstractDeclaratorContext) AllGccDeclaratorExtension() []IGccDeclaratorExtensionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IGccDeclaratorExtensionContext); ok {
			len++
		}
	}

	tst := make([]IGccDeclaratorExtensionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IGccDeclaratorExtensionContext); ok {
			tst[i] = t.(IGccDeclaratorExtensionContext)
			i++
		}
	}

	return tst
}

func (s *DirectAbstractDeclaratorContext) GccDeclaratorExtension(i int) IGccDeclaratorExtensionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGccDeclaratorExtensionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGccDeclaratorExtensionContext)
}

func (s *DirectAbstractDeclaratorContext) LeftBracket() antlr.TerminalNode {
	return s.GetToken(CParserLeftBracket, 0)
}

func (s *DirectAbstractDeclaratorContext) RightBracket() antlr.TerminalNode {
	return s.GetToken(CParserRightBracket, 0)
}

func (s *DirectAbstractDeclaratorContext) TypeQualifierList() ITypeQualifierListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeQualifierListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeQualifierListContext)
}

func (s *DirectAbstractDeclaratorContext) AssignmentExpression() IAssignmentExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAssignmentExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAssignmentExpressionContext)
}

func (s *DirectAbstractDeclaratorContext) Static() antlr.TerminalNode {
	return s.GetToken(CParserStatic, 0)
}

func (s *DirectAbstractDeclaratorContext) Star() antlr.TerminalNode {
	return s.GetToken(CParserStar, 0)
}

func (s *DirectAbstractDeclaratorContext) ParameterTypeList() IParameterTypeListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IParameterTypeListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IParameterTypeListContext)
}

func (s *DirectAbstractDeclaratorContext) DirectAbstractDeclarator() IDirectAbstractDeclaratorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDirectAbstractDeclaratorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDirectAbstractDeclaratorContext)
}

func (s *DirectAbstractDeclaratorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DirectAbstractDeclaratorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DirectAbstractDeclaratorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CParserVisitor:
		return t.VisitDirectAbstractDeclarator(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CParser) DirectAbstractDeclarator() (localctx IDirectAbstractDeclaratorContext) {
	return p.directAbstractDeclarator(0)
}

func (p *CParser) directAbstractDeclarator(_p int) (localctx IDirectAbstractDeclaratorContext) {
	this := p
	_ = this

	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()
	_parentState := p.GetState()
	localctx = NewDirectAbstractDeclaratorContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IDirectAbstractDeclaratorContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 106
	p.EnterRecursionRule(localctx, 106, CParserRULE_directAbstractDeclarator, _p)
	var _la int

	defer func() {
		p.UnrollRecursionContexts(_parentctx)
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(862)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 101, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(817)
			p.Match(CParserLeftParen)
		}
		{
			p.SetState(818)
			p.AbstractDeclarator()
		}
		{
			p.SetState(819)
			p.Match(CParserRightParen)
		}
		p.SetState(823)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 95, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(820)
					p.GccDeclaratorExtension()
				}

			}
			p.SetState(825)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 95, p.GetParserRuleContext())
		}

	case 2:
		{
			p.SetState(826)
			p.Match(CParserLeftBracket)
		}
		p.SetState(828)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if (int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&592780984352) != 0 {
			{
				p.SetState(827)
				p.TypeQualifierList()
			}

		}
		p.SetState(831)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if (int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-3458619103273549824) != 0 || (int64((_la-66)) & ^0x3f) == 0 && ((int64(1)<<(_la-66))&489089400837) != 0 {
			{
				p.SetState(830)
				p.AssignmentExpression()
			}

		}
		{
			p.SetState(833)
			p.Match(CParserRightBracket)
		}

	case 3:
		{
			p.SetState(834)
			p.Match(CParserLeftBracket)
		}
		{
			p.SetState(835)
			p.Match(CParserStatic)
		}
		p.SetState(837)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if (int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&592780984352) != 0 {
			{
				p.SetState(836)
				p.TypeQualifierList()
			}

		}
		{
			p.SetState(839)
			p.AssignmentExpression()
		}
		{
			p.SetState(840)
			p.Match(CParserRightBracket)
		}

	case 4:
		{
			p.SetState(842)
			p.Match(CParserLeftBracket)
		}
		{
			p.SetState(843)
			p.TypeQualifierList()
		}
		{
			p.SetState(844)
			p.Match(CParserStatic)
		}
		{
			p.SetState(845)
			p.AssignmentExpression()
		}
		{
			p.SetState(846)
			p.Match(CParserRightBracket)
		}

	case 5:
		{
			p.SetState(848)
			p.Match(CParserLeftBracket)
		}
		{
			p.SetState(849)
			p.Match(CParserStar)
		}
		{
			p.SetState(850)
			p.Match(CParserRightBracket)
		}

	case 6:
		{
			p.SetState(851)
			p.Match(CParserLeftParen)
		}
		p.SetState(853)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if (int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&92014154380850) != 0 || (int64((_la-94)) & ^0x3f) == 0 && ((int64(1)<<(_la-94))&260355) != 0 {
			{
				p.SetState(852)
				p.ParameterTypeList()
			}

		}
		{
			p.SetState(855)
			p.Match(CParserRightParen)
		}
		p.SetState(859)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 100, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(856)
					p.GccDeclaratorExtension()
				}

			}
			p.SetState(861)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 100, p.GetParserRuleContext())
		}

	}
	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(907)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 108, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			p.SetState(905)
			p.GetErrorHandler().Sync(p)
			switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 107, p.GetParserRuleContext()) {
			case 1:
				localctx = NewDirectAbstractDeclaratorContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, CParserRULE_directAbstractDeclarator)
				p.SetState(864)

				if !(p.Precpred(p.GetParserRuleContext(), 5)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 5)", ""))
				}
				{
					p.SetState(865)
					p.Match(CParserLeftBracket)
				}
				p.SetState(867)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)

				if (int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&592780984352) != 0 {
					{
						p.SetState(866)
						p.TypeQualifierList()
					}

				}
				p.SetState(870)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)

				if (int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-3458619103273549824) != 0 || (int64((_la-66)) & ^0x3f) == 0 && ((int64(1)<<(_la-66))&489089400837) != 0 {
					{
						p.SetState(869)
						p.AssignmentExpression()
					}

				}
				{
					p.SetState(872)
					p.Match(CParserRightBracket)
				}

			case 2:
				localctx = NewDirectAbstractDeclaratorContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, CParserRULE_directAbstractDeclarator)
				p.SetState(873)

				if !(p.Precpred(p.GetParserRuleContext(), 4)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 4)", ""))
				}
				{
					p.SetState(874)
					p.Match(CParserLeftBracket)
				}
				{
					p.SetState(875)
					p.Match(CParserStatic)
				}
				p.SetState(877)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)

				if (int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&592780984352) != 0 {
					{
						p.SetState(876)
						p.TypeQualifierList()
					}

				}
				{
					p.SetState(879)
					p.AssignmentExpression()
				}
				{
					p.SetState(880)
					p.Match(CParserRightBracket)
				}

			case 3:
				localctx = NewDirectAbstractDeclaratorContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, CParserRULE_directAbstractDeclarator)
				p.SetState(882)

				if !(p.Precpred(p.GetParserRuleContext(), 3)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 3)", ""))
				}
				{
					p.SetState(883)
					p.Match(CParserLeftBracket)
				}
				{
					p.SetState(884)
					p.TypeQualifierList()
				}
				{
					p.SetState(885)
					p.Match(CParserStatic)
				}
				{
					p.SetState(886)
					p.AssignmentExpression()
				}
				{
					p.SetState(887)
					p.Match(CParserRightBracket)
				}

			case 4:
				localctx = NewDirectAbstractDeclaratorContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, CParserRULE_directAbstractDeclarator)
				p.SetState(889)

				if !(p.Precpred(p.GetParserRuleContext(), 2)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 2)", ""))
				}
				{
					p.SetState(890)
					p.Match(CParserLeftBracket)
				}
				{
					p.SetState(891)
					p.Match(CParserStar)
				}
				{
					p.SetState(892)
					p.Match(CParserRightBracket)
				}

			case 5:
				localctx = NewDirectAbstractDeclaratorContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, CParserRULE_directAbstractDeclarator)
				p.SetState(893)

				if !(p.Precpred(p.GetParserRuleContext(), 1)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 1)", ""))
				}
				{
					p.SetState(894)
					p.Match(CParserLeftParen)
				}
				p.SetState(896)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)

				if (int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&92014154380850) != 0 || (int64((_la-94)) & ^0x3f) == 0 && ((int64(1)<<(_la-94))&260355) != 0 {
					{
						p.SetState(895)
						p.ParameterTypeList()
					}

				}
				{
					p.SetState(898)
					p.Match(CParserRightParen)
				}
				p.SetState(902)
				p.GetErrorHandler().Sync(p)
				_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 106, p.GetParserRuleContext())

				for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
					if _alt == 1 {
						{
							p.SetState(899)
							p.GccDeclaratorExtension()
						}

					}
					p.SetState(904)
					p.GetErrorHandler().Sync(p)
					_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 106, p.GetParserRuleContext())
				}

			}

		}
		p.SetState(909)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 108, p.GetParserRuleContext())
	}

	return localctx
}

// ITypedefNameContext is an interface to support dynamic dispatch.
type ITypedefNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTypedefNameContext differentiates from other interfaces.
	IsTypedefNameContext()
}

type TypedefNameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypedefNameContext() *TypedefNameContext {
	var p = new(TypedefNameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CParserRULE_typedefName
	return p
}

func (*TypedefNameContext) IsTypedefNameContext() {}

func NewTypedefNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypedefNameContext {
	var p = new(TypedefNameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CParserRULE_typedefName

	return p
}

func (s *TypedefNameContext) GetParser() antlr.Parser { return s.parser }

func (s *TypedefNameContext) Identifier() antlr.TerminalNode {
	return s.GetToken(CParserIdentifier, 0)
}

func (s *TypedefNameContext) StructOrUnion() IStructOrUnionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStructOrUnionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStructOrUnionContext)
}

func (s *TypedefNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypedefNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypedefNameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CParserVisitor:
		return t.VisitTypedefName(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CParser) TypedefName() (localctx ITypedefNameContext) {
	this := p
	_ = this

	localctx = NewTypedefNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 108, CParserRULE_typedefName)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(911)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == CParserStruct || _la == CParserUnion {
		{
			p.SetState(910)
			p.StructOrUnion()
		}

	}
	{
		p.SetState(913)
		p.Match(CParserIdentifier)
	}

	return localctx
}

// IInitializerContext is an interface to support dynamic dispatch.
type IInitializerContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInitializerContext differentiates from other interfaces.
	IsInitializerContext()
}

type InitializerContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInitializerContext() *InitializerContext {
	var p = new(InitializerContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CParserRULE_initializer
	return p
}

func (*InitializerContext) IsInitializerContext() {}

func NewInitializerContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InitializerContext {
	var p = new(InitializerContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CParserRULE_initializer

	return p
}

func (s *InitializerContext) GetParser() antlr.Parser { return s.parser }

func (s *InitializerContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *InitializerContext) LeftBrace() antlr.TerminalNode {
	return s.GetToken(CParserLeftBrace, 0)
}

func (s *InitializerContext) RightBrace() antlr.TerminalNode {
	return s.GetToken(CParserRightBrace, 0)
}

func (s *InitializerContext) InitializerList() IInitializerListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInitializerListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInitializerListContext)
}

func (s *InitializerContext) Comma() antlr.TerminalNode {
	return s.GetToken(CParserComma, 0)
}

func (s *InitializerContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InitializerContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InitializerContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CParserVisitor:
		return t.VisitInitializer(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CParser) Initializer() (localctx IInitializerContext) {
	this := p
	_ = this

	localctx = NewInitializerContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 110, CParserRULE_initializer)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(924)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case CParserAuto, CParserChar, CParserConst, CParserDouble, CParserLongdouble, CParserEnum, CParserExtern, CParserFloat, CParserInline, CParserInt, CParserLong, CParserLonglong, CParserRegister, CParserRestrict, CParserShort, CParserSigned, CParserSizeof, CParserStatic, CParserStruct, CParserTypedef, CParserUnion, CParserUnsigned, CParserVoid, CParserVolatile, CParserAlignas, CParserAlignof, CParserAtomic, CParserBool, CParserComplex, CParserGeneric, CParserNoreturn, CParserThreadLocal, CParserLeftParen, CParserPlus, CParserPlusPlus, CParserMinus, CParserMinusMinus, CParserStar, CParserAnd, CParserAndAnd, CParserCaret, CParserNot, CParserTilde, CParserAttribute__, CParserIdentifier, CParserConstant, CParserDigitSequence, CParserStringLiteral, CParserExtension, CParserBuiltinVaArg, CParserBuiltinOffsetof, CParserM128, CParserM128d, CParserM128i, CParserTypeof, CParserInline__, CParserStdcall, CParserDeclspec:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(915)
			p.expression(0)
		}

	case CParserLeftBrace:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(916)
			p.Match(CParserLeftBrace)
		}
		p.SetState(918)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if (int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-573408577834944974) != 0 || (int64((_la-66)) & ^0x3f) == 0 && ((int64(1)<<(_la-66))&70308379754613) != 0 {
			{
				p.SetState(917)
				p.InitializerList()
			}

		}
		p.SetState(921)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == CParserComma {
			{
				p.SetState(920)
				p.Match(CParserComma)
			}

		}
		{
			p.SetState(923)
			p.Match(CParserRightBrace)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IInitializerListContext is an interface to support dynamic dispatch.
type IInitializerListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInitializerListContext differentiates from other interfaces.
	IsInitializerListContext()
}

type InitializerListContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInitializerListContext() *InitializerListContext {
	var p = new(InitializerListContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CParserRULE_initializerList
	return p
}

func (*InitializerListContext) IsInitializerListContext() {}

func NewInitializerListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InitializerListContext {
	var p = new(InitializerListContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CParserRULE_initializerList

	return p
}

func (s *InitializerListContext) GetParser() antlr.Parser { return s.parser }

func (s *InitializerListContext) AllInitializer() []IInitializerContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IInitializerContext); ok {
			len++
		}
	}

	tst := make([]IInitializerContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IInitializerContext); ok {
			tst[i] = t.(IInitializerContext)
			i++
		}
	}

	return tst
}

func (s *InitializerListContext) Initializer(i int) IInitializerContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInitializerContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInitializerContext)
}

func (s *InitializerListContext) AllDesignation() []IDesignationContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IDesignationContext); ok {
			len++
		}
	}

	tst := make([]IDesignationContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IDesignationContext); ok {
			tst[i] = t.(IDesignationContext)
			i++
		}
	}

	return tst
}

func (s *InitializerListContext) Designation(i int) IDesignationContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDesignationContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDesignationContext)
}

func (s *InitializerListContext) AllComma() []antlr.TerminalNode {
	return s.GetTokens(CParserComma)
}

func (s *InitializerListContext) Comma(i int) antlr.TerminalNode {
	return s.GetToken(CParserComma, i)
}

func (s *InitializerListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InitializerListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InitializerListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CParserVisitor:
		return t.VisitInitializerList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CParser) InitializerList() (localctx IInitializerListContext) {
	this := p
	_ = this

	localctx = NewInitializerListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 112, CParserRULE_initializerList)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(927)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == CParserLeftBracket || _la == CParserDot {
		{
			p.SetState(926)
			p.Designation()
		}

	}
	{
		p.SetState(929)
		p.Initializer()
	}
	p.SetState(937)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 115, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(930)
				p.Match(CParserComma)
			}
			p.SetState(932)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == CParserLeftBracket || _la == CParserDot {
				{
					p.SetState(931)
					p.Designation()
				}

			}
			{
				p.SetState(934)
				p.Initializer()
			}

		}
		p.SetState(939)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 115, p.GetParserRuleContext())
	}

	return localctx
}

// IDesignationContext is an interface to support dynamic dispatch.
type IDesignationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDesignationContext differentiates from other interfaces.
	IsDesignationContext()
}

type DesignationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDesignationContext() *DesignationContext {
	var p = new(DesignationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CParserRULE_designation
	return p
}

func (*DesignationContext) IsDesignationContext() {}

func NewDesignationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DesignationContext {
	var p = new(DesignationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CParserRULE_designation

	return p
}

func (s *DesignationContext) GetParser() antlr.Parser { return s.parser }

func (s *DesignationContext) DesignatorList() IDesignatorListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDesignatorListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDesignatorListContext)
}

func (s *DesignationContext) Assign() antlr.TerminalNode {
	return s.GetToken(CParserAssign, 0)
}

func (s *DesignationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DesignationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DesignationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CParserVisitor:
		return t.VisitDesignation(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CParser) Designation() (localctx IDesignationContext) {
	this := p
	_ = this

	localctx = NewDesignationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 114, CParserRULE_designation)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(940)
		p.DesignatorList()
	}
	{
		p.SetState(941)
		p.Match(CParserAssign)
	}

	return localctx
}

// IDesignatorListContext is an interface to support dynamic dispatch.
type IDesignatorListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDesignatorListContext differentiates from other interfaces.
	IsDesignatorListContext()
}

type DesignatorListContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDesignatorListContext() *DesignatorListContext {
	var p = new(DesignatorListContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CParserRULE_designatorList
	return p
}

func (*DesignatorListContext) IsDesignatorListContext() {}

func NewDesignatorListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DesignatorListContext {
	var p = new(DesignatorListContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CParserRULE_designatorList

	return p
}

func (s *DesignatorListContext) GetParser() antlr.Parser { return s.parser }

func (s *DesignatorListContext) AllDesignator() []IDesignatorContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IDesignatorContext); ok {
			len++
		}
	}

	tst := make([]IDesignatorContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IDesignatorContext); ok {
			tst[i] = t.(IDesignatorContext)
			i++
		}
	}

	return tst
}

func (s *DesignatorListContext) Designator(i int) IDesignatorContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDesignatorContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDesignatorContext)
}

func (s *DesignatorListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DesignatorListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DesignatorListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CParserVisitor:
		return t.VisitDesignatorList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CParser) DesignatorList() (localctx IDesignatorListContext) {
	this := p
	_ = this

	localctx = NewDesignatorListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 116, CParserRULE_designatorList)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(944)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = _la == CParserLeftBracket || _la == CParserDot {
		{
			p.SetState(943)
			p.Designator()
		}

		p.SetState(946)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IDesignatorContext is an interface to support dynamic dispatch.
type IDesignatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDesignatorContext differentiates from other interfaces.
	IsDesignatorContext()
}

type DesignatorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDesignatorContext() *DesignatorContext {
	var p = new(DesignatorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CParserRULE_designator
	return p
}

func (*DesignatorContext) IsDesignatorContext() {}

func NewDesignatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DesignatorContext {
	var p = new(DesignatorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CParserRULE_designator

	return p
}

func (s *DesignatorContext) GetParser() antlr.Parser { return s.parser }

func (s *DesignatorContext) LeftBracket() antlr.TerminalNode {
	return s.GetToken(CParserLeftBracket, 0)
}

func (s *DesignatorContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *DesignatorContext) RightBracket() antlr.TerminalNode {
	return s.GetToken(CParserRightBracket, 0)
}

func (s *DesignatorContext) Dot() antlr.TerminalNode {
	return s.GetToken(CParserDot, 0)
}

func (s *DesignatorContext) Identifier() antlr.TerminalNode {
	return s.GetToken(CParserIdentifier, 0)
}

func (s *DesignatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DesignatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DesignatorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CParserVisitor:
		return t.VisitDesignator(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CParser) Designator() (localctx IDesignatorContext) {
	this := p
	_ = this

	localctx = NewDesignatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 118, CParserRULE_designator)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(954)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case CParserLeftBracket:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(948)
			p.Match(CParserLeftBracket)
		}
		{
			p.SetState(949)
			p.expression(0)
		}
		{
			p.SetState(950)
			p.Match(CParserRightBracket)
		}

	case CParserDot:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(952)
			p.Match(CParserDot)
		}
		{
			p.SetState(953)
			p.Match(CParserIdentifier)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IStaticAssertDeclarationContext is an interface to support dynamic dispatch.
type IStaticAssertDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsStaticAssertDeclarationContext differentiates from other interfaces.
	IsStaticAssertDeclarationContext()
}

type StaticAssertDeclarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStaticAssertDeclarationContext() *StaticAssertDeclarationContext {
	var p = new(StaticAssertDeclarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CParserRULE_staticAssertDeclaration
	return p
}

func (*StaticAssertDeclarationContext) IsStaticAssertDeclarationContext() {}

func NewStaticAssertDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StaticAssertDeclarationContext {
	var p = new(StaticAssertDeclarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CParserRULE_staticAssertDeclaration

	return p
}

func (s *StaticAssertDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *StaticAssertDeclarationContext) StaticAssert() antlr.TerminalNode {
	return s.GetToken(CParserStaticAssert, 0)
}

func (s *StaticAssertDeclarationContext) LeftParen() antlr.TerminalNode {
	return s.GetToken(CParserLeftParen, 0)
}

func (s *StaticAssertDeclarationContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *StaticAssertDeclarationContext) Comma() antlr.TerminalNode {
	return s.GetToken(CParserComma, 0)
}

func (s *StaticAssertDeclarationContext) RightParen() antlr.TerminalNode {
	return s.GetToken(CParserRightParen, 0)
}

func (s *StaticAssertDeclarationContext) Semi() antlr.TerminalNode {
	return s.GetToken(CParserSemi, 0)
}

func (s *StaticAssertDeclarationContext) AllStringLiteral() []antlr.TerminalNode {
	return s.GetTokens(CParserStringLiteral)
}

func (s *StaticAssertDeclarationContext) StringLiteral(i int) antlr.TerminalNode {
	return s.GetToken(CParserStringLiteral, i)
}

func (s *StaticAssertDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StaticAssertDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StaticAssertDeclarationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CParserVisitor:
		return t.VisitStaticAssertDeclaration(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CParser) StaticAssertDeclaration() (localctx IStaticAssertDeclarationContext) {
	this := p
	_ = this

	localctx = NewStaticAssertDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 120, CParserRULE_staticAssertDeclaration)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(956)
		p.Match(CParserStaticAssert)
	}
	{
		p.SetState(957)
		p.Match(CParserLeftParen)
	}
	{
		p.SetState(958)
		p.expression(0)
	}
	{
		p.SetState(959)
		p.Match(CParserComma)
	}
	p.SetState(961)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = _la == CParserStringLiteral {
		{
			p.SetState(960)
			p.Match(CParserStringLiteral)
		}

		p.SetState(963)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(965)
		p.Match(CParserRightParen)
	}
	{
		p.SetState(966)
		p.Match(CParserSemi)
	}

	return localctx
}

// IStatementContext is an interface to support dynamic dispatch.
type IStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsStatementContext differentiates from other interfaces.
	IsStatementContext()
}

type StatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStatementContext() *StatementContext {
	var p = new(StatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CParserRULE_statement
	return p
}

func (*StatementContext) IsStatementContext() {}

func NewStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StatementContext {
	var p = new(StatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CParserRULE_statement

	return p
}

func (s *StatementContext) GetParser() antlr.Parser { return s.parser }

func (s *StatementContext) Identifier() antlr.TerminalNode {
	return s.GetToken(CParserIdentifier, 0)
}

func (s *StatementContext) Colon() antlr.TerminalNode {
	return s.GetToken(CParserColon, 0)
}

func (s *StatementContext) Statement() IStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *StatementContext) CompoundStatement() ICompoundStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICompoundStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICompoundStatementContext)
}

func (s *StatementContext) ExpressionStatement() IExpressionStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionStatementContext)
}

func (s *StatementContext) StatementsExpression() IStatementsExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementsExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementsExpressionContext)
}

func (s *StatementContext) SelectionStatement() ISelectionStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelectionStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelectionStatementContext)
}

func (s *StatementContext) IterationStatement() IIterationStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIterationStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIterationStatementContext)
}

func (s *StatementContext) JumpStatement() IJumpStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IJumpStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IJumpStatementContext)
}

func (s *StatementContext) AsmStatement() IAsmStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAsmStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAsmStatementContext)
}

func (s *StatementContext) Semi() antlr.TerminalNode {
	return s.GetToken(CParserSemi, 0)
}

func (s *StatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CParserVisitor:
		return t.VisitStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CParser) Statement() (localctx IStatementContext) {
	this := p
	_ = this

	localctx = NewStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 122, CParserRULE_statement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(981)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 120, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(968)
			p.Match(CParserIdentifier)
		}
		{
			p.SetState(969)
			p.Match(CParserColon)
		}
		p.SetState(971)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 119, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(970)
				p.Statement()
			}

		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(973)
			p.CompoundStatement()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(974)
			p.ExpressionStatement()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(975)
			p.StatementsExpression()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(976)
			p.SelectionStatement()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(977)
			p.IterationStatement()
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(978)
			p.JumpStatement()
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(979)
			p.AsmStatement()
		}

	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(980)
			p.Match(CParserSemi)
		}

	}

	return localctx
}

// IAsmStatementContext is an interface to support dynamic dispatch.
type IAsmStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAsmStatementContext differentiates from other interfaces.
	IsAsmStatementContext()
}

type AsmStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAsmStatementContext() *AsmStatementContext {
	var p = new(AsmStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CParserRULE_asmStatement
	return p
}

func (*AsmStatementContext) IsAsmStatementContext() {}

func NewAsmStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AsmStatementContext {
	var p = new(AsmStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CParserRULE_asmStatement

	return p
}

func (s *AsmStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *AsmStatementContext) Asm() antlr.TerminalNode {
	return s.GetToken(CParserAsm, 0)
}

func (s *AsmStatementContext) LeftParen() antlr.TerminalNode {
	return s.GetToken(CParserLeftParen, 0)
}

func (s *AsmStatementContext) RightParen() antlr.TerminalNode {
	return s.GetToken(CParserRightParen, 0)
}

func (s *AsmStatementContext) Semi() antlr.TerminalNode {
	return s.GetToken(CParserSemi, 0)
}

func (s *AsmStatementContext) AllAsmExprList() []IAsmExprListContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAsmExprListContext); ok {
			len++
		}
	}

	tst := make([]IAsmExprListContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAsmExprListContext); ok {
			tst[i] = t.(IAsmExprListContext)
			i++
		}
	}

	return tst
}

func (s *AsmStatementContext) AsmExprList(i int) IAsmExprListContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAsmExprListContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAsmExprListContext)
}

func (s *AsmStatementContext) AllColon() []antlr.TerminalNode {
	return s.GetTokens(CParserColon)
}

func (s *AsmStatementContext) Colon(i int) antlr.TerminalNode {
	return s.GetToken(CParserColon, i)
}

func (s *AsmStatementContext) Volatile() antlr.TerminalNode {
	return s.GetToken(CParserVolatile, 0)
}

func (s *AsmStatementContext) Volatile__() antlr.TerminalNode {
	return s.GetToken(CParserVolatile__, 0)
}

func (s *AsmStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AsmStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AsmStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CParserVisitor:
		return t.VisitAsmStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CParser) AsmStatement() (localctx IAsmStatementContext) {
	this := p
	_ = this

	localctx = NewAsmStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 124, CParserRULE_asmStatement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(983)
		p.Match(CParserAsm)
	}
	p.SetState(985)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == CParserVolatile || _la == CParserVolatile__ {
		{
			p.SetState(984)
			_la = p.GetTokenStream().LA(1)

			if !(_la == CParserVolatile || _la == CParserVolatile__) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}
	{
		p.SetState(987)
		p.Match(CParserLeftParen)
	}
	p.SetState(989)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if (int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-576223327602051534) != 0 || (int64((_la-66)) & ^0x3f) == 0 && ((int64(1)<<(_la-66))&70308346200181) != 0 {
		{
			p.SetState(988)
			p.AsmExprList()
		}

	}
	p.SetState(1007)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == CParserColon {
		{
			p.SetState(991)
			p.Match(CParserColon)
		}
		p.SetState(993)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if (int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-576223327602051534) != 0 || (int64((_la-66)) & ^0x3f) == 0 && ((int64(1)<<(_la-66))&70308346200181) != 0 {
			{
				p.SetState(992)
				p.AsmExprList()
			}

		}
		p.SetState(1005)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == CParserColon {
			{
				p.SetState(995)
				p.Match(CParserColon)
			}
			p.SetState(997)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if (int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-576223327602051534) != 0 || (int64((_la-66)) & ^0x3f) == 0 && ((int64(1)<<(_la-66))&70308346200181) != 0 {
				{
					p.SetState(996)
					p.AsmExprList()
				}

			}
			p.SetState(1003)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == CParserColon {
				{
					p.SetState(999)
					p.Match(CParserColon)
				}
				p.SetState(1001)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)

				if (int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-576223327602051534) != 0 || (int64((_la-66)) & ^0x3f) == 0 && ((int64(1)<<(_la-66))&70308346200181) != 0 {
					{
						p.SetState(1000)
						p.AsmExprList()
					}

				}

			}

		}

	}
	{
		p.SetState(1009)
		p.Match(CParserRightParen)
	}
	{
		p.SetState(1010)
		p.Match(CParserSemi)
	}

	return localctx
}

// IAsmExprListContext is an interface to support dynamic dispatch.
type IAsmExprListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAsmExprListContext differentiates from other interfaces.
	IsAsmExprListContext()
}

type AsmExprListContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAsmExprListContext() *AsmExprListContext {
	var p = new(AsmExprListContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CParserRULE_asmExprList
	return p
}

func (*AsmExprListContext) IsAsmExprListContext() {}

func NewAsmExprListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AsmExprListContext {
	var p = new(AsmExprListContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CParserRULE_asmExprList

	return p
}

func (s *AsmExprListContext) GetParser() antlr.Parser { return s.parser }

func (s *AsmExprListContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *AsmExprListContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *AsmExprListContext) AllComma() []antlr.TerminalNode {
	return s.GetTokens(CParserComma)
}

func (s *AsmExprListContext) Comma(i int) antlr.TerminalNode {
	return s.GetToken(CParserComma, i)
}

func (s *AsmExprListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AsmExprListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AsmExprListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CParserVisitor:
		return t.VisitAsmExprList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CParser) AsmExprList() (localctx IAsmExprListContext) {
	this := p
	_ = this

	localctx = NewAsmExprListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 126, CParserRULE_asmExprList)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1012)
		p.expression(0)
	}
	p.SetState(1017)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == CParserComma {
		{
			p.SetState(1013)
			p.Match(CParserComma)
		}
		{
			p.SetState(1014)
			p.expression(0)
		}

		p.SetState(1019)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// ILabeledStatementContext is an interface to support dynamic dispatch.
type ILabeledStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLabeledStatementContext differentiates from other interfaces.
	IsLabeledStatementContext()
}

type LabeledStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLabeledStatementContext() *LabeledStatementContext {
	var p = new(LabeledStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CParserRULE_labeledStatement
	return p
}

func (*LabeledStatementContext) IsLabeledStatementContext() {}

func NewLabeledStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LabeledStatementContext {
	var p = new(LabeledStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CParserRULE_labeledStatement

	return p
}

func (s *LabeledStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *LabeledStatementContext) Case() antlr.TerminalNode {
	return s.GetToken(CParserCase, 0)
}

func (s *LabeledStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *LabeledStatementContext) Colon() antlr.TerminalNode {
	return s.GetToken(CParserColon, 0)
}

func (s *LabeledStatementContext) AllStatement() []IStatementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStatementContext); ok {
			len++
		}
	}

	tst := make([]IStatementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStatementContext); ok {
			tst[i] = t.(IStatementContext)
			i++
		}
	}

	return tst
}

func (s *LabeledStatementContext) Statement(i int) IStatementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *LabeledStatementContext) Default() antlr.TerminalNode {
	return s.GetToken(CParserDefault, 0)
}

func (s *LabeledStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LabeledStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LabeledStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CParserVisitor:
		return t.VisitLabeledStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CParser) LabeledStatement() (localctx ILabeledStatementContext) {
	this := p
	_ = this

	localctx = NewLabeledStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 128, CParserRULE_labeledStatement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1037)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case CParserCase:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1020)
			p.Match(CParserCase)
		}
		{
			p.SetState(1021)
			p.expression(0)
		}
		{
			p.SetState(1022)
			p.Match(CParserColon)
		}
		p.SetState(1026)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for (int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-3456367233649639100) != 0 || (int64((_la-66)) & ^0x3f) == 0 && ((int64(1)<<(_la-66))&489223619077) != 0 {
			{
				p.SetState(1023)
				p.Statement()
			}

			p.SetState(1028)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	case CParserDefault:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1029)
			p.Match(CParserDefault)
		}
		{
			p.SetState(1030)
			p.Match(CParserColon)
		}
		p.SetState(1034)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for (int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-3456367233649639100) != 0 || (int64((_la-66)) & ^0x3f) == 0 && ((int64(1)<<(_la-66))&489223619077) != 0 {
			{
				p.SetState(1031)
				p.Statement()
			}

			p.SetState(1036)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ICompoundStatementContext is an interface to support dynamic dispatch.
type ICompoundStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCompoundStatementContext differentiates from other interfaces.
	IsCompoundStatementContext()
}

type CompoundStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCompoundStatementContext() *CompoundStatementContext {
	var p = new(CompoundStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CParserRULE_compoundStatement
	return p
}

func (*CompoundStatementContext) IsCompoundStatementContext() {}

func NewCompoundStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CompoundStatementContext {
	var p = new(CompoundStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CParserRULE_compoundStatement

	return p
}

func (s *CompoundStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *CompoundStatementContext) LeftBrace() antlr.TerminalNode {
	return s.GetToken(CParserLeftBrace, 0)
}

func (s *CompoundStatementContext) RightBrace() antlr.TerminalNode {
	return s.GetToken(CParserRightBrace, 0)
}

func (s *CompoundStatementContext) BlockItemList() IBlockItemListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBlockItemListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBlockItemListContext)
}

func (s *CompoundStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CompoundStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CompoundStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CParserVisitor:
		return t.VisitCompoundStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CParser) CompoundStatement() (localctx ICompoundStatementContext) {
	this := p
	_ = this

	localctx = NewCompoundStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 130, CParserRULE_compoundStatement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1039)
		p.Match(CParserLeftBrace)
	}
	p.SetState(1041)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if (int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-3456240035123169418) != 0 || (int64((_la-66)) & ^0x3f) == 0 && ((int64(1)<<(_la-66))&70308480418309) != 0 {
		{
			p.SetState(1040)
			p.BlockItemList()
		}

	}
	{
		p.SetState(1043)
		p.Match(CParserRightBrace)
	}

	return localctx
}

// IBlockItemListContext is an interface to support dynamic dispatch.
type IBlockItemListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsBlockItemListContext differentiates from other interfaces.
	IsBlockItemListContext()
}

type BlockItemListContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBlockItemListContext() *BlockItemListContext {
	var p = new(BlockItemListContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CParserRULE_blockItemList
	return p
}

func (*BlockItemListContext) IsBlockItemListContext() {}

func NewBlockItemListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BlockItemListContext {
	var p = new(BlockItemListContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CParserRULE_blockItemList

	return p
}

func (s *BlockItemListContext) GetParser() antlr.Parser { return s.parser }

func (s *BlockItemListContext) AllBlockItem() []IBlockItemContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IBlockItemContext); ok {
			len++
		}
	}

	tst := make([]IBlockItemContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IBlockItemContext); ok {
			tst[i] = t.(IBlockItemContext)
			i++
		}
	}

	return tst
}

func (s *BlockItemListContext) BlockItem(i int) IBlockItemContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBlockItemContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBlockItemContext)
}

func (s *BlockItemListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BlockItemListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BlockItemListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CParserVisitor:
		return t.VisitBlockItemList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CParser) BlockItemList() (localctx IBlockItemListContext) {
	this := p
	_ = this

	localctx = NewBlockItemListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 132, CParserRULE_blockItemList)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1046)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = (int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-3456240035123169418) != 0 || (int64((_la-66)) & ^0x3f) == 0 && ((int64(1)<<(_la-66))&70308480418309) != 0 {
		{
			p.SetState(1045)
			p.BlockItem()
		}

		p.SetState(1048)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IBlockItemContext is an interface to support dynamic dispatch.
type IBlockItemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsBlockItemContext differentiates from other interfaces.
	IsBlockItemContext()
}

type BlockItemContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBlockItemContext() *BlockItemContext {
	var p = new(BlockItemContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CParserRULE_blockItem
	return p
}

func (*BlockItemContext) IsBlockItemContext() {}

func NewBlockItemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BlockItemContext {
	var p = new(BlockItemContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CParserRULE_blockItem

	return p
}

func (s *BlockItemContext) GetParser() antlr.Parser { return s.parser }

func (s *BlockItemContext) Statement() IStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *BlockItemContext) Declaration() IDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDeclarationContext)
}

func (s *BlockItemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BlockItemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BlockItemContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CParserVisitor:
		return t.VisitBlockItem(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CParser) BlockItem() (localctx IBlockItemContext) {
	this := p
	_ = this

	localctx = NewBlockItemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 134, CParserRULE_blockItem)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1052)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 135, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1050)
			p.Statement()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1051)
			p.Declaration()
		}

	}

	return localctx
}

// IExpressionStatementContext is an interface to support dynamic dispatch.
type IExpressionStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExpressionStatementContext differentiates from other interfaces.
	IsExpressionStatementContext()
}

type ExpressionStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpressionStatementContext() *ExpressionStatementContext {
	var p = new(ExpressionStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CParserRULE_expressionStatement
	return p
}

func (*ExpressionStatementContext) IsExpressionStatementContext() {}

func NewExpressionStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExpressionStatementContext {
	var p = new(ExpressionStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CParserRULE_expressionStatement

	return p
}

func (s *ExpressionStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ExpressionStatementContext) AssignmentExpressions() IAssignmentExpressionsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAssignmentExpressionsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAssignmentExpressionsContext)
}

func (s *ExpressionStatementContext) Semi() antlr.TerminalNode {
	return s.GetToken(CParserSemi, 0)
}

func (s *ExpressionStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExpressionStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExpressionStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CParserVisitor:
		return t.VisitExpressionStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CParser) ExpressionStatement() (localctx IExpressionStatementContext) {
	this := p
	_ = this

	localctx = NewExpressionStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 136, CParserRULE_expressionStatement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1054)
		p.AssignmentExpressions()
	}
	{
		p.SetState(1055)
		p.Match(CParserSemi)
	}

	return localctx
}

// ISelectionStatementContext is an interface to support dynamic dispatch.
type ISelectionStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSelectionStatementContext differentiates from other interfaces.
	IsSelectionStatementContext()
}

type SelectionStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySelectionStatementContext() *SelectionStatementContext {
	var p = new(SelectionStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CParserRULE_selectionStatement
	return p
}

func (*SelectionStatementContext) IsSelectionStatementContext() {}

func NewSelectionStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SelectionStatementContext {
	var p = new(SelectionStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CParserRULE_selectionStatement

	return p
}

func (s *SelectionStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *SelectionStatementContext) If() antlr.TerminalNode {
	return s.GetToken(CParserIf, 0)
}

func (s *SelectionStatementContext) LeftParen() antlr.TerminalNode {
	return s.GetToken(CParserLeftParen, 0)
}

func (s *SelectionStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *SelectionStatementContext) RightParen() antlr.TerminalNode {
	return s.GetToken(CParserRightParen, 0)
}

func (s *SelectionStatementContext) AllStatement() []IStatementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStatementContext); ok {
			len++
		}
	}

	tst := make([]IStatementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStatementContext); ok {
			tst[i] = t.(IStatementContext)
			i++
		}
	}

	return tst
}

func (s *SelectionStatementContext) Statement(i int) IStatementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *SelectionStatementContext) Else() antlr.TerminalNode {
	return s.GetToken(CParserElse, 0)
}

func (s *SelectionStatementContext) Switch() antlr.TerminalNode {
	return s.GetToken(CParserSwitch, 0)
}

func (s *SelectionStatementContext) LeftBrace() antlr.TerminalNode {
	return s.GetToken(CParserLeftBrace, 0)
}

func (s *SelectionStatementContext) RightBrace() antlr.TerminalNode {
	return s.GetToken(CParserRightBrace, 0)
}

func (s *SelectionStatementContext) AllLabeledStatement() []ILabeledStatementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ILabeledStatementContext); ok {
			len++
		}
	}

	tst := make([]ILabeledStatementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ILabeledStatementContext); ok {
			tst[i] = t.(ILabeledStatementContext)
			i++
		}
	}

	return tst
}

func (s *SelectionStatementContext) LabeledStatement(i int) ILabeledStatementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILabeledStatementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILabeledStatementContext)
}

func (s *SelectionStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SelectionStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SelectionStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CParserVisitor:
		return t.VisitSelectionStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CParser) SelectionStatement() (localctx ISelectionStatementContext) {
	this := p
	_ = this

	localctx = NewSelectionStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 138, CParserRULE_selectionStatement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1079)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case CParserIf:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1057)
			p.Match(CParserIf)
		}
		{
			p.SetState(1058)
			p.Match(CParserLeftParen)
		}
		{
			p.SetState(1059)
			p.expression(0)
		}
		{
			p.SetState(1060)
			p.Match(CParserRightParen)
		}
		{
			p.SetState(1061)
			p.Statement()
		}
		p.SetState(1064)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 136, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1062)
				p.Match(CParserElse)
			}
			{
				p.SetState(1063)
				p.Statement()
			}

		}

	case CParserSwitch:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1066)
			p.Match(CParserSwitch)
		}
		{
			p.SetState(1067)
			p.Match(CParserLeftParen)
		}
		{
			p.SetState(1068)
			p.expression(0)
		}
		{
			p.SetState(1069)
			p.Match(CParserRightParen)
		}
		{
			p.SetState(1070)
			p.Match(CParserLeftBrace)
		}
		p.SetState(1074)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == CParserCase || _la == CParserDefault {
			{
				p.SetState(1071)
				p.LabeledStatement()
			}

			p.SetState(1076)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1077)
			p.Match(CParserRightBrace)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IIterationStatementContext is an interface to support dynamic dispatch.
type IIterationStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsIterationStatementContext differentiates from other interfaces.
	IsIterationStatementContext()
}

type IterationStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIterationStatementContext() *IterationStatementContext {
	var p = new(IterationStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CParserRULE_iterationStatement
	return p
}

func (*IterationStatementContext) IsIterationStatementContext() {}

func NewIterationStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IterationStatementContext {
	var p = new(IterationStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CParserRULE_iterationStatement

	return p
}

func (s *IterationStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *IterationStatementContext) While() antlr.TerminalNode {
	return s.GetToken(CParserWhile, 0)
}

func (s *IterationStatementContext) LeftParen() antlr.TerminalNode {
	return s.GetToken(CParserLeftParen, 0)
}

func (s *IterationStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *IterationStatementContext) RightParen() antlr.TerminalNode {
	return s.GetToken(CParserRightParen, 0)
}

func (s *IterationStatementContext) Statement() IStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *IterationStatementContext) Semi() antlr.TerminalNode {
	return s.GetToken(CParserSemi, 0)
}

func (s *IterationStatementContext) Do() antlr.TerminalNode {
	return s.GetToken(CParserDo, 0)
}

func (s *IterationStatementContext) For() antlr.TerminalNode {
	return s.GetToken(CParserFor, 0)
}

func (s *IterationStatementContext) ForCondition() IForConditionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IForConditionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IForConditionContext)
}

func (s *IterationStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IterationStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IterationStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CParserVisitor:
		return t.VisitIterationStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CParser) IterationStatement() (localctx IIterationStatementContext) {
	this := p
	_ = this

	localctx = NewIterationStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 140, CParserRULE_iterationStatement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1105)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case CParserWhile:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1081)
			p.Match(CParserWhile)
		}
		{
			p.SetState(1082)
			p.Match(CParserLeftParen)
		}
		{
			p.SetState(1083)
			p.expression(0)
		}
		{
			p.SetState(1084)
			p.Match(CParserRightParen)
		}
		p.SetState(1086)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 139, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1085)
				p.Match(CParserSemi)
			}

		}
		{
			p.SetState(1088)
			p.Statement()
		}

	case CParserDo:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1090)
			p.Match(CParserDo)
		}
		{
			p.SetState(1091)
			p.Statement()
		}
		{
			p.SetState(1092)
			p.Match(CParserWhile)
		}
		{
			p.SetState(1093)
			p.Match(CParserLeftParen)
		}
		{
			p.SetState(1094)
			p.expression(0)
		}
		{
			p.SetState(1095)
			p.Match(CParserRightParen)
		}
		p.SetState(1097)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 140, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1096)
				p.Match(CParserSemi)
			}

		}

	case CParserFor:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1099)
			p.Match(CParserFor)
		}
		{
			p.SetState(1100)
			p.Match(CParserLeftParen)
		}
		{
			p.SetState(1101)
			p.ForCondition()
		}
		{
			p.SetState(1102)
			p.Match(CParserRightParen)
		}
		{
			p.SetState(1103)
			p.Statement()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IForConditionContext is an interface to support dynamic dispatch.
type IForConditionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsForConditionContext differentiates from other interfaces.
	IsForConditionContext()
}

type ForConditionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyForConditionContext() *ForConditionContext {
	var p = new(ForConditionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CParserRULE_forCondition
	return p
}

func (*ForConditionContext) IsForConditionContext() {}

func NewForConditionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ForConditionContext {
	var p = new(ForConditionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CParserRULE_forCondition

	return p
}

func (s *ForConditionContext) GetParser() antlr.Parser { return s.parser }

func (s *ForConditionContext) AllSemi() []antlr.TerminalNode {
	return s.GetTokens(CParserSemi)
}

func (s *ForConditionContext) Semi(i int) antlr.TerminalNode {
	return s.GetToken(CParserSemi, i)
}

func (s *ForConditionContext) ForDeclarations() IForDeclarationsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IForDeclarationsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IForDeclarationsContext)
}

func (s *ForConditionContext) AllForExpression() []IForExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IForExpressionContext); ok {
			len++
		}
	}

	tst := make([]IForExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IForExpressionContext); ok {
			tst[i] = t.(IForExpressionContext)
			i++
		}
	}

	return tst
}

func (s *ForConditionContext) ForExpression(i int) IForExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IForExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IForExpressionContext)
}

func (s *ForConditionContext) AssignmentExpressions() IAssignmentExpressionsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAssignmentExpressionsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAssignmentExpressionsContext)
}

func (s *ForConditionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ForConditionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ForConditionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CParserVisitor:
		return t.VisitForCondition(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CParser) ForCondition() (localctx IForConditionContext) {
	this := p
	_ = this

	localctx = NewForConditionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 142, CParserRULE_forCondition)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1111)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 143, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(1107)
			p.ForDeclarations()
		}

	case 2:
		p.SetState(1109)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if (int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-3458619103273549824) != 0 || (int64((_la-66)) & ^0x3f) == 0 && ((int64(1)<<(_la-66))&489089400837) != 0 {
			{
				p.SetState(1108)
				p.AssignmentExpressions()
			}

		}

	}
	{
		p.SetState(1113)
		p.Match(CParserSemi)
	}
	p.SetState(1115)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if (int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-576223327602051534) != 0 || (int64((_la-66)) & ^0x3f) == 0 && ((int64(1)<<(_la-66))&70308346200181) != 0 {
		{
			p.SetState(1114)
			p.ForExpression()
		}

	}
	{
		p.SetState(1117)
		p.Match(CParserSemi)
	}
	p.SetState(1119)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if (int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-576223327602051534) != 0 || (int64((_la-66)) & ^0x3f) == 0 && ((int64(1)<<(_la-66))&70308346200181) != 0 {
		{
			p.SetState(1118)
			p.ForExpression()
		}

	}

	return localctx
}

// IAssignmentExpressionsContext is an interface to support dynamic dispatch.
type IAssignmentExpressionsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAssignmentExpressionsContext differentiates from other interfaces.
	IsAssignmentExpressionsContext()
}

type AssignmentExpressionsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAssignmentExpressionsContext() *AssignmentExpressionsContext {
	var p = new(AssignmentExpressionsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CParserRULE_assignmentExpressions
	return p
}

func (*AssignmentExpressionsContext) IsAssignmentExpressionsContext() {}

func NewAssignmentExpressionsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AssignmentExpressionsContext {
	var p = new(AssignmentExpressionsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CParserRULE_assignmentExpressions

	return p
}

func (s *AssignmentExpressionsContext) GetParser() antlr.Parser { return s.parser }

func (s *AssignmentExpressionsContext) AllAssignmentExpression() []IAssignmentExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAssignmentExpressionContext); ok {
			len++
		}
	}

	tst := make([]IAssignmentExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAssignmentExpressionContext); ok {
			tst[i] = t.(IAssignmentExpressionContext)
			i++
		}
	}

	return tst
}

func (s *AssignmentExpressionsContext) AssignmentExpression(i int) IAssignmentExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAssignmentExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAssignmentExpressionContext)
}

func (s *AssignmentExpressionsContext) AllComma() []antlr.TerminalNode {
	return s.GetTokens(CParserComma)
}

func (s *AssignmentExpressionsContext) Comma(i int) antlr.TerminalNode {
	return s.GetToken(CParserComma, i)
}

func (s *AssignmentExpressionsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AssignmentExpressionsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AssignmentExpressionsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CParserVisitor:
		return t.VisitAssignmentExpressions(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CParser) AssignmentExpressions() (localctx IAssignmentExpressionsContext) {
	this := p
	_ = this

	localctx = NewAssignmentExpressionsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 144, CParserRULE_assignmentExpressions)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1121)
		p.AssignmentExpression()
	}
	p.SetState(1126)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == CParserComma {
		{
			p.SetState(1122)
			p.Match(CParserComma)
		}
		{
			p.SetState(1123)
			p.AssignmentExpression()
		}

		p.SetState(1128)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IForDeclarationsContext is an interface to support dynamic dispatch.
type IForDeclarationsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsForDeclarationsContext differentiates from other interfaces.
	IsForDeclarationsContext()
}

type ForDeclarationsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyForDeclarationsContext() *ForDeclarationsContext {
	var p = new(ForDeclarationsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CParserRULE_forDeclarations
	return p
}

func (*ForDeclarationsContext) IsForDeclarationsContext() {}

func NewForDeclarationsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ForDeclarationsContext {
	var p = new(ForDeclarationsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CParserRULE_forDeclarations

	return p
}

func (s *ForDeclarationsContext) GetParser() antlr.Parser { return s.parser }

func (s *ForDeclarationsContext) AllForDeclaration() []IForDeclarationContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IForDeclarationContext); ok {
			len++
		}
	}

	tst := make([]IForDeclarationContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IForDeclarationContext); ok {
			tst[i] = t.(IForDeclarationContext)
			i++
		}
	}

	return tst
}

func (s *ForDeclarationsContext) ForDeclaration(i int) IForDeclarationContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IForDeclarationContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IForDeclarationContext)
}

func (s *ForDeclarationsContext) AllComma() []antlr.TerminalNode {
	return s.GetTokens(CParserComma)
}

func (s *ForDeclarationsContext) Comma(i int) antlr.TerminalNode {
	return s.GetToken(CParserComma, i)
}

func (s *ForDeclarationsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ForDeclarationsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ForDeclarationsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CParserVisitor:
		return t.VisitForDeclarations(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CParser) ForDeclarations() (localctx IForDeclarationsContext) {
	this := p
	_ = this

	localctx = NewForDeclarationsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 146, CParserRULE_forDeclarations)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1129)
		p.ForDeclaration()
	}
	p.SetState(1134)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == CParserComma {
		{
			p.SetState(1130)
			p.Match(CParserComma)
		}
		{
			p.SetState(1131)
			p.ForDeclaration()
		}

		p.SetState(1136)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IForDeclarationContext is an interface to support dynamic dispatch.
type IForDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsForDeclarationContext differentiates from other interfaces.
	IsForDeclarationContext()
}

type ForDeclarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyForDeclarationContext() *ForDeclarationContext {
	var p = new(ForDeclarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CParserRULE_forDeclaration
	return p
}

func (*ForDeclarationContext) IsForDeclarationContext() {}

func NewForDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ForDeclarationContext {
	var p = new(ForDeclarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CParserRULE_forDeclaration

	return p
}

func (s *ForDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *ForDeclarationContext) DeclarationSpecifier() IDeclarationSpecifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDeclarationSpecifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDeclarationSpecifierContext)
}

func (s *ForDeclarationContext) InitDeclaratorList() IInitDeclaratorListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInitDeclaratorListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInitDeclaratorListContext)
}

func (s *ForDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ForDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ForDeclarationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CParserVisitor:
		return t.VisitForDeclaration(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CParser) ForDeclaration() (localctx IForDeclarationContext) {
	this := p
	_ = this

	localctx = NewForDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 148, CParserRULE_forDeclaration)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1137)
		p.DeclarationSpecifier()
	}
	p.SetState(1139)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == CParserLeftParen || _la == CParserStar || (int64((_la-70)) & ^0x3f) == 0 && ((int64(1)<<(_la-70))&137438987026433) != 0 {
		{
			p.SetState(1138)
			p.InitDeclaratorList()
		}

	}

	return localctx
}

// IForExpressionContext is an interface to support dynamic dispatch.
type IForExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsForExpressionContext differentiates from other interfaces.
	IsForExpressionContext()
}

type ForExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyForExpressionContext() *ForExpressionContext {
	var p = new(ForExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CParserRULE_forExpression
	return p
}

func (*ForExpressionContext) IsForExpressionContext() {}

func NewForExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ForExpressionContext {
	var p = new(ForExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CParserRULE_forExpression

	return p
}

func (s *ForExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *ForExpressionContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *ForExpressionContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ForExpressionContext) AllComma() []antlr.TerminalNode {
	return s.GetTokens(CParserComma)
}

func (s *ForExpressionContext) Comma(i int) antlr.TerminalNode {
	return s.GetToken(CParserComma, i)
}

func (s *ForExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ForExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ForExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CParserVisitor:
		return t.VisitForExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CParser) ForExpression() (localctx IForExpressionContext) {
	this := p
	_ = this

	localctx = NewForExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 150, CParserRULE_forExpression)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1141)
		p.expression(0)
	}
	p.SetState(1146)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == CParserComma {
		{
			p.SetState(1142)
			p.Match(CParserComma)
		}
		{
			p.SetState(1143)
			p.expression(0)
		}

		p.SetState(1148)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IJumpStatementContext is an interface to support dynamic dispatch.
type IJumpStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsJumpStatementContext differentiates from other interfaces.
	IsJumpStatementContext()
}

type JumpStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyJumpStatementContext() *JumpStatementContext {
	var p = new(JumpStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CParserRULE_jumpStatement
	return p
}

func (*JumpStatementContext) IsJumpStatementContext() {}

func NewJumpStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *JumpStatementContext {
	var p = new(JumpStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CParserRULE_jumpStatement

	return p
}

func (s *JumpStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *JumpStatementContext) Semi() antlr.TerminalNode {
	return s.GetToken(CParserSemi, 0)
}

func (s *JumpStatementContext) Goto() antlr.TerminalNode {
	return s.GetToken(CParserGoto, 0)
}

func (s *JumpStatementContext) Identifier() antlr.TerminalNode {
	return s.GetToken(CParserIdentifier, 0)
}

func (s *JumpStatementContext) Continue() antlr.TerminalNode {
	return s.GetToken(CParserContinue, 0)
}

func (s *JumpStatementContext) Break() antlr.TerminalNode {
	return s.GetToken(CParserBreak, 0)
}

func (s *JumpStatementContext) Return() antlr.TerminalNode {
	return s.GetToken(CParserReturn, 0)
}

func (s *JumpStatementContext) AllStar() []antlr.TerminalNode {
	return s.GetTokens(CParserStar)
}

func (s *JumpStatementContext) Star(i int) antlr.TerminalNode {
	return s.GetToken(CParserStar, i)
}

func (s *JumpStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *JumpStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *JumpStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *JumpStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CParserVisitor:
		return t.VisitJumpStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CParser) JumpStatement() (localctx IJumpStatementContext) {
	this := p
	_ = this

	localctx = NewJumpStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 152, CParserRULE_jumpStatement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1163)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case CParserGoto:
		{
			p.SetState(1149)
			p.Match(CParserGoto)
		}
		p.SetState(1153)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == CParserStar {
			{
				p.SetState(1150)
				p.Match(CParserStar)
			}

			p.SetState(1155)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1156)
			p.Match(CParserIdentifier)
		}

	case CParserContinue:
		{
			p.SetState(1157)
			p.Match(CParserContinue)
		}

	case CParserBreak:
		{
			p.SetState(1158)
			p.Match(CParserBreak)
		}

	case CParserReturn:
		{
			p.SetState(1159)
			p.Match(CParserReturn)
		}
		p.SetState(1161)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if (int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-576223327602051534) != 0 || (int64((_la-66)) & ^0x3f) == 0 && ((int64(1)<<(_la-66))&70308346200181) != 0 {
			{
				p.SetState(1160)
				p.expression(0)
			}

		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}
	{
		p.SetState(1165)
		p.Match(CParserSemi)
	}

	return localctx
}

// ICompilationUnitContext is an interface to support dynamic dispatch.
type ICompilationUnitContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCompilationUnitContext differentiates from other interfaces.
	IsCompilationUnitContext()
}

type CompilationUnitContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCompilationUnitContext() *CompilationUnitContext {
	var p = new(CompilationUnitContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CParserRULE_compilationUnit
	return p
}

func (*CompilationUnitContext) IsCompilationUnitContext() {}

func NewCompilationUnitContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CompilationUnitContext {
	var p = new(CompilationUnitContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CParserRULE_compilationUnit

	return p
}

func (s *CompilationUnitContext) GetParser() antlr.Parser { return s.parser }

func (s *CompilationUnitContext) EOF() antlr.TerminalNode {
	return s.GetToken(CParserEOF, 0)
}

func (s *CompilationUnitContext) TranslationUnit() ITranslationUnitContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITranslationUnitContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITranslationUnitContext)
}

func (s *CompilationUnitContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CompilationUnitContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CompilationUnitContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CParserVisitor:
		return t.VisitCompilationUnit(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CParser) CompilationUnit() (localctx ICompilationUnitContext) {
	this := p
	_ = this

	localctx = NewCompilationUnitContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 154, CParserRULE_compilationUnit)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1168)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if (int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-9223104100839950798) != 0 || (int64((_la-70)) & ^0x3f) == 0 && ((int64(1)<<(_la-70))&140707473915937) != 0 {
		{
			p.SetState(1167)
			p.TranslationUnit()
		}

	}
	{
		p.SetState(1170)
		p.Match(CParserEOF)
	}

	return localctx
}

// ITranslationUnitContext is an interface to support dynamic dispatch.
type ITranslationUnitContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTranslationUnitContext differentiates from other interfaces.
	IsTranslationUnitContext()
}

type TranslationUnitContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTranslationUnitContext() *TranslationUnitContext {
	var p = new(TranslationUnitContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CParserRULE_translationUnit
	return p
}

func (*TranslationUnitContext) IsTranslationUnitContext() {}

func NewTranslationUnitContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TranslationUnitContext {
	var p = new(TranslationUnitContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CParserRULE_translationUnit

	return p
}

func (s *TranslationUnitContext) GetParser() antlr.Parser { return s.parser }

func (s *TranslationUnitContext) AllExternalDeclaration() []IExternalDeclarationContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExternalDeclarationContext); ok {
			len++
		}
	}

	tst := make([]IExternalDeclarationContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExternalDeclarationContext); ok {
			tst[i] = t.(IExternalDeclarationContext)
			i++
		}
	}

	return tst
}

func (s *TranslationUnitContext) ExternalDeclaration(i int) IExternalDeclarationContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExternalDeclarationContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExternalDeclarationContext)
}

func (s *TranslationUnitContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TranslationUnitContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TranslationUnitContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CParserVisitor:
		return t.VisitTranslationUnit(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CParser) TranslationUnit() (localctx ITranslationUnitContext) {
	this := p
	_ = this

	localctx = NewTranslationUnitContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 156, CParserRULE_translationUnit)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1173)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = (int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-9223104100839950798) != 0 || (int64((_la-70)) & ^0x3f) == 0 && ((int64(1)<<(_la-70))&140707473915937) != 0 {
		{
			p.SetState(1172)
			p.ExternalDeclaration()
		}

		p.SetState(1175)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IExternalDeclarationContext is an interface to support dynamic dispatch.
type IExternalDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExternalDeclarationContext differentiates from other interfaces.
	IsExternalDeclarationContext()
}

type ExternalDeclarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExternalDeclarationContext() *ExternalDeclarationContext {
	var p = new(ExternalDeclarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CParserRULE_externalDeclaration
	return p
}

func (*ExternalDeclarationContext) IsExternalDeclarationContext() {}

func NewExternalDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExternalDeclarationContext {
	var p = new(ExternalDeclarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CParserRULE_externalDeclaration

	return p
}

func (s *ExternalDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *ExternalDeclarationContext) DeclarationSpecifier() IDeclarationSpecifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDeclarationSpecifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDeclarationSpecifierContext)
}

func (s *ExternalDeclarationContext) FunctionDefinition() IFunctionDefinitionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionDefinitionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionDefinitionContext)
}

func (s *ExternalDeclarationContext) Declaration() IDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDeclarationContext)
}

func (s *ExternalDeclarationContext) Semi() antlr.TerminalNode {
	return s.GetToken(CParserSemi, 0)
}

func (s *ExternalDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExternalDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExternalDeclarationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CParserVisitor:
		return t.VisitExternalDeclaration(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CParser) ExternalDeclaration() (localctx IExternalDeclarationContext) {
	this := p
	_ = this

	localctx = NewExternalDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 158, CParserRULE_externalDeclaration)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1181)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 155, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1177)
			p.DeclarationSpecifier()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1178)
			p.FunctionDefinition()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1179)
			p.Declaration()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1180)
			p.Match(CParserSemi)
		}

	}

	return localctx
}

// IFunctionDefinitionContext is an interface to support dynamic dispatch.
type IFunctionDefinitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFunctionDefinitionContext differentiates from other interfaces.
	IsFunctionDefinitionContext()
}

type FunctionDefinitionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunctionDefinitionContext() *FunctionDefinitionContext {
	var p = new(FunctionDefinitionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CParserRULE_functionDefinition
	return p
}

func (*FunctionDefinitionContext) IsFunctionDefinitionContext() {}

func NewFunctionDefinitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FunctionDefinitionContext {
	var p = new(FunctionDefinitionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CParserRULE_functionDefinition

	return p
}

func (s *FunctionDefinitionContext) GetParser() antlr.Parser { return s.parser }

func (s *FunctionDefinitionContext) Declarator() IDeclaratorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDeclaratorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDeclaratorContext)
}

func (s *FunctionDefinitionContext) DeclarationSpecifier() IDeclarationSpecifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDeclarationSpecifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDeclarationSpecifierContext)
}

func (s *FunctionDefinitionContext) DeclarationList() IDeclarationListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDeclarationListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDeclarationListContext)
}

func (s *FunctionDefinitionContext) CompoundStatement() ICompoundStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICompoundStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICompoundStatementContext)
}

func (s *FunctionDefinitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FunctionDefinitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FunctionDefinitionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CParserVisitor:
		return t.VisitFunctionDefinition(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CParser) FunctionDefinition() (localctx IFunctionDefinitionContext) {
	this := p
	_ = this

	localctx = NewFunctionDefinitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 160, CParserRULE_functionDefinition)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1184)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 156, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1183)
			p.DeclarationSpecifier()
		}

	}
	{
		p.SetState(1186)
		p.Declarator()
	}
	p.SetState(1188)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 157, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1187)
			p.DeclarationList()
		}

	}
	p.SetState(1191)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == CParserLeftBrace {
		{
			p.SetState(1190)
			p.CompoundStatement()
		}

	}

	return localctx
}

// IDeclarationListContext is an interface to support dynamic dispatch.
type IDeclarationListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDeclarationListContext differentiates from other interfaces.
	IsDeclarationListContext()
}

type DeclarationListContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDeclarationListContext() *DeclarationListContext {
	var p = new(DeclarationListContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CParserRULE_declarationList
	return p
}

func (*DeclarationListContext) IsDeclarationListContext() {}

func NewDeclarationListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DeclarationListContext {
	var p = new(DeclarationListContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CParserRULE_declarationList

	return p
}

func (s *DeclarationListContext) GetParser() antlr.Parser { return s.parser }

func (s *DeclarationListContext) AllDeclaration() []IDeclarationContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IDeclarationContext); ok {
			len++
		}
	}

	tst := make([]IDeclarationContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IDeclarationContext); ok {
			tst[i] = t.(IDeclarationContext)
			i++
		}
	}

	return tst
}

func (s *DeclarationListContext) Declaration(i int) IDeclarationContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDeclarationContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDeclarationContext)
}

func (s *DeclarationListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DeclarationListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DeclarationListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CParserVisitor:
		return t.VisitDeclarationList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CParser) DeclarationList() (localctx IDeclarationListContext) {
	this := p
	_ = this

	localctx = NewDeclarationListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 162, CParserRULE_declarationList)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1194)
	p.GetErrorHandler().Sync(p)
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			{
				p.SetState(1193)
				p.Declaration()
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(1196)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 159, p.GetParserRuleContext())
	}

	return localctx
}

func (p *CParser) Sempred(localctx antlr.RuleContext, ruleIndex, predIndex int) bool {
	switch ruleIndex {
	case 4:
		var t *PostfixExpressionContext = nil
		if localctx != nil {
			t = localctx.(*PostfixExpressionContext)
		}
		return p.PostfixExpression_Sempred(t, predIndex)

	case 5:
		var t *PostfixExpressionLvalueContext = nil
		if localctx != nil {
			t = localctx.(*PostfixExpressionLvalueContext)
		}
		return p.PostfixExpressionLvalue_Sempred(t, predIndex)

	case 14:
		var t *ExpressionContext = nil
		if localctx != nil {
			t = localctx.(*ExpressionContext)
		}
		return p.Expression_Sempred(t, predIndex)

	case 38:
		var t *DirectDeclaratorContext = nil
		if localctx != nil {
			t = localctx.(*DirectDeclaratorContext)
		}
		return p.DirectDeclarator_Sempred(t, predIndex)

	case 51:
		var t *TypeNameContext = nil
		if localctx != nil {
			t = localctx.(*TypeNameContext)
		}
		return p.TypeName_Sempred(t, predIndex)

	case 53:
		var t *DirectAbstractDeclaratorContext = nil
		if localctx != nil {
			t = localctx.(*DirectAbstractDeclaratorContext)
		}
		return p.DirectAbstractDeclarator_Sempred(t, predIndex)

	default:
		panic("No predicate with index: " + fmt.Sprint(ruleIndex))
	}
}

func (p *CParser) PostfixExpression_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	this := p
	_ = this

	switch predIndex {
	case 0:
		return p.Precpred(p.GetParserRuleContext(), 5)

	case 1:
		return p.Precpred(p.GetParserRuleContext(), 4)

	case 2:
		return p.Precpred(p.GetParserRuleContext(), 3)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *CParser) PostfixExpressionLvalue_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	this := p
	_ = this

	switch predIndex {
	case 3:
		return p.Precpred(p.GetParserRuleContext(), 2)

	case 4:
		return p.Precpred(p.GetParserRuleContext(), 1)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *CParser) Expression_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	this := p
	_ = this

	switch predIndex {
	case 5:
		return p.Precpred(p.GetParserRuleContext(), 11)

	case 6:
		return p.Precpred(p.GetParserRuleContext(), 10)

	case 7:
		return p.Precpred(p.GetParserRuleContext(), 9)

	case 8:
		return p.Precpred(p.GetParserRuleContext(), 8)

	case 9:
		return p.Precpred(p.GetParserRuleContext(), 7)

	case 10:
		return p.Precpred(p.GetParserRuleContext(), 5)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *CParser) DirectDeclarator_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	this := p
	_ = this

	switch predIndex {
	case 11:
		return p.Precpred(p.GetParserRuleContext(), 9)

	case 12:
		return p.Precpred(p.GetParserRuleContext(), 8)

	case 13:
		return p.Precpred(p.GetParserRuleContext(), 7)

	case 14:
		return p.Precpred(p.GetParserRuleContext(), 6)

	case 15:
		return p.Precpred(p.GetParserRuleContext(), 5)

	case 16:
		return p.Precpred(p.GetParserRuleContext(), 4)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *CParser) TypeName_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	this := p
	_ = this

	switch predIndex {
	case 17:
		return p.Precpred(p.GetParserRuleContext(), 1)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *CParser) DirectAbstractDeclarator_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	this := p
	_ = this

	switch predIndex {
	case 18:
		return p.Precpred(p.GetParserRuleContext(), 5)

	case 19:
		return p.Precpred(p.GetParserRuleContext(), 4)

	case 20:
		return p.Precpred(p.GetParserRuleContext(), 3)

	case 21:
		return p.Precpred(p.GetParserRuleContext(), 2)

	case 22:
		return p.Precpred(p.GetParserRuleContext(), 1)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}
