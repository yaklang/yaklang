// Code generated from java-escape by ANTLR 4.11.1. DO NOT EDIT.

package c // CParser
import (
	"fmt"
	"strconv"
	"sync"

	"github.com/antlr/antlr4/runtime/Go/antlr/v4"
)

// Suppress unused import errors
var _ = fmt.Printf
var _ = strconv.Itoa
var _ = sync.Once{}

type CParser struct {
	*antlr.BaseParser
}

var cparserParserStaticData struct {
	once                   sync.Once
	serializedATN          []int32
	literalNames           []string
	symbolicNames          []string
	ruleNames              []string
	predictionContextCache *antlr.PredictionContextCache
	atn                    *antlr.ATN
	decisionToDFA          []*antlr.DFA
}

func cparserParserInit() {
	staticData := &cparserParserStaticData
	staticData.literalNames = []string{
		"", "'auto'", "'break'", "'case'", "'char'", "'const'", "'continue'",
		"'default'", "'do'", "'double'", "'long double'", "'else'", "'enum'",
		"'extern'", "'float'", "'for'", "'goto'", "'if'", "'inline'", "'int'",
		"'long'", "'long long'", "'register'", "'restrict'", "'return'", "'short'",
		"'signed'", "'sizeof'", "'static'", "'struct'", "'switch'", "'typedef'",
		"'union'", "'unsigned'", "'void'", "'volatile'", "'while'", "'_Alignas'",
		"'_Alignof'", "'_Atomic'", "'_Bool'", "'_Complex'", "'_Generic'", "'_Imaginary'",
		"'_Noreturn'", "'_Static_assert'", "'_Thread_local'", "'('", "')'",
		"'['", "']'", "'{'", "'}'", "'<'", "'<='", "'>'", "'>='", "'<<'", "'>>'",
		"'+'", "'++'", "'-'", "'--'", "'*'", "'/'", "'%'", "'&'", "'|'", "'&&'",
		"'||'", "'^'", "'!'", "'~'", "'?'", "':'", "';'", "','", "'='", "'*='",
		"'/='", "'%='", "'+='", "'-='", "'<<='", "'>>='", "'&='", "'^='", "'|='",
		"'=='", "'!='", "'->'", "'.'", "'...'", "", "'__attribute__'", "", "",
		"", "", "", "", "", "'__extension__'", "'__builtin_va_arg'", "'__builtin_offsetof'",
		"'__m128'", "'__m128d'", "'__m128i'", "'__typeof__'", "'__inline__'",
		"'__stdcall'", "'__declspec'", "'__cdecl'", "'__clrcall'", "'__fastcall'",
		"'__thiscall'", "'__vectorcall'", "'__volatile__'",
	}
	staticData.symbolicNames = []string{
		"", "Auto", "Break", "Case", "Char", "Const", "Continue", "Default",
		"Do", "Double", "Longdouble", "Else", "Enum", "Extern", "Float", "For",
		"Goto", "If", "Inline", "Int", "Long", "Longlong", "Register", "Restrict",
		"Return", "Short", "Signed", "Sizeof", "Static", "Struct", "Switch",
		"Typedef", "Union", "Unsigned", "Void", "Volatile", "While", "Alignas",
		"Alignof", "Atomic", "Bool", "Complex", "Generic", "Imaginary", "Noreturn",
		"StaticAssert", "ThreadLocal", "LeftParen", "RightParen", "LeftBracket",
		"RightBracket", "LeftBrace", "RightBrace", "Less", "LessEqual", "Greater",
		"GreaterEqual", "LeftShift", "RightShift", "Plus", "PlusPlus", "Minus",
		"MinusMinus", "Star", "Div", "Mod", "And", "Or", "AndAnd", "OrOr", "Caret",
		"Not", "Tilde", "Question", "Colon", "Semi", "Comma", "Assign", "StarAssign",
		"DivAssign", "ModAssign", "PlusAssign", "MinusAssign", "LeftShiftAssign",
		"RightShiftAssign", "AndAssign", "XorAssign", "OrAssign", "Equal", "NotEqual",
		"Arrow", "Dot", "Ellipsis", "Asm", "Attribute__", "Identifier", "Constant",
		"DigitSequence", "StringLiteral", "WS", "LINE_COMMENT", "BLOCK_COMMENT",
		"Extension", "BuiltinVaArg", "BuiltinOffsetof", "M128", "M128d", "M128i",
		"Typeof", "Inline__", "Stdcall", "Declspec", "Cdecl", "Clrcall", "Fastcall",
		"Thiscall", "Vectorcall", "Volatile__", "MultiLineMacro", "Directive",
		"AsmBlock", "Whitespace", "Newline", "BlockComment", "LineComment",
		"LineContinuation", "EOS",
	}
	staticData.ruleNames = []string{
		"primaryExpression", "stringLiteralExpression", "genericSelection",
		"genericAssocList", "genericAssociation", "postfixExpression", "postfixSuffix",
		"postfixExpressionLvalue", "postfixSuffixLvalue", "argumentExpressionList",
		"macroArgument", "unaryExpression", "castExpression", "coreExpression",
		"assignmentExpression", "assignmentExpressions", "assignmentOperator",
		"expressionList", "statementsExpression", "leftExpression", "expression",
		"declaration", "declarationSpecifiers", "declarationSpecifiers2", "declarationSpecifier",
		"initDeclaratorList", "initDeclarator", "storageClassSpecifier", "typeSpecifier",
		"structOrUnionSpecifier", "structOrUnion", "structDeclarationList",
		"structDeclaration", "specifierQualifierList", "structDeclaratorList",
		"structDeclarator", "enumSpecifier", "enumeratorList", "enumerator",
		"atomicTypeSpecifier", "typeQualifier", "functionSpecifier", "alignmentSpecifier",
		"declarator", "directDeclarator", "declaratorSuffix", "arraySuffix",
		"functionSuffix", "vcSpecificModifer", "gccDeclaratorExtension", "gccAttributeSpecifier",
		"gccAttributeList", "gccAttribute", "pointer", "pointerPart", "typeQualifierList",
		"parameterTypeList", "parameterList", "parameterDeclaration", "identifierList",
		"typeName", "abstractDeclarator", "directAbstractDeclarator", "abstractDeclaratorSuffix",
		"abstractArraySuffix", "abstractFunctionSuffix", "typedefName", "initializer",
		"initializerList", "designation", "designatorList", "designator", "staticAssertDeclaration",
		"statement", "macroCallStatement", "asmStatement", "asmExprList", "labeledStatement",
		"compoundStatement", "blockItemList", "blockItem", "expressionStatement",
		"selectionStatement", "iterationStatement", "forCondition", "coreExpressions",
		"forDeclarations", "forDeclaration", "forExpression", "jumpStatement",
		"compilationUnit", "translationUnit", "externalDeclaration", "macroCallExpression",
		"macroArgumentList", "functionDefinition", "declarationList", "ws",
		"eos",
	}
	staticData.predictionContextCache = antlr.NewPredictionContextCache()
	staticData.serializedATN = []int32{
		4, 1, 126, 2490, 2, 0, 7, 0, 2, 1, 7, 1, 2, 2, 7, 2, 2, 3, 7, 3, 2, 4,
		7, 4, 2, 5, 7, 5, 2, 6, 7, 6, 2, 7, 7, 7, 2, 8, 7, 8, 2, 9, 7, 9, 2, 10,
		7, 10, 2, 11, 7, 11, 2, 12, 7, 12, 2, 13, 7, 13, 2, 14, 7, 14, 2, 15, 7,
		15, 2, 16, 7, 16, 2, 17, 7, 17, 2, 18, 7, 18, 2, 19, 7, 19, 2, 20, 7, 20,
		2, 21, 7, 21, 2, 22, 7, 22, 2, 23, 7, 23, 2, 24, 7, 24, 2, 25, 7, 25, 2,
		26, 7, 26, 2, 27, 7, 27, 2, 28, 7, 28, 2, 29, 7, 29, 2, 30, 7, 30, 2, 31,
		7, 31, 2, 32, 7, 32, 2, 33, 7, 33, 2, 34, 7, 34, 2, 35, 7, 35, 2, 36, 7,
		36, 2, 37, 7, 37, 2, 38, 7, 38, 2, 39, 7, 39, 2, 40, 7, 40, 2, 41, 7, 41,
		2, 42, 7, 42, 2, 43, 7, 43, 2, 44, 7, 44, 2, 45, 7, 45, 2, 46, 7, 46, 2,
		47, 7, 47, 2, 48, 7, 48, 2, 49, 7, 49, 2, 50, 7, 50, 2, 51, 7, 51, 2, 52,
		7, 52, 2, 53, 7, 53, 2, 54, 7, 54, 2, 55, 7, 55, 2, 56, 7, 56, 2, 57, 7,
		57, 2, 58, 7, 58, 2, 59, 7, 59, 2, 60, 7, 60, 2, 61, 7, 61, 2, 62, 7, 62,
		2, 63, 7, 63, 2, 64, 7, 64, 2, 65, 7, 65, 2, 66, 7, 66, 2, 67, 7, 67, 2,
		68, 7, 68, 2, 69, 7, 69, 2, 70, 7, 70, 2, 71, 7, 71, 2, 72, 7, 72, 2, 73,
		7, 73, 2, 74, 7, 74, 2, 75, 7, 75, 2, 76, 7, 76, 2, 77, 7, 77, 2, 78, 7,
		78, 2, 79, 7, 79, 2, 80, 7, 80, 2, 81, 7, 81, 2, 82, 7, 82, 2, 83, 7, 83,
		2, 84, 7, 84, 2, 85, 7, 85, 2, 86, 7, 86, 2, 87, 7, 87, 2, 88, 7, 88, 2,
		89, 7, 89, 2, 90, 7, 90, 2, 91, 7, 91, 2, 92, 7, 92, 2, 93, 7, 93, 2, 94,
		7, 94, 2, 95, 7, 95, 2, 96, 7, 96, 2, 97, 7, 97, 2, 98, 7, 98, 1, 0, 1,
		0, 1, 0, 1, 0, 1, 0, 5, 0, 204, 8, 0, 10, 0, 12, 0, 207, 9, 0, 1, 0, 1,
		0, 5, 0, 211, 8, 0, 10, 0, 12, 0, 214, 9, 0, 1, 0, 1, 0, 1, 0, 1, 0, 3,
		0, 220, 8, 0, 1, 0, 1, 0, 5, 0, 224, 8, 0, 10, 0, 12, 0, 227, 9, 0, 1,
		0, 1, 0, 5, 0, 231, 8, 0, 10, 0, 12, 0, 234, 9, 0, 1, 0, 1, 0, 1, 0, 1,
		0, 1, 0, 5, 0, 241, 8, 0, 10, 0, 12, 0, 244, 9, 0, 1, 0, 1, 0, 5, 0, 248,
		8, 0, 10, 0, 12, 0, 251, 9, 0, 1, 0, 1, 0, 5, 0, 255, 8, 0, 10, 0, 12,
		0, 258, 9, 0, 1, 0, 1, 0, 5, 0, 262, 8, 0, 10, 0, 12, 0, 265, 9, 0, 1,
		0, 1, 0, 1, 0, 1, 0, 1, 0, 5, 0, 272, 8, 0, 10, 0, 12, 0, 275, 9, 0, 1,
		0, 1, 0, 5, 0, 279, 8, 0, 10, 0, 12, 0, 282, 9, 0, 1, 0, 1, 0, 5, 0, 286,
		8, 0, 10, 0, 12, 0, 289, 9, 0, 1, 0, 1, 0, 5, 0, 293, 8, 0, 10, 0, 12,
		0, 296, 9, 0, 1, 0, 1, 0, 1, 0, 3, 0, 301, 8, 0, 1, 1, 1, 1, 1, 1, 1, 1,
		5, 1, 307, 8, 1, 10, 1, 12, 1, 310, 9, 1, 1, 1, 3, 1, 313, 8, 1, 1, 2,
		1, 2, 1, 2, 5, 2, 318, 8, 2, 10, 2, 12, 2, 321, 9, 2, 1, 2, 1, 2, 5, 2,
		325, 8, 2, 10, 2, 12, 2, 328, 9, 2, 1, 2, 1, 2, 5, 2, 332, 8, 2, 10, 2,
		12, 2, 335, 9, 2, 1, 2, 1, 2, 5, 2, 339, 8, 2, 10, 2, 12, 2, 342, 9, 2,
		1, 2, 1, 2, 1, 3, 1, 3, 1, 3, 5, 3, 349, 8, 3, 10, 3, 12, 3, 352, 9, 3,
		1, 3, 5, 3, 355, 8, 3, 10, 3, 12, 3, 358, 9, 3, 1, 4, 1, 4, 3, 4, 362,
		8, 4, 1, 4, 1, 4, 1, 4, 1, 5, 1, 5, 3, 5, 369, 8, 5, 1, 5, 1, 5, 1, 5,
		1, 5, 1, 5, 1, 5, 3, 5, 377, 8, 5, 1, 5, 1, 5, 3, 5, 381, 8, 5, 1, 5, 5,
		5, 384, 8, 5, 10, 5, 12, 5, 387, 9, 5, 1, 5, 1, 5, 1, 5, 1, 5, 1, 5, 1,
		5, 3, 5, 395, 8, 5, 1, 6, 1, 6, 5, 6, 399, 8, 6, 10, 6, 12, 6, 402, 9,
		6, 1, 6, 1, 6, 5, 6, 406, 8, 6, 10, 6, 12, 6, 409, 9, 6, 1, 6, 1, 6, 1,
		6, 1, 6, 5, 6, 415, 8, 6, 10, 6, 12, 6, 418, 9, 6, 1, 6, 3, 6, 421, 8,
		6, 1, 6, 5, 6, 424, 8, 6, 10, 6, 12, 6, 427, 9, 6, 1, 6, 1, 6, 1, 6, 3,
		6, 432, 8, 6, 1, 7, 1, 7, 3, 7, 436, 8, 7, 1, 7, 1, 7, 1, 7, 1, 7, 1, 7,
		1, 7, 3, 7, 444, 8, 7, 1, 7, 1, 7, 3, 7, 448, 8, 7, 1, 7, 5, 7, 451, 8,
		7, 10, 7, 12, 7, 454, 9, 7, 1, 7, 3, 7, 457, 8, 7, 1, 8, 1, 8, 1, 8, 5,
		8, 462, 8, 8, 10, 8, 12, 8, 465, 9, 8, 1, 8, 1, 8, 5, 8, 469, 8, 8, 10,
		8, 12, 8, 472, 9, 8, 1, 8, 1, 8, 1, 8, 1, 8, 3, 8, 478, 8, 8, 1, 8, 1,
		8, 1, 8, 5, 8, 483, 8, 8, 10, 8, 12, 8, 486, 9, 8, 1, 9, 1, 9, 1, 9, 5,
		9, 491, 8, 9, 10, 9, 12, 9, 494, 9, 9, 1, 9, 5, 9, 497, 8, 9, 10, 9, 12,
		9, 500, 9, 9, 1, 10, 1, 10, 1, 10, 1, 10, 3, 10, 506, 8, 10, 1, 10, 3,
		10, 509, 8, 10, 1, 11, 1, 11, 5, 11, 513, 8, 11, 10, 11, 12, 11, 516, 9,
		11, 1, 11, 1, 11, 1, 11, 5, 11, 521, 8, 11, 10, 11, 12, 11, 524, 9, 11,
		1, 11, 1, 11, 1, 11, 5, 11, 529, 8, 11, 10, 11, 12, 11, 532, 9, 11, 1,
		11, 1, 11, 1, 11, 5, 11, 537, 8, 11, 10, 11, 12, 11, 540, 9, 11, 1, 11,
		1, 11, 1, 11, 1, 11, 5, 11, 546, 8, 11, 10, 11, 12, 11, 549, 9, 11, 1,
		11, 5, 11, 552, 8, 11, 10, 11, 12, 11, 555, 9, 11, 1, 11, 5, 11, 558, 8,
		11, 10, 11, 12, 11, 561, 9, 11, 1, 11, 1, 11, 3, 11, 565, 8, 11, 1, 11,
		5, 11, 568, 8, 11, 10, 11, 12, 11, 571, 9, 11, 1, 11, 1, 11, 1, 11, 1,
		11, 5, 11, 577, 8, 11, 10, 11, 12, 11, 580, 9, 11, 1, 11, 1, 11, 3, 11,
		584, 8, 11, 1, 12, 3, 12, 587, 8, 12, 1, 12, 1, 12, 5, 12, 591, 8, 12,
		10, 12, 12, 12, 594, 9, 12, 1, 12, 1, 12, 5, 12, 598, 8, 12, 10, 12, 12,
		12, 601, 9, 12, 1, 12, 1, 12, 5, 12, 605, 8, 12, 10, 12, 12, 12, 608, 9,
		12, 1, 12, 1, 12, 1, 12, 1, 12, 3, 12, 614, 8, 12, 1, 13, 1, 13, 3, 13,
		618, 8, 13, 1, 14, 1, 14, 5, 14, 622, 8, 14, 10, 14, 12, 14, 625, 9, 14,
		1, 14, 1, 14, 5, 14, 629, 8, 14, 10, 14, 12, 14, 632, 9, 14, 1, 14, 1,
		14, 1, 15, 1, 15, 1, 15, 5, 15, 639, 8, 15, 10, 15, 12, 15, 642, 9, 15,
		1, 15, 5, 15, 645, 8, 15, 10, 15, 12, 15, 648, 9, 15, 1, 16, 1, 16, 1,
		17, 1, 17, 1, 17, 5, 17, 655, 8, 17, 10, 17, 12, 17, 658, 9, 17, 1, 17,
		5, 17, 661, 8, 17, 10, 17, 12, 17, 664, 9, 17, 1, 18, 1, 18, 1, 18, 5,
		18, 669, 8, 18, 10, 18, 12, 18, 672, 9, 18, 1, 18, 3, 18, 675, 8, 18, 1,
		18, 3, 18, 678, 8, 18, 1, 18, 1, 18, 1, 18, 1, 19, 1, 19, 5, 19, 685, 8,
		19, 10, 19, 12, 19, 688, 9, 19, 1, 19, 1, 19, 1, 19, 5, 19, 693, 8, 19,
		10, 19, 12, 19, 696, 9, 19, 1, 19, 1, 19, 1, 19, 1, 19, 5, 19, 702, 8,
		19, 10, 19, 12, 19, 705, 9, 19, 1, 19, 1, 19, 5, 19, 709, 8, 19, 10, 19,
		12, 19, 712, 9, 19, 1, 19, 1, 19, 3, 19, 716, 8, 19, 1, 20, 1, 20, 1, 20,
		5, 20, 721, 8, 20, 10, 20, 12, 20, 724, 9, 20, 1, 20, 1, 20, 1, 20, 5,
		20, 729, 8, 20, 10, 20, 12, 20, 732, 9, 20, 1, 20, 1, 20, 5, 20, 736, 8,
		20, 10, 20, 12, 20, 739, 9, 20, 1, 20, 1, 20, 1, 20, 1, 20, 1, 20, 3, 20,
		746, 8, 20, 1, 20, 1, 20, 1, 20, 5, 20, 751, 8, 20, 10, 20, 12, 20, 754,
		9, 20, 1, 20, 1, 20, 1, 20, 1, 20, 5, 20, 760, 8, 20, 10, 20, 12, 20, 763,
		9, 20, 1, 20, 1, 20, 1, 20, 1, 20, 5, 20, 769, 8, 20, 10, 20, 12, 20, 772,
		9, 20, 1, 20, 1, 20, 1, 20, 1, 20, 5, 20, 778, 8, 20, 10, 20, 12, 20, 781,
		9, 20, 1, 20, 1, 20, 1, 20, 1, 20, 5, 20, 787, 8, 20, 10, 20, 12, 20, 790,
		9, 20, 1, 20, 1, 20, 1, 20, 1, 20, 5, 20, 796, 8, 20, 10, 20, 12, 20, 799,
		9, 20, 1, 20, 1, 20, 1, 20, 5, 20, 804, 8, 20, 10, 20, 12, 20, 807, 9,
		20, 1, 20, 1, 20, 5, 20, 811, 8, 20, 10, 20, 12, 20, 814, 9, 20, 1, 21,
		1, 21, 5, 21, 818, 8, 21, 10, 21, 12, 21, 821, 9, 21, 1, 21, 3, 21, 824,
		8, 21, 1, 21, 5, 21, 827, 8, 21, 10, 21, 12, 21, 830, 9, 21, 1, 21, 1,
		21, 1, 21, 1, 21, 5, 21, 836, 8, 21, 10, 21, 12, 21, 839, 9, 21, 1, 21,
		5, 21, 842, 8, 21, 10, 21, 12, 21, 845, 9, 21, 1, 21, 1, 21, 3, 21, 849,
		8, 21, 1, 21, 5, 21, 852, 8, 21, 10, 21, 12, 21, 855, 9, 21, 1, 21, 1,
		21, 1, 21, 3, 21, 860, 8, 21, 1, 22, 1, 22, 1, 22, 5, 22, 865, 8, 22, 10,
		22, 12, 22, 868, 9, 22, 1, 22, 3, 22, 871, 8, 22, 1, 23, 1, 23, 1, 23,
		5, 23, 876, 8, 23, 10, 23, 12, 23, 879, 9, 23, 1, 23, 3, 23, 882, 8, 23,
		1, 24, 1, 24, 1, 24, 5, 24, 887, 8, 24, 10, 24, 12, 24, 890, 9, 24, 1,
		24, 3, 24, 893, 8, 24, 1, 24, 1, 24, 3, 24, 897, 8, 24, 1, 24, 5, 24, 900,
		8, 24, 10, 24, 12, 24, 903, 9, 24, 1, 24, 3, 24, 906, 8, 24, 1, 25, 1,
		25, 1, 25, 5, 25, 911, 8, 25, 10, 25, 12, 25, 914, 9, 25, 1, 25, 5, 25,
		917, 8, 25, 10, 25, 12, 25, 920, 9, 25, 1, 26, 1, 26, 1, 26, 3, 26, 925,
		8, 26, 1, 27, 1, 27, 1, 28, 1, 28, 1, 28, 1, 28, 1, 28, 1, 28, 1, 28, 1,
		28, 1, 28, 1, 28, 1, 28, 1, 28, 1, 28, 1, 28, 1, 28, 1, 28, 1, 28, 1, 28,
		1, 28, 1, 28, 1, 28, 1, 28, 1, 28, 1, 28, 1, 28, 1, 28, 1, 28, 1, 28, 1,
		28, 3, 28, 958, 8, 28, 1, 29, 1, 29, 5, 29, 962, 8, 29, 10, 29, 12, 29,
		965, 9, 29, 1, 29, 3, 29, 968, 8, 29, 1, 29, 1, 29, 5, 29, 972, 8, 29,
		10, 29, 12, 29, 975, 9, 29, 1, 29, 1, 29, 5, 29, 979, 8, 29, 10, 29, 12,
		29, 982, 9, 29, 1, 29, 1, 29, 5, 29, 986, 8, 29, 10, 29, 12, 29, 989, 9,
		29, 1, 29, 3, 29, 992, 8, 29, 1, 30, 1, 30, 1, 31, 1, 31, 5, 31, 998, 8,
		31, 10, 31, 12, 31, 1001, 9, 31, 4, 31, 1003, 8, 31, 11, 31, 12, 31, 1004,
		1, 32, 1, 32, 5, 32, 1009, 8, 32, 10, 32, 12, 32, 1012, 9, 32, 1, 32, 1,
		32, 5, 32, 1016, 8, 32, 10, 32, 12, 32, 1019, 9, 32, 1, 32, 1, 32, 1, 32,
		1, 32, 5, 32, 1025, 8, 32, 10, 32, 12, 32, 1028, 9, 32, 1, 32, 1, 32, 1,
		32, 3, 32, 1033, 8, 32, 1, 33, 1, 33, 3, 33, 1037, 8, 33, 1, 33, 3, 33,
		1040, 8, 33, 1, 34, 1, 34, 1, 34, 5, 34, 1045, 8, 34, 10, 34, 12, 34, 1048,
		9, 34, 1, 34, 5, 34, 1051, 8, 34, 10, 34, 12, 34, 1054, 9, 34, 1, 35, 1,
		35, 3, 35, 1058, 8, 35, 1, 35, 1, 35, 5, 35, 1062, 8, 35, 10, 35, 12, 35,
		1065, 9, 35, 1, 35, 3, 35, 1068, 8, 35, 1, 36, 1, 36, 5, 36, 1072, 8, 36,
		10, 36, 12, 36, 1075, 9, 36, 1, 36, 3, 36, 1078, 8, 36, 1, 36, 1, 36, 5,
		36, 1082, 8, 36, 10, 36, 12, 36, 1085, 9, 36, 1, 36, 1, 36, 5, 36, 1089,
		8, 36, 10, 36, 12, 36, 1092, 9, 36, 1, 36, 3, 36, 1095, 8, 36, 1, 36, 5,
		36, 1098, 8, 36, 10, 36, 12, 36, 1101, 9, 36, 1, 36, 1, 36, 1, 36, 1, 36,
		5, 36, 1107, 8, 36, 10, 36, 12, 36, 1110, 9, 36, 1, 36, 3, 36, 1113, 8,
		36, 1, 37, 1, 37, 1, 37, 5, 37, 1118, 8, 37, 10, 37, 12, 37, 1121, 9, 37,
		1, 37, 5, 37, 1124, 8, 37, 10, 37, 12, 37, 1127, 9, 37, 1, 38, 1, 38, 5,
		38, 1131, 8, 38, 10, 38, 12, 38, 1134, 9, 38, 1, 38, 1, 38, 1, 38, 5, 38,
		1139, 8, 38, 10, 38, 12, 38, 1142, 9, 38, 1, 38, 3, 38, 1145, 8, 38, 1,
		38, 1, 38, 1, 38, 5, 38, 1150, 8, 38, 10, 38, 12, 38, 1153, 9, 38, 1, 38,
		3, 38, 1156, 8, 38, 3, 38, 1158, 8, 38, 1, 39, 1, 39, 1, 39, 5, 39, 1163,
		8, 39, 10, 39, 12, 39, 1166, 9, 39, 1, 39, 1, 39, 5, 39, 1170, 8, 39, 10,
		39, 12, 39, 1173, 9, 39, 1, 39, 1, 39, 1, 40, 1, 40, 1, 41, 1, 41, 1, 41,
		1, 41, 1, 41, 1, 41, 1, 41, 1, 41, 1, 41, 3, 41, 1188, 8, 41, 1, 42, 1,
		42, 1, 42, 5, 42, 1193, 8, 42, 10, 42, 12, 42, 1196, 9, 42, 1, 42, 1, 42,
		3, 42, 1200, 8, 42, 1, 42, 5, 42, 1203, 8, 42, 10, 42, 12, 42, 1206, 9,
		42, 1, 42, 1, 42, 1, 43, 3, 43, 1211, 8, 43, 1, 43, 1, 43, 5, 43, 1215,
		8, 43, 10, 43, 12, 43, 1218, 9, 43, 1, 44, 1, 44, 5, 44, 1222, 8, 44, 10,
		44, 12, 44, 1225, 9, 44, 1, 44, 1, 44, 5, 44, 1229, 8, 44, 10, 44, 12,
		44, 1232, 9, 44, 1, 44, 1, 44, 5, 44, 1236, 8, 44, 10, 44, 12, 44, 1239,
		9, 44, 1, 44, 1, 44, 5, 44, 1243, 8, 44, 10, 44, 12, 44, 1246, 9, 44, 1,
		44, 1, 44, 5, 44, 1250, 8, 44, 10, 44, 12, 44, 1253, 9, 44, 1, 44, 1, 44,
		1, 44, 5, 44, 1258, 8, 44, 10, 44, 12, 44, 1261, 9, 44, 1, 44, 1, 44, 1,
		44, 5, 44, 1266, 8, 44, 10, 44, 12, 44, 1269, 9, 44, 1, 44, 1, 44, 5, 44,
		1273, 8, 44, 10, 44, 12, 44, 1276, 9, 44, 1, 44, 1, 44, 5, 44, 1280, 8,
		44, 10, 44, 12, 44, 1283, 9, 44, 1, 44, 1, 44, 5, 44, 1287, 8, 44, 10,
		44, 12, 44, 1290, 9, 44, 1, 44, 1, 44, 5, 44, 1294, 8, 44, 10, 44, 12,
		44, 1297, 9, 44, 1, 44, 1, 44, 5, 44, 1301, 8, 44, 10, 44, 12, 44, 1304,
		9, 44, 3, 44, 1306, 8, 44, 1, 45, 1, 45, 3, 45, 1310, 8, 45, 1, 46, 1,
		46, 5, 46, 1314, 8, 46, 10, 46, 12, 46, 1317, 9, 46, 1, 46, 3, 46, 1320,
		8, 46, 1, 46, 5, 46, 1323, 8, 46, 10, 46, 12, 46, 1326, 9, 46, 1, 46, 3,
		46, 1329, 8, 46, 1, 46, 5, 46, 1332, 8, 46, 10, 46, 12, 46, 1335, 9, 46,
		1, 46, 1, 46, 1, 46, 5, 46, 1340, 8, 46, 10, 46, 12, 46, 1343, 9, 46, 1,
		46, 1, 46, 5, 46, 1347, 8, 46, 10, 46, 12, 46, 1350, 9, 46, 1, 46, 3, 46,
		1353, 8, 46, 1, 46, 5, 46, 1356, 8, 46, 10, 46, 12, 46, 1359, 9, 46, 1,
		46, 1, 46, 5, 46, 1363, 8, 46, 10, 46, 12, 46, 1366, 9, 46, 1, 46, 1, 46,
		1, 46, 1, 46, 5, 46, 1372, 8, 46, 10, 46, 12, 46, 1375, 9, 46, 1, 46, 1,
		46, 5, 46, 1379, 8, 46, 10, 46, 12, 46, 1382, 9, 46, 1, 46, 1, 46, 5, 46,
		1386, 8, 46, 10, 46, 12, 46, 1389, 9, 46, 1, 46, 1, 46, 5, 46, 1393, 8,
		46, 10, 46, 12, 46, 1396, 9, 46, 1, 46, 1, 46, 1, 46, 1, 46, 5, 46, 1402,
		8, 46, 10, 46, 12, 46, 1405, 9, 46, 1, 46, 3, 46, 1408, 8, 46, 1, 46, 5,
		46, 1411, 8, 46, 10, 46, 12, 46, 1414, 9, 46, 1, 46, 1, 46, 5, 46, 1418,
		8, 46, 10, 46, 12, 46, 1421, 9, 46, 1, 46, 3, 46, 1424, 8, 46, 1, 47, 1,
		47, 5, 47, 1428, 8, 47, 10, 47, 12, 47, 1431, 9, 47, 1, 47, 1, 47, 5, 47,
		1435, 8, 47, 10, 47, 12, 47, 1438, 9, 47, 1, 47, 1, 47, 1, 47, 1, 47, 5,
		47, 1444, 8, 47, 10, 47, 12, 47, 1447, 9, 47, 1, 47, 3, 47, 1450, 8, 47,
		1, 47, 5, 47, 1453, 8, 47, 10, 47, 12, 47, 1456, 9, 47, 1, 47, 3, 47, 1459,
		8, 47, 1, 48, 1, 48, 1, 49, 1, 49, 1, 49, 1, 49, 1, 49, 1, 49, 1, 49, 3,
		49, 1470, 8, 49, 3, 49, 1472, 8, 49, 1, 50, 1, 50, 1, 50, 5, 50, 1477,
		8, 50, 10, 50, 12, 50, 1480, 9, 50, 1, 50, 1, 50, 5, 50, 1484, 8, 50, 10,
		50, 12, 50, 1487, 9, 50, 1, 50, 3, 50, 1490, 8, 50, 1, 50, 5, 50, 1493,
		8, 50, 10, 50, 12, 50, 1496, 9, 50, 1, 50, 1, 50, 5, 50, 1500, 8, 50, 10,
		50, 12, 50, 1503, 9, 50, 1, 50, 1, 50, 1, 51, 1, 51, 1, 51, 5, 51, 1510,
		8, 51, 10, 51, 12, 51, 1513, 9, 51, 1, 51, 5, 51, 1516, 8, 51, 10, 51,
		12, 51, 1519, 9, 51, 1, 52, 1, 52, 1, 52, 3, 52, 1524, 8, 52, 1, 52, 3,
		52, 1527, 8, 52, 1, 52, 1, 52, 1, 52, 3, 52, 1532, 8, 52, 1, 52, 3, 52,
		1535, 8, 52, 3, 52, 1537, 8, 52, 1, 53, 4, 53, 1540, 8, 53, 11, 53, 12,
		53, 1541, 1, 54, 1, 54, 3, 54, 1546, 8, 54, 1, 55, 4, 55, 1549, 8, 55,
		11, 55, 12, 55, 1550, 1, 56, 1, 56, 1, 56, 5, 56, 1556, 8, 56, 10, 56,
		12, 56, 1559, 9, 56, 1, 56, 3, 56, 1562, 8, 56, 1, 56, 5, 56, 1565, 8,
		56, 10, 56, 12, 56, 1568, 9, 56, 3, 56, 1570, 8, 56, 1, 57, 1, 57, 1, 57,
		5, 57, 1575, 8, 57, 10, 57, 12, 57, 1578, 9, 57, 1, 57, 5, 57, 1581, 8,
		57, 10, 57, 12, 57, 1584, 9, 57, 1, 58, 1, 58, 1, 58, 1, 58, 1, 58, 3,
		58, 1591, 8, 58, 3, 58, 1593, 8, 58, 1, 59, 1, 59, 1, 59, 5, 59, 1598,
		8, 59, 10, 59, 12, 59, 1601, 9, 59, 1, 59, 5, 59, 1604, 8, 59, 10, 59,
		12, 59, 1607, 9, 59, 1, 60, 1, 60, 1, 60, 3, 60, 1612, 8, 60, 1, 60, 1,
		60, 1, 60, 5, 60, 1617, 8, 60, 10, 60, 12, 60, 1620, 9, 60, 1, 61, 1, 61,
		3, 61, 1624, 8, 61, 1, 61, 1, 61, 5, 61, 1628, 8, 61, 10, 61, 12, 61, 1631,
		9, 61, 3, 61, 1633, 8, 61, 1, 62, 1, 62, 5, 62, 1637, 8, 62, 10, 62, 12,
		62, 1640, 9, 62, 1, 62, 1, 62, 5, 62, 1644, 8, 62, 10, 62, 12, 62, 1647,
		9, 62, 1, 62, 1, 62, 5, 62, 1651, 8, 62, 10, 62, 12, 62, 1654, 9, 62, 1,
		62, 5, 62, 1657, 8, 62, 10, 62, 12, 62, 1660, 9, 62, 1, 62, 4, 62, 1663,
		8, 62, 11, 62, 12, 62, 1664, 3, 62, 1667, 8, 62, 1, 63, 1, 63, 3, 63, 1671,
		8, 63, 1, 64, 1, 64, 5, 64, 1675, 8, 64, 10, 64, 12, 64, 1678, 9, 64, 1,
		64, 3, 64, 1681, 8, 64, 1, 64, 5, 64, 1684, 8, 64, 10, 64, 12, 64, 1687,
		9, 64, 1, 64, 3, 64, 1690, 8, 64, 1, 64, 5, 64, 1693, 8, 64, 10, 64, 12,
		64, 1696, 9, 64, 1, 64, 1, 64, 1, 64, 5, 64, 1701, 8, 64, 10, 64, 12, 64,
		1704, 9, 64, 1, 64, 1, 64, 5, 64, 1708, 8, 64, 10, 64, 12, 64, 1711, 9,
		64, 1, 64, 3, 64, 1714, 8, 64, 1, 64, 5, 64, 1717, 8, 64, 10, 64, 12, 64,
		1720, 9, 64, 1, 64, 1, 64, 5, 64, 1724, 8, 64, 10, 64, 12, 64, 1727, 9,
		64, 1, 64, 1, 64, 1, 64, 1, 64, 5, 64, 1733, 8, 64, 10, 64, 12, 64, 1736,
		9, 64, 1, 64, 1, 64, 5, 64, 1740, 8, 64, 10, 64, 12, 64, 1743, 9, 64, 1,
		64, 1, 64, 5, 64, 1747, 8, 64, 10, 64, 12, 64, 1750, 9, 64, 1, 64, 1, 64,
		5, 64, 1754, 8, 64, 10, 64, 12, 64, 1757, 9, 64, 1, 64, 1, 64, 1, 64, 1,
		64, 5, 64, 1763, 8, 64, 10, 64, 12, 64, 1766, 9, 64, 1, 64, 1, 64, 5, 64,
		1770, 8, 64, 10, 64, 12, 64, 1773, 9, 64, 1, 64, 3, 64, 1776, 8, 64, 1,
		65, 1, 65, 5, 65, 1780, 8, 65, 10, 65, 12, 65, 1783, 9, 65, 1, 65, 3, 65,
		1786, 8, 65, 1, 65, 5, 65, 1789, 8, 65, 10, 65, 12, 65, 1792, 9, 65, 1,
		65, 1, 65, 5, 65, 1796, 8, 65, 10, 65, 12, 65, 1799, 9, 65, 1, 66, 3, 66,
		1802, 8, 66, 1, 66, 1, 66, 1, 67, 1, 67, 1, 67, 5, 67, 1809, 8, 67, 10,
		67, 12, 67, 1812, 9, 67, 1, 67, 3, 67, 1815, 8, 67, 1, 67, 5, 67, 1818,
		8, 67, 10, 67, 12, 67, 1821, 9, 67, 1, 67, 3, 67, 1824, 8, 67, 1, 67, 5,
		67, 1827, 8, 67, 10, 67, 12, 67, 1830, 9, 67, 1, 67, 3, 67, 1833, 8, 67,
		1, 68, 3, 68, 1836, 8, 68, 1, 68, 1, 68, 1, 68, 5, 68, 1841, 8, 68, 10,
		68, 12, 68, 1844, 9, 68, 1, 68, 3, 68, 1847, 8, 68, 1, 68, 5, 68, 1850,
		8, 68, 10, 68, 12, 68, 1853, 9, 68, 1, 69, 1, 69, 5, 69, 1857, 8, 69, 10,
		69, 12, 69, 1860, 9, 69, 1, 69, 1, 69, 1, 70, 4, 70, 1865, 8, 70, 11, 70,
		12, 70, 1866, 1, 71, 1, 71, 5, 71, 1871, 8, 71, 10, 71, 12, 71, 1874, 9,
		71, 1, 71, 1, 71, 5, 71, 1878, 8, 71, 10, 71, 12, 71, 1881, 9, 71, 1, 71,
		1, 71, 1, 71, 1, 71, 5, 71, 1887, 8, 71, 10, 71, 12, 71, 1890, 9, 71, 1,
		71, 3, 71, 1893, 8, 71, 1, 72, 1, 72, 5, 72, 1897, 8, 72, 10, 72, 12, 72,
		1900, 9, 72, 1, 72, 1, 72, 5, 72, 1904, 8, 72, 10, 72, 12, 72, 1907, 9,
		72, 1, 72, 1, 72, 5, 72, 1911, 8, 72, 10, 72, 12, 72, 1914, 9, 72, 1, 72,
		1, 72, 5, 72, 1918, 8, 72, 10, 72, 12, 72, 1921, 9, 72, 1, 72, 4, 72, 1924,
		8, 72, 11, 72, 12, 72, 1925, 1, 72, 5, 72, 1929, 8, 72, 10, 72, 12, 72,
		1932, 9, 72, 1, 72, 1, 72, 5, 72, 1936, 8, 72, 10, 72, 12, 72, 1939, 9,
		72, 1, 72, 1, 72, 1, 73, 1, 73, 1, 73, 5, 73, 1946, 8, 73, 10, 73, 12,
		73, 1949, 9, 73, 1, 73, 3, 73, 1952, 8, 73, 1, 73, 1, 73, 1, 73, 1, 73,
		1, 73, 1, 73, 1, 73, 1, 73, 1, 73, 3, 73, 1963, 8, 73, 1, 74, 1, 74, 5,
		74, 1967, 8, 74, 10, 74, 12, 74, 1970, 9, 74, 1, 75, 1, 75, 5, 75, 1974,
		8, 75, 10, 75, 12, 75, 1977, 9, 75, 1, 75, 3, 75, 1980, 8, 75, 1, 75, 5,
		75, 1983, 8, 75, 10, 75, 12, 75, 1986, 9, 75, 1, 75, 1, 75, 5, 75, 1990,
		8, 75, 10, 75, 12, 75, 1993, 9, 75, 1, 75, 3, 75, 1996, 8, 75, 1, 75, 5,
		75, 1999, 8, 75, 10, 75, 12, 75, 2002, 9, 75, 1, 75, 1, 75, 5, 75, 2006,
		8, 75, 10, 75, 12, 75, 2009, 9, 75, 1, 75, 3, 75, 2012, 8, 75, 1, 75, 5,
		75, 2015, 8, 75, 10, 75, 12, 75, 2018, 9, 75, 1, 75, 1, 75, 5, 75, 2022,
		8, 75, 10, 75, 12, 75, 2025, 9, 75, 1, 75, 3, 75, 2028, 8, 75, 1, 75, 5,
		75, 2031, 8, 75, 10, 75, 12, 75, 2034, 9, 75, 1, 75, 1, 75, 5, 75, 2038,
		8, 75, 10, 75, 12, 75, 2041, 9, 75, 1, 75, 3, 75, 2044, 8, 75, 1, 75, 5,
		75, 2047, 8, 75, 10, 75, 12, 75, 2050, 9, 75, 3, 75, 2052, 8, 75, 3, 75,
		2054, 8, 75, 1, 75, 5, 75, 2057, 8, 75, 10, 75, 12, 75, 2060, 9, 75, 3,
		75, 2062, 8, 75, 1, 75, 1, 75, 5, 75, 2066, 8, 75, 10, 75, 12, 75, 2069,
		9, 75, 1, 75, 1, 75, 1, 76, 1, 76, 1, 76, 5, 76, 2076, 8, 76, 10, 76, 12,
		76, 2079, 9, 76, 1, 76, 5, 76, 2082, 8, 76, 10, 76, 12, 76, 2085, 9, 76,
		1, 77, 1, 77, 1, 77, 1, 77, 5, 77, 2091, 8, 77, 10, 77, 12, 77, 2094, 9,
		77, 1, 77, 5, 77, 2097, 8, 77, 10, 77, 12, 77, 2100, 9, 77, 1, 77, 1, 77,
		1, 77, 5, 77, 2105, 8, 77, 10, 77, 12, 77, 2108, 9, 77, 1, 77, 5, 77, 2111,
		8, 77, 10, 77, 12, 77, 2114, 9, 77, 3, 77, 2116, 8, 77, 1, 78, 1, 78, 3,
		78, 2120, 8, 78, 1, 78, 1, 78, 1, 79, 1, 79, 5, 79, 2126, 8, 79, 10, 79,
		12, 79, 2129, 9, 79, 4, 79, 2131, 8, 79, 11, 79, 12, 79, 2132, 1, 80, 1,
		80, 3, 80, 2137, 8, 80, 1, 81, 1, 81, 5, 81, 2141, 8, 81, 10, 81, 12, 81,
		2144, 9, 81, 1, 81, 1, 81, 1, 82, 1, 82, 1, 82, 5, 82, 2151, 8, 82, 10,
		82, 12, 82, 2154, 9, 82, 1, 82, 1, 82, 5, 82, 2158, 8, 82, 10, 82, 12,
		82, 2161, 9, 82, 1, 82, 1, 82, 5, 82, 2165, 8, 82, 10, 82, 12, 82, 2168,
		9, 82, 1, 82, 1, 82, 1, 82, 5, 82, 2173, 8, 82, 10, 82, 12, 82, 2176, 9,
		82, 1, 82, 3, 82, 2179, 8, 82, 1, 82, 1, 82, 1, 82, 5, 82, 2184, 8, 82,
		10, 82, 12, 82, 2187, 9, 82, 1, 82, 1, 82, 5, 82, 2191, 8, 82, 10, 82,
		12, 82, 2194, 9, 82, 1, 82, 1, 82, 1, 82, 5, 82, 2199, 8, 82, 10, 82, 12,
		82, 2202, 9, 82, 1, 82, 5, 82, 2205, 8, 82, 10, 82, 12, 82, 2208, 9, 82,
		1, 82, 5, 82, 2211, 8, 82, 10, 82, 12, 82, 2214, 9, 82, 1, 82, 1, 82, 3,
		82, 2218, 8, 82, 1, 83, 1, 83, 1, 83, 5, 83, 2223, 8, 83, 10, 83, 12, 83,
		2226, 9, 83, 1, 83, 1, 83, 5, 83, 2230, 8, 83, 10, 83, 12, 83, 2233, 9,
		83, 1, 83, 1, 83, 3, 83, 2237, 8, 83, 1, 83, 5, 83, 2240, 8, 83, 10, 83,
		12, 83, 2243, 9, 83, 1, 83, 1, 83, 1, 83, 1, 83, 5, 83, 2249, 8, 83, 10,
		83, 12, 83, 2252, 9, 83, 1, 83, 1, 83, 1, 83, 1, 83, 5, 83, 2258, 8, 83,
		10, 83, 12, 83, 2261, 9, 83, 1, 83, 1, 83, 5, 83, 2265, 8, 83, 10, 83,
		12, 83, 2268, 9, 83, 1, 83, 1, 83, 3, 83, 2272, 8, 83, 1, 83, 1, 83, 1,
		83, 5, 83, 2277, 8, 83, 10, 83, 12, 83, 2280, 9, 83, 1, 83, 1, 83, 5, 83,
		2284, 8, 83, 10, 83, 12, 83, 2287, 9, 83, 1, 83, 1, 83, 5, 83, 2291, 8,
		83, 10, 83, 12, 83, 2294, 9, 83, 1, 83, 1, 83, 3, 83, 2298, 8, 83, 1, 84,
		1, 84, 3, 84, 2302, 8, 84, 3, 84, 2304, 8, 84, 1, 84, 1, 84, 3, 84, 2308,
		8, 84, 1, 84, 1, 84, 3, 84, 2312, 8, 84, 1, 85, 1, 85, 1, 85, 5, 85, 2317,
		8, 85, 10, 85, 12, 85, 2320, 9, 85, 1, 85, 5, 85, 2323, 8, 85, 10, 85,
		12, 85, 2326, 9, 85, 1, 86, 1, 86, 1, 86, 5, 86, 2331, 8, 86, 10, 86, 12,
		86, 2334, 9, 86, 1, 86, 5, 86, 2337, 8, 86, 10, 86, 12, 86, 2340, 9, 86,
		1, 87, 1, 87, 3, 87, 2344, 8, 87, 1, 88, 1, 88, 1, 88, 5, 88, 2349, 8,
		88, 10, 88, 12, 88, 2352, 9, 88, 1, 88, 5, 88, 2355, 8, 88, 10, 88, 12,
		88, 2358, 9, 88, 1, 89, 1, 89, 5, 89, 2362, 8, 89, 10, 89, 12, 89, 2365,
		9, 89, 1, 89, 1, 89, 1, 89, 1, 89, 1, 89, 5, 89, 2372, 8, 89, 10, 89, 12,
		89, 2375, 9, 89, 1, 89, 3, 89, 2378, 8, 89, 3, 89, 2380, 8, 89, 1, 89,
		5, 89, 2383, 8, 89, 10, 89, 12, 89, 2386, 9, 89, 1, 89, 1, 89, 1, 90, 5,
		90, 2391, 8, 90, 10, 90, 12, 90, 2394, 9, 90, 1, 90, 3, 90, 2397, 8, 90,
		1, 90, 1, 90, 1, 91, 1, 91, 5, 91, 2403, 8, 91, 10, 91, 12, 91, 2406, 9,
		91, 4, 91, 2408, 8, 91, 11, 91, 12, 91, 2409, 1, 92, 1, 92, 1, 92, 1, 92,
		1, 92, 1, 92, 3, 92, 2418, 8, 92, 1, 93, 1, 93, 1, 93, 5, 93, 2423, 8,
		93, 10, 93, 12, 93, 2426, 9, 93, 1, 93, 3, 93, 2429, 8, 93, 1, 93, 5, 93,
		2432, 8, 93, 10, 93, 12, 93, 2435, 9, 93, 1, 93, 1, 93, 5, 93, 2439, 8,
		93, 10, 93, 12, 93, 2442, 9, 93, 1, 94, 1, 94, 1, 94, 5, 94, 2447, 8, 94,
		10, 94, 12, 94, 2450, 9, 94, 1, 94, 5, 94, 2453, 8, 94, 10, 94, 12, 94,
		2456, 9, 94, 1, 95, 3, 95, 2459, 8, 95, 1, 95, 1, 95, 3, 95, 2463, 8, 95,
		1, 95, 3, 95, 2466, 8, 95, 1, 96, 1, 96, 5, 96, 2470, 8, 96, 10, 96, 12,
		96, 2473, 9, 96, 4, 96, 2475, 8, 96, 11, 96, 12, 96, 2476, 1, 97, 4, 97,
		2480, 8, 97, 11, 97, 12, 97, 2481, 1, 97, 1, 97, 3, 97, 2486, 8, 97, 1,
		98, 1, 98, 1, 98, 0, 3, 16, 40, 120, 99, 0, 2, 4, 6, 8, 10, 12, 14, 16,
		18, 20, 22, 24, 26, 28, 30, 32, 34, 36, 38, 40, 42, 44, 46, 48, 50, 52,
		54, 56, 58, 60, 62, 64, 66, 68, 70, 72, 74, 76, 78, 80, 82, 84, 86, 88,
		90, 92, 94, 96, 98, 100, 102, 104, 106, 108, 110, 112, 114, 116, 118, 120,
		122, 124, 126, 128, 130, 132, 134, 136, 138, 140, 142, 144, 146, 148, 150,
		152, 154, 156, 158, 160, 162, 164, 166, 168, 170, 172, 174, 176, 178, 180,
		182, 184, 186, 188, 190, 192, 194, 196, 0, 18, 1, 0, 90, 91, 2, 0, 53,
		72, 88, 89, 2, 0, 60, 60, 62, 62, 2, 0, 27, 27, 38, 38, 1, 0, 77, 87, 5,
		0, 59, 59, 61, 61, 63, 63, 66, 66, 70, 72, 2, 0, 57, 58, 63, 66, 4, 0,
		59, 59, 61, 61, 67, 67, 70, 70, 2, 0, 53, 56, 88, 89, 6, 0, 1, 1, 13, 13,
		22, 22, 28, 28, 31, 31, 46, 46, 1, 0, 105, 107, 2, 0, 29, 29, 32, 32, 6,
		0, 5, 5, 23, 23, 26, 26, 33, 33, 35, 35, 39, 39, 2, 0, 110, 110, 112, 116,
		2, 0, 47, 48, 76, 76, 2, 0, 63, 63, 70, 70, 2, 0, 35, 35, 117, 117, 2,
		0, 75, 75, 126, 126, 2841, 0, 300, 1, 0, 0, 0, 2, 302, 1, 0, 0, 0, 4, 314,
		1, 0, 0, 0, 6, 345, 1, 0, 0, 0, 8, 361, 1, 0, 0, 0, 10, 394, 1, 0, 0, 0,
		12, 431, 1, 0, 0, 0, 14, 456, 1, 0, 0, 0, 16, 477, 1, 0, 0, 0, 18, 487,
		1, 0, 0, 0, 20, 508, 1, 0, 0, 0, 22, 583, 1, 0, 0, 0, 24, 613, 1, 0, 0,
		0, 26, 617, 1, 0, 0, 0, 28, 619, 1, 0, 0, 0, 30, 635, 1, 0, 0, 0, 32, 649,
		1, 0, 0, 0, 34, 651, 1, 0, 0, 0, 36, 665, 1, 0, 0, 0, 38, 715, 1, 0, 0,
		0, 40, 745, 1, 0, 0, 0, 42, 859, 1, 0, 0, 0, 44, 861, 1, 0, 0, 0, 46, 872,
		1, 0, 0, 0, 48, 905, 1, 0, 0, 0, 50, 907, 1, 0, 0, 0, 52, 921, 1, 0, 0,
		0, 54, 926, 1, 0, 0, 0, 56, 957, 1, 0, 0, 0, 58, 959, 1, 0, 0, 0, 60, 993,
		1, 0, 0, 0, 62, 1002, 1, 0, 0, 0, 64, 1032, 1, 0, 0, 0, 66, 1036, 1, 0,
		0, 0, 68, 1041, 1, 0, 0, 0, 70, 1067, 1, 0, 0, 0, 72, 1112, 1, 0, 0, 0,
		74, 1114, 1, 0, 0, 0, 76, 1157, 1, 0, 0, 0, 78, 1159, 1, 0, 0, 0, 80, 1176,
		1, 0, 0, 0, 82, 1187, 1, 0, 0, 0, 84, 1189, 1, 0, 0, 0, 86, 1210, 1, 0,
		0, 0, 88, 1305, 1, 0, 0, 0, 90, 1309, 1, 0, 0, 0, 92, 1423, 1, 0, 0, 0,
		94, 1458, 1, 0, 0, 0, 96, 1460, 1, 0, 0, 0, 98, 1471, 1, 0, 0, 0, 100,
		1473, 1, 0, 0, 0, 102, 1506, 1, 0, 0, 0, 104, 1536, 1, 0, 0, 0, 106, 1539,
		1, 0, 0, 0, 108, 1543, 1, 0, 0, 0, 110, 1548, 1, 0, 0, 0, 112, 1552, 1,
		0, 0, 0, 114, 1571, 1, 0, 0, 0, 116, 1592, 1, 0, 0, 0, 118, 1594, 1, 0,
		0, 0, 120, 1608, 1, 0, 0, 0, 122, 1632, 1, 0, 0, 0, 124, 1666, 1, 0, 0,
		0, 126, 1670, 1, 0, 0, 0, 128, 1775, 1, 0, 0, 0, 130, 1777, 1, 0, 0, 0,
		132, 1801, 1, 0, 0, 0, 134, 1832, 1, 0, 0, 0, 136, 1835, 1, 0, 0, 0, 138,
		1854, 1, 0, 0, 0, 140, 1864, 1, 0, 0, 0, 142, 1892, 1, 0, 0, 0, 144, 1894,
		1, 0, 0, 0, 146, 1962, 1, 0, 0, 0, 148, 1964, 1, 0, 0, 0, 150, 1971, 1,
		0, 0, 0, 152, 2072, 1, 0, 0, 0, 154, 2115, 1, 0, 0, 0, 156, 2117, 1, 0,
		0, 0, 158, 2130, 1, 0, 0, 0, 160, 2136, 1, 0, 0, 0, 162, 2138, 1, 0, 0,
		0, 164, 2217, 1, 0, 0, 0, 166, 2297, 1, 0, 0, 0, 168, 2303, 1, 0, 0, 0,
		170, 2313, 1, 0, 0, 0, 172, 2327, 1, 0, 0, 0, 174, 2341, 1, 0, 0, 0, 176,
		2345, 1, 0, 0, 0, 178, 2379, 1, 0, 0, 0, 180, 2392, 1, 0, 0, 0, 182, 2407,
		1, 0, 0, 0, 184, 2417, 1, 0, 0, 0, 186, 2419, 1, 0, 0, 0, 188, 2443, 1,
		0, 0, 0, 190, 2458, 1, 0, 0, 0, 192, 2474, 1, 0, 0, 0, 194, 2485, 1, 0,
		0, 0, 196, 2487, 1, 0, 0, 0, 198, 301, 5, 95, 0, 0, 199, 301, 5, 96, 0,
		0, 200, 301, 3, 2, 1, 0, 201, 205, 5, 47, 0, 0, 202, 204, 3, 196, 98, 0,
		203, 202, 1, 0, 0, 0, 204, 207, 1, 0, 0, 0, 205, 203, 1, 0, 0, 0, 205,
		206, 1, 0, 0, 0, 206, 208, 1, 0, 0, 0, 207, 205, 1, 0, 0, 0, 208, 212,
		3, 40, 20, 0, 209, 211, 3, 196, 98, 0, 210, 209, 1, 0, 0, 0, 211, 214,
		1, 0, 0, 0, 212, 210, 1, 0, 0, 0, 212, 213, 1, 0, 0, 0, 213, 215, 1, 0,
		0, 0, 214, 212, 1, 0, 0, 0, 215, 216, 5, 48, 0, 0, 216, 301, 1, 0, 0, 0,
		217, 301, 3, 4, 2, 0, 218, 220, 5, 102, 0, 0, 219, 218, 1, 0, 0, 0, 219,
		220, 1, 0, 0, 0, 220, 221, 1, 0, 0, 0, 221, 225, 5, 47, 0, 0, 222, 224,
		3, 196, 98, 0, 223, 222, 1, 0, 0, 0, 224, 227, 1, 0, 0, 0, 225, 223, 1,
		0, 0, 0, 225, 226, 1, 0, 0, 0, 226, 228, 1, 0, 0, 0, 227, 225, 1, 0, 0,
		0, 228, 232, 3, 156, 78, 0, 229, 231, 3, 196, 98, 0, 230, 229, 1, 0, 0,
		0, 231, 234, 1, 0, 0, 0, 232, 230, 1, 0, 0, 0, 232, 233, 1, 0, 0, 0, 233,
		235, 1, 0, 0, 0, 234, 232, 1, 0, 0, 0, 235, 236, 5, 48, 0, 0, 236, 301,
		1, 0, 0, 0, 237, 238, 5, 103, 0, 0, 238, 242, 5, 47, 0, 0, 239, 241, 3,
		196, 98, 0, 240, 239, 1, 0, 0, 0, 241, 244, 1, 0, 0, 0, 242, 240, 1, 0,
		0, 0, 242, 243, 1, 0, 0, 0, 243, 245, 1, 0, 0, 0, 244, 242, 1, 0, 0, 0,
		245, 249, 3, 22, 11, 0, 246, 248, 3, 196, 98, 0, 247, 246, 1, 0, 0, 0,
		248, 251, 1, 0, 0, 0, 249, 247, 1, 0, 0, 0, 249, 250, 1, 0, 0, 0, 250,
		252, 1, 0, 0, 0, 251, 249, 1, 0, 0, 0, 252, 256, 5, 76, 0, 0, 253, 255,
		3, 196, 98, 0, 254, 253, 1, 0, 0, 0, 255, 258, 1, 0, 0, 0, 256, 254, 1,
		0, 0, 0, 256, 257, 1, 0, 0, 0, 257, 259, 1, 0, 0, 0, 258, 256, 1, 0, 0,
		0, 259, 263, 3, 120, 60, 0, 260, 262, 3, 196, 98, 0, 261, 260, 1, 0, 0,
		0, 262, 265, 1, 0, 0, 0, 263, 261, 1, 0, 0, 0, 263, 264, 1, 0, 0, 0, 264,
		266, 1, 0, 0, 0, 265, 263, 1, 0, 0, 0, 266, 267, 5, 48, 0, 0, 267, 301,
		1, 0, 0, 0, 268, 269, 5, 104, 0, 0, 269, 273, 5, 47, 0, 0, 270, 272, 3,
		196, 98, 0, 271, 270, 1, 0, 0, 0, 272, 275, 1, 0, 0, 0, 273, 271, 1, 0,
		0, 0, 273, 274, 1, 0, 0, 0, 274, 276, 1, 0, 0, 0, 275, 273, 1, 0, 0, 0,
		276, 280, 3, 120, 60, 0, 277, 279, 3, 196, 98, 0, 278, 277, 1, 0, 0, 0,
		279, 282, 1, 0, 0, 0, 280, 278, 1, 0, 0, 0, 280, 281, 1, 0, 0, 0, 281,
		283, 1, 0, 0, 0, 282, 280, 1, 0, 0, 0, 283, 287, 5, 76, 0, 0, 284, 286,
		3, 196, 98, 0, 285, 284, 1, 0, 0, 0, 286, 289, 1, 0, 0, 0, 287, 285, 1,
		0, 0, 0, 287, 288, 1, 0, 0, 0, 288, 290, 1, 0, 0, 0, 289, 287, 1, 0, 0,
		0, 290, 294, 3, 22, 11, 0, 291, 293, 3, 196, 98, 0, 292, 291, 1, 0, 0,
		0, 293, 296, 1, 0, 0, 0, 294, 292, 1, 0, 0, 0, 294, 295, 1, 0, 0, 0, 295,
		297, 1, 0, 0, 0, 296, 294, 1, 0, 0, 0, 297, 298, 5, 48, 0, 0, 298, 301,
		1, 0, 0, 0, 299, 301, 3, 186, 93, 0, 300, 198, 1, 0, 0, 0, 300, 199, 1,
		0, 0, 0, 300, 200, 1, 0, 0, 0, 300, 201, 1, 0, 0, 0, 300, 217, 1, 0, 0,
		0, 300, 219, 1, 0, 0, 0, 300, 237, 1, 0, 0, 0, 300, 268, 1, 0, 0, 0, 300,
		299, 1, 0, 0, 0, 301, 1, 1, 0, 0, 0, 302, 308, 5, 98, 0, 0, 303, 307, 5,
		98, 0, 0, 304, 305, 5, 95, 0, 0, 305, 307, 5, 98, 0, 0, 306, 303, 1, 0,
		0, 0, 306, 304, 1, 0, 0, 0, 307, 310, 1, 0, 0, 0, 308, 306, 1, 0, 0, 0,
		308, 309, 1, 0, 0, 0, 309, 312, 1, 0, 0, 0, 310, 308, 1, 0, 0, 0, 311,
		313, 5, 95, 0, 0, 312, 311, 1, 0, 0, 0, 312, 313, 1, 0, 0, 0, 313, 3, 1,
		0, 0, 0, 314, 315, 5, 42, 0, 0, 315, 319, 5, 47, 0, 0, 316, 318, 3, 196,
		98, 0, 317, 316, 1, 0, 0, 0, 318, 321, 1, 0, 0, 0, 319, 317, 1, 0, 0, 0,
		319, 320, 1, 0, 0, 0, 320, 322, 1, 0, 0, 0, 321, 319, 1, 0, 0, 0, 322,
		326, 3, 26, 13, 0, 323, 325, 3, 196, 98, 0, 324, 323, 1, 0, 0, 0, 325,
		328, 1, 0, 0, 0, 326, 324, 1, 0, 0, 0, 326, 327, 1, 0, 0, 0, 327, 329,
		1, 0, 0, 0, 328, 326, 1, 0, 0, 0, 329, 333, 5, 76, 0, 0, 330, 332, 3, 196,
		98, 0, 331, 330, 1, 0, 0, 0, 332, 335, 1, 0, 0, 0, 333, 331, 1, 0, 0, 0,
		333, 334, 1, 0, 0, 0, 334, 336, 1, 0, 0, 0, 335, 333, 1, 0, 0, 0, 336,
		340, 3, 6, 3, 0, 337, 339, 3, 196, 98, 0, 338, 337, 1, 0, 0, 0, 339, 342,
		1, 0, 0, 0, 340, 338, 1, 0, 0, 0, 340, 341, 1, 0, 0, 0, 341, 343, 1, 0,
		0, 0, 342, 340, 1, 0, 0, 0, 343, 344, 5, 48, 0, 0, 344, 5, 1, 0, 0, 0,
		345, 356, 3, 8, 4, 0, 346, 350, 5, 76, 0, 0, 347, 349, 3, 196, 98, 0, 348,
		347, 1, 0, 0, 0, 349, 352, 1, 0, 0, 0, 350, 348, 1, 0, 0, 0, 350, 351,
		1, 0, 0, 0, 351, 353, 1, 0, 0, 0, 352, 350, 1, 0, 0, 0, 353, 355, 3, 8,
		4, 0, 354, 346, 1, 0, 0, 0, 355, 358, 1, 0, 0, 0, 356, 354, 1, 0, 0, 0,
		356, 357, 1, 0, 0, 0, 357, 7, 1, 0, 0, 0, 358, 356, 1, 0, 0, 0, 359, 362,
		3, 120, 60, 0, 360, 362, 5, 7, 0, 0, 361, 359, 1, 0, 0, 0, 361, 360, 1,
		0, 0, 0, 362, 363, 1, 0, 0, 0, 363, 364, 5, 74, 0, 0, 364, 365, 3, 26,
		13, 0, 365, 9, 1, 0, 0, 0, 366, 381, 3, 0, 0, 0, 367, 369, 5, 102, 0, 0,
		368, 367, 1, 0, 0, 0, 368, 369, 1, 0, 0, 0, 369, 370, 1, 0, 0, 0, 370,
		371, 5, 47, 0, 0, 371, 372, 3, 120, 60, 0, 372, 373, 5, 48, 0, 0, 373,
		374, 5, 51, 0, 0, 374, 376, 3, 136, 68, 0, 375, 377, 5, 76, 0, 0, 376,
		375, 1, 0, 0, 0, 376, 377, 1, 0, 0, 0, 377, 378, 1, 0, 0, 0, 378, 379,
		5, 52, 0, 0, 379, 381, 1, 0, 0, 0, 380, 366, 1, 0, 0, 0, 380, 368, 1, 0,
		0, 0, 381, 385, 1, 0, 0, 0, 382, 384, 3, 12, 6, 0, 383, 382, 1, 0, 0, 0,
		384, 387, 1, 0, 0, 0, 385, 383, 1, 0, 0, 0, 385, 386, 1, 0, 0, 0, 386,
		395, 1, 0, 0, 0, 387, 385, 1, 0, 0, 0, 388, 389, 3, 38, 19, 0, 389, 390,
		5, 60, 0, 0, 390, 395, 1, 0, 0, 0, 391, 392, 3, 38, 19, 0, 392, 393, 5,
		62, 0, 0, 393, 395, 1, 0, 0, 0, 394, 380, 1, 0, 0, 0, 394, 388, 1, 0, 0,
		0, 394, 391, 1, 0, 0, 0, 395, 11, 1, 0, 0, 0, 396, 400, 5, 49, 0, 0, 397,
		399, 3, 196, 98, 0, 398, 397, 1, 0, 0, 0, 399, 402, 1, 0, 0, 0, 400, 398,
		1, 0, 0, 0, 400, 401, 1, 0, 0, 0, 401, 403, 1, 0, 0, 0, 402, 400, 1, 0,
		0, 0, 403, 407, 3, 40, 20, 0, 404, 406, 3, 196, 98, 0, 405, 404, 1, 0,
		0, 0, 406, 409, 1, 0, 0, 0, 407, 405, 1, 0, 0, 0, 407, 408, 1, 0, 0, 0,
		408, 410, 1, 0, 0, 0, 409, 407, 1, 0, 0, 0, 410, 411, 5, 50, 0, 0, 411,
		432, 1, 0, 0, 0, 412, 416, 5, 47, 0, 0, 413, 415, 3, 196, 98, 0, 414, 413,
		1, 0, 0, 0, 415, 418, 1, 0, 0, 0, 416, 414, 1, 0, 0, 0, 416, 417, 1, 0,
		0, 0, 417, 420, 1, 0, 0, 0, 418, 416, 1, 0, 0, 0, 419, 421, 3, 18, 9, 0,
		420, 419, 1, 0, 0, 0, 420, 421, 1, 0, 0, 0, 421, 425, 1, 0, 0, 0, 422,
		424, 3, 196, 98, 0, 423, 422, 1, 0, 0, 0, 424, 427, 1, 0, 0, 0, 425, 423,
		1, 0, 0, 0, 425, 426, 1, 0, 0, 0, 426, 428, 1, 0, 0, 0, 427, 425, 1, 0,
		0, 0, 428, 432, 5, 48, 0, 0, 429, 430, 7, 0, 0, 0, 430, 432, 5, 95, 0,
		0, 431, 396, 1, 0, 0, 0, 431, 412, 1, 0, 0, 0, 431, 429, 1, 0, 0, 0, 432,
		13, 1, 0, 0, 0, 433, 448, 3, 0, 0, 0, 434, 436, 5, 102, 0, 0, 435, 434,
		1, 0, 0, 0, 435, 436, 1, 0, 0, 0, 436, 437, 1, 0, 0, 0, 437, 438, 5, 47,
		0, 0, 438, 439, 3, 120, 60, 0, 439, 440, 5, 48, 0, 0, 440, 441, 5, 51,
		0, 0, 441, 443, 3, 136, 68, 0, 442, 444, 5, 76, 0, 0, 443, 442, 1, 0, 0,
		0, 443, 444, 1, 0, 0, 0, 444, 445, 1, 0, 0, 0, 445, 446, 5, 52, 0, 0, 446,
		448, 1, 0, 0, 0, 447, 433, 1, 0, 0, 0, 447, 435, 1, 0, 0, 0, 448, 452,
		1, 0, 0, 0, 449, 451, 3, 16, 8, 0, 450, 449, 1, 0, 0, 0, 451, 454, 1, 0,
		0, 0, 452, 450, 1, 0, 0, 0, 452, 453, 1, 0, 0, 0, 453, 457, 1, 0, 0, 0,
		454, 452, 1, 0, 0, 0, 455, 457, 3, 16, 8, 0, 456, 447, 1, 0, 0, 0, 456,
		455, 1, 0, 0, 0, 457, 15, 1, 0, 0, 0, 458, 459, 6, 8, -1, 0, 459, 463,
		5, 49, 0, 0, 460, 462, 3, 196, 98, 0, 461, 460, 1, 0, 0, 0, 462, 465, 1,
		0, 0, 0, 463, 461, 1, 0, 0, 0, 463, 464, 1, 0, 0, 0, 464, 466, 1, 0, 0,
		0, 465, 463, 1, 0, 0, 0, 466, 470, 3, 40, 20, 0, 467, 469, 3, 196, 98,
		0, 468, 467, 1, 0, 0, 0, 469, 472, 1, 0, 0, 0, 470, 468, 1, 0, 0, 0, 470,
		471, 1, 0, 0, 0, 471, 473, 1, 0, 0, 0, 472, 470, 1, 0, 0, 0, 473, 474,
		5, 50, 0, 0, 474, 478, 1, 0, 0, 0, 475, 476, 7, 0, 0, 0, 476, 478, 5, 95,
		0, 0, 477, 458, 1, 0, 0, 0, 477, 475, 1, 0, 0, 0, 478, 484, 1, 0, 0, 0,
		479, 480, 10, 2, 0, 0, 480, 481, 7, 0, 0, 0, 481, 483, 5, 95, 0, 0, 482,
		479, 1, 0, 0, 0, 483, 486, 1, 0, 0, 0, 484, 482, 1, 0, 0, 0, 484, 485,
		1, 0, 0, 0, 485, 17, 1, 0, 0, 0, 486, 484, 1, 0, 0, 0, 487, 498, 3, 20,
		10, 0, 488, 492, 5, 76, 0, 0, 489, 491, 3, 196, 98, 0, 490, 489, 1, 0,
		0, 0, 491, 494, 1, 0, 0, 0, 492, 490, 1, 0, 0, 0, 492, 493, 1, 0, 0, 0,
		493, 495, 1, 0, 0, 0, 494, 492, 1, 0, 0, 0, 495, 497, 3, 20, 10, 0, 496,
		488, 1, 0, 0, 0, 497, 500, 1, 0, 0, 0, 498, 496, 1, 0, 0, 0, 498, 499,
		1, 0, 0, 0, 499, 19, 1, 0, 0, 0, 500, 498, 1, 0, 0, 0, 501, 509, 3, 40,
		20, 0, 502, 509, 3, 120, 60, 0, 503, 505, 5, 97, 0, 0, 504, 506, 5, 95,
		0, 0, 505, 504, 1, 0, 0, 0, 505, 506, 1, 0, 0, 0, 506, 509, 1, 0, 0, 0,
		507, 509, 7, 1, 0, 0, 508, 501, 1, 0, 0, 0, 508, 502, 1, 0, 0, 0, 508,
		503, 1, 0, 0, 0, 508, 507, 1, 0, 0, 0, 509, 21, 1, 0, 0, 0, 510, 514, 7,
		2, 0, 0, 511, 513, 3, 196, 98, 0, 512, 511, 1, 0, 0, 0, 513, 516, 1, 0,
		0, 0, 514, 512, 1, 0, 0, 0, 514, 515, 1, 0, 0, 0, 515, 517, 1, 0, 0, 0,
		516, 514, 1, 0, 0, 0, 517, 584, 3, 38, 19, 0, 518, 522, 5, 63, 0, 0, 519,
		521, 3, 196, 98, 0, 520, 519, 1, 0, 0, 0, 521, 524, 1, 0, 0, 0, 522, 520,
		1, 0, 0, 0, 522, 523, 1, 0, 0, 0, 523, 525, 1, 0, 0, 0, 524, 522, 1, 0,
		0, 0, 525, 584, 3, 22, 11, 0, 526, 530, 5, 66, 0, 0, 527, 529, 3, 196,
		98, 0, 528, 527, 1, 0, 0, 0, 529, 532, 1, 0, 0, 0, 530, 528, 1, 0, 0, 0,
		530, 531, 1, 0, 0, 0, 531, 533, 1, 0, 0, 0, 532, 530, 1, 0, 0, 0, 533,
		584, 3, 38, 19, 0, 534, 538, 7, 3, 0, 0, 535, 537, 3, 196, 98, 0, 536,
		535, 1, 0, 0, 0, 537, 540, 1, 0, 0, 0, 538, 536, 1, 0, 0, 0, 538, 539,
		1, 0, 0, 0, 539, 541, 1, 0, 0, 0, 540, 538, 1, 0, 0, 0, 541, 584, 3, 22,
		11, 0, 542, 543, 7, 3, 0, 0, 543, 547, 5, 47, 0, 0, 544, 546, 3, 196, 98,
		0, 545, 544, 1, 0, 0, 0, 546, 549, 1, 0, 0, 0, 547, 545, 1, 0, 0, 0, 547,
		548, 1, 0, 0, 0, 548, 564, 1, 0, 0, 0, 549, 547, 1, 0, 0, 0, 550, 552,
		5, 63, 0, 0, 551, 550, 1, 0, 0, 0, 552, 555, 1, 0, 0, 0, 553, 551, 1, 0,
		0, 0, 553, 554, 1, 0, 0, 0, 554, 559, 1, 0, 0, 0, 555, 553, 1, 0, 0, 0,
		556, 558, 3, 196, 98, 0, 557, 556, 1, 0, 0, 0, 558, 561, 1, 0, 0, 0, 559,
		557, 1, 0, 0, 0, 559, 560, 1, 0, 0, 0, 560, 562, 1, 0, 0, 0, 561, 559,
		1, 0, 0, 0, 562, 565, 3, 120, 60, 0, 563, 565, 3, 22, 11, 0, 564, 553,
		1, 0, 0, 0, 564, 563, 1, 0, 0, 0, 565, 569, 1, 0, 0, 0, 566, 568, 3, 196,
		98, 0, 567, 566, 1, 0, 0, 0, 568, 571, 1, 0, 0, 0, 569, 567, 1, 0, 0, 0,
		569, 570, 1, 0, 0, 0, 570, 572, 1, 0, 0, 0, 571, 569, 1, 0, 0, 0, 572,
		573, 5, 48, 0, 0, 573, 584, 1, 0, 0, 0, 574, 578, 5, 68, 0, 0, 575, 577,
		3, 196, 98, 0, 576, 575, 1, 0, 0, 0, 577, 580, 1, 0, 0, 0, 578, 576, 1,
		0, 0, 0, 578, 579, 1, 0, 0, 0, 579, 581, 1, 0, 0, 0, 580, 578, 1, 0, 0,
		0, 581, 584, 3, 22, 11, 0, 582, 584, 3, 10, 5, 0, 583, 510, 1, 0, 0, 0,
		583, 518, 1, 0, 0, 0, 583, 526, 1, 0, 0, 0, 583, 534, 1, 0, 0, 0, 583,
		542, 1, 0, 0, 0, 583, 574, 1, 0, 0, 0, 583, 582, 1, 0, 0, 0, 584, 23, 1,
		0, 0, 0, 585, 587, 5, 102, 0, 0, 586, 585, 1, 0, 0, 0, 586, 587, 1, 0,
		0, 0, 587, 588, 1, 0, 0, 0, 588, 592, 5, 47, 0, 0, 589, 591, 3, 196, 98,
		0, 590, 589, 1, 0, 0, 0, 591, 594, 1, 0, 0, 0, 592, 590, 1, 0, 0, 0, 592,
		593, 1, 0, 0, 0, 593, 595, 1, 0, 0, 0, 594, 592, 1, 0, 0, 0, 595, 599,
		3, 120, 60, 0, 596, 598, 3, 196, 98, 0, 597, 596, 1, 0, 0, 0, 598, 601,
		1, 0, 0, 0, 599, 597, 1, 0, 0, 0, 599, 600, 1, 0, 0, 0, 600, 602, 1, 0,
		0, 0, 601, 599, 1, 0, 0, 0, 602, 606, 5, 48, 0, 0, 603, 605, 3, 196, 98,
		0, 604, 603, 1, 0, 0, 0, 605, 608, 1, 0, 0, 0, 606, 604, 1, 0, 0, 0, 606,
		607, 1, 0, 0, 0, 607, 609, 1, 0, 0, 0, 608, 606, 1, 0, 0, 0, 609, 610,
		3, 24, 12, 0, 610, 614, 1, 0, 0, 0, 611, 614, 3, 22, 11, 0, 612, 614, 5,
		97, 0, 0, 613, 586, 1, 0, 0, 0, 613, 611, 1, 0, 0, 0, 613, 612, 1, 0, 0,
		0, 614, 25, 1, 0, 0, 0, 615, 618, 3, 28, 14, 0, 616, 618, 3, 24, 12, 0,
		617, 615, 1, 0, 0, 0, 617, 616, 1, 0, 0, 0, 618, 27, 1, 0, 0, 0, 619, 623,
		3, 38, 19, 0, 620, 622, 3, 196, 98, 0, 621, 620, 1, 0, 0, 0, 622, 625,
		1, 0, 0, 0, 623, 621, 1, 0, 0, 0, 623, 624, 1, 0, 0, 0, 624, 626, 1, 0,
		0, 0, 625, 623, 1, 0, 0, 0, 626, 630, 3, 32, 16, 0, 627, 629, 3, 196, 98,
		0, 628, 627, 1, 0, 0, 0, 629, 632, 1, 0, 0, 0, 630, 628, 1, 0, 0, 0, 630,
		631, 1, 0, 0, 0, 631, 633, 1, 0, 0, 0, 632, 630, 1, 0, 0, 0, 633, 634,
		3, 40, 20, 0, 634, 29, 1, 0, 0, 0, 635, 646, 3, 28, 14, 0, 636, 640, 5,
		76, 0, 0, 637, 639, 3, 196, 98, 0, 638, 637, 1, 0, 0, 0, 639, 642, 1, 0,
		0, 0, 640, 638, 1, 0, 0, 0, 640, 641, 1, 0, 0, 0, 641, 643, 1, 0, 0, 0,
		642, 640, 1, 0, 0, 0, 643, 645, 3, 28, 14, 0, 644, 636, 1, 0, 0, 0, 645,
		648, 1, 0, 0, 0, 646, 644, 1, 0, 0, 0, 646, 647, 1, 0, 0, 0, 647, 31, 1,
		0, 0, 0, 648, 646, 1, 0, 0, 0, 649, 650, 7, 4, 0, 0, 650, 33, 1, 0, 0,
		0, 651, 662, 3, 40, 20, 0, 652, 656, 5, 76, 0, 0, 653, 655, 3, 196, 98,
		0, 654, 653, 1, 0, 0, 0, 655, 658, 1, 0, 0, 0, 656, 654, 1, 0, 0, 0, 656,
		657, 1, 0, 0, 0, 657, 659, 1, 0, 0, 0, 658, 656, 1, 0, 0, 0, 659, 661,
		3, 40, 20, 0, 660, 652, 1, 0, 0, 0, 661, 664, 1, 0, 0, 0, 662, 660, 1,
		0, 0, 0, 662, 663, 1, 0, 0, 0, 663, 35, 1, 0, 0, 0, 664, 662, 1, 0, 0,
		0, 665, 666, 5, 47, 0, 0, 666, 670, 5, 51, 0, 0, 667, 669, 3, 146, 73,
		0, 668, 667, 1, 0, 0, 0, 669, 672, 1, 0, 0, 0, 670, 668, 1, 0, 0, 0, 670,
		671, 1, 0, 0, 0, 671, 674, 1, 0, 0, 0, 672, 670, 1, 0, 0, 0, 673, 675,
		3, 40, 20, 0, 674, 673, 1, 0, 0, 0, 674, 675, 1, 0, 0, 0, 675, 677, 1,
		0, 0, 0, 676, 678, 5, 75, 0, 0, 677, 676, 1, 0, 0, 0, 677, 678, 1, 0, 0,
		0, 678, 679, 1, 0, 0, 0, 679, 680, 5, 52, 0, 0, 680, 681, 5, 48, 0, 0,
		681, 37, 1, 0, 0, 0, 682, 686, 5, 63, 0, 0, 683, 685, 3, 196, 98, 0, 684,
		683, 1, 0, 0, 0, 685, 688, 1, 0, 0, 0, 686, 684, 1, 0, 0, 0, 686, 687,
		1, 0, 0, 0, 687, 689, 1, 0, 0, 0, 688, 686, 1, 0, 0, 0, 689, 716, 3, 22,
		11, 0, 690, 694, 5, 63, 0, 0, 691, 693, 3, 196, 98, 0, 692, 691, 1, 0,
		0, 0, 693, 696, 1, 0, 0, 0, 694, 692, 1, 0, 0, 0, 694, 695, 1, 0, 0, 0,
		695, 697, 1, 0, 0, 0, 696, 694, 1, 0, 0, 0, 697, 716, 3, 24, 12, 0, 698,
		716, 3, 14, 7, 0, 699, 703, 5, 47, 0, 0, 700, 702, 3, 196, 98, 0, 701,
		700, 1, 0, 0, 0, 702, 705, 1, 0, 0, 0, 703, 701, 1, 0, 0, 0, 703, 704,
		1, 0, 0, 0, 704, 706, 1, 0, 0, 0, 705, 703, 1, 0, 0, 0, 706, 710, 3, 38,
		19, 0, 707, 709, 3, 196, 98, 0, 708, 707, 1, 0, 0, 0, 709, 712, 1, 0, 0,
		0, 710, 708, 1, 0, 0, 0, 710, 711, 1, 0, 0, 0, 711, 713, 1, 0, 0, 0, 712,
		710, 1, 0, 0, 0, 713, 714, 5, 48, 0, 0, 714, 716, 1, 0, 0, 0, 715, 682,
		1, 0, 0, 0, 715, 690, 1, 0, 0, 0, 715, 698, 1, 0, 0, 0, 715, 699, 1, 0,
		0, 0, 716, 39, 1, 0, 0, 0, 717, 718, 6, 20, -1, 0, 718, 722, 7, 5, 0, 0,
		719, 721, 3, 196, 98, 0, 720, 719, 1, 0, 0, 0, 721, 724, 1, 0, 0, 0, 722,
		720, 1, 0, 0, 0, 722, 723, 1, 0, 0, 0, 723, 725, 1, 0, 0, 0, 724, 722,
		1, 0, 0, 0, 725, 746, 3, 40, 20, 11, 726, 730, 5, 47, 0, 0, 727, 729, 3,
		196, 98, 0, 728, 727, 1, 0, 0, 0, 729, 732, 1, 0, 0, 0, 730, 728, 1, 0,
		0, 0, 730, 731, 1, 0, 0, 0, 731, 733, 1, 0, 0, 0, 732, 730, 1, 0, 0, 0,
		733, 737, 3, 40, 20, 0, 734, 736, 3, 196, 98, 0, 735, 734, 1, 0, 0, 0,
		736, 739, 1, 0, 0, 0, 737, 735, 1, 0, 0, 0, 737, 738, 1, 0, 0, 0, 738,
		740, 1, 0, 0, 0, 739, 737, 1, 0, 0, 0, 740, 741, 5, 48, 0, 0, 741, 746,
		1, 0, 0, 0, 742, 746, 3, 24, 12, 0, 743, 746, 3, 36, 18, 0, 744, 746, 3,
		48, 24, 0, 745, 717, 1, 0, 0, 0, 745, 726, 1, 0, 0, 0, 745, 742, 1, 0,
		0, 0, 745, 743, 1, 0, 0, 0, 745, 744, 1, 0, 0, 0, 746, 812, 1, 0, 0, 0,
		747, 748, 10, 10, 0, 0, 748, 752, 7, 6, 0, 0, 749, 751, 3, 196, 98, 0,
		750, 749, 1, 0, 0, 0, 751, 754, 1, 0, 0, 0, 752, 750, 1, 0, 0, 0, 752,
		753, 1, 0, 0, 0, 753, 755, 1, 0, 0, 0, 754, 752, 1, 0, 0, 0, 755, 811,
		3, 40, 20, 11, 756, 757, 10, 9, 0, 0, 757, 761, 7, 7, 0, 0, 758, 760, 3,
		196, 98, 0, 759, 758, 1, 0, 0, 0, 760, 763, 1, 0, 0, 0, 761, 759, 1, 0,
		0, 0, 761, 762, 1, 0, 0, 0, 762, 764, 1, 0, 0, 0, 763, 761, 1, 0, 0, 0,
		764, 811, 3, 40, 20, 10, 765, 766, 10, 8, 0, 0, 766, 770, 7, 8, 0, 0, 767,
		769, 3, 196, 98, 0, 768, 767, 1, 0, 0, 0, 769, 772, 1, 0, 0, 0, 770, 768,
		1, 0, 0, 0, 770, 771, 1, 0, 0, 0, 771, 773, 1, 0, 0, 0, 772, 770, 1, 0,
		0, 0, 773, 811, 3, 40, 20, 9, 774, 775, 10, 7, 0, 0, 775, 779, 5, 68, 0,
		0, 776, 778, 3, 196, 98, 0, 777, 776, 1, 0, 0, 0, 778, 781, 1, 0, 0, 0,
		779, 777, 1, 0, 0, 0, 779, 780, 1, 0, 0, 0, 780, 782, 1, 0, 0, 0, 781,
		779, 1, 0, 0, 0, 782, 811, 3, 40, 20, 8, 783, 784, 10, 6, 0, 0, 784, 788,
		5, 69, 0, 0, 785, 787, 3, 196, 98, 0, 786, 785, 1, 0, 0, 0, 787, 790, 1,
		0, 0, 0, 788, 786, 1, 0, 0, 0, 788, 789, 1, 0, 0, 0, 789, 791, 1, 0, 0,
		0, 790, 788, 1, 0, 0, 0, 791, 811, 3, 40, 20, 7, 792, 793, 10, 4, 0, 0,
		793, 797, 5, 73, 0, 0, 794, 796, 3, 196, 98, 0, 795, 794, 1, 0, 0, 0, 796,
		799, 1, 0, 0, 0, 797, 795, 1, 0, 0, 0, 797, 798, 1, 0, 0, 0, 798, 800,
		1, 0, 0, 0, 799, 797, 1, 0, 0, 0, 800, 801, 3, 40, 20, 0, 801, 805, 5,
		74, 0, 0, 802, 804, 3, 196, 98, 0, 803, 802, 1, 0, 0, 0, 804, 807, 1, 0,
		0, 0, 805, 803, 1, 0, 0, 0, 805, 806, 1, 0, 0, 0, 806, 808, 1, 0, 0, 0,
		807, 805, 1, 0, 0, 0, 808, 809, 3, 40, 20, 0, 809, 811, 1, 0, 0, 0, 810,
		747, 1, 0, 0, 0, 810, 756, 1, 0, 0, 0, 810, 765, 1, 0, 0, 0, 810, 774,
		1, 0, 0, 0, 810, 783, 1, 0, 0, 0, 810, 792, 1, 0, 0, 0, 811, 814, 1, 0,
		0, 0, 812, 810, 1, 0, 0, 0, 812, 813, 1, 0, 0, 0, 813, 41, 1, 0, 0, 0,
		814, 812, 1, 0, 0, 0, 815, 819, 3, 48, 24, 0, 816, 818, 3, 196, 98, 0,
		817, 816, 1, 0, 0, 0, 818, 821, 1, 0, 0, 0, 819, 817, 1, 0, 0, 0, 819,
		820, 1, 0, 0, 0, 820, 823, 1, 0, 0, 0, 821, 819, 1, 0, 0, 0, 822, 824,
		3, 50, 25, 0, 823, 822, 1, 0, 0, 0, 823, 824, 1, 0, 0, 0, 824, 828, 1,
		0, 0, 0, 825, 827, 3, 196, 98, 0, 826, 825, 1, 0, 0, 0, 827, 830, 1, 0,
		0, 0, 828, 826, 1, 0, 0, 0, 828, 829, 1, 0, 0, 0, 829, 831, 1, 0, 0, 0,
		830, 828, 1, 0, 0, 0, 831, 832, 5, 75, 0, 0, 832, 860, 1, 0, 0, 0, 833,
		837, 3, 186, 93, 0, 834, 836, 3, 90, 45, 0, 835, 834, 1, 0, 0, 0, 836,
		839, 1, 0, 0, 0, 837, 835, 1, 0, 0, 0, 837, 838, 1, 0, 0, 0, 838, 843,
		1, 0, 0, 0, 839, 837, 1, 0, 0, 0, 840, 842, 3, 196, 98, 0, 841, 840, 1,
		0, 0, 0, 842, 845, 1, 0, 0, 0, 843, 841, 1, 0, 0, 0, 843, 844, 1, 0, 0,
		0, 844, 848, 1, 0, 0, 0, 845, 843, 1, 0, 0, 0, 846, 847, 5, 77, 0, 0, 847,
		849, 3, 134, 67, 0, 848, 846, 1, 0, 0, 0, 848, 849, 1, 0, 0, 0, 849, 853,
		1, 0, 0, 0, 850, 852, 3, 196, 98, 0, 851, 850, 1, 0, 0, 0, 852, 855, 1,
		0, 0, 0, 853, 851, 1, 0, 0, 0, 853, 854, 1, 0, 0, 0, 854, 856, 1, 0, 0,
		0, 855, 853, 1, 0, 0, 0, 856, 857, 5, 75, 0, 0, 857, 860, 1, 0, 0, 0, 858,
		860, 3, 144, 72, 0, 859, 815, 1, 0, 0, 0, 859, 833, 1, 0, 0, 0, 859, 858,
		1, 0, 0, 0, 860, 43, 1, 0, 0, 0, 861, 870, 3, 48, 24, 0, 862, 866, 5, 76,
		0, 0, 863, 865, 3, 196, 98, 0, 864, 863, 1, 0, 0, 0, 865, 868, 1, 0, 0,
		0, 866, 864, 1, 0, 0, 0, 866, 867, 1, 0, 0, 0, 867, 869, 1, 0, 0, 0, 868,
		866, 1, 0, 0, 0, 869, 871, 3, 48, 24, 0, 870, 862, 1, 0, 0, 0, 870, 871,
		1, 0, 0, 0, 871, 45, 1, 0, 0, 0, 872, 881, 3, 48, 24, 0, 873, 877, 5, 76,
		0, 0, 874, 876, 3, 196, 98, 0, 875, 874, 1, 0, 0, 0, 876, 879, 1, 0, 0,
		0, 877, 875, 1, 0, 0, 0, 877, 878, 1, 0, 0, 0, 878, 880, 1, 0, 0, 0, 879,
		877, 1, 0, 0, 0, 880, 882, 3, 48, 24, 0, 881, 873, 1, 0, 0, 0, 881, 882,
		1, 0, 0, 0, 882, 47, 1, 0, 0, 0, 883, 887, 3, 54, 27, 0, 884, 887, 3, 80,
		40, 0, 885, 887, 3, 82, 41, 0, 886, 883, 1, 0, 0, 0, 886, 884, 1, 0, 0,
		0, 886, 885, 1, 0, 0, 0, 887, 890, 1, 0, 0, 0, 888, 886, 1, 0, 0, 0, 888,
		889, 1, 0, 0, 0, 889, 892, 1, 0, 0, 0, 890, 888, 1, 0, 0, 0, 891, 893,
		3, 60, 30, 0, 892, 891, 1, 0, 0, 0, 892, 893, 1, 0, 0, 0, 893, 896, 1,
		0, 0, 0, 894, 897, 3, 56, 28, 0, 895, 897, 5, 95, 0, 0, 896, 894, 1, 0,
		0, 0, 896, 895, 1, 0, 0, 0, 897, 901, 1, 0, 0, 0, 898, 900, 3, 80, 40,
		0, 899, 898, 1, 0, 0, 0, 900, 903, 1, 0, 0, 0, 901, 899, 1, 0, 0, 0, 901,
		902, 1, 0, 0, 0, 902, 906, 1, 0, 0, 0, 903, 901, 1, 0, 0, 0, 904, 906,
		3, 84, 42, 0, 905, 888, 1, 0, 0, 0, 905, 904, 1, 0, 0, 0, 906, 49, 1, 0,
		0, 0, 907, 918, 3, 52, 26, 0, 908, 912, 5, 76, 0, 0, 909, 911, 3, 196,
		98, 0, 910, 909, 1, 0, 0, 0, 911, 914, 1, 0, 0, 0, 912, 910, 1, 0, 0, 0,
		912, 913, 1, 0, 0, 0, 913, 915, 1, 0, 0, 0, 914, 912, 1, 0, 0, 0, 915,
		917, 3, 52, 26, 0, 916, 908, 1, 0, 0, 0, 917, 920, 1, 0, 0, 0, 918, 916,
		1, 0, 0, 0, 918, 919, 1, 0, 0, 0, 919, 51, 1, 0, 0, 0, 920, 918, 1, 0,
		0, 0, 921, 924, 3, 86, 43, 0, 922, 923, 5, 77, 0, 0, 923, 925, 3, 134,
		67, 0, 924, 922, 1, 0, 0, 0, 924, 925, 1, 0, 0, 0, 925, 53, 1, 0, 0, 0,
		926, 927, 7, 9, 0, 0, 927, 55, 1, 0, 0, 0, 928, 958, 5, 34, 0, 0, 929,
		958, 5, 4, 0, 0, 930, 958, 5, 25, 0, 0, 931, 958, 5, 19, 0, 0, 932, 958,
		5, 20, 0, 0, 933, 958, 5, 21, 0, 0, 934, 958, 5, 14, 0, 0, 935, 958, 5,
		9, 0, 0, 936, 958, 5, 10, 0, 0, 937, 958, 5, 40, 0, 0, 938, 958, 5, 41,
		0, 0, 939, 958, 5, 105, 0, 0, 940, 958, 5, 106, 0, 0, 941, 958, 5, 107,
		0, 0, 942, 943, 5, 102, 0, 0, 943, 944, 5, 47, 0, 0, 944, 945, 7, 10, 0,
		0, 945, 958, 5, 48, 0, 0, 946, 958, 5, 26, 0, 0, 947, 958, 5, 33, 0, 0,
		948, 958, 3, 78, 39, 0, 949, 958, 3, 58, 29, 0, 950, 958, 3, 72, 36, 0,
		951, 958, 3, 132, 66, 0, 952, 953, 5, 108, 0, 0, 953, 954, 5, 47, 0, 0,
		954, 955, 3, 40, 20, 0, 955, 956, 5, 48, 0, 0, 956, 958, 1, 0, 0, 0, 957,
		928, 1, 0, 0, 0, 957, 929, 1, 0, 0, 0, 957, 930, 1, 0, 0, 0, 957, 931,
		1, 0, 0, 0, 957, 932, 1, 0, 0, 0, 957, 933, 1, 0, 0, 0, 957, 934, 1, 0,
		0, 0, 957, 935, 1, 0, 0, 0, 957, 936, 1, 0, 0, 0, 957, 937, 1, 0, 0, 0,
		957, 938, 1, 0, 0, 0, 957, 939, 1, 0, 0, 0, 957, 940, 1, 0, 0, 0, 957,
		941, 1, 0, 0, 0, 957, 942, 1, 0, 0, 0, 957, 946, 1, 0, 0, 0, 957, 947,
		1, 0, 0, 0, 957, 948, 1, 0, 0, 0, 957, 949, 1, 0, 0, 0, 957, 950, 1, 0,
		0, 0, 957, 951, 1, 0, 0, 0, 957, 952, 1, 0, 0, 0, 958, 57, 1, 0, 0, 0,
		959, 963, 3, 60, 30, 0, 960, 962, 3, 196, 98, 0, 961, 960, 1, 0, 0, 0,
		962, 965, 1, 0, 0, 0, 963, 961, 1, 0, 0, 0, 963, 964, 1, 0, 0, 0, 964,
		967, 1, 0, 0, 0, 965, 963, 1, 0, 0, 0, 966, 968, 5, 95, 0, 0, 967, 966,
		1, 0, 0, 0, 967, 968, 1, 0, 0, 0, 968, 969, 1, 0, 0, 0, 969, 973, 5, 51,
		0, 0, 970, 972, 3, 196, 98, 0, 971, 970, 1, 0, 0, 0, 972, 975, 1, 0, 0,
		0, 973, 971, 1, 0, 0, 0, 973, 974, 1, 0, 0, 0, 974, 976, 1, 0, 0, 0, 975,
		973, 1, 0, 0, 0, 976, 980, 3, 62, 31, 0, 977, 979, 3, 196, 98, 0, 978,
		977, 1, 0, 0, 0, 979, 982, 1, 0, 0, 0, 980, 978, 1, 0, 0, 0, 980, 981,
		1, 0, 0, 0, 981, 983, 1, 0, 0, 0, 982, 980, 1, 0, 0, 0, 983, 987, 5, 52,
		0, 0, 984, 986, 3, 196, 98, 0, 985, 984, 1, 0, 0, 0, 986, 989, 1, 0, 0,
		0, 987, 985, 1, 0, 0, 0, 987, 988, 1, 0, 0, 0, 988, 991, 1, 0, 0, 0, 989,
		987, 1, 0, 0, 0, 990, 992, 5, 95, 0, 0, 991, 990, 1, 0, 0, 0, 991, 992,
		1, 0, 0, 0, 992, 59, 1, 0, 0, 0, 993, 994, 7, 11, 0, 0, 994, 61, 1, 0,
		0, 0, 995, 999, 3, 64, 32, 0, 996, 998, 3, 194, 97, 0, 997, 996, 1, 0,
		0, 0, 998, 1001, 1, 0, 0, 0, 999, 997, 1, 0, 0, 0, 999, 1000, 1, 0, 0,
		0, 1000, 1003, 1, 0, 0, 0, 1001, 999, 1, 0, 0, 0, 1002, 995, 1, 0, 0, 0,
		1003, 1004, 1, 0, 0, 0, 1004, 1002, 1, 0, 0, 0, 1004, 1005, 1, 0, 0, 0,
		1005, 63, 1, 0, 0, 0, 1006, 1010, 3, 66, 33, 0, 1007, 1009, 3, 196, 98,
		0, 1008, 1007, 1, 0, 0, 0, 1009, 1012, 1, 0, 0, 0, 1010, 1008, 1, 0, 0,
		0, 1010, 1011, 1, 0, 0, 0, 1011, 1013, 1, 0, 0, 0, 1012, 1010, 1, 0, 0,
		0, 1013, 1017, 3, 68, 34, 0, 1014, 1016, 3, 196, 98, 0, 1015, 1014, 1,
		0, 0, 0, 1016, 1019, 1, 0, 0, 0, 1017, 1015, 1, 0, 0, 0, 1017, 1018, 1,
		0, 0, 0, 1018, 1020, 1, 0, 0, 0, 1019, 1017, 1, 0, 0, 0, 1020, 1021, 5,
		75, 0, 0, 1021, 1033, 1, 0, 0, 0, 1022, 1026, 3, 66, 33, 0, 1023, 1025,
		3, 196, 98, 0, 1024, 1023, 1, 0, 0, 0, 1025, 1028, 1, 0, 0, 0, 1026, 1024,
		1, 0, 0, 0, 1026, 1027, 1, 0, 0, 0, 1027, 1029, 1, 0, 0, 0, 1028, 1026,
		1, 0, 0, 0, 1029, 1030, 5, 75, 0, 0, 1030, 1033, 1, 0, 0, 0, 1031, 1033,
		3, 144, 72, 0, 1032, 1006, 1, 0, 0, 0, 1032, 1022, 1, 0, 0, 0, 1032, 1031,
		1, 0, 0, 0, 1033, 65, 1, 0, 0, 0, 1034, 1037, 3, 56, 28, 0, 1035, 1037,
		3, 80, 40, 0, 1036, 1034, 1, 0, 0, 0, 1036, 1035, 1, 0, 0, 0, 1037, 1039,
		1, 0, 0, 0, 1038, 1040, 3, 66, 33, 0, 1039, 1038, 1, 0, 0, 0, 1039, 1040,
		1, 0, 0, 0, 1040, 67, 1, 0, 0, 0, 1041, 1052, 3, 70, 35, 0, 1042, 1046,
		5, 76, 0, 0, 1043, 1045, 3, 196, 98, 0, 1044, 1043, 1, 0, 0, 0, 1045, 1048,
		1, 0, 0, 0, 1046, 1044, 1, 0, 0, 0, 1046, 1047, 1, 0, 0, 0, 1047, 1049,
		1, 0, 0, 0, 1048, 1046, 1, 0, 0, 0, 1049, 1051, 3, 70, 35, 0, 1050, 1042,
		1, 0, 0, 0, 1051, 1054, 1, 0, 0, 0, 1052, 1050, 1, 0, 0, 0, 1052, 1053,
		1, 0, 0, 0, 1053, 69, 1, 0, 0, 0, 1054, 1052, 1, 0, 0, 0, 1055, 1068, 3,
		86, 43, 0, 1056, 1058, 3, 86, 43, 0, 1057, 1056, 1, 0, 0, 0, 1057, 1058,
		1, 0, 0, 0, 1058, 1059, 1, 0, 0, 0, 1059, 1063, 5, 74, 0, 0, 1060, 1062,
		3, 196, 98, 0, 1061, 1060, 1, 0, 0, 0, 1062, 1065, 1, 0, 0, 0, 1063, 1061,
		1, 0, 0, 0, 1063, 1064, 1, 0, 0, 0, 1064, 1066, 1, 0, 0, 0, 1065, 1063,
		1, 0, 0, 0, 1066, 1068, 3, 40, 20, 0, 1067, 1055, 1, 0, 0, 0, 1067, 1057,
		1, 0, 0, 0, 1068, 71, 1, 0, 0, 0, 1069, 1073, 5, 12, 0, 0, 1070, 1072,
		3, 196, 98, 0, 1071, 1070, 1, 0, 0, 0, 1072, 1075, 1, 0, 0, 0, 1073, 1071,
		1, 0, 0, 0, 1073, 1074, 1, 0, 0, 0, 1074, 1077, 1, 0, 0, 0, 1075, 1073,
		1, 0, 0, 0, 1076, 1078, 5, 95, 0, 0, 1077, 1076, 1, 0, 0, 0, 1077, 1078,
		1, 0, 0, 0, 1078, 1079, 1, 0, 0, 0, 1079, 1083, 5, 51, 0, 0, 1080, 1082,
		3, 196, 98, 0, 1081, 1080, 1, 0, 0, 0, 1082, 1085, 1, 0, 0, 0, 1083, 1081,
		1, 0, 0, 0, 1083, 1084, 1, 0, 0, 0, 1084, 1086, 1, 0, 0, 0, 1085, 1083,
		1, 0, 0, 0, 1086, 1090, 3, 74, 37, 0, 1087, 1089, 3, 196, 98, 0, 1088,
		1087, 1, 0, 0, 0, 1089, 1092, 1, 0, 0, 0, 1090, 1088, 1, 0, 0, 0, 1090,
		1091, 1, 0, 0, 0, 1091, 1094, 1, 0, 0, 0, 1092, 1090, 1, 0, 0, 0, 1093,
		1095, 5, 76, 0, 0, 1094, 1093, 1, 0, 0, 0, 1094, 1095, 1, 0, 0, 0, 1095,
		1099, 1, 0, 0, 0, 1096, 1098, 3, 196, 98, 0, 1097, 1096, 1, 0, 0, 0, 1098,
		1101, 1, 0, 0, 0, 1099, 1097, 1, 0, 0, 0, 1099, 1100, 1, 0, 0, 0, 1100,
		1102, 1, 0, 0, 0, 1101, 1099, 1, 0, 0, 0, 1102, 1103, 5, 52, 0, 0, 1103,
		1113, 1, 0, 0, 0, 1104, 1108, 5, 12, 0, 0, 1105, 1107, 3, 196, 98, 0, 1106,
		1105, 1, 0, 0, 0, 1107, 1110, 1, 0, 0, 0, 1108, 1106, 1, 0, 0, 0, 1108,
		1109, 1, 0, 0, 0, 1109, 1111, 1, 0, 0, 0, 1110, 1108, 1, 0, 0, 0, 1111,
		1113, 5, 95, 0, 0, 1112, 1069, 1, 0, 0, 0, 1112, 1104, 1, 0, 0, 0, 1113,
		73, 1, 0, 0, 0, 1114, 1125, 3, 76, 38, 0, 1115, 1119, 5, 76, 0, 0, 1116,
		1118, 3, 196, 98, 0, 1117, 1116, 1, 0, 0, 0, 1118, 1121, 1, 0, 0, 0, 1119,
		1117, 1, 0, 0, 0, 1119, 1120, 1, 0, 0, 0, 1120, 1122, 1, 0, 0, 0, 1121,
		1119, 1, 0, 0, 0, 1122, 1124, 3, 76, 38, 0, 1123, 1115, 1, 0, 0, 0, 1124,
		1127, 1, 0, 0, 0, 1125, 1123, 1, 0, 0, 0, 1125, 1126, 1, 0, 0, 0, 1126,
		75, 1, 0, 0, 0, 1127, 1125, 1, 0, 0, 0, 1128, 1132, 5, 95, 0, 0, 1129,
		1131, 3, 196, 98, 0, 1130, 1129, 1, 0, 0, 0, 1131, 1134, 1, 0, 0, 0, 1132,
		1130, 1, 0, 0, 0, 1132, 1133, 1, 0, 0, 0, 1133, 1135, 1, 0, 0, 0, 1134,
		1132, 1, 0, 0, 0, 1135, 1144, 3, 100, 50, 0, 1136, 1140, 5, 77, 0, 0, 1137,
		1139, 3, 196, 98, 0, 1138, 1137, 1, 0, 0, 0, 1139, 1142, 1, 0, 0, 0, 1140,
		1138, 1, 0, 0, 0, 1140, 1141, 1, 0, 0, 0, 1141, 1143, 1, 0, 0, 0, 1142,
		1140, 1, 0, 0, 0, 1143, 1145, 3, 40, 20, 0, 1144, 1136, 1, 0, 0, 0, 1144,
		1145, 1, 0, 0, 0, 1145, 1158, 1, 0, 0, 0, 1146, 1155, 5, 95, 0, 0, 1147,
		1151, 5, 77, 0, 0, 1148, 1150, 3, 196, 98, 0, 1149, 1148, 1, 0, 0, 0, 1150,
		1153, 1, 0, 0, 0, 1151, 1149, 1, 0, 0, 0, 1151, 1152, 1, 0, 0, 0, 1152,
		1154, 1, 0, 0, 0, 1153, 1151, 1, 0, 0, 0, 1154, 1156, 3, 40, 20, 0, 1155,
		1147, 1, 0, 0, 0, 1155, 1156, 1, 0, 0, 0, 1156, 1158, 1, 0, 0, 0, 1157,
		1128, 1, 0, 0, 0, 1157, 1146, 1, 0, 0, 0, 1158, 77, 1, 0, 0, 0, 1159, 1160,
		5, 39, 0, 0, 1160, 1164, 5, 47, 0, 0, 1161, 1163, 3, 196, 98, 0, 1162,
		1161, 1, 0, 0, 0, 1163, 1166, 1, 0, 0, 0, 1164, 1162, 1, 0, 0, 0, 1164,
		1165, 1, 0, 0, 0, 1165, 1167, 1, 0, 0, 0, 1166, 1164, 1, 0, 0, 0, 1167,
		1171, 3, 120, 60, 0, 1168, 1170, 3, 196, 98, 0, 1169, 1168, 1, 0, 0, 0,
		1170, 1173, 1, 0, 0, 0, 1171, 1169, 1, 0, 0, 0, 1171, 1172, 1, 0, 0, 0,
		1172, 1174, 1, 0, 0, 0, 1173, 1171, 1, 0, 0, 0, 1174, 1175, 5, 48, 0, 0,
		1175, 79, 1, 0, 0, 0, 1176, 1177, 7, 12, 0, 0, 1177, 81, 1, 0, 0, 0, 1178,
		1188, 5, 18, 0, 0, 1179, 1188, 5, 44, 0, 0, 1180, 1188, 5, 109, 0, 0, 1181,
		1188, 5, 110, 0, 0, 1182, 1188, 3, 100, 50, 0, 1183, 1184, 5, 111, 0, 0,
		1184, 1185, 5, 47, 0, 0, 1185, 1186, 5, 95, 0, 0, 1186, 1188, 5, 48, 0,
		0, 1187, 1178, 1, 0, 0, 0, 1187, 1179, 1, 0, 0, 0, 1187, 1180, 1, 0, 0,
		0, 1187, 1181, 1, 0, 0, 0, 1187, 1182, 1, 0, 0, 0, 1187, 1183, 1, 0, 0,
		0, 1188, 83, 1, 0, 0, 0, 1189, 1190, 5, 37, 0, 0, 1190, 1194, 5, 47, 0,
		0, 1191, 1193, 3, 196, 98, 0, 1192, 1191, 1, 0, 0, 0, 1193, 1196, 1, 0,
		0, 0, 1194, 1192, 1, 0, 0, 0, 1194, 1195, 1, 0, 0, 0, 1195, 1199, 1, 0,
		0, 0, 1196, 1194, 1, 0, 0, 0, 1197, 1200, 3, 120, 60, 0, 1198, 1200, 3,
		40, 20, 0, 1199, 1197, 1, 0, 0, 0, 1199, 1198, 1, 0, 0, 0, 1200, 1204,
		1, 0, 0, 0, 1201, 1203, 3, 196, 98, 0, 1202, 1201, 1, 0, 0, 0, 1203, 1206,
		1, 0, 0, 0, 1204, 1202, 1, 0, 0, 0, 1204, 1205, 1, 0, 0, 0, 1205, 1207,
		1, 0, 0, 0, 1206, 1204, 1, 0, 0, 0, 1207, 1208, 5, 48, 0, 0, 1208, 85,
		1, 0, 0, 0, 1209, 1211, 3, 106, 53, 0, 1210, 1209, 1, 0, 0, 0, 1210, 1211,
		1, 0, 0, 0, 1211, 1212, 1, 0, 0, 0, 1212, 1216, 3, 88, 44, 0, 1213, 1215,
		3, 98, 49, 0, 1214, 1213, 1, 0, 0, 0, 1215, 1218, 1, 0, 0, 0, 1216, 1214,
		1, 0, 0, 0, 1216, 1217, 1, 0, 0, 0, 1217, 87, 1, 0, 0, 0, 1218, 1216, 1,
		0, 0, 0, 1219, 1223, 5, 95, 0, 0, 1220, 1222, 3, 90, 45, 0, 1221, 1220,
		1, 0, 0, 0, 1222, 1225, 1, 0, 0, 0, 1223, 1221, 1, 0, 0, 0, 1223, 1224,
		1, 0, 0, 0, 1224, 1306, 1, 0, 0, 0, 1225, 1223, 1, 0, 0, 0, 1226, 1230,
		3, 186, 93, 0, 1227, 1229, 3, 90, 45, 0, 1228, 1227, 1, 0, 0, 0, 1229,
		1232, 1, 0, 0, 0, 1230, 1228, 1, 0, 0, 0, 1230, 1231, 1, 0, 0, 0, 1231,
		1306, 1, 0, 0, 0, 1232, 1230, 1, 0, 0, 0, 1233, 1237, 5, 47, 0, 0, 1234,
		1236, 3, 196, 98, 0, 1235, 1234, 1, 0, 0, 0, 1236, 1239, 1, 0, 0, 0, 1237,
		1235, 1, 0, 0, 0, 1237, 1238, 1, 0, 0, 0, 1238, 1240, 1, 0, 0, 0, 1239,
		1237, 1, 0, 0, 0, 1240, 1244, 3, 86, 43, 0, 1241, 1243, 3, 196, 98, 0,
		1242, 1241, 1, 0, 0, 0, 1243, 1246, 1, 0, 0, 0, 1244, 1242, 1, 0, 0, 0,
		1244, 1245, 1, 0, 0, 0, 1245, 1247, 1, 0, 0, 0, 1246, 1244, 1, 0, 0, 0,
		1247, 1251, 5, 48, 0, 0, 1248, 1250, 3, 90, 45, 0, 1249, 1248, 1, 0, 0,
		0, 1250, 1253, 1, 0, 0, 0, 1251, 1249, 1, 0, 0, 0, 1251, 1252, 1, 0, 0,
		0, 1252, 1306, 1, 0, 0, 0, 1253, 1251, 1, 0, 0, 0, 1254, 1255, 5, 95, 0,
		0, 1255, 1259, 5, 74, 0, 0, 1256, 1258, 3, 196, 98, 0, 1257, 1256, 1, 0,
		0, 0, 1258, 1261, 1, 0, 0, 0, 1259, 1257, 1, 0, 0, 0, 1259, 1260, 1, 0,
		0, 0, 1260, 1262, 1, 0, 0, 0, 1261, 1259, 1, 0, 0, 0, 1262, 1306, 5, 97,
		0, 0, 1263, 1267, 3, 96, 48, 0, 1264, 1266, 3, 196, 98, 0, 1265, 1264,
		1, 0, 0, 0, 1266, 1269, 1, 0, 0, 0, 1267, 1265, 1, 0, 0, 0, 1267, 1268,
		1, 0, 0, 0, 1268, 1270, 1, 0, 0, 0, 1269, 1267, 1, 0, 0, 0, 1270, 1274,
		5, 95, 0, 0, 1271, 1273, 3, 90, 45, 0, 1272, 1271, 1, 0, 0, 0, 1273, 1276,
		1, 0, 0, 0, 1274, 1272, 1, 0, 0, 0, 1274, 1275, 1, 0, 0, 0, 1275, 1306,
		1, 0, 0, 0, 1276, 1274, 1, 0, 0, 0, 1277, 1281, 5, 47, 0, 0, 1278, 1280,
		3, 196, 98, 0, 1279, 1278, 1, 0, 0, 0, 1280, 1283, 1, 0, 0, 0, 1281, 1279,
		1, 0, 0, 0, 1281, 1282, 1, 0, 0, 0, 1282, 1284, 1, 0, 0, 0, 1283, 1281,
		1, 0, 0, 0, 1284, 1288, 3, 96, 48, 0, 1285, 1287, 3, 196, 98, 0, 1286,
		1285, 1, 0, 0, 0, 1287, 1290, 1, 0, 0, 0, 1288, 1286, 1, 0, 0, 0, 1288,
		1289, 1, 0, 0, 0, 1289, 1291, 1, 0, 0, 0, 1290, 1288, 1, 0, 0, 0, 1291,
		1295, 3, 86, 43, 0, 1292, 1294, 3, 196, 98, 0, 1293, 1292, 1, 0, 0, 0,
		1294, 1297, 1, 0, 0, 0, 1295, 1293, 1, 0, 0, 0, 1295, 1296, 1, 0, 0, 0,
		1296, 1298, 1, 0, 0, 0, 1297, 1295, 1, 0, 0, 0, 1298, 1302, 5, 48, 0, 0,
		1299, 1301, 3, 90, 45, 0, 1300, 1299, 1, 0, 0, 0, 1301, 1304, 1, 0, 0,
		0, 1302, 1300, 1, 0, 0, 0, 1302, 1303, 1, 0, 0, 0, 1303, 1306, 1, 0, 0,
		0, 1304, 1302, 1, 0, 0, 0, 1305, 1219, 1, 0, 0, 0, 1305, 1226, 1, 0, 0,
		0, 1305, 1233, 1, 0, 0, 0, 1305, 1254, 1, 0, 0, 0, 1305, 1263, 1, 0, 0,
		0, 1305, 1277, 1, 0, 0, 0, 1306, 89, 1, 0, 0, 0, 1307, 1310, 3, 92, 46,
		0, 1308, 1310, 3, 94, 47, 0, 1309, 1307, 1, 0, 0, 0, 1309, 1308, 1, 0,
		0, 0, 1310, 91, 1, 0, 0, 0, 1311, 1315, 5, 49, 0, 0, 1312, 1314, 3, 196,
		98, 0, 1313, 1312, 1, 0, 0, 0, 1314, 1317, 1, 0, 0, 0, 1315, 1313, 1, 0,
		0, 0, 1315, 1316, 1, 0, 0, 0, 1316, 1319, 1, 0, 0, 0, 1317, 1315, 1, 0,
		0, 0, 1318, 1320, 3, 110, 55, 0, 1319, 1318, 1, 0, 0, 0, 1319, 1320, 1,
		0, 0, 0, 1320, 1324, 1, 0, 0, 0, 1321, 1323, 3, 196, 98, 0, 1322, 1321,
		1, 0, 0, 0, 1323, 1326, 1, 0, 0, 0, 1324, 1322, 1, 0, 0, 0, 1324, 1325,
		1, 0, 0, 0, 1325, 1328, 1, 0, 0, 0, 1326, 1324, 1, 0, 0, 0, 1327, 1329,
		3, 40, 20, 0, 1328, 1327, 1, 0, 0, 0, 1328, 1329, 1, 0, 0, 0, 1329, 1333,
		1, 0, 0, 0, 1330, 1332, 3, 196, 98, 0, 1331, 1330, 1, 0, 0, 0, 1332, 1335,
		1, 0, 0, 0, 1333, 1331, 1, 0, 0, 0, 1333, 1334, 1, 0, 0, 0, 1334, 1336,
		1, 0, 0, 0, 1335, 1333, 1, 0, 0, 0, 1336, 1424, 5, 50, 0, 0, 1337, 1341,
		5, 49, 0, 0, 1338, 1340, 3, 196, 98, 0, 1339, 1338, 1, 0, 0, 0, 1340, 1343,
		1, 0, 0, 0, 1341, 1339, 1, 0, 0, 0, 1341, 1342, 1, 0, 0, 0, 1342, 1344,
		1, 0, 0, 0, 1343, 1341, 1, 0, 0, 0, 1344, 1348, 5, 28, 0, 0, 1345, 1347,
		3, 196, 98, 0, 1346, 1345, 1, 0, 0, 0, 1347, 1350, 1, 0, 0, 0, 1348, 1346,
		1, 0, 0, 0, 1348, 1349, 1, 0, 0, 0, 1349, 1352, 1, 0, 0, 0, 1350, 1348,
		1, 0, 0, 0, 1351, 1353, 3, 110, 55, 0, 1352, 1351, 1, 0, 0, 0, 1352, 1353,
		1, 0, 0, 0, 1353, 1357, 1, 0, 0, 0, 1354, 1356, 3, 196, 98, 0, 1355, 1354,
		1, 0, 0, 0, 1356, 1359, 1, 0, 0, 0, 1357, 1355, 1, 0, 0, 0, 1357, 1358,
		1, 0, 0, 0, 1358, 1360, 1, 0, 0, 0, 1359, 1357, 1, 0, 0, 0, 1360, 1364,
		3, 40, 20, 0, 1361, 1363, 3, 196, 98, 0, 1362, 1361, 1, 0, 0, 0, 1363,
		1366, 1, 0, 0, 0, 1364, 1362, 1, 0, 0, 0, 1364, 1365, 1, 0, 0, 0, 1365,
		1367, 1, 0, 0, 0, 1366, 1364, 1, 0, 0, 0, 1367, 1368, 5, 50, 0, 0, 1368,
		1424, 1, 0, 0, 0, 1369, 1373, 5, 49, 0, 0, 1370, 1372, 3, 196, 98, 0, 1371,
		1370, 1, 0, 0, 0, 1372, 1375, 1, 0, 0, 0, 1373, 1371, 1, 0, 0, 0, 1373,
		1374, 1, 0, 0, 0, 1374, 1376, 1, 0, 0, 0, 1375, 1373, 1, 0, 0, 0, 1376,
		1380, 3, 110, 55, 0, 1377, 1379, 3, 196, 98, 0, 1378, 1377, 1, 0, 0, 0,
		1379, 1382, 1, 0, 0, 0, 1380, 1378, 1, 0, 0, 0, 1380, 1381, 1, 0, 0, 0,
		1381, 1383, 1, 0, 0, 0, 1382, 1380, 1, 0, 0, 0, 1383, 1387, 5, 28, 0, 0,
		1384, 1386, 3, 196, 98, 0, 1385, 1384, 1, 0, 0, 0, 1386, 1389, 1, 0, 0,
		0, 1387, 1385, 1, 0, 0, 0, 1387, 1388, 1, 0, 0, 0, 1388, 1390, 1, 0, 0,
		0, 1389, 1387, 1, 0, 0, 0, 1390, 1394, 3, 40, 20, 0, 1391, 1393, 3, 196,
		98, 0, 1392, 1391, 1, 0, 0, 0, 1393, 1396, 1, 0, 0, 0, 1394, 1392, 1, 0,
		0, 0, 1394, 1395, 1, 0, 0, 0, 1395, 1397, 1, 0, 0, 0, 1396, 1394, 1, 0,
		0, 0, 1397, 1398, 5, 50, 0, 0, 1398, 1424, 1, 0, 0, 0, 1399, 1403, 5, 49,
		0, 0, 1400, 1402, 3, 196, 98, 0, 1401, 1400, 1, 0, 0, 0, 1402, 1405, 1,
		0, 0, 0, 1403, 1401, 1, 0, 0, 0, 1403, 1404, 1, 0, 0, 0, 1404, 1407, 1,
		0, 0, 0, 1405, 1403, 1, 0, 0, 0, 1406, 1408, 3, 110, 55, 0, 1407, 1406,
		1, 0, 0, 0, 1407, 1408, 1, 0, 0, 0, 1408, 1412, 1, 0, 0, 0, 1409, 1411,
		3, 196, 98, 0, 1410, 1409, 1, 0, 0, 0, 1411, 1414, 1, 0, 0, 0, 1412, 1410,
		1, 0, 0, 0, 1412, 1413, 1, 0, 0, 0, 1413, 1415, 1, 0, 0, 0, 1414, 1412,
		1, 0, 0, 0, 1415, 1419, 5, 63, 0, 0, 1416, 1418, 3, 196, 98, 0, 1417, 1416,
		1, 0, 0, 0, 1418, 1421, 1, 0, 0, 0, 1419, 1417, 1, 0, 0, 0, 1419, 1420,
		1, 0, 0, 0, 1420, 1422, 1, 0, 0, 0, 1421, 1419, 1, 0, 0, 0, 1422, 1424,
		5, 50, 0, 0, 1423, 1311, 1, 0, 0, 0, 1423, 1337, 1, 0, 0, 0, 1423, 1369,
		1, 0, 0, 0, 1423, 1399, 1, 0, 0, 0, 1424, 93, 1, 0, 0, 0, 1425, 1429, 5,
		47, 0, 0, 1426, 1428, 3, 196, 98, 0, 1427, 1426, 1, 0, 0, 0, 1428, 1431,
		1, 0, 0, 0, 1429, 1427, 1, 0, 0, 0, 1429, 1430, 1, 0, 0, 0, 1430, 1432,
		1, 0, 0, 0, 1431, 1429, 1, 0, 0, 0, 1432, 1436, 3, 112, 56, 0, 1433, 1435,
		3, 196, 98, 0, 1434, 1433, 1, 0, 0, 0, 1435, 1438, 1, 0, 0, 0, 1436, 1434,
		1, 0, 0, 0, 1436, 1437, 1, 0, 0, 0, 1437, 1439, 1, 0, 0, 0, 1438, 1436,
		1, 0, 0, 0, 1439, 1440, 5, 48, 0, 0, 1440, 1459, 1, 0, 0, 0, 1441, 1445,
		5, 47, 0, 0, 1442, 1444, 3, 196, 98, 0, 1443, 1442, 1, 0, 0, 0, 1444, 1447,
		1, 0, 0, 0, 1445, 1443, 1, 0, 0, 0, 1445, 1446, 1, 0, 0, 0, 1446, 1449,
		1, 0, 0, 0, 1447, 1445, 1, 0, 0, 0, 1448, 1450, 3, 118, 59, 0, 1449, 1448,
		1, 0, 0, 0, 1449, 1450, 1, 0, 0, 0, 1450, 1454, 1, 0, 0, 0, 1451, 1453,
		3, 196, 98, 0, 1452, 1451, 1, 0, 0, 0, 1453, 1456, 1, 0, 0, 0, 1454, 1452,
		1, 0, 0, 0, 1454, 1455, 1, 0, 0, 0, 1455, 1457, 1, 0, 0, 0, 1456, 1454,
		1, 0, 0, 0, 1457, 1459, 5, 48, 0, 0, 1458, 1425, 1, 0, 0, 0, 1458, 1441,
		1, 0, 0, 0, 1459, 95, 1, 0, 0, 0, 1460, 1461, 7, 13, 0, 0, 1461, 97, 1,
		0, 0, 0, 1462, 1472, 5, 93, 0, 0, 1463, 1472, 3, 100, 50, 0, 1464, 1469,
		5, 95, 0, 0, 1465, 1466, 5, 47, 0, 0, 1466, 1467, 3, 102, 51, 0, 1467,
		1468, 5, 48, 0, 0, 1468, 1470, 1, 0, 0, 0, 1469, 1465, 1, 0, 0, 0, 1469,
		1470, 1, 0, 0, 0, 1470, 1472, 1, 0, 0, 0, 1471, 1462, 1, 0, 0, 0, 1471,
		1463, 1, 0, 0, 0, 1471, 1464, 1, 0, 0, 0, 1472, 99, 1, 0, 0, 0, 1473, 1474,
		5, 94, 0, 0, 1474, 1478, 5, 47, 0, 0, 1475, 1477, 3, 196, 98, 0, 1476,
		1475, 1, 0, 0, 0, 1477, 1480, 1, 0, 0, 0, 1478, 1476, 1, 0, 0, 0, 1478,
		1479, 1, 0, 0, 0, 1479, 1481, 1, 0, 0, 0, 1480, 1478, 1, 0, 0, 0, 1481,
		1485, 5, 47, 0, 0, 1482, 1484, 3, 196, 98, 0, 1483, 1482, 1, 0, 0, 0, 1484,
		1487, 1, 0, 0, 0, 1485, 1483, 1, 0, 0, 0, 1485, 1486, 1, 0, 0, 0, 1486,
		1489, 1, 0, 0, 0, 1487, 1485, 1, 0, 0, 0, 1488, 1490, 3, 102, 51, 0, 1489,
		1488, 1, 0, 0, 0, 1489, 1490, 1, 0, 0, 0, 1490, 1494, 1, 0, 0, 0, 1491,
		1493, 3, 196, 98, 0, 1492, 1491, 1, 0, 0, 0, 1493, 1496, 1, 0, 0, 0, 1494,
		1492, 1, 0, 0, 0, 1494, 1495, 1, 0, 0, 0, 1495, 1497, 1, 0, 0, 0, 1496,
		1494, 1, 0, 0, 0, 1497, 1501, 5, 48, 0, 0, 1498, 1500, 3, 196, 98, 0, 1499,
		1498, 1, 0, 0, 0, 1500, 1503, 1, 0, 0, 0, 1501, 1499, 1, 0, 0, 0, 1501,
		1502, 1, 0, 0, 0, 1502, 1504, 1, 0, 0, 0, 1503, 1501, 1, 0, 0, 0, 1504,
		1505, 5, 48, 0, 0, 1505, 101, 1, 0, 0, 0, 1506, 1517, 3, 104, 52, 0, 1507,
		1511, 5, 76, 0, 0, 1508, 1510, 3, 196, 98, 0, 1509, 1508, 1, 0, 0, 0, 1510,
		1513, 1, 0, 0, 0, 1511, 1509, 1, 0, 0, 0, 1511, 1512, 1, 0, 0, 0, 1512,
		1514, 1, 0, 0, 0, 1513, 1511, 1, 0, 0, 0, 1514, 1516, 3, 104, 52, 0, 1515,
		1507, 1, 0, 0, 0, 1516, 1519, 1, 0, 0, 0, 1517, 1515, 1, 0, 0, 0, 1517,
		1518, 1, 0, 0, 0, 1518, 103, 1, 0, 0, 0, 1519, 1517, 1, 0, 0, 0, 1520,
		1526, 8, 14, 0, 0, 1521, 1523, 5, 47, 0, 0, 1522, 1524, 3, 18, 9, 0, 1523,
		1522, 1, 0, 0, 0, 1523, 1524, 1, 0, 0, 0, 1524, 1525, 1, 0, 0, 0, 1525,
		1527, 5, 48, 0, 0, 1526, 1521, 1, 0, 0, 0, 1526, 1527, 1, 0, 0, 0, 1527,
		1537, 1, 0, 0, 0, 1528, 1534, 5, 95, 0, 0, 1529, 1531, 5, 47, 0, 0, 1530,
		1532, 3, 18, 9, 0, 1531, 1530, 1, 0, 0, 0, 1531, 1532, 1, 0, 0, 0, 1532,
		1533, 1, 0, 0, 0, 1533, 1535, 5, 48, 0, 0, 1534, 1529, 1, 0, 0, 0, 1534,
		1535, 1, 0, 0, 0, 1535, 1537, 1, 0, 0, 0, 1536, 1520, 1, 0, 0, 0, 1536,
		1528, 1, 0, 0, 0, 1537, 105, 1, 0, 0, 0, 1538, 1540, 3, 108, 54, 0, 1539,
		1538, 1, 0, 0, 0, 1540, 1541, 1, 0, 0, 0, 1541, 1539, 1, 0, 0, 0, 1541,
		1542, 1, 0, 0, 0, 1542, 107, 1, 0, 0, 0, 1543, 1545, 7, 15, 0, 0, 1544,
		1546, 3, 110, 55, 0, 1545, 1544, 1, 0, 0, 0, 1545, 1546, 1, 0, 0, 0, 1546,
		109, 1, 0, 0, 0, 1547, 1549, 3, 80, 40, 0, 1548, 1547, 1, 0, 0, 0, 1549,
		1550, 1, 0, 0, 0, 1550, 1548, 1, 0, 0, 0, 1550, 1551, 1, 0, 0, 0, 1551,
		111, 1, 0, 0, 0, 1552, 1569, 3, 114, 57, 0, 1553, 1557, 5, 76, 0, 0, 1554,
		1556, 3, 196, 98, 0, 1555, 1554, 1, 0, 0, 0, 1556, 1559, 1, 0, 0, 0, 1557,
		1555, 1, 0, 0, 0, 1557, 1558, 1, 0, 0, 0, 1558, 1561, 1, 0, 0, 0, 1559,
		1557, 1, 0, 0, 0, 1560, 1562, 5, 92, 0, 0, 1561, 1560, 1, 0, 0, 0, 1561,
		1562, 1, 0, 0, 0, 1562, 1566, 1, 0, 0, 0, 1563, 1565, 3, 196, 98, 0, 1564,
		1563, 1, 0, 0, 0, 1565, 1568, 1, 0, 0, 0, 1566, 1564, 1, 0, 0, 0, 1566,
		1567, 1, 0, 0, 0, 1567, 1570, 1, 0, 0, 0, 1568, 1566, 1, 0, 0, 0, 1569,
		1553, 1, 0, 0, 0, 1569, 1570, 1, 0, 0, 0, 1570, 113, 1, 0, 0, 0, 1571,
		1582, 3, 116, 58, 0, 1572, 1576, 5, 76, 0, 0, 1573, 1575, 3, 196, 98, 0,
		1574, 1573, 1, 0, 0, 0, 1575, 1578, 1, 0, 0, 0, 1576, 1574, 1, 0, 0, 0,
		1576, 1577, 1, 0, 0, 0, 1577, 1579, 1, 0, 0, 0, 1578, 1576, 1, 0, 0, 0,
		1579, 1581, 3, 116, 58, 0, 1580, 1572, 1, 0, 0, 0, 1581, 1584, 1, 0, 0,
		0, 1582, 1580, 1, 0, 0, 0, 1582, 1583, 1, 0, 0, 0, 1583, 115, 1, 0, 0,
		0, 1584, 1582, 1, 0, 0, 0, 1585, 1586, 3, 48, 24, 0, 1586, 1587, 3, 86,
		43, 0, 1587, 1593, 1, 0, 0, 0, 1588, 1590, 3, 48, 24, 0, 1589, 1591, 3,
		122, 61, 0, 1590, 1589, 1, 0, 0, 0, 1590, 1591, 1, 0, 0, 0, 1591, 1593,
		1, 0, 0, 0, 1592, 1585, 1, 0, 0, 0, 1592, 1588, 1, 0, 0, 0, 1593, 117,
		1, 0, 0, 0, 1594, 1605, 5, 95, 0, 0, 1595, 1599, 5, 76, 0, 0, 1596, 1598,
		3, 196, 98, 0, 1597, 1596, 1, 0, 0, 0, 1598, 1601, 1, 0, 0, 0, 1599, 1597,
		1, 0, 0, 0, 1599, 1600, 1, 0, 0, 0, 1600, 1602, 1, 0, 0, 0, 1601, 1599,
		1, 0, 0, 0, 1602, 1604, 5, 95, 0, 0, 1603, 1595, 1, 0, 0, 0, 1604, 1607,
		1, 0, 0, 0, 1605, 1603, 1, 0, 0, 0, 1605, 1606, 1, 0, 0, 0, 1606, 119,
		1, 0, 0, 0, 1607, 1605, 1, 0, 0, 0, 1608, 1609, 6, 60, -1, 0, 1609, 1611,
		3, 66, 33, 0, 1610, 1612, 3, 122, 61, 0, 1611, 1610, 1, 0, 0, 0, 1611,
		1612, 1, 0, 0, 0, 1612, 1618, 1, 0, 0, 0, 1613, 1614, 10, 1, 0, 0, 1614,
		1615, 7, 0, 0, 0, 1615, 1617, 5, 95, 0, 0, 1616, 1613, 1, 0, 0, 0, 1617,
		1620, 1, 0, 0, 0, 1618, 1616, 1, 0, 0, 0, 1618, 1619, 1, 0, 0, 0, 1619,
		121, 1, 0, 0, 0, 1620, 1618, 1, 0, 0, 0, 1621, 1633, 3, 106, 53, 0, 1622,
		1624, 3, 106, 53, 0, 1623, 1622, 1, 0, 0, 0, 1623, 1624, 1, 0, 0, 0, 1624,
		1625, 1, 0, 0, 0, 1625, 1629, 3, 124, 62, 0, 1626, 1628, 3, 98, 49, 0,
		1627, 1626, 1, 0, 0, 0, 1628, 1631, 1, 0, 0, 0, 1629, 1627, 1, 0, 0, 0,
		1629, 1630, 1, 0, 0, 0, 1630, 1633, 1, 0, 0, 0, 1631, 1629, 1, 0, 0, 0,
		1632, 1621, 1, 0, 0, 0, 1632, 1623, 1, 0, 0, 0, 1633, 123, 1, 0, 0, 0,
		1634, 1638, 5, 47, 0, 0, 1635, 1637, 3, 196, 98, 0, 1636, 1635, 1, 0, 0,
		0, 1637, 1640, 1, 0, 0, 0, 1638, 1636, 1, 0, 0, 0, 1638, 1639, 1, 0, 0,
		0, 1639, 1641, 1, 0, 0, 0, 1640, 1638, 1, 0, 0, 0, 1641, 1645, 3, 122,
		61, 0, 1642, 1644, 3, 196, 98, 0, 1643, 1642, 1, 0, 0, 0, 1644, 1647, 1,
		0, 0, 0, 1645, 1643, 1, 0, 0, 0, 1645, 1646, 1, 0, 0, 0, 1646, 1648, 1,
		0, 0, 0, 1647, 1645, 1, 0, 0, 0, 1648, 1652, 5, 48, 0, 0, 1649, 1651, 3,
		98, 49, 0, 1650, 1649, 1, 0, 0, 0, 1651, 1654, 1, 0, 0, 0, 1652, 1650,
		1, 0, 0, 0, 1652, 1653, 1, 0, 0, 0, 1653, 1658, 1, 0, 0, 0, 1654, 1652,
		1, 0, 0, 0, 1655, 1657, 3, 126, 63, 0, 1656, 1655, 1, 0, 0, 0, 1657, 1660,
		1, 0, 0, 0, 1658, 1656, 1, 0, 0, 0, 1658, 1659, 1, 0, 0, 0, 1659, 1667,
		1, 0, 0, 0, 1660, 1658, 1, 0, 0, 0, 1661, 1663, 3, 126, 63, 0, 1662, 1661,
		1, 0, 0, 0, 1663, 1664, 1, 0, 0, 0, 1664, 1662, 1, 0, 0, 0, 1664, 1665,
		1, 0, 0, 0, 1665, 1667, 1, 0, 0, 0, 1666, 1634, 1, 0, 0, 0, 1666, 1662,
		1, 0, 0, 0, 1667, 125, 1, 0, 0, 0, 1668, 1671, 3, 128, 64, 0, 1669, 1671,
		3, 130, 65, 0, 1670, 1668, 1, 0, 0, 0, 1670, 1669, 1, 0, 0, 0, 1671, 127,
		1, 0, 0, 0, 1672, 1676, 5, 49, 0, 0, 1673, 1675, 3, 196, 98, 0, 1674, 1673,
		1, 0, 0, 0, 1675, 1678, 1, 0, 0, 0, 1676, 1674, 1, 0, 0, 0, 1676, 1677,
		1, 0, 0, 0, 1677, 1680, 1, 0, 0, 0, 1678, 1676, 1, 0, 0, 0, 1679, 1681,
		3, 110, 55, 0, 1680, 1679, 1, 0, 0, 0, 1680, 1681, 1, 0, 0, 0, 1681, 1685,
		1, 0, 0, 0, 1682, 1684, 3, 196, 98, 0, 1683, 1682, 1, 0, 0, 0, 1684, 1687,
		1, 0, 0, 0, 1685, 1683, 1, 0, 0, 0, 1685, 1686, 1, 0, 0, 0, 1686, 1689,
		1, 0, 0, 0, 1687, 1685, 1, 0, 0, 0, 1688, 1690, 3, 26, 13, 0, 1689, 1688,
		1, 0, 0, 0, 1689, 1690, 1, 0, 0, 0, 1690, 1694, 1, 0, 0, 0, 1691, 1693,
		3, 196, 98, 0, 1692, 1691, 1, 0, 0, 0, 1693, 1696, 1, 0, 0, 0, 1694, 1692,
		1, 0, 0, 0, 1694, 1695, 1, 0, 0, 0, 1695, 1697, 1, 0, 0, 0, 1696, 1694,
		1, 0, 0, 0, 1697, 1776, 5, 50, 0, 0, 1698, 1702, 5, 49, 0, 0, 1699, 1701,
		3, 196, 98, 0, 1700, 1699, 1, 0, 0, 0, 1701, 1704, 1, 0, 0, 0, 1702, 1700,
		1, 0, 0, 0, 1702, 1703, 1, 0, 0, 0, 1703, 1705, 1, 0, 0, 0, 1704, 1702,
		1, 0, 0, 0, 1705, 1709, 5, 28, 0, 0, 1706, 1708, 3, 196, 98, 0, 1707, 1706,
		1, 0, 0, 0, 1708, 1711, 1, 0, 0, 0, 1709, 1707, 1, 0, 0, 0, 1709, 1710,
		1, 0, 0, 0, 1710, 1713, 1, 0, 0, 0, 1711, 1709, 1, 0, 0, 0, 1712, 1714,
		3, 110, 55, 0, 1713, 1712, 1, 0, 0, 0, 1713, 1714, 1, 0, 0, 0, 1714, 1718,
		1, 0, 0, 0, 1715, 1717, 3, 196, 98, 0, 1716, 1715, 1, 0, 0, 0, 1717, 1720,
		1, 0, 0, 0, 1718, 1716, 1, 0, 0, 0, 1718, 1719, 1, 0, 0, 0, 1719, 1721,
		1, 0, 0, 0, 1720, 1718, 1, 0, 0, 0, 1721, 1725, 3, 26, 13, 0, 1722, 1724,
		3, 196, 98, 0, 1723, 1722, 1, 0, 0, 0, 1724, 1727, 1, 0, 0, 0, 1725, 1723,
		1, 0, 0, 0, 1725, 1726, 1, 0, 0, 0, 1726, 1728, 1, 0, 0, 0, 1727, 1725,
		1, 0, 0, 0, 1728, 1729, 5, 50, 0, 0, 1729, 1776, 1, 0, 0, 0, 1730, 1734,
		5, 49, 0, 0, 1731, 1733, 3, 196, 98, 0, 1732, 1731, 1, 0, 0, 0, 1733, 1736,
		1, 0, 0, 0, 1734, 1732, 1, 0, 0, 0, 1734, 1735, 1, 0, 0, 0, 1735, 1737,
		1, 0, 0, 0, 1736, 1734, 1, 0, 0, 0, 1737, 1741, 3, 110, 55, 0, 1738, 1740,
		3, 196, 98, 0, 1739, 1738, 1, 0, 0, 0, 1740, 1743, 1, 0, 0, 0, 1741, 1739,
		1, 0, 0, 0, 1741, 1742, 1, 0, 0, 0, 1742, 1744, 1, 0, 0, 0, 1743, 1741,
		1, 0, 0, 0, 1744, 1748, 5, 28, 0, 0, 1745, 1747, 3, 196, 98, 0, 1746, 1745,
		1, 0, 0, 0, 1747, 1750, 1, 0, 0, 0, 1748, 1746, 1, 0, 0, 0, 1748, 1749,
		1, 0, 0, 0, 1749, 1751, 1, 0, 0, 0, 1750, 1748, 1, 0, 0, 0, 1751, 1755,
		3, 26, 13, 0, 1752, 1754, 3, 196, 98, 0, 1753, 1752, 1, 0, 0, 0, 1754,
		1757, 1, 0, 0, 0, 1755, 1753, 1, 0, 0, 0, 1755, 1756, 1, 0, 0, 0, 1756,
		1758, 1, 0, 0, 0, 1757, 1755, 1, 0, 0, 0, 1758, 1759, 5, 50, 0, 0, 1759,
		1776, 1, 0, 0, 0, 1760, 1764, 5, 49, 0, 0, 1761, 1763, 3, 196, 98, 0, 1762,
		1761, 1, 0, 0, 0, 1763, 1766, 1, 0, 0, 0, 1764, 1762, 1, 0, 0, 0, 1764,
		1765, 1, 0, 0, 0, 1765, 1767, 1, 0, 0, 0, 1766, 1764, 1, 0, 0, 0, 1767,
		1771, 5, 63, 0, 0, 1768, 1770, 3, 196, 98, 0, 1769, 1768, 1, 0, 0, 0, 1770,
		1773, 1, 0, 0, 0, 1771, 1769, 1, 0, 0, 0, 1771, 1772, 1, 0, 0, 0, 1772,
		1774, 1, 0, 0, 0, 1773, 1771, 1, 0, 0, 0, 1774, 1776, 5, 50, 0, 0, 1775,
		1672, 1, 0, 0, 0, 1775, 1698, 1, 0, 0, 0, 1775, 1730, 1, 0, 0, 0, 1775,
		1760, 1, 0, 0, 0, 1776, 129, 1, 0, 0, 0, 1777, 1781, 5, 47, 0, 0, 1778,
		1780, 3, 196, 98, 0, 1779, 1778, 1, 0, 0, 0, 1780, 1783, 1, 0, 0, 0, 1781,
		1779, 1, 0, 0, 0, 1781, 1782, 1, 0, 0, 0, 1782, 1785, 1, 0, 0, 0, 1783,
		1781, 1, 0, 0, 0, 1784, 1786, 3, 112, 56, 0, 1785, 1784, 1, 0, 0, 0, 1785,
		1786, 1, 0, 0, 0, 1786, 1790, 1, 0, 0, 0, 1787, 1789, 3, 196, 98, 0, 1788,
		1787, 1, 0, 0, 0, 1789, 1792, 1, 0, 0, 0, 1790, 1788, 1, 0, 0, 0, 1790,
		1791, 1, 0, 0, 0, 1791, 1793, 1, 0, 0, 0, 1792, 1790, 1, 0, 0, 0, 1793,
		1797, 5, 48, 0, 0, 1794, 1796, 3, 98, 49, 0, 1795, 1794, 1, 0, 0, 0, 1796,
		1799, 1, 0, 0, 0, 1797, 1795, 1, 0, 0, 0, 1797, 1798, 1, 0, 0, 0, 1798,
		131, 1, 0, 0, 0, 1799, 1797, 1, 0, 0, 0, 1800, 1802, 3, 60, 30, 0, 1801,
		1800, 1, 0, 0, 0, 1801, 1802, 1, 0, 0, 0, 1802, 1803, 1, 0, 0, 0, 1803,
		1804, 5, 95, 0, 0, 1804, 133, 1, 0, 0, 0, 1805, 1833, 3, 40, 20, 0, 1806,
		1810, 5, 51, 0, 0, 1807, 1809, 3, 196, 98, 0, 1808, 1807, 1, 0, 0, 0, 1809,
		1812, 1, 0, 0, 0, 1810, 1808, 1, 0, 0, 0, 1810, 1811, 1, 0, 0, 0, 1811,
		1814, 1, 0, 0, 0, 1812, 1810, 1, 0, 0, 0, 1813, 1815, 3, 136, 68, 0, 1814,
		1813, 1, 0, 0, 0, 1814, 1815, 1, 0, 0, 0, 1815, 1819, 1, 0, 0, 0, 1816,
		1818, 3, 196, 98, 0, 1817, 1816, 1, 0, 0, 0, 1818, 1821, 1, 0, 0, 0, 1819,
		1817, 1, 0, 0, 0, 1819, 1820, 1, 0, 0, 0, 1820, 1823, 1, 0, 0, 0, 1821,
		1819, 1, 0, 0, 0, 1822, 1824, 5, 76, 0, 0, 1823, 1822, 1, 0, 0, 0, 1823,
		1824, 1, 0, 0, 0, 1824, 1828, 1, 0, 0, 0, 1825, 1827, 3, 196, 98, 0, 1826,
		1825, 1, 0, 0, 0, 1827, 1830, 1, 0, 0, 0, 1828, 1826, 1, 0, 0, 0, 1828,
		1829, 1, 0, 0, 0, 1829, 1831, 1, 0, 0, 0, 1830, 1828, 1, 0, 0, 0, 1831,
		1833, 5, 52, 0, 0, 1832, 1805, 1, 0, 0, 0, 1832, 1806, 1, 0, 0, 0, 1833,
		135, 1, 0, 0, 0, 1834, 1836, 3, 138, 69, 0, 1835, 1834, 1, 0, 0, 0, 1835,
		1836, 1, 0, 0, 0, 1836, 1837, 1, 0, 0, 0, 1837, 1851, 3, 134, 67, 0, 1838,
		1842, 5, 76, 0, 0, 1839, 1841, 3, 196, 98, 0, 1840, 1839, 1, 0, 0, 0, 1841,
		1844, 1, 0, 0, 0, 1842, 1840, 1, 0, 0, 0, 1842, 1843, 1, 0, 0, 0, 1843,
		1846, 1, 0, 0, 0, 1844, 1842, 1, 0, 0, 0, 1845, 1847, 3, 138, 69, 0, 1846,
		1845, 1, 0, 0, 0, 1846, 1847, 1, 0, 0, 0, 1847, 1848, 1, 0, 0, 0, 1848,
		1850, 3, 134, 67, 0, 1849, 1838, 1, 0, 0, 0, 1850, 1853, 1, 0, 0, 0, 1851,
		1849, 1, 0, 0, 0, 1851, 1852, 1, 0, 0, 0, 1852, 137, 1, 0, 0, 0, 1853,
		1851, 1, 0, 0, 0, 1854, 1858, 3, 140, 70, 0, 1855, 1857, 3, 196, 98, 0,
		1856, 1855, 1, 0, 0, 0, 1857, 1860, 1, 0, 0, 0, 1858, 1856, 1, 0, 0, 0,
		1858, 1859, 1, 0, 0, 0, 1859, 1861, 1, 0, 0, 0, 1860, 1858, 1, 0, 0, 0,
		1861, 1862, 5, 77, 0, 0, 1862, 139, 1, 0, 0, 0, 1863, 1865, 3, 142, 71,
		0, 1864, 1863, 1, 0, 0, 0, 1865, 1866, 1, 0, 0, 0, 1866, 1864, 1, 0, 0,
		0, 1866, 1867, 1, 0, 0, 0, 1867, 141, 1, 0, 0, 0, 1868, 1872, 5, 49, 0,
		0, 1869, 1871, 3, 196, 98, 0, 1870, 1869, 1, 0, 0, 0, 1871, 1874, 1, 0,
		0, 0, 1872, 1870, 1, 0, 0, 0, 1872, 1873, 1, 0, 0, 0, 1873, 1875, 1, 0,
		0, 0, 1874, 1872, 1, 0, 0, 0, 1875, 1879, 3, 40, 20, 0, 1876, 1878, 3,
		196, 98, 0, 1877, 1876, 1, 0, 0, 0, 1878, 1881, 1, 0, 0, 0, 1879, 1877,
		1, 0, 0, 0, 1879, 1880, 1, 0, 0, 0, 1880, 1882, 1, 0, 0, 0, 1881, 1879,
		1, 0, 0, 0, 1882, 1883, 5, 50, 0, 0, 1883, 1893, 1, 0, 0, 0, 1884, 1888,
		5, 91, 0, 0, 1885, 1887, 3, 196, 98, 0, 1886, 1885, 1, 0, 0, 0, 1887, 1890,
		1, 0, 0, 0, 1888, 1886, 1, 0, 0, 0, 1888, 1889, 1, 0, 0, 0, 1889, 1891,
		1, 0, 0, 0, 1890, 1888, 1, 0, 0, 0, 1891, 1893, 5, 95, 0, 0, 1892, 1868,
		1, 0, 0, 0, 1892, 1884, 1, 0, 0, 0, 1893, 143, 1, 0, 0, 0, 1894, 1898,
		5, 45, 0, 0, 1895, 1897, 3, 196, 98, 0, 1896, 1895, 1, 0, 0, 0, 1897, 1900,
		1, 0, 0, 0, 1898, 1896, 1, 0, 0, 0, 1898, 1899, 1, 0, 0, 0, 1899, 1901,
		1, 0, 0, 0, 1900, 1898, 1, 0, 0, 0, 1901, 1905, 5, 47, 0, 0, 1902, 1904,
		3, 196, 98, 0, 1903, 1902, 1, 0, 0, 0, 1904, 1907, 1, 0, 0, 0, 1905, 1903,
		1, 0, 0, 0, 1905, 1906, 1, 0, 0, 0, 1906, 1908, 1, 0, 0, 0, 1907, 1905,
		1, 0, 0, 0, 1908, 1912, 3, 40, 20, 0, 1909, 1911, 3, 196, 98, 0, 1910,
		1909, 1, 0, 0, 0, 1911, 1914, 1, 0, 0, 0, 1912, 1910, 1, 0, 0, 0, 1912,
		1913, 1, 0, 0, 0, 1913, 1915, 1, 0, 0, 0, 1914, 1912, 1, 0, 0, 0, 1915,
		1919, 5, 76, 0, 0, 1916, 1918, 3, 196, 98, 0, 1917, 1916, 1, 0, 0, 0, 1918,
		1921, 1, 0, 0, 0, 1919, 1917, 1, 0, 0, 0, 1919, 1920, 1, 0, 0, 0, 1920,
		1923, 1, 0, 0, 0, 1921, 1919, 1, 0, 0, 0, 1922, 1924, 5, 98, 0, 0, 1923,
		1922, 1, 0, 0, 0, 1924, 1925, 1, 0, 0, 0, 1925, 1923, 1, 0, 0, 0, 1925,
		1926, 1, 0, 0, 0, 1926, 1930, 1, 0, 0, 0, 1927, 1929, 3, 196, 98, 0, 1928,
		1927, 1, 0, 0, 0, 1929, 1932, 1, 0, 0, 0, 1930, 1928, 1, 0, 0, 0, 1930,
		1931, 1, 0, 0, 0, 1931, 1933, 1, 0, 0, 0, 1932, 1930, 1, 0, 0, 0, 1933,
		1937, 5, 48, 0, 0, 1934, 1936, 3, 196, 98, 0, 1935, 1934, 1, 0, 0, 0, 1936,
		1939, 1, 0, 0, 0, 1937, 1935, 1, 0, 0, 0, 1937, 1938, 1, 0, 0, 0, 1938,
		1940, 1, 0, 0, 0, 1939, 1937, 1, 0, 0, 0, 1940, 1941, 5, 75, 0, 0, 1941,
		145, 1, 0, 0, 0, 1942, 1943, 5, 95, 0, 0, 1943, 1947, 5, 74, 0, 0, 1944,
		1946, 3, 196, 98, 0, 1945, 1944, 1, 0, 0, 0, 1946, 1949, 1, 0, 0, 0, 1947,
		1945, 1, 0, 0, 0, 1947, 1948, 1, 0, 0, 0, 1948, 1951, 1, 0, 0, 0, 1949,
		1947, 1, 0, 0, 0, 1950, 1952, 3, 146, 73, 0, 1951, 1950, 1, 0, 0, 0, 1951,
		1952, 1, 0, 0, 0, 1952, 1963, 1, 0, 0, 0, 1953, 1963, 3, 156, 78, 0, 1954,
		1963, 3, 162, 81, 0, 1955, 1963, 3, 36, 18, 0, 1956, 1963, 3, 164, 82,
		0, 1957, 1963, 3, 166, 83, 0, 1958, 1963, 3, 178, 89, 0, 1959, 1963, 3,
		150, 75, 0, 1960, 1963, 3, 148, 74, 0, 1961, 1963, 5, 75, 0, 0, 1962, 1942,
		1, 0, 0, 0, 1962, 1953, 1, 0, 0, 0, 1962, 1954, 1, 0, 0, 0, 1962, 1955,
		1, 0, 0, 0, 1962, 1956, 1, 0, 0, 0, 1962, 1957, 1, 0, 0, 0, 1962, 1958,
		1, 0, 0, 0, 1962, 1959, 1, 0, 0, 0, 1962, 1960, 1, 0, 0, 0, 1962, 1961,
		1, 0, 0, 0, 1963, 147, 1, 0, 0, 0, 1964, 1968, 5, 95, 0, 0, 1965, 1967,
		3, 196, 98, 0, 1966, 1965, 1, 0, 0, 0, 1967, 1970, 1, 0, 0, 0, 1968, 1966,
		1, 0, 0, 0, 1968, 1969, 1, 0, 0, 0, 1969, 149, 1, 0, 0, 0, 1970, 1968,
		1, 0, 0, 0, 1971, 1975, 5, 93, 0, 0, 1972, 1974, 3, 196, 98, 0, 1973, 1972,
		1, 0, 0, 0, 1974, 1977, 1, 0, 0, 0, 1975, 1973, 1, 0, 0, 0, 1975, 1976,
		1, 0, 0, 0, 1976, 1979, 1, 0, 0, 0, 1977, 1975, 1, 0, 0, 0, 1978, 1980,
		7, 16, 0, 0, 1979, 1978, 1, 0, 0, 0, 1979, 1980, 1, 0, 0, 0, 1980, 1984,
		1, 0, 0, 0, 1981, 1983, 3, 196, 98, 0, 1982, 1981, 1, 0, 0, 0, 1983, 1986,
		1, 0, 0, 0, 1984, 1982, 1, 0, 0, 0, 1984, 1985, 1, 0, 0, 0, 1985, 1987,
		1, 0, 0, 0, 1986, 1984, 1, 0, 0, 0, 1987, 1991, 5, 47, 0, 0, 1988, 1990,
		3, 196, 98, 0, 1989, 1988, 1, 0, 0, 0, 1990, 1993, 1, 0, 0, 0, 1991, 1989,
		1, 0, 0, 0, 1991, 1992, 1, 0, 0, 0, 1992, 1995, 1, 0, 0, 0, 1993, 1991,
		1, 0, 0, 0, 1994, 1996, 3, 152, 76, 0, 1995, 1994, 1, 0, 0, 0, 1995, 1996,
		1, 0, 0, 0, 1996, 2000, 1, 0, 0, 0, 1997, 1999, 3, 196, 98, 0, 1998, 1997,
		1, 0, 0, 0, 1999, 2002, 1, 0, 0, 0, 2000, 1998, 1, 0, 0, 0, 2000, 2001,
		1, 0, 0, 0, 2001, 2061, 1, 0, 0, 0, 2002, 2000, 1, 0, 0, 0, 2003, 2007,
		5, 74, 0, 0, 2004, 2006, 3, 196, 98, 0, 2005, 2004, 1, 0, 0, 0, 2006, 2009,
		1, 0, 0, 0, 2007, 2005, 1, 0, 0, 0, 2007, 2008, 1, 0, 0, 0, 2008, 2011,
		1, 0, 0, 0, 2009, 2007, 1, 0, 0, 0, 2010, 2012, 3, 152, 76, 0, 2011, 2010,
		1, 0, 0, 0, 2011, 2012, 1, 0, 0, 0, 2012, 2016, 1, 0, 0, 0, 2013, 2015,
		3, 196, 98, 0, 2014, 2013, 1, 0, 0, 0, 2015, 2018, 1, 0, 0, 0, 2016, 2014,
		1, 0, 0, 0, 2016, 2017, 1, 0, 0, 0, 2017, 2053, 1, 0, 0, 0, 2018, 2016,
		1, 0, 0, 0, 2019, 2023, 5, 74, 0, 0, 2020, 2022, 3, 196, 98, 0, 2021, 2020,
		1, 0, 0, 0, 2022, 2025, 1, 0, 0, 0, 2023, 2021, 1, 0, 0, 0, 2023, 2024,
		1, 0, 0, 0, 2024, 2027, 1, 0, 0, 0, 2025, 2023, 1, 0, 0, 0, 2026, 2028,
		3, 152, 76, 0, 2027, 2026, 1, 0, 0, 0, 2027, 2028, 1, 0, 0, 0, 2028, 2032,
		1, 0, 0, 0, 2029, 2031, 3, 196, 98, 0, 2030, 2029, 1, 0, 0, 0, 2031, 2034,
		1, 0, 0, 0, 2032, 2030, 1, 0, 0, 0, 2032, 2033, 1, 0, 0, 0, 2033, 2051,
		1, 0, 0, 0, 2034, 2032, 1, 0, 0, 0, 2035, 2039, 5, 74, 0, 0, 2036, 2038,
		3, 196, 98, 0, 2037, 2036, 1, 0, 0, 0, 2038, 2041, 1, 0, 0, 0, 2039, 2037,
		1, 0, 0, 0, 2039, 2040, 1, 0, 0, 0, 2040, 2043, 1, 0, 0, 0, 2041, 2039,
		1, 0, 0, 0, 2042, 2044, 3, 152, 76, 0, 2043, 2042, 1, 0, 0, 0, 2043, 2044,
		1, 0, 0, 0, 2044, 2048, 1, 0, 0, 0, 2045, 2047, 3, 196, 98, 0, 2046, 2045,
		1, 0, 0, 0, 2047, 2050, 1, 0, 0, 0, 2048, 2046, 1, 0, 0, 0, 2048, 2049,
		1, 0, 0, 0, 2049, 2052, 1, 0, 0, 0, 2050, 2048, 1, 0, 0, 0, 2051, 2035,
		1, 0, 0, 0, 2051, 2052, 1, 0, 0, 0, 2052, 2054, 1, 0, 0, 0, 2053, 2019,
		1, 0, 0, 0, 2053, 2054, 1, 0, 0, 0, 2054, 2058, 1, 0, 0, 0, 2055, 2057,
		3, 196, 98, 0, 2056, 2055, 1, 0, 0, 0, 2057, 2060, 1, 0, 0, 0, 2058, 2056,
		1, 0, 0, 0, 2058, 2059, 1, 0, 0, 0, 2059, 2062, 1, 0, 0, 0, 2060, 2058,
		1, 0, 0, 0, 2061, 2003, 1, 0, 0, 0, 2061, 2062, 1, 0, 0, 0, 2062, 2063,
		1, 0, 0, 0, 2063, 2067, 5, 48, 0, 0, 2064, 2066, 3, 196, 98, 0, 2065, 2064,
		1, 0, 0, 0, 2066, 2069, 1, 0, 0, 0, 2067, 2065, 1, 0, 0, 0, 2067, 2068,
		1, 0, 0, 0, 2068, 2070, 1, 0, 0, 0, 2069, 2067, 1, 0, 0, 0, 2070, 2071,
		5, 75, 0, 0, 2071, 151, 1, 0, 0, 0, 2072, 2083, 3, 40, 20, 0, 2073, 2077,
		5, 76, 0, 0, 2074, 2076, 3, 196, 98, 0, 2075, 2074, 1, 0, 0, 0, 2076, 2079,
		1, 0, 0, 0, 2077, 2075, 1, 0, 0, 0, 2077, 2078, 1, 0, 0, 0, 2078, 2080,
		1, 0, 0, 0, 2079, 2077, 1, 0, 0, 0, 2080, 2082, 3, 40, 20, 0, 2081, 2073,
		1, 0, 0, 0, 2082, 2085, 1, 0, 0, 0, 2083, 2081, 1, 0, 0, 0, 2083, 2084,
		1, 0, 0, 0, 2084, 153, 1, 0, 0, 0, 2085, 2083, 1, 0, 0, 0, 2086, 2087,
		5, 3, 0, 0, 2087, 2088, 3, 40, 20, 0, 2088, 2092, 5, 74, 0, 0, 2089, 2091,
		3, 196, 98, 0, 2090, 2089, 1, 0, 0, 0, 2091, 2094, 1, 0, 0, 0, 2092, 2090,
		1, 0, 0, 0, 2092, 2093, 1, 0, 0, 0, 2093, 2098, 1, 0, 0, 0, 2094, 2092,
		1, 0, 0, 0, 2095, 2097, 3, 146, 73, 0, 2096, 2095, 1, 0, 0, 0, 2097, 2100,
		1, 0, 0, 0, 2098, 2096, 1, 0, 0, 0, 2098, 2099, 1, 0, 0, 0, 2099, 2116,
		1, 0, 0, 0, 2100, 2098, 1, 0, 0, 0, 2101, 2102, 5, 7, 0, 0, 2102, 2106,
		5, 74, 0, 0, 2103, 2105, 3, 196, 98, 0, 2104, 2103, 1, 0, 0, 0, 2105, 2108,
		1, 0, 0, 0, 2106, 2104, 1, 0, 0, 0, 2106, 2107, 1, 0, 0, 0, 2107, 2112,
		1, 0, 0, 0, 2108, 2106, 1, 0, 0, 0, 2109, 2111, 3, 146, 73, 0, 2110, 2109,
		1, 0, 0, 0, 2111, 2114, 1, 0, 0, 0, 2112, 2110, 1, 0, 0, 0, 2112, 2113,
		1, 0, 0, 0, 2113, 2116, 1, 0, 0, 0, 2114, 2112, 1, 0, 0, 0, 2115, 2086,
		1, 0, 0, 0, 2115, 2101, 1, 0, 0, 0, 2116, 155, 1, 0, 0, 0, 2117, 2119,
		5, 51, 0, 0, 2118, 2120, 3, 158, 79, 0, 2119, 2118, 1, 0, 0, 0, 2119, 2120,
		1, 0, 0, 0, 2120, 2121, 1, 0, 0, 0, 2121, 2122, 5, 52, 0, 0, 2122, 157,
		1, 0, 0, 0, 2123, 2127, 3, 160, 80, 0, 2124, 2126, 3, 194, 97, 0, 2125,
		2124, 1, 0, 0, 0, 2126, 2129, 1, 0, 0, 0, 2127, 2125, 1, 0, 0, 0, 2127,
		2128, 1, 0, 0, 0, 2128, 2131, 1, 0, 0, 0, 2129, 2127, 1, 0, 0, 0, 2130,
		2123, 1, 0, 0, 0, 2131, 2132, 1, 0, 0, 0, 2132, 2130, 1, 0, 0, 0, 2132,
		2133, 1, 0, 0, 0, 2133, 159, 1, 0, 0, 0, 2134, 2137, 3, 146, 73, 0, 2135,
		2137, 3, 42, 21, 0, 2136, 2134, 1, 0, 0, 0, 2136, 2135, 1, 0, 0, 0, 2137,
		161, 1, 0, 0, 0, 2138, 2142, 3, 170, 85, 0, 2139, 2141, 3, 196, 98, 0,
		2140, 2139, 1, 0, 0, 0, 2141, 2144, 1, 0, 0, 0, 2142, 2140, 1, 0, 0, 0,
		2142, 2143, 1, 0, 0, 0, 2143, 2145, 1, 0, 0, 0, 2144, 2142, 1, 0, 0, 0,
		2145, 2146, 5, 75, 0, 0, 2146, 163, 1, 0, 0, 0, 2147, 2148, 5, 17, 0, 0,
		2148, 2152, 5, 47, 0, 0, 2149, 2151, 3, 196, 98, 0, 2150, 2149, 1, 0, 0,
		0, 2151, 2154, 1, 0, 0, 0, 2152, 2150, 1, 0, 0, 0, 2152, 2153, 1, 0, 0,
		0, 2153, 2155, 1, 0, 0, 0, 2154, 2152, 1, 0, 0, 0, 2155, 2159, 3, 40, 20,
		0, 2156, 2158, 3, 196, 98, 0, 2157, 2156, 1, 0, 0, 0, 2158, 2161, 1, 0,
		0, 0, 2159, 2157, 1, 0, 0, 0, 2159, 2160, 1, 0, 0, 0, 2160, 2162, 1, 0,
		0, 0, 2161, 2159, 1, 0, 0, 0, 2162, 2166, 5, 48, 0, 0, 2163, 2165, 3, 196,
		98, 0, 2164, 2163, 1, 0, 0, 0, 2165, 2168, 1, 0, 0, 0, 2166, 2164, 1, 0,
		0, 0, 2166, 2167, 1, 0, 0, 0, 2167, 2169, 1, 0, 0, 0, 2168, 2166, 1, 0,
		0, 0, 2169, 2178, 3, 146, 73, 0, 2170, 2174, 5, 11, 0, 0, 2171, 2173, 3,
		196, 98, 0, 2172, 2171, 1, 0, 0, 0, 2173, 2176, 1, 0, 0, 0, 2174, 2172,
		1, 0, 0, 0, 2174, 2175, 1, 0, 0, 0, 2175, 2177, 1, 0, 0, 0, 2176, 2174,
		1, 0, 0, 0, 2177, 2179, 3, 146, 73, 0, 2178, 2170, 1, 0, 0, 0, 2178, 2179,
		1, 0, 0, 0, 2179, 2218, 1, 0, 0, 0, 2180, 2181, 5, 30, 0, 0, 2181, 2185,
		5, 47, 0, 0, 2182, 2184, 3, 196, 98, 0, 2183, 2182, 1, 0, 0, 0, 2184, 2187,
		1, 0, 0, 0, 2185, 2183, 1, 0, 0, 0, 2185, 2186, 1, 0, 0, 0, 2186, 2188,
		1, 0, 0, 0, 2187, 2185, 1, 0, 0, 0, 2188, 2192, 3, 40, 20, 0, 2189, 2191,
		3, 196, 98, 0, 2190, 2189, 1, 0, 0, 0, 2191, 2194, 1, 0, 0, 0, 2192, 2190,
		1, 0, 0, 0, 2192, 2193, 1, 0, 0, 0, 2193, 2195, 1, 0, 0, 0, 2194, 2192,
		1, 0, 0, 0, 2195, 2196, 5, 48, 0, 0, 2196, 2200, 5, 51, 0, 0, 2197, 2199,
		3, 196, 98, 0, 2198, 2197, 1, 0, 0, 0, 2199, 2202, 1, 0, 0, 0, 2200, 2198,
		1, 0, 0, 0, 2200, 2201, 1, 0, 0, 0, 2201, 2206, 1, 0, 0, 0, 2202, 2200,
		1, 0, 0, 0, 2203, 2205, 3, 154, 77, 0, 2204, 2203, 1, 0, 0, 0, 2205, 2208,
		1, 0, 0, 0, 2206, 2204, 1, 0, 0, 0, 2206, 2207, 1, 0, 0, 0, 2207, 2212,
		1, 0, 0, 0, 2208, 2206, 1, 0, 0, 0, 2209, 2211, 3, 196, 98, 0, 2210, 2209,
		1, 0, 0, 0, 2211, 2214, 1, 0, 0, 0, 2212, 2210, 1, 0, 0, 0, 2212, 2213,
		1, 0, 0, 0, 2213, 2215, 1, 0, 0, 0, 2214, 2212, 1, 0, 0, 0, 2215, 2216,
		5, 52, 0, 0, 2216, 2218, 1, 0, 0, 0, 2217, 2147, 1, 0, 0, 0, 2217, 2180,
		1, 0, 0, 0, 2218, 165, 1, 0, 0, 0, 2219, 2220, 5, 36, 0, 0, 2220, 2224,
		5, 47, 0, 0, 2221, 2223, 3, 196, 98, 0, 2222, 2221, 1, 0, 0, 0, 2223, 2226,
		1, 0, 0, 0, 2224, 2222, 1, 0, 0, 0, 2224, 2225, 1, 0, 0, 0, 2225, 2227,
		1, 0, 0, 0, 2226, 2224, 1, 0, 0, 0, 2227, 2231, 3, 40, 20, 0, 2228, 2230,
		3, 196, 98, 0, 2229, 2228, 1, 0, 0, 0, 2230, 2233, 1, 0, 0, 0, 2231, 2229,
		1, 0, 0, 0, 2231, 2232, 1, 0, 0, 0, 2232, 2234, 1, 0, 0, 0, 2233, 2231,
		1, 0, 0, 0, 2234, 2236, 5, 48, 0, 0, 2235, 2237, 5, 75, 0, 0, 2236, 2235,
		1, 0, 0, 0, 2236, 2237, 1, 0, 0, 0, 2237, 2241, 1, 0, 0, 0, 2238, 2240,
		3, 196, 98, 0, 2239, 2238, 1, 0, 0, 0, 2240, 2243, 1, 0, 0, 0, 2241, 2239,
		1, 0, 0, 0, 2241, 2242, 1, 0, 0, 0, 2242, 2244, 1, 0, 0, 0, 2243, 2241,
		1, 0, 0, 0, 2244, 2245, 3, 146, 73, 0, 2245, 2298, 1, 0, 0, 0, 2246, 2250,
		5, 8, 0, 0, 2247, 2249, 3, 196, 98, 0, 2248, 2247, 1, 0, 0, 0, 2249, 2252,
		1, 0, 0, 0, 2250, 2248, 1, 0, 0, 0, 2250, 2251, 1, 0, 0, 0, 2251, 2253,
		1, 0, 0, 0, 2252, 2250, 1, 0, 0, 0, 2253, 2254, 3, 146, 73, 0, 2254, 2255,
		5, 36, 0, 0, 2255, 2259, 5, 47, 0, 0, 2256, 2258, 3, 196, 98, 0, 2257,
		2256, 1, 0, 0, 0, 2258, 2261, 1, 0, 0, 0, 2259, 2257, 1, 0, 0, 0, 2259,
		2260, 1, 0, 0, 0, 2260, 2262, 1, 0, 0, 0, 2261, 2259, 1, 0, 0, 0, 2262,
		2266, 3, 40, 20, 0, 2263, 2265, 3, 196, 98, 0, 2264, 2263, 1, 0, 0, 0,
		2265, 2268, 1, 0, 0, 0, 2266, 2264, 1, 0, 0, 0, 2266, 2267, 1, 0, 0, 0,
		2267, 2269, 1, 0, 0, 0, 2268, 2266, 1, 0, 0, 0, 2269, 2271, 5, 48, 0, 0,
		2270, 2272, 5, 75, 0, 0, 2271, 2270, 1, 0, 0, 0, 2271, 2272, 1, 0, 0, 0,
		2272, 2298, 1, 0, 0, 0, 2273, 2274, 5, 15, 0, 0, 2274, 2278, 5, 47, 0,
		0, 2275, 2277, 3, 196, 98, 0, 2276, 2275, 1, 0, 0, 0, 2277, 2280, 1, 0,
		0, 0, 2278, 2276, 1, 0, 0, 0, 2278, 2279, 1, 0, 0, 0, 2279, 2281, 1, 0,
		0, 0, 2280, 2278, 1, 0, 0, 0, 2281, 2285, 3, 168, 84, 0, 2282, 2284, 3,
		196, 98, 0, 2283, 2282, 1, 0, 0, 0, 2284, 2287, 1, 0, 0, 0, 2285, 2283,
		1, 0, 0, 0, 2285, 2286, 1, 0, 0, 0, 2286, 2288, 1, 0, 0, 0, 2287, 2285,
		1, 0, 0, 0, 2288, 2292, 5, 48, 0, 0, 2289, 2291, 3, 196, 98, 0, 2290, 2289,
		1, 0, 0, 0, 2291, 2294, 1, 0, 0, 0, 2292, 2290, 1, 0, 0, 0, 2292, 2293,
		1, 0, 0, 0, 2293, 2295, 1, 0, 0, 0, 2294, 2292, 1, 0, 0, 0, 2295, 2296,
		3, 146, 73, 0, 2296, 2298, 1, 0, 0, 0, 2297, 2219, 1, 0, 0, 0, 2297, 2246,
		1, 0, 0, 0, 2297, 2273, 1, 0, 0, 0, 2298, 167, 1, 0, 0, 0, 2299, 2304,
		3, 172, 86, 0, 2300, 2302, 3, 30, 15, 0, 2301, 2300, 1, 0, 0, 0, 2301,
		2302, 1, 0, 0, 0, 2302, 2304, 1, 0, 0, 0, 2303, 2299, 1, 0, 0, 0, 2303,
		2301, 1, 0, 0, 0, 2304, 2305, 1, 0, 0, 0, 2305, 2307, 5, 75, 0, 0, 2306,
		2308, 3, 176, 88, 0, 2307, 2306, 1, 0, 0, 0, 2307, 2308, 1, 0, 0, 0, 2308,
		2309, 1, 0, 0, 0, 2309, 2311, 5, 75, 0, 0, 2310, 2312, 3, 176, 88, 0, 2311,
		2310, 1, 0, 0, 0, 2311, 2312, 1, 0, 0, 0, 2312, 169, 1, 0, 0, 0, 2313,
		2324, 3, 26, 13, 0, 2314, 2318, 5, 76, 0, 0, 2315, 2317, 3, 196, 98, 0,
		2316, 2315, 1, 0, 0, 0, 2317, 2320, 1, 0, 0, 0, 2318, 2316, 1, 0, 0, 0,
		2318, 2319, 1, 0, 0, 0, 2319, 2321, 1, 0, 0, 0, 2320, 2318, 1, 0, 0, 0,
		2321, 2323, 3, 26, 13, 0, 2322, 2314, 1, 0, 0, 0, 2323, 2326, 1, 0, 0,
		0, 2324, 2322, 1, 0, 0, 0, 2324, 2325, 1, 0, 0, 0, 2325, 171, 1, 0, 0,
		0, 2326, 2324, 1, 0, 0, 0, 2327, 2338, 3, 174, 87, 0, 2328, 2332, 5, 76,
		0, 0, 2329, 2331, 3, 196, 98, 0, 2330, 2329, 1, 0, 0, 0, 2331, 2334, 1,
		0, 0, 0, 2332, 2330, 1, 0, 0, 0, 2332, 2333, 1, 0, 0, 0, 2333, 2335, 1,
		0, 0, 0, 2334, 2332, 1, 0, 0, 0, 2335, 2337, 3, 174, 87, 0, 2336, 2328,
		1, 0, 0, 0, 2337, 2340, 1, 0, 0, 0, 2338, 2336, 1, 0, 0, 0, 2338, 2339,
		1, 0, 0, 0, 2339, 173, 1, 0, 0, 0, 2340, 2338, 1, 0, 0, 0, 2341, 2343,
		3, 48, 24, 0, 2342, 2344, 3, 50, 25, 0, 2343, 2342, 1, 0, 0, 0, 2343, 2344,
		1, 0, 0, 0, 2344, 175, 1, 0, 0, 0, 2345, 2356, 3, 40, 20, 0, 2346, 2350,
		5, 76, 0, 0, 2347, 2349, 3, 196, 98, 0, 2348, 2347, 1, 0, 0, 0, 2349, 2352,
		1, 0, 0, 0, 2350, 2348, 1, 0, 0, 0, 2350, 2351, 1, 0, 0, 0, 2351, 2353,
		1, 0, 0, 0, 2352, 2350, 1, 0, 0, 0, 2353, 2355, 3, 40, 20, 0, 2354, 2346,
		1, 0, 0, 0, 2355, 2358, 1, 0, 0, 0, 2356, 2354, 1, 0, 0, 0, 2356, 2357,
		1, 0, 0, 0, 2357, 177, 1, 0, 0, 0, 2358, 2356, 1, 0, 0, 0, 2359, 2363,
		5, 16, 0, 0, 2360, 2362, 5, 63, 0, 0, 2361, 2360, 1, 0, 0, 0, 2362, 2365,
		1, 0, 0, 0, 2363, 2361, 1, 0, 0, 0, 2363, 2364, 1, 0, 0, 0, 2364, 2366,
		1, 0, 0, 0, 2365, 2363, 1, 0, 0, 0, 2366, 2380, 5, 95, 0, 0, 2367, 2380,
		5, 6, 0, 0, 2368, 2380, 5, 2, 0, 0, 2369, 2373, 5, 24, 0, 0, 2370, 2372,
		3, 196, 98, 0, 2371, 2370, 1, 0, 0, 0, 2372, 2375, 1, 0, 0, 0, 2373, 2371,
		1, 0, 0, 0, 2373, 2374, 1, 0, 0, 0, 2374, 2377, 1, 0, 0, 0, 2375, 2373,
		1, 0, 0, 0, 2376, 2378, 3, 40, 20, 0, 2377, 2376, 1, 0, 0, 0, 2377, 2378,
		1, 0, 0, 0, 2378, 2380, 1, 0, 0, 0, 2379, 2359, 1, 0, 0, 0, 2379, 2367,
		1, 0, 0, 0, 2379, 2368, 1, 0, 0, 0, 2379, 2369, 1, 0, 0, 0, 2380, 2384,
		1, 0, 0, 0, 2381, 2383, 3, 196, 98, 0, 2382, 2381, 1, 0, 0, 0, 2383, 2386,
		1, 0, 0, 0, 2384, 2382, 1, 0, 0, 0, 2384, 2385, 1, 0, 0, 0, 2385, 2387,
		1, 0, 0, 0, 2386, 2384, 1, 0, 0, 0, 2387, 2388, 5, 75, 0, 0, 2388, 179,
		1, 0, 0, 0, 2389, 2391, 3, 194, 97, 0, 2390, 2389, 1, 0, 0, 0, 2391, 2394,
		1, 0, 0, 0, 2392, 2390, 1, 0, 0, 0, 2392, 2393, 1, 0, 0, 0, 2393, 2396,
		1, 0, 0, 0, 2394, 2392, 1, 0, 0, 0, 2395, 2397, 3, 182, 91, 0, 2396, 2395,
		1, 0, 0, 0, 2396, 2397, 1, 0, 0, 0, 2397, 2398, 1, 0, 0, 0, 2398, 2399,
		5, 0, 0, 1, 2399, 181, 1, 0, 0, 0, 2400, 2404, 3, 184, 92, 0, 2401, 2403,
		3, 194, 97, 0, 2402, 2401, 1, 0, 0, 0, 2403, 2406, 1, 0, 0, 0, 2404, 2402,
		1, 0, 0, 0, 2404, 2405, 1, 0, 0, 0, 2405, 2408, 1, 0, 0, 0, 2406, 2404,
		1, 0, 0, 0, 2407, 2400, 1, 0, 0, 0, 2408, 2409, 1, 0, 0, 0, 2409, 2407,
		1, 0, 0, 0, 2409, 2410, 1, 0, 0, 0, 2410, 183, 1, 0, 0, 0, 2411, 2418,
		3, 48, 24, 0, 2412, 2418, 3, 190, 95, 0, 2413, 2418, 3, 42, 21, 0, 2414,
		2418, 3, 186, 93, 0, 2415, 2418, 3, 148, 74, 0, 2416, 2418, 5, 75, 0, 0,
		2417, 2411, 1, 0, 0, 0, 2417, 2412, 1, 0, 0, 0, 2417, 2413, 1, 0, 0, 0,
		2417, 2414, 1, 0, 0, 0, 2417, 2415, 1, 0, 0, 0, 2417, 2416, 1, 0, 0, 0,
		2418, 185, 1, 0, 0, 0, 2419, 2420, 5, 95, 0, 0, 2420, 2424, 5, 47, 0, 0,
		2421, 2423, 3, 196, 98, 0, 2422, 2421, 1, 0, 0, 0, 2423, 2426, 1, 0, 0,
		0, 2424, 2422, 1, 0, 0, 0, 2424, 2425, 1, 0, 0, 0, 2425, 2428, 1, 0, 0,
		0, 2426, 2424, 1, 0, 0, 0, 2427, 2429, 3, 188, 94, 0, 2428, 2427, 1, 0,
		0, 0, 2428, 2429, 1, 0, 0, 0, 2429, 2433, 1, 0, 0, 0, 2430, 2432, 3, 196,
		98, 0, 2431, 2430, 1, 0, 0, 0, 2432, 2435, 1, 0, 0, 0, 2433, 2431, 1, 0,
		0, 0, 2433, 2434, 1, 0, 0, 0, 2434, 2436, 1, 0, 0, 0, 2435, 2433, 1, 0,
		0, 0, 2436, 2440, 5, 48, 0, 0, 2437, 2439, 3, 12, 6, 0, 2438, 2437, 1,
		0, 0, 0, 2439, 2442, 1, 0, 0, 0, 2440, 2438, 1, 0, 0, 0, 2440, 2441, 1,
		0, 0, 0, 2441, 187, 1, 0, 0, 0, 2442, 2440, 1, 0, 0, 0, 2443, 2454, 3,
		20, 10, 0, 2444, 2448, 5, 76, 0, 0, 2445, 2447, 3, 196, 98, 0, 2446, 2445,
		1, 0, 0, 0, 2447, 2450, 1, 0, 0, 0, 2448, 2446, 1, 0, 0, 0, 2448, 2449,
		1, 0, 0, 0, 2449, 2451, 1, 0, 0, 0, 2450, 2448, 1, 0, 0, 0, 2451, 2453,
		3, 20, 10, 0, 2452, 2444, 1, 0, 0, 0, 2453, 2456, 1, 0, 0, 0, 2454, 2452,
		1, 0, 0, 0, 2454, 2455, 1, 0, 0, 0, 2455, 189, 1, 0, 0, 0, 2456, 2454,
		1, 0, 0, 0, 2457, 2459, 3, 48, 24, 0, 2458, 2457, 1, 0, 0, 0, 2458, 2459,
		1, 0, 0, 0, 2459, 2460, 1, 0, 0, 0, 2460, 2462, 3, 86, 43, 0, 2461, 2463,
		3, 192, 96, 0, 2462, 2461, 1, 0, 0, 0, 2462, 2463, 1, 0, 0, 0, 2463, 2465,
		1, 0, 0, 0, 2464, 2466, 3, 156, 78, 0, 2465, 2464, 1, 0, 0, 0, 2465, 2466,
		1, 0, 0, 0, 2466, 191, 1, 0, 0, 0, 2467, 2471, 3, 42, 21, 0, 2468, 2470,
		3, 194, 97, 0, 2469, 2468, 1, 0, 0, 0, 2470, 2473, 1, 0, 0, 0, 2471, 2469,
		1, 0, 0, 0, 2471, 2472, 1, 0, 0, 0, 2472, 2475, 1, 0, 0, 0, 2473, 2471,
		1, 0, 0, 0, 2474, 2467, 1, 0, 0, 0, 2475, 2476, 1, 0, 0, 0, 2476, 2474,
		1, 0, 0, 0, 2476, 2477, 1, 0, 0, 0, 2477, 193, 1, 0, 0, 0, 2478, 2480,
		5, 126, 0, 0, 2479, 2478, 1, 0, 0, 0, 2480, 2481, 1, 0, 0, 0, 2481, 2479,
		1, 0, 0, 0, 2481, 2482, 1, 0, 0, 0, 2482, 2486, 1, 0, 0, 0, 2483, 2486,
		5, 123, 0, 0, 2484, 2486, 5, 124, 0, 0, 2485, 2479, 1, 0, 0, 0, 2485, 2483,
		1, 0, 0, 0, 2485, 2484, 1, 0, 0, 0, 2486, 195, 1, 0, 0, 0, 2487, 2488,
		7, 17, 0, 0, 2488, 197, 1, 0, 0, 0, 373, 205, 212, 219, 225, 232, 242,
		249, 256, 263, 273, 280, 287, 294, 300, 306, 308, 312, 319, 326, 333, 340,
		350, 356, 361, 368, 376, 380, 385, 394, 400, 407, 416, 420, 425, 431, 435,
		443, 447, 452, 456, 463, 470, 477, 484, 492, 498, 505, 508, 514, 522, 530,
		538, 547, 553, 559, 564, 569, 578, 583, 586, 592, 599, 606, 613, 617, 623,
		630, 640, 646, 656, 662, 670, 674, 677, 686, 694, 703, 710, 715, 722, 730,
		737, 745, 752, 761, 770, 779, 788, 797, 805, 810, 812, 819, 823, 828, 837,
		843, 848, 853, 859, 866, 870, 877, 881, 886, 888, 892, 896, 901, 905, 912,
		918, 924, 957, 963, 967, 973, 980, 987, 991, 999, 1004, 1010, 1017, 1026,
		1032, 1036, 1039, 1046, 1052, 1057, 1063, 1067, 1073, 1077, 1083, 1090,
		1094, 1099, 1108, 1112, 1119, 1125, 1132, 1140, 1144, 1151, 1155, 1157,
		1164, 1171, 1187, 1194, 1199, 1204, 1210, 1216, 1223, 1230, 1237, 1244,
		1251, 1259, 1267, 1274, 1281, 1288, 1295, 1302, 1305, 1309, 1315, 1319,
		1324, 1328, 1333, 1341, 1348, 1352, 1357, 1364, 1373, 1380, 1387, 1394,
		1403, 1407, 1412, 1419, 1423, 1429, 1436, 1445, 1449, 1454, 1458, 1469,
		1471, 1478, 1485, 1489, 1494, 1501, 1511, 1517, 1523, 1526, 1531, 1534,
		1536, 1541, 1545, 1550, 1557, 1561, 1566, 1569, 1576, 1582, 1590, 1592,
		1599, 1605, 1611, 1618, 1623, 1629, 1632, 1638, 1645, 1652, 1658, 1664,
		1666, 1670, 1676, 1680, 1685, 1689, 1694, 1702, 1709, 1713, 1718, 1725,
		1734, 1741, 1748, 1755, 1764, 1771, 1775, 1781, 1785, 1790, 1797, 1801,
		1810, 1814, 1819, 1823, 1828, 1832, 1835, 1842, 1846, 1851, 1858, 1866,
		1872, 1879, 1888, 1892, 1898, 1905, 1912, 1919, 1925, 1930, 1937, 1947,
		1951, 1962, 1968, 1975, 1979, 1984, 1991, 1995, 2000, 2007, 2011, 2016,
		2023, 2027, 2032, 2039, 2043, 2048, 2051, 2053, 2058, 2061, 2067, 2077,
		2083, 2092, 2098, 2106, 2112, 2115, 2119, 2127, 2132, 2136, 2142, 2152,
		2159, 2166, 2174, 2178, 2185, 2192, 2200, 2206, 2212, 2217, 2224, 2231,
		2236, 2241, 2250, 2259, 2266, 2271, 2278, 2285, 2292, 2297, 2301, 2303,
		2307, 2311, 2318, 2324, 2332, 2338, 2343, 2350, 2356, 2363, 2373, 2377,
		2379, 2384, 2392, 2396, 2404, 2409, 2417, 2424, 2428, 2433, 2440, 2448,
		2454, 2458, 2462, 2465, 2471, 2476, 2481, 2485,
	}
	deserializer := antlr.NewATNDeserializer(nil)
	staticData.atn = deserializer.Deserialize(staticData.serializedATN)
	atn := staticData.atn
	staticData.decisionToDFA = make([]*antlr.DFA, len(atn.DecisionToState))
	decisionToDFA := staticData.decisionToDFA
	for index, state := range atn.DecisionToState {
		decisionToDFA[index] = antlr.NewDFA(state, index)
	}
}

// CParserInit initializes any static state used to implement CParser. By default the
// static state used to implement the parser is lazily initialized during the first call to
// NewCParser(). You can call this function if you wish to initialize the static state ahead
// of time.
func CParserInit() {
	staticData := &cparserParserStaticData
	staticData.once.Do(cparserParserInit)
}

// NewCParser produces a new parser instance for the optional input antlr.TokenStream.
func NewCParser(input antlr.TokenStream) *CParser {
	CParserInit()
	this := new(CParser)
	this.BaseParser = antlr.NewBaseParser(input)
	staticData := &cparserParserStaticData
	this.Interpreter = antlr.NewParserATNSimulator(this, staticData.atn, staticData.decisionToDFA, staticData.predictionContextCache)
	this.RuleNames = staticData.ruleNames
	this.LiteralNames = staticData.literalNames
	this.SymbolicNames = staticData.symbolicNames
	this.GrammarFileName = "java-escape"

	return this
}

// CParser tokens.
const (
	CParserEOF              = antlr.TokenEOF
	CParserAuto             = 1
	CParserBreak            = 2
	CParserCase             = 3
	CParserChar             = 4
	CParserConst            = 5
	CParserContinue         = 6
	CParserDefault          = 7
	CParserDo               = 8
	CParserDouble           = 9
	CParserLongdouble       = 10
	CParserElse             = 11
	CParserEnum             = 12
	CParserExtern           = 13
	CParserFloat            = 14
	CParserFor              = 15
	CParserGoto             = 16
	CParserIf               = 17
	CParserInline           = 18
	CParserInt              = 19
	CParserLong             = 20
	CParserLonglong         = 21
	CParserRegister         = 22
	CParserRestrict         = 23
	CParserReturn           = 24
	CParserShort            = 25
	CParserSigned           = 26
	CParserSizeof           = 27
	CParserStatic           = 28
	CParserStruct           = 29
	CParserSwitch           = 30
	CParserTypedef          = 31
	CParserUnion            = 32
	CParserUnsigned         = 33
	CParserVoid             = 34
	CParserVolatile         = 35
	CParserWhile            = 36
	CParserAlignas          = 37
	CParserAlignof          = 38
	CParserAtomic           = 39
	CParserBool             = 40
	CParserComplex          = 41
	CParserGeneric          = 42
	CParserImaginary        = 43
	CParserNoreturn         = 44
	CParserStaticAssert     = 45
	CParserThreadLocal      = 46
	CParserLeftParen        = 47
	CParserRightParen       = 48
	CParserLeftBracket      = 49
	CParserRightBracket     = 50
	CParserLeftBrace        = 51
	CParserRightBrace       = 52
	CParserLess             = 53
	CParserLessEqual        = 54
	CParserGreater          = 55
	CParserGreaterEqual     = 56
	CParserLeftShift        = 57
	CParserRightShift       = 58
	CParserPlus             = 59
	CParserPlusPlus         = 60
	CParserMinus            = 61
	CParserMinusMinus       = 62
	CParserStar             = 63
	CParserDiv              = 64
	CParserMod              = 65
	CParserAnd              = 66
	CParserOr               = 67
	CParserAndAnd           = 68
	CParserOrOr             = 69
	CParserCaret            = 70
	CParserNot              = 71
	CParserTilde            = 72
	CParserQuestion         = 73
	CParserColon            = 74
	CParserSemi             = 75
	CParserComma            = 76
	CParserAssign           = 77
	CParserStarAssign       = 78
	CParserDivAssign        = 79
	CParserModAssign        = 80
	CParserPlusAssign       = 81
	CParserMinusAssign      = 82
	CParserLeftShiftAssign  = 83
	CParserRightShiftAssign = 84
	CParserAndAssign        = 85
	CParserXorAssign        = 86
	CParserOrAssign         = 87
	CParserEqual            = 88
	CParserNotEqual         = 89
	CParserArrow            = 90
	CParserDot              = 91
	CParserEllipsis         = 92
	CParserAsm              = 93
	CParserAttribute__      = 94
	CParserIdentifier       = 95
	CParserConstant         = 96
	CParserDigitSequence    = 97
	CParserStringLiteral    = 98
	CParserWS               = 99
	CParserLINE_COMMENT     = 100
	CParserBLOCK_COMMENT    = 101
	CParserExtension        = 102
	CParserBuiltinVaArg     = 103
	CParserBuiltinOffsetof  = 104
	CParserM128             = 105
	CParserM128d            = 106
	CParserM128i            = 107
	CParserTypeof           = 108
	CParserInline__         = 109
	CParserStdcall          = 110
	CParserDeclspec         = 111
	CParserCdecl            = 112
	CParserClrcall          = 113
	CParserFastcall         = 114
	CParserThiscall         = 115
	CParserVectorcall       = 116
	CParserVolatile__       = 117
	CParserMultiLineMacro   = 118
	CParserDirective        = 119
	CParserAsmBlock         = 120
	CParserWhitespace       = 121
	CParserNewline          = 122
	CParserBlockComment     = 123
	CParserLineComment      = 124
	CParserLineContinuation = 125
	CParserEOS              = 126
)

// CParser rules.
const (
	CParserRULE_primaryExpression        = 0
	CParserRULE_stringLiteralExpression  = 1
	CParserRULE_genericSelection         = 2
	CParserRULE_genericAssocList         = 3
	CParserRULE_genericAssociation       = 4
	CParserRULE_postfixExpression        = 5
	CParserRULE_postfixSuffix            = 6
	CParserRULE_postfixExpressionLvalue  = 7
	CParserRULE_postfixSuffixLvalue      = 8
	CParserRULE_argumentExpressionList   = 9
	CParserRULE_macroArgument            = 10
	CParserRULE_unaryExpression          = 11
	CParserRULE_castExpression           = 12
	CParserRULE_coreExpression           = 13
	CParserRULE_assignmentExpression     = 14
	CParserRULE_assignmentExpressions    = 15
	CParserRULE_assignmentOperator       = 16
	CParserRULE_expressionList           = 17
	CParserRULE_statementsExpression     = 18
	CParserRULE_leftExpression           = 19
	CParserRULE_expression               = 20
	CParserRULE_declaration              = 21
	CParserRULE_declarationSpecifiers    = 22
	CParserRULE_declarationSpecifiers2   = 23
	CParserRULE_declarationSpecifier     = 24
	CParserRULE_initDeclaratorList       = 25
	CParserRULE_initDeclarator           = 26
	CParserRULE_storageClassSpecifier    = 27
	CParserRULE_typeSpecifier            = 28
	CParserRULE_structOrUnionSpecifier   = 29
	CParserRULE_structOrUnion            = 30
	CParserRULE_structDeclarationList    = 31
	CParserRULE_structDeclaration        = 32
	CParserRULE_specifierQualifierList   = 33
	CParserRULE_structDeclaratorList     = 34
	CParserRULE_structDeclarator         = 35
	CParserRULE_enumSpecifier            = 36
	CParserRULE_enumeratorList           = 37
	CParserRULE_enumerator               = 38
	CParserRULE_atomicTypeSpecifier      = 39
	CParserRULE_typeQualifier            = 40
	CParserRULE_functionSpecifier        = 41
	CParserRULE_alignmentSpecifier       = 42
	CParserRULE_declarator               = 43
	CParserRULE_directDeclarator         = 44
	CParserRULE_declaratorSuffix         = 45
	CParserRULE_arraySuffix              = 46
	CParserRULE_functionSuffix           = 47
	CParserRULE_vcSpecificModifer        = 48
	CParserRULE_gccDeclaratorExtension   = 49
	CParserRULE_gccAttributeSpecifier    = 50
	CParserRULE_gccAttributeList         = 51
	CParserRULE_gccAttribute             = 52
	CParserRULE_pointer                  = 53
	CParserRULE_pointerPart              = 54
	CParserRULE_typeQualifierList        = 55
	CParserRULE_parameterTypeList        = 56
	CParserRULE_parameterList            = 57
	CParserRULE_parameterDeclaration     = 58
	CParserRULE_identifierList           = 59
	CParserRULE_typeName                 = 60
	CParserRULE_abstractDeclarator       = 61
	CParserRULE_directAbstractDeclarator = 62
	CParserRULE_abstractDeclaratorSuffix = 63
	CParserRULE_abstractArraySuffix      = 64
	CParserRULE_abstractFunctionSuffix   = 65
	CParserRULE_typedefName              = 66
	CParserRULE_initializer              = 67
	CParserRULE_initializerList          = 68
	CParserRULE_designation              = 69
	CParserRULE_designatorList           = 70
	CParserRULE_designator               = 71
	CParserRULE_staticAssertDeclaration  = 72
	CParserRULE_statement                = 73
	CParserRULE_macroCallStatement       = 74
	CParserRULE_asmStatement             = 75
	CParserRULE_asmExprList              = 76
	CParserRULE_labeledStatement         = 77
	CParserRULE_compoundStatement        = 78
	CParserRULE_blockItemList            = 79
	CParserRULE_blockItem                = 80
	CParserRULE_expressionStatement      = 81
	CParserRULE_selectionStatement       = 82
	CParserRULE_iterationStatement       = 83
	CParserRULE_forCondition             = 84
	CParserRULE_coreExpressions          = 85
	CParserRULE_forDeclarations          = 86
	CParserRULE_forDeclaration           = 87
	CParserRULE_forExpression            = 88
	CParserRULE_jumpStatement            = 89
	CParserRULE_compilationUnit          = 90
	CParserRULE_translationUnit          = 91
	CParserRULE_externalDeclaration      = 92
	CParserRULE_macroCallExpression      = 93
	CParserRULE_macroArgumentList        = 94
	CParserRULE_functionDefinition       = 95
	CParserRULE_declarationList          = 96
	CParserRULE_ws                       = 97
	CParserRULE_eos                      = 98
)

// IPrimaryExpressionContext is an interface to support dynamic dispatch.
type IPrimaryExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPrimaryExpressionContext differentiates from other interfaces.
	IsPrimaryExpressionContext()
}

type PrimaryExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPrimaryExpressionContext() *PrimaryExpressionContext {
	var p = new(PrimaryExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CParserRULE_primaryExpression
	return p
}

func (*PrimaryExpressionContext) IsPrimaryExpressionContext() {}

func NewPrimaryExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PrimaryExpressionContext {
	var p = new(PrimaryExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CParserRULE_primaryExpression

	return p
}

func (s *PrimaryExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *PrimaryExpressionContext) Identifier() antlr.TerminalNode {
	return s.GetToken(CParserIdentifier, 0)
}

func (s *PrimaryExpressionContext) Constant() antlr.TerminalNode {
	return s.GetToken(CParserConstant, 0)
}

func (s *PrimaryExpressionContext) StringLiteralExpression() IStringLiteralExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringLiteralExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringLiteralExpressionContext)
}

func (s *PrimaryExpressionContext) LeftParen() antlr.TerminalNode {
	return s.GetToken(CParserLeftParen, 0)
}

func (s *PrimaryExpressionContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *PrimaryExpressionContext) RightParen() antlr.TerminalNode {
	return s.GetToken(CParserRightParen, 0)
}

func (s *PrimaryExpressionContext) AllEos() []IEosContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IEosContext); ok {
			len++
		}
	}

	tst := make([]IEosContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IEosContext); ok {
			tst[i] = t.(IEosContext)
			i++
		}
	}

	return tst
}

func (s *PrimaryExpressionContext) Eos(i int) IEosContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEosContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEosContext)
}

func (s *PrimaryExpressionContext) GenericSelection() IGenericSelectionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGenericSelectionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGenericSelectionContext)
}

func (s *PrimaryExpressionContext) CompoundStatement() ICompoundStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICompoundStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICompoundStatementContext)
}

func (s *PrimaryExpressionContext) Extension() antlr.TerminalNode {
	return s.GetToken(CParserExtension, 0)
}

func (s *PrimaryExpressionContext) BuiltinVaArg() antlr.TerminalNode {
	return s.GetToken(CParserBuiltinVaArg, 0)
}

func (s *PrimaryExpressionContext) UnaryExpression() IUnaryExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnaryExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnaryExpressionContext)
}

func (s *PrimaryExpressionContext) Comma() antlr.TerminalNode {
	return s.GetToken(CParserComma, 0)
}

func (s *PrimaryExpressionContext) TypeName() ITypeNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeNameContext)
}

func (s *PrimaryExpressionContext) BuiltinOffsetof() antlr.TerminalNode {
	return s.GetToken(CParserBuiltinOffsetof, 0)
}

func (s *PrimaryExpressionContext) MacroCallExpression() IMacroCallExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMacroCallExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMacroCallExpressionContext)
}

func (s *PrimaryExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrimaryExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PrimaryExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CParserVisitor:
		return t.VisitPrimaryExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CParser) PrimaryExpression() (localctx IPrimaryExpressionContext) {
	this := p
	_ = this

	localctx = NewPrimaryExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 0, CParserRULE_primaryExpression)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(300)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 13, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(198)
			p.Match(CParserIdentifier)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(199)
			p.Match(CParserConstant)
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(200)
			p.StringLiteralExpression()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(201)
			p.Match(CParserLeftParen)
		}
		p.SetState(205)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == CParserSemi || _la == CParserEOS {
			{
				p.SetState(202)
				p.Eos()
			}

			p.SetState(207)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(208)
			p.expression(0)
		}
		p.SetState(212)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == CParserSemi || _la == CParserEOS {
			{
				p.SetState(209)
				p.Eos()
			}

			p.SetState(214)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(215)
			p.Match(CParserRightParen)
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(217)
			p.GenericSelection()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		p.SetState(219)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == CParserExtension {
			{
				p.SetState(218)
				p.Match(CParserExtension)
			}

		}
		{
			p.SetState(221)
			p.Match(CParserLeftParen)
		}
		p.SetState(225)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == CParserSemi || _la == CParserEOS {
			{
				p.SetState(222)
				p.Eos()
			}

			p.SetState(227)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(228)
			p.CompoundStatement()
		}
		p.SetState(232)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == CParserSemi || _la == CParserEOS {
			{
				p.SetState(229)
				p.Eos()
			}

			p.SetState(234)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(235)
			p.Match(CParserRightParen)
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(237)
			p.Match(CParserBuiltinVaArg)
		}
		{
			p.SetState(238)
			p.Match(CParserLeftParen)
		}
		p.SetState(242)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == CParserSemi || _la == CParserEOS {
			{
				p.SetState(239)
				p.Eos()
			}

			p.SetState(244)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(245)
			p.UnaryExpression()
		}
		p.SetState(249)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == CParserSemi || _la == CParserEOS {
			{
				p.SetState(246)
				p.Eos()
			}

			p.SetState(251)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(252)
			p.Match(CParserComma)
		}
		p.SetState(256)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == CParserSemi || _la == CParserEOS {
			{
				p.SetState(253)
				p.Eos()
			}

			p.SetState(258)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(259)
			p.typeName(0)
		}
		p.SetState(263)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == CParserSemi || _la == CParserEOS {
			{
				p.SetState(260)
				p.Eos()
			}

			p.SetState(265)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(266)
			p.Match(CParserRightParen)
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(268)
			p.Match(CParserBuiltinOffsetof)
		}
		{
			p.SetState(269)
			p.Match(CParserLeftParen)
		}
		p.SetState(273)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == CParserSemi || _la == CParserEOS {
			{
				p.SetState(270)
				p.Eos()
			}

			p.SetState(275)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(276)
			p.typeName(0)
		}
		p.SetState(280)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == CParserSemi || _la == CParserEOS {
			{
				p.SetState(277)
				p.Eos()
			}

			p.SetState(282)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(283)
			p.Match(CParserComma)
		}
		p.SetState(287)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == CParserSemi || _la == CParserEOS {
			{
				p.SetState(284)
				p.Eos()
			}

			p.SetState(289)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(290)
			p.UnaryExpression()
		}
		p.SetState(294)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == CParserSemi || _la == CParserEOS {
			{
				p.SetState(291)
				p.Eos()
			}

			p.SetState(296)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(297)
			p.Match(CParserRightParen)
		}

	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(299)
			p.MacroCallExpression()
		}

	}

	return localctx
}

// IStringLiteralExpressionContext is an interface to support dynamic dispatch.
type IStringLiteralExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsStringLiteralExpressionContext differentiates from other interfaces.
	IsStringLiteralExpressionContext()
}

type StringLiteralExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStringLiteralExpressionContext() *StringLiteralExpressionContext {
	var p = new(StringLiteralExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CParserRULE_stringLiteralExpression
	return p
}

func (*StringLiteralExpressionContext) IsStringLiteralExpressionContext() {}

func NewStringLiteralExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StringLiteralExpressionContext {
	var p = new(StringLiteralExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CParserRULE_stringLiteralExpression

	return p
}

func (s *StringLiteralExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *StringLiteralExpressionContext) AllStringLiteral() []antlr.TerminalNode {
	return s.GetTokens(CParserStringLiteral)
}

func (s *StringLiteralExpressionContext) StringLiteral(i int) antlr.TerminalNode {
	return s.GetToken(CParserStringLiteral, i)
}

func (s *StringLiteralExpressionContext) AllIdentifier() []antlr.TerminalNode {
	return s.GetTokens(CParserIdentifier)
}

func (s *StringLiteralExpressionContext) Identifier(i int) antlr.TerminalNode {
	return s.GetToken(CParserIdentifier, i)
}

func (s *StringLiteralExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StringLiteralExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StringLiteralExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CParserVisitor:
		return t.VisitStringLiteralExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CParser) StringLiteralExpression() (localctx IStringLiteralExpressionContext) {
	this := p
	_ = this

	localctx = NewStringLiteralExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 2, CParserRULE_stringLiteralExpression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(302)
		p.Match(CParserStringLiteral)
	}
	p.SetState(308)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 15, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			p.SetState(306)
			p.GetErrorHandler().Sync(p)

			switch p.GetTokenStream().LA(1) {
			case CParserStringLiteral:
				{
					p.SetState(303)
					p.Match(CParserStringLiteral)
				}

			case CParserIdentifier:
				{
					p.SetState(304)
					p.Match(CParserIdentifier)
				}
				{
					p.SetState(305)
					p.Match(CParserStringLiteral)
				}

			default:
				panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			}

		}
		p.SetState(310)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 15, p.GetParserRuleContext())
	}
	p.SetState(312)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 16, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(311)
			p.Match(CParserIdentifier)
		}

	}

	return localctx
}

// IGenericSelectionContext is an interface to support dynamic dispatch.
type IGenericSelectionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsGenericSelectionContext differentiates from other interfaces.
	IsGenericSelectionContext()
}

type GenericSelectionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGenericSelectionContext() *GenericSelectionContext {
	var p = new(GenericSelectionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CParserRULE_genericSelection
	return p
}

func (*GenericSelectionContext) IsGenericSelectionContext() {}

func NewGenericSelectionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GenericSelectionContext {
	var p = new(GenericSelectionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CParserRULE_genericSelection

	return p
}

func (s *GenericSelectionContext) GetParser() antlr.Parser { return s.parser }

func (s *GenericSelectionContext) Generic() antlr.TerminalNode {
	return s.GetToken(CParserGeneric, 0)
}

func (s *GenericSelectionContext) LeftParen() antlr.TerminalNode {
	return s.GetToken(CParserLeftParen, 0)
}

func (s *GenericSelectionContext) CoreExpression() ICoreExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICoreExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICoreExpressionContext)
}

func (s *GenericSelectionContext) Comma() antlr.TerminalNode {
	return s.GetToken(CParserComma, 0)
}

func (s *GenericSelectionContext) GenericAssocList() IGenericAssocListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGenericAssocListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGenericAssocListContext)
}

func (s *GenericSelectionContext) RightParen() antlr.TerminalNode {
	return s.GetToken(CParserRightParen, 0)
}

func (s *GenericSelectionContext) AllEos() []IEosContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IEosContext); ok {
			len++
		}
	}

	tst := make([]IEosContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IEosContext); ok {
			tst[i] = t.(IEosContext)
			i++
		}
	}

	return tst
}

func (s *GenericSelectionContext) Eos(i int) IEosContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEosContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEosContext)
}

func (s *GenericSelectionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GenericSelectionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GenericSelectionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CParserVisitor:
		return t.VisitGenericSelection(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CParser) GenericSelection() (localctx IGenericSelectionContext) {
	this := p
	_ = this

	localctx = NewGenericSelectionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 4, CParserRULE_genericSelection)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(314)
		p.Match(CParserGeneric)
	}
	{
		p.SetState(315)
		p.Match(CParserLeftParen)
	}
	p.SetState(319)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == CParserSemi || _la == CParserEOS {
		{
			p.SetState(316)
			p.Eos()
		}

		p.SetState(321)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(322)
		p.CoreExpression()
	}
	p.SetState(326)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == CParserSemi || _la == CParserEOS {
		{
			p.SetState(323)
			p.Eos()
		}

		p.SetState(328)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(329)
		p.Match(CParserComma)
	}
	p.SetState(333)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == CParserSemi || _la == CParserEOS {
		{
			p.SetState(330)
			p.Eos()
		}

		p.SetState(335)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(336)
		p.GenericAssocList()
	}
	p.SetState(340)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == CParserSemi || _la == CParserEOS {
		{
			p.SetState(337)
			p.Eos()
		}

		p.SetState(342)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(343)
		p.Match(CParserRightParen)
	}

	return localctx
}

// IGenericAssocListContext is an interface to support dynamic dispatch.
type IGenericAssocListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsGenericAssocListContext differentiates from other interfaces.
	IsGenericAssocListContext()
}

type GenericAssocListContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGenericAssocListContext() *GenericAssocListContext {
	var p = new(GenericAssocListContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CParserRULE_genericAssocList
	return p
}

func (*GenericAssocListContext) IsGenericAssocListContext() {}

func NewGenericAssocListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GenericAssocListContext {
	var p = new(GenericAssocListContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CParserRULE_genericAssocList

	return p
}

func (s *GenericAssocListContext) GetParser() antlr.Parser { return s.parser }

func (s *GenericAssocListContext) AllGenericAssociation() []IGenericAssociationContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IGenericAssociationContext); ok {
			len++
		}
	}

	tst := make([]IGenericAssociationContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IGenericAssociationContext); ok {
			tst[i] = t.(IGenericAssociationContext)
			i++
		}
	}

	return tst
}

func (s *GenericAssocListContext) GenericAssociation(i int) IGenericAssociationContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGenericAssociationContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGenericAssociationContext)
}

func (s *GenericAssocListContext) AllComma() []antlr.TerminalNode {
	return s.GetTokens(CParserComma)
}

func (s *GenericAssocListContext) Comma(i int) antlr.TerminalNode {
	return s.GetToken(CParserComma, i)
}

func (s *GenericAssocListContext) AllEos() []IEosContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IEosContext); ok {
			len++
		}
	}

	tst := make([]IEosContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IEosContext); ok {
			tst[i] = t.(IEosContext)
			i++
		}
	}

	return tst
}

func (s *GenericAssocListContext) Eos(i int) IEosContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEosContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEosContext)
}

func (s *GenericAssocListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GenericAssocListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GenericAssocListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CParserVisitor:
		return t.VisitGenericAssocList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CParser) GenericAssocList() (localctx IGenericAssocListContext) {
	this := p
	_ = this

	localctx = NewGenericAssocListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 6, CParserRULE_genericAssocList)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(345)
		p.GenericAssociation()
	}
	p.SetState(356)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == CParserComma {
		{
			p.SetState(346)
			p.Match(CParserComma)
		}
		p.SetState(350)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == CParserSemi || _la == CParserEOS {
			{
				p.SetState(347)
				p.Eos()
			}

			p.SetState(352)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(353)
			p.GenericAssociation()
		}

		p.SetState(358)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IGenericAssociationContext is an interface to support dynamic dispatch.
type IGenericAssociationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsGenericAssociationContext differentiates from other interfaces.
	IsGenericAssociationContext()
}

type GenericAssociationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGenericAssociationContext() *GenericAssociationContext {
	var p = new(GenericAssociationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CParserRULE_genericAssociation
	return p
}

func (*GenericAssociationContext) IsGenericAssociationContext() {}

func NewGenericAssociationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GenericAssociationContext {
	var p = new(GenericAssociationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CParserRULE_genericAssociation

	return p
}

func (s *GenericAssociationContext) GetParser() antlr.Parser { return s.parser }

func (s *GenericAssociationContext) Colon() antlr.TerminalNode {
	return s.GetToken(CParserColon, 0)
}

func (s *GenericAssociationContext) CoreExpression() ICoreExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICoreExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICoreExpressionContext)
}

func (s *GenericAssociationContext) TypeName() ITypeNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeNameContext)
}

func (s *GenericAssociationContext) Default() antlr.TerminalNode {
	return s.GetToken(CParserDefault, 0)
}

func (s *GenericAssociationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GenericAssociationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GenericAssociationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CParserVisitor:
		return t.VisitGenericAssociation(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CParser) GenericAssociation() (localctx IGenericAssociationContext) {
	this := p
	_ = this

	localctx = NewGenericAssociationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 8, CParserRULE_genericAssociation)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(361)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case CParserChar, CParserConst, CParserDouble, CParserLongdouble, CParserEnum, CParserFloat, CParserInt, CParserLong, CParserLonglong, CParserRestrict, CParserShort, CParserSigned, CParserStruct, CParserUnion, CParserUnsigned, CParserVoid, CParserVolatile, CParserAtomic, CParserBool, CParserComplex, CParserIdentifier, CParserExtension, CParserM128, CParserM128d, CParserM128i, CParserTypeof:
		{
			p.SetState(359)
			p.typeName(0)
		}

	case CParserDefault:
		{
			p.SetState(360)
			p.Match(CParserDefault)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}
	{
		p.SetState(363)
		p.Match(CParserColon)
	}
	{
		p.SetState(364)
		p.CoreExpression()
	}

	return localctx
}

// IPostfixExpressionContext is an interface to support dynamic dispatch.
type IPostfixExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPostfixExpressionContext differentiates from other interfaces.
	IsPostfixExpressionContext()
}

type PostfixExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPostfixExpressionContext() *PostfixExpressionContext {
	var p = new(PostfixExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CParserRULE_postfixExpression
	return p
}

func (*PostfixExpressionContext) IsPostfixExpressionContext() {}

func NewPostfixExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PostfixExpressionContext {
	var p = new(PostfixExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CParserRULE_postfixExpression

	return p
}

func (s *PostfixExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *PostfixExpressionContext) PrimaryExpression() IPrimaryExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrimaryExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrimaryExpressionContext)
}

func (s *PostfixExpressionContext) LeftParen() antlr.TerminalNode {
	return s.GetToken(CParserLeftParen, 0)
}

func (s *PostfixExpressionContext) TypeName() ITypeNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeNameContext)
}

func (s *PostfixExpressionContext) RightParen() antlr.TerminalNode {
	return s.GetToken(CParserRightParen, 0)
}

func (s *PostfixExpressionContext) LeftBrace() antlr.TerminalNode {
	return s.GetToken(CParserLeftBrace, 0)
}

func (s *PostfixExpressionContext) InitializerList() IInitializerListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInitializerListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInitializerListContext)
}

func (s *PostfixExpressionContext) RightBrace() antlr.TerminalNode {
	return s.GetToken(CParserRightBrace, 0)
}

func (s *PostfixExpressionContext) AllPostfixSuffix() []IPostfixSuffixContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPostfixSuffixContext); ok {
			len++
		}
	}

	tst := make([]IPostfixSuffixContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPostfixSuffixContext); ok {
			tst[i] = t.(IPostfixSuffixContext)
			i++
		}
	}

	return tst
}

func (s *PostfixExpressionContext) PostfixSuffix(i int) IPostfixSuffixContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPostfixSuffixContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPostfixSuffixContext)
}

func (s *PostfixExpressionContext) Extension() antlr.TerminalNode {
	return s.GetToken(CParserExtension, 0)
}

func (s *PostfixExpressionContext) Comma() antlr.TerminalNode {
	return s.GetToken(CParserComma, 0)
}

func (s *PostfixExpressionContext) LeftExpression() ILeftExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILeftExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILeftExpressionContext)
}

func (s *PostfixExpressionContext) PlusPlus() antlr.TerminalNode {
	return s.GetToken(CParserPlusPlus, 0)
}

func (s *PostfixExpressionContext) MinusMinus() antlr.TerminalNode {
	return s.GetToken(CParserMinusMinus, 0)
}

func (s *PostfixExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PostfixExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PostfixExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CParserVisitor:
		return t.VisitPostfixExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CParser) PostfixExpression() (localctx IPostfixExpressionContext) {
	this := p
	_ = this

	localctx = NewPostfixExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 10, CParserRULE_postfixExpression)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.SetState(394)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 28, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(380)
		p.GetErrorHandler().Sync(p)
		switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 26, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(366)
				p.PrimaryExpression()
			}

		case 2:
			p.SetState(368)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == CParserExtension {
				{
					p.SetState(367)
					p.Match(CParserExtension)
				}

			}
			{
				p.SetState(370)
				p.Match(CParserLeftParen)
			}
			{
				p.SetState(371)
				p.typeName(0)
			}
			{
				p.SetState(372)
				p.Match(CParserRightParen)
			}
			{
				p.SetState(373)
				p.Match(CParserLeftBrace)
			}
			{
				p.SetState(374)
				p.InitializerList()
			}
			p.SetState(376)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == CParserComma {
				{
					p.SetState(375)
					p.Match(CParserComma)
				}

			}
			{
				p.SetState(378)
				p.Match(CParserRightBrace)
			}

		}
		p.SetState(385)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 27, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(382)
					p.PostfixSuffix()
				}

			}
			p.SetState(387)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 27, p.GetParserRuleContext())
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(388)
			p.LeftExpression()
		}
		{
			p.SetState(389)
			p.Match(CParserPlusPlus)
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(391)
			p.LeftExpression()
		}
		{
			p.SetState(392)
			p.Match(CParserMinusMinus)
		}

	}

	return localctx
}

// IPostfixSuffixContext is an interface to support dynamic dispatch.
type IPostfixSuffixContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPostfixSuffixContext differentiates from other interfaces.
	IsPostfixSuffixContext()
}

type PostfixSuffixContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPostfixSuffixContext() *PostfixSuffixContext {
	var p = new(PostfixSuffixContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CParserRULE_postfixSuffix
	return p
}

func (*PostfixSuffixContext) IsPostfixSuffixContext() {}

func NewPostfixSuffixContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PostfixSuffixContext {
	var p = new(PostfixSuffixContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CParserRULE_postfixSuffix

	return p
}

func (s *PostfixSuffixContext) GetParser() antlr.Parser { return s.parser }

func (s *PostfixSuffixContext) LeftBracket() antlr.TerminalNode {
	return s.GetToken(CParserLeftBracket, 0)
}

func (s *PostfixSuffixContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *PostfixSuffixContext) RightBracket() antlr.TerminalNode {
	return s.GetToken(CParserRightBracket, 0)
}

func (s *PostfixSuffixContext) AllEos() []IEosContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IEosContext); ok {
			len++
		}
	}

	tst := make([]IEosContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IEosContext); ok {
			tst[i] = t.(IEosContext)
			i++
		}
	}

	return tst
}

func (s *PostfixSuffixContext) Eos(i int) IEosContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEosContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEosContext)
}

func (s *PostfixSuffixContext) LeftParen() antlr.TerminalNode {
	return s.GetToken(CParserLeftParen, 0)
}

func (s *PostfixSuffixContext) RightParen() antlr.TerminalNode {
	return s.GetToken(CParserRightParen, 0)
}

func (s *PostfixSuffixContext) ArgumentExpressionList() IArgumentExpressionListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArgumentExpressionListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArgumentExpressionListContext)
}

func (s *PostfixSuffixContext) Identifier() antlr.TerminalNode {
	return s.GetToken(CParserIdentifier, 0)
}

func (s *PostfixSuffixContext) Dot() antlr.TerminalNode {
	return s.GetToken(CParserDot, 0)
}

func (s *PostfixSuffixContext) Arrow() antlr.TerminalNode {
	return s.GetToken(CParserArrow, 0)
}

func (s *PostfixSuffixContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PostfixSuffixContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PostfixSuffixContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CParserVisitor:
		return t.VisitPostfixSuffix(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CParser) PostfixSuffix() (localctx IPostfixSuffixContext) {
	this := p
	_ = this

	localctx = NewPostfixSuffixContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 12, CParserRULE_postfixSuffix)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.SetState(431)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case CParserLeftBracket:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(396)
			p.Match(CParserLeftBracket)
		}
		p.SetState(400)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == CParserSemi || _la == CParserEOS {
			{
				p.SetState(397)
				p.Eos()
			}

			p.SetState(402)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(403)
			p.expression(0)
		}
		p.SetState(407)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == CParserSemi || _la == CParserEOS {
			{
				p.SetState(404)
				p.Eos()
			}

			p.SetState(409)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(410)
			p.Match(CParserRightBracket)
		}

	case CParserLeftParen:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(412)
			p.Match(CParserLeftParen)
		}
		p.SetState(416)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 31, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(413)
					p.Eos()
				}

			}
			p.SetState(418)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 31, p.GetParserRuleContext())
		}
		p.SetState(420)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if (int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-8206824599947726) != 0 || (int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&281233636459007) != 0 {
			{
				p.SetState(419)
				p.ArgumentExpressionList()
			}

		}
		p.SetState(425)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == CParserSemi || _la == CParserEOS {
			{
				p.SetState(422)
				p.Eos()
			}

			p.SetState(427)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(428)
			p.Match(CParserRightParen)
		}

	case CParserArrow, CParserDot:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(429)
			_la = p.GetTokenStream().LA(1)

			if !(_la == CParserArrow || _la == CParserDot) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(430)
			p.Match(CParserIdentifier)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IPostfixExpressionLvalueContext is an interface to support dynamic dispatch.
type IPostfixExpressionLvalueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPostfixExpressionLvalueContext differentiates from other interfaces.
	IsPostfixExpressionLvalueContext()
}

type PostfixExpressionLvalueContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPostfixExpressionLvalueContext() *PostfixExpressionLvalueContext {
	var p = new(PostfixExpressionLvalueContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CParserRULE_postfixExpressionLvalue
	return p
}

func (*PostfixExpressionLvalueContext) IsPostfixExpressionLvalueContext() {}

func NewPostfixExpressionLvalueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PostfixExpressionLvalueContext {
	var p = new(PostfixExpressionLvalueContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CParserRULE_postfixExpressionLvalue

	return p
}

func (s *PostfixExpressionLvalueContext) GetParser() antlr.Parser { return s.parser }

func (s *PostfixExpressionLvalueContext) PrimaryExpression() IPrimaryExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrimaryExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrimaryExpressionContext)
}

func (s *PostfixExpressionLvalueContext) LeftParen() antlr.TerminalNode {
	return s.GetToken(CParserLeftParen, 0)
}

func (s *PostfixExpressionLvalueContext) TypeName() ITypeNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeNameContext)
}

func (s *PostfixExpressionLvalueContext) RightParen() antlr.TerminalNode {
	return s.GetToken(CParserRightParen, 0)
}

func (s *PostfixExpressionLvalueContext) LeftBrace() antlr.TerminalNode {
	return s.GetToken(CParserLeftBrace, 0)
}

func (s *PostfixExpressionLvalueContext) InitializerList() IInitializerListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInitializerListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInitializerListContext)
}

func (s *PostfixExpressionLvalueContext) RightBrace() antlr.TerminalNode {
	return s.GetToken(CParserRightBrace, 0)
}

func (s *PostfixExpressionLvalueContext) AllPostfixSuffixLvalue() []IPostfixSuffixLvalueContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPostfixSuffixLvalueContext); ok {
			len++
		}
	}

	tst := make([]IPostfixSuffixLvalueContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPostfixSuffixLvalueContext); ok {
			tst[i] = t.(IPostfixSuffixLvalueContext)
			i++
		}
	}

	return tst
}

func (s *PostfixExpressionLvalueContext) PostfixSuffixLvalue(i int) IPostfixSuffixLvalueContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPostfixSuffixLvalueContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPostfixSuffixLvalueContext)
}

func (s *PostfixExpressionLvalueContext) Extension() antlr.TerminalNode {
	return s.GetToken(CParserExtension, 0)
}

func (s *PostfixExpressionLvalueContext) Comma() antlr.TerminalNode {
	return s.GetToken(CParserComma, 0)
}

func (s *PostfixExpressionLvalueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PostfixExpressionLvalueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PostfixExpressionLvalueContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CParserVisitor:
		return t.VisitPostfixExpressionLvalue(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CParser) PostfixExpressionLvalue() (localctx IPostfixExpressionLvalueContext) {
	this := p
	_ = this

	localctx = NewPostfixExpressionLvalueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 14, CParserRULE_postfixExpressionLvalue)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.SetState(456)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case CParserGeneric, CParserLeftParen, CParserIdentifier, CParserConstant, CParserStringLiteral, CParserExtension, CParserBuiltinVaArg, CParserBuiltinOffsetof:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(447)
		p.GetErrorHandler().Sync(p)
		switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 37, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(433)
				p.PrimaryExpression()
			}

		case 2:
			p.SetState(435)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == CParserExtension {
				{
					p.SetState(434)
					p.Match(CParserExtension)
				}

			}
			{
				p.SetState(437)
				p.Match(CParserLeftParen)
			}
			{
				p.SetState(438)
				p.typeName(0)
			}
			{
				p.SetState(439)
				p.Match(CParserRightParen)
			}
			{
				p.SetState(440)
				p.Match(CParserLeftBrace)
			}
			{
				p.SetState(441)
				p.InitializerList()
			}
			p.SetState(443)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == CParserComma {
				{
					p.SetState(442)
					p.Match(CParserComma)
				}

			}
			{
				p.SetState(445)
				p.Match(CParserRightBrace)
			}

		}
		p.SetState(452)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 38, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(449)
					p.postfixSuffixLvalue(0)
				}

			}
			p.SetState(454)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 38, p.GetParserRuleContext())
		}

	case CParserLeftBracket, CParserArrow, CParserDot:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(455)
			p.postfixSuffixLvalue(0)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IPostfixSuffixLvalueContext is an interface to support dynamic dispatch.
type IPostfixSuffixLvalueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPostfixSuffixLvalueContext differentiates from other interfaces.
	IsPostfixSuffixLvalueContext()
}

type PostfixSuffixLvalueContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPostfixSuffixLvalueContext() *PostfixSuffixLvalueContext {
	var p = new(PostfixSuffixLvalueContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CParserRULE_postfixSuffixLvalue
	return p
}

func (*PostfixSuffixLvalueContext) IsPostfixSuffixLvalueContext() {}

func NewPostfixSuffixLvalueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PostfixSuffixLvalueContext {
	var p = new(PostfixSuffixLvalueContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CParserRULE_postfixSuffixLvalue

	return p
}

func (s *PostfixSuffixLvalueContext) GetParser() antlr.Parser { return s.parser }

func (s *PostfixSuffixLvalueContext) LeftBracket() antlr.TerminalNode {
	return s.GetToken(CParserLeftBracket, 0)
}

func (s *PostfixSuffixLvalueContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *PostfixSuffixLvalueContext) RightBracket() antlr.TerminalNode {
	return s.GetToken(CParserRightBracket, 0)
}

func (s *PostfixSuffixLvalueContext) AllEos() []IEosContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IEosContext); ok {
			len++
		}
	}

	tst := make([]IEosContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IEosContext); ok {
			tst[i] = t.(IEosContext)
			i++
		}
	}

	return tst
}

func (s *PostfixSuffixLvalueContext) Eos(i int) IEosContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEosContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEosContext)
}

func (s *PostfixSuffixLvalueContext) Identifier() antlr.TerminalNode {
	return s.GetToken(CParserIdentifier, 0)
}

func (s *PostfixSuffixLvalueContext) Dot() antlr.TerminalNode {
	return s.GetToken(CParserDot, 0)
}

func (s *PostfixSuffixLvalueContext) Arrow() antlr.TerminalNode {
	return s.GetToken(CParserArrow, 0)
}

func (s *PostfixSuffixLvalueContext) PostfixSuffixLvalue() IPostfixSuffixLvalueContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPostfixSuffixLvalueContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPostfixSuffixLvalueContext)
}

func (s *PostfixSuffixLvalueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PostfixSuffixLvalueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PostfixSuffixLvalueContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CParserVisitor:
		return t.VisitPostfixSuffixLvalue(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CParser) PostfixSuffixLvalue() (localctx IPostfixSuffixLvalueContext) {
	return p.postfixSuffixLvalue(0)
}

func (p *CParser) postfixSuffixLvalue(_p int) (localctx IPostfixSuffixLvalueContext) {
	this := p
	_ = this

	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()
	_parentState := p.GetState()
	localctx = NewPostfixSuffixLvalueContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IPostfixSuffixLvalueContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 16
	p.EnterRecursionRule(localctx, 16, CParserRULE_postfixSuffixLvalue, _p)
	var _la int

	defer func() {
		p.UnrollRecursionContexts(_parentctx)
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(477)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case CParserLeftBracket:
		{
			p.SetState(459)
			p.Match(CParserLeftBracket)
		}
		p.SetState(463)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == CParserSemi || _la == CParserEOS {
			{
				p.SetState(460)
				p.Eos()
			}

			p.SetState(465)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(466)
			p.expression(0)
		}
		p.SetState(470)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == CParserSemi || _la == CParserEOS {
			{
				p.SetState(467)
				p.Eos()
			}

			p.SetState(472)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(473)
			p.Match(CParserRightBracket)
		}

	case CParserArrow, CParserDot:
		{
			p.SetState(475)
			_la = p.GetTokenStream().LA(1)

			if !(_la == CParserArrow || _la == CParserDot) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(476)
			p.Match(CParserIdentifier)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}
	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(484)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 43, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			localctx = NewPostfixSuffixLvalueContext(p, _parentctx, _parentState)
			p.PushNewRecursionContext(localctx, _startState, CParserRULE_postfixSuffixLvalue)
			p.SetState(479)

			if !(p.Precpred(p.GetParserRuleContext(), 2)) {
				panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 2)", ""))
			}
			{
				p.SetState(480)
				_la = p.GetTokenStream().LA(1)

				if !(_la == CParserArrow || _la == CParserDot) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}
			{
				p.SetState(481)
				p.Match(CParserIdentifier)
			}

		}
		p.SetState(486)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 43, p.GetParserRuleContext())
	}

	return localctx
}

// IArgumentExpressionListContext is an interface to support dynamic dispatch.
type IArgumentExpressionListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsArgumentExpressionListContext differentiates from other interfaces.
	IsArgumentExpressionListContext()
}

type ArgumentExpressionListContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyArgumentExpressionListContext() *ArgumentExpressionListContext {
	var p = new(ArgumentExpressionListContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CParserRULE_argumentExpressionList
	return p
}

func (*ArgumentExpressionListContext) IsArgumentExpressionListContext() {}

func NewArgumentExpressionListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ArgumentExpressionListContext {
	var p = new(ArgumentExpressionListContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CParserRULE_argumentExpressionList

	return p
}

func (s *ArgumentExpressionListContext) GetParser() antlr.Parser { return s.parser }

func (s *ArgumentExpressionListContext) AllMacroArgument() []IMacroArgumentContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IMacroArgumentContext); ok {
			len++
		}
	}

	tst := make([]IMacroArgumentContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IMacroArgumentContext); ok {
			tst[i] = t.(IMacroArgumentContext)
			i++
		}
	}

	return tst
}

func (s *ArgumentExpressionListContext) MacroArgument(i int) IMacroArgumentContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMacroArgumentContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMacroArgumentContext)
}

func (s *ArgumentExpressionListContext) AllComma() []antlr.TerminalNode {
	return s.GetTokens(CParserComma)
}

func (s *ArgumentExpressionListContext) Comma(i int) antlr.TerminalNode {
	return s.GetToken(CParserComma, i)
}

func (s *ArgumentExpressionListContext) AllEos() []IEosContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IEosContext); ok {
			len++
		}
	}

	tst := make([]IEosContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IEosContext); ok {
			tst[i] = t.(IEosContext)
			i++
		}
	}

	return tst
}

func (s *ArgumentExpressionListContext) Eos(i int) IEosContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEosContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEosContext)
}

func (s *ArgumentExpressionListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArgumentExpressionListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ArgumentExpressionListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CParserVisitor:
		return t.VisitArgumentExpressionList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CParser) ArgumentExpressionList() (localctx IArgumentExpressionListContext) {
	this := p
	_ = this

	localctx = NewArgumentExpressionListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 18, CParserRULE_argumentExpressionList)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(487)
		p.MacroArgument()
	}
	p.SetState(498)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == CParserComma {
		{
			p.SetState(488)
			p.Match(CParserComma)
		}
		p.SetState(492)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == CParserSemi || _la == CParserEOS {
			{
				p.SetState(489)
				p.Eos()
			}

			p.SetState(494)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(495)
			p.MacroArgument()
		}

		p.SetState(500)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IMacroArgumentContext is an interface to support dynamic dispatch.
type IMacroArgumentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMacroArgumentContext differentiates from other interfaces.
	IsMacroArgumentContext()
}

type MacroArgumentContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMacroArgumentContext() *MacroArgumentContext {
	var p = new(MacroArgumentContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CParserRULE_macroArgument
	return p
}

func (*MacroArgumentContext) IsMacroArgumentContext() {}

func NewMacroArgumentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MacroArgumentContext {
	var p = new(MacroArgumentContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CParserRULE_macroArgument

	return p
}

func (s *MacroArgumentContext) GetParser() antlr.Parser { return s.parser }

func (s *MacroArgumentContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *MacroArgumentContext) TypeName() ITypeNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeNameContext)
}

func (s *MacroArgumentContext) DigitSequence() antlr.TerminalNode {
	return s.GetToken(CParserDigitSequence, 0)
}

func (s *MacroArgumentContext) Identifier() antlr.TerminalNode {
	return s.GetToken(CParserIdentifier, 0)
}

func (s *MacroArgumentContext) Less() antlr.TerminalNode {
	return s.GetToken(CParserLess, 0)
}

func (s *MacroArgumentContext) Greater() antlr.TerminalNode {
	return s.GetToken(CParserGreater, 0)
}

func (s *MacroArgumentContext) LessEqual() antlr.TerminalNode {
	return s.GetToken(CParserLessEqual, 0)
}

func (s *MacroArgumentContext) GreaterEqual() antlr.TerminalNode {
	return s.GetToken(CParserGreaterEqual, 0)
}

func (s *MacroArgumentContext) Equal() antlr.TerminalNode {
	return s.GetToken(CParserEqual, 0)
}

func (s *MacroArgumentContext) NotEqual() antlr.TerminalNode {
	return s.GetToken(CParserNotEqual, 0)
}

func (s *MacroArgumentContext) Plus() antlr.TerminalNode {
	return s.GetToken(CParserPlus, 0)
}

func (s *MacroArgumentContext) Minus() antlr.TerminalNode {
	return s.GetToken(CParserMinus, 0)
}

func (s *MacroArgumentContext) Star() antlr.TerminalNode {
	return s.GetToken(CParserStar, 0)
}

func (s *MacroArgumentContext) Div() antlr.TerminalNode {
	return s.GetToken(CParserDiv, 0)
}

func (s *MacroArgumentContext) Mod() antlr.TerminalNode {
	return s.GetToken(CParserMod, 0)
}

func (s *MacroArgumentContext) LeftShift() antlr.TerminalNode {
	return s.GetToken(CParserLeftShift, 0)
}

func (s *MacroArgumentContext) RightShift() antlr.TerminalNode {
	return s.GetToken(CParserRightShift, 0)
}

func (s *MacroArgumentContext) And() antlr.TerminalNode {
	return s.GetToken(CParserAnd, 0)
}

func (s *MacroArgumentContext) Or() antlr.TerminalNode {
	return s.GetToken(CParserOr, 0)
}

func (s *MacroArgumentContext) Caret() antlr.TerminalNode {
	return s.GetToken(CParserCaret, 0)
}

func (s *MacroArgumentContext) AndAnd() antlr.TerminalNode {
	return s.GetToken(CParserAndAnd, 0)
}

func (s *MacroArgumentContext) OrOr() antlr.TerminalNode {
	return s.GetToken(CParserOrOr, 0)
}

func (s *MacroArgumentContext) Tilde() antlr.TerminalNode {
	return s.GetToken(CParserTilde, 0)
}

func (s *MacroArgumentContext) Not() antlr.TerminalNode {
	return s.GetToken(CParserNot, 0)
}

func (s *MacroArgumentContext) PlusPlus() antlr.TerminalNode {
	return s.GetToken(CParserPlusPlus, 0)
}

func (s *MacroArgumentContext) MinusMinus() antlr.TerminalNode {
	return s.GetToken(CParserMinusMinus, 0)
}

func (s *MacroArgumentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MacroArgumentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MacroArgumentContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CParserVisitor:
		return t.VisitMacroArgument(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CParser) MacroArgument() (localctx IMacroArgumentContext) {
	this := p
	_ = this

	localctx = NewMacroArgumentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 20, CParserRULE_macroArgument)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(508)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 47, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(501)
			p.expression(0)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(502)
			p.typeName(0)
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(503)
			p.Match(CParserDigitSequence)
		}
		p.SetState(505)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == CParserIdentifier {
			{
				p.SetState(504)
				p.Match(CParserIdentifier)
			}

		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(507)
			_la = p.GetTokenStream().LA(1)

			if !((int64((_la-53)) & ^0x3f) == 0 && ((int64(1)<<(_la-53))&103080263679) != 0) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}

	return localctx
}

// IUnaryExpressionContext is an interface to support dynamic dispatch.
type IUnaryExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsUnaryExpressionContext differentiates from other interfaces.
	IsUnaryExpressionContext()
}

type UnaryExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnaryExpressionContext() *UnaryExpressionContext {
	var p = new(UnaryExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CParserRULE_unaryExpression
	return p
}

func (*UnaryExpressionContext) IsUnaryExpressionContext() {}

func NewUnaryExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UnaryExpressionContext {
	var p = new(UnaryExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CParserRULE_unaryExpression

	return p
}

func (s *UnaryExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *UnaryExpressionContext) LeftExpression() ILeftExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILeftExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILeftExpressionContext)
}

func (s *UnaryExpressionContext) PlusPlus() antlr.TerminalNode {
	return s.GetToken(CParserPlusPlus, 0)
}

func (s *UnaryExpressionContext) MinusMinus() antlr.TerminalNode {
	return s.GetToken(CParserMinusMinus, 0)
}

func (s *UnaryExpressionContext) AllEos() []IEosContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IEosContext); ok {
			len++
		}
	}

	tst := make([]IEosContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IEosContext); ok {
			tst[i] = t.(IEosContext)
			i++
		}
	}

	return tst
}

func (s *UnaryExpressionContext) Eos(i int) IEosContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEosContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEosContext)
}

func (s *UnaryExpressionContext) AllStar() []antlr.TerminalNode {
	return s.GetTokens(CParserStar)
}

func (s *UnaryExpressionContext) Star(i int) antlr.TerminalNode {
	return s.GetToken(CParserStar, i)
}

func (s *UnaryExpressionContext) UnaryExpression() IUnaryExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnaryExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnaryExpressionContext)
}

func (s *UnaryExpressionContext) And() antlr.TerminalNode {
	return s.GetToken(CParserAnd, 0)
}

func (s *UnaryExpressionContext) Sizeof() antlr.TerminalNode {
	return s.GetToken(CParserSizeof, 0)
}

func (s *UnaryExpressionContext) Alignof() antlr.TerminalNode {
	return s.GetToken(CParserAlignof, 0)
}

func (s *UnaryExpressionContext) LeftParen() antlr.TerminalNode {
	return s.GetToken(CParserLeftParen, 0)
}

func (s *UnaryExpressionContext) RightParen() antlr.TerminalNode {
	return s.GetToken(CParserRightParen, 0)
}

func (s *UnaryExpressionContext) TypeName() ITypeNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeNameContext)
}

func (s *UnaryExpressionContext) AndAnd() antlr.TerminalNode {
	return s.GetToken(CParserAndAnd, 0)
}

func (s *UnaryExpressionContext) PostfixExpression() IPostfixExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPostfixExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPostfixExpressionContext)
}

func (s *UnaryExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnaryExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UnaryExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CParserVisitor:
		return t.VisitUnaryExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CParser) UnaryExpression() (localctx IUnaryExpressionContext) {
	this := p
	_ = this

	localctx = NewUnaryExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 22, CParserRULE_unaryExpression)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.SetState(583)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 58, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(510)
			_la = p.GetTokenStream().LA(1)

			if !(_la == CParserPlusPlus || _la == CParserMinusMinus) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		p.SetState(514)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == CParserSemi || _la == CParserEOS {
			{
				p.SetState(511)
				p.Eos()
			}

			p.SetState(516)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(517)
			p.LeftExpression()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(518)
			p.Match(CParserStar)
		}
		p.SetState(522)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == CParserSemi || _la == CParserEOS {
			{
				p.SetState(519)
				p.Eos()
			}

			p.SetState(524)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(525)
			p.UnaryExpression()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(526)
			p.Match(CParserAnd)
		}
		p.SetState(530)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == CParserSemi || _la == CParserEOS {
			{
				p.SetState(527)
				p.Eos()
			}

			p.SetState(532)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(533)
			p.LeftExpression()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(534)
			_la = p.GetTokenStream().LA(1)

			if !(_la == CParserSizeof || _la == CParserAlignof) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		p.SetState(538)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == CParserSemi || _la == CParserEOS {
			{
				p.SetState(535)
				p.Eos()
			}

			p.SetState(540)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(541)
			p.UnaryExpression()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(542)
			_la = p.GetTokenStream().LA(1)

			if !(_la == CParserSizeof || _la == CParserAlignof) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(543)
			p.Match(CParserLeftParen)
		}
		p.SetState(547)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 52, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(544)
					p.Eos()
				}

			}
			p.SetState(549)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 52, p.GetParserRuleContext())
		}
		p.SetState(564)
		p.GetErrorHandler().Sync(p)
		switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 55, p.GetParserRuleContext()) {
		case 1:
			p.SetState(553)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			for _la == CParserStar {
				{
					p.SetState(550)
					p.Match(CParserStar)
				}

				p.SetState(555)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)
			}
			p.SetState(559)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			for _la == CParserSemi || _la == CParserEOS {
				{
					p.SetState(556)
					p.Eos()
				}

				p.SetState(561)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(562)
				p.typeName(0)
			}

		case 2:
			{
				p.SetState(563)
				p.UnaryExpression()
			}

		}
		p.SetState(569)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == CParserSemi || _la == CParserEOS {
			{
				p.SetState(566)
				p.Eos()
			}

			p.SetState(571)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(572)
			p.Match(CParserRightParen)
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(574)
			p.Match(CParserAndAnd)
		}
		p.SetState(578)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == CParserSemi || _la == CParserEOS {
			{
				p.SetState(575)
				p.Eos()
			}

			p.SetState(580)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(581)
			p.UnaryExpression()
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(582)
			p.PostfixExpression()
		}

	}

	return localctx
}

// ICastExpressionContext is an interface to support dynamic dispatch.
type ICastExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCastExpressionContext differentiates from other interfaces.
	IsCastExpressionContext()
}

type CastExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCastExpressionContext() *CastExpressionContext {
	var p = new(CastExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CParserRULE_castExpression
	return p
}

func (*CastExpressionContext) IsCastExpressionContext() {}

func NewCastExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CastExpressionContext {
	var p = new(CastExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CParserRULE_castExpression

	return p
}

func (s *CastExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *CastExpressionContext) LeftParen() antlr.TerminalNode {
	return s.GetToken(CParserLeftParen, 0)
}

func (s *CastExpressionContext) TypeName() ITypeNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeNameContext)
}

func (s *CastExpressionContext) RightParen() antlr.TerminalNode {
	return s.GetToken(CParserRightParen, 0)
}

func (s *CastExpressionContext) CastExpression() ICastExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICastExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICastExpressionContext)
}

func (s *CastExpressionContext) Extension() antlr.TerminalNode {
	return s.GetToken(CParserExtension, 0)
}

func (s *CastExpressionContext) AllEos() []IEosContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IEosContext); ok {
			len++
		}
	}

	tst := make([]IEosContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IEosContext); ok {
			tst[i] = t.(IEosContext)
			i++
		}
	}

	return tst
}

func (s *CastExpressionContext) Eos(i int) IEosContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEosContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEosContext)
}

func (s *CastExpressionContext) UnaryExpression() IUnaryExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnaryExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnaryExpressionContext)
}

func (s *CastExpressionContext) DigitSequence() antlr.TerminalNode {
	return s.GetToken(CParserDigitSequence, 0)
}

func (s *CastExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CastExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CastExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CParserVisitor:
		return t.VisitCastExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CParser) CastExpression() (localctx ICastExpressionContext) {
	this := p
	_ = this

	localctx = NewCastExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 24, CParserRULE_castExpression)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(613)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 63, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(586)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == CParserExtension {
			{
				p.SetState(585)
				p.Match(CParserExtension)
			}

		}
		{
			p.SetState(588)
			p.Match(CParserLeftParen)
		}
		p.SetState(592)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == CParserSemi || _la == CParserEOS {
			{
				p.SetState(589)
				p.Eos()
			}

			p.SetState(594)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(595)
			p.typeName(0)
		}
		p.SetState(599)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == CParserSemi || _la == CParserEOS {
			{
				p.SetState(596)
				p.Eos()
			}

			p.SetState(601)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(602)
			p.Match(CParserRightParen)
		}
		p.SetState(606)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == CParserSemi || _la == CParserEOS {
			{
				p.SetState(603)
				p.Eos()
			}

			p.SetState(608)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(609)
			p.CastExpression()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(611)
			p.UnaryExpression()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(612)
			p.Match(CParserDigitSequence)
		}

	}

	return localctx
}

// ICoreExpressionContext is an interface to support dynamic dispatch.
type ICoreExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCoreExpressionContext differentiates from other interfaces.
	IsCoreExpressionContext()
}

type CoreExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCoreExpressionContext() *CoreExpressionContext {
	var p = new(CoreExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CParserRULE_coreExpression
	return p
}

func (*CoreExpressionContext) IsCoreExpressionContext() {}

func NewCoreExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CoreExpressionContext {
	var p = new(CoreExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CParserRULE_coreExpression

	return p
}

func (s *CoreExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *CoreExpressionContext) AssignmentExpression() IAssignmentExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAssignmentExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAssignmentExpressionContext)
}

func (s *CoreExpressionContext) CastExpression() ICastExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICastExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICastExpressionContext)
}

func (s *CoreExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CoreExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CoreExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CParserVisitor:
		return t.VisitCoreExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CParser) CoreExpression() (localctx ICoreExpressionContext) {
	this := p
	_ = this

	localctx = NewCoreExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 26, CParserRULE_coreExpression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(617)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 64, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(615)
			p.AssignmentExpression()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(616)
			p.CastExpression()
		}

	}

	return localctx
}

// IAssignmentExpressionContext is an interface to support dynamic dispatch.
type IAssignmentExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAssignmentExpressionContext differentiates from other interfaces.
	IsAssignmentExpressionContext()
}

type AssignmentExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAssignmentExpressionContext() *AssignmentExpressionContext {
	var p = new(AssignmentExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CParserRULE_assignmentExpression
	return p
}

func (*AssignmentExpressionContext) IsAssignmentExpressionContext() {}

func NewAssignmentExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AssignmentExpressionContext {
	var p = new(AssignmentExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CParserRULE_assignmentExpression

	return p
}

func (s *AssignmentExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *AssignmentExpressionContext) LeftExpression() ILeftExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILeftExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILeftExpressionContext)
}

func (s *AssignmentExpressionContext) AssignmentOperator() IAssignmentOperatorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAssignmentOperatorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAssignmentOperatorContext)
}

func (s *AssignmentExpressionContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *AssignmentExpressionContext) AllEos() []IEosContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IEosContext); ok {
			len++
		}
	}

	tst := make([]IEosContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IEosContext); ok {
			tst[i] = t.(IEosContext)
			i++
		}
	}

	return tst
}

func (s *AssignmentExpressionContext) Eos(i int) IEosContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEosContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEosContext)
}

func (s *AssignmentExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AssignmentExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AssignmentExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CParserVisitor:
		return t.VisitAssignmentExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CParser) AssignmentExpression() (localctx IAssignmentExpressionContext) {
	this := p
	_ = this

	localctx = NewAssignmentExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 28, CParserRULE_assignmentExpression)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(619)
		p.LeftExpression()
	}
	p.SetState(623)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == CParserSemi || _la == CParserEOS {
		{
			p.SetState(620)
			p.Eos()
		}

		p.SetState(625)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(626)
		p.AssignmentOperator()
	}
	p.SetState(630)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == CParserSemi || _la == CParserEOS {
		{
			p.SetState(627)
			p.Eos()
		}

		p.SetState(632)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(633)
		p.expression(0)
	}

	return localctx
}

// IAssignmentExpressionsContext is an interface to support dynamic dispatch.
type IAssignmentExpressionsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAssignmentExpressionsContext differentiates from other interfaces.
	IsAssignmentExpressionsContext()
}

type AssignmentExpressionsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAssignmentExpressionsContext() *AssignmentExpressionsContext {
	var p = new(AssignmentExpressionsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CParserRULE_assignmentExpressions
	return p
}

func (*AssignmentExpressionsContext) IsAssignmentExpressionsContext() {}

func NewAssignmentExpressionsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AssignmentExpressionsContext {
	var p = new(AssignmentExpressionsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CParserRULE_assignmentExpressions

	return p
}

func (s *AssignmentExpressionsContext) GetParser() antlr.Parser { return s.parser }

func (s *AssignmentExpressionsContext) AllAssignmentExpression() []IAssignmentExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAssignmentExpressionContext); ok {
			len++
		}
	}

	tst := make([]IAssignmentExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAssignmentExpressionContext); ok {
			tst[i] = t.(IAssignmentExpressionContext)
			i++
		}
	}

	return tst
}

func (s *AssignmentExpressionsContext) AssignmentExpression(i int) IAssignmentExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAssignmentExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAssignmentExpressionContext)
}

func (s *AssignmentExpressionsContext) AllComma() []antlr.TerminalNode {
	return s.GetTokens(CParserComma)
}

func (s *AssignmentExpressionsContext) Comma(i int) antlr.TerminalNode {
	return s.GetToken(CParserComma, i)
}

func (s *AssignmentExpressionsContext) AllEos() []IEosContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IEosContext); ok {
			len++
		}
	}

	tst := make([]IEosContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IEosContext); ok {
			tst[i] = t.(IEosContext)
			i++
		}
	}

	return tst
}

func (s *AssignmentExpressionsContext) Eos(i int) IEosContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEosContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEosContext)
}

func (s *AssignmentExpressionsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AssignmentExpressionsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AssignmentExpressionsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CParserVisitor:
		return t.VisitAssignmentExpressions(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CParser) AssignmentExpressions() (localctx IAssignmentExpressionsContext) {
	this := p
	_ = this

	localctx = NewAssignmentExpressionsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 30, CParserRULE_assignmentExpressions)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(635)
		p.AssignmentExpression()
	}
	p.SetState(646)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == CParserComma {
		{
			p.SetState(636)
			p.Match(CParserComma)
		}
		p.SetState(640)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == CParserSemi || _la == CParserEOS {
			{
				p.SetState(637)
				p.Eos()
			}

			p.SetState(642)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(643)
			p.AssignmentExpression()
		}

		p.SetState(648)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IAssignmentOperatorContext is an interface to support dynamic dispatch.
type IAssignmentOperatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAssignmentOperatorContext differentiates from other interfaces.
	IsAssignmentOperatorContext()
}

type AssignmentOperatorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAssignmentOperatorContext() *AssignmentOperatorContext {
	var p = new(AssignmentOperatorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CParserRULE_assignmentOperator
	return p
}

func (*AssignmentOperatorContext) IsAssignmentOperatorContext() {}

func NewAssignmentOperatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AssignmentOperatorContext {
	var p = new(AssignmentOperatorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CParserRULE_assignmentOperator

	return p
}

func (s *AssignmentOperatorContext) GetParser() antlr.Parser { return s.parser }

func (s *AssignmentOperatorContext) Assign() antlr.TerminalNode {
	return s.GetToken(CParserAssign, 0)
}

func (s *AssignmentOperatorContext) StarAssign() antlr.TerminalNode {
	return s.GetToken(CParserStarAssign, 0)
}

func (s *AssignmentOperatorContext) DivAssign() antlr.TerminalNode {
	return s.GetToken(CParserDivAssign, 0)
}

func (s *AssignmentOperatorContext) ModAssign() antlr.TerminalNode {
	return s.GetToken(CParserModAssign, 0)
}

func (s *AssignmentOperatorContext) PlusAssign() antlr.TerminalNode {
	return s.GetToken(CParserPlusAssign, 0)
}

func (s *AssignmentOperatorContext) MinusAssign() antlr.TerminalNode {
	return s.GetToken(CParserMinusAssign, 0)
}

func (s *AssignmentOperatorContext) LeftShiftAssign() antlr.TerminalNode {
	return s.GetToken(CParserLeftShiftAssign, 0)
}

func (s *AssignmentOperatorContext) RightShiftAssign() antlr.TerminalNode {
	return s.GetToken(CParserRightShiftAssign, 0)
}

func (s *AssignmentOperatorContext) AndAssign() antlr.TerminalNode {
	return s.GetToken(CParserAndAssign, 0)
}

func (s *AssignmentOperatorContext) XorAssign() antlr.TerminalNode {
	return s.GetToken(CParserXorAssign, 0)
}

func (s *AssignmentOperatorContext) OrAssign() antlr.TerminalNode {
	return s.GetToken(CParserOrAssign, 0)
}

func (s *AssignmentOperatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AssignmentOperatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AssignmentOperatorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CParserVisitor:
		return t.VisitAssignmentOperator(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CParser) AssignmentOperator() (localctx IAssignmentOperatorContext) {
	this := p
	_ = this

	localctx = NewAssignmentOperatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 32, CParserRULE_assignmentOperator)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(649)
		_la = p.GetTokenStream().LA(1)

		if !((int64((_la-77)) & ^0x3f) == 0 && ((int64(1)<<(_la-77))&2047) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IExpressionListContext is an interface to support dynamic dispatch.
type IExpressionListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExpressionListContext differentiates from other interfaces.
	IsExpressionListContext()
}

type ExpressionListContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpressionListContext() *ExpressionListContext {
	var p = new(ExpressionListContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CParserRULE_expressionList
	return p
}

func (*ExpressionListContext) IsExpressionListContext() {}

func NewExpressionListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExpressionListContext {
	var p = new(ExpressionListContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CParserRULE_expressionList

	return p
}

func (s *ExpressionListContext) GetParser() antlr.Parser { return s.parser }

func (s *ExpressionListContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *ExpressionListContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ExpressionListContext) AllComma() []antlr.TerminalNode {
	return s.GetTokens(CParserComma)
}

func (s *ExpressionListContext) Comma(i int) antlr.TerminalNode {
	return s.GetToken(CParserComma, i)
}

func (s *ExpressionListContext) AllEos() []IEosContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IEosContext); ok {
			len++
		}
	}

	tst := make([]IEosContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IEosContext); ok {
			tst[i] = t.(IEosContext)
			i++
		}
	}

	return tst
}

func (s *ExpressionListContext) Eos(i int) IEosContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEosContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEosContext)
}

func (s *ExpressionListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExpressionListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExpressionListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CParserVisitor:
		return t.VisitExpressionList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CParser) ExpressionList() (localctx IExpressionListContext) {
	this := p
	_ = this

	localctx = NewExpressionListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 34, CParserRULE_expressionList)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(651)
		p.expression(0)
	}
	p.SetState(662)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == CParserComma {
		{
			p.SetState(652)
			p.Match(CParserComma)
		}
		p.SetState(656)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == CParserSemi || _la == CParserEOS {
			{
				p.SetState(653)
				p.Eos()
			}

			p.SetState(658)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(659)
			p.expression(0)
		}

		p.SetState(664)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IStatementsExpressionContext is an interface to support dynamic dispatch.
type IStatementsExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsStatementsExpressionContext differentiates from other interfaces.
	IsStatementsExpressionContext()
}

type StatementsExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStatementsExpressionContext() *StatementsExpressionContext {
	var p = new(StatementsExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CParserRULE_statementsExpression
	return p
}

func (*StatementsExpressionContext) IsStatementsExpressionContext() {}

func NewStatementsExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StatementsExpressionContext {
	var p = new(StatementsExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CParserRULE_statementsExpression

	return p
}

func (s *StatementsExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *StatementsExpressionContext) LeftParen() antlr.TerminalNode {
	return s.GetToken(CParserLeftParen, 0)
}

func (s *StatementsExpressionContext) LeftBrace() antlr.TerminalNode {
	return s.GetToken(CParserLeftBrace, 0)
}

func (s *StatementsExpressionContext) RightBrace() antlr.TerminalNode {
	return s.GetToken(CParserRightBrace, 0)
}

func (s *StatementsExpressionContext) RightParen() antlr.TerminalNode {
	return s.GetToken(CParserRightParen, 0)
}

func (s *StatementsExpressionContext) AllStatement() []IStatementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStatementContext); ok {
			len++
		}
	}

	tst := make([]IStatementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStatementContext); ok {
			tst[i] = t.(IStatementContext)
			i++
		}
	}

	return tst
}

func (s *StatementsExpressionContext) Statement(i int) IStatementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *StatementsExpressionContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *StatementsExpressionContext) Semi() antlr.TerminalNode {
	return s.GetToken(CParserSemi, 0)
}

func (s *StatementsExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StatementsExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StatementsExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CParserVisitor:
		return t.VisitStatementsExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CParser) StatementsExpression() (localctx IStatementsExpressionContext) {
	this := p
	_ = this

	localctx = NewStatementsExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 36, CParserRULE_statementsExpression)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(665)
		p.Match(CParserLeftParen)
	}
	{
		p.SetState(666)
		p.Match(CParserLeftBrace)
	}
	p.SetState(670)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 71, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(667)
				p.Statement()
			}

		}
		p.SetState(672)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 71, p.GetParserRuleContext())
	}
	p.SetState(674)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if (int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-575660377648630222) != 0 || (int64((_la-66)) & ^0x3f) == 0 && ((int64(1)<<(_la-66))&70308396531829) != 0 {
		{
			p.SetState(673)
			p.expression(0)
		}

	}
	p.SetState(677)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == CParserSemi {
		{
			p.SetState(676)
			p.Match(CParserSemi)
		}

	}
	{
		p.SetState(679)
		p.Match(CParserRightBrace)
	}
	{
		p.SetState(680)
		p.Match(CParserRightParen)
	}

	return localctx
}

// ILeftExpressionContext is an interface to support dynamic dispatch.
type ILeftExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLeftExpressionContext differentiates from other interfaces.
	IsLeftExpressionContext()
}

type LeftExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLeftExpressionContext() *LeftExpressionContext {
	var p = new(LeftExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CParserRULE_leftExpression
	return p
}

func (*LeftExpressionContext) IsLeftExpressionContext() {}

func NewLeftExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LeftExpressionContext {
	var p = new(LeftExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CParserRULE_leftExpression

	return p
}

func (s *LeftExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *LeftExpressionContext) Star() antlr.TerminalNode {
	return s.GetToken(CParserStar, 0)
}

func (s *LeftExpressionContext) UnaryExpression() IUnaryExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnaryExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnaryExpressionContext)
}

func (s *LeftExpressionContext) AllEos() []IEosContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IEosContext); ok {
			len++
		}
	}

	tst := make([]IEosContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IEosContext); ok {
			tst[i] = t.(IEosContext)
			i++
		}
	}

	return tst
}

func (s *LeftExpressionContext) Eos(i int) IEosContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEosContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEosContext)
}

func (s *LeftExpressionContext) CastExpression() ICastExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICastExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICastExpressionContext)
}

func (s *LeftExpressionContext) PostfixExpressionLvalue() IPostfixExpressionLvalueContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPostfixExpressionLvalueContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPostfixExpressionLvalueContext)
}

func (s *LeftExpressionContext) LeftParen() antlr.TerminalNode {
	return s.GetToken(CParserLeftParen, 0)
}

func (s *LeftExpressionContext) LeftExpression() ILeftExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILeftExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILeftExpressionContext)
}

func (s *LeftExpressionContext) RightParen() antlr.TerminalNode {
	return s.GetToken(CParserRightParen, 0)
}

func (s *LeftExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LeftExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LeftExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CParserVisitor:
		return t.VisitLeftExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CParser) LeftExpression() (localctx ILeftExpressionContext) {
	this := p
	_ = this

	localctx = NewLeftExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 38, CParserRULE_leftExpression)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(715)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 78, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(682)
			p.Match(CParserStar)
		}
		p.SetState(686)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == CParserSemi || _la == CParserEOS {
			{
				p.SetState(683)
				p.Eos()
			}

			p.SetState(688)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(689)
			p.UnaryExpression()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(690)
			p.Match(CParserStar)
		}
		p.SetState(694)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == CParserSemi || _la == CParserEOS {
			{
				p.SetState(691)
				p.Eos()
			}

			p.SetState(696)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(697)
			p.CastExpression()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(698)
			p.PostfixExpressionLvalue()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(699)
			p.Match(CParserLeftParen)
		}
		p.SetState(703)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == CParserSemi || _la == CParserEOS {
			{
				p.SetState(700)
				p.Eos()
			}

			p.SetState(705)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(706)
			p.LeftExpression()
		}
		p.SetState(710)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == CParserSemi || _la == CParserEOS {
			{
				p.SetState(707)
				p.Eos()
			}

			p.SetState(712)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(713)
			p.Match(CParserRightParen)
		}

	}

	return localctx
}

// IExpressionContext is an interface to support dynamic dispatch.
type IExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetUnary_op returns the unary_op token.
	GetUnary_op() antlr.Token

	// GetMul_op returns the mul_op token.
	GetMul_op() antlr.Token

	// GetAdd_op returns the add_op token.
	GetAdd_op() antlr.Token

	// GetRel_op returns the rel_op token.
	GetRel_op() antlr.Token

	// SetUnary_op sets the unary_op token.
	SetUnary_op(antlr.Token)

	// SetMul_op sets the mul_op token.
	SetMul_op(antlr.Token)

	// SetAdd_op sets the add_op token.
	SetAdd_op(antlr.Token)

	// SetRel_op sets the rel_op token.
	SetRel_op(antlr.Token)

	// IsExpressionContext differentiates from other interfaces.
	IsExpressionContext()
}

type ExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser   antlr.Parser
	unary_op antlr.Token
	mul_op   antlr.Token
	add_op   antlr.Token
	rel_op   antlr.Token
}

func NewEmptyExpressionContext() *ExpressionContext {
	var p = new(ExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CParserRULE_expression
	return p
}

func (*ExpressionContext) IsExpressionContext() {}

func NewExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExpressionContext {
	var p = new(ExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CParserRULE_expression

	return p
}

func (s *ExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *ExpressionContext) GetUnary_op() antlr.Token { return s.unary_op }

func (s *ExpressionContext) GetMul_op() antlr.Token { return s.mul_op }

func (s *ExpressionContext) GetAdd_op() antlr.Token { return s.add_op }

func (s *ExpressionContext) GetRel_op() antlr.Token { return s.rel_op }

func (s *ExpressionContext) SetUnary_op(v antlr.Token) { s.unary_op = v }

func (s *ExpressionContext) SetMul_op(v antlr.Token) { s.mul_op = v }

func (s *ExpressionContext) SetAdd_op(v antlr.Token) { s.add_op = v }

func (s *ExpressionContext) SetRel_op(v antlr.Token) { s.rel_op = v }

func (s *ExpressionContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *ExpressionContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ExpressionContext) Tilde() antlr.TerminalNode {
	return s.GetToken(CParserTilde, 0)
}

func (s *ExpressionContext) Plus() antlr.TerminalNode {
	return s.GetToken(CParserPlus, 0)
}

func (s *ExpressionContext) Minus() antlr.TerminalNode {
	return s.GetToken(CParserMinus, 0)
}

func (s *ExpressionContext) Not() antlr.TerminalNode {
	return s.GetToken(CParserNot, 0)
}

func (s *ExpressionContext) Caret() antlr.TerminalNode {
	return s.GetToken(CParserCaret, 0)
}

func (s *ExpressionContext) Star() antlr.TerminalNode {
	return s.GetToken(CParserStar, 0)
}

func (s *ExpressionContext) And() antlr.TerminalNode {
	return s.GetToken(CParserAnd, 0)
}

func (s *ExpressionContext) AllEos() []IEosContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IEosContext); ok {
			len++
		}
	}

	tst := make([]IEosContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IEosContext); ok {
			tst[i] = t.(IEosContext)
			i++
		}
	}

	return tst
}

func (s *ExpressionContext) Eos(i int) IEosContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEosContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEosContext)
}

func (s *ExpressionContext) LeftParen() antlr.TerminalNode {
	return s.GetToken(CParserLeftParen, 0)
}

func (s *ExpressionContext) RightParen() antlr.TerminalNode {
	return s.GetToken(CParserRightParen, 0)
}

func (s *ExpressionContext) CastExpression() ICastExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICastExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICastExpressionContext)
}

func (s *ExpressionContext) StatementsExpression() IStatementsExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementsExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementsExpressionContext)
}

func (s *ExpressionContext) DeclarationSpecifier() IDeclarationSpecifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDeclarationSpecifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDeclarationSpecifierContext)
}

func (s *ExpressionContext) Div() antlr.TerminalNode {
	return s.GetToken(CParserDiv, 0)
}

func (s *ExpressionContext) Mod() antlr.TerminalNode {
	return s.GetToken(CParserMod, 0)
}

func (s *ExpressionContext) LeftShift() antlr.TerminalNode {
	return s.GetToken(CParserLeftShift, 0)
}

func (s *ExpressionContext) RightShift() antlr.TerminalNode {
	return s.GetToken(CParserRightShift, 0)
}

func (s *ExpressionContext) Or() antlr.TerminalNode {
	return s.GetToken(CParserOr, 0)
}

func (s *ExpressionContext) Equal() antlr.TerminalNode {
	return s.GetToken(CParserEqual, 0)
}

func (s *ExpressionContext) NotEqual() antlr.TerminalNode {
	return s.GetToken(CParserNotEqual, 0)
}

func (s *ExpressionContext) Less() antlr.TerminalNode {
	return s.GetToken(CParserLess, 0)
}

func (s *ExpressionContext) LessEqual() antlr.TerminalNode {
	return s.GetToken(CParserLessEqual, 0)
}

func (s *ExpressionContext) Greater() antlr.TerminalNode {
	return s.GetToken(CParserGreater, 0)
}

func (s *ExpressionContext) GreaterEqual() antlr.TerminalNode {
	return s.GetToken(CParserGreaterEqual, 0)
}

func (s *ExpressionContext) AndAnd() antlr.TerminalNode {
	return s.GetToken(CParserAndAnd, 0)
}

func (s *ExpressionContext) OrOr() antlr.TerminalNode {
	return s.GetToken(CParserOrOr, 0)
}

func (s *ExpressionContext) Question() antlr.TerminalNode {
	return s.GetToken(CParserQuestion, 0)
}

func (s *ExpressionContext) Colon() antlr.TerminalNode {
	return s.GetToken(CParserColon, 0)
}

func (s *ExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CParserVisitor:
		return t.VisitExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CParser) Expression() (localctx IExpressionContext) {
	return p.expression(0)
}

func (p *CParser) expression(_p int) (localctx IExpressionContext) {
	this := p
	_ = this

	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()
	_parentState := p.GetState()
	localctx = NewExpressionContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IExpressionContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 40
	p.EnterRecursionRule(localctx, 40, CParserRULE_expression, _p)
	var _la int

	defer func() {
		p.UnrollRecursionContexts(_parentctx)
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(745)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 82, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(718)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*ExpressionContext).unary_op = _lt

			_la = p.GetTokenStream().LA(1)

			if !((int64((_la-59)) & ^0x3f) == 0 && ((int64(1)<<(_la-59))&14485) != 0) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*ExpressionContext).unary_op = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		p.SetState(722)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == CParserSemi || _la == CParserEOS {
			{
				p.SetState(719)
				p.Eos()
			}

			p.SetState(724)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(725)
			p.expression(11)
		}

	case 2:
		{
			p.SetState(726)
			p.Match(CParserLeftParen)
		}
		p.SetState(730)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == CParserSemi || _la == CParserEOS {
			{
				p.SetState(727)
				p.Eos()
			}

			p.SetState(732)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(733)
			p.expression(0)
		}
		p.SetState(737)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == CParserSemi || _la == CParserEOS {
			{
				p.SetState(734)
				p.Eos()
			}

			p.SetState(739)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(740)
			p.Match(CParserRightParen)
		}

	case 3:
		{
			p.SetState(742)
			p.CastExpression()
		}

	case 4:
		{
			p.SetState(743)
			p.StatementsExpression()
		}

	case 5:
		{
			p.SetState(744)
			p.DeclarationSpecifier()
		}

	}
	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(812)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 91, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			p.SetState(810)
			p.GetErrorHandler().Sync(p)
			switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 90, p.GetParserRuleContext()) {
			case 1:
				localctx = NewExpressionContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, CParserRULE_expression)
				p.SetState(747)

				if !(p.Precpred(p.GetParserRuleContext(), 10)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 10)", ""))
				}
				{
					p.SetState(748)

					var _lt = p.GetTokenStream().LT(1)

					localctx.(*ExpressionContext).mul_op = _lt

					_la = p.GetTokenStream().LA(1)

					if !((int64((_la-57)) & ^0x3f) == 0 && ((int64(1)<<(_la-57))&963) != 0) {
						var _ri = p.GetErrorHandler().RecoverInline(p)

						localctx.(*ExpressionContext).mul_op = _ri
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				p.SetState(752)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)

				for _la == CParserSemi || _la == CParserEOS {
					{
						p.SetState(749)
						p.Eos()
					}

					p.SetState(754)
					p.GetErrorHandler().Sync(p)
					_la = p.GetTokenStream().LA(1)
				}
				{
					p.SetState(755)
					p.expression(11)
				}

			case 2:
				localctx = NewExpressionContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, CParserRULE_expression)
				p.SetState(756)

				if !(p.Precpred(p.GetParserRuleContext(), 9)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 9)", ""))
				}
				{
					p.SetState(757)

					var _lt = p.GetTokenStream().LT(1)

					localctx.(*ExpressionContext).add_op = _lt

					_la = p.GetTokenStream().LA(1)

					if !((int64((_la-59)) & ^0x3f) == 0 && ((int64(1)<<(_la-59))&2309) != 0) {
						var _ri = p.GetErrorHandler().RecoverInline(p)

						localctx.(*ExpressionContext).add_op = _ri
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				p.SetState(761)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)

				for _la == CParserSemi || _la == CParserEOS {
					{
						p.SetState(758)
						p.Eos()
					}

					p.SetState(763)
					p.GetErrorHandler().Sync(p)
					_la = p.GetTokenStream().LA(1)
				}
				{
					p.SetState(764)
					p.expression(10)
				}

			case 3:
				localctx = NewExpressionContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, CParserRULE_expression)
				p.SetState(765)

				if !(p.Precpred(p.GetParserRuleContext(), 8)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 8)", ""))
				}
				{
					p.SetState(766)

					var _lt = p.GetTokenStream().LT(1)

					localctx.(*ExpressionContext).rel_op = _lt

					_la = p.GetTokenStream().LA(1)

					if !((int64((_la-53)) & ^0x3f) == 0 && ((int64(1)<<(_la-53))&103079215119) != 0) {
						var _ri = p.GetErrorHandler().RecoverInline(p)

						localctx.(*ExpressionContext).rel_op = _ri
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				p.SetState(770)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)

				for _la == CParserSemi || _la == CParserEOS {
					{
						p.SetState(767)
						p.Eos()
					}

					p.SetState(772)
					p.GetErrorHandler().Sync(p)
					_la = p.GetTokenStream().LA(1)
				}
				{
					p.SetState(773)
					p.expression(9)
				}

			case 4:
				localctx = NewExpressionContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, CParserRULE_expression)
				p.SetState(774)

				if !(p.Precpred(p.GetParserRuleContext(), 7)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 7)", ""))
				}
				{
					p.SetState(775)
					p.Match(CParserAndAnd)
				}
				p.SetState(779)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)

				for _la == CParserSemi || _la == CParserEOS {
					{
						p.SetState(776)
						p.Eos()
					}

					p.SetState(781)
					p.GetErrorHandler().Sync(p)
					_la = p.GetTokenStream().LA(1)
				}
				{
					p.SetState(782)
					p.expression(8)
				}

			case 5:
				localctx = NewExpressionContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, CParserRULE_expression)
				p.SetState(783)

				if !(p.Precpred(p.GetParserRuleContext(), 6)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 6)", ""))
				}
				{
					p.SetState(784)
					p.Match(CParserOrOr)
				}
				p.SetState(788)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)

				for _la == CParserSemi || _la == CParserEOS {
					{
						p.SetState(785)
						p.Eos()
					}

					p.SetState(790)
					p.GetErrorHandler().Sync(p)
					_la = p.GetTokenStream().LA(1)
				}
				{
					p.SetState(791)
					p.expression(7)
				}

			case 6:
				localctx = NewExpressionContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, CParserRULE_expression)
				p.SetState(792)

				if !(p.Precpred(p.GetParserRuleContext(), 4)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 4)", ""))
				}

				{
					p.SetState(793)
					p.Match(CParserQuestion)
				}
				p.SetState(797)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)

				for _la == CParserSemi || _la == CParserEOS {
					{
						p.SetState(794)
						p.Eos()
					}

					p.SetState(799)
					p.GetErrorHandler().Sync(p)
					_la = p.GetTokenStream().LA(1)
				}
				{
					p.SetState(800)
					p.expression(0)
				}
				{
					p.SetState(801)
					p.Match(CParserColon)
				}
				p.SetState(805)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)

				for _la == CParserSemi || _la == CParserEOS {
					{
						p.SetState(802)
						p.Eos()
					}

					p.SetState(807)
					p.GetErrorHandler().Sync(p)
					_la = p.GetTokenStream().LA(1)
				}
				{
					p.SetState(808)
					p.expression(0)
				}

			}

		}
		p.SetState(814)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 91, p.GetParserRuleContext())
	}

	return localctx
}

// IDeclarationContext is an interface to support dynamic dispatch.
type IDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDeclarationContext differentiates from other interfaces.
	IsDeclarationContext()
}

type DeclarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDeclarationContext() *DeclarationContext {
	var p = new(DeclarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CParserRULE_declaration
	return p
}

func (*DeclarationContext) IsDeclarationContext() {}

func NewDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DeclarationContext {
	var p = new(DeclarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CParserRULE_declaration

	return p
}

func (s *DeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *DeclarationContext) DeclarationSpecifier() IDeclarationSpecifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDeclarationSpecifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDeclarationSpecifierContext)
}

func (s *DeclarationContext) Semi() antlr.TerminalNode {
	return s.GetToken(CParserSemi, 0)
}

func (s *DeclarationContext) AllEos() []IEosContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IEosContext); ok {
			len++
		}
	}

	tst := make([]IEosContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IEosContext); ok {
			tst[i] = t.(IEosContext)
			i++
		}
	}

	return tst
}

func (s *DeclarationContext) Eos(i int) IEosContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEosContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEosContext)
}

func (s *DeclarationContext) InitDeclaratorList() IInitDeclaratorListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInitDeclaratorListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInitDeclaratorListContext)
}

func (s *DeclarationContext) MacroCallExpression() IMacroCallExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMacroCallExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMacroCallExpressionContext)
}

func (s *DeclarationContext) AllDeclaratorSuffix() []IDeclaratorSuffixContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IDeclaratorSuffixContext); ok {
			len++
		}
	}

	tst := make([]IDeclaratorSuffixContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IDeclaratorSuffixContext); ok {
			tst[i] = t.(IDeclaratorSuffixContext)
			i++
		}
	}

	return tst
}

func (s *DeclarationContext) DeclaratorSuffix(i int) IDeclaratorSuffixContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDeclaratorSuffixContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDeclaratorSuffixContext)
}

func (s *DeclarationContext) Assign() antlr.TerminalNode {
	return s.GetToken(CParserAssign, 0)
}

func (s *DeclarationContext) Initializer() IInitializerContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInitializerContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInitializerContext)
}

func (s *DeclarationContext) StaticAssertDeclaration() IStaticAssertDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStaticAssertDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStaticAssertDeclarationContext)
}

func (s *DeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DeclarationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CParserVisitor:
		return t.VisitDeclaration(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CParser) Declaration() (localctx IDeclarationContext) {
	this := p
	_ = this

	localctx = NewDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 42, CParserRULE_declaration)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.SetState(859)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 99, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(815)
			p.DeclarationSpecifier()
		}
		p.SetState(819)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 92, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(816)
					p.Eos()
				}

			}
			p.SetState(821)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 92, p.GetParserRuleContext())
		}
		p.SetState(823)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == CParserLeftParen || _la == CParserStar || (int64((_la-70)) & ^0x3f) == 0 && ((int64(1)<<(_la-70))&137438987026433) != 0 {
			{
				p.SetState(822)
				p.InitDeclaratorList()
			}

		}
		p.SetState(828)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 94, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(825)
					p.Eos()
				}

			}
			p.SetState(830)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 94, p.GetParserRuleContext())
		}
		{
			p.SetState(831)
			p.Match(CParserSemi)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(833)
			p.MacroCallExpression()
		}
		p.SetState(837)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == CParserLeftParen || _la == CParserLeftBracket {
			{
				p.SetState(834)
				p.DeclaratorSuffix()
			}

			p.SetState(839)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		p.SetState(843)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 96, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(840)
					p.Eos()
				}

			}
			p.SetState(845)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 96, p.GetParserRuleContext())
		}
		p.SetState(848)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == CParserAssign {
			{
				p.SetState(846)
				p.Match(CParserAssign)
			}
			{
				p.SetState(847)
				p.Initializer()
			}

		}
		p.SetState(853)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 98, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(850)
					p.Eos()
				}

			}
			p.SetState(855)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 98, p.GetParserRuleContext())
		}
		{
			p.SetState(856)
			p.Match(CParserSemi)
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(858)
			p.StaticAssertDeclaration()
		}

	}

	return localctx
}

// IDeclarationSpecifiersContext is an interface to support dynamic dispatch.
type IDeclarationSpecifiersContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDeclarationSpecifiersContext differentiates from other interfaces.
	IsDeclarationSpecifiersContext()
}

type DeclarationSpecifiersContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDeclarationSpecifiersContext() *DeclarationSpecifiersContext {
	var p = new(DeclarationSpecifiersContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CParserRULE_declarationSpecifiers
	return p
}

func (*DeclarationSpecifiersContext) IsDeclarationSpecifiersContext() {}

func NewDeclarationSpecifiersContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DeclarationSpecifiersContext {
	var p = new(DeclarationSpecifiersContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CParserRULE_declarationSpecifiers

	return p
}

func (s *DeclarationSpecifiersContext) GetParser() antlr.Parser { return s.parser }

func (s *DeclarationSpecifiersContext) AllDeclarationSpecifier() []IDeclarationSpecifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IDeclarationSpecifierContext); ok {
			len++
		}
	}

	tst := make([]IDeclarationSpecifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IDeclarationSpecifierContext); ok {
			tst[i] = t.(IDeclarationSpecifierContext)
			i++
		}
	}

	return tst
}

func (s *DeclarationSpecifiersContext) DeclarationSpecifier(i int) IDeclarationSpecifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDeclarationSpecifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDeclarationSpecifierContext)
}

func (s *DeclarationSpecifiersContext) Comma() antlr.TerminalNode {
	return s.GetToken(CParserComma, 0)
}

func (s *DeclarationSpecifiersContext) AllEos() []IEosContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IEosContext); ok {
			len++
		}
	}

	tst := make([]IEosContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IEosContext); ok {
			tst[i] = t.(IEosContext)
			i++
		}
	}

	return tst
}

func (s *DeclarationSpecifiersContext) Eos(i int) IEosContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEosContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEosContext)
}

func (s *DeclarationSpecifiersContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DeclarationSpecifiersContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DeclarationSpecifiersContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CParserVisitor:
		return t.VisitDeclarationSpecifiers(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CParser) DeclarationSpecifiers() (localctx IDeclarationSpecifiersContext) {
	this := p
	_ = this

	localctx = NewDeclarationSpecifiersContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 44, CParserRULE_declarationSpecifiers)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(861)
		p.DeclarationSpecifier()
	}
	p.SetState(870)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == CParserComma {
		{
			p.SetState(862)
			p.Match(CParserComma)
		}
		p.SetState(866)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == CParserSemi || _la == CParserEOS {
			{
				p.SetState(863)
				p.Eos()
			}

			p.SetState(868)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(869)
			p.DeclarationSpecifier()
		}

	}

	return localctx
}

// IDeclarationSpecifiers2Context is an interface to support dynamic dispatch.
type IDeclarationSpecifiers2Context interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDeclarationSpecifiers2Context differentiates from other interfaces.
	IsDeclarationSpecifiers2Context()
}

type DeclarationSpecifiers2Context struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDeclarationSpecifiers2Context() *DeclarationSpecifiers2Context {
	var p = new(DeclarationSpecifiers2Context)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CParserRULE_declarationSpecifiers2
	return p
}

func (*DeclarationSpecifiers2Context) IsDeclarationSpecifiers2Context() {}

func NewDeclarationSpecifiers2Context(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DeclarationSpecifiers2Context {
	var p = new(DeclarationSpecifiers2Context)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CParserRULE_declarationSpecifiers2

	return p
}

func (s *DeclarationSpecifiers2Context) GetParser() antlr.Parser { return s.parser }

func (s *DeclarationSpecifiers2Context) AllDeclarationSpecifier() []IDeclarationSpecifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IDeclarationSpecifierContext); ok {
			len++
		}
	}

	tst := make([]IDeclarationSpecifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IDeclarationSpecifierContext); ok {
			tst[i] = t.(IDeclarationSpecifierContext)
			i++
		}
	}

	return tst
}

func (s *DeclarationSpecifiers2Context) DeclarationSpecifier(i int) IDeclarationSpecifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDeclarationSpecifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDeclarationSpecifierContext)
}

func (s *DeclarationSpecifiers2Context) Comma() antlr.TerminalNode {
	return s.GetToken(CParserComma, 0)
}

func (s *DeclarationSpecifiers2Context) AllEos() []IEosContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IEosContext); ok {
			len++
		}
	}

	tst := make([]IEosContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IEosContext); ok {
			tst[i] = t.(IEosContext)
			i++
		}
	}

	return tst
}

func (s *DeclarationSpecifiers2Context) Eos(i int) IEosContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEosContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEosContext)
}

func (s *DeclarationSpecifiers2Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DeclarationSpecifiers2Context) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DeclarationSpecifiers2Context) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CParserVisitor:
		return t.VisitDeclarationSpecifiers2(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CParser) DeclarationSpecifiers2() (localctx IDeclarationSpecifiers2Context) {
	this := p
	_ = this

	localctx = NewDeclarationSpecifiers2Context(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 46, CParserRULE_declarationSpecifiers2)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(872)
		p.DeclarationSpecifier()
	}
	p.SetState(881)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == CParserComma {
		{
			p.SetState(873)
			p.Match(CParserComma)
		}
		p.SetState(877)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == CParserSemi || _la == CParserEOS {
			{
				p.SetState(874)
				p.Eos()
			}

			p.SetState(879)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(880)
			p.DeclarationSpecifier()
		}

	}

	return localctx
}

// IDeclarationSpecifierContext is an interface to support dynamic dispatch.
type IDeclarationSpecifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDeclarationSpecifierContext differentiates from other interfaces.
	IsDeclarationSpecifierContext()
}

type DeclarationSpecifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDeclarationSpecifierContext() *DeclarationSpecifierContext {
	var p = new(DeclarationSpecifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CParserRULE_declarationSpecifier
	return p
}

func (*DeclarationSpecifierContext) IsDeclarationSpecifierContext() {}

func NewDeclarationSpecifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DeclarationSpecifierContext {
	var p = new(DeclarationSpecifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CParserRULE_declarationSpecifier

	return p
}

func (s *DeclarationSpecifierContext) GetParser() antlr.Parser { return s.parser }

func (s *DeclarationSpecifierContext) TypeSpecifier() ITypeSpecifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeSpecifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeSpecifierContext)
}

func (s *DeclarationSpecifierContext) Identifier() antlr.TerminalNode {
	return s.GetToken(CParserIdentifier, 0)
}

func (s *DeclarationSpecifierContext) AllStorageClassSpecifier() []IStorageClassSpecifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStorageClassSpecifierContext); ok {
			len++
		}
	}

	tst := make([]IStorageClassSpecifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStorageClassSpecifierContext); ok {
			tst[i] = t.(IStorageClassSpecifierContext)
			i++
		}
	}

	return tst
}

func (s *DeclarationSpecifierContext) StorageClassSpecifier(i int) IStorageClassSpecifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStorageClassSpecifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStorageClassSpecifierContext)
}

func (s *DeclarationSpecifierContext) AllTypeQualifier() []ITypeQualifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITypeQualifierContext); ok {
			len++
		}
	}

	tst := make([]ITypeQualifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITypeQualifierContext); ok {
			tst[i] = t.(ITypeQualifierContext)
			i++
		}
	}

	return tst
}

func (s *DeclarationSpecifierContext) TypeQualifier(i int) ITypeQualifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeQualifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeQualifierContext)
}

func (s *DeclarationSpecifierContext) AllFunctionSpecifier() []IFunctionSpecifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IFunctionSpecifierContext); ok {
			len++
		}
	}

	tst := make([]IFunctionSpecifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IFunctionSpecifierContext); ok {
			tst[i] = t.(IFunctionSpecifierContext)
			i++
		}
	}

	return tst
}

func (s *DeclarationSpecifierContext) FunctionSpecifier(i int) IFunctionSpecifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionSpecifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionSpecifierContext)
}

func (s *DeclarationSpecifierContext) StructOrUnion() IStructOrUnionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStructOrUnionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStructOrUnionContext)
}

func (s *DeclarationSpecifierContext) AlignmentSpecifier() IAlignmentSpecifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlignmentSpecifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlignmentSpecifierContext)
}

func (s *DeclarationSpecifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DeclarationSpecifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DeclarationSpecifierContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CParserVisitor:
		return t.VisitDeclarationSpecifier(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CParser) DeclarationSpecifier() (localctx IDeclarationSpecifierContext) {
	this := p
	_ = this

	localctx = NewDeclarationSpecifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 48, CParserRULE_declarationSpecifier)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.SetState(905)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case CParserAuto, CParserChar, CParserConst, CParserDouble, CParserLongdouble, CParserEnum, CParserExtern, CParserFloat, CParserInline, CParserInt, CParserLong, CParserLonglong, CParserRegister, CParserRestrict, CParserShort, CParserSigned, CParserStatic, CParserStruct, CParserTypedef, CParserUnion, CParserUnsigned, CParserVoid, CParserVolatile, CParserAtomic, CParserBool, CParserComplex, CParserNoreturn, CParserThreadLocal, CParserAttribute__, CParserIdentifier, CParserExtension, CParserM128, CParserM128d, CParserM128i, CParserTypeof, CParserInline__, CParserStdcall, CParserDeclspec:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(888)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 105, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				p.SetState(886)
				p.GetErrorHandler().Sync(p)

				switch p.GetTokenStream().LA(1) {
				case CParserAuto, CParserExtern, CParserRegister, CParserStatic, CParserTypedef, CParserThreadLocal:
					{
						p.SetState(883)
						p.StorageClassSpecifier()
					}

				case CParserConst, CParserRestrict, CParserSigned, CParserUnsigned, CParserVolatile, CParserAtomic:
					{
						p.SetState(884)
						p.TypeQualifier()
					}

				case CParserInline, CParserNoreturn, CParserAttribute__, CParserInline__, CParserStdcall, CParserDeclspec:
					{
						p.SetState(885)
						p.FunctionSpecifier()
					}

				default:
					panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
				}

			}
			p.SetState(890)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 105, p.GetParserRuleContext())
		}
		p.SetState(892)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 106, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(891)
				p.StructOrUnion()
			}

		}
		p.SetState(896)
		p.GetErrorHandler().Sync(p)
		switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 107, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(894)
				p.TypeSpecifier()
			}

		case 2:
			{
				p.SetState(895)
				p.Match(CParserIdentifier)
			}

		}
		p.SetState(901)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 108, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(898)
					p.TypeQualifier()
				}

			}
			p.SetState(903)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 108, p.GetParserRuleContext())
		}

	case CParserAlignas:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(904)
			p.AlignmentSpecifier()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IInitDeclaratorListContext is an interface to support dynamic dispatch.
type IInitDeclaratorListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInitDeclaratorListContext differentiates from other interfaces.
	IsInitDeclaratorListContext()
}

type InitDeclaratorListContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInitDeclaratorListContext() *InitDeclaratorListContext {
	var p = new(InitDeclaratorListContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CParserRULE_initDeclaratorList
	return p
}

func (*InitDeclaratorListContext) IsInitDeclaratorListContext() {}

func NewInitDeclaratorListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InitDeclaratorListContext {
	var p = new(InitDeclaratorListContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CParserRULE_initDeclaratorList

	return p
}

func (s *InitDeclaratorListContext) GetParser() antlr.Parser { return s.parser }

func (s *InitDeclaratorListContext) AllInitDeclarator() []IInitDeclaratorContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IInitDeclaratorContext); ok {
			len++
		}
	}

	tst := make([]IInitDeclaratorContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IInitDeclaratorContext); ok {
			tst[i] = t.(IInitDeclaratorContext)
			i++
		}
	}

	return tst
}

func (s *InitDeclaratorListContext) InitDeclarator(i int) IInitDeclaratorContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInitDeclaratorContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInitDeclaratorContext)
}

func (s *InitDeclaratorListContext) AllComma() []antlr.TerminalNode {
	return s.GetTokens(CParserComma)
}

func (s *InitDeclaratorListContext) Comma(i int) antlr.TerminalNode {
	return s.GetToken(CParserComma, i)
}

func (s *InitDeclaratorListContext) AllEos() []IEosContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IEosContext); ok {
			len++
		}
	}

	tst := make([]IEosContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IEosContext); ok {
			tst[i] = t.(IEosContext)
			i++
		}
	}

	return tst
}

func (s *InitDeclaratorListContext) Eos(i int) IEosContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEosContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEosContext)
}

func (s *InitDeclaratorListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InitDeclaratorListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InitDeclaratorListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CParserVisitor:
		return t.VisitInitDeclaratorList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CParser) InitDeclaratorList() (localctx IInitDeclaratorListContext) {
	this := p
	_ = this

	localctx = NewInitDeclaratorListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 50, CParserRULE_initDeclaratorList)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(907)
		p.InitDeclarator()
	}
	p.SetState(918)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 111, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(908)
				p.Match(CParserComma)
			}
			p.SetState(912)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			for _la == CParserSemi || _la == CParserEOS {
				{
					p.SetState(909)
					p.Eos()
				}

				p.SetState(914)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(915)
				p.InitDeclarator()
			}

		}
		p.SetState(920)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 111, p.GetParserRuleContext())
	}

	return localctx
}

// IInitDeclaratorContext is an interface to support dynamic dispatch.
type IInitDeclaratorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInitDeclaratorContext differentiates from other interfaces.
	IsInitDeclaratorContext()
}

type InitDeclaratorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInitDeclaratorContext() *InitDeclaratorContext {
	var p = new(InitDeclaratorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CParserRULE_initDeclarator
	return p
}

func (*InitDeclaratorContext) IsInitDeclaratorContext() {}

func NewInitDeclaratorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InitDeclaratorContext {
	var p = new(InitDeclaratorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CParserRULE_initDeclarator

	return p
}

func (s *InitDeclaratorContext) GetParser() antlr.Parser { return s.parser }

func (s *InitDeclaratorContext) Declarator() IDeclaratorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDeclaratorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDeclaratorContext)
}

func (s *InitDeclaratorContext) Assign() antlr.TerminalNode {
	return s.GetToken(CParserAssign, 0)
}

func (s *InitDeclaratorContext) Initializer() IInitializerContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInitializerContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInitializerContext)
}

func (s *InitDeclaratorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InitDeclaratorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InitDeclaratorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CParserVisitor:
		return t.VisitInitDeclarator(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CParser) InitDeclarator() (localctx IInitDeclaratorContext) {
	this := p
	_ = this

	localctx = NewInitDeclaratorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 52, CParserRULE_initDeclarator)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(921)
		p.Declarator()
	}
	p.SetState(924)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == CParserAssign {
		{
			p.SetState(922)
			p.Match(CParserAssign)
		}
		{
			p.SetState(923)
			p.Initializer()
		}

	}

	return localctx
}

// IStorageClassSpecifierContext is an interface to support dynamic dispatch.
type IStorageClassSpecifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsStorageClassSpecifierContext differentiates from other interfaces.
	IsStorageClassSpecifierContext()
}

type StorageClassSpecifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStorageClassSpecifierContext() *StorageClassSpecifierContext {
	var p = new(StorageClassSpecifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CParserRULE_storageClassSpecifier
	return p
}

func (*StorageClassSpecifierContext) IsStorageClassSpecifierContext() {}

func NewStorageClassSpecifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StorageClassSpecifierContext {
	var p = new(StorageClassSpecifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CParserRULE_storageClassSpecifier

	return p
}

func (s *StorageClassSpecifierContext) GetParser() antlr.Parser { return s.parser }

func (s *StorageClassSpecifierContext) Typedef() antlr.TerminalNode {
	return s.GetToken(CParserTypedef, 0)
}

func (s *StorageClassSpecifierContext) Extern() antlr.TerminalNode {
	return s.GetToken(CParserExtern, 0)
}

func (s *StorageClassSpecifierContext) Static() antlr.TerminalNode {
	return s.GetToken(CParserStatic, 0)
}

func (s *StorageClassSpecifierContext) ThreadLocal() antlr.TerminalNode {
	return s.GetToken(CParserThreadLocal, 0)
}

func (s *StorageClassSpecifierContext) Auto() antlr.TerminalNode {
	return s.GetToken(CParserAuto, 0)
}

func (s *StorageClassSpecifierContext) Register() antlr.TerminalNode {
	return s.GetToken(CParserRegister, 0)
}

func (s *StorageClassSpecifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StorageClassSpecifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StorageClassSpecifierContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CParserVisitor:
		return t.VisitStorageClassSpecifier(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CParser) StorageClassSpecifier() (localctx IStorageClassSpecifierContext) {
	this := p
	_ = this

	localctx = NewStorageClassSpecifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 54, CParserRULE_storageClassSpecifier)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(926)
		_la = p.GetTokenStream().LA(1)

		if !((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&70371164299266) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// ITypeSpecifierContext is an interface to support dynamic dispatch.
type ITypeSpecifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTypeSpecifierContext differentiates from other interfaces.
	IsTypeSpecifierContext()
}

type TypeSpecifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeSpecifierContext() *TypeSpecifierContext {
	var p = new(TypeSpecifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CParserRULE_typeSpecifier
	return p
}

func (*TypeSpecifierContext) IsTypeSpecifierContext() {}

func NewTypeSpecifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeSpecifierContext {
	var p = new(TypeSpecifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CParserRULE_typeSpecifier

	return p
}

func (s *TypeSpecifierContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeSpecifierContext) Void() antlr.TerminalNode {
	return s.GetToken(CParserVoid, 0)
}

func (s *TypeSpecifierContext) Char() antlr.TerminalNode {
	return s.GetToken(CParserChar, 0)
}

func (s *TypeSpecifierContext) Short() antlr.TerminalNode {
	return s.GetToken(CParserShort, 0)
}

func (s *TypeSpecifierContext) Int() antlr.TerminalNode {
	return s.GetToken(CParserInt, 0)
}

func (s *TypeSpecifierContext) Long() antlr.TerminalNode {
	return s.GetToken(CParserLong, 0)
}

func (s *TypeSpecifierContext) Longlong() antlr.TerminalNode {
	return s.GetToken(CParserLonglong, 0)
}

func (s *TypeSpecifierContext) Float() antlr.TerminalNode {
	return s.GetToken(CParserFloat, 0)
}

func (s *TypeSpecifierContext) Double() antlr.TerminalNode {
	return s.GetToken(CParserDouble, 0)
}

func (s *TypeSpecifierContext) Longdouble() antlr.TerminalNode {
	return s.GetToken(CParserLongdouble, 0)
}

func (s *TypeSpecifierContext) Bool() antlr.TerminalNode {
	return s.GetToken(CParserBool, 0)
}

func (s *TypeSpecifierContext) Complex() antlr.TerminalNode {
	return s.GetToken(CParserComplex, 0)
}

func (s *TypeSpecifierContext) M128() antlr.TerminalNode {
	return s.GetToken(CParserM128, 0)
}

func (s *TypeSpecifierContext) M128d() antlr.TerminalNode {
	return s.GetToken(CParserM128d, 0)
}

func (s *TypeSpecifierContext) M128i() antlr.TerminalNode {
	return s.GetToken(CParserM128i, 0)
}

func (s *TypeSpecifierContext) Extension() antlr.TerminalNode {
	return s.GetToken(CParserExtension, 0)
}

func (s *TypeSpecifierContext) LeftParen() antlr.TerminalNode {
	return s.GetToken(CParserLeftParen, 0)
}

func (s *TypeSpecifierContext) RightParen() antlr.TerminalNode {
	return s.GetToken(CParserRightParen, 0)
}

func (s *TypeSpecifierContext) Signed() antlr.TerminalNode {
	return s.GetToken(CParserSigned, 0)
}

func (s *TypeSpecifierContext) Unsigned() antlr.TerminalNode {
	return s.GetToken(CParserUnsigned, 0)
}

func (s *TypeSpecifierContext) AtomicTypeSpecifier() IAtomicTypeSpecifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAtomicTypeSpecifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAtomicTypeSpecifierContext)
}

func (s *TypeSpecifierContext) StructOrUnionSpecifier() IStructOrUnionSpecifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStructOrUnionSpecifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStructOrUnionSpecifierContext)
}

func (s *TypeSpecifierContext) EnumSpecifier() IEnumSpecifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEnumSpecifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEnumSpecifierContext)
}

func (s *TypeSpecifierContext) TypedefName() ITypedefNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypedefNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypedefNameContext)
}

func (s *TypeSpecifierContext) Typeof() antlr.TerminalNode {
	return s.GetToken(CParserTypeof, 0)
}

func (s *TypeSpecifierContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *TypeSpecifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeSpecifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeSpecifierContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CParserVisitor:
		return t.VisitTypeSpecifier(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CParser) TypeSpecifier() (localctx ITypeSpecifierContext) {
	this := p
	_ = this

	localctx = NewTypeSpecifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 56, CParserRULE_typeSpecifier)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(957)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 113, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(928)
			p.Match(CParserVoid)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(929)
			p.Match(CParserChar)
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(930)
			p.Match(CParserShort)
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(931)
			p.Match(CParserInt)
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(932)
			p.Match(CParserLong)
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(933)
			p.Match(CParserLonglong)
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(934)
			p.Match(CParserFloat)
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(935)
			p.Match(CParserDouble)
		}

	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(936)
			p.Match(CParserLongdouble)
		}

	case 10:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(937)
			p.Match(CParserBool)
		}

	case 11:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(938)
			p.Match(CParserComplex)
		}

	case 12:
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(939)
			p.Match(CParserM128)
		}

	case 13:
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(940)
			p.Match(CParserM128d)
		}

	case 14:
		p.EnterOuterAlt(localctx, 14)
		{
			p.SetState(941)
			p.Match(CParserM128i)
		}

	case 15:
		p.EnterOuterAlt(localctx, 15)
		{
			p.SetState(942)
			p.Match(CParserExtension)
		}
		{
			p.SetState(943)
			p.Match(CParserLeftParen)
		}
		{
			p.SetState(944)
			_la = p.GetTokenStream().LA(1)

			if !((int64((_la-105)) & ^0x3f) == 0 && ((int64(1)<<(_la-105))&7) != 0) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(945)
			p.Match(CParserRightParen)
		}

	case 16:
		p.EnterOuterAlt(localctx, 16)
		{
			p.SetState(946)
			p.Match(CParserSigned)
		}

	case 17:
		p.EnterOuterAlt(localctx, 17)
		{
			p.SetState(947)
			p.Match(CParserUnsigned)
		}

	case 18:
		p.EnterOuterAlt(localctx, 18)
		{
			p.SetState(948)
			p.AtomicTypeSpecifier()
		}

	case 19:
		p.EnterOuterAlt(localctx, 19)
		{
			p.SetState(949)
			p.StructOrUnionSpecifier()
		}

	case 20:
		p.EnterOuterAlt(localctx, 20)
		{
			p.SetState(950)
			p.EnumSpecifier()
		}

	case 21:
		p.EnterOuterAlt(localctx, 21)
		{
			p.SetState(951)
			p.TypedefName()
		}

	case 22:
		p.EnterOuterAlt(localctx, 22)
		{
			p.SetState(952)
			p.Match(CParserTypeof)
		}
		{
			p.SetState(953)
			p.Match(CParserLeftParen)
		}
		{
			p.SetState(954)
			p.expression(0)
		}
		{
			p.SetState(955)
			p.Match(CParserRightParen)
		}

	}

	return localctx
}

// IStructOrUnionSpecifierContext is an interface to support dynamic dispatch.
type IStructOrUnionSpecifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsStructOrUnionSpecifierContext differentiates from other interfaces.
	IsStructOrUnionSpecifierContext()
}

type StructOrUnionSpecifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStructOrUnionSpecifierContext() *StructOrUnionSpecifierContext {
	var p = new(StructOrUnionSpecifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CParserRULE_structOrUnionSpecifier
	return p
}

func (*StructOrUnionSpecifierContext) IsStructOrUnionSpecifierContext() {}

func NewStructOrUnionSpecifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StructOrUnionSpecifierContext {
	var p = new(StructOrUnionSpecifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CParserRULE_structOrUnionSpecifier

	return p
}

func (s *StructOrUnionSpecifierContext) GetParser() antlr.Parser { return s.parser }

func (s *StructOrUnionSpecifierContext) StructOrUnion() IStructOrUnionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStructOrUnionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStructOrUnionContext)
}

func (s *StructOrUnionSpecifierContext) LeftBrace() antlr.TerminalNode {
	return s.GetToken(CParserLeftBrace, 0)
}

func (s *StructOrUnionSpecifierContext) StructDeclarationList() IStructDeclarationListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStructDeclarationListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStructDeclarationListContext)
}

func (s *StructOrUnionSpecifierContext) RightBrace() antlr.TerminalNode {
	return s.GetToken(CParserRightBrace, 0)
}

func (s *StructOrUnionSpecifierContext) AllEos() []IEosContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IEosContext); ok {
			len++
		}
	}

	tst := make([]IEosContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IEosContext); ok {
			tst[i] = t.(IEosContext)
			i++
		}
	}

	return tst
}

func (s *StructOrUnionSpecifierContext) Eos(i int) IEosContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEosContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEosContext)
}

func (s *StructOrUnionSpecifierContext) AllIdentifier() []antlr.TerminalNode {
	return s.GetTokens(CParserIdentifier)
}

func (s *StructOrUnionSpecifierContext) Identifier(i int) antlr.TerminalNode {
	return s.GetToken(CParserIdentifier, i)
}

func (s *StructOrUnionSpecifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StructOrUnionSpecifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StructOrUnionSpecifierContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CParserVisitor:
		return t.VisitStructOrUnionSpecifier(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CParser) StructOrUnionSpecifier() (localctx IStructOrUnionSpecifierContext) {
	this := p
	_ = this

	localctx = NewStructOrUnionSpecifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 58, CParserRULE_structOrUnionSpecifier)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(959)
		p.StructOrUnion()
	}
	p.SetState(963)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == CParserSemi || _la == CParserEOS {
		{
			p.SetState(960)
			p.Eos()
		}

		p.SetState(965)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(967)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == CParserIdentifier {
		{
			p.SetState(966)
			p.Match(CParserIdentifier)
		}

	}
	{
		p.SetState(969)
		p.Match(CParserLeftBrace)
	}
	p.SetState(973)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == CParserSemi || _la == CParserEOS {
		{
			p.SetState(970)
			p.Eos()
		}

		p.SetState(975)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(976)
		p.StructDeclarationList()
	}
	p.SetState(980)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == CParserSemi || _la == CParserEOS {
		{
			p.SetState(977)
			p.Eos()
		}

		p.SetState(982)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(983)
		p.Match(CParserRightBrace)
	}
	p.SetState(987)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 118, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(984)
				p.Eos()
			}

		}
		p.SetState(989)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 118, p.GetParserRuleContext())
	}
	p.SetState(991)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 119, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(990)
			p.Match(CParserIdentifier)
		}

	}

	return localctx
}

// IStructOrUnionContext is an interface to support dynamic dispatch.
type IStructOrUnionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsStructOrUnionContext differentiates from other interfaces.
	IsStructOrUnionContext()
}

type StructOrUnionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStructOrUnionContext() *StructOrUnionContext {
	var p = new(StructOrUnionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CParserRULE_structOrUnion
	return p
}

func (*StructOrUnionContext) IsStructOrUnionContext() {}

func NewStructOrUnionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StructOrUnionContext {
	var p = new(StructOrUnionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CParserRULE_structOrUnion

	return p
}

func (s *StructOrUnionContext) GetParser() antlr.Parser { return s.parser }

func (s *StructOrUnionContext) Struct() antlr.TerminalNode {
	return s.GetToken(CParserStruct, 0)
}

func (s *StructOrUnionContext) Union() antlr.TerminalNode {
	return s.GetToken(CParserUnion, 0)
}

func (s *StructOrUnionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StructOrUnionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StructOrUnionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CParserVisitor:
		return t.VisitStructOrUnion(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CParser) StructOrUnion() (localctx IStructOrUnionContext) {
	this := p
	_ = this

	localctx = NewStructOrUnionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 60, CParserRULE_structOrUnion)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(993)
		_la = p.GetTokenStream().LA(1)

		if !(_la == CParserStruct || _la == CParserUnion) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IStructDeclarationListContext is an interface to support dynamic dispatch.
type IStructDeclarationListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsStructDeclarationListContext differentiates from other interfaces.
	IsStructDeclarationListContext()
}

type StructDeclarationListContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStructDeclarationListContext() *StructDeclarationListContext {
	var p = new(StructDeclarationListContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CParserRULE_structDeclarationList
	return p
}

func (*StructDeclarationListContext) IsStructDeclarationListContext() {}

func NewStructDeclarationListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StructDeclarationListContext {
	var p = new(StructDeclarationListContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CParserRULE_structDeclarationList

	return p
}

func (s *StructDeclarationListContext) GetParser() antlr.Parser { return s.parser }

func (s *StructDeclarationListContext) AllStructDeclaration() []IStructDeclarationContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStructDeclarationContext); ok {
			len++
		}
	}

	tst := make([]IStructDeclarationContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStructDeclarationContext); ok {
			tst[i] = t.(IStructDeclarationContext)
			i++
		}
	}

	return tst
}

func (s *StructDeclarationListContext) StructDeclaration(i int) IStructDeclarationContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStructDeclarationContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStructDeclarationContext)
}

func (s *StructDeclarationListContext) AllWs() []IWsContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IWsContext); ok {
			len++
		}
	}

	tst := make([]IWsContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IWsContext); ok {
			tst[i] = t.(IWsContext)
			i++
		}
	}

	return tst
}

func (s *StructDeclarationListContext) Ws(i int) IWsContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWsContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWsContext)
}

func (s *StructDeclarationListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StructDeclarationListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StructDeclarationListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CParserVisitor:
		return t.VisitStructDeclarationList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CParser) StructDeclarationList() (localctx IStructDeclarationListContext) {
	this := p
	_ = this

	localctx = NewStructDeclarationListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 62, CParserRULE_structDeclarationList)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1002)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = (int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&39097736910384) != 0 || (int64((_la-95)) & ^0x3f) == 0 && ((int64(1)<<(_la-95))&15489) != 0 {
		{
			p.SetState(995)
			p.StructDeclaration()
		}
		p.SetState(999)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 120, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(996)
					p.Ws()
				}

			}
			p.SetState(1001)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 120, p.GetParserRuleContext())
		}

		p.SetState(1004)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IStructDeclarationContext is an interface to support dynamic dispatch.
type IStructDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsStructDeclarationContext differentiates from other interfaces.
	IsStructDeclarationContext()
}

type StructDeclarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStructDeclarationContext() *StructDeclarationContext {
	var p = new(StructDeclarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CParserRULE_structDeclaration
	return p
}

func (*StructDeclarationContext) IsStructDeclarationContext() {}

func NewStructDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StructDeclarationContext {
	var p = new(StructDeclarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CParserRULE_structDeclaration

	return p
}

func (s *StructDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *StructDeclarationContext) SpecifierQualifierList() ISpecifierQualifierListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISpecifierQualifierListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISpecifierQualifierListContext)
}

func (s *StructDeclarationContext) StructDeclaratorList() IStructDeclaratorListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStructDeclaratorListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStructDeclaratorListContext)
}

func (s *StructDeclarationContext) Semi() antlr.TerminalNode {
	return s.GetToken(CParserSemi, 0)
}

func (s *StructDeclarationContext) AllEos() []IEosContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IEosContext); ok {
			len++
		}
	}

	tst := make([]IEosContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IEosContext); ok {
			tst[i] = t.(IEosContext)
			i++
		}
	}

	return tst
}

func (s *StructDeclarationContext) Eos(i int) IEosContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEosContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEosContext)
}

func (s *StructDeclarationContext) StaticAssertDeclaration() IStaticAssertDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStaticAssertDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStaticAssertDeclarationContext)
}

func (s *StructDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StructDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StructDeclarationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CParserVisitor:
		return t.VisitStructDeclaration(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CParser) StructDeclaration() (localctx IStructDeclarationContext) {
	this := p
	_ = this

	localctx = NewStructDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 64, CParserRULE_structDeclaration)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.SetState(1032)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 125, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1006)
			p.SpecifierQualifierList()
		}
		p.SetState(1010)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == CParserSemi || _la == CParserEOS {
			{
				p.SetState(1007)
				p.Eos()
			}

			p.SetState(1012)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1013)
			p.StructDeclaratorList()
		}
		p.SetState(1017)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 123, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(1014)
					p.Eos()
				}

			}
			p.SetState(1019)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 123, p.GetParserRuleContext())
		}
		{
			p.SetState(1020)
			p.Match(CParserSemi)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1022)
			p.SpecifierQualifierList()
		}
		p.SetState(1026)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 124, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(1023)
					p.Eos()
				}

			}
			p.SetState(1028)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 124, p.GetParserRuleContext())
		}
		{
			p.SetState(1029)
			p.Match(CParserSemi)
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1031)
			p.StaticAssertDeclaration()
		}

	}

	return localctx
}

// ISpecifierQualifierListContext is an interface to support dynamic dispatch.
type ISpecifierQualifierListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSpecifierQualifierListContext differentiates from other interfaces.
	IsSpecifierQualifierListContext()
}

type SpecifierQualifierListContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySpecifierQualifierListContext() *SpecifierQualifierListContext {
	var p = new(SpecifierQualifierListContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CParserRULE_specifierQualifierList
	return p
}

func (*SpecifierQualifierListContext) IsSpecifierQualifierListContext() {}

func NewSpecifierQualifierListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SpecifierQualifierListContext {
	var p = new(SpecifierQualifierListContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CParserRULE_specifierQualifierList

	return p
}

func (s *SpecifierQualifierListContext) GetParser() antlr.Parser { return s.parser }

func (s *SpecifierQualifierListContext) TypeSpecifier() ITypeSpecifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeSpecifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeSpecifierContext)
}

func (s *SpecifierQualifierListContext) TypeQualifier() ITypeQualifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeQualifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeQualifierContext)
}

func (s *SpecifierQualifierListContext) SpecifierQualifierList() ISpecifierQualifierListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISpecifierQualifierListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISpecifierQualifierListContext)
}

func (s *SpecifierQualifierListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SpecifierQualifierListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SpecifierQualifierListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CParserVisitor:
		return t.VisitSpecifierQualifierList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CParser) SpecifierQualifierList() (localctx ISpecifierQualifierListContext) {
	this := p
	_ = this

	localctx = NewSpecifierQualifierListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 66, CParserRULE_specifierQualifierList)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1036)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 126, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(1034)
			p.TypeSpecifier()
		}

	case 2:
		{
			p.SetState(1035)
			p.TypeQualifier()
		}

	}
	p.SetState(1039)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 127, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1038)
			p.SpecifierQualifierList()
		}

	}

	return localctx
}

// IStructDeclaratorListContext is an interface to support dynamic dispatch.
type IStructDeclaratorListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsStructDeclaratorListContext differentiates from other interfaces.
	IsStructDeclaratorListContext()
}

type StructDeclaratorListContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStructDeclaratorListContext() *StructDeclaratorListContext {
	var p = new(StructDeclaratorListContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CParserRULE_structDeclaratorList
	return p
}

func (*StructDeclaratorListContext) IsStructDeclaratorListContext() {}

func NewStructDeclaratorListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StructDeclaratorListContext {
	var p = new(StructDeclaratorListContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CParserRULE_structDeclaratorList

	return p
}

func (s *StructDeclaratorListContext) GetParser() antlr.Parser { return s.parser }

func (s *StructDeclaratorListContext) AllStructDeclarator() []IStructDeclaratorContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStructDeclaratorContext); ok {
			len++
		}
	}

	tst := make([]IStructDeclaratorContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStructDeclaratorContext); ok {
			tst[i] = t.(IStructDeclaratorContext)
			i++
		}
	}

	return tst
}

func (s *StructDeclaratorListContext) StructDeclarator(i int) IStructDeclaratorContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStructDeclaratorContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStructDeclaratorContext)
}

func (s *StructDeclaratorListContext) AllComma() []antlr.TerminalNode {
	return s.GetTokens(CParserComma)
}

func (s *StructDeclaratorListContext) Comma(i int) antlr.TerminalNode {
	return s.GetToken(CParserComma, i)
}

func (s *StructDeclaratorListContext) AllEos() []IEosContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IEosContext); ok {
			len++
		}
	}

	tst := make([]IEosContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IEosContext); ok {
			tst[i] = t.(IEosContext)
			i++
		}
	}

	return tst
}

func (s *StructDeclaratorListContext) Eos(i int) IEosContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEosContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEosContext)
}

func (s *StructDeclaratorListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StructDeclaratorListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StructDeclaratorListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CParserVisitor:
		return t.VisitStructDeclaratorList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CParser) StructDeclaratorList() (localctx IStructDeclaratorListContext) {
	this := p
	_ = this

	localctx = NewStructDeclaratorListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 68, CParserRULE_structDeclaratorList)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1041)
		p.StructDeclarator()
	}
	p.SetState(1052)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == CParserComma {
		{
			p.SetState(1042)
			p.Match(CParserComma)
		}
		p.SetState(1046)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == CParserSemi || _la == CParserEOS {
			{
				p.SetState(1043)
				p.Eos()
			}

			p.SetState(1048)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1049)
			p.StructDeclarator()
		}

		p.SetState(1054)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IStructDeclaratorContext is an interface to support dynamic dispatch.
type IStructDeclaratorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsStructDeclaratorContext differentiates from other interfaces.
	IsStructDeclaratorContext()
}

type StructDeclaratorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStructDeclaratorContext() *StructDeclaratorContext {
	var p = new(StructDeclaratorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CParserRULE_structDeclarator
	return p
}

func (*StructDeclaratorContext) IsStructDeclaratorContext() {}

func NewStructDeclaratorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StructDeclaratorContext {
	var p = new(StructDeclaratorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CParserRULE_structDeclarator

	return p
}

func (s *StructDeclaratorContext) GetParser() antlr.Parser { return s.parser }

func (s *StructDeclaratorContext) Declarator() IDeclaratorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDeclaratorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDeclaratorContext)
}

func (s *StructDeclaratorContext) Colon() antlr.TerminalNode {
	return s.GetToken(CParserColon, 0)
}

func (s *StructDeclaratorContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *StructDeclaratorContext) AllEos() []IEosContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IEosContext); ok {
			len++
		}
	}

	tst := make([]IEosContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IEosContext); ok {
			tst[i] = t.(IEosContext)
			i++
		}
	}

	return tst
}

func (s *StructDeclaratorContext) Eos(i int) IEosContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEosContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEosContext)
}

func (s *StructDeclaratorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StructDeclaratorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StructDeclaratorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CParserVisitor:
		return t.VisitStructDeclarator(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CParser) StructDeclarator() (localctx IStructDeclaratorContext) {
	this := p
	_ = this

	localctx = NewStructDeclaratorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 70, CParserRULE_structDeclarator)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1067)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 132, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1055)
			p.Declarator()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(1057)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == CParserLeftParen || _la == CParserStar || (int64((_la-70)) & ^0x3f) == 0 && ((int64(1)<<(_la-70))&137438987026433) != 0 {
			{
				p.SetState(1056)
				p.Declarator()
			}

		}
		{
			p.SetState(1059)
			p.Match(CParserColon)
		}
		p.SetState(1063)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == CParserSemi || _la == CParserEOS {
			{
				p.SetState(1060)
				p.Eos()
			}

			p.SetState(1065)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1066)
			p.expression(0)
		}

	}

	return localctx
}

// IEnumSpecifierContext is an interface to support dynamic dispatch.
type IEnumSpecifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEnumSpecifierContext differentiates from other interfaces.
	IsEnumSpecifierContext()
}

type EnumSpecifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEnumSpecifierContext() *EnumSpecifierContext {
	var p = new(EnumSpecifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CParserRULE_enumSpecifier
	return p
}

func (*EnumSpecifierContext) IsEnumSpecifierContext() {}

func NewEnumSpecifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EnumSpecifierContext {
	var p = new(EnumSpecifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CParserRULE_enumSpecifier

	return p
}

func (s *EnumSpecifierContext) GetParser() antlr.Parser { return s.parser }

func (s *EnumSpecifierContext) Enum() antlr.TerminalNode {
	return s.GetToken(CParserEnum, 0)
}

func (s *EnumSpecifierContext) LeftBrace() antlr.TerminalNode {
	return s.GetToken(CParserLeftBrace, 0)
}

func (s *EnumSpecifierContext) EnumeratorList() IEnumeratorListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEnumeratorListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEnumeratorListContext)
}

func (s *EnumSpecifierContext) RightBrace() antlr.TerminalNode {
	return s.GetToken(CParserRightBrace, 0)
}

func (s *EnumSpecifierContext) AllEos() []IEosContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IEosContext); ok {
			len++
		}
	}

	tst := make([]IEosContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IEosContext); ok {
			tst[i] = t.(IEosContext)
			i++
		}
	}

	return tst
}

func (s *EnumSpecifierContext) Eos(i int) IEosContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEosContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEosContext)
}

func (s *EnumSpecifierContext) Identifier() antlr.TerminalNode {
	return s.GetToken(CParserIdentifier, 0)
}

func (s *EnumSpecifierContext) Comma() antlr.TerminalNode {
	return s.GetToken(CParserComma, 0)
}

func (s *EnumSpecifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EnumSpecifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EnumSpecifierContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CParserVisitor:
		return t.VisitEnumSpecifier(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CParser) EnumSpecifier() (localctx IEnumSpecifierContext) {
	this := p
	_ = this

	localctx = NewEnumSpecifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 72, CParserRULE_enumSpecifier)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.SetState(1112)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 140, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1069)
			p.Match(CParserEnum)
		}
		p.SetState(1073)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == CParserSemi || _la == CParserEOS {
			{
				p.SetState(1070)
				p.Eos()
			}

			p.SetState(1075)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		p.SetState(1077)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == CParserIdentifier {
			{
				p.SetState(1076)
				p.Match(CParserIdentifier)
			}

		}
		{
			p.SetState(1079)
			p.Match(CParserLeftBrace)
		}
		p.SetState(1083)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == CParserSemi || _la == CParserEOS {
			{
				p.SetState(1080)
				p.Eos()
			}

			p.SetState(1085)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1086)
			p.EnumeratorList()
		}
		p.SetState(1090)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 136, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(1087)
					p.Eos()
				}

			}
			p.SetState(1092)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 136, p.GetParserRuleContext())
		}
		p.SetState(1094)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == CParserComma {
			{
				p.SetState(1093)
				p.Match(CParserComma)
			}

		}
		p.SetState(1099)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == CParserSemi || _la == CParserEOS {
			{
				p.SetState(1096)
				p.Eos()
			}

			p.SetState(1101)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1102)
			p.Match(CParserRightBrace)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1104)
			p.Match(CParserEnum)
		}
		p.SetState(1108)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == CParserSemi || _la == CParserEOS {
			{
				p.SetState(1105)
				p.Eos()
			}

			p.SetState(1110)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1111)
			p.Match(CParserIdentifier)
		}

	}

	return localctx
}

// IEnumeratorListContext is an interface to support dynamic dispatch.
type IEnumeratorListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEnumeratorListContext differentiates from other interfaces.
	IsEnumeratorListContext()
}

type EnumeratorListContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEnumeratorListContext() *EnumeratorListContext {
	var p = new(EnumeratorListContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CParserRULE_enumeratorList
	return p
}

func (*EnumeratorListContext) IsEnumeratorListContext() {}

func NewEnumeratorListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EnumeratorListContext {
	var p = new(EnumeratorListContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CParserRULE_enumeratorList

	return p
}

func (s *EnumeratorListContext) GetParser() antlr.Parser { return s.parser }

func (s *EnumeratorListContext) AllEnumerator() []IEnumeratorContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IEnumeratorContext); ok {
			len++
		}
	}

	tst := make([]IEnumeratorContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IEnumeratorContext); ok {
			tst[i] = t.(IEnumeratorContext)
			i++
		}
	}

	return tst
}

func (s *EnumeratorListContext) Enumerator(i int) IEnumeratorContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEnumeratorContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEnumeratorContext)
}

func (s *EnumeratorListContext) AllComma() []antlr.TerminalNode {
	return s.GetTokens(CParserComma)
}

func (s *EnumeratorListContext) Comma(i int) antlr.TerminalNode {
	return s.GetToken(CParserComma, i)
}

func (s *EnumeratorListContext) AllEos() []IEosContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IEosContext); ok {
			len++
		}
	}

	tst := make([]IEosContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IEosContext); ok {
			tst[i] = t.(IEosContext)
			i++
		}
	}

	return tst
}

func (s *EnumeratorListContext) Eos(i int) IEosContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEosContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEosContext)
}

func (s *EnumeratorListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EnumeratorListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EnumeratorListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CParserVisitor:
		return t.VisitEnumeratorList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CParser) EnumeratorList() (localctx IEnumeratorListContext) {
	this := p
	_ = this

	localctx = NewEnumeratorListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 74, CParserRULE_enumeratorList)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1114)
		p.Enumerator()
	}
	p.SetState(1125)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 142, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1115)
				p.Match(CParserComma)
			}
			p.SetState(1119)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			for _la == CParserSemi || _la == CParserEOS {
				{
					p.SetState(1116)
					p.Eos()
				}

				p.SetState(1121)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(1122)
				p.Enumerator()
			}

		}
		p.SetState(1127)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 142, p.GetParserRuleContext())
	}

	return localctx
}

// IEnumeratorContext is an interface to support dynamic dispatch.
type IEnumeratorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEnumeratorContext differentiates from other interfaces.
	IsEnumeratorContext()
}

type EnumeratorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEnumeratorContext() *EnumeratorContext {
	var p = new(EnumeratorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CParserRULE_enumerator
	return p
}

func (*EnumeratorContext) IsEnumeratorContext() {}

func NewEnumeratorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EnumeratorContext {
	var p = new(EnumeratorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CParserRULE_enumerator

	return p
}

func (s *EnumeratorContext) GetParser() antlr.Parser { return s.parser }

func (s *EnumeratorContext) Identifier() antlr.TerminalNode {
	return s.GetToken(CParserIdentifier, 0)
}

func (s *EnumeratorContext) GccAttributeSpecifier() IGccAttributeSpecifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGccAttributeSpecifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGccAttributeSpecifierContext)
}

func (s *EnumeratorContext) AllEos() []IEosContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IEosContext); ok {
			len++
		}
	}

	tst := make([]IEosContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IEosContext); ok {
			tst[i] = t.(IEosContext)
			i++
		}
	}

	return tst
}

func (s *EnumeratorContext) Eos(i int) IEosContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEosContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEosContext)
}

func (s *EnumeratorContext) Assign() antlr.TerminalNode {
	return s.GetToken(CParserAssign, 0)
}

func (s *EnumeratorContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *EnumeratorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EnumeratorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EnumeratorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CParserVisitor:
		return t.VisitEnumerator(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CParser) Enumerator() (localctx IEnumeratorContext) {
	this := p
	_ = this

	localctx = NewEnumeratorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 76, CParserRULE_enumerator)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1157)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 148, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1128)
			p.Match(CParserIdentifier)
		}
		p.SetState(1132)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == CParserSemi || _la == CParserEOS {
			{
				p.SetState(1129)
				p.Eos()
			}

			p.SetState(1134)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1135)
			p.GccAttributeSpecifier()
		}
		p.SetState(1144)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == CParserAssign {
			{
				p.SetState(1136)
				p.Match(CParserAssign)
			}
			p.SetState(1140)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			for _la == CParserSemi || _la == CParserEOS {
				{
					p.SetState(1137)
					p.Eos()
				}

				p.SetState(1142)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(1143)
				p.expression(0)
			}

		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1146)
			p.Match(CParserIdentifier)
		}
		p.SetState(1155)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == CParserAssign {
			{
				p.SetState(1147)
				p.Match(CParserAssign)
			}
			p.SetState(1151)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			for _la == CParserSemi || _la == CParserEOS {
				{
					p.SetState(1148)
					p.Eos()
				}

				p.SetState(1153)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(1154)
				p.expression(0)
			}

		}

	}

	return localctx
}

// IAtomicTypeSpecifierContext is an interface to support dynamic dispatch.
type IAtomicTypeSpecifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAtomicTypeSpecifierContext differentiates from other interfaces.
	IsAtomicTypeSpecifierContext()
}

type AtomicTypeSpecifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAtomicTypeSpecifierContext() *AtomicTypeSpecifierContext {
	var p = new(AtomicTypeSpecifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CParserRULE_atomicTypeSpecifier
	return p
}

func (*AtomicTypeSpecifierContext) IsAtomicTypeSpecifierContext() {}

func NewAtomicTypeSpecifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AtomicTypeSpecifierContext {
	var p = new(AtomicTypeSpecifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CParserRULE_atomicTypeSpecifier

	return p
}

func (s *AtomicTypeSpecifierContext) GetParser() antlr.Parser { return s.parser }

func (s *AtomicTypeSpecifierContext) Atomic() antlr.TerminalNode {
	return s.GetToken(CParserAtomic, 0)
}

func (s *AtomicTypeSpecifierContext) LeftParen() antlr.TerminalNode {
	return s.GetToken(CParserLeftParen, 0)
}

func (s *AtomicTypeSpecifierContext) TypeName() ITypeNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeNameContext)
}

func (s *AtomicTypeSpecifierContext) RightParen() antlr.TerminalNode {
	return s.GetToken(CParserRightParen, 0)
}

func (s *AtomicTypeSpecifierContext) AllEos() []IEosContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IEosContext); ok {
			len++
		}
	}

	tst := make([]IEosContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IEosContext); ok {
			tst[i] = t.(IEosContext)
			i++
		}
	}

	return tst
}

func (s *AtomicTypeSpecifierContext) Eos(i int) IEosContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEosContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEosContext)
}

func (s *AtomicTypeSpecifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AtomicTypeSpecifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AtomicTypeSpecifierContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CParserVisitor:
		return t.VisitAtomicTypeSpecifier(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CParser) AtomicTypeSpecifier() (localctx IAtomicTypeSpecifierContext) {
	this := p
	_ = this

	localctx = NewAtomicTypeSpecifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 78, CParserRULE_atomicTypeSpecifier)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1159)
		p.Match(CParserAtomic)
	}
	{
		p.SetState(1160)
		p.Match(CParserLeftParen)
	}
	p.SetState(1164)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == CParserSemi || _la == CParserEOS {
		{
			p.SetState(1161)
			p.Eos()
		}

		p.SetState(1166)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1167)
		p.typeName(0)
	}
	p.SetState(1171)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == CParserSemi || _la == CParserEOS {
		{
			p.SetState(1168)
			p.Eos()
		}

		p.SetState(1173)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1174)
		p.Match(CParserRightParen)
	}

	return localctx
}

// ITypeQualifierContext is an interface to support dynamic dispatch.
type ITypeQualifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTypeQualifierContext differentiates from other interfaces.
	IsTypeQualifierContext()
}

type TypeQualifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeQualifierContext() *TypeQualifierContext {
	var p = new(TypeQualifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CParserRULE_typeQualifier
	return p
}

func (*TypeQualifierContext) IsTypeQualifierContext() {}

func NewTypeQualifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeQualifierContext {
	var p = new(TypeQualifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CParserRULE_typeQualifier

	return p
}

func (s *TypeQualifierContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeQualifierContext) Const() antlr.TerminalNode {
	return s.GetToken(CParserConst, 0)
}

func (s *TypeQualifierContext) Restrict() antlr.TerminalNode {
	return s.GetToken(CParserRestrict, 0)
}

func (s *TypeQualifierContext) Volatile() antlr.TerminalNode {
	return s.GetToken(CParserVolatile, 0)
}

func (s *TypeQualifierContext) Atomic() antlr.TerminalNode {
	return s.GetToken(CParserAtomic, 0)
}

func (s *TypeQualifierContext) Signed() antlr.TerminalNode {
	return s.GetToken(CParserSigned, 0)
}

func (s *TypeQualifierContext) Unsigned() antlr.TerminalNode {
	return s.GetToken(CParserUnsigned, 0)
}

func (s *TypeQualifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeQualifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeQualifierContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CParserVisitor:
		return t.VisitTypeQualifier(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CParser) TypeQualifier() (localctx ITypeQualifierContext) {
	this := p
	_ = this

	localctx = NewTypeQualifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 80, CParserRULE_typeQualifier)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1176)
		_la = p.GetTokenStream().LA(1)

		if !((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&592780984352) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IFunctionSpecifierContext is an interface to support dynamic dispatch.
type IFunctionSpecifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFunctionSpecifierContext differentiates from other interfaces.
	IsFunctionSpecifierContext()
}

type FunctionSpecifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunctionSpecifierContext() *FunctionSpecifierContext {
	var p = new(FunctionSpecifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CParserRULE_functionSpecifier
	return p
}

func (*FunctionSpecifierContext) IsFunctionSpecifierContext() {}

func NewFunctionSpecifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FunctionSpecifierContext {
	var p = new(FunctionSpecifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CParserRULE_functionSpecifier

	return p
}

func (s *FunctionSpecifierContext) GetParser() antlr.Parser { return s.parser }

func (s *FunctionSpecifierContext) Inline() antlr.TerminalNode {
	return s.GetToken(CParserInline, 0)
}

func (s *FunctionSpecifierContext) Noreturn() antlr.TerminalNode {
	return s.GetToken(CParserNoreturn, 0)
}

func (s *FunctionSpecifierContext) Inline__() antlr.TerminalNode {
	return s.GetToken(CParserInline__, 0)
}

func (s *FunctionSpecifierContext) Stdcall() antlr.TerminalNode {
	return s.GetToken(CParserStdcall, 0)
}

func (s *FunctionSpecifierContext) GccAttributeSpecifier() IGccAttributeSpecifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGccAttributeSpecifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGccAttributeSpecifierContext)
}

func (s *FunctionSpecifierContext) Declspec() antlr.TerminalNode {
	return s.GetToken(CParserDeclspec, 0)
}

func (s *FunctionSpecifierContext) LeftParen() antlr.TerminalNode {
	return s.GetToken(CParserLeftParen, 0)
}

func (s *FunctionSpecifierContext) Identifier() antlr.TerminalNode {
	return s.GetToken(CParserIdentifier, 0)
}

func (s *FunctionSpecifierContext) RightParen() antlr.TerminalNode {
	return s.GetToken(CParserRightParen, 0)
}

func (s *FunctionSpecifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FunctionSpecifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FunctionSpecifierContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CParserVisitor:
		return t.VisitFunctionSpecifier(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CParser) FunctionSpecifier() (localctx IFunctionSpecifierContext) {
	this := p
	_ = this

	localctx = NewFunctionSpecifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 82, CParserRULE_functionSpecifier)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1187)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case CParserInline:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1178)
			p.Match(CParserInline)
		}

	case CParserNoreturn:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1179)
			p.Match(CParserNoreturn)
		}

	case CParserInline__:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1180)
			p.Match(CParserInline__)
		}

	case CParserStdcall:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1181)
			p.Match(CParserStdcall)
		}

	case CParserAttribute__:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1182)
			p.GccAttributeSpecifier()
		}

	case CParserDeclspec:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(1183)
			p.Match(CParserDeclspec)
		}
		{
			p.SetState(1184)
			p.Match(CParserLeftParen)
		}
		{
			p.SetState(1185)
			p.Match(CParserIdentifier)
		}
		{
			p.SetState(1186)
			p.Match(CParserRightParen)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IAlignmentSpecifierContext is an interface to support dynamic dispatch.
type IAlignmentSpecifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAlignmentSpecifierContext differentiates from other interfaces.
	IsAlignmentSpecifierContext()
}

type AlignmentSpecifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlignmentSpecifierContext() *AlignmentSpecifierContext {
	var p = new(AlignmentSpecifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CParserRULE_alignmentSpecifier
	return p
}

func (*AlignmentSpecifierContext) IsAlignmentSpecifierContext() {}

func NewAlignmentSpecifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlignmentSpecifierContext {
	var p = new(AlignmentSpecifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CParserRULE_alignmentSpecifier

	return p
}

func (s *AlignmentSpecifierContext) GetParser() antlr.Parser { return s.parser }

func (s *AlignmentSpecifierContext) Alignas() antlr.TerminalNode {
	return s.GetToken(CParserAlignas, 0)
}

func (s *AlignmentSpecifierContext) LeftParen() antlr.TerminalNode {
	return s.GetToken(CParserLeftParen, 0)
}

func (s *AlignmentSpecifierContext) RightParen() antlr.TerminalNode {
	return s.GetToken(CParserRightParen, 0)
}

func (s *AlignmentSpecifierContext) TypeName() ITypeNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeNameContext)
}

func (s *AlignmentSpecifierContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *AlignmentSpecifierContext) AllEos() []IEosContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IEosContext); ok {
			len++
		}
	}

	tst := make([]IEosContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IEosContext); ok {
			tst[i] = t.(IEosContext)
			i++
		}
	}

	return tst
}

func (s *AlignmentSpecifierContext) Eos(i int) IEosContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEosContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEosContext)
}

func (s *AlignmentSpecifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlignmentSpecifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AlignmentSpecifierContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CParserVisitor:
		return t.VisitAlignmentSpecifier(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CParser) AlignmentSpecifier() (localctx IAlignmentSpecifierContext) {
	this := p
	_ = this

	localctx = NewAlignmentSpecifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 84, CParserRULE_alignmentSpecifier)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1189)
		p.Match(CParserAlignas)
	}
	{
		p.SetState(1190)
		p.Match(CParserLeftParen)
	}
	p.SetState(1194)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == CParserSemi || _la == CParserEOS {
		{
			p.SetState(1191)
			p.Eos()
		}

		p.SetState(1196)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(1199)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 153, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(1197)
			p.typeName(0)
		}

	case 2:
		{
			p.SetState(1198)
			p.expression(0)
		}

	}
	p.SetState(1204)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == CParserSemi || _la == CParserEOS {
		{
			p.SetState(1201)
			p.Eos()
		}

		p.SetState(1206)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1207)
		p.Match(CParserRightParen)
	}

	return localctx
}

// IDeclaratorContext is an interface to support dynamic dispatch.
type IDeclaratorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDeclaratorContext differentiates from other interfaces.
	IsDeclaratorContext()
}

type DeclaratorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDeclaratorContext() *DeclaratorContext {
	var p = new(DeclaratorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CParserRULE_declarator
	return p
}

func (*DeclaratorContext) IsDeclaratorContext() {}

func NewDeclaratorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DeclaratorContext {
	var p = new(DeclaratorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CParserRULE_declarator

	return p
}

func (s *DeclaratorContext) GetParser() antlr.Parser { return s.parser }

func (s *DeclaratorContext) DirectDeclarator() IDirectDeclaratorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDirectDeclaratorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDirectDeclaratorContext)
}

func (s *DeclaratorContext) Pointer() IPointerContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPointerContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPointerContext)
}

func (s *DeclaratorContext) AllGccDeclaratorExtension() []IGccDeclaratorExtensionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IGccDeclaratorExtensionContext); ok {
			len++
		}
	}

	tst := make([]IGccDeclaratorExtensionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IGccDeclaratorExtensionContext); ok {
			tst[i] = t.(IGccDeclaratorExtensionContext)
			i++
		}
	}

	return tst
}

func (s *DeclaratorContext) GccDeclaratorExtension(i int) IGccDeclaratorExtensionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGccDeclaratorExtensionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGccDeclaratorExtensionContext)
}

func (s *DeclaratorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DeclaratorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DeclaratorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CParserVisitor:
		return t.VisitDeclarator(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CParser) Declarator() (localctx IDeclaratorContext) {
	this := p
	_ = this

	localctx = NewDeclaratorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 86, CParserRULE_declarator)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1210)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == CParserStar || _la == CParserCaret {
		{
			p.SetState(1209)
			p.Pointer()
		}

	}
	{
		p.SetState(1212)
		p.DirectDeclarator()
	}
	p.SetState(1216)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 156, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1213)
				p.GccDeclaratorExtension()
			}

		}
		p.SetState(1218)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 156, p.GetParserRuleContext())
	}

	return localctx
}

// IDirectDeclaratorContext is an interface to support dynamic dispatch.
type IDirectDeclaratorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDirectDeclaratorContext differentiates from other interfaces.
	IsDirectDeclaratorContext()
}

type DirectDeclaratorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDirectDeclaratorContext() *DirectDeclaratorContext {
	var p = new(DirectDeclaratorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CParserRULE_directDeclarator
	return p
}

func (*DirectDeclaratorContext) IsDirectDeclaratorContext() {}

func NewDirectDeclaratorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DirectDeclaratorContext {
	var p = new(DirectDeclaratorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CParserRULE_directDeclarator

	return p
}

func (s *DirectDeclaratorContext) GetParser() antlr.Parser { return s.parser }

func (s *DirectDeclaratorContext) Identifier() antlr.TerminalNode {
	return s.GetToken(CParserIdentifier, 0)
}

func (s *DirectDeclaratorContext) AllDeclaratorSuffix() []IDeclaratorSuffixContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IDeclaratorSuffixContext); ok {
			len++
		}
	}

	tst := make([]IDeclaratorSuffixContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IDeclaratorSuffixContext); ok {
			tst[i] = t.(IDeclaratorSuffixContext)
			i++
		}
	}

	return tst
}

func (s *DirectDeclaratorContext) DeclaratorSuffix(i int) IDeclaratorSuffixContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDeclaratorSuffixContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDeclaratorSuffixContext)
}

func (s *DirectDeclaratorContext) MacroCallExpression() IMacroCallExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMacroCallExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMacroCallExpressionContext)
}

func (s *DirectDeclaratorContext) LeftParen() antlr.TerminalNode {
	return s.GetToken(CParserLeftParen, 0)
}

func (s *DirectDeclaratorContext) Declarator() IDeclaratorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDeclaratorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDeclaratorContext)
}

func (s *DirectDeclaratorContext) RightParen() antlr.TerminalNode {
	return s.GetToken(CParserRightParen, 0)
}

func (s *DirectDeclaratorContext) AllEos() []IEosContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IEosContext); ok {
			len++
		}
	}

	tst := make([]IEosContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IEosContext); ok {
			tst[i] = t.(IEosContext)
			i++
		}
	}

	return tst
}

func (s *DirectDeclaratorContext) Eos(i int) IEosContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEosContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEosContext)
}

func (s *DirectDeclaratorContext) Colon() antlr.TerminalNode {
	return s.GetToken(CParserColon, 0)
}

func (s *DirectDeclaratorContext) DigitSequence() antlr.TerminalNode {
	return s.GetToken(CParserDigitSequence, 0)
}

func (s *DirectDeclaratorContext) VcSpecificModifer() IVcSpecificModiferContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVcSpecificModiferContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVcSpecificModiferContext)
}

func (s *DirectDeclaratorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DirectDeclaratorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DirectDeclaratorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CParserVisitor:
		return t.VisitDirectDeclarator(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CParser) DirectDeclarator() (localctx IDirectDeclaratorContext) {
	this := p
	_ = this

	localctx = NewDirectDeclaratorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 88, CParserRULE_directDeclarator)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.SetState(1305)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 169, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1219)
			p.Match(CParserIdentifier)
		}
		p.SetState(1223)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 157, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(1220)
					p.DeclaratorSuffix()
				}

			}
			p.SetState(1225)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 157, p.GetParserRuleContext())
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1226)
			p.MacroCallExpression()
		}
		p.SetState(1230)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 158, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(1227)
					p.DeclaratorSuffix()
				}

			}
			p.SetState(1232)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 158, p.GetParserRuleContext())
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1233)
			p.Match(CParserLeftParen)
		}
		p.SetState(1237)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == CParserSemi || _la == CParserEOS {
			{
				p.SetState(1234)
				p.Eos()
			}

			p.SetState(1239)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1240)
			p.Declarator()
		}
		p.SetState(1244)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == CParserSemi || _la == CParserEOS {
			{
				p.SetState(1241)
				p.Eos()
			}

			p.SetState(1246)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1247)
			p.Match(CParserRightParen)
		}
		p.SetState(1251)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 161, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(1248)
					p.DeclaratorSuffix()
				}

			}
			p.SetState(1253)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 161, p.GetParserRuleContext())
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1254)
			p.Match(CParserIdentifier)
		}
		{
			p.SetState(1255)
			p.Match(CParserColon)
		}
		p.SetState(1259)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == CParserSemi || _la == CParserEOS {
			{
				p.SetState(1256)
				p.Eos()
			}

			p.SetState(1261)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1262)
			p.Match(CParserDigitSequence)
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1263)
			p.VcSpecificModifer()
		}
		p.SetState(1267)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == CParserSemi || _la == CParserEOS {
			{
				p.SetState(1264)
				p.Eos()
			}

			p.SetState(1269)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1270)
			p.Match(CParserIdentifier)
		}
		p.SetState(1274)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 164, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(1271)
					p.DeclaratorSuffix()
				}

			}
			p.SetState(1276)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 164, p.GetParserRuleContext())
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(1277)
			p.Match(CParserLeftParen)
		}
		p.SetState(1281)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == CParserSemi || _la == CParserEOS {
			{
				p.SetState(1278)
				p.Eos()
			}

			p.SetState(1283)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1284)
			p.VcSpecificModifer()
		}
		p.SetState(1288)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == CParserSemi || _la == CParserEOS {
			{
				p.SetState(1285)
				p.Eos()
			}

			p.SetState(1290)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1291)
			p.Declarator()
		}
		p.SetState(1295)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == CParserSemi || _la == CParserEOS {
			{
				p.SetState(1292)
				p.Eos()
			}

			p.SetState(1297)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1298)
			p.Match(CParserRightParen)
		}
		p.SetState(1302)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 168, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(1299)
					p.DeclaratorSuffix()
				}

			}
			p.SetState(1304)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 168, p.GetParserRuleContext())
		}

	}

	return localctx
}

// IDeclaratorSuffixContext is an interface to support dynamic dispatch.
type IDeclaratorSuffixContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDeclaratorSuffixContext differentiates from other interfaces.
	IsDeclaratorSuffixContext()
}

type DeclaratorSuffixContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDeclaratorSuffixContext() *DeclaratorSuffixContext {
	var p = new(DeclaratorSuffixContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CParserRULE_declaratorSuffix
	return p
}

func (*DeclaratorSuffixContext) IsDeclaratorSuffixContext() {}

func NewDeclaratorSuffixContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DeclaratorSuffixContext {
	var p = new(DeclaratorSuffixContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CParserRULE_declaratorSuffix

	return p
}

func (s *DeclaratorSuffixContext) GetParser() antlr.Parser { return s.parser }

func (s *DeclaratorSuffixContext) ArraySuffix() IArraySuffixContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArraySuffixContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArraySuffixContext)
}

func (s *DeclaratorSuffixContext) FunctionSuffix() IFunctionSuffixContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionSuffixContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionSuffixContext)
}

func (s *DeclaratorSuffixContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DeclaratorSuffixContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DeclaratorSuffixContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CParserVisitor:
		return t.VisitDeclaratorSuffix(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CParser) DeclaratorSuffix() (localctx IDeclaratorSuffixContext) {
	this := p
	_ = this

	localctx = NewDeclaratorSuffixContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 90, CParserRULE_declaratorSuffix)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1309)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case CParserLeftBracket:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1307)
			p.ArraySuffix()
		}

	case CParserLeftParen:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1308)
			p.FunctionSuffix()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IArraySuffixContext is an interface to support dynamic dispatch.
type IArraySuffixContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsArraySuffixContext differentiates from other interfaces.
	IsArraySuffixContext()
}

type ArraySuffixContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyArraySuffixContext() *ArraySuffixContext {
	var p = new(ArraySuffixContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CParserRULE_arraySuffix
	return p
}

func (*ArraySuffixContext) IsArraySuffixContext() {}

func NewArraySuffixContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ArraySuffixContext {
	var p = new(ArraySuffixContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CParserRULE_arraySuffix

	return p
}

func (s *ArraySuffixContext) GetParser() antlr.Parser { return s.parser }

func (s *ArraySuffixContext) LeftBracket() antlr.TerminalNode {
	return s.GetToken(CParserLeftBracket, 0)
}

func (s *ArraySuffixContext) RightBracket() antlr.TerminalNode {
	return s.GetToken(CParserRightBracket, 0)
}

func (s *ArraySuffixContext) AllEos() []IEosContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IEosContext); ok {
			len++
		}
	}

	tst := make([]IEosContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IEosContext); ok {
			tst[i] = t.(IEosContext)
			i++
		}
	}

	return tst
}

func (s *ArraySuffixContext) Eos(i int) IEosContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEosContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEosContext)
}

func (s *ArraySuffixContext) TypeQualifierList() ITypeQualifierListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeQualifierListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeQualifierListContext)
}

func (s *ArraySuffixContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ArraySuffixContext) Static() antlr.TerminalNode {
	return s.GetToken(CParserStatic, 0)
}

func (s *ArraySuffixContext) Star() antlr.TerminalNode {
	return s.GetToken(CParserStar, 0)
}

func (s *ArraySuffixContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArraySuffixContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ArraySuffixContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CParserVisitor:
		return t.VisitArraySuffix(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CParser) ArraySuffix() (localctx IArraySuffixContext) {
	this := p
	_ = this

	localctx = NewArraySuffixContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 92, CParserRULE_arraySuffix)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.SetState(1423)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 189, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1311)
			p.Match(CParserLeftBracket)
		}
		p.SetState(1315)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 171, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(1312)
					p.Eos()
				}

			}
			p.SetState(1317)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 171, p.GetParserRuleContext())
		}
		p.SetState(1319)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 172, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1318)
				p.TypeQualifierList()
			}

		}
		p.SetState(1324)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 173, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(1321)
					p.Eos()
				}

			}
			p.SetState(1326)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 173, p.GetParserRuleContext())
		}
		p.SetState(1328)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if (int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-575660377648630222) != 0 || (int64((_la-66)) & ^0x3f) == 0 && ((int64(1)<<(_la-66))&70308396531829) != 0 {
			{
				p.SetState(1327)
				p.expression(0)
			}

		}
		p.SetState(1333)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == CParserSemi || _la == CParserEOS {
			{
				p.SetState(1330)
				p.Eos()
			}

			p.SetState(1335)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1336)
			p.Match(CParserRightBracket)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1337)
			p.Match(CParserLeftBracket)
		}
		p.SetState(1341)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == CParserSemi || _la == CParserEOS {
			{
				p.SetState(1338)
				p.Eos()
			}

			p.SetState(1343)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1344)
			p.Match(CParserStatic)
		}
		p.SetState(1348)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 177, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(1345)
					p.Eos()
				}

			}
			p.SetState(1350)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 177, p.GetParserRuleContext())
		}
		p.SetState(1352)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 178, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1351)
				p.TypeQualifierList()
			}

		}
		p.SetState(1357)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == CParserSemi || _la == CParserEOS {
			{
				p.SetState(1354)
				p.Eos()
			}

			p.SetState(1359)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1360)
			p.expression(0)
		}
		p.SetState(1364)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == CParserSemi || _la == CParserEOS {
			{
				p.SetState(1361)
				p.Eos()
			}

			p.SetState(1366)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1367)
			p.Match(CParserRightBracket)
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1369)
			p.Match(CParserLeftBracket)
		}
		p.SetState(1373)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == CParserSemi || _la == CParserEOS {
			{
				p.SetState(1370)
				p.Eos()
			}

			p.SetState(1375)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1376)
			p.TypeQualifierList()
		}
		p.SetState(1380)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == CParserSemi || _la == CParserEOS {
			{
				p.SetState(1377)
				p.Eos()
			}

			p.SetState(1382)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1383)
			p.Match(CParserStatic)
		}
		p.SetState(1387)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == CParserSemi || _la == CParserEOS {
			{
				p.SetState(1384)
				p.Eos()
			}

			p.SetState(1389)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1390)
			p.expression(0)
		}
		p.SetState(1394)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == CParserSemi || _la == CParserEOS {
			{
				p.SetState(1391)
				p.Eos()
			}

			p.SetState(1396)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1397)
			p.Match(CParserRightBracket)
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1399)
			p.Match(CParserLeftBracket)
		}
		p.SetState(1403)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 185, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(1400)
					p.Eos()
				}

			}
			p.SetState(1405)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 185, p.GetParserRuleContext())
		}
		p.SetState(1407)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if (int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&592780984352) != 0 {
			{
				p.SetState(1406)
				p.TypeQualifierList()
			}

		}
		p.SetState(1412)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == CParserSemi || _la == CParserEOS {
			{
				p.SetState(1409)
				p.Eos()
			}

			p.SetState(1414)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1415)
			p.Match(CParserStar)
		}
		p.SetState(1419)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == CParserSemi || _la == CParserEOS {
			{
				p.SetState(1416)
				p.Eos()
			}

			p.SetState(1421)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1422)
			p.Match(CParserRightBracket)
		}

	}

	return localctx
}

// IFunctionSuffixContext is an interface to support dynamic dispatch.
type IFunctionSuffixContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFunctionSuffixContext differentiates from other interfaces.
	IsFunctionSuffixContext()
}

type FunctionSuffixContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunctionSuffixContext() *FunctionSuffixContext {
	var p = new(FunctionSuffixContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CParserRULE_functionSuffix
	return p
}

func (*FunctionSuffixContext) IsFunctionSuffixContext() {}

func NewFunctionSuffixContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FunctionSuffixContext {
	var p = new(FunctionSuffixContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CParserRULE_functionSuffix

	return p
}

func (s *FunctionSuffixContext) GetParser() antlr.Parser { return s.parser }

func (s *FunctionSuffixContext) LeftParen() antlr.TerminalNode {
	return s.GetToken(CParserLeftParen, 0)
}

func (s *FunctionSuffixContext) ParameterTypeList() IParameterTypeListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IParameterTypeListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IParameterTypeListContext)
}

func (s *FunctionSuffixContext) RightParen() antlr.TerminalNode {
	return s.GetToken(CParserRightParen, 0)
}

func (s *FunctionSuffixContext) AllEos() []IEosContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IEosContext); ok {
			len++
		}
	}

	tst := make([]IEosContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IEosContext); ok {
			tst[i] = t.(IEosContext)
			i++
		}
	}

	return tst
}

func (s *FunctionSuffixContext) Eos(i int) IEosContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEosContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEosContext)
}

func (s *FunctionSuffixContext) IdentifierList() IIdentifierListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierListContext)
}

func (s *FunctionSuffixContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FunctionSuffixContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FunctionSuffixContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CParserVisitor:
		return t.VisitFunctionSuffix(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CParser) FunctionSuffix() (localctx IFunctionSuffixContext) {
	this := p
	_ = this

	localctx = NewFunctionSuffixContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 94, CParserRULE_functionSuffix)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.SetState(1458)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 195, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1425)
			p.Match(CParserLeftParen)
		}
		p.SetState(1429)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == CParserSemi || _la == CParserEOS {
			{
				p.SetState(1426)
				p.Eos()
			}

			p.SetState(1431)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1432)
			p.ParameterTypeList()
		}
		p.SetState(1436)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == CParserSemi || _la == CParserEOS {
			{
				p.SetState(1433)
				p.Eos()
			}

			p.SetState(1438)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1439)
			p.Match(CParserRightParen)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1441)
			p.Match(CParserLeftParen)
		}
		p.SetState(1445)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 192, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(1442)
					p.Eos()
				}

			}
			p.SetState(1447)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 192, p.GetParserRuleContext())
		}
		p.SetState(1449)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == CParserIdentifier {
			{
				p.SetState(1448)
				p.IdentifierList()
			}

		}
		p.SetState(1454)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == CParserSemi || _la == CParserEOS {
			{
				p.SetState(1451)
				p.Eos()
			}

			p.SetState(1456)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1457)
			p.Match(CParserRightParen)
		}

	}

	return localctx
}

// IVcSpecificModiferContext is an interface to support dynamic dispatch.
type IVcSpecificModiferContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsVcSpecificModiferContext differentiates from other interfaces.
	IsVcSpecificModiferContext()
}

type VcSpecificModiferContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVcSpecificModiferContext() *VcSpecificModiferContext {
	var p = new(VcSpecificModiferContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CParserRULE_vcSpecificModifer
	return p
}

func (*VcSpecificModiferContext) IsVcSpecificModiferContext() {}

func NewVcSpecificModiferContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *VcSpecificModiferContext {
	var p = new(VcSpecificModiferContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CParserRULE_vcSpecificModifer

	return p
}

func (s *VcSpecificModiferContext) GetParser() antlr.Parser { return s.parser }

func (s *VcSpecificModiferContext) Cdecl() antlr.TerminalNode {
	return s.GetToken(CParserCdecl, 0)
}

func (s *VcSpecificModiferContext) Clrcall() antlr.TerminalNode {
	return s.GetToken(CParserClrcall, 0)
}

func (s *VcSpecificModiferContext) Stdcall() antlr.TerminalNode {
	return s.GetToken(CParserStdcall, 0)
}

func (s *VcSpecificModiferContext) Fastcall() antlr.TerminalNode {
	return s.GetToken(CParserFastcall, 0)
}

func (s *VcSpecificModiferContext) Thiscall() antlr.TerminalNode {
	return s.GetToken(CParserThiscall, 0)
}

func (s *VcSpecificModiferContext) Vectorcall() antlr.TerminalNode {
	return s.GetToken(CParserVectorcall, 0)
}

func (s *VcSpecificModiferContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VcSpecificModiferContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *VcSpecificModiferContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CParserVisitor:
		return t.VisitVcSpecificModifer(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CParser) VcSpecificModifer() (localctx IVcSpecificModiferContext) {
	this := p
	_ = this

	localctx = NewVcSpecificModiferContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 96, CParserRULE_vcSpecificModifer)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1460)
		_la = p.GetTokenStream().LA(1)

		if !((int64((_la-110)) & ^0x3f) == 0 && ((int64(1)<<(_la-110))&125) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IGccDeclaratorExtensionContext is an interface to support dynamic dispatch.
type IGccDeclaratorExtensionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsGccDeclaratorExtensionContext differentiates from other interfaces.
	IsGccDeclaratorExtensionContext()
}

type GccDeclaratorExtensionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGccDeclaratorExtensionContext() *GccDeclaratorExtensionContext {
	var p = new(GccDeclaratorExtensionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CParserRULE_gccDeclaratorExtension
	return p
}

func (*GccDeclaratorExtensionContext) IsGccDeclaratorExtensionContext() {}

func NewGccDeclaratorExtensionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GccDeclaratorExtensionContext {
	var p = new(GccDeclaratorExtensionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CParserRULE_gccDeclaratorExtension

	return p
}

func (s *GccDeclaratorExtensionContext) GetParser() antlr.Parser { return s.parser }

func (s *GccDeclaratorExtensionContext) Asm() antlr.TerminalNode {
	return s.GetToken(CParserAsm, 0)
}

func (s *GccDeclaratorExtensionContext) GccAttributeSpecifier() IGccAttributeSpecifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGccAttributeSpecifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGccAttributeSpecifierContext)
}

func (s *GccDeclaratorExtensionContext) Identifier() antlr.TerminalNode {
	return s.GetToken(CParserIdentifier, 0)
}

func (s *GccDeclaratorExtensionContext) LeftParen() antlr.TerminalNode {
	return s.GetToken(CParserLeftParen, 0)
}

func (s *GccDeclaratorExtensionContext) GccAttributeList() IGccAttributeListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGccAttributeListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGccAttributeListContext)
}

func (s *GccDeclaratorExtensionContext) RightParen() antlr.TerminalNode {
	return s.GetToken(CParserRightParen, 0)
}

func (s *GccDeclaratorExtensionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GccDeclaratorExtensionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GccDeclaratorExtensionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CParserVisitor:
		return t.VisitGccDeclaratorExtension(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CParser) GccDeclaratorExtension() (localctx IGccDeclaratorExtensionContext) {
	this := p
	_ = this

	localctx = NewGccDeclaratorExtensionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 98, CParserRULE_gccDeclaratorExtension)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1471)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case CParserAsm:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1462)
			p.Match(CParserAsm)
		}

	case CParserAttribute__:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1463)
			p.GccAttributeSpecifier()
		}

	case CParserIdentifier:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1464)
			p.Match(CParserIdentifier)
		}
		p.SetState(1469)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 196, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1465)
				p.Match(CParserLeftParen)
			}
			{
				p.SetState(1466)
				p.GccAttributeList()
			}
			{
				p.SetState(1467)
				p.Match(CParserRightParen)
			}

		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IGccAttributeSpecifierContext is an interface to support dynamic dispatch.
type IGccAttributeSpecifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsGccAttributeSpecifierContext differentiates from other interfaces.
	IsGccAttributeSpecifierContext()
}

type GccAttributeSpecifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGccAttributeSpecifierContext() *GccAttributeSpecifierContext {
	var p = new(GccAttributeSpecifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CParserRULE_gccAttributeSpecifier
	return p
}

func (*GccAttributeSpecifierContext) IsGccAttributeSpecifierContext() {}

func NewGccAttributeSpecifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GccAttributeSpecifierContext {
	var p = new(GccAttributeSpecifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CParserRULE_gccAttributeSpecifier

	return p
}

func (s *GccAttributeSpecifierContext) GetParser() antlr.Parser { return s.parser }

func (s *GccAttributeSpecifierContext) Attribute__() antlr.TerminalNode {
	return s.GetToken(CParserAttribute__, 0)
}

func (s *GccAttributeSpecifierContext) AllLeftParen() []antlr.TerminalNode {
	return s.GetTokens(CParserLeftParen)
}

func (s *GccAttributeSpecifierContext) LeftParen(i int) antlr.TerminalNode {
	return s.GetToken(CParserLeftParen, i)
}

func (s *GccAttributeSpecifierContext) AllRightParen() []antlr.TerminalNode {
	return s.GetTokens(CParserRightParen)
}

func (s *GccAttributeSpecifierContext) RightParen(i int) antlr.TerminalNode {
	return s.GetToken(CParserRightParen, i)
}

func (s *GccAttributeSpecifierContext) AllEos() []IEosContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IEosContext); ok {
			len++
		}
	}

	tst := make([]IEosContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IEosContext); ok {
			tst[i] = t.(IEosContext)
			i++
		}
	}

	return tst
}

func (s *GccAttributeSpecifierContext) Eos(i int) IEosContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEosContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEosContext)
}

func (s *GccAttributeSpecifierContext) GccAttributeList() IGccAttributeListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGccAttributeListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGccAttributeListContext)
}

func (s *GccAttributeSpecifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GccAttributeSpecifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GccAttributeSpecifierContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CParserVisitor:
		return t.VisitGccAttributeSpecifier(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CParser) GccAttributeSpecifier() (localctx IGccAttributeSpecifierContext) {
	this := p
	_ = this

	localctx = NewGccAttributeSpecifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 100, CParserRULE_gccAttributeSpecifier)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1473)
		p.Match(CParserAttribute__)
	}
	{
		p.SetState(1474)
		p.Match(CParserLeftParen)
	}
	p.SetState(1478)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == CParserSemi || _la == CParserEOS {
		{
			p.SetState(1475)
			p.Eos()
		}

		p.SetState(1480)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1481)
		p.Match(CParserLeftParen)
	}
	p.SetState(1485)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 199, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1482)
				p.Eos()
			}

		}
		p.SetState(1487)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 199, p.GetParserRuleContext())
	}
	p.SetState(1489)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 200, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1488)
			p.GccAttributeList()
		}

	}
	p.SetState(1494)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == CParserSemi || _la == CParserEOS {
		{
			p.SetState(1491)
			p.Eos()
		}

		p.SetState(1496)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1497)
		p.Match(CParserRightParen)
	}
	p.SetState(1501)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == CParserSemi || _la == CParserEOS {
		{
			p.SetState(1498)
			p.Eos()
		}

		p.SetState(1503)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1504)
		p.Match(CParserRightParen)
	}

	return localctx
}

// IGccAttributeListContext is an interface to support dynamic dispatch.
type IGccAttributeListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsGccAttributeListContext differentiates from other interfaces.
	IsGccAttributeListContext()
}

type GccAttributeListContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGccAttributeListContext() *GccAttributeListContext {
	var p = new(GccAttributeListContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CParserRULE_gccAttributeList
	return p
}

func (*GccAttributeListContext) IsGccAttributeListContext() {}

func NewGccAttributeListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GccAttributeListContext {
	var p = new(GccAttributeListContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CParserRULE_gccAttributeList

	return p
}

func (s *GccAttributeListContext) GetParser() antlr.Parser { return s.parser }

func (s *GccAttributeListContext) AllGccAttribute() []IGccAttributeContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IGccAttributeContext); ok {
			len++
		}
	}

	tst := make([]IGccAttributeContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IGccAttributeContext); ok {
			tst[i] = t.(IGccAttributeContext)
			i++
		}
	}

	return tst
}

func (s *GccAttributeListContext) GccAttribute(i int) IGccAttributeContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGccAttributeContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGccAttributeContext)
}

func (s *GccAttributeListContext) AllComma() []antlr.TerminalNode {
	return s.GetTokens(CParserComma)
}

func (s *GccAttributeListContext) Comma(i int) antlr.TerminalNode {
	return s.GetToken(CParserComma, i)
}

func (s *GccAttributeListContext) AllEos() []IEosContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IEosContext); ok {
			len++
		}
	}

	tst := make([]IEosContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IEosContext); ok {
			tst[i] = t.(IEosContext)
			i++
		}
	}

	return tst
}

func (s *GccAttributeListContext) Eos(i int) IEosContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEosContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEosContext)
}

func (s *GccAttributeListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GccAttributeListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GccAttributeListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CParserVisitor:
		return t.VisitGccAttributeList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CParser) GccAttributeList() (localctx IGccAttributeListContext) {
	this := p
	_ = this

	localctx = NewGccAttributeListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 102, CParserRULE_gccAttributeList)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1506)
		p.GccAttribute()
	}
	p.SetState(1517)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == CParserComma {
		{
			p.SetState(1507)
			p.Match(CParserComma)
		}
		p.SetState(1511)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 203, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(1508)
					p.Eos()
				}

			}
			p.SetState(1513)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 203, p.GetParserRuleContext())
		}
		{
			p.SetState(1514)
			p.GccAttribute()
		}

		p.SetState(1519)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IGccAttributeContext is an interface to support dynamic dispatch.
type IGccAttributeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsGccAttributeContext differentiates from other interfaces.
	IsGccAttributeContext()
}

type GccAttributeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGccAttributeContext() *GccAttributeContext {
	var p = new(GccAttributeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CParserRULE_gccAttribute
	return p
}

func (*GccAttributeContext) IsGccAttributeContext() {}

func NewGccAttributeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GccAttributeContext {
	var p = new(GccAttributeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CParserRULE_gccAttribute

	return p
}

func (s *GccAttributeContext) GetParser() antlr.Parser { return s.parser }

func (s *GccAttributeContext) Comma() antlr.TerminalNode {
	return s.GetToken(CParserComma, 0)
}

func (s *GccAttributeContext) AllLeftParen() []antlr.TerminalNode {
	return s.GetTokens(CParserLeftParen)
}

func (s *GccAttributeContext) LeftParen(i int) antlr.TerminalNode {
	return s.GetToken(CParserLeftParen, i)
}

func (s *GccAttributeContext) AllRightParen() []antlr.TerminalNode {
	return s.GetTokens(CParserRightParen)
}

func (s *GccAttributeContext) RightParen(i int) antlr.TerminalNode {
	return s.GetToken(CParserRightParen, i)
}

func (s *GccAttributeContext) ArgumentExpressionList() IArgumentExpressionListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArgumentExpressionListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArgumentExpressionListContext)
}

func (s *GccAttributeContext) Identifier() antlr.TerminalNode {
	return s.GetToken(CParserIdentifier, 0)
}

func (s *GccAttributeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GccAttributeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GccAttributeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CParserVisitor:
		return t.VisitGccAttribute(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CParser) GccAttribute() (localctx IGccAttributeContext) {
	this := p
	_ = this

	localctx = NewGccAttributeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 104, CParserRULE_gccAttribute)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1536)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 209, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1520)
			_la = p.GetTokenStream().LA(1)

			if _la <= 0 || (int64((_la-47)) & ^0x3f) == 0 && ((int64(1)<<(_la-47))&536870915) != 0 {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		p.SetState(1526)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == CParserLeftParen {
			{
				p.SetState(1521)
				p.Match(CParserLeftParen)
			}
			p.SetState(1523)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if (int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-8206824599947726) != 0 || (int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&281233636459007) != 0 {
				{
					p.SetState(1522)
					p.ArgumentExpressionList()
				}

			}
			{
				p.SetState(1525)
				p.Match(CParserRightParen)
			}

		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1528)
			p.Match(CParserIdentifier)
		}
		p.SetState(1534)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == CParserLeftParen {
			{
				p.SetState(1529)
				p.Match(CParserLeftParen)
			}
			p.SetState(1531)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if (int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-8206824599947726) != 0 || (int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&281233636459007) != 0 {
				{
					p.SetState(1530)
					p.ArgumentExpressionList()
				}

			}
			{
				p.SetState(1533)
				p.Match(CParserRightParen)
			}

		}

	}

	return localctx
}

// IPointerContext is an interface to support dynamic dispatch.
type IPointerContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPointerContext differentiates from other interfaces.
	IsPointerContext()
}

type PointerContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPointerContext() *PointerContext {
	var p = new(PointerContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CParserRULE_pointer
	return p
}

func (*PointerContext) IsPointerContext() {}

func NewPointerContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PointerContext {
	var p = new(PointerContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CParserRULE_pointer

	return p
}

func (s *PointerContext) GetParser() antlr.Parser { return s.parser }

func (s *PointerContext) AllPointerPart() []IPointerPartContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPointerPartContext); ok {
			len++
		}
	}

	tst := make([]IPointerPartContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPointerPartContext); ok {
			tst[i] = t.(IPointerPartContext)
			i++
		}
	}

	return tst
}

func (s *PointerContext) PointerPart(i int) IPointerPartContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPointerPartContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPointerPartContext)
}

func (s *PointerContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PointerContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PointerContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CParserVisitor:
		return t.VisitPointer(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CParser) Pointer() (localctx IPointerContext) {
	this := p
	_ = this

	localctx = NewPointerContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 106, CParserRULE_pointer)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1539)
	p.GetErrorHandler().Sync(p)
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			{
				p.SetState(1538)
				p.PointerPart()
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(1541)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 210, p.GetParserRuleContext())
	}

	return localctx
}

// IPointerPartContext is an interface to support dynamic dispatch.
type IPointerPartContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPointerPartContext differentiates from other interfaces.
	IsPointerPartContext()
}

type PointerPartContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPointerPartContext() *PointerPartContext {
	var p = new(PointerPartContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CParserRULE_pointerPart
	return p
}

func (*PointerPartContext) IsPointerPartContext() {}

func NewPointerPartContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PointerPartContext {
	var p = new(PointerPartContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CParserRULE_pointerPart

	return p
}

func (s *PointerPartContext) GetParser() antlr.Parser { return s.parser }

func (s *PointerPartContext) Star() antlr.TerminalNode {
	return s.GetToken(CParserStar, 0)
}

func (s *PointerPartContext) Caret() antlr.TerminalNode {
	return s.GetToken(CParserCaret, 0)
}

func (s *PointerPartContext) TypeQualifierList() ITypeQualifierListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeQualifierListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeQualifierListContext)
}

func (s *PointerPartContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PointerPartContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PointerPartContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CParserVisitor:
		return t.VisitPointerPart(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CParser) PointerPart() (localctx IPointerPartContext) {
	this := p
	_ = this

	localctx = NewPointerPartContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 108, CParserRULE_pointerPart)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1543)
		_la = p.GetTokenStream().LA(1)

		if !(_la == CParserStar || _la == CParserCaret) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	p.SetState(1545)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 211, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1544)
			p.TypeQualifierList()
		}

	}

	return localctx
}

// ITypeQualifierListContext is an interface to support dynamic dispatch.
type ITypeQualifierListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTypeQualifierListContext differentiates from other interfaces.
	IsTypeQualifierListContext()
}

type TypeQualifierListContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeQualifierListContext() *TypeQualifierListContext {
	var p = new(TypeQualifierListContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CParserRULE_typeQualifierList
	return p
}

func (*TypeQualifierListContext) IsTypeQualifierListContext() {}

func NewTypeQualifierListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeQualifierListContext {
	var p = new(TypeQualifierListContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CParserRULE_typeQualifierList

	return p
}

func (s *TypeQualifierListContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeQualifierListContext) AllTypeQualifier() []ITypeQualifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITypeQualifierContext); ok {
			len++
		}
	}

	tst := make([]ITypeQualifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITypeQualifierContext); ok {
			tst[i] = t.(ITypeQualifierContext)
			i++
		}
	}

	return tst
}

func (s *TypeQualifierListContext) TypeQualifier(i int) ITypeQualifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeQualifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeQualifierContext)
}

func (s *TypeQualifierListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeQualifierListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeQualifierListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CParserVisitor:
		return t.VisitTypeQualifierList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CParser) TypeQualifierList() (localctx ITypeQualifierListContext) {
	this := p
	_ = this

	localctx = NewTypeQualifierListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 110, CParserRULE_typeQualifierList)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1548)
	p.GetErrorHandler().Sync(p)
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			{
				p.SetState(1547)
				p.TypeQualifier()
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(1550)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 212, p.GetParserRuleContext())
	}

	return localctx
}

// IParameterTypeListContext is an interface to support dynamic dispatch.
type IParameterTypeListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsParameterTypeListContext differentiates from other interfaces.
	IsParameterTypeListContext()
}

type ParameterTypeListContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyParameterTypeListContext() *ParameterTypeListContext {
	var p = new(ParameterTypeListContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CParserRULE_parameterTypeList
	return p
}

func (*ParameterTypeListContext) IsParameterTypeListContext() {}

func NewParameterTypeListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ParameterTypeListContext {
	var p = new(ParameterTypeListContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CParserRULE_parameterTypeList

	return p
}

func (s *ParameterTypeListContext) GetParser() antlr.Parser { return s.parser }

func (s *ParameterTypeListContext) ParameterList() IParameterListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IParameterListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IParameterListContext)
}

func (s *ParameterTypeListContext) Comma() antlr.TerminalNode {
	return s.GetToken(CParserComma, 0)
}

func (s *ParameterTypeListContext) AllEos() []IEosContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IEosContext); ok {
			len++
		}
	}

	tst := make([]IEosContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IEosContext); ok {
			tst[i] = t.(IEosContext)
			i++
		}
	}

	return tst
}

func (s *ParameterTypeListContext) Eos(i int) IEosContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEosContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEosContext)
}

func (s *ParameterTypeListContext) Ellipsis() antlr.TerminalNode {
	return s.GetToken(CParserEllipsis, 0)
}

func (s *ParameterTypeListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ParameterTypeListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ParameterTypeListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CParserVisitor:
		return t.VisitParameterTypeList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CParser) ParameterTypeList() (localctx IParameterTypeListContext) {
	this := p
	_ = this

	localctx = NewParameterTypeListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 112, CParserRULE_parameterTypeList)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1552)
		p.ParameterList()
	}
	p.SetState(1569)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == CParserComma {
		{
			p.SetState(1553)
			p.Match(CParserComma)
		}
		p.SetState(1557)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 213, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(1554)
					p.Eos()
				}

			}
			p.SetState(1559)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 213, p.GetParserRuleContext())
		}
		p.SetState(1561)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == CParserEllipsis {
			{
				p.SetState(1560)
				p.Match(CParserEllipsis)
			}

		}
		p.SetState(1566)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 215, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(1563)
					p.Eos()
				}

			}
			p.SetState(1568)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 215, p.GetParserRuleContext())
		}

	}

	return localctx
}

// IParameterListContext is an interface to support dynamic dispatch.
type IParameterListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsParameterListContext differentiates from other interfaces.
	IsParameterListContext()
}

type ParameterListContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyParameterListContext() *ParameterListContext {
	var p = new(ParameterListContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CParserRULE_parameterList
	return p
}

func (*ParameterListContext) IsParameterListContext() {}

func NewParameterListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ParameterListContext {
	var p = new(ParameterListContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CParserRULE_parameterList

	return p
}

func (s *ParameterListContext) GetParser() antlr.Parser { return s.parser }

func (s *ParameterListContext) AllParameterDeclaration() []IParameterDeclarationContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IParameterDeclarationContext); ok {
			len++
		}
	}

	tst := make([]IParameterDeclarationContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IParameterDeclarationContext); ok {
			tst[i] = t.(IParameterDeclarationContext)
			i++
		}
	}

	return tst
}

func (s *ParameterListContext) ParameterDeclaration(i int) IParameterDeclarationContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IParameterDeclarationContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IParameterDeclarationContext)
}

func (s *ParameterListContext) AllComma() []antlr.TerminalNode {
	return s.GetTokens(CParserComma)
}

func (s *ParameterListContext) Comma(i int) antlr.TerminalNode {
	return s.GetToken(CParserComma, i)
}

func (s *ParameterListContext) AllEos() []IEosContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IEosContext); ok {
			len++
		}
	}

	tst := make([]IEosContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IEosContext); ok {
			tst[i] = t.(IEosContext)
			i++
		}
	}

	return tst
}

func (s *ParameterListContext) Eos(i int) IEosContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEosContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEosContext)
}

func (s *ParameterListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ParameterListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ParameterListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CParserVisitor:
		return t.VisitParameterList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CParser) ParameterList() (localctx IParameterListContext) {
	this := p
	_ = this

	localctx = NewParameterListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 114, CParserRULE_parameterList)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1571)
		p.ParameterDeclaration()
	}
	p.SetState(1582)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 218, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1572)
				p.Match(CParserComma)
			}
			p.SetState(1576)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			for _la == CParserSemi || _la == CParserEOS {
				{
					p.SetState(1573)
					p.Eos()
				}

				p.SetState(1578)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(1579)
				p.ParameterDeclaration()
			}

		}
		p.SetState(1584)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 218, p.GetParserRuleContext())
	}

	return localctx
}

// IParameterDeclarationContext is an interface to support dynamic dispatch.
type IParameterDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsParameterDeclarationContext differentiates from other interfaces.
	IsParameterDeclarationContext()
}

type ParameterDeclarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyParameterDeclarationContext() *ParameterDeclarationContext {
	var p = new(ParameterDeclarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CParserRULE_parameterDeclaration
	return p
}

func (*ParameterDeclarationContext) IsParameterDeclarationContext() {}

func NewParameterDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ParameterDeclarationContext {
	var p = new(ParameterDeclarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CParserRULE_parameterDeclaration

	return p
}

func (s *ParameterDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *ParameterDeclarationContext) DeclarationSpecifier() IDeclarationSpecifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDeclarationSpecifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDeclarationSpecifierContext)
}

func (s *ParameterDeclarationContext) Declarator() IDeclaratorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDeclaratorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDeclaratorContext)
}

func (s *ParameterDeclarationContext) AbstractDeclarator() IAbstractDeclaratorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAbstractDeclaratorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAbstractDeclaratorContext)
}

func (s *ParameterDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ParameterDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ParameterDeclarationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CParserVisitor:
		return t.VisitParameterDeclaration(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CParser) ParameterDeclaration() (localctx IParameterDeclarationContext) {
	this := p
	_ = this

	localctx = NewParameterDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 116, CParserRULE_parameterDeclaration)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1592)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 220, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1585)
			p.DeclarationSpecifier()
		}
		{
			p.SetState(1586)
			p.Declarator()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1588)
			p.DeclarationSpecifier()
		}
		p.SetState(1590)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if (int64((_la-47)) & ^0x3f) == 0 && ((int64(1)<<(_la-47))&8454149) != 0 {
			{
				p.SetState(1589)
				p.AbstractDeclarator()
			}

		}

	}

	return localctx
}

// IIdentifierListContext is an interface to support dynamic dispatch.
type IIdentifierListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsIdentifierListContext differentiates from other interfaces.
	IsIdentifierListContext()
}

type IdentifierListContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIdentifierListContext() *IdentifierListContext {
	var p = new(IdentifierListContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CParserRULE_identifierList
	return p
}

func (*IdentifierListContext) IsIdentifierListContext() {}

func NewIdentifierListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IdentifierListContext {
	var p = new(IdentifierListContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CParserRULE_identifierList

	return p
}

func (s *IdentifierListContext) GetParser() antlr.Parser { return s.parser }

func (s *IdentifierListContext) AllIdentifier() []antlr.TerminalNode {
	return s.GetTokens(CParserIdentifier)
}

func (s *IdentifierListContext) Identifier(i int) antlr.TerminalNode {
	return s.GetToken(CParserIdentifier, i)
}

func (s *IdentifierListContext) AllComma() []antlr.TerminalNode {
	return s.GetTokens(CParserComma)
}

func (s *IdentifierListContext) Comma(i int) antlr.TerminalNode {
	return s.GetToken(CParserComma, i)
}

func (s *IdentifierListContext) AllEos() []IEosContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IEosContext); ok {
			len++
		}
	}

	tst := make([]IEosContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IEosContext); ok {
			tst[i] = t.(IEosContext)
			i++
		}
	}

	return tst
}

func (s *IdentifierListContext) Eos(i int) IEosContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEosContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEosContext)
}

func (s *IdentifierListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IdentifierListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IdentifierListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CParserVisitor:
		return t.VisitIdentifierList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CParser) IdentifierList() (localctx IIdentifierListContext) {
	this := p
	_ = this

	localctx = NewIdentifierListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 118, CParserRULE_identifierList)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1594)
		p.Match(CParserIdentifier)
	}
	p.SetState(1605)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == CParserComma {
		{
			p.SetState(1595)
			p.Match(CParserComma)
		}
		p.SetState(1599)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == CParserSemi || _la == CParserEOS {
			{
				p.SetState(1596)
				p.Eos()
			}

			p.SetState(1601)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1602)
			p.Match(CParserIdentifier)
		}

		p.SetState(1607)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// ITypeNameContext is an interface to support dynamic dispatch.
type ITypeNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTypeNameContext differentiates from other interfaces.
	IsTypeNameContext()
}

type TypeNameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeNameContext() *TypeNameContext {
	var p = new(TypeNameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CParserRULE_typeName
	return p
}

func (*TypeNameContext) IsTypeNameContext() {}

func NewTypeNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeNameContext {
	var p = new(TypeNameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CParserRULE_typeName

	return p
}

func (s *TypeNameContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeNameContext) SpecifierQualifierList() ISpecifierQualifierListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISpecifierQualifierListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISpecifierQualifierListContext)
}

func (s *TypeNameContext) AbstractDeclarator() IAbstractDeclaratorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAbstractDeclaratorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAbstractDeclaratorContext)
}

func (s *TypeNameContext) TypeName() ITypeNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeNameContext)
}

func (s *TypeNameContext) Identifier() antlr.TerminalNode {
	return s.GetToken(CParserIdentifier, 0)
}

func (s *TypeNameContext) Dot() antlr.TerminalNode {
	return s.GetToken(CParserDot, 0)
}

func (s *TypeNameContext) Arrow() antlr.TerminalNode {
	return s.GetToken(CParserArrow, 0)
}

func (s *TypeNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeNameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CParserVisitor:
		return t.VisitTypeName(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CParser) TypeName() (localctx ITypeNameContext) {
	return p.typeName(0)
}

func (p *CParser) typeName(_p int) (localctx ITypeNameContext) {
	this := p
	_ = this

	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()
	_parentState := p.GetState()
	localctx = NewTypeNameContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx ITypeNameContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 120
	p.EnterRecursionRule(localctx, 120, CParserRULE_typeName, _p)
	var _la int

	defer func() {
		p.UnrollRecursionContexts(_parentctx)
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1609)
		p.SpecifierQualifierList()
	}
	p.SetState(1611)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 223, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1610)
			p.AbstractDeclarator()
		}

	}

	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(1618)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 224, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			localctx = NewTypeNameContext(p, _parentctx, _parentState)
			p.PushNewRecursionContext(localctx, _startState, CParserRULE_typeName)
			p.SetState(1613)

			if !(p.Precpred(p.GetParserRuleContext(), 1)) {
				panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 1)", ""))
			}
			{
				p.SetState(1614)
				_la = p.GetTokenStream().LA(1)

				if !(_la == CParserArrow || _la == CParserDot) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}
			{
				p.SetState(1615)
				p.Match(CParserIdentifier)
			}

		}
		p.SetState(1620)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 224, p.GetParserRuleContext())
	}

	return localctx
}

// IAbstractDeclaratorContext is an interface to support dynamic dispatch.
type IAbstractDeclaratorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAbstractDeclaratorContext differentiates from other interfaces.
	IsAbstractDeclaratorContext()
}

type AbstractDeclaratorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAbstractDeclaratorContext() *AbstractDeclaratorContext {
	var p = new(AbstractDeclaratorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CParserRULE_abstractDeclarator
	return p
}

func (*AbstractDeclaratorContext) IsAbstractDeclaratorContext() {}

func NewAbstractDeclaratorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AbstractDeclaratorContext {
	var p = new(AbstractDeclaratorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CParserRULE_abstractDeclarator

	return p
}

func (s *AbstractDeclaratorContext) GetParser() antlr.Parser { return s.parser }

func (s *AbstractDeclaratorContext) Pointer() IPointerContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPointerContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPointerContext)
}

func (s *AbstractDeclaratorContext) DirectAbstractDeclarator() IDirectAbstractDeclaratorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDirectAbstractDeclaratorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDirectAbstractDeclaratorContext)
}

func (s *AbstractDeclaratorContext) AllGccDeclaratorExtension() []IGccDeclaratorExtensionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IGccDeclaratorExtensionContext); ok {
			len++
		}
	}

	tst := make([]IGccDeclaratorExtensionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IGccDeclaratorExtensionContext); ok {
			tst[i] = t.(IGccDeclaratorExtensionContext)
			i++
		}
	}

	return tst
}

func (s *AbstractDeclaratorContext) GccDeclaratorExtension(i int) IGccDeclaratorExtensionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGccDeclaratorExtensionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGccDeclaratorExtensionContext)
}

func (s *AbstractDeclaratorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AbstractDeclaratorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AbstractDeclaratorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CParserVisitor:
		return t.VisitAbstractDeclarator(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CParser) AbstractDeclarator() (localctx IAbstractDeclaratorContext) {
	this := p
	_ = this

	localctx = NewAbstractDeclaratorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 122, CParserRULE_abstractDeclarator)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.SetState(1632)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 227, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1621)
			p.Pointer()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(1623)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == CParserStar || _la == CParserCaret {
			{
				p.SetState(1622)
				p.Pointer()
			}

		}
		{
			p.SetState(1625)
			p.DirectAbstractDeclarator()
		}
		p.SetState(1629)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 226, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(1626)
					p.GccDeclaratorExtension()
				}

			}
			p.SetState(1631)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 226, p.GetParserRuleContext())
		}

	}

	return localctx
}

// IDirectAbstractDeclaratorContext is an interface to support dynamic dispatch.
type IDirectAbstractDeclaratorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDirectAbstractDeclaratorContext differentiates from other interfaces.
	IsDirectAbstractDeclaratorContext()
}

type DirectAbstractDeclaratorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDirectAbstractDeclaratorContext() *DirectAbstractDeclaratorContext {
	var p = new(DirectAbstractDeclaratorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CParserRULE_directAbstractDeclarator
	return p
}

func (*DirectAbstractDeclaratorContext) IsDirectAbstractDeclaratorContext() {}

func NewDirectAbstractDeclaratorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DirectAbstractDeclaratorContext {
	var p = new(DirectAbstractDeclaratorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CParserRULE_directAbstractDeclarator

	return p
}

func (s *DirectAbstractDeclaratorContext) GetParser() antlr.Parser { return s.parser }

func (s *DirectAbstractDeclaratorContext) LeftParen() antlr.TerminalNode {
	return s.GetToken(CParserLeftParen, 0)
}

func (s *DirectAbstractDeclaratorContext) AbstractDeclarator() IAbstractDeclaratorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAbstractDeclaratorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAbstractDeclaratorContext)
}

func (s *DirectAbstractDeclaratorContext) RightParen() antlr.TerminalNode {
	return s.GetToken(CParserRightParen, 0)
}

func (s *DirectAbstractDeclaratorContext) AllEos() []IEosContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IEosContext); ok {
			len++
		}
	}

	tst := make([]IEosContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IEosContext); ok {
			tst[i] = t.(IEosContext)
			i++
		}
	}

	return tst
}

func (s *DirectAbstractDeclaratorContext) Eos(i int) IEosContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEosContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEosContext)
}

func (s *DirectAbstractDeclaratorContext) AllGccDeclaratorExtension() []IGccDeclaratorExtensionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IGccDeclaratorExtensionContext); ok {
			len++
		}
	}

	tst := make([]IGccDeclaratorExtensionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IGccDeclaratorExtensionContext); ok {
			tst[i] = t.(IGccDeclaratorExtensionContext)
			i++
		}
	}

	return tst
}

func (s *DirectAbstractDeclaratorContext) GccDeclaratorExtension(i int) IGccDeclaratorExtensionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGccDeclaratorExtensionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGccDeclaratorExtensionContext)
}

func (s *DirectAbstractDeclaratorContext) AllAbstractDeclaratorSuffix() []IAbstractDeclaratorSuffixContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAbstractDeclaratorSuffixContext); ok {
			len++
		}
	}

	tst := make([]IAbstractDeclaratorSuffixContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAbstractDeclaratorSuffixContext); ok {
			tst[i] = t.(IAbstractDeclaratorSuffixContext)
			i++
		}
	}

	return tst
}

func (s *DirectAbstractDeclaratorContext) AbstractDeclaratorSuffix(i int) IAbstractDeclaratorSuffixContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAbstractDeclaratorSuffixContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAbstractDeclaratorSuffixContext)
}

func (s *DirectAbstractDeclaratorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DirectAbstractDeclaratorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DirectAbstractDeclaratorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CParserVisitor:
		return t.VisitDirectAbstractDeclarator(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CParser) DirectAbstractDeclarator() (localctx IDirectAbstractDeclaratorContext) {
	this := p
	_ = this

	localctx = NewDirectAbstractDeclaratorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 124, CParserRULE_directAbstractDeclarator)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.SetState(1666)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 233, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1634)
			p.Match(CParserLeftParen)
		}
		p.SetState(1638)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == CParserSemi || _la == CParserEOS {
			{
				p.SetState(1635)
				p.Eos()
			}

			p.SetState(1640)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1641)
			p.AbstractDeclarator()
		}
		p.SetState(1645)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == CParserSemi || _la == CParserEOS {
			{
				p.SetState(1642)
				p.Eos()
			}

			p.SetState(1647)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1648)
			p.Match(CParserRightParen)
		}
		p.SetState(1652)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 230, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(1649)
					p.GccDeclaratorExtension()
				}

			}
			p.SetState(1654)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 230, p.GetParserRuleContext())
		}
		p.SetState(1658)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 231, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(1655)
					p.AbstractDeclaratorSuffix()
				}

			}
			p.SetState(1660)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 231, p.GetParserRuleContext())
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(1662)
		p.GetErrorHandler().Sync(p)
		_alt = 1
		for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			switch _alt {
			case 1:
				{
					p.SetState(1661)
					p.AbstractDeclaratorSuffix()
				}

			default:
				panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			}

			p.SetState(1664)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 232, p.GetParserRuleContext())
		}

	}

	return localctx
}

// IAbstractDeclaratorSuffixContext is an interface to support dynamic dispatch.
type IAbstractDeclaratorSuffixContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAbstractDeclaratorSuffixContext differentiates from other interfaces.
	IsAbstractDeclaratorSuffixContext()
}

type AbstractDeclaratorSuffixContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAbstractDeclaratorSuffixContext() *AbstractDeclaratorSuffixContext {
	var p = new(AbstractDeclaratorSuffixContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CParserRULE_abstractDeclaratorSuffix
	return p
}

func (*AbstractDeclaratorSuffixContext) IsAbstractDeclaratorSuffixContext() {}

func NewAbstractDeclaratorSuffixContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AbstractDeclaratorSuffixContext {
	var p = new(AbstractDeclaratorSuffixContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CParserRULE_abstractDeclaratorSuffix

	return p
}

func (s *AbstractDeclaratorSuffixContext) GetParser() antlr.Parser { return s.parser }

func (s *AbstractDeclaratorSuffixContext) AbstractArraySuffix() IAbstractArraySuffixContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAbstractArraySuffixContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAbstractArraySuffixContext)
}

func (s *AbstractDeclaratorSuffixContext) AbstractFunctionSuffix() IAbstractFunctionSuffixContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAbstractFunctionSuffixContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAbstractFunctionSuffixContext)
}

func (s *AbstractDeclaratorSuffixContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AbstractDeclaratorSuffixContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AbstractDeclaratorSuffixContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CParserVisitor:
		return t.VisitAbstractDeclaratorSuffix(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CParser) AbstractDeclaratorSuffix() (localctx IAbstractDeclaratorSuffixContext) {
	this := p
	_ = this

	localctx = NewAbstractDeclaratorSuffixContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 126, CParserRULE_abstractDeclaratorSuffix)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1670)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case CParserLeftBracket:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1668)
			p.AbstractArraySuffix()
		}

	case CParserLeftParen:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1669)
			p.AbstractFunctionSuffix()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IAbstractArraySuffixContext is an interface to support dynamic dispatch.
type IAbstractArraySuffixContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAbstractArraySuffixContext differentiates from other interfaces.
	IsAbstractArraySuffixContext()
}

type AbstractArraySuffixContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAbstractArraySuffixContext() *AbstractArraySuffixContext {
	var p = new(AbstractArraySuffixContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CParserRULE_abstractArraySuffix
	return p
}

func (*AbstractArraySuffixContext) IsAbstractArraySuffixContext() {}

func NewAbstractArraySuffixContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AbstractArraySuffixContext {
	var p = new(AbstractArraySuffixContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CParserRULE_abstractArraySuffix

	return p
}

func (s *AbstractArraySuffixContext) GetParser() antlr.Parser { return s.parser }

func (s *AbstractArraySuffixContext) LeftBracket() antlr.TerminalNode {
	return s.GetToken(CParserLeftBracket, 0)
}

func (s *AbstractArraySuffixContext) RightBracket() antlr.TerminalNode {
	return s.GetToken(CParserRightBracket, 0)
}

func (s *AbstractArraySuffixContext) AllEos() []IEosContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IEosContext); ok {
			len++
		}
	}

	tst := make([]IEosContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IEosContext); ok {
			tst[i] = t.(IEosContext)
			i++
		}
	}

	return tst
}

func (s *AbstractArraySuffixContext) Eos(i int) IEosContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEosContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEosContext)
}

func (s *AbstractArraySuffixContext) TypeQualifierList() ITypeQualifierListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeQualifierListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeQualifierListContext)
}

func (s *AbstractArraySuffixContext) CoreExpression() ICoreExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICoreExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICoreExpressionContext)
}

func (s *AbstractArraySuffixContext) Static() antlr.TerminalNode {
	return s.GetToken(CParserStatic, 0)
}

func (s *AbstractArraySuffixContext) Star() antlr.TerminalNode {
	return s.GetToken(CParserStar, 0)
}

func (s *AbstractArraySuffixContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AbstractArraySuffixContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AbstractArraySuffixContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CParserVisitor:
		return t.VisitAbstractArraySuffix(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CParser) AbstractArraySuffix() (localctx IAbstractArraySuffixContext) {
	this := p
	_ = this

	localctx = NewAbstractArraySuffixContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 128, CParserRULE_abstractArraySuffix)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.SetState(1775)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 251, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1672)
			p.Match(CParserLeftBracket)
		}
		p.SetState(1676)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 235, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(1673)
					p.Eos()
				}

			}
			p.SetState(1678)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 235, p.GetParserRuleContext())
		}
		p.SetState(1680)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if (int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&592780984352) != 0 {
			{
				p.SetState(1679)
				p.TypeQualifierList()
			}

		}
		p.SetState(1685)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 237, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(1682)
					p.Eos()
				}

			}
			p.SetState(1687)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 237, p.GetParserRuleContext())
		}
		p.SetState(1689)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if (int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-3458056153320128512) != 0 || (int64((_la-66)) & ^0x3f) == 0 && ((int64(1)<<(_la-66))&489139732485) != 0 {
			{
				p.SetState(1688)
				p.CoreExpression()
			}

		}
		p.SetState(1694)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == CParserSemi || _la == CParserEOS {
			{
				p.SetState(1691)
				p.Eos()
			}

			p.SetState(1696)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1697)
			p.Match(CParserRightBracket)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1698)
			p.Match(CParserLeftBracket)
		}
		p.SetState(1702)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == CParserSemi || _la == CParserEOS {
			{
				p.SetState(1699)
				p.Eos()
			}

			p.SetState(1704)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1705)
			p.Match(CParserStatic)
		}
		p.SetState(1709)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 241, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(1706)
					p.Eos()
				}

			}
			p.SetState(1711)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 241, p.GetParserRuleContext())
		}
		p.SetState(1713)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if (int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&592780984352) != 0 {
			{
				p.SetState(1712)
				p.TypeQualifierList()
			}

		}
		p.SetState(1718)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == CParserSemi || _la == CParserEOS {
			{
				p.SetState(1715)
				p.Eos()
			}

			p.SetState(1720)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1721)
			p.CoreExpression()
		}
		p.SetState(1725)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == CParserSemi || _la == CParserEOS {
			{
				p.SetState(1722)
				p.Eos()
			}

			p.SetState(1727)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1728)
			p.Match(CParserRightBracket)
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1730)
			p.Match(CParserLeftBracket)
		}
		p.SetState(1734)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == CParserSemi || _la == CParserEOS {
			{
				p.SetState(1731)
				p.Eos()
			}

			p.SetState(1736)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1737)
			p.TypeQualifierList()
		}
		p.SetState(1741)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == CParserSemi || _la == CParserEOS {
			{
				p.SetState(1738)
				p.Eos()
			}

			p.SetState(1743)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1744)
			p.Match(CParserStatic)
		}
		p.SetState(1748)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == CParserSemi || _la == CParserEOS {
			{
				p.SetState(1745)
				p.Eos()
			}

			p.SetState(1750)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1751)
			p.CoreExpression()
		}
		p.SetState(1755)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == CParserSemi || _la == CParserEOS {
			{
				p.SetState(1752)
				p.Eos()
			}

			p.SetState(1757)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1758)
			p.Match(CParserRightBracket)
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1760)
			p.Match(CParserLeftBracket)
		}
		p.SetState(1764)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == CParserSemi || _la == CParserEOS {
			{
				p.SetState(1761)
				p.Eos()
			}

			p.SetState(1766)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1767)
			p.Match(CParserStar)
		}
		p.SetState(1771)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == CParserSemi || _la == CParserEOS {
			{
				p.SetState(1768)
				p.Eos()
			}

			p.SetState(1773)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1774)
			p.Match(CParserRightBracket)
		}

	}

	return localctx
}

// IAbstractFunctionSuffixContext is an interface to support dynamic dispatch.
type IAbstractFunctionSuffixContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAbstractFunctionSuffixContext differentiates from other interfaces.
	IsAbstractFunctionSuffixContext()
}

type AbstractFunctionSuffixContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAbstractFunctionSuffixContext() *AbstractFunctionSuffixContext {
	var p = new(AbstractFunctionSuffixContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CParserRULE_abstractFunctionSuffix
	return p
}

func (*AbstractFunctionSuffixContext) IsAbstractFunctionSuffixContext() {}

func NewAbstractFunctionSuffixContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AbstractFunctionSuffixContext {
	var p = new(AbstractFunctionSuffixContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CParserRULE_abstractFunctionSuffix

	return p
}

func (s *AbstractFunctionSuffixContext) GetParser() antlr.Parser { return s.parser }

func (s *AbstractFunctionSuffixContext) LeftParen() antlr.TerminalNode {
	return s.GetToken(CParserLeftParen, 0)
}

func (s *AbstractFunctionSuffixContext) RightParen() antlr.TerminalNode {
	return s.GetToken(CParserRightParen, 0)
}

func (s *AbstractFunctionSuffixContext) AllEos() []IEosContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IEosContext); ok {
			len++
		}
	}

	tst := make([]IEosContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IEosContext); ok {
			tst[i] = t.(IEosContext)
			i++
		}
	}

	return tst
}

func (s *AbstractFunctionSuffixContext) Eos(i int) IEosContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEosContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEosContext)
}

func (s *AbstractFunctionSuffixContext) ParameterTypeList() IParameterTypeListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IParameterTypeListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IParameterTypeListContext)
}

func (s *AbstractFunctionSuffixContext) AllGccDeclaratorExtension() []IGccDeclaratorExtensionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IGccDeclaratorExtensionContext); ok {
			len++
		}
	}

	tst := make([]IGccDeclaratorExtensionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IGccDeclaratorExtensionContext); ok {
			tst[i] = t.(IGccDeclaratorExtensionContext)
			i++
		}
	}

	return tst
}

func (s *AbstractFunctionSuffixContext) GccDeclaratorExtension(i int) IGccDeclaratorExtensionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGccDeclaratorExtensionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGccDeclaratorExtensionContext)
}

func (s *AbstractFunctionSuffixContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AbstractFunctionSuffixContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AbstractFunctionSuffixContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CParserVisitor:
		return t.VisitAbstractFunctionSuffix(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CParser) AbstractFunctionSuffix() (localctx IAbstractFunctionSuffixContext) {
	this := p
	_ = this

	localctx = NewAbstractFunctionSuffixContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 130, CParserRULE_abstractFunctionSuffix)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1777)
		p.Match(CParserLeftParen)
	}
	p.SetState(1781)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 252, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1778)
				p.Eos()
			}

		}
		p.SetState(1783)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 252, p.GetParserRuleContext())
	}
	p.SetState(1785)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if (int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&92014154380850) != 0 || (int64((_la-94)) & ^0x3f) == 0 && ((int64(1)<<(_la-94))&260355) != 0 {
		{
			p.SetState(1784)
			p.ParameterTypeList()
		}

	}
	p.SetState(1790)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == CParserSemi || _la == CParserEOS {
		{
			p.SetState(1787)
			p.Eos()
		}

		p.SetState(1792)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1793)
		p.Match(CParserRightParen)
	}
	p.SetState(1797)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 255, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1794)
				p.GccDeclaratorExtension()
			}

		}
		p.SetState(1799)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 255, p.GetParserRuleContext())
	}

	return localctx
}

// ITypedefNameContext is an interface to support dynamic dispatch.
type ITypedefNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTypedefNameContext differentiates from other interfaces.
	IsTypedefNameContext()
}

type TypedefNameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypedefNameContext() *TypedefNameContext {
	var p = new(TypedefNameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CParserRULE_typedefName
	return p
}

func (*TypedefNameContext) IsTypedefNameContext() {}

func NewTypedefNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypedefNameContext {
	var p = new(TypedefNameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CParserRULE_typedefName

	return p
}

func (s *TypedefNameContext) GetParser() antlr.Parser { return s.parser }

func (s *TypedefNameContext) Identifier() antlr.TerminalNode {
	return s.GetToken(CParserIdentifier, 0)
}

func (s *TypedefNameContext) StructOrUnion() IStructOrUnionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStructOrUnionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStructOrUnionContext)
}

func (s *TypedefNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypedefNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypedefNameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CParserVisitor:
		return t.VisitTypedefName(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CParser) TypedefName() (localctx ITypedefNameContext) {
	this := p
	_ = this

	localctx = NewTypedefNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 132, CParserRULE_typedefName)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1801)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == CParserStruct || _la == CParserUnion {
		{
			p.SetState(1800)
			p.StructOrUnion()
		}

	}
	{
		p.SetState(1803)
		p.Match(CParserIdentifier)
	}

	return localctx
}

// IInitializerContext is an interface to support dynamic dispatch.
type IInitializerContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInitializerContext differentiates from other interfaces.
	IsInitializerContext()
}

type InitializerContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInitializerContext() *InitializerContext {
	var p = new(InitializerContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CParserRULE_initializer
	return p
}

func (*InitializerContext) IsInitializerContext() {}

func NewInitializerContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InitializerContext {
	var p = new(InitializerContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CParserRULE_initializer

	return p
}

func (s *InitializerContext) GetParser() antlr.Parser { return s.parser }

func (s *InitializerContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *InitializerContext) LeftBrace() antlr.TerminalNode {
	return s.GetToken(CParserLeftBrace, 0)
}

func (s *InitializerContext) RightBrace() antlr.TerminalNode {
	return s.GetToken(CParserRightBrace, 0)
}

func (s *InitializerContext) AllEos() []IEosContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IEosContext); ok {
			len++
		}
	}

	tst := make([]IEosContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IEosContext); ok {
			tst[i] = t.(IEosContext)
			i++
		}
	}

	return tst
}

func (s *InitializerContext) Eos(i int) IEosContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEosContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEosContext)
}

func (s *InitializerContext) InitializerList() IInitializerListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInitializerListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInitializerListContext)
}

func (s *InitializerContext) Comma() antlr.TerminalNode {
	return s.GetToken(CParserComma, 0)
}

func (s *InitializerContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InitializerContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InitializerContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CParserVisitor:
		return t.VisitInitializer(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CParser) Initializer() (localctx IInitializerContext) {
	this := p
	_ = this

	localctx = NewInitializerContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 134, CParserRULE_initializer)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.SetState(1832)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case CParserAuto, CParserChar, CParserConst, CParserDouble, CParserLongdouble, CParserEnum, CParserExtern, CParserFloat, CParserInline, CParserInt, CParserLong, CParserLonglong, CParserRegister, CParserRestrict, CParserShort, CParserSigned, CParserSizeof, CParserStatic, CParserStruct, CParserTypedef, CParserUnion, CParserUnsigned, CParserVoid, CParserVolatile, CParserAlignas, CParserAlignof, CParserAtomic, CParserBool, CParserComplex, CParserGeneric, CParserNoreturn, CParserThreadLocal, CParserLeftParen, CParserLeftBracket, CParserPlus, CParserPlusPlus, CParserMinus, CParserMinusMinus, CParserStar, CParserAnd, CParserAndAnd, CParserCaret, CParserNot, CParserTilde, CParserArrow, CParserDot, CParserAttribute__, CParserIdentifier, CParserConstant, CParserDigitSequence, CParserStringLiteral, CParserExtension, CParserBuiltinVaArg, CParserBuiltinOffsetof, CParserM128, CParserM128d, CParserM128i, CParserTypeof, CParserInline__, CParserStdcall, CParserDeclspec:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1805)
			p.expression(0)
		}

	case CParserLeftBrace:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1806)
			p.Match(CParserLeftBrace)
		}
		p.SetState(1810)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 257, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(1807)
					p.Eos()
				}

			}
			p.SetState(1812)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 257, p.GetParserRuleContext())
		}
		p.SetState(1814)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if (int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-573408577834944974) != 0 || (int64((_la-66)) & ^0x3f) == 0 && ((int64(1)<<(_la-66))&70308396531829) != 0 {
			{
				p.SetState(1813)
				p.InitializerList()
			}

		}
		p.SetState(1819)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 259, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(1816)
					p.Eos()
				}

			}
			p.SetState(1821)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 259, p.GetParserRuleContext())
		}
		p.SetState(1823)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == CParserComma {
			{
				p.SetState(1822)
				p.Match(CParserComma)
			}

		}
		p.SetState(1828)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == CParserSemi || _la == CParserEOS {
			{
				p.SetState(1825)
				p.Eos()
			}

			p.SetState(1830)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1831)
			p.Match(CParserRightBrace)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IInitializerListContext is an interface to support dynamic dispatch.
type IInitializerListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInitializerListContext differentiates from other interfaces.
	IsInitializerListContext()
}

type InitializerListContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInitializerListContext() *InitializerListContext {
	var p = new(InitializerListContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CParserRULE_initializerList
	return p
}

func (*InitializerListContext) IsInitializerListContext() {}

func NewInitializerListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InitializerListContext {
	var p = new(InitializerListContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CParserRULE_initializerList

	return p
}

func (s *InitializerListContext) GetParser() antlr.Parser { return s.parser }

func (s *InitializerListContext) AllInitializer() []IInitializerContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IInitializerContext); ok {
			len++
		}
	}

	tst := make([]IInitializerContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IInitializerContext); ok {
			tst[i] = t.(IInitializerContext)
			i++
		}
	}

	return tst
}

func (s *InitializerListContext) Initializer(i int) IInitializerContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInitializerContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInitializerContext)
}

func (s *InitializerListContext) AllDesignation() []IDesignationContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IDesignationContext); ok {
			len++
		}
	}

	tst := make([]IDesignationContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IDesignationContext); ok {
			tst[i] = t.(IDesignationContext)
			i++
		}
	}

	return tst
}

func (s *InitializerListContext) Designation(i int) IDesignationContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDesignationContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDesignationContext)
}

func (s *InitializerListContext) AllComma() []antlr.TerminalNode {
	return s.GetTokens(CParserComma)
}

func (s *InitializerListContext) Comma(i int) antlr.TerminalNode {
	return s.GetToken(CParserComma, i)
}

func (s *InitializerListContext) AllEos() []IEosContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IEosContext); ok {
			len++
		}
	}

	tst := make([]IEosContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IEosContext); ok {
			tst[i] = t.(IEosContext)
			i++
		}
	}

	return tst
}

func (s *InitializerListContext) Eos(i int) IEosContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEosContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEosContext)
}

func (s *InitializerListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InitializerListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InitializerListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CParserVisitor:
		return t.VisitInitializerList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CParser) InitializerList() (localctx IInitializerListContext) {
	this := p
	_ = this

	localctx = NewInitializerListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 136, CParserRULE_initializerList)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1835)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 263, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1834)
			p.Designation()
		}

	}
	{
		p.SetState(1837)
		p.Initializer()
	}
	p.SetState(1851)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 266, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1838)
				p.Match(CParserComma)
			}
			p.SetState(1842)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			for _la == CParserSemi || _la == CParserEOS {
				{
					p.SetState(1839)
					p.Eos()
				}

				p.SetState(1844)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)
			}
			p.SetState(1846)
			p.GetErrorHandler().Sync(p)

			if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 265, p.GetParserRuleContext()) == 1 {
				{
					p.SetState(1845)
					p.Designation()
				}

			}
			{
				p.SetState(1848)
				p.Initializer()
			}

		}
		p.SetState(1853)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 266, p.GetParserRuleContext())
	}

	return localctx
}

// IDesignationContext is an interface to support dynamic dispatch.
type IDesignationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDesignationContext differentiates from other interfaces.
	IsDesignationContext()
}

type DesignationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDesignationContext() *DesignationContext {
	var p = new(DesignationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CParserRULE_designation
	return p
}

func (*DesignationContext) IsDesignationContext() {}

func NewDesignationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DesignationContext {
	var p = new(DesignationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CParserRULE_designation

	return p
}

func (s *DesignationContext) GetParser() antlr.Parser { return s.parser }

func (s *DesignationContext) DesignatorList() IDesignatorListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDesignatorListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDesignatorListContext)
}

func (s *DesignationContext) Assign() antlr.TerminalNode {
	return s.GetToken(CParserAssign, 0)
}

func (s *DesignationContext) AllEos() []IEosContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IEosContext); ok {
			len++
		}
	}

	tst := make([]IEosContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IEosContext); ok {
			tst[i] = t.(IEosContext)
			i++
		}
	}

	return tst
}

func (s *DesignationContext) Eos(i int) IEosContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEosContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEosContext)
}

func (s *DesignationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DesignationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DesignationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CParserVisitor:
		return t.VisitDesignation(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CParser) Designation() (localctx IDesignationContext) {
	this := p
	_ = this

	localctx = NewDesignationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 138, CParserRULE_designation)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1854)
		p.DesignatorList()
	}
	p.SetState(1858)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == CParserSemi || _la == CParserEOS {
		{
			p.SetState(1855)
			p.Eos()
		}

		p.SetState(1860)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1861)
		p.Match(CParserAssign)
	}

	return localctx
}

// IDesignatorListContext is an interface to support dynamic dispatch.
type IDesignatorListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDesignatorListContext differentiates from other interfaces.
	IsDesignatorListContext()
}

type DesignatorListContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDesignatorListContext() *DesignatorListContext {
	var p = new(DesignatorListContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CParserRULE_designatorList
	return p
}

func (*DesignatorListContext) IsDesignatorListContext() {}

func NewDesignatorListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DesignatorListContext {
	var p = new(DesignatorListContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CParserRULE_designatorList

	return p
}

func (s *DesignatorListContext) GetParser() antlr.Parser { return s.parser }

func (s *DesignatorListContext) AllDesignator() []IDesignatorContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IDesignatorContext); ok {
			len++
		}
	}

	tst := make([]IDesignatorContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IDesignatorContext); ok {
			tst[i] = t.(IDesignatorContext)
			i++
		}
	}

	return tst
}

func (s *DesignatorListContext) Designator(i int) IDesignatorContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDesignatorContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDesignatorContext)
}

func (s *DesignatorListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DesignatorListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DesignatorListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CParserVisitor:
		return t.VisitDesignatorList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CParser) DesignatorList() (localctx IDesignatorListContext) {
	this := p
	_ = this

	localctx = NewDesignatorListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 140, CParserRULE_designatorList)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1864)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = _la == CParserLeftBracket || _la == CParserDot {
		{
			p.SetState(1863)
			p.Designator()
		}

		p.SetState(1866)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IDesignatorContext is an interface to support dynamic dispatch.
type IDesignatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDesignatorContext differentiates from other interfaces.
	IsDesignatorContext()
}

type DesignatorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDesignatorContext() *DesignatorContext {
	var p = new(DesignatorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CParserRULE_designator
	return p
}

func (*DesignatorContext) IsDesignatorContext() {}

func NewDesignatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DesignatorContext {
	var p = new(DesignatorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CParserRULE_designator

	return p
}

func (s *DesignatorContext) GetParser() antlr.Parser { return s.parser }

func (s *DesignatorContext) LeftBracket() antlr.TerminalNode {
	return s.GetToken(CParserLeftBracket, 0)
}

func (s *DesignatorContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *DesignatorContext) RightBracket() antlr.TerminalNode {
	return s.GetToken(CParserRightBracket, 0)
}

func (s *DesignatorContext) AllEos() []IEosContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IEosContext); ok {
			len++
		}
	}

	tst := make([]IEosContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IEosContext); ok {
			tst[i] = t.(IEosContext)
			i++
		}
	}

	return tst
}

func (s *DesignatorContext) Eos(i int) IEosContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEosContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEosContext)
}

func (s *DesignatorContext) Dot() antlr.TerminalNode {
	return s.GetToken(CParserDot, 0)
}

func (s *DesignatorContext) Identifier() antlr.TerminalNode {
	return s.GetToken(CParserIdentifier, 0)
}

func (s *DesignatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DesignatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DesignatorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CParserVisitor:
		return t.VisitDesignator(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CParser) Designator() (localctx IDesignatorContext) {
	this := p
	_ = this

	localctx = NewDesignatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 142, CParserRULE_designator)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1892)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case CParserLeftBracket:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1868)
			p.Match(CParserLeftBracket)
		}
		p.SetState(1872)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == CParserSemi || _la == CParserEOS {
			{
				p.SetState(1869)
				p.Eos()
			}

			p.SetState(1874)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1875)
			p.expression(0)
		}
		p.SetState(1879)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == CParserSemi || _la == CParserEOS {
			{
				p.SetState(1876)
				p.Eos()
			}

			p.SetState(1881)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1882)
			p.Match(CParserRightBracket)
		}

	case CParserDot:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1884)
			p.Match(CParserDot)
		}
		p.SetState(1888)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == CParserSemi || _la == CParserEOS {
			{
				p.SetState(1885)
				p.Eos()
			}

			p.SetState(1890)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1891)
			p.Match(CParserIdentifier)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IStaticAssertDeclarationContext is an interface to support dynamic dispatch.
type IStaticAssertDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsStaticAssertDeclarationContext differentiates from other interfaces.
	IsStaticAssertDeclarationContext()
}

type StaticAssertDeclarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStaticAssertDeclarationContext() *StaticAssertDeclarationContext {
	var p = new(StaticAssertDeclarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CParserRULE_staticAssertDeclaration
	return p
}

func (*StaticAssertDeclarationContext) IsStaticAssertDeclarationContext() {}

func NewStaticAssertDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StaticAssertDeclarationContext {
	var p = new(StaticAssertDeclarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CParserRULE_staticAssertDeclaration

	return p
}

func (s *StaticAssertDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *StaticAssertDeclarationContext) StaticAssert() antlr.TerminalNode {
	return s.GetToken(CParserStaticAssert, 0)
}

func (s *StaticAssertDeclarationContext) LeftParen() antlr.TerminalNode {
	return s.GetToken(CParserLeftParen, 0)
}

func (s *StaticAssertDeclarationContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *StaticAssertDeclarationContext) Comma() antlr.TerminalNode {
	return s.GetToken(CParserComma, 0)
}

func (s *StaticAssertDeclarationContext) RightParen() antlr.TerminalNode {
	return s.GetToken(CParserRightParen, 0)
}

func (s *StaticAssertDeclarationContext) Semi() antlr.TerminalNode {
	return s.GetToken(CParserSemi, 0)
}

func (s *StaticAssertDeclarationContext) AllEos() []IEosContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IEosContext); ok {
			len++
		}
	}

	tst := make([]IEosContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IEosContext); ok {
			tst[i] = t.(IEosContext)
			i++
		}
	}

	return tst
}

func (s *StaticAssertDeclarationContext) Eos(i int) IEosContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEosContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEosContext)
}

func (s *StaticAssertDeclarationContext) AllStringLiteral() []antlr.TerminalNode {
	return s.GetTokens(CParserStringLiteral)
}

func (s *StaticAssertDeclarationContext) StringLiteral(i int) antlr.TerminalNode {
	return s.GetToken(CParserStringLiteral, i)
}

func (s *StaticAssertDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StaticAssertDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StaticAssertDeclarationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CParserVisitor:
		return t.VisitStaticAssertDeclaration(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CParser) StaticAssertDeclaration() (localctx IStaticAssertDeclarationContext) {
	this := p
	_ = this

	localctx = NewStaticAssertDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 144, CParserRULE_staticAssertDeclaration)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1894)
		p.Match(CParserStaticAssert)
	}
	p.SetState(1898)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == CParserSemi || _la == CParserEOS {
		{
			p.SetState(1895)
			p.Eos()
		}

		p.SetState(1900)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1901)
		p.Match(CParserLeftParen)
	}
	p.SetState(1905)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == CParserSemi || _la == CParserEOS {
		{
			p.SetState(1902)
			p.Eos()
		}

		p.SetState(1907)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1908)
		p.expression(0)
	}
	p.SetState(1912)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == CParserSemi || _la == CParserEOS {
		{
			p.SetState(1909)
			p.Eos()
		}

		p.SetState(1914)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1915)
		p.Match(CParserComma)
	}
	p.SetState(1919)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == CParserSemi || _la == CParserEOS {
		{
			p.SetState(1916)
			p.Eos()
		}

		p.SetState(1921)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(1923)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = _la == CParserStringLiteral {
		{
			p.SetState(1922)
			p.Match(CParserStringLiteral)
		}

		p.SetState(1925)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(1930)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == CParserSemi || _la == CParserEOS {
		{
			p.SetState(1927)
			p.Eos()
		}

		p.SetState(1932)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1933)
		p.Match(CParserRightParen)
	}
	p.SetState(1937)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 279, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1934)
				p.Eos()
			}

		}
		p.SetState(1939)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 279, p.GetParserRuleContext())
	}
	{
		p.SetState(1940)
		p.Match(CParserSemi)
	}

	return localctx
}

// IStatementContext is an interface to support dynamic dispatch.
type IStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsStatementContext differentiates from other interfaces.
	IsStatementContext()
}

type StatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStatementContext() *StatementContext {
	var p = new(StatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CParserRULE_statement
	return p
}

func (*StatementContext) IsStatementContext() {}

func NewStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StatementContext {
	var p = new(StatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CParserRULE_statement

	return p
}

func (s *StatementContext) GetParser() antlr.Parser { return s.parser }

func (s *StatementContext) Identifier() antlr.TerminalNode {
	return s.GetToken(CParserIdentifier, 0)
}

func (s *StatementContext) Colon() antlr.TerminalNode {
	return s.GetToken(CParserColon, 0)
}

func (s *StatementContext) AllEos() []IEosContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IEosContext); ok {
			len++
		}
	}

	tst := make([]IEosContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IEosContext); ok {
			tst[i] = t.(IEosContext)
			i++
		}
	}

	return tst
}

func (s *StatementContext) Eos(i int) IEosContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEosContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEosContext)
}

func (s *StatementContext) Statement() IStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *StatementContext) CompoundStatement() ICompoundStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICompoundStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICompoundStatementContext)
}

func (s *StatementContext) ExpressionStatement() IExpressionStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionStatementContext)
}

func (s *StatementContext) StatementsExpression() IStatementsExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementsExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementsExpressionContext)
}

func (s *StatementContext) SelectionStatement() ISelectionStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelectionStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelectionStatementContext)
}

func (s *StatementContext) IterationStatement() IIterationStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIterationStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIterationStatementContext)
}

func (s *StatementContext) JumpStatement() IJumpStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IJumpStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IJumpStatementContext)
}

func (s *StatementContext) AsmStatement() IAsmStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAsmStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAsmStatementContext)
}

func (s *StatementContext) MacroCallStatement() IMacroCallStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMacroCallStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMacroCallStatementContext)
}

func (s *StatementContext) Semi() antlr.TerminalNode {
	return s.GetToken(CParserSemi, 0)
}

func (s *StatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CParserVisitor:
		return t.VisitStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CParser) Statement() (localctx IStatementContext) {
	this := p
	_ = this

	localctx = NewStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 146, CParserRULE_statement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.SetState(1962)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 282, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1942)
			p.Match(CParserIdentifier)
		}
		{
			p.SetState(1943)
			p.Match(CParserColon)
		}
		p.SetState(1947)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 280, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(1944)
					p.Eos()
				}

			}
			p.SetState(1949)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 280, p.GetParserRuleContext())
		}
		p.SetState(1951)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 281, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1950)
				p.Statement()
			}

		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1953)
			p.CompoundStatement()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1954)
			p.ExpressionStatement()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1955)
			p.StatementsExpression()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1956)
			p.SelectionStatement()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(1957)
			p.IterationStatement()
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(1958)
			p.JumpStatement()
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(1959)
			p.AsmStatement()
		}

	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(1960)
			p.MacroCallStatement()
		}

	case 10:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(1961)
			p.Match(CParserSemi)
		}

	}

	return localctx
}

// IMacroCallStatementContext is an interface to support dynamic dispatch.
type IMacroCallStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMacroCallStatementContext differentiates from other interfaces.
	IsMacroCallStatementContext()
}

type MacroCallStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMacroCallStatementContext() *MacroCallStatementContext {
	var p = new(MacroCallStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CParserRULE_macroCallStatement
	return p
}

func (*MacroCallStatementContext) IsMacroCallStatementContext() {}

func NewMacroCallStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MacroCallStatementContext {
	var p = new(MacroCallStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CParserRULE_macroCallStatement

	return p
}

func (s *MacroCallStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *MacroCallStatementContext) Identifier() antlr.TerminalNode {
	return s.GetToken(CParserIdentifier, 0)
}

func (s *MacroCallStatementContext) AllEos() []IEosContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IEosContext); ok {
			len++
		}
	}

	tst := make([]IEosContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IEosContext); ok {
			tst[i] = t.(IEosContext)
			i++
		}
	}

	return tst
}

func (s *MacroCallStatementContext) Eos(i int) IEosContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEosContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEosContext)
}

func (s *MacroCallStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MacroCallStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MacroCallStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CParserVisitor:
		return t.VisitMacroCallStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CParser) MacroCallStatement() (localctx IMacroCallStatementContext) {
	this := p
	_ = this

	localctx = NewMacroCallStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 148, CParserRULE_macroCallStatement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1964)
		p.Match(CParserIdentifier)
	}
	p.SetState(1968)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 283, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1965)
				p.Eos()
			}

		}
		p.SetState(1970)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 283, p.GetParserRuleContext())
	}

	return localctx
}

// IAsmStatementContext is an interface to support dynamic dispatch.
type IAsmStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAsmStatementContext differentiates from other interfaces.
	IsAsmStatementContext()
}

type AsmStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAsmStatementContext() *AsmStatementContext {
	var p = new(AsmStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CParserRULE_asmStatement
	return p
}

func (*AsmStatementContext) IsAsmStatementContext() {}

func NewAsmStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AsmStatementContext {
	var p = new(AsmStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CParserRULE_asmStatement

	return p
}

func (s *AsmStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *AsmStatementContext) Asm() antlr.TerminalNode {
	return s.GetToken(CParserAsm, 0)
}

func (s *AsmStatementContext) LeftParen() antlr.TerminalNode {
	return s.GetToken(CParserLeftParen, 0)
}

func (s *AsmStatementContext) RightParen() antlr.TerminalNode {
	return s.GetToken(CParserRightParen, 0)
}

func (s *AsmStatementContext) Semi() antlr.TerminalNode {
	return s.GetToken(CParserSemi, 0)
}

func (s *AsmStatementContext) AllEos() []IEosContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IEosContext); ok {
			len++
		}
	}

	tst := make([]IEosContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IEosContext); ok {
			tst[i] = t.(IEosContext)
			i++
		}
	}

	return tst
}

func (s *AsmStatementContext) Eos(i int) IEosContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEosContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEosContext)
}

func (s *AsmStatementContext) AllAsmExprList() []IAsmExprListContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAsmExprListContext); ok {
			len++
		}
	}

	tst := make([]IAsmExprListContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAsmExprListContext); ok {
			tst[i] = t.(IAsmExprListContext)
			i++
		}
	}

	return tst
}

func (s *AsmStatementContext) AsmExprList(i int) IAsmExprListContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAsmExprListContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAsmExprListContext)
}

func (s *AsmStatementContext) AllColon() []antlr.TerminalNode {
	return s.GetTokens(CParserColon)
}

func (s *AsmStatementContext) Colon(i int) antlr.TerminalNode {
	return s.GetToken(CParserColon, i)
}

func (s *AsmStatementContext) Volatile() antlr.TerminalNode {
	return s.GetToken(CParserVolatile, 0)
}

func (s *AsmStatementContext) Volatile__() antlr.TerminalNode {
	return s.GetToken(CParserVolatile__, 0)
}

func (s *AsmStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AsmStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AsmStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CParserVisitor:
		return t.VisitAsmStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CParser) AsmStatement() (localctx IAsmStatementContext) {
	this := p
	_ = this

	localctx = NewAsmStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 150, CParserRULE_asmStatement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1971)
		p.Match(CParserAsm)
	}
	p.SetState(1975)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 284, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1972)
				p.Eos()
			}

		}
		p.SetState(1977)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 284, p.GetParserRuleContext())
	}
	p.SetState(1979)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == CParserVolatile || _la == CParserVolatile__ {
		{
			p.SetState(1978)
			_la = p.GetTokenStream().LA(1)

			if !(_la == CParserVolatile || _la == CParserVolatile__) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}
	p.SetState(1984)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == CParserSemi || _la == CParserEOS {
		{
			p.SetState(1981)
			p.Eos()
		}

		p.SetState(1986)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1987)
		p.Match(CParserLeftParen)
	}
	p.SetState(1991)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 287, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1988)
				p.Eos()
			}

		}
		p.SetState(1993)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 287, p.GetParserRuleContext())
	}
	p.SetState(1995)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if (int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-575660377648630222) != 0 || (int64((_la-66)) & ^0x3f) == 0 && ((int64(1)<<(_la-66))&70308396531829) != 0 {
		{
			p.SetState(1994)
			p.AsmExprList()
		}

	}
	p.SetState(2000)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == CParserSemi || _la == CParserEOS {
		{
			p.SetState(1997)
			p.Eos()
		}

		p.SetState(2002)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(2061)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == CParserColon {
		{
			p.SetState(2003)
			p.Match(CParserColon)
		}
		p.SetState(2007)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 290, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(2004)
					p.Eos()
				}

			}
			p.SetState(2009)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 290, p.GetParserRuleContext())
		}
		p.SetState(2011)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if (int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-575660377648630222) != 0 || (int64((_la-66)) & ^0x3f) == 0 && ((int64(1)<<(_la-66))&70308396531829) != 0 {
			{
				p.SetState(2010)
				p.AsmExprList()
			}

		}
		p.SetState(2016)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 292, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(2013)
					p.Eos()
				}

			}
			p.SetState(2018)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 292, p.GetParserRuleContext())
		}
		p.SetState(2053)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == CParserColon {
			{
				p.SetState(2019)
				p.Match(CParserColon)
			}
			p.SetState(2023)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 293, p.GetParserRuleContext())

			for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
				if _alt == 1 {
					{
						p.SetState(2020)
						p.Eos()
					}

				}
				p.SetState(2025)
				p.GetErrorHandler().Sync(p)
				_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 293, p.GetParserRuleContext())
			}
			p.SetState(2027)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if (int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-575660377648630222) != 0 || (int64((_la-66)) & ^0x3f) == 0 && ((int64(1)<<(_la-66))&70308396531829) != 0 {
				{
					p.SetState(2026)
					p.AsmExprList()
				}

			}
			p.SetState(2032)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 295, p.GetParserRuleContext())

			for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
				if _alt == 1 {
					{
						p.SetState(2029)
						p.Eos()
					}

				}
				p.SetState(2034)
				p.GetErrorHandler().Sync(p)
				_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 295, p.GetParserRuleContext())
			}
			p.SetState(2051)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == CParserColon {
				{
					p.SetState(2035)
					p.Match(CParserColon)
				}
				p.SetState(2039)
				p.GetErrorHandler().Sync(p)
				_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 296, p.GetParserRuleContext())

				for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
					if _alt == 1 {
						{
							p.SetState(2036)
							p.Eos()
						}

					}
					p.SetState(2041)
					p.GetErrorHandler().Sync(p)
					_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 296, p.GetParserRuleContext())
				}
				p.SetState(2043)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)

				if (int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-575660377648630222) != 0 || (int64((_la-66)) & ^0x3f) == 0 && ((int64(1)<<(_la-66))&70308396531829) != 0 {
					{
						p.SetState(2042)
						p.AsmExprList()
					}

				}
				p.SetState(2048)
				p.GetErrorHandler().Sync(p)
				_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 298, p.GetParserRuleContext())

				for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
					if _alt == 1 {
						{
							p.SetState(2045)
							p.Eos()
						}

					}
					p.SetState(2050)
					p.GetErrorHandler().Sync(p)
					_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 298, p.GetParserRuleContext())
				}

			}

		}
		p.SetState(2058)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == CParserSemi || _la == CParserEOS {
			{
				p.SetState(2055)
				p.Eos()
			}

			p.SetState(2060)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	}
	{
		p.SetState(2063)
		p.Match(CParserRightParen)
	}
	p.SetState(2067)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 303, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(2064)
				p.Eos()
			}

		}
		p.SetState(2069)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 303, p.GetParserRuleContext())
	}
	{
		p.SetState(2070)
		p.Match(CParserSemi)
	}

	return localctx
}

// IAsmExprListContext is an interface to support dynamic dispatch.
type IAsmExprListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAsmExprListContext differentiates from other interfaces.
	IsAsmExprListContext()
}

type AsmExprListContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAsmExprListContext() *AsmExprListContext {
	var p = new(AsmExprListContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CParserRULE_asmExprList
	return p
}

func (*AsmExprListContext) IsAsmExprListContext() {}

func NewAsmExprListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AsmExprListContext {
	var p = new(AsmExprListContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CParserRULE_asmExprList

	return p
}

func (s *AsmExprListContext) GetParser() antlr.Parser { return s.parser }

func (s *AsmExprListContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *AsmExprListContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *AsmExprListContext) AllComma() []antlr.TerminalNode {
	return s.GetTokens(CParserComma)
}

func (s *AsmExprListContext) Comma(i int) antlr.TerminalNode {
	return s.GetToken(CParserComma, i)
}

func (s *AsmExprListContext) AllEos() []IEosContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IEosContext); ok {
			len++
		}
	}

	tst := make([]IEosContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IEosContext); ok {
			tst[i] = t.(IEosContext)
			i++
		}
	}

	return tst
}

func (s *AsmExprListContext) Eos(i int) IEosContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEosContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEosContext)
}

func (s *AsmExprListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AsmExprListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AsmExprListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CParserVisitor:
		return t.VisitAsmExprList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CParser) AsmExprList() (localctx IAsmExprListContext) {
	this := p
	_ = this

	localctx = NewAsmExprListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 152, CParserRULE_asmExprList)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2072)
		p.expression(0)
	}
	p.SetState(2083)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == CParserComma {
		{
			p.SetState(2073)
			p.Match(CParserComma)
		}
		p.SetState(2077)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == CParserSemi || _la == CParserEOS {
			{
				p.SetState(2074)
				p.Eos()
			}

			p.SetState(2079)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(2080)
			p.expression(0)
		}

		p.SetState(2085)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// ILabeledStatementContext is an interface to support dynamic dispatch.
type ILabeledStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLabeledStatementContext differentiates from other interfaces.
	IsLabeledStatementContext()
}

type LabeledStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLabeledStatementContext() *LabeledStatementContext {
	var p = new(LabeledStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CParserRULE_labeledStatement
	return p
}

func (*LabeledStatementContext) IsLabeledStatementContext() {}

func NewLabeledStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LabeledStatementContext {
	var p = new(LabeledStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CParserRULE_labeledStatement

	return p
}

func (s *LabeledStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *LabeledStatementContext) Case() antlr.TerminalNode {
	return s.GetToken(CParserCase, 0)
}

func (s *LabeledStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *LabeledStatementContext) Colon() antlr.TerminalNode {
	return s.GetToken(CParserColon, 0)
}

func (s *LabeledStatementContext) AllEos() []IEosContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IEosContext); ok {
			len++
		}
	}

	tst := make([]IEosContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IEosContext); ok {
			tst[i] = t.(IEosContext)
			i++
		}
	}

	return tst
}

func (s *LabeledStatementContext) Eos(i int) IEosContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEosContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEosContext)
}

func (s *LabeledStatementContext) AllStatement() []IStatementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStatementContext); ok {
			len++
		}
	}

	tst := make([]IStatementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStatementContext); ok {
			tst[i] = t.(IStatementContext)
			i++
		}
	}

	return tst
}

func (s *LabeledStatementContext) Statement(i int) IStatementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *LabeledStatementContext) Default() antlr.TerminalNode {
	return s.GetToken(CParserDefault, 0)
}

func (s *LabeledStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LabeledStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LabeledStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CParserVisitor:
		return t.VisitLabeledStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CParser) LabeledStatement() (localctx ILabeledStatementContext) {
	this := p
	_ = this

	localctx = NewLabeledStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 154, CParserRULE_labeledStatement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.SetState(2115)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case CParserCase:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2086)
			p.Match(CParserCase)
		}
		{
			p.SetState(2087)
			p.expression(0)
		}
		{
			p.SetState(2088)
			p.Match(CParserColon)
		}
		p.SetState(2092)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 306, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(2089)
					p.Eos()
				}

			}
			p.SetState(2094)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 306, p.GetParserRuleContext())
		}
		p.SetState(2098)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 307, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(2095)
					p.Statement()
				}

			}
			p.SetState(2100)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 307, p.GetParserRuleContext())
		}

	case CParserDefault:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2101)
			p.Match(CParserDefault)
		}
		{
			p.SetState(2102)
			p.Match(CParserColon)
		}
		p.SetState(2106)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 308, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(2103)
					p.Eos()
				}

			}
			p.SetState(2108)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 308, p.GetParserRuleContext())
		}
		p.SetState(2112)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 309, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(2109)
					p.Statement()
				}

			}
			p.SetState(2114)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 309, p.GetParserRuleContext())
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ICompoundStatementContext is an interface to support dynamic dispatch.
type ICompoundStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCompoundStatementContext differentiates from other interfaces.
	IsCompoundStatementContext()
}

type CompoundStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCompoundStatementContext() *CompoundStatementContext {
	var p = new(CompoundStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CParserRULE_compoundStatement
	return p
}

func (*CompoundStatementContext) IsCompoundStatementContext() {}

func NewCompoundStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CompoundStatementContext {
	var p = new(CompoundStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CParserRULE_compoundStatement

	return p
}

func (s *CompoundStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *CompoundStatementContext) LeftBrace() antlr.TerminalNode {
	return s.GetToken(CParserLeftBrace, 0)
}

func (s *CompoundStatementContext) RightBrace() antlr.TerminalNode {
	return s.GetToken(CParserRightBrace, 0)
}

func (s *CompoundStatementContext) BlockItemList() IBlockItemListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBlockItemListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBlockItemListContext)
}

func (s *CompoundStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CompoundStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CompoundStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CParserVisitor:
		return t.VisitCompoundStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CParser) CompoundStatement() (localctx ICompoundStatementContext) {
	this := p
	_ = this

	localctx = NewCompoundStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 156, CParserRULE_compoundStatement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2117)
		p.Match(CParserLeftBrace)
	}
	p.SetState(2119)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if (int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-3455677085169748106) != 0 || (int64((_la-66)) & ^0x3f) == 0 && ((int64(1)<<(_la-66))&70308530749957) != 0 {
		{
			p.SetState(2118)
			p.BlockItemList()
		}

	}
	{
		p.SetState(2121)
		p.Match(CParserRightBrace)
	}

	return localctx
}

// IBlockItemListContext is an interface to support dynamic dispatch.
type IBlockItemListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsBlockItemListContext differentiates from other interfaces.
	IsBlockItemListContext()
}

type BlockItemListContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBlockItemListContext() *BlockItemListContext {
	var p = new(BlockItemListContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CParserRULE_blockItemList
	return p
}

func (*BlockItemListContext) IsBlockItemListContext() {}

func NewBlockItemListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BlockItemListContext {
	var p = new(BlockItemListContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CParserRULE_blockItemList

	return p
}

func (s *BlockItemListContext) GetParser() antlr.Parser { return s.parser }

func (s *BlockItemListContext) AllBlockItem() []IBlockItemContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IBlockItemContext); ok {
			len++
		}
	}

	tst := make([]IBlockItemContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IBlockItemContext); ok {
			tst[i] = t.(IBlockItemContext)
			i++
		}
	}

	return tst
}

func (s *BlockItemListContext) BlockItem(i int) IBlockItemContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBlockItemContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBlockItemContext)
}

func (s *BlockItemListContext) AllWs() []IWsContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IWsContext); ok {
			len++
		}
	}

	tst := make([]IWsContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IWsContext); ok {
			tst[i] = t.(IWsContext)
			i++
		}
	}

	return tst
}

func (s *BlockItemListContext) Ws(i int) IWsContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWsContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWsContext)
}

func (s *BlockItemListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BlockItemListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BlockItemListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CParserVisitor:
		return t.VisitBlockItemList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CParser) BlockItemList() (localctx IBlockItemListContext) {
	this := p
	_ = this

	localctx = NewBlockItemListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 158, CParserRULE_blockItemList)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2130)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = (int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-3455677085169748106) != 0 || (int64((_la-66)) & ^0x3f) == 0 && ((int64(1)<<(_la-66))&70308530749957) != 0 {
		{
			p.SetState(2123)
			p.BlockItem()
		}
		p.SetState(2127)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for (int64((_la-123)) & ^0x3f) == 0 && ((int64(1)<<(_la-123))&11) != 0 {
			{
				p.SetState(2124)
				p.Ws()
			}

			p.SetState(2129)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

		p.SetState(2132)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IBlockItemContext is an interface to support dynamic dispatch.
type IBlockItemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsBlockItemContext differentiates from other interfaces.
	IsBlockItemContext()
}

type BlockItemContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBlockItemContext() *BlockItemContext {
	var p = new(BlockItemContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CParserRULE_blockItem
	return p
}

func (*BlockItemContext) IsBlockItemContext() {}

func NewBlockItemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BlockItemContext {
	var p = new(BlockItemContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CParserRULE_blockItem

	return p
}

func (s *BlockItemContext) GetParser() antlr.Parser { return s.parser }

func (s *BlockItemContext) Statement() IStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *BlockItemContext) Declaration() IDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDeclarationContext)
}

func (s *BlockItemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BlockItemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BlockItemContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CParserVisitor:
		return t.VisitBlockItem(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CParser) BlockItem() (localctx IBlockItemContext) {
	this := p
	_ = this

	localctx = NewBlockItemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 160, CParserRULE_blockItem)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(2136)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 314, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2134)
			p.Statement()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2135)
			p.Declaration()
		}

	}

	return localctx
}

// IExpressionStatementContext is an interface to support dynamic dispatch.
type IExpressionStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExpressionStatementContext differentiates from other interfaces.
	IsExpressionStatementContext()
}

type ExpressionStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpressionStatementContext() *ExpressionStatementContext {
	var p = new(ExpressionStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CParserRULE_expressionStatement
	return p
}

func (*ExpressionStatementContext) IsExpressionStatementContext() {}

func NewExpressionStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExpressionStatementContext {
	var p = new(ExpressionStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CParserRULE_expressionStatement

	return p
}

func (s *ExpressionStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ExpressionStatementContext) CoreExpressions() ICoreExpressionsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICoreExpressionsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICoreExpressionsContext)
}

func (s *ExpressionStatementContext) Semi() antlr.TerminalNode {
	return s.GetToken(CParserSemi, 0)
}

func (s *ExpressionStatementContext) AllEos() []IEosContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IEosContext); ok {
			len++
		}
	}

	tst := make([]IEosContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IEosContext); ok {
			tst[i] = t.(IEosContext)
			i++
		}
	}

	return tst
}

func (s *ExpressionStatementContext) Eos(i int) IEosContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEosContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEosContext)
}

func (s *ExpressionStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExpressionStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExpressionStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CParserVisitor:
		return t.VisitExpressionStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CParser) ExpressionStatement() (localctx IExpressionStatementContext) {
	this := p
	_ = this

	localctx = NewExpressionStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 162, CParserRULE_expressionStatement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2138)
		p.CoreExpressions()
	}
	p.SetState(2142)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 315, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(2139)
				p.Eos()
			}

		}
		p.SetState(2144)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 315, p.GetParserRuleContext())
	}
	{
		p.SetState(2145)
		p.Match(CParserSemi)
	}

	return localctx
}

// ISelectionStatementContext is an interface to support dynamic dispatch.
type ISelectionStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSelectionStatementContext differentiates from other interfaces.
	IsSelectionStatementContext()
}

type SelectionStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySelectionStatementContext() *SelectionStatementContext {
	var p = new(SelectionStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CParserRULE_selectionStatement
	return p
}

func (*SelectionStatementContext) IsSelectionStatementContext() {}

func NewSelectionStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SelectionStatementContext {
	var p = new(SelectionStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CParserRULE_selectionStatement

	return p
}

func (s *SelectionStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *SelectionStatementContext) If() antlr.TerminalNode {
	return s.GetToken(CParserIf, 0)
}

func (s *SelectionStatementContext) LeftParen() antlr.TerminalNode {
	return s.GetToken(CParserLeftParen, 0)
}

func (s *SelectionStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *SelectionStatementContext) RightParen() antlr.TerminalNode {
	return s.GetToken(CParserRightParen, 0)
}

func (s *SelectionStatementContext) AllStatement() []IStatementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStatementContext); ok {
			len++
		}
	}

	tst := make([]IStatementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStatementContext); ok {
			tst[i] = t.(IStatementContext)
			i++
		}
	}

	return tst
}

func (s *SelectionStatementContext) Statement(i int) IStatementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *SelectionStatementContext) AllEos() []IEosContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IEosContext); ok {
			len++
		}
	}

	tst := make([]IEosContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IEosContext); ok {
			tst[i] = t.(IEosContext)
			i++
		}
	}

	return tst
}

func (s *SelectionStatementContext) Eos(i int) IEosContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEosContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEosContext)
}

func (s *SelectionStatementContext) Else() antlr.TerminalNode {
	return s.GetToken(CParserElse, 0)
}

func (s *SelectionStatementContext) Switch() antlr.TerminalNode {
	return s.GetToken(CParserSwitch, 0)
}

func (s *SelectionStatementContext) LeftBrace() antlr.TerminalNode {
	return s.GetToken(CParserLeftBrace, 0)
}

func (s *SelectionStatementContext) RightBrace() antlr.TerminalNode {
	return s.GetToken(CParserRightBrace, 0)
}

func (s *SelectionStatementContext) AllLabeledStatement() []ILabeledStatementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ILabeledStatementContext); ok {
			len++
		}
	}

	tst := make([]ILabeledStatementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ILabeledStatementContext); ok {
			tst[i] = t.(ILabeledStatementContext)
			i++
		}
	}

	return tst
}

func (s *SelectionStatementContext) LabeledStatement(i int) ILabeledStatementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILabeledStatementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILabeledStatementContext)
}

func (s *SelectionStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SelectionStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SelectionStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CParserVisitor:
		return t.VisitSelectionStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CParser) SelectionStatement() (localctx ISelectionStatementContext) {
	this := p
	_ = this

	localctx = NewSelectionStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 164, CParserRULE_selectionStatement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.SetState(2217)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case CParserIf:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2147)
			p.Match(CParserIf)
		}
		{
			p.SetState(2148)
			p.Match(CParserLeftParen)
		}
		p.SetState(2152)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == CParserSemi || _la == CParserEOS {
			{
				p.SetState(2149)
				p.Eos()
			}

			p.SetState(2154)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(2155)
			p.expression(0)
		}
		p.SetState(2159)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == CParserSemi || _la == CParserEOS {
			{
				p.SetState(2156)
				p.Eos()
			}

			p.SetState(2161)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(2162)
			p.Match(CParserRightParen)
		}
		p.SetState(2166)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 318, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(2163)
					p.Eos()
				}

			}
			p.SetState(2168)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 318, p.GetParserRuleContext())
		}
		{
			p.SetState(2169)
			p.Statement()
		}
		p.SetState(2178)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 320, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(2170)
				p.Match(CParserElse)
			}
			p.SetState(2174)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 319, p.GetParserRuleContext())

			for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
				if _alt == 1 {
					{
						p.SetState(2171)
						p.Eos()
					}

				}
				p.SetState(2176)
				p.GetErrorHandler().Sync(p)
				_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 319, p.GetParserRuleContext())
			}
			{
				p.SetState(2177)
				p.Statement()
			}

		}

	case CParserSwitch:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2180)
			p.Match(CParserSwitch)
		}
		{
			p.SetState(2181)
			p.Match(CParserLeftParen)
		}
		p.SetState(2185)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == CParserSemi || _la == CParserEOS {
			{
				p.SetState(2182)
				p.Eos()
			}

			p.SetState(2187)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(2188)
			p.expression(0)
		}
		p.SetState(2192)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == CParserSemi || _la == CParserEOS {
			{
				p.SetState(2189)
				p.Eos()
			}

			p.SetState(2194)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(2195)
			p.Match(CParserRightParen)
		}
		{
			p.SetState(2196)
			p.Match(CParserLeftBrace)
		}
		p.SetState(2200)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 323, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(2197)
					p.Eos()
				}

			}
			p.SetState(2202)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 323, p.GetParserRuleContext())
		}
		p.SetState(2206)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == CParserCase || _la == CParserDefault {
			{
				p.SetState(2203)
				p.LabeledStatement()
			}

			p.SetState(2208)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		p.SetState(2212)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == CParserSemi || _la == CParserEOS {
			{
				p.SetState(2209)
				p.Eos()
			}

			p.SetState(2214)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(2215)
			p.Match(CParserRightBrace)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IIterationStatementContext is an interface to support dynamic dispatch.
type IIterationStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsIterationStatementContext differentiates from other interfaces.
	IsIterationStatementContext()
}

type IterationStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIterationStatementContext() *IterationStatementContext {
	var p = new(IterationStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CParserRULE_iterationStatement
	return p
}

func (*IterationStatementContext) IsIterationStatementContext() {}

func NewIterationStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IterationStatementContext {
	var p = new(IterationStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CParserRULE_iterationStatement

	return p
}

func (s *IterationStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *IterationStatementContext) While() antlr.TerminalNode {
	return s.GetToken(CParserWhile, 0)
}

func (s *IterationStatementContext) LeftParen() antlr.TerminalNode {
	return s.GetToken(CParserLeftParen, 0)
}

func (s *IterationStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *IterationStatementContext) RightParen() antlr.TerminalNode {
	return s.GetToken(CParserRightParen, 0)
}

func (s *IterationStatementContext) Statement() IStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *IterationStatementContext) AllEos() []IEosContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IEosContext); ok {
			len++
		}
	}

	tst := make([]IEosContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IEosContext); ok {
			tst[i] = t.(IEosContext)
			i++
		}
	}

	return tst
}

func (s *IterationStatementContext) Eos(i int) IEosContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEosContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEosContext)
}

func (s *IterationStatementContext) Semi() antlr.TerminalNode {
	return s.GetToken(CParserSemi, 0)
}

func (s *IterationStatementContext) Do() antlr.TerminalNode {
	return s.GetToken(CParserDo, 0)
}

func (s *IterationStatementContext) For() antlr.TerminalNode {
	return s.GetToken(CParserFor, 0)
}

func (s *IterationStatementContext) ForCondition() IForConditionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IForConditionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IForConditionContext)
}

func (s *IterationStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IterationStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IterationStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CParserVisitor:
		return t.VisitIterationStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CParser) IterationStatement() (localctx IIterationStatementContext) {
	this := p
	_ = this

	localctx = NewIterationStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 166, CParserRULE_iterationStatement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.SetState(2297)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case CParserWhile:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2219)
			p.Match(CParserWhile)
		}
		{
			p.SetState(2220)
			p.Match(CParserLeftParen)
		}
		p.SetState(2224)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == CParserSemi || _la == CParserEOS {
			{
				p.SetState(2221)
				p.Eos()
			}

			p.SetState(2226)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(2227)
			p.expression(0)
		}
		p.SetState(2231)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == CParserSemi || _la == CParserEOS {
			{
				p.SetState(2228)
				p.Eos()
			}

			p.SetState(2233)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(2234)
			p.Match(CParserRightParen)
		}
		p.SetState(2236)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 329, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(2235)
				p.Match(CParserSemi)
			}

		}
		p.SetState(2241)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 330, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(2238)
					p.Eos()
				}

			}
			p.SetState(2243)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 330, p.GetParserRuleContext())
		}
		{
			p.SetState(2244)
			p.Statement()
		}

	case CParserDo:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2246)
			p.Match(CParserDo)
		}
		p.SetState(2250)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 331, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(2247)
					p.Eos()
				}

			}
			p.SetState(2252)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 331, p.GetParserRuleContext())
		}
		{
			p.SetState(2253)
			p.Statement()
		}
		{
			p.SetState(2254)
			p.Match(CParserWhile)
		}
		{
			p.SetState(2255)
			p.Match(CParserLeftParen)
		}
		p.SetState(2259)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == CParserSemi || _la == CParserEOS {
			{
				p.SetState(2256)
				p.Eos()
			}

			p.SetState(2261)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(2262)
			p.expression(0)
		}
		p.SetState(2266)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == CParserSemi || _la == CParserEOS {
			{
				p.SetState(2263)
				p.Eos()
			}

			p.SetState(2268)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(2269)
			p.Match(CParserRightParen)
		}
		p.SetState(2271)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 334, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(2270)
				p.Match(CParserSemi)
			}

		}

	case CParserFor:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2273)
			p.Match(CParserFor)
		}
		{
			p.SetState(2274)
			p.Match(CParserLeftParen)
		}
		p.SetState(2278)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 335, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(2275)
					p.Eos()
				}

			}
			p.SetState(2280)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 335, p.GetParserRuleContext())
		}
		{
			p.SetState(2281)
			p.ForCondition()
		}
		p.SetState(2285)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == CParserSemi || _la == CParserEOS {
			{
				p.SetState(2282)
				p.Eos()
			}

			p.SetState(2287)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(2288)
			p.Match(CParserRightParen)
		}
		p.SetState(2292)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 337, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(2289)
					p.Eos()
				}

			}
			p.SetState(2294)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 337, p.GetParserRuleContext())
		}
		{
			p.SetState(2295)
			p.Statement()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IForConditionContext is an interface to support dynamic dispatch.
type IForConditionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsForConditionContext differentiates from other interfaces.
	IsForConditionContext()
}

type ForConditionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyForConditionContext() *ForConditionContext {
	var p = new(ForConditionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CParserRULE_forCondition
	return p
}

func (*ForConditionContext) IsForConditionContext() {}

func NewForConditionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ForConditionContext {
	var p = new(ForConditionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CParserRULE_forCondition

	return p
}

func (s *ForConditionContext) GetParser() antlr.Parser { return s.parser }

func (s *ForConditionContext) AllSemi() []antlr.TerminalNode {
	return s.GetTokens(CParserSemi)
}

func (s *ForConditionContext) Semi(i int) antlr.TerminalNode {
	return s.GetToken(CParserSemi, i)
}

func (s *ForConditionContext) ForDeclarations() IForDeclarationsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IForDeclarationsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IForDeclarationsContext)
}

func (s *ForConditionContext) AllForExpression() []IForExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IForExpressionContext); ok {
			len++
		}
	}

	tst := make([]IForExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IForExpressionContext); ok {
			tst[i] = t.(IForExpressionContext)
			i++
		}
	}

	return tst
}

func (s *ForConditionContext) ForExpression(i int) IForExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IForExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IForExpressionContext)
}

func (s *ForConditionContext) AssignmentExpressions() IAssignmentExpressionsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAssignmentExpressionsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAssignmentExpressionsContext)
}

func (s *ForConditionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ForConditionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ForConditionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CParserVisitor:
		return t.VisitForCondition(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CParser) ForCondition() (localctx IForConditionContext) {
	this := p
	_ = this

	localctx = NewForConditionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 168, CParserRULE_forCondition)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2303)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 340, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(2299)
			p.ForDeclarations()
		}

	case 2:
		p.SetState(2301)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if (int64((_la-42)) & ^0x3f) == 0 && ((int64(1)<<(_la-42))&8170374148982309025) != 0 {
			{
				p.SetState(2300)
				p.AssignmentExpressions()
			}

		}

	}
	{
		p.SetState(2305)
		p.Match(CParserSemi)
	}
	p.SetState(2307)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if (int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-575660377648630222) != 0 || (int64((_la-66)) & ^0x3f) == 0 && ((int64(1)<<(_la-66))&70308396531829) != 0 {
		{
			p.SetState(2306)
			p.ForExpression()
		}

	}
	{
		p.SetState(2309)
		p.Match(CParserSemi)
	}
	p.SetState(2311)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if (int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-575660377648630222) != 0 || (int64((_la-66)) & ^0x3f) == 0 && ((int64(1)<<(_la-66))&70308396531829) != 0 {
		{
			p.SetState(2310)
			p.ForExpression()
		}

	}

	return localctx
}

// ICoreExpressionsContext is an interface to support dynamic dispatch.
type ICoreExpressionsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCoreExpressionsContext differentiates from other interfaces.
	IsCoreExpressionsContext()
}

type CoreExpressionsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCoreExpressionsContext() *CoreExpressionsContext {
	var p = new(CoreExpressionsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CParserRULE_coreExpressions
	return p
}

func (*CoreExpressionsContext) IsCoreExpressionsContext() {}

func NewCoreExpressionsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CoreExpressionsContext {
	var p = new(CoreExpressionsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CParserRULE_coreExpressions

	return p
}

func (s *CoreExpressionsContext) GetParser() antlr.Parser { return s.parser }

func (s *CoreExpressionsContext) AllCoreExpression() []ICoreExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ICoreExpressionContext); ok {
			len++
		}
	}

	tst := make([]ICoreExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ICoreExpressionContext); ok {
			tst[i] = t.(ICoreExpressionContext)
			i++
		}
	}

	return tst
}

func (s *CoreExpressionsContext) CoreExpression(i int) ICoreExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICoreExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICoreExpressionContext)
}

func (s *CoreExpressionsContext) AllComma() []antlr.TerminalNode {
	return s.GetTokens(CParserComma)
}

func (s *CoreExpressionsContext) Comma(i int) antlr.TerminalNode {
	return s.GetToken(CParserComma, i)
}

func (s *CoreExpressionsContext) AllEos() []IEosContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IEosContext); ok {
			len++
		}
	}

	tst := make([]IEosContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IEosContext); ok {
			tst[i] = t.(IEosContext)
			i++
		}
	}

	return tst
}

func (s *CoreExpressionsContext) Eos(i int) IEosContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEosContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEosContext)
}

func (s *CoreExpressionsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CoreExpressionsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CoreExpressionsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CParserVisitor:
		return t.VisitCoreExpressions(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CParser) CoreExpressions() (localctx ICoreExpressionsContext) {
	this := p
	_ = this

	localctx = NewCoreExpressionsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 170, CParserRULE_coreExpressions)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2313)
		p.CoreExpression()
	}
	p.SetState(2324)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == CParserComma {
		{
			p.SetState(2314)
			p.Match(CParserComma)
		}
		p.SetState(2318)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == CParserSemi || _la == CParserEOS {
			{
				p.SetState(2315)
				p.Eos()
			}

			p.SetState(2320)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(2321)
			p.CoreExpression()
		}

		p.SetState(2326)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IForDeclarationsContext is an interface to support dynamic dispatch.
type IForDeclarationsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsForDeclarationsContext differentiates from other interfaces.
	IsForDeclarationsContext()
}

type ForDeclarationsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyForDeclarationsContext() *ForDeclarationsContext {
	var p = new(ForDeclarationsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CParserRULE_forDeclarations
	return p
}

func (*ForDeclarationsContext) IsForDeclarationsContext() {}

func NewForDeclarationsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ForDeclarationsContext {
	var p = new(ForDeclarationsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CParserRULE_forDeclarations

	return p
}

func (s *ForDeclarationsContext) GetParser() antlr.Parser { return s.parser }

func (s *ForDeclarationsContext) AllForDeclaration() []IForDeclarationContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IForDeclarationContext); ok {
			len++
		}
	}

	tst := make([]IForDeclarationContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IForDeclarationContext); ok {
			tst[i] = t.(IForDeclarationContext)
			i++
		}
	}

	return tst
}

func (s *ForDeclarationsContext) ForDeclaration(i int) IForDeclarationContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IForDeclarationContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IForDeclarationContext)
}

func (s *ForDeclarationsContext) AllComma() []antlr.TerminalNode {
	return s.GetTokens(CParserComma)
}

func (s *ForDeclarationsContext) Comma(i int) antlr.TerminalNode {
	return s.GetToken(CParserComma, i)
}

func (s *ForDeclarationsContext) AllEos() []IEosContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IEosContext); ok {
			len++
		}
	}

	tst := make([]IEosContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IEosContext); ok {
			tst[i] = t.(IEosContext)
			i++
		}
	}

	return tst
}

func (s *ForDeclarationsContext) Eos(i int) IEosContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEosContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEosContext)
}

func (s *ForDeclarationsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ForDeclarationsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ForDeclarationsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CParserVisitor:
		return t.VisitForDeclarations(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CParser) ForDeclarations() (localctx IForDeclarationsContext) {
	this := p
	_ = this

	localctx = NewForDeclarationsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 172, CParserRULE_forDeclarations)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2327)
		p.ForDeclaration()
	}
	p.SetState(2338)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == CParserComma {
		{
			p.SetState(2328)
			p.Match(CParserComma)
		}
		p.SetState(2332)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == CParserSemi || _la == CParserEOS {
			{
				p.SetState(2329)
				p.Eos()
			}

			p.SetState(2334)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(2335)
			p.ForDeclaration()
		}

		p.SetState(2340)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IForDeclarationContext is an interface to support dynamic dispatch.
type IForDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsForDeclarationContext differentiates from other interfaces.
	IsForDeclarationContext()
}

type ForDeclarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyForDeclarationContext() *ForDeclarationContext {
	var p = new(ForDeclarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CParserRULE_forDeclaration
	return p
}

func (*ForDeclarationContext) IsForDeclarationContext() {}

func NewForDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ForDeclarationContext {
	var p = new(ForDeclarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CParserRULE_forDeclaration

	return p
}

func (s *ForDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *ForDeclarationContext) DeclarationSpecifier() IDeclarationSpecifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDeclarationSpecifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDeclarationSpecifierContext)
}

func (s *ForDeclarationContext) InitDeclaratorList() IInitDeclaratorListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInitDeclaratorListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInitDeclaratorListContext)
}

func (s *ForDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ForDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ForDeclarationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CParserVisitor:
		return t.VisitForDeclaration(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CParser) ForDeclaration() (localctx IForDeclarationContext) {
	this := p
	_ = this

	localctx = NewForDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 174, CParserRULE_forDeclaration)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2341)
		p.DeclarationSpecifier()
	}
	p.SetState(2343)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == CParserLeftParen || _la == CParserStar || (int64((_la-70)) & ^0x3f) == 0 && ((int64(1)<<(_la-70))&137438987026433) != 0 {
		{
			p.SetState(2342)
			p.InitDeclaratorList()
		}

	}

	return localctx
}

// IForExpressionContext is an interface to support dynamic dispatch.
type IForExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsForExpressionContext differentiates from other interfaces.
	IsForExpressionContext()
}

type ForExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyForExpressionContext() *ForExpressionContext {
	var p = new(ForExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CParserRULE_forExpression
	return p
}

func (*ForExpressionContext) IsForExpressionContext() {}

func NewForExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ForExpressionContext {
	var p = new(ForExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CParserRULE_forExpression

	return p
}

func (s *ForExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *ForExpressionContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *ForExpressionContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ForExpressionContext) AllComma() []antlr.TerminalNode {
	return s.GetTokens(CParserComma)
}

func (s *ForExpressionContext) Comma(i int) antlr.TerminalNode {
	return s.GetToken(CParserComma, i)
}

func (s *ForExpressionContext) AllEos() []IEosContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IEosContext); ok {
			len++
		}
	}

	tst := make([]IEosContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IEosContext); ok {
			tst[i] = t.(IEosContext)
			i++
		}
	}

	return tst
}

func (s *ForExpressionContext) Eos(i int) IEosContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEosContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEosContext)
}

func (s *ForExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ForExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ForExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CParserVisitor:
		return t.VisitForExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CParser) ForExpression() (localctx IForExpressionContext) {
	this := p
	_ = this

	localctx = NewForExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 176, CParserRULE_forExpression)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2345)
		p.expression(0)
	}
	p.SetState(2356)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == CParserComma {
		{
			p.SetState(2346)
			p.Match(CParserComma)
		}
		p.SetState(2350)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == CParserSemi || _la == CParserEOS {
			{
				p.SetState(2347)
				p.Eos()
			}

			p.SetState(2352)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(2353)
			p.expression(0)
		}

		p.SetState(2358)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IJumpStatementContext is an interface to support dynamic dispatch.
type IJumpStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsJumpStatementContext differentiates from other interfaces.
	IsJumpStatementContext()
}

type JumpStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyJumpStatementContext() *JumpStatementContext {
	var p = new(JumpStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CParserRULE_jumpStatement
	return p
}

func (*JumpStatementContext) IsJumpStatementContext() {}

func NewJumpStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *JumpStatementContext {
	var p = new(JumpStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CParserRULE_jumpStatement

	return p
}

func (s *JumpStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *JumpStatementContext) Semi() antlr.TerminalNode {
	return s.GetToken(CParserSemi, 0)
}

func (s *JumpStatementContext) Goto() antlr.TerminalNode {
	return s.GetToken(CParserGoto, 0)
}

func (s *JumpStatementContext) Identifier() antlr.TerminalNode {
	return s.GetToken(CParserIdentifier, 0)
}

func (s *JumpStatementContext) Continue() antlr.TerminalNode {
	return s.GetToken(CParserContinue, 0)
}

func (s *JumpStatementContext) Break() antlr.TerminalNode {
	return s.GetToken(CParserBreak, 0)
}

func (s *JumpStatementContext) Return() antlr.TerminalNode {
	return s.GetToken(CParserReturn, 0)
}

func (s *JumpStatementContext) AllEos() []IEosContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IEosContext); ok {
			len++
		}
	}

	tst := make([]IEosContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IEosContext); ok {
			tst[i] = t.(IEosContext)
			i++
		}
	}

	return tst
}

func (s *JumpStatementContext) Eos(i int) IEosContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEosContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEosContext)
}

func (s *JumpStatementContext) AllStar() []antlr.TerminalNode {
	return s.GetTokens(CParserStar)
}

func (s *JumpStatementContext) Star(i int) antlr.TerminalNode {
	return s.GetToken(CParserStar, i)
}

func (s *JumpStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *JumpStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *JumpStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *JumpStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CParserVisitor:
		return t.VisitJumpStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CParser) JumpStatement() (localctx IJumpStatementContext) {
	this := p
	_ = this

	localctx = NewJumpStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 178, CParserRULE_jumpStatement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2379)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case CParserGoto:
		{
			p.SetState(2359)
			p.Match(CParserGoto)
		}
		p.SetState(2363)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == CParserStar {
			{
				p.SetState(2360)
				p.Match(CParserStar)
			}

			p.SetState(2365)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(2366)
			p.Match(CParserIdentifier)
		}

	case CParserContinue:
		{
			p.SetState(2367)
			p.Match(CParserContinue)
		}

	case CParserBreak:
		{
			p.SetState(2368)
			p.Match(CParserBreak)
		}

	case CParserReturn:
		{
			p.SetState(2369)
			p.Match(CParserReturn)
		}
		p.SetState(2373)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 351, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(2370)
					p.Eos()
				}

			}
			p.SetState(2375)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 351, p.GetParserRuleContext())
		}
		p.SetState(2377)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if (int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-575660377648630222) != 0 || (int64((_la-66)) & ^0x3f) == 0 && ((int64(1)<<(_la-66))&70308396531829) != 0 {
			{
				p.SetState(2376)
				p.expression(0)
			}

		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}
	p.SetState(2384)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 354, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(2381)
				p.Eos()
			}

		}
		p.SetState(2386)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 354, p.GetParserRuleContext())
	}
	{
		p.SetState(2387)
		p.Match(CParserSemi)
	}

	return localctx
}

// ICompilationUnitContext is an interface to support dynamic dispatch.
type ICompilationUnitContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCompilationUnitContext differentiates from other interfaces.
	IsCompilationUnitContext()
}

type CompilationUnitContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCompilationUnitContext() *CompilationUnitContext {
	var p = new(CompilationUnitContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CParserRULE_compilationUnit
	return p
}

func (*CompilationUnitContext) IsCompilationUnitContext() {}

func NewCompilationUnitContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CompilationUnitContext {
	var p = new(CompilationUnitContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CParserRULE_compilationUnit

	return p
}

func (s *CompilationUnitContext) GetParser() antlr.Parser { return s.parser }

func (s *CompilationUnitContext) EOF() antlr.TerminalNode {
	return s.GetToken(CParserEOF, 0)
}

func (s *CompilationUnitContext) AllWs() []IWsContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IWsContext); ok {
			len++
		}
	}

	tst := make([]IWsContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IWsContext); ok {
			tst[i] = t.(IWsContext)
			i++
		}
	}

	return tst
}

func (s *CompilationUnitContext) Ws(i int) IWsContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWsContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWsContext)
}

func (s *CompilationUnitContext) TranslationUnit() ITranslationUnitContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITranslationUnitContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITranslationUnitContext)
}

func (s *CompilationUnitContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CompilationUnitContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CompilationUnitContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CParserVisitor:
		return t.VisitCompilationUnit(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CParser) CompilationUnit() (localctx ICompilationUnitContext) {
	this := p
	_ = this

	localctx = NewCompilationUnitContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 180, CParserRULE_compilationUnit)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2392)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for (int64((_la-123)) & ^0x3f) == 0 && ((int64(1)<<(_la-123))&11) != 0 {
		{
			p.SetState(2389)
			p.Ws()
		}

		p.SetState(2394)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(2396)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if (int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-9223104100839950798) != 0 || (int64((_la-70)) & ^0x3f) == 0 && ((int64(1)<<(_la-70))&140707473915937) != 0 {
		{
			p.SetState(2395)
			p.TranslationUnit()
		}

	}
	{
		p.SetState(2398)
		p.Match(CParserEOF)
	}

	return localctx
}

// ITranslationUnitContext is an interface to support dynamic dispatch.
type ITranslationUnitContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTranslationUnitContext differentiates from other interfaces.
	IsTranslationUnitContext()
}

type TranslationUnitContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTranslationUnitContext() *TranslationUnitContext {
	var p = new(TranslationUnitContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CParserRULE_translationUnit
	return p
}

func (*TranslationUnitContext) IsTranslationUnitContext() {}

func NewTranslationUnitContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TranslationUnitContext {
	var p = new(TranslationUnitContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CParserRULE_translationUnit

	return p
}

func (s *TranslationUnitContext) GetParser() antlr.Parser { return s.parser }

func (s *TranslationUnitContext) AllExternalDeclaration() []IExternalDeclarationContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExternalDeclarationContext); ok {
			len++
		}
	}

	tst := make([]IExternalDeclarationContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExternalDeclarationContext); ok {
			tst[i] = t.(IExternalDeclarationContext)
			i++
		}
	}

	return tst
}

func (s *TranslationUnitContext) ExternalDeclaration(i int) IExternalDeclarationContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExternalDeclarationContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExternalDeclarationContext)
}

func (s *TranslationUnitContext) AllWs() []IWsContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IWsContext); ok {
			len++
		}
	}

	tst := make([]IWsContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IWsContext); ok {
			tst[i] = t.(IWsContext)
			i++
		}
	}

	return tst
}

func (s *TranslationUnitContext) Ws(i int) IWsContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWsContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWsContext)
}

func (s *TranslationUnitContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TranslationUnitContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TranslationUnitContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CParserVisitor:
		return t.VisitTranslationUnit(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CParser) TranslationUnit() (localctx ITranslationUnitContext) {
	this := p
	_ = this

	localctx = NewTranslationUnitContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 182, CParserRULE_translationUnit)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2407)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = (int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-9223104100839950798) != 0 || (int64((_la-70)) & ^0x3f) == 0 && ((int64(1)<<(_la-70))&140707473915937) != 0 {
		{
			p.SetState(2400)
			p.ExternalDeclaration()
		}
		p.SetState(2404)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for (int64((_la-123)) & ^0x3f) == 0 && ((int64(1)<<(_la-123))&11) != 0 {
			{
				p.SetState(2401)
				p.Ws()
			}

			p.SetState(2406)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

		p.SetState(2409)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IExternalDeclarationContext is an interface to support dynamic dispatch.
type IExternalDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExternalDeclarationContext differentiates from other interfaces.
	IsExternalDeclarationContext()
}

type ExternalDeclarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExternalDeclarationContext() *ExternalDeclarationContext {
	var p = new(ExternalDeclarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CParserRULE_externalDeclaration
	return p
}

func (*ExternalDeclarationContext) IsExternalDeclarationContext() {}

func NewExternalDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExternalDeclarationContext {
	var p = new(ExternalDeclarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CParserRULE_externalDeclaration

	return p
}

func (s *ExternalDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *ExternalDeclarationContext) DeclarationSpecifier() IDeclarationSpecifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDeclarationSpecifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDeclarationSpecifierContext)
}

func (s *ExternalDeclarationContext) FunctionDefinition() IFunctionDefinitionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionDefinitionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionDefinitionContext)
}

func (s *ExternalDeclarationContext) Declaration() IDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDeclarationContext)
}

func (s *ExternalDeclarationContext) MacroCallExpression() IMacroCallExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMacroCallExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMacroCallExpressionContext)
}

func (s *ExternalDeclarationContext) MacroCallStatement() IMacroCallStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMacroCallStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMacroCallStatementContext)
}

func (s *ExternalDeclarationContext) Semi() antlr.TerminalNode {
	return s.GetToken(CParserSemi, 0)
}

func (s *ExternalDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExternalDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExternalDeclarationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CParserVisitor:
		return t.VisitExternalDeclaration(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CParser) ExternalDeclaration() (localctx IExternalDeclarationContext) {
	this := p
	_ = this

	localctx = NewExternalDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 184, CParserRULE_externalDeclaration)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(2417)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 359, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2411)
			p.DeclarationSpecifier()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2412)
			p.FunctionDefinition()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2413)
			p.Declaration()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(2414)
			p.MacroCallExpression()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(2415)
			p.MacroCallStatement()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(2416)
			p.Match(CParserSemi)
		}

	}

	return localctx
}

// IMacroCallExpressionContext is an interface to support dynamic dispatch.
type IMacroCallExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMacroCallExpressionContext differentiates from other interfaces.
	IsMacroCallExpressionContext()
}

type MacroCallExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMacroCallExpressionContext() *MacroCallExpressionContext {
	var p = new(MacroCallExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CParserRULE_macroCallExpression
	return p
}

func (*MacroCallExpressionContext) IsMacroCallExpressionContext() {}

func NewMacroCallExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MacroCallExpressionContext {
	var p = new(MacroCallExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CParserRULE_macroCallExpression

	return p
}

func (s *MacroCallExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *MacroCallExpressionContext) Identifier() antlr.TerminalNode {
	return s.GetToken(CParserIdentifier, 0)
}

func (s *MacroCallExpressionContext) LeftParen() antlr.TerminalNode {
	return s.GetToken(CParserLeftParen, 0)
}

func (s *MacroCallExpressionContext) RightParen() antlr.TerminalNode {
	return s.GetToken(CParserRightParen, 0)
}

func (s *MacroCallExpressionContext) AllEos() []IEosContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IEosContext); ok {
			len++
		}
	}

	tst := make([]IEosContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IEosContext); ok {
			tst[i] = t.(IEosContext)
			i++
		}
	}

	return tst
}

func (s *MacroCallExpressionContext) Eos(i int) IEosContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEosContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEosContext)
}

func (s *MacroCallExpressionContext) MacroArgumentList() IMacroArgumentListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMacroArgumentListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMacroArgumentListContext)
}

func (s *MacroCallExpressionContext) AllPostfixSuffix() []IPostfixSuffixContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPostfixSuffixContext); ok {
			len++
		}
	}

	tst := make([]IPostfixSuffixContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPostfixSuffixContext); ok {
			tst[i] = t.(IPostfixSuffixContext)
			i++
		}
	}

	return tst
}

func (s *MacroCallExpressionContext) PostfixSuffix(i int) IPostfixSuffixContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPostfixSuffixContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPostfixSuffixContext)
}

func (s *MacroCallExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MacroCallExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MacroCallExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CParserVisitor:
		return t.VisitMacroCallExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CParser) MacroCallExpression() (localctx IMacroCallExpressionContext) {
	this := p
	_ = this

	localctx = NewMacroCallExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 186, CParserRULE_macroCallExpression)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2419)
		p.Match(CParserIdentifier)
	}
	{
		p.SetState(2420)
		p.Match(CParserLeftParen)
	}
	p.SetState(2424)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 360, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(2421)
				p.Eos()
			}

		}
		p.SetState(2426)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 360, p.GetParserRuleContext())
	}
	p.SetState(2428)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if (int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-8206824599947726) != 0 || (int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&281233636459007) != 0 {
		{
			p.SetState(2427)
			p.MacroArgumentList()
		}

	}
	p.SetState(2433)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == CParserSemi || _la == CParserEOS {
		{
			p.SetState(2430)
			p.Eos()
		}

		p.SetState(2435)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(2436)
		p.Match(CParserRightParen)
	}
	p.SetState(2440)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 363, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(2437)
				p.PostfixSuffix()
			}

		}
		p.SetState(2442)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 363, p.GetParserRuleContext())
	}

	return localctx
}

// IMacroArgumentListContext is an interface to support dynamic dispatch.
type IMacroArgumentListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMacroArgumentListContext differentiates from other interfaces.
	IsMacroArgumentListContext()
}

type MacroArgumentListContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMacroArgumentListContext() *MacroArgumentListContext {
	var p = new(MacroArgumentListContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CParserRULE_macroArgumentList
	return p
}

func (*MacroArgumentListContext) IsMacroArgumentListContext() {}

func NewMacroArgumentListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MacroArgumentListContext {
	var p = new(MacroArgumentListContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CParserRULE_macroArgumentList

	return p
}

func (s *MacroArgumentListContext) GetParser() antlr.Parser { return s.parser }

func (s *MacroArgumentListContext) AllMacroArgument() []IMacroArgumentContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IMacroArgumentContext); ok {
			len++
		}
	}

	tst := make([]IMacroArgumentContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IMacroArgumentContext); ok {
			tst[i] = t.(IMacroArgumentContext)
			i++
		}
	}

	return tst
}

func (s *MacroArgumentListContext) MacroArgument(i int) IMacroArgumentContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMacroArgumentContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMacroArgumentContext)
}

func (s *MacroArgumentListContext) AllComma() []antlr.TerminalNode {
	return s.GetTokens(CParserComma)
}

func (s *MacroArgumentListContext) Comma(i int) antlr.TerminalNode {
	return s.GetToken(CParserComma, i)
}

func (s *MacroArgumentListContext) AllEos() []IEosContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IEosContext); ok {
			len++
		}
	}

	tst := make([]IEosContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IEosContext); ok {
			tst[i] = t.(IEosContext)
			i++
		}
	}

	return tst
}

func (s *MacroArgumentListContext) Eos(i int) IEosContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEosContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEosContext)
}

func (s *MacroArgumentListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MacroArgumentListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MacroArgumentListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CParserVisitor:
		return t.VisitMacroArgumentList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CParser) MacroArgumentList() (localctx IMacroArgumentListContext) {
	this := p
	_ = this

	localctx = NewMacroArgumentListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 188, CParserRULE_macroArgumentList)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2443)
		p.MacroArgument()
	}
	p.SetState(2454)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == CParserComma {
		{
			p.SetState(2444)
			p.Match(CParserComma)
		}
		p.SetState(2448)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == CParserSemi || _la == CParserEOS {
			{
				p.SetState(2445)
				p.Eos()
			}

			p.SetState(2450)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(2451)
			p.MacroArgument()
		}

		p.SetState(2456)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IFunctionDefinitionContext is an interface to support dynamic dispatch.
type IFunctionDefinitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFunctionDefinitionContext differentiates from other interfaces.
	IsFunctionDefinitionContext()
}

type FunctionDefinitionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunctionDefinitionContext() *FunctionDefinitionContext {
	var p = new(FunctionDefinitionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CParserRULE_functionDefinition
	return p
}

func (*FunctionDefinitionContext) IsFunctionDefinitionContext() {}

func NewFunctionDefinitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FunctionDefinitionContext {
	var p = new(FunctionDefinitionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CParserRULE_functionDefinition

	return p
}

func (s *FunctionDefinitionContext) GetParser() antlr.Parser { return s.parser }

func (s *FunctionDefinitionContext) Declarator() IDeclaratorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDeclaratorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDeclaratorContext)
}

func (s *FunctionDefinitionContext) DeclarationSpecifier() IDeclarationSpecifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDeclarationSpecifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDeclarationSpecifierContext)
}

func (s *FunctionDefinitionContext) DeclarationList() IDeclarationListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDeclarationListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDeclarationListContext)
}

func (s *FunctionDefinitionContext) CompoundStatement() ICompoundStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICompoundStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICompoundStatementContext)
}

func (s *FunctionDefinitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FunctionDefinitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FunctionDefinitionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CParserVisitor:
		return t.VisitFunctionDefinition(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CParser) FunctionDefinition() (localctx IFunctionDefinitionContext) {
	this := p
	_ = this

	localctx = NewFunctionDefinitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 190, CParserRULE_functionDefinition)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2458)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 366, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2457)
			p.DeclarationSpecifier()
		}

	}
	{
		p.SetState(2460)
		p.Declarator()
	}
	p.SetState(2462)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 367, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2461)
			p.DeclarationList()
		}

	}
	p.SetState(2465)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == CParserLeftBrace {
		{
			p.SetState(2464)
			p.CompoundStatement()
		}

	}

	return localctx
}

// IDeclarationListContext is an interface to support dynamic dispatch.
type IDeclarationListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDeclarationListContext differentiates from other interfaces.
	IsDeclarationListContext()
}

type DeclarationListContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDeclarationListContext() *DeclarationListContext {
	var p = new(DeclarationListContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CParserRULE_declarationList
	return p
}

func (*DeclarationListContext) IsDeclarationListContext() {}

func NewDeclarationListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DeclarationListContext {
	var p = new(DeclarationListContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CParserRULE_declarationList

	return p
}

func (s *DeclarationListContext) GetParser() antlr.Parser { return s.parser }

func (s *DeclarationListContext) AllDeclaration() []IDeclarationContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IDeclarationContext); ok {
			len++
		}
	}

	tst := make([]IDeclarationContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IDeclarationContext); ok {
			tst[i] = t.(IDeclarationContext)
			i++
		}
	}

	return tst
}

func (s *DeclarationListContext) Declaration(i int) IDeclarationContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDeclarationContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDeclarationContext)
}

func (s *DeclarationListContext) AllWs() []IWsContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IWsContext); ok {
			len++
		}
	}

	tst := make([]IWsContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IWsContext); ok {
			tst[i] = t.(IWsContext)
			i++
		}
	}

	return tst
}

func (s *DeclarationListContext) Ws(i int) IWsContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWsContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWsContext)
}

func (s *DeclarationListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DeclarationListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DeclarationListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CParserVisitor:
		return t.VisitDeclarationList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CParser) DeclarationList() (localctx IDeclarationListContext) {
	this := p
	_ = this

	localctx = NewDeclarationListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 192, CParserRULE_declarationList)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2474)
	p.GetErrorHandler().Sync(p)
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			{
				p.SetState(2467)
				p.Declaration()
			}
			p.SetState(2471)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 369, p.GetParserRuleContext())

			for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
				if _alt == 1 {
					{
						p.SetState(2468)
						p.Ws()
					}

				}
				p.SetState(2473)
				p.GetErrorHandler().Sync(p)
				_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 369, p.GetParserRuleContext())
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(2476)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 370, p.GetParserRuleContext())
	}

	return localctx
}

// IWsContext is an interface to support dynamic dispatch.
type IWsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsWsContext differentiates from other interfaces.
	IsWsContext()
}

type WsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWsContext() *WsContext {
	var p = new(WsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CParserRULE_ws
	return p
}

func (*WsContext) IsWsContext() {}

func NewWsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WsContext {
	var p = new(WsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CParserRULE_ws

	return p
}

func (s *WsContext) GetParser() antlr.Parser { return s.parser }

func (s *WsContext) AllEOS() []antlr.TerminalNode {
	return s.GetTokens(CParserEOS)
}

func (s *WsContext) EOS(i int) antlr.TerminalNode {
	return s.GetToken(CParserEOS, i)
}

func (s *WsContext) BlockComment() antlr.TerminalNode {
	return s.GetToken(CParserBlockComment, 0)
}

func (s *WsContext) LineComment() antlr.TerminalNode {
	return s.GetToken(CParserLineComment, 0)
}

func (s *WsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CParserVisitor:
		return t.VisitWs(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CParser) Ws() (localctx IWsContext) {
	this := p
	_ = this

	localctx = NewWsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 194, CParserRULE_ws)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.SetState(2485)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case CParserEOS:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(2479)
		p.GetErrorHandler().Sync(p)
		_alt = 1
		for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			switch _alt {
			case 1:
				{
					p.SetState(2478)
					p.Match(CParserEOS)
				}

			default:
				panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			}

			p.SetState(2481)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 371, p.GetParserRuleContext())
		}

	case CParserBlockComment:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2483)
			p.Match(CParserBlockComment)
		}

	case CParserLineComment:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2484)
			p.Match(CParserLineComment)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IEosContext is an interface to support dynamic dispatch.
type IEosContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEosContext differentiates from other interfaces.
	IsEosContext()
}

type EosContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEosContext() *EosContext {
	var p = new(EosContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CParserRULE_eos
	return p
}

func (*EosContext) IsEosContext() {}

func NewEosContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EosContext {
	var p = new(EosContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CParserRULE_eos

	return p
}

func (s *EosContext) GetParser() antlr.Parser { return s.parser }

func (s *EosContext) Semi() antlr.TerminalNode {
	return s.GetToken(CParserSemi, 0)
}

func (s *EosContext) EOS() antlr.TerminalNode {
	return s.GetToken(CParserEOS, 0)
}

func (s *EosContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EosContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EosContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CParserVisitor:
		return t.VisitEos(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CParser) Eos() (localctx IEosContext) {
	this := p
	_ = this

	localctx = NewEosContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 196, CParserRULE_eos)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2487)
		_la = p.GetTokenStream().LA(1)

		if !(_la == CParserSemi || _la == CParserEOS) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

func (p *CParser) Sempred(localctx antlr.RuleContext, ruleIndex, predIndex int) bool {
	switch ruleIndex {
	case 8:
		var t *PostfixSuffixLvalueContext = nil
		if localctx != nil {
			t = localctx.(*PostfixSuffixLvalueContext)
		}
		return p.PostfixSuffixLvalue_Sempred(t, predIndex)

	case 20:
		var t *ExpressionContext = nil
		if localctx != nil {
			t = localctx.(*ExpressionContext)
		}
		return p.Expression_Sempred(t, predIndex)

	case 60:
		var t *TypeNameContext = nil
		if localctx != nil {
			t = localctx.(*TypeNameContext)
		}
		return p.TypeName_Sempred(t, predIndex)

	default:
		panic("No predicate with index: " + fmt.Sprint(ruleIndex))
	}
}

func (p *CParser) PostfixSuffixLvalue_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	this := p
	_ = this

	switch predIndex {
	case 0:
		return p.Precpred(p.GetParserRuleContext(), 2)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *CParser) Expression_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	this := p
	_ = this

	switch predIndex {
	case 1:
		return p.Precpred(p.GetParserRuleContext(), 10)

	case 2:
		return p.Precpred(p.GetParserRuleContext(), 9)

	case 3:
		return p.Precpred(p.GetParserRuleContext(), 8)

	case 4:
		return p.Precpred(p.GetParserRuleContext(), 7)

	case 5:
		return p.Precpred(p.GetParserRuleContext(), 6)

	case 6:
		return p.Precpred(p.GetParserRuleContext(), 4)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *CParser) TypeName_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	this := p
	_ = this

	switch predIndex {
	case 7:
		return p.Precpred(p.GetParserRuleContext(), 1)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}
