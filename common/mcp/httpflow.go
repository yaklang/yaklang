package mcp

import (
	"context"
	"strconv"
	"strings"
	"time"

	"github.com/go-viper/mapstructure/v2"
	"github.com/jinzhu/gorm"
	"github.com/yaklang/yaklang/common/mcp/mcp-go/mcp"
	"github.com/yaklang/yaklang/common/mcp/mcp-go/server"
	"github.com/yaklang/yaklang/common/schema"
	"github.com/yaklang/yaklang/common/utils"
	"github.com/yaklang/yaklang/common/yakgrpc/ypb"
)

var filterHTTPFlowToolOptions = []mcp.ToolOption{
	mcp.WithPaging("pagination",
		[]string{"id", "created_at", "updated_at", "deleted_at", "hidden_index", "no_fix_content_length", "hash", "is_http_s", "url", "path", "method", "body_length", "content_type", "status_code", "source_type", "request", "response", "duration", "get_params_total", "post_params_total", "cookie_params_total", "ip_address", "remote_addr", "ip_integer", "tags", "payload", "is_websocket", "websocket_hash", "runtime_id", "from_plugin", "process_name", "is_too_large_response", "too_large_response_header_file", "too_large_response_body_file", "upload_online"},
		mcp.Description("Pagination settings for the query"),
	),
	mcp.WithString("sourceType",
		mcp.Description("Source type of the HTTP flow"),
	),
	mcp.WithString("methods",
		mcp.Description("HTTP methods to filter"),
	),
	mcp.WithString("searchURL",
		mcp.Description("URL to search for"),
	),
	mcp.WithString("statusCode",
		mcp.Description("HTTP status code to filter"),
	),
	mcp.WithBool("haveBody",
		mcp.Description("Whether the HTTP flow has a body"),
	),
	mcp.WithString("searchContentType",
		mcp.Description("Content type to search for"),
	),
	mcp.WithNumber("beforeUpdatedAt",
		mcp.Description("Filter flows updated before this timestamp"),
	),
	mcp.WithNumber("afterUpdatedAt",
		mcp.Description("Filter flows updated after this timestamp"),
	),
	mcp.WithNumber("afterId",
		mcp.Description("Filter flows with ID greater than this value"),
	),
	mcp.WithNumber("beforeId",
		mcp.Description("Filter flows with ID less than this value"),
	),
	mcp.WithString("keyword",
		mcp.Description("Keyword to search for in the flow"),
	),
	mcp.WithBool("onlyWebsocket",
		mcp.Description("Filter only websocket flows"),
	),
	mcp.WithStringArray("includeInUrl",
		mcp.Description("Include flows with these URLs"),
	),
	mcp.WithStringArray("excludeInUrl",
		mcp.Description("Exclude flows with these URLs"),
	),
	mcp.WithStringArray("includeInIP",
		mcp.Description("Include flows with these IPs"),
	),
	mcp.WithStringArray("excludeInIP",
		mcp.Description("Exclude flows with these IPs"),
	),
	mcp.WithStringArray("tags",
		mcp.Description("Filter flows by these tags"),
	),
	mcp.WithNumber("afterBodyLength",
		mcp.Description("Filter flows with body length greater than this value"),
	),
	mcp.WithNumber("beforeBodyLength",
		mcp.Description("Filter flows with body length less than this value"),
	),
	mcp.WithString("isWebsocket",
		mcp.Description("Filter flows by websocket status"),
	),
	mcp.WithString("fromPlugin",
		mcp.Description("Filter flows generated by this plugin"),
	),
	mcp.WithBool("full",
		mcp.Description("Whether to return full flow data"),
	),
	mcp.WithStringArray("includePath",
		mcp.Description("Include flows with these paths"),
	),
	mcp.WithStringArray("excludePath",
		mcp.Description("Exclude flows with these paths"),
	),
	mcp.WithStringArray("includeSuffix",
		mcp.Description("Include flows with these suffixes"),
	),
	mcp.WithStringArray("excludeSuffix",
		mcp.Description("Exclude flows with these suffixes"),
	),
	mcp.WithStringArray("excludeContentType",
		mcp.Description("Exclude flows with these content types"),
	),
	mcp.WithBool("withPayload",
		mcp.Description("Whether to include payload in the flow"),
	),
	mcp.WithStringArray("processName",
		mcp.Description("Filter flows by process name"),
	),
	mcp.WithStringArray("excludeKeywords",
		mcp.Description("Exclude flows containing these keywords"),
	),
	mcp.WithString("keywordType",
		mcp.Description("Type of keyword to search for (empty means all, or response, or request)"),
		mcp.Enum("", "response", "request"),
	),
}

func init() {
	AddGlobalToolSet("httpflow",
		WithTool(mcp.NewTool("query_http_flow",
			append([]mcp.ToolOption{
				mcp.WithDescription("Query HTTP flow data with flexible filters"),
			}, filterYakScriptToolOptions...)...,
		), handleQueryHTTPFlows),
		WithTool(mcp.NewTool(string("set_tag_for_http_flow"),
			mcp.WithDescription("Sets tags for an HTTP flow"),
			mcp.WithNumber("id",
				mcp.Description("The ID of the HTTP flow, maybe use query_http_flow to get the ID of the flow to be tagged"),
				mcp.Required(),
			),
			mcp.WithStringArray("tags",
				mcp.Description("The tags to be set for the HTTP flow"),
				mcp.Required(),
			),
		), handleSetTagForHTTPFlow),
		WithTool(mcp.NewTool(string("delete_http_flow"),
			mcp.WithDescription("Delete HTTP flow with flexible filters"),
			mcp.WithBool("deleteAll",
				mcp.Description("Delete all flows")),
			mcp.WithStruct("filter",
				[]mcp.PropertyOption{
					mcp.Description("Filter that same with query_http_flow arguments"),
				},
				filterHTTPFlowToolOptions...,
			),
		), handleDeleteHTTPFlows),
	)
}

func ypbHTTPFlowToFriendlyHTTPFlow(f *ypb.HTTPFlow) *schema.HTTPFlow {
	flow := &schema.HTTPFlow{
		Model: gorm.Model{
			ID:        uint(f.Id),
			CreatedAt: time.Unix(f.CreatedAt, 0),
			UpdatedAt: time.Unix(f.UpdatedAt, 0),
		},
		NoFixContentLength:         f.NoFixContentLength,
		IsHTTPS:                    f.IsHTTPS,
		Url:                        f.Url,
		Path:                       f.Path,
		Method:                     f.Method,
		BodyLength:                 f.BodyLength,
		ContentType:                f.ContentType,
		StatusCode:                 f.StatusCode,
		SourceType:                 f.SourceType,
		Duration:                   f.DurationMs * int64(time.Millisecond),
		GetParamsTotal:             int(f.GetParamsTotal),
		PostParamsTotal:            int(f.PostParamsTotal),
		CookieParamsTotal:          int(f.CookieParamsTotal),
		IPAddress:                  f.IPAddress,
		RemoteAddr:                 f.HostPort,
		Tags:                       f.Tags,
		Payload:                    strings.Join(f.Payloads, ","),
		IsWebsocket:                f.IsWebsocket,
		WebsocketHash:              f.WebsocketHash,
		FromPlugin:                 f.FromPlugin,
		IsTooLargeResponse:         f.IsTooLargeResponse,
		TooLargeResponseBodyFile:   string(f.TooLargeResponseBodyFile),
		TooLargeResponseHeaderFile: string(f.TooLargeResponseHeaderFile),
	}

	flow.Response = strconv.Quote(string(f.Response))
	flow.Request = strconv.Quote(string(f.Request))

	return flow
}

func handleQueryHTTPFlows(s *MCPServer) server.ToolHandlerFunc {
	return func(
		ctx context.Context,
		request mcp.CallToolRequest,
	) (*mcp.CallToolResult, error) {
		var req ypb.QueryHTTPFlowRequest
		err := mapstructure.Decode(request.Params.Arguments, &req)
		if err != nil {
			return nil, utils.Wrap(err, "invalid argument")
		}
		rsp, err := s.grpcClient.QueryHTTPFlows(ctx, &req)
		if err != nil {
			return nil, utils.Wrap(err, "failed to query HTTPFlows")
		}
		results := make([]*schema.HTTPFlow, 0, len(rsp.Data))
		for _, flow := range rsp.Data {
			if flow == nil {
				continue
			}
			results = append(results, ypbHTTPFlowToFriendlyHTTPFlow(flow))
		}
		return NewCommonCallToolResult(results)
	}
}

func handleSetTagForHTTPFlow(s *MCPServer) server.ToolHandlerFunc {
	return func(
		ctx context.Context,
		request mcp.CallToolRequest,
	) (*mcp.CallToolResult, error) {
		var req ypb.SetTagForHTTPFlowRequest
		err := mapstructure.Decode(request.Params.Arguments, &req)
		if err != nil {
			return nil, utils.Wrap(err, "invalid argument")
		}
		_, err = s.grpcClient.SetTagForHTTPFlow(ctx, &req)
		if err != nil {
			return nil, utils.Wrap(err, "failed to set tag for httpflow(s)")
		}
		return NewCommonCallToolResult("set tag for httpflow(s) success")
	}
}

func handleDeleteHTTPFlows(s *MCPServer) server.ToolHandlerFunc {
	return func(
		ctx context.Context,
		request mcp.CallToolRequest,
	) (*mcp.CallToolResult, error) {
		var req ypb.DeleteHTTPFlowRequest
		err := mapstructure.Decode(request.Params.Arguments, &req)
		if err != nil {
			return nil, utils.Wrap(err, "invalid argument")
		}
		_, err = s.grpcClient.DeleteHTTPFlows(ctx, &req)
		if err != nil {
			return nil, utils.Wrap(err, "failed to delete httpflow(s)")
		}
		return NewCommonCallToolResult("delete httpflow(s) success")
	}
}
