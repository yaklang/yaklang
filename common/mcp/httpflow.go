package mcp

import (
	"context"
	"strconv"
	"strings"
	"time"

	"github.com/go-viper/mapstructure/v2"
	"github.com/jinzhu/gorm"
	"github.com/yaklang/yaklang/common/mcp/mcp-go/mcp"
	"github.com/yaklang/yaklang/common/schema"
	"github.com/yaklang/yaklang/common/utils"
	"github.com/yaklang/yaklang/common/yakgrpc/ypb"
)

func (s *MCPServer) registerHTTPFlowTool() {
	s.server.AddTool(mcp.NewTool("query_http_flow",
		mcp.WithDescription("Query HTTP flow data with flexible filters"),
		mcp.WithPaging("pagination",
			[]string{"id", "created_at", "updated_at", "deleted_at", "hidden_index", "no_fix_content_length", "hash", "is_http_s", "url", "path", "method", "body_length", "content_type", "status_code", "source_type", "request", "response", "duration", "get_params_total", "post_params_total", "cookie_params_total", "ip_address", "remote_addr", "ip_integer", "tags", "payload", "is_websocket", "websocket_hash", "runtime_id", "from_plugin", "process_name", "is_too_large_response", "too_large_response_header_file", "too_large_response_body_file", "upload_online"},
			mcp.Description("Pagination settings for the query"),
		),
		mcp.WithString("sourceType",
			mcp.Description("Source type of the HTTP flow"),
		),
		mcp.WithString("methods",
			mcp.Description("HTTP methods to filter"),
		),
		mcp.WithString("searchURL",
			mcp.Description("URL to search for"),
		),
		mcp.WithString("statusCode",
			mcp.Description("HTTP status code to filter"),
		),
		mcp.WithBool("haveBody",
			mcp.Description("Whether the HTTP flow has a body"),
		),
		mcp.WithString("searchContentType",
			mcp.Description("Content type to search for"),
		),
		mcp.WithNumber("beforeUpdatedAt",
			mcp.Description("Filter flows updated before this timestamp"),
		),
		mcp.WithNumber("afterUpdatedAt",
			mcp.Description("Filter flows updated after this timestamp"),
		),
		mcp.WithNumber("afterId",
			mcp.Description("Filter flows with ID greater than this value"),
		),
		mcp.WithNumber("beforeId",
			mcp.Description("Filter flows with ID less than this value"),
		),
		mcp.WithString("keyword",
			mcp.Description("Keyword to search for in the flow"),
		),
		mcp.WithBool("onlyWebsocket",
			mcp.Description("Filter only websocket flows"),
		),
		mcp.WithStringArray("includeInUrl",
			mcp.Description("Include flows with these URLs"),
		),
		mcp.WithStringArray("excludeInUrl",
			mcp.Description("Exclude flows with these URLs"),
		),
		mcp.WithStringArray("includeInIP",
			mcp.Description("Include flows with these IPs"),
		),
		mcp.WithStringArray("excludeInIP",
			mcp.Description("Exclude flows with these IPs"),
		),
		mcp.WithStringArray("tags",
			mcp.Description("Filter flows by these tags"),
		),
		mcp.WithNumber("afterBodyLength",
			mcp.Description("Filter flows with body length greater than this value"),
		),
		mcp.WithNumber("beforeBodyLength",
			mcp.Description("Filter flows with body length less than this value"),
		),
		mcp.WithString("isWebsocket",
			mcp.Description("Filter flows by websocket status"),
		),
		mcp.WithString("fromPlugin",
			mcp.Description("Filter flows generated by this plugin"),
		),
		mcp.WithBool("full",
			mcp.Description("Whether to return full flow data"),
		),
		mcp.WithStringArray("includePath",
			mcp.Description("Include flows with these paths"),
		),
		mcp.WithStringArray("excludePath",
			mcp.Description("Exclude flows with these paths"),
		),
		mcp.WithStringArray("includeSuffix",
			mcp.Description("Include flows with these suffixes"),
		),
		mcp.WithStringArray("excludeSuffix",
			mcp.Description("Exclude flows with these suffixes"),
		),
		mcp.WithStringArray("excludeContentType",
			mcp.Description("Exclude flows with these content types"),
		),
		mcp.WithBool("withPayload",
			mcp.Description("Whether to include payload in the flow"),
		),
		mcp.WithStringArray("processName",
			mcp.Description("Filter flows by process name"),
		),
		mcp.WithStringArray("excludeKeywords",
			mcp.Description("Exclude flows containing these keywords"),
		),
		mcp.WithString("keywordType",
			mcp.Description("Type of keyword to search for (empty means all, or response, or request)"),
			mcp.Enum("", "response", "request"),
		),
	), s.handleQueryHTTPFlows)
}

func ypbHTTPFlowToFriendlyHTTPFlow(f *ypb.HTTPFlow) *schema.HTTPFlow {
	flow := &schema.HTTPFlow{
		Model: gorm.Model{
			ID:        uint(f.Id),
			CreatedAt: time.Unix(f.CreatedAt, 0),
			UpdatedAt: time.Unix(f.UpdatedAt, 0),
		},
		NoFixContentLength:         f.NoFixContentLength,
		IsHTTPS:                    f.IsHTTPS,
		Url:                        f.Url,
		Path:                       f.Path,
		Method:                     f.Method,
		BodyLength:                 f.BodyLength,
		ContentType:                f.ContentType,
		StatusCode:                 f.StatusCode,
		SourceType:                 f.SourceType,
		Duration:                   f.DurationMs * int64(time.Millisecond),
		GetParamsTotal:             int(f.GetParamsTotal),
		PostParamsTotal:            int(f.PostParamsTotal),
		CookieParamsTotal:          int(f.CookieParamsTotal),
		IPAddress:                  f.IPAddress,
		RemoteAddr:                 f.HostPort,
		Tags:                       f.Tags,
		Payload:                    strings.Join(f.Payloads, ","),
		IsWebsocket:                f.IsWebsocket,
		WebsocketHash:              f.WebsocketHash,
		FromPlugin:                 f.FromPlugin,
		IsTooLargeResponse:         f.IsTooLargeResponse,
		TooLargeResponseBodyFile:   string(f.TooLargeResponseBodyFile),
		TooLargeResponseHeaderFile: string(f.TooLargeResponseHeaderFile),
	}

	flow.Response = strconv.Quote(string(f.Response))
	flow.Request = strconv.Quote(string(f.Request))

	return flow
}

func (s *MCPServer) handleQueryHTTPFlows(
	ctx context.Context,
	request mcp.CallToolRequest,
) (*mcp.CallToolResult, error) {
	var req ypb.QueryHTTPFlowRequest
	err := mapstructure.Decode(request.Params.Arguments, &req)
	if err != nil {
		return nil, utils.Wrap(err, "invalid argument")
	}
	rsp, err := s.grpcClient.QueryHTTPFlows(ctx, &req)
	if err != nil {
		return nil, utils.Wrap(err, "failed to query HTTPFlows")
	}
	results := make([]*schema.HTTPFlow, 0, len(rsp.Data))
	for _, flow := range rsp.Data {
		if flow == nil {
			continue
		}
		results = append(results, ypbHTTPFlowToFriendlyHTTPFlow(flow))
	}
	return NewCommonCallToolResult(results)
}
