name: Diff-Code-Check
on:
  workflow_run:
    workflows: [ "Essential Tests" ]
    types:
      - completed
  pull_request:
    branches: [main]
    types: [ opened, synchronize, reopened ]
    paths:
      - "go.mod"
      - ".github/workflows/diff-code-check.yml"
      - ".github/workflows/security-comment-simple.yml"
      - ".github/actions/security-commenter/action.yml"
      - "common/ssa_bootstrapping/ci_rule/**"
      - "common/syntaxflow/sfbuildin/buildin/golang/**"
      - "scripts/ssa-risk-tools/**"

concurrency:
  group: ${{ github.workflow }}-${{ github.event.pull_request.number || github.ref }}
  cancel-in-progress: true

jobs:
  setup:
    runs-on: ubuntu-22.04
    if: ${{ (github.event_name == 'workflow_run' && github.event.workflow_run.conclusion == 'success') || (github.event_name == 'pull_request') }}
    permissions:
      contents: read
      pull-requests: write
      issues: write
      actions: read
    steps:
      - name: Initialize workflow context
        id: init
        run: | 
          if [ "${{ github.event_name }}" == "workflow_run" ]; then
            HEAD_SHA="${{ github.event.workflow_run.head_sha }}"
            if [ "${{ github.event.workflow_run.pull_requests }}" != "[]" ] && [ "${{ github.event.workflow_run.pull_requests }}" != "null" ]; then
              PR_NUMBER="${{ github.event.workflow_run.pull_requests[0].number }}"
            else
              PR_NUMBER="0"
            fi
          elif [ "${{ github.event_name }}" == "pull_request" ]; then
            HEAD_SHA="${{ github.event.pull_request.head.sha }}"
            PR_NUMBER="${{ github.event.pull_request.number }}"
          else
            echo "::error::Unsupported event type: ${{ github.event_name }}"
            exit 1
          fi
          
          echo "HEAD_SHA=$HEAD_SHA" >> $GITHUB_ENV
          echo "PR_NUMBER=$PR_NUMBER" >> $GITHUB_ENV

      - name: Set Cache Key
        id: cache_key
        run: |
          CACHE_SHA="${{ env.HEAD_SHA }}"
          echo "sha=$CACHE_SHA" >> $GITHUB_OUTPUT
          echo "Cache key will be: go-$CACHE_SHA"

      - name: Security validation and PR checks
        id: validate
        run: |
          if [ "${{ env.PR_NUMBER }}" == "0" ] || [ "${{ env.PR_NUMBER }}" == "" ]; then
            echo "should_skip=false" >> $GITHUB_OUTPUT
            echo "skip_reason=none" >> $GITHUB_OUTPUT
            exit 0
          fi
          
            PR_RESPONSE=$(curl -s -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
              -H "Accept: application/vnd.github.v3+json" \
              "https://api.github.com/repos/${{ github.repository }}/pulls/${{ env.PR_NUMBER }}")
            
            HEAD_REPO=$(echo "$PR_RESPONSE" | jq -r '.head.repo.full_name // "unknown"')
            BASE_REPO=$(echo "$PR_RESPONSE" | jq -r '.base.repo.full_name // "unknown"')
            PR_STATE=$(echo "$PR_RESPONSE" | jq -r '.state // "unknown"')
            PR_HEAD_SHA=$(echo "$PR_RESPONSE" | jq -r '.head.sha // "unknown"')
          
          if [ "$HEAD_REPO" != "$BASE_REPO" ] && [ "$HEAD_REPO" != "unknown" ] && [ "$BASE_REPO" != "unknown" ]; then
            echo "::error::🚫 SECURITY BLOCK: Fork PR detected (Base: $BASE_REPO, Head: $HEAD_REPO)"
            echo "::error::This workflow only runs for PRs from the same repository."
            exit 1
          fi
          
            if [ "$PR_STATE" != "open" ]; then
              echo "should_skip=true" >> $GITHUB_OUTPUT
              echo "skip_reason=pr_not_open" >> $GITHUB_OUTPUT
              exit 0
            fi
            
            if [ "$PR_HEAD_SHA" != "${{ env.HEAD_SHA }}" ]; then
              echo "should_skip=true" >> $GITHUB_OUTPUT
              echo "skip_reason=sha_mismatch" >> $GITHUB_OUTPUT
              exit 0
            fi
            
            echo "should_skip=false" >> $GITHUB_OUTPUT
            echo "skip_reason=none" >> $GITHUB_OUTPUT

      - name: Skip Workflow (Validation Failed)
        if: steps.validate.outputs.should_skip == 'true'
        run: |
          echo "Skipped: ${{ steps.validate.outputs.skip_reason }}"

      - name: Restore cached YakLang project
        if: steps.validate.outputs.should_skip != 'true'
        uses: actions/cache@v3
        id: cache-project
        with:
          path: |
            ~/yakit-projects
            ~/go/pkg/mod
          key: go-${{ steps.cache_key.outputs.sha }}
          restore-keys: |
            go-

      - name: Clean problematic directories
        if: steps.validate.outputs.should_skip != 'true'
        run: |
          if [ -d "vendor" ]; then
            sudo chmod -R +w vendor/ 2>/dev/null || true
            sudo rm -rf vendor/ || rm -rf vendor/ || true
          fi
          if [ -d ".git/modules" ]; then
            sudo chmod -R +w .git/modules/ 2>/dev/null || true
          fi

      - name: Check out code into the Go module directory
        if: steps.validate.outputs.should_skip != 'true' && steps.cache-project.outputs.cache-hit != 'true'
        uses: actions/checkout@v3
        with:
          ref: ${{ env.HEAD_SHA }}
          fetch-depth: 0
          clean: false

      - name: Fetch Main And Reset Main
        if: steps.validate.outputs.should_skip != 'true' && steps.cache-project.outputs.cache-hit != 'true'
        run: |
          git fetch --all
          git checkout main
          git reset --hard origin/main

      - name: Set up Go 1.x
        if: steps.validate.outputs.should_skip != 'true' && steps.cache-project.outputs.cache-hit != 'true'
        uses: actions/setup-go@v5
        with:
          go-version-file: "./go.mod"
        id: go

      - name: Init Module
        if: steps.validate.outputs.should_skip != 'true' && steps.cache-project.outputs.cache-hit != 'true'
        run: |
          go mod tidy && go work vendor
          
          LIBPCAP_PATH=$(go env GOPATH)/pkg/mod/$(go list -m github.com/yaklang/pcap | sed 's/ /@/')/libpcap
          
          if [ -d "$LIBPCAP_PATH" ]; then
            chmod -R +r "$LIBPCAP_PATH" 2>/dev/null || true
            mkdir -p ./vendor/github.com/yaklang/pcap/
            cp -r "$LIBPCAP_PATH" ./vendor/github.com/yaklang/pcap/
            chmod -R +w ./vendor/github.com/yaklang/pcap/libpcap 2>/dev/null || true
          fi
          
          tree ./vendor || ls -la ./vendor

      - name: Init Project
        if: steps.validate.outputs.should_skip != 'true' && steps.cache-project.outputs.cache-hit != 'true'
        env: 
          SKIP_SYNC_EMBED_RULE_IN_GITHUB: "true"
        run: |
          go build common/yak/cmd/yak.go 
          ./yak --help

      - name: Generate Prog
        if: steps.validate.outputs.should_skip != 'true'
        run: |
          git checkout ${{ env.HEAD_SHA }}
          ./yak sf-import --file common/ssa_bootstrapping/ci_rule/ --format raw
          MERGE_BASE=$(git merge-base main ${{ env.HEAD_SHA }})
          ./yak gitefs --start $MERGE_BASE --end ${{ env.HEAD_SHA }} --output ./fs.zip 

      - name: Upload fs.zip
        if: steps.validate.outputs.should_skip != 'true'
        uses: actions/upload-artifact@v4
        with:
          name: fs.zip
          path: fs.zip

      - name: Check With SyntaxFlow
        if: steps.validate.outputs.should_skip != 'true'
        id: scan
        run: |
          ./yak code-scan -t ./fs.zip -l golang --rule-keyword golang --format irify -o risk --memory --log-level debug --exclude-file **/vendor/**,vendor/**,**/classes/**,**/target/**,**include/**,**caches/**,**cache/**,**tmp/**,**alipay/**,**includes/**,**temp/**,**zh_cn/**,**zh_en/**,**plugins/**,**PHPExcel/**,*.pb.go
          NUM=$(cat risk.json | jq .RiskNums)
          echo "risk_count=$NUM" >> $GITHUB_OUTPUT
          if [ $NUM == 0 ]; then
            echo "scan_result=success" >> $GITHUB_OUTPUT
          else
            echo "scan_result=failure" >> $GITHUB_OUTPUT
          fi
        # Get-Content risk.json -Encoding UTF8 | jq .RiskNums

      - name: Setup Python environment
        if: steps.validate.outputs.should_skip != 'true'
        uses: actions/setup-python@v4
        with:
          python-version: '3.9'
          cache: 'pip'

      - name: Install Python dependencies
        if: steps.validate.outputs.should_skip != 'true'
        run: |
          pip install --quiet --upgrade pip
          pip install --quiet pyyaml requests

      - name: Verify GitHub token permissions
        if: steps.validate.outputs.should_skip != 'true' && env.PR_NUMBER != '0'
        id: test_token
        run: |
          HTTP_CODE=$(curl -s -o /dev/null -w "%{http_code}" \
            -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
            -H "Accept: application/vnd.github.v3+json" \
            "https://api.github.com/repos/${{ github.repository }}/pulls/${{ env.PR_NUMBER }}")
          
          if [ "$HTTP_CODE" = "200" ]; then
            echo "has_permissions=true" >> $GITHUB_OUTPUT
          else
            echo "has_permissions=false" >> $GITHUB_OUTPUT
          fi

      - name: Skip Security Comment (Insufficient Permissions)
        if: steps.validate.outputs.should_skip != 'true' && steps.scan.outputs.scan_result == 'failure' && steps.test_token.outputs.has_permissions == 'false'
        run: |
          echo "::warning::Insufficient token permissions, skipping security comments"
      
      - name: Generate security report
        if: steps.validate.outputs.should_skip != 'true' && steps.scan.outputs.scan_result == 'failure'
        run: |
          rm -rf results
          
          if [ ! -f "./risk.json" ]; then
            echo "::error::Risk file not found: ./risk.json"
            exit 1
          fi
          
          if [ ! -f "./scripts/ssa-risk-tools/extract-risks-deserializer.awk" ]; then
            echo "::error::AWK script not found: ./scripts/ssa-risk-tools/extract-risks-deserializer.awk"
            exit 1
          fi
          
          awk -f scripts/ssa-risk-tools/extract-risks-deserializer.awk ./risk.json
          
          if [ -d "results" ]; then
            HIGH_CRITICAL_COUNT=0
            if [ -f "results/scan_summary.txt" ]; then
              if ls results/risk_details_*.txt 1> /dev/null 2>&1; then
                COUNT_RESULT=$(grep -c "严重程度: high\|严重程度: critical" results/risk_details_*.txt 2>/dev/null || echo "0")
                if [[ "$COUNT_RESULT" =~ ^[0-9]+$ ]]; then
                  HIGH_CRITICAL_COUNT=$COUNT_RESULT
                else
                  HIGH_CRITICAL_COUNT=0
                fi
              else
                HIGH_CRITICAL_COUNT=0
              fi
            else
              HIGH_CRITICAL_COUNT=0
            fi
            echo "HIGH_CRITICAL_COUNT=$HIGH_CRITICAL_COUNT" >> $GITHUB_OUTPUT
          else
            echo "::error::Failed to generate results directory"
            exit 1
          fi

      - name: Clean up old security comments (No vulnerabilities found)
        if: steps.validate.outputs.should_skip != 'true' && steps.scan.outputs.scan_result == 'success' && steps.test_token.outputs.has_permissions == 'true' && env.PR_NUMBER != '' && env.PR_NUMBER != '0'
        uses: actions/github-script@v6
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            try {
              // 定义安全扫描评论的唯一标识符
              const commentIdentifier = '<!-- security-scan-report:main -->';
              
              // 查询所有评论
              const comments = await github.rest.issues.listComments({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: Number(process.env.PR_NUMBER),
                per_page: 100
              });
              
              let deletedCount = 0;
              
              // 删除所有机器人自己的安全相关评论
              for (const comment of comments.data) {
                const isBotComment = comment.user.type === 'Bot' || 
                                   comment.user.login === 'github-actions[bot]' ||
                                   comment.user.login.endsWith('[bot]') ||
                                   comment.body.includes('此评论由代码安全检查工具自动生成') ||
                                   comment.body.includes('此报告由代码安全扫描工具自动生成');
                
                if (isBotComment && (comment.body.includes(commentIdentifier) || comment.body.includes('<!-- security-line-comment:'))) {
                  await github.rest.issues.deleteComment({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    comment_id: comment.id
                  });
                  deletedCount++;
                  console.log(`Cleaned up old security comment: ${comment.id}`);
                }
              }
              
              if (deletedCount > 0) {
                console.log(`Cleaned up ${deletedCount} old security comments (no vulnerabilities found)`);
              } else {
                console.log('No old security comments found to clean up');
              }
              
            } catch (error) {
              console.error('Failed to clean up old security comments:', error);
              // 不抛出错误，避免影响主流程
            }

      - name: Comment PR with security findings
        if: steps.validate.outputs.should_skip != 'true' && steps.scan.outputs.scan_result == 'failure' && steps.test_token.outputs.has_permissions == 'true' && env.PR_NUMBER != '' && env.PR_NUMBER != '0'
        uses: actions/github-script@v6
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const fs = require('fs');
            
            try {
              // 从文件读取报告内容，避免 JavaScript 关键字冲突
              const path = require('path');
              const resultsDir = path.join(process.cwd(), 'results');
              
              let report = '';
              const summaryFile = path.join(resultsDir, 'scan_summary.txt');
              if (fs.existsSync(summaryFile)) {
                report = fs.readFileSync(summaryFile, 'utf8');
              } else {
                report = '报告文件未找到';
              }
              
              // 定义安全扫描评论的唯一标识符
              const commentIdentifier = '<!-- security-scan-report:main -->';
              
              // 使用更高效的查询方式：只查询机器人自己的评论
              const comments = await github.rest.issues.listComments({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: Number(process.env.PR_NUMBER),
                per_page: 100
              });
              
              // 查找现有的安全扫描主报告评论（只查找机器人自己的评论）
              let existingMainComment = null;
              for (const comment of comments.data) {
                // 只处理机器人自己的评论，避免误操作其他人的评论
                if (comment.user.type === 'Bot' && comment.body.includes(commentIdentifier)) {
                  existingMainComment = comment;
                  break;
                }
              }
              
              // 在报告内容中添加标识符
              const reportWithIdentifier = commentIdentifier + '\n\n' + report;
              
              if (existingMainComment) {
                // 更新现有主报告评论
                await github.rest.issues.updateComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  comment_id: existingMainComment.id,
                  body: reportWithIdentifier
                });
                console.log('Security report comment updated successfully');
              } else {
                // 创建新的主报告评论
                await github.rest.issues.createComment({
                  issue_number: Number(process.env.PR_NUMBER),
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  body: reportWithIdentifier
                });
                console.log('Security report comment posted successfully to PR comments');
              }
              
              // 然后尝试在具体的代码行上添加评论
              // 读取 results 目录中的风险详情文件
              
              try {
                if (fs.existsSync(resultsDir)) {
                  const files = fs.readdirSync(resultsDir);
                  const detailFiles = files.filter(file => file.startsWith('risk_details_') && file.endsWith('.txt'));
                  
                  for (const detailFile of detailFiles) {
                    const detailPath = path.join(resultsDir, detailFile);
                    const content = fs.readFileSync(detailPath, 'utf8');
                    
                    // 解析文件内容
                    const lines = content.split('\n');
                    let filePath = '';
                    let lineNum = '';
                    let severity = '';
                    let title = '';
                    let description = '';
                    let solution = '';
                    
                    // 解析文件内容，处理多行字段
                    let inDescription = false;
                    let inSolution = false;
                    
                    for (let i = 0; i < lines.length; i++) {
                      const line = lines[i];
                      
                      if (line.startsWith('文件路径:')) {
                        filePath = line.replace('文件路径:', '').trim();
                      } else if (line.startsWith('行号:')) {
                        lineNum = line.replace('行号:', '').trim();
                      } else if (line.startsWith('严重程度:')) {
                        severity = line.replace('严重程度:', '').trim();
                      } else if (line.startsWith('中文标题:')) {
                        title = line.replace('中文标题:', '').trim();
                      } else if (line.startsWith('标题:') && !title) {
                        title = line.replace('标题:', '').trim();
                      } else if (line.startsWith('描述:')) {
                        description = '';
                        inDescription = true;
                        inSolution = false;
                      } else if (line.startsWith('解决方案:')) {
                        solution = '';
                        inDescription = false;
                        inSolution = true;
                      } else if (line.startsWith('=== 扫描统计 ===')) {
                        inDescription = false;
                        inSolution = false;
                        break;
                      } else if (inDescription) {
                        if (description !== '') {
                          description += '\n';
                        }
                        description += line;
                      } else if (inSolution) {
                        if (solution !== '') {
                          solution += '\n';
                        }
                        solution += line;
                      }
                    }
                     
                     if (filePath && lineNum && severity && title && (severity === 'high' || severity === 'critical')) {
                       try {
                         const codeReference = `\`${filePath}:${lineNum}\``;
                         const lineCommentIdentifier = `<!-- security-line-comment:${filePath}:${lineNum} -->`;
                         const lineLink = `https://github.com/${context.repo.owner}/${context.repo.repo}/blob/${context.sha}/${filePath}#L${lineNum}`;
                         const cleanedDescription = description.trim();
                         const cleanedSolution = solution.trim();
                         
                         const lineComment = [
                           lineCommentIdentifier,
                           '',
                           '## ⚠️ 安全风险检测',
                           '',
                           `**问题:** ${title}`,
                           `**严重程度:** ${severity}`,
                           `**文件位置:** ${codeReference}`,
                           `**代码链接:** [查看代码](${lineLink})`,
                           '',
                           '### 📋 描述',
                           '',
                           cleanedDescription,
                           '',
                           '### 💡 建议解决方案',
                           '',
                           cleanedSolution,
                           '',
                           '---',
                           '*此评论由代码安全检查工具自动生成*'
                         ].join('\n');
                         
                         let existingLineComment = null;
                         for (const comment of comments.data) {
                           if (comment.user.type === 'Bot' && comment.body.includes(lineCommentIdentifier)) {
                             existingLineComment = comment;
                             break;
                           }
                         }
                         
                         if (existingLineComment) {
                           await github.rest.issues.updateComment({
                             owner: context.repo.owner,
                             repo: context.repo.repo,
                             comment_id: existingLineComment.id,
                             body: lineComment
                           });
                         } else {
                           await github.rest.issues.createComment({
                             issue_number: Number(process.env.PR_NUMBER),
                             owner: context.repo.owner,
                             repo: context.repo.repo,
                             body: lineComment
                           });
                         }
                       } catch (lineError) {
                         console.warn(`Failed to post comment for ${filePath}:${lineNum}`);
                       }
                     }
                  }
                }
              } catch (resultsError) {
                console.warn('Failed to process results directory');
              }
              
              try {
                const activeRisks = new Set();
                if (fs.existsSync(resultsDir)) {
                  const files = fs.readdirSync(resultsDir);
                  const detailFiles = files.filter(file => file.startsWith('risk_details_') && file.endsWith('.txt'));
                  
                  for (const detailFile of detailFiles) {
                    const detailPath = path.join(resultsDir, detailFile);
                    const content = fs.readFileSync(detailPath, 'utf8');
                    const lines = content.split('\n');
                    let filePath = '';
                    let lineNum = '';
                    let severity = '';
                    
                    for (const line of lines) {
                      if (line.startsWith('文件路径:')) filePath = line.replace('文件路径:', '').trim();
                      else if (line.startsWith('行号:')) lineNum = line.replace('行号:', '').trim();
                      else if (line.startsWith('严重程度:')) severity = line.replace('严重程度:', '').trim();
                      else if (line.startsWith('=== 扫描统计 ===')) break;
                    }
                    
                    if (filePath && lineNum && severity && (severity === 'high' || severity === 'critical')) {
                      activeRisks.add(`${filePath}:${lineNum}`);
                    }
                  }
                }
                
                for (const comment of comments.data) {
                  if (comment.user.type === 'Bot' && comment.body.includes('<!-- security-line-comment:')) {
                    const match = comment.body.match(/<!-- security-line-comment:([^:]+:\d+) -->/);
                    if (match && !activeRisks.has(match[1])) {
                      await github.rest.issues.deleteComment({
                        owner: context.repo.owner,
                        repo: context.repo.repo,
                        comment_id: comment.id
                      });
                    }
                  }
                }
              } catch (cleanupError) {
                console.warn('Failed to cleanup outdated comments');
              }
              
              process.exit(1);
              
            } catch (error) {
              console.error('Failed to post security comments:', error);
              throw error;
            }

      - name: Upload risk log
        if: steps.validate.outputs.should_skip != 'true' && failure()
        uses: actions/upload-artifact@v4
        with:
          name: risk.json
          path: risk.json

      - name: Display high severity risks
        if: steps.validate.outputs.should_skip != 'true' && failure()
        run: ./yak ssa-risk --input ./risk.json --with-code --severity high

      - name: Display all risks
        if: steps.validate.outputs.should_skip != 'true' && failure()
        run: ./yak ssa-risk --input ./risk.json --with-code
      
      - name: Cleanup workspace
        if: always()
        run: |
          if [ -d "vendor" ]; then
            sudo chmod -R +w vendor/ 2>/dev/null || chmod -R +w vendor/ || true
            rm -rf vendor/ || true
          fi