// author: v1ll4n
// json schema 可以用来验证输入

params = str.JsonToMap(DATA)
url = str.ParamsGetOr(params, "URL", "")
assert(url != "", "empty url")

urls = str.SplitAndTrim(url, ",")
urls = str.ParseStringToUrlsWith3W(urls...)
assert(len(urls) > 0, "empty urls")

log("\n start to scan urls: \n%v", sdump(urls))

//
// MITM 桥接模式
//
log("开始启动 MITM 代理链模式")
bridgeLeft = f("http://%v:%v", "127.0.0.1", os.GetRandomAvailableTCPPort())
bridgeRight = f("http://%v:%v", "127.0.0.1", os.GetRandomAvailableTCPPort())

log("MITM 代理链 left: %v ====> right: %v", bridgeLeft, bridgeRight)

host, port, err = str.ParseStringToHostPort(bridgeLeft)
assertNil(err)

log("MITM 代理链正在启动")
err = mitm.Bridge(CTX, host, port, bridgeRight, fn(isHttps, req, rsp) {
    println(f("crawler found: %s", req.URL.String()))
    e = db.SaveHTTPRequestAndResponse(isHttps, req, rsp)
    if e != nil {
        log(err.Error())
    }
})
assertNil(err)
log("MITM 代理链启动成功")


swg = sync.NewSizedWaitGroup(1)
swg.Add()

//
// WEBHOOK 接受 XRAY 结果
//
radExited = false
log("正在启动 Webhook 服务器")

haveStatistic = false
haveStatisticTime = now()
hook = NewWebHook(os.GetRandomAvailableTCPPort(), fn(data) {
    mapRaw, err = str.JsonRawByteToMap(data)
    if err != nil {
        return
    }

    type = f("%v", mapRaw.type)
    if type == "web_vuln" {
        log("发现一个漏洞【%v】", type)
        err = db.SaveVulnFromXrayRawMap(mapRaw, TASK_ID, RUNTIME_ID)
        if err != nil {
            log("漏洞存储失败：%v, DATA: \n%v\n", err, sdump(mapRaw))
        }
    } elif type == "web_statistic"  {
        haveStatistic = true
        haveStatisticTime = now()

        /*
        (map[string]interface {}) (len=7) {
         (string) (len=21) "average_response_time": (float64) 1.1782945,
         (string) (len=14) "num_found_urls": (float64) 1,
         (string) (len=16) "num_scanned_urls": (float64) 0,
         (string) (len=22) "num_sent_http_requests": (float64) 654,
         (string) (len=26) "ratio_failed_http_requests": (float64) 0,
         (string) (len=14) "ratio_progress": (float64) 0,
         (string) (len=4) "type": (string) (len=13) "web_statistic"
        }
        */


        log("found %v msg: progress: %v/%v  avg_response_ms: %.2f   sent_requests: %v",
            type, mapRaw.num_scanned_urls, mapRaw.num_found_urls,
            mapRaw.average_response_time, mapRaw,num_sent_http_requests,
        )

        if radExited {
            if mapRaw.num_found_urls <= mapRaw.num_scanned_urls {
                swg.Done()
            }
        }
    }
})
addr = hook.Addr()
hook.Start()
sleep(1)

//
// 初始化 XRAY 和 RAD 的进程
//
log("正在初始化 XRAY 进程")
host, port, err = str.ParseStringToHostPort(bridgeRight)
assertNil(err)
xrayMitm = str.HostPort(host, port)
xray, err = GetXraySubProcess(
    CTX,
    "webscan",
    "--listen", xrayMitm,
    "--webhook-output", addr,
)
assertNil(err)

stdout, err = xray.StdoutPipe()
assertNil(err)
err = xray.Start()
assertNil(err)

log("启动 XRAY，等待完全启动")
io.ReadEvery1s(CTX, stdout, fn(raw){
    data = string(raw)
    if str.Contains(data, f("starting mitm server at %v", xrayMitm)) {
        return false
    }
    return true
})
log("XRAY 已经启动完全")

// radSwg = sync.NewSizedWaitGroup(1)

for _, url = range urls {
    log("正在初始化 RAD 并启动，开始进行浏览器爬虫")
    rad, err = GetRadSubProcess(
        CTX,
        "--target", url,
        "--http-proxy", bridgeLeft,
    )
    assertNil(err)
    _, _ = rad.CombinedOutput()
}

radExited = true

log("浏览器爬虫已经结束")

if !haveStatistic {
    return
}

go fn{
    swg.Wait()
    panic("finished")
}

Tick1s(fn(){
    if now().Sub(haveStatisticTime).Seconds() > 30 {
        panic("finished")
    }
    return true
})

