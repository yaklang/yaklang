// author: v1ll4n
// json schema 用来验证输入


/*
{
    "监控主机": "13.75.75.185/24",
    "监控端口": "80,443,8080",
    "按负责人/监管机构监控": "测试",
    "通知前探活": "false",
    "钉钉通知": "true",
    "钉钉通知配置名称": "default",
}
*/

/*
    这个脚本定期检查端口黑名单

    1. 如果有黑名单内，则每次检查都会报警
*/
params = str.JsonToMap(DATA)
if isNil(params) {
    die("参数无法解析")
}

hosts = str.ParamsGetOr(params, "监控主机", "")
ports = str.ParamsGetOr(params, "监控端口", "22,80,443")
supervisor = str.ParamsGetOr(params, "按负责人/监管机构监控", "")

detectAliveBeforeNotify = parseBool(str.ParamsGetOr(params, "通知前探活", "true"))
dingNotify = parseBool(str.ParamsGetOr(params, "钉钉通知", "true"))
dingNotifyConfigName = str.ParamsGetOr(params, "钉钉通知配置名称", "default")

dump(params)

if hosts == "" && supervisor == "" {
    die("监控主机和负责人监管机构监控不能同时为空")
}

if ports == "" {
    die("想要监控的端口不能为空")
}

portModels = []

if hosts != "" {
    portsChan = db.QueryPortsByNetwork(CTX, hosts, ports)
    for port = range portsChan {
        if port.IsTCPOpen() {
            portModels = append(portModels, port)
        }
    }
}

if supervisor != "" {
    records, _ = db.QuerySupervisionRecordsBySupervisor(CTX, supervisor)
    for _, record = range records {
        for port = range db.QueryPortsByNetwork(CTX, str.Join(record.GetHosts(), ","), ports) {
            if port.IsTCPOpen() {
                portModels = append(portModels, port)
            }
        }
    }
}

if len(portModels) <= 0 {
    die("【已知数据库】没有发现规则中的违规开放端口")
}

filtered = {}
swg = sync.NewSizedWaitGroup(5)
mux = sync.NewMutex()
for _, port = range portModels {
    swg.Add()
    go fn{
        defer swg.Done()

        mux.Lock()
        if filtered[port.String()] == undefined || filtered[port.String()] == nil {
            mux.Unlock()


            if !detectAliveBeforeNotify || os.IsRemoteTCPPortOpen(port.Host, port.Port) {
                if detectAliveBeforeNotify {
                    log("正在检测 %v 是否开放", str.HostPort(port.Host, port.Port))
                }
                port.UpdatedAt = now()
                mux.Lock()
                filtered[port.String()] = port
                mux.Unlock()
            }
        }else{
            mux.Unlock()
        }
    }
}
swg.Wait()

if len(filtered) <= 0 {
    die("没有发现规则中的违规开放端口")
}

/*
   filtered 中是违规端口
*/

stats = db.NewPortStats()
for _, port = range filtered {
    stats.Feed(port)
}


cClassMarkdownTable = ""
total = 0
for network, count = range stats.CClassNetCount {
    total += count
    cClassMarkdownTable += f("|%v|%v|\n", network, count)
}

knownServices = `|涉及到的服务/指纹|端口开放数量|
|----|----|
`
for service, count = range stats.ServiceCount {
    knownServices += f("|%v|%v|\n", service, count)
}

shortMessage = f(`# 违规开放端口检测报告

## 统计数据

探测到非法开放端口总量: %v

|涉及C段|开放端口数|
|---|---|
%v

%v

`, total, cClassMarkdownTable, knownServices)

longTable = `|违规端口详细信息|最近更新时间|
|----|----|
`
for data, port = range filtered {
    longTable += f("|%v|%v|\n", data, TimestampFormat(port.UpdatedAt.Unix()))
}

longMessage = shortMessage + f(`## 违规开放端口列表详细数据

%v`, longTable)

log(longMessage)

date, err = time.GetCurrentDate()
assertNil(err)

dateRaw = date.Format("2006-01-02")
reportName = f("违规开放端口检查报告[%v]", dateRaw)
if dingNotify {
    ding, err = notify.GetDingRobotByName(dingNotifyConfigName)
    if err == nil {
        ding.SendMarkdown(reportName, shortMessage, make([]string), false)
    }
}

report = graph.NewTimelineReport(reportName)
report.AddMarkdownBlock(longMessage)
item = graph.NewTimelinePointItemNow(reportName, report.ToTimelineItemData())
item.FromSystem = "威胁情报"
err = CreateOrUpdateTimelineItem(item)
assertNil(err)